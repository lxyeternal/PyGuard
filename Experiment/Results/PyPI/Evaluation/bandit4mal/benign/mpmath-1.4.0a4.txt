Run started:2025-05-25 12:34:33.923843

Test results:
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/demo/manydigits.py:27
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
26	
27	print("""
28	This script prints answers to a selection of the "Many Digits"

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/docs/conf.py:45
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
44	intersphinx_mapping = {
45	    'python': ('https://docs.python.org/3/', None),
46	    'sympy': ('https://docs.sympy.org/latest/', None),

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/docs/conf.py:46
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
45	    'python': ('https://docs.python.org/3/', None),
46	    'sympy': ('https://docs.sympy.org/latest/', None),
47	}

--------------------------------------------------
>> Issue: [B800:exec_used] exec
   Severity: Medium   Confidence: High
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/docs/plots/buildplots.py:22
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b800_exec_used.html
21	    code = "\n".join(code)
22	    exec(code)

--------------------------------------------------
>> Issue: [B842:runsource] code.InteractiveInterpreter.runsource
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/__main__.py:137
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b842_runsource.html
136	
137	                return super().runsource(source, filename=filename, symbol=symbol)
138	

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/function_docs.py:266
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
265	
266	glaisher = r"""
267	Glaisher's constant `A`, also known as the Glaisher-Kinkelin
268	constant, is a number approximately equal to 1.282427129 that
269	sometimes appears in formulas related to gamma and zeta functions.
270	It is also related to the Barnes G-function (see :func:`~mpmath.barnesg`).
271	
272	The constant is defined  as `A = \exp(1/12-\zeta'(-1))` where
273	`\zeta'(s)` denotes the derivative of the Riemann zeta function
274	(see :func:`~mpmath.zeta`).
275	
276	Mpmath can evaluate Glaisher's constant to arbitrary precision:
277	
278	    >>> from mpmath import mp, glaisher, quad, log, gamma, pi, mpf, zeta
279	    >>> mp.dps = 50; mp.pretty = True
280	    >>> +glaisher
281	    1.282427129100622636875342568869791727767688927325
282	
283	We can verify that the value computed by :data:`glaisher` is
284	correct using mpmath's facilities for numerical
285	differentiation and arbitrary evaluation of the zeta function:
286	
287	    >>> exp(mpf(1)/12 - diff(zeta, -1))
288	    1.282427129100622636875342568869791727767688927325
289	
290	Here is an example of an integral that can be evaluated in
291	terms of Glaisher's constant:
292	
293	    >>> mp.dps = 15
294	    >>> quad(lambda x: log(gamma(x)), [1, 1.5])
295	    -0.0428537406502909
296	    >>> -0.5 - 7*log(2)/24 + log(pi)/4 + 3*log(glaisher)/2
297	    -0.042853740650291
298	
299	Mpmath computes Glaisher's constant by applying Euler-Maclaurin
300	summation to a slowly convergent series. The implementation is
301	reasonably efficient up to about 10,000 digits. See the source
302	code for additional details.
303	
304	References:
305	http://mathworld.wolfram.com/Glaisher-KinkelinConstant.html
306	"""
307	
308	apery = r"""

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/function_docs.py:344
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
343	
344	mertens = r"""
345	Represents the Mertens or Meissel-Mertens constant, which is the
346	prime number analog of Euler's constant:
347	
348	.. math ::
349	
350	    B_1 = \lim_{N\to\infty}
351	        \left(\sum_{p_k \le N} \frac{1}{p_k} - \log \log N \right)
352	
353	Here `p_k` denotes the `k`-th prime number. Other names for this
354	constant include the Hadamard-de la Vallee-Poussin constant or
355	the prime reciprocal constant.
356	
357	The following gives the Mertens constant to 50 digits::
358	
359	    >>> from mpmath import mp, mertens
360	    >>> mp.dps = 50; mp.pretty = True
361	    >>> +mertens
362	    0.2614972128476427837554268386086958590515666482612
363	
364	References:
365	http://mathworld.wolfram.com/MertensConstant.html
366	"""
367	
368	twinprime = r"""

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/function_docs.py:368
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
367	
368	twinprime = r"""
369	Represents the twin prime constant, which is the factor `C_2`
370	featuring in the Hardy-Littlewood conjecture for the growth of the
371	twin prime counting function,
372	
373	.. math ::
374	
375	    \pi_2(n) \sim 2 C_2 \frac{n}{\log^2 n}.
376	
377	It is given by the product over primes
378	
379	.. math ::
380	
381	    C_2 = \prod_{p\ge3} \frac{p(p-2)}{(p-1)^2} \approx 0.66016
382	
383	Computing `C_2` to 50 digits::
384	
385	    >>> from mpmath import mp, twinprime
386	    >>> mp.dps = 50; mp.pretty = True
387	    >>> +twinprime
388	    0.66016181584686957392781211001455577843262336028473
389	
390	References:
391	http://mathworld.wolfram.com/TwinPrimesConstant.html
392	"""
393	
394	ln = r"""

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/function_docs.py:1724
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
1723	
1724	fibonacci = r"""
1725	``fibonacci(n)`` computes the `n`-th Fibonacci number, `F(n)`. The
1726	Fibonacci numbers are defined by the recurrence `F(n) = F(n-1) + F(n-2)`
1727	with the initial values `F(0) = 0`, `F(1) = 1`. :func:`~mpmath.fibonacci`
1728	extends this definition to arbitrary real and complex arguments
1729	using the formula
1730	
1731	.. math ::
1732	
1733	  F(z) = \frac{\phi^z - \cos(\pi z) \phi^{-z}}{\sqrt 5}
1734	
1735	where `\phi` is the golden ratio. :func:`~mpmath.fibonacci` also uses this
1736	continuous formula to compute `F(n)` for extremely large `n`, where
1737	calculating the exact integer would be wasteful.
1738	
1739	For convenience, ``fib()`` is available as an alias for
1740	:func:`~mpmath.fibonacci`.
1741	
1742	**Basic examples**
1743	
1744	Some small Fibonacci numbers are::
1745	
1746	    >>> from mpmath import mp, fibonacci, fib, pi, findroot, nsum, sqrt, inf
1747	    >>> mp.pretty = True
1748	    >>> for i in range(10):
1749	    ...     print(fibonacci(i))
1750	    ...
1751	    0.0
1752	    1.0
1753	    1.0
1754	    2.0
1755	    3.0
1756	    5.0
1757	    8.0
1758	    13.0
1759	    21.0
1760	    34.0
1761	    >>> fibonacci(50)
1762	    12586269025.0
1763	
1764	The recurrence for `F(n)` extends backwards to negative `n`::
1765	
1766	    >>> for i in range(10):
1767	    ...     print(fibonacci(-i))
1768	    ...
1769	    0.0
1770	    1.0
1771	    -1.0
1772	    2.0
1773	    -3.0
1774	    5.0
1775	    -8.0
1776	    13.0
1777	    -21.0
1778	    34.0
1779	
1780	Large Fibonacci numbers will be computed approximately unless
1781	the precision is set high enough::
1782	
1783	    >>> fib(200)
1784	    2.8057117299251e+41
1785	    >>> mp.dps = 45
1786	    >>> fib(200)
1787	    280571172992510140037611932413038677189525.0
1788	
1789	:func:`~mpmath.fibonacci` can compute approximate Fibonacci numbers
1790	of stupendous size::
1791	
1792	    >>> mp.dps = 15
1793	    >>> fibonacci(10**25)
1794	    3.49052338550226e+2089876402499787337692720
1795	
1796	**Real and complex arguments**
1797	
1798	The extended Fibonacci function is an analytic function. The
1799	property `F(z) = F(z-1) + F(z-2)` holds for arbitrary `z`::
1800	
1801	    >>> mp.dps = 15
1802	    >>> fib(pi)
1803	    2.1170270579161
1804	    >>> fib(pi-1) + fib(pi-2)
1805	    2.1170270579161
1806	    >>> fib(3+4j)
1807	    (-5248.51130728372 - 14195.962288353j)
1808	    >>> fib(2+4j) + fib(1+4j)
1809	    (-5248.51130728372 - 14195.962288353j)
1810	
1811	The Fibonacci function has infinitely many roots on the
1812	negative half-real axis. The first root is at 0, the second is
1813	close to -0.18, and then there are infinitely many roots that
1814	asymptotically approach `-n+1/2`::
1815	
1816	    >>> findroot(fib, -0.2)
1817	    -0.183802359692956
1818	    >>> findroot(fib, -2)
1819	    -1.57077646820395
1820	    >>> findroot(fib, -17)
1821	    -16.4999999596115
1822	    >>> findroot(fib, -24)
1823	    -23.5000000000479
1824	
1825	**Mathematical relationships**
1826	
1827	For large `n`, `F(n+1)/F(n)` approaches the golden ratio::
1828	
1829	    >>> mp.dps = 50
1830	    >>> fibonacci(101)/fibonacci(100)
1831	    1.6180339887498948482045868343656381177203127439638
1832	    >>> +phi
1833	    1.6180339887498948482045868343656381177203091798058
1834	
1835	The sum of reciprocal Fibonacci numbers converges to an irrational
1836	number for which no closed form expression is known::
1837	
1838	    >>> mp.dps = 15
1839	    >>> nsum(lambda n: 1/fib(n), [1, inf])
1840	    3.35988566624318
1841	
1842	Amazingly, however, the sum of odd-index reciprocal Fibonacci
1843	numbers can be expressed in terms of a Jacobi theta function::
1844	
1845	    >>> nsum(lambda n: 1/fib(2*n+1), [0, inf])
1846	    1.82451515740692
1847	    >>> sqrt(5)*jtheta(2,0,(3-sqrt(5))/2)**2/4
1848	    1.82451515740692
1849	
1850	Some related sums can be done in closed form::
1851	
1852	    >>> nsum(lambda k: 1/(1+fib(2*k+1)), [0, inf])
1853	    1.11803398874989
1854	    >>> phi - 0.5
1855	    1.11803398874989
1856	    >>> f = lambda k:(-1)**(k+1) / sum(fib(n)**2 for n in range(1,int(k+1)))
1857	    >>> nsum(f, [1, inf])
1858	    0.618033988749895
1859	    >>> phi-1
1860	    0.618033988749895
1861	
1862	**References**
1863	
1864	1. http://mathworld.wolfram.com/FibonacciNumber.html
1865	"""
1866	
1867	altzeta = r"""

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/function_docs.py:1867
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
1866	
1867	altzeta = r"""
1868	Gives the Dirichlet eta function, `\eta(s)`, also known as the
1869	alternating zeta function. This function is defined in analogy
1870	with the Riemann zeta function as providing the sum of the
1871	alternating series
1872	
1873	.. math ::
1874	
1875	    \eta(s) = \sum_{k=1}^{\infty} \frac{(-1)^{k-1}}{k^s}
1876	        = 1-\frac{1}{2^s}+\frac{1}{3^s}-\frac{1}{4^s}+\ldots
1877	
1878	The eta function, unlike the Riemann zeta function, is an entire
1879	function, having a finite value for all complex `s`. The special case
1880	`\eta(1) = \log(2)` gives the value of the alternating harmonic series.
1881	
1882	The alternating zeta function may expressed using the Riemann zeta function
1883	as `\eta(s) = (1 - 2^{1-s}) \zeta(s)`. It can also be expressed
1884	in terms of the Hurwitz zeta function, for example using
1885	:func:`~mpmath.dirichlet` (see documentation for that function).
1886	
1887	**Examples**
1888	
1889	Some special values are::
1890	
1891	    >>> from mpmath import mp, altzeta, mpf, pi, inf
1892	    >>> mp.pretty = True
1893	    >>> altzeta(1)
1894	    0.693147180559945
1895	    >>> altzeta(0)
1896	    0.5
1897	    >>> altzeta(-1)
1898	    0.25
1899	    >>> altzeta(-2)
1900	    0.0
1901	
1902	An example of a sum that can be computed more accurately and
1903	efficiently via :func:`~mpmath.altzeta` than via numerical summation::
1904	
1905	    >>> sum(-(-1)**n / mpf(n)**2.5 for n in range(1, 100))
1906	    0.867204951503984
1907	    >>> altzeta(2.5)
1908	    0.867199889012184
1909	
1910	At positive even integers, the Dirichlet eta function
1911	evaluates to a rational multiple of a power of `\pi`::
1912	
1913	    >>> altzeta(2)
1914	    0.822467033424113
1915	    >>> pi**2/12
1916	    0.822467033424113
1917	
1918	Like the Riemann zeta function, `\eta(s)`, approaches 1
1919	as `s` approaches positive infinity, although it does
1920	so from below rather than from above::
1921	
1922	    >>> altzeta(30)
1923	    0.999999999068682
1924	    >>> altzeta(inf)
1925	    1.0
1926	    >>> mp.pretty = False
1927	    >>> altzeta(1000, rounding='d')
1928	    mpf('0.99999999999999989')
1929	    >>> altzeta(1000, rounding='u')
1930	    mpf('1.0')
1931	
1932	**References**
1933	
1934	1. http://mathworld.wolfram.com/DirichletEtaFunction.html
1935	
1936	2. http://en.wikipedia.org/wiki/Dirichlet_eta_function
1937	"""
1938	
1939	factorial = r"""

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/function_docs.py:2224
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
2223	
2224	bernoulli = r"""
2225	Computes the nth Bernoulli number, `B_n`, for any integer `n \ge 0`.
2226	
2227	The Bernoulli numbers are rational numbers, but this function
2228	returns a floating-point approximation. To obtain an exact
2229	fraction, use :func:`~mpmath.bernfrac` instead.
2230	
2231	Optional ``plus`` flag (default: False) control the sign choice of
2232	the `B_1` value (default: `-0.5`).
2233	
2234	**Examples**
2235	
2236	Numerical values of the first few Bernoulli numbers::
2237	
2238	    >>> from mpmath import mp, bernoulli, pi, fac, zeta
2239	    >>> mp.pretty = True
2240	    >>> for n in range(15):
2241	    ...     print("%s %s" % (n, bernoulli(n)))
2242	    ...
2243	    0 1.0
2244	    1 -0.5
2245	    2 0.166666666666667
2246	    3 0.0
2247	    4 -0.0333333333333333
2248	    5 0.0
2249	    6 0.0238095238095238
2250	    7 0.0
2251	    8 -0.0333333333333333
2252	    9 0.0
2253	    10 0.0757575757575758
2254	    11 0.0
2255	    12 -0.253113553113553
2256	    13 0.0
2257	    14 1.16666666666667
2258	
2259	Bernoulli numbers can be approximated with arbitrary precision::
2260	
2261	    >>> mp.dps = 50
2262	    >>> bernoulli(100)
2263	    -2.8382249570693706959264156336481764738284680928013e+78
2264	
2265	Arbitrarily large `n` are supported::
2266	
2267	    >>> mp.dps = 15
2268	    >>> bernoulli(10**20 + 2)
2269	    3.09136296657021e+1876752564973863312327
2270	
2271	The Bernoulli numbers are related to the Riemann zeta function
2272	at integer arguments::
2273	
2274	    >>> -bernoulli(8) * (2*pi)**8 / (2*fac(8))
2275	    1.00407735619794
2276	    >>> zeta(8)
2277	    1.00407735619794
2278	
2279	**Algorithm**
2280	
2281	For small `n` (`n < 3000`) :func:`~mpmath.bernoulli` uses a recurrence
2282	formula due to Ramanujan. All results in this range are cached,
2283	so sequential computation of small Bernoulli numbers is
2284	guaranteed to be fast.
2285	
2286	For larger `n`, `B_n` is evaluated in terms of the Riemann zeta
2287	function.
2288	
2289	**References**
2290	
2291	1. https://en.wikipedia.org/wiki/Bernoulli_number
2292	
2293	"""
2294	
2295	stieltjes = r"""

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/function_docs.py:2295
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
2294	
2295	stieltjes = r"""
2296	For a nonnegative integer `n`, ``stieltjes(n)`` computes the
2297	`n`-th Stieltjes constant `\gamma_n`, defined as the
2298	`n`-th coefficient in the Laurent series expansion of the
2299	Riemann zeta function around the pole at `s = 1`. That is,
2300	we have:
2301	
2302	.. math ::
2303	
2304	  \zeta(s) = \frac{1}{s-1} \sum_{n=0}^{\infty}
2305	      \frac{(-1)^n}{n!} \gamma_n (s-1)^n
2306	
2307	More generally, ``stieltjes(n, a)`` gives the corresponding
2308	coefficient `\gamma_n(a)` for the Hurwitz zeta function
2309	`\zeta(s,a)` (with `\gamma_n = \gamma_n(1)`).
2310	
2311	**Examples**
2312	
2313	The zeroth Stieltjes constant is just Euler's constant `\gamma`::
2314	
2315	    >>> from mpmath import mp, stieltjes, extradps, zeta, diff
2316	    >>> mp.pretty = True
2317	    >>> stieltjes(0)
2318	    0.577215664901533
2319	
2320	Some more values are::
2321	
2322	    >>> stieltjes(1)
2323	    -0.0728158454836767
2324	    >>> stieltjes(10)
2325	    0.000205332814909065
2326	    >>> stieltjes(30)
2327	    0.00355772885557316
2328	    >>> stieltjes(1000)
2329	    -1.57095384420474e+486
2330	    >>> stieltjes(2000)
2331	    2.680424678918e+1109
2332	    >>> stieltjes(1, 2.5)
2333	    -0.23747539175716
2334	
2335	An alternative way to compute `\gamma_1`::
2336	
2337	    >>> diff(extradps(15)(lambda x: 1/(x-1) - zeta(x)), 1)
2338	    -0.0728158454836767
2339	
2340	:func:`~mpmath.stieltjes` supports arbitrary precision evaluation::
2341	
2342	    >>> mp.dps = 50
2343	    >>> stieltjes(2)
2344	    -0.0096903631928723184845303860352125293590658061013408
2345	
2346	**Algorithm**
2347	
2348	:func:`~mpmath.stieltjes` numerically evaluates the integral in
2349	the following representation due to Ainsworth, Howell and
2350	Coffey [1], [2]:
2351	
2352	.. math ::
2353	
2354	  \gamma_n(a) = \frac{\log^n a}{2a} - \frac{\log^{n+1}(a)}{n+1} +
2355	      \frac{2}{a} \Re \int_0^{\infty}
2356	      \frac{(x/a-i)\log^n(a-ix)}{(1+x^2/a^2)(e^{2\pi x}-1)} dx.
2357	
2358	For some reference values with `a = 1`, see e.g. [4].
2359	
2360	**References**
2361	
2362	1. O. R. Ainsworth & L. W. Howell, "An integral representation of
2363	   the generalized Euler-Mascheroni constants", NASA Technical
2364	   Paper 2456 (1985),
2365	   http://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19850014994_1985014994.pdf
2366	
2367	2. M. W. Coffey, "The Stieltjes constants, their relation to the
2368	   `\eta_j` coefficients, and representation of the Hurwitz
2369	   zeta function", 	arXiv:0706.0343v1 http://arxiv.org/abs/0706.0343
2370	
2371	3. http://mathworld.wolfram.com/StieltjesConstants.html
2372	
2373	4. http://pi.lacim.uqam.ca/piDATA/stieltjesgamma.txt
2374	
2375	"""
2376	
2377	gammaprod = r"""

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/function_docs.py:2689
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
2688	
2689	fac2 = r"""
2690	Computes the double factorial `x!!`, defined for integers
2691	`x > 0` by
2692	
2693	.. math ::
2694	
2695	    x!! = \begin{cases}
2696	        1 \cdot 3 \cdots (x-2) \cdot x & x \;\mathrm{odd} \\
2697	        2 \cdot 4 \cdots (x-2) \cdot x & x \;\mathrm{even}
2698	    \end{cases}
2699	
2700	and more generally by [1]
2701	
2702	.. math ::
2703	
2704	    x!! = 2^{x/2} \left(\frac{\pi}{2}\right)^{(\cos(\pi x)-1)/4}
2705	          \Gamma\left(\frac{x}{2}+1\right).
2706	
2707	**Examples**
2708	
2709	The integer sequence of double factorials begins::
2710	
2711	    >>> from mpmath import (mp, fac2, nprint, mpf, exp, pi, nsum, sqrt, e,
2712	    ...                     gamma, inf, erf, fac)
2713	    >>> mp.pretty = True
2714	    >>> nprint([fac2(n) for n in range(10)])
2715	    [1.0, 1.0, 2.0, 3.0, 8.0, 15.0, 48.0, 105.0, 384.0, 945.0]
2716	
2717	For large `x`, double factorials follow a Stirling-like asymptotic
2718	approximation::
2719	
2720	    >>> x = mpf(10000)
2721	    >>> fac2(x)
2722	    5.97272691416282e+17830
2723	    >>> sqrt(pi)*x**((x+1)/2)*exp(-x/2)
2724	    5.97262736954392e+17830
2725	
2726	The recurrence formula `x!! = x (x-2)!!` can be reversed to
2727	define the double factorial of negative odd integers (but
2728	not negative even integers)::
2729	
2730	    >>> fac2(-1), fac2(-3), fac2(-5), fac2(-7)
2731	    (1.0, -1.0, 0.333333333333333, -0.0666666666666667)
2732	    >>> fac2(-2)
2733	    Traceback (most recent call last):
2734	      ...
2735	    ValueError: gamma function pole
2736	
2737	With the exception of the poles at negative even integers,
2738	:func:`~mpmath.fac2` supports evaluation for arbitrary complex arguments.
2739	The recurrence formula is valid generally::
2740	
2741	    >>> fac2(pi+2j)
2742	    (-1.3697207890154e-12 + 3.93665300979176e-12j)
2743	    >>> (pi+2j)*fac2(pi-2+2j)
2744	    (-1.3697207890154e-12 + 3.93665300979176e-12j)
2745	
2746	Double factorials should not be confused with nested factorials,
2747	which are immensely larger::
2748	
2749	    >>> fac(fac(20))
2750	    5.13805976125208e+43675043585825292774
2751	    >>> fac2(20)
2752	    3715891200.0
2753	
2754	Double factorials appear, among other things, in series expansions
2755	of Gaussian functions and the error function. Infinite series
2756	include::
2757	
2758	    >>> nsum(lambda k: 1/fac2(k), [0, inf])
2759	    3.05940740534258
2760	    >>> sqrt(e)*(1+sqrt(pi/2)*erf(sqrt(2)/2))
2761	    3.05940740534258
2762	    >>> nsum(lambda k: 2**k/fac2(2*k-1), [1, inf])
2763	    4.06015693855741
2764	    >>> e * erf(1) * sqrt(pi)
2765	    4.06015693855741
2766	
2767	A beautiful Ramanujan sum::
2768	
2769	    >>> nsum(lambda k: (-1)**k*(fac2(2*k-1)/fac2(2*k))**3, [0,inf])
2770	    0.90917279454693
2771	    >>> (gamma('9/8')/gamma('5/4')/gamma('7/8'))**2
2772	    0.90917279454693
2773	
2774	**References**
2775	
2776	1. http://functions.wolfram.com/GammaBetaErf/Factorial2/27/01/0002/
2777	
2778	2. http://mathworld.wolfram.com/DoubleFactorial.html
2779	
2780	"""
2781	
2782	hyper = r"""

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/function_docs.py:3375
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
3374	
3375	hyperu = r"""
3376	Gives the Tricomi confluent hypergeometric function `U`, also known as
3377	the Kummer or confluent hypergeometric function of the second kind. This
3378	function gives a second linearly independent solution to the confluent
3379	hypergeometric differential equation (the first is provided by `\,_1F_1`  --
3380	see :func:`~mpmath.hyp1f1`).
3381	
3382	**Examples**
3383	
3384	Evaluation for arbitrary complex arguments::
3385	
3386	    >>> from mpmath import mp, hyperu, chop, diff, quad, gamma, exp, inf
3387	    >>> mp.dps = 25; mp.pretty = True
3388	    >>> hyperu(2,3,4)
3389	    0.0625
3390	    >>> hyperu(0.25, 5, 1000)
3391	    0.1779949416140579573763523
3392	    >>> hyperu(0.25, 5, -1000)
3393	    (0.1256256609322773150118907 - 0.1256256609322773150118907j)
3394	
3395	The `U` function may be singular at `z = 0`::
3396	
3397	    >>> hyperu(1.5, 2, 0)
3398	    inf
3399	    >>> hyperu(1.5, -2, 0)
3400	    0.1719434921288400112603671
3401	
3402	Verifying the differential equation::
3403	
3404	    >>> a, b = 1.5, 2
3405	    >>> f = lambda z: hyperu(a,b,z)
3406	    >>> for z in [-10, 3, 3+4j]:
3407	    ...     chop(z*diff(f,z,2) + (b-z)*diff(f,z) - a*f(z))
3408	    ...
3409	    0.0
3410	    0.0
3411	    0.0
3412	
3413	An integral representation::
3414	
3415	    >>> a,b,z = 2, 3.5, 4.25
3416	    >>> hyperu(a,b,z)
3417	    0.06674960718150520648014567
3418	    >>> quad(lambda t: exp(-z*t)*t**(a-1)*(1+t)**(b-a-1),[0,inf]) / gamma(a)
3419	    0.06674960718150520648014567
3420	
3421	
3422	[1] http://people.math.sfu.ca/~cbm/aands/page_504.htm
3423	"""
3424	
3425	hyp2f0 = r"""

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/function_docs.py:3425
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
3424	
3425	hyp2f0 = r"""
3426	Gives the hypergeometric function `\,_2F_0`, defined formally by the
3427	series
3428	
3429	.. math ::
3430	
3431	    \,_2F_0(a,b;;z) = \sum_{n=0}^{\infty} (a)_n (b)_n \frac{z^n}{n!}.
3432	
3433	This series usually does not converge. For small enough `z`, it can be viewed
3434	as an asymptotic series that may be summed directly with an appropriate
3435	truncation. When this is not the case, :func:`~mpmath.hyp2f0` gives a regularized sum,
3436	or equivalently, it uses a representation in terms of the
3437	hypergeometric U function [1]. The series also converges when either `a` or `b`
3438	is a nonpositive integer, as it then terminates into a polynomial
3439	after `-a` or `-b` terms.
3440	
3441	**Examples**
3442	
3443	Evaluation is supported for arbitrary complex arguments::
3444	
3445	    >>> from mpmath import mp, hyp2f0, j, nprint, identify, taylor
3446	    >>> mp.dps = 25; mp.pretty = True
3447	    >>> hyp2f0((2,3), 1.25, -100)
3448	    0.07095851870980052763312791
3449	    >>> hyp2f0((2,3), 1.25, 100)
3450	    (-0.03254379032170590665041131 + 0.07269254613282301012735797j)
3451	    >>> hyp2f0(-0.75, 1-j, 4j)
3452	    (-0.3579987031082732264862155 - 3.052951783922142735255881j)
3453	
3454	Even with real arguments, the regularized value of 2F0 is often complex-valued,
3455	but the imaginary part decreases exponentially as `z \to 0`. In the following
3456	example, the first call uses complex evaluation while the second has a small
3457	enough `z` to evaluate using the direct series and thus the returned value
3458	is strictly real (this should be taken to indicate that the imaginary
3459	part is less than ``eps``)::
3460	
3461	    >>> mp.dps = 15
3462	    >>> hyp2f0(1.5, 0.5, 0.05)
3463	    (1.04166637647907 + 8.34584913683906e-8j)
3464	    >>> hyp2f0(1.5, 0.5, 0.0005)
3465	    1.00037535207621
3466	
3467	The imaginary part can be retrieved by increasing the working precision::
3468	
3469	    >>> mp.dps = 80
3470	    >>> nprint(hyp2f0(1.5, 0.5, 0.009).imag)
3471	    1.23828e-46
3472	
3473	In the polynomial case (the series terminating), 2F0 can evaluate exactly::
3474	
3475	    >>> mp.dps = 15
3476	    >>> hyp2f0(-6,-6,2)
3477	    291793.0
3478	    >>> identify(hyp2f0(-2,1,0.25))
3479	    '(5/8)'
3480	
3481	The coefficients of the polynomials can be recovered using Taylor expansion::
3482	
3483	    >>> nprint(taylor(lambda x: hyp2f0(-3,0.5,x), 0, 10))
3484	    [1.0, -1.5, 2.25, -1.875, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
3485	    >>> nprint(taylor(lambda x: hyp2f0(-4,0.5,x), 0, 10))
3486	    [1.0, -2.0, 4.5, -7.5, 6.5625, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
3487	
3488	
3489	[1] http://people.math.sfu.ca/~cbm/aands/page_504.htm
3490	"""
3491	
3492	
3493	gammainc = r"""

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/function_docs.py:3997
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
3996	
3997	ei = r"""
3998	Computes the exponential integral or Ei-function, `\mathrm{Ei}(x)`.
3999	The exponential integral is defined as
4000	
4001	.. math ::
4002	
4003	  \mathrm{Ei}(x) = \int_{-\infty\,}^x \frac{e^t}{t} \, dt.
4004	
4005	When the integration range includes `t = 0`, the exponential
4006	integral is interpreted as providing the Cauchy principal value.
4007	
4008	For real `x`, the Ei-function behaves roughly like
4009	`\mathrm{Ei}(x) \approx \exp(x) + \log(|x|)`.
4010	
4011	The Ei-function is related to the more general family of exponential
4012	integral functions denoted by `E_n`, which are available as :func:`~mpmath.expint`.
4013	
4014	**Basic examples**
4015	
4016	Some basic values and limits are::
4017	
4018	    >>> from mpmath import (mp, ei, inf, quad, exp, chop, si, pi, j, chi,
4019	    ...                     shi, hyper, euler, ln, ci)
4020	    >>> mp.pretty = True
4021	    >>> ei(0)
4022	    -inf
4023	    >>> ei(1)
4024	    1.89511781635594
4025	    >>> ei(inf)
4026	    inf
4027	    >>> ei(-inf)
4028	    0.0
4029	
4030	For `x < 0`, the defining integral can be evaluated
4031	numerically as a reference::
4032	
4033	    >>> ei(-4)
4034	    -0.00377935240984891
4035	    >>> quad(lambda t: exp(t)/t, [-inf, -4])
4036	    -0.00377935240984891
4037	
4038	:func:`~mpmath.ei` supports complex arguments and arbitrary
4039	precision evaluation::
4040	
4041	    >>> mp.dps = 50
4042	    >>> ei(pi)
4043	    10.928374389331410348638445906907535171566338835056
4044	    >>> mp.dps = 25
4045	    >>> ei(3+4j)
4046	    (-4.154091651642689822535359 + 4.294418620024357476985535j)
4047	
4048	**Related functions**
4049	
4050	The exponential integral is closely related to the logarithmic
4051	integral. See :func:`~mpmath.li` for additional information.
4052	
4053	The exponential integral is related to the hyperbolic
4054	and trigonometric integrals (see :func:`~mpmath.chi`, :func:`~mpmath.shi`,
4055	:func:`~mpmath.ci`, :func:`~mpmath.si`) similarly to how the ordinary
4056	exponential function is related to the hyperbolic and
4057	trigonometric functions::
4058	
4059	    >>> mp.dps = 15
4060	    >>> ei(3)
4061	    9.93383257062542
4062	    >>> chi(3) + shi(3)
4063	    9.93383257062542
4064	    >>> chop(ci(3j) - j*si(3j) - pi*j/2)
4065	    9.93383257062542
4066	
4067	Beware that logarithmic corrections, as in the last example
4068	above, are required to obtain the correct branch in general.
4069	For details, see [1].
4070	
4071	The exponential integral is also a special case of the
4072	hypergeometric function `\,_2F_2`::
4073	
4074	    >>> z = 0.6
4075	    >>> z*hyper([1,1],[2,2],z) + (ln(z)-ln(1/z))/2 + euler
4076	    0.769881289937359
4077	    >>> ei(z)
4078	    0.769881289937359
4079	
4080	**References**
4081	
4082	1. Relations between Ei and other functions:
4083	   http://functions.wolfram.com/GammaBetaErf/ExpIntegralEi/27/01/
4084	
4085	2. Abramowitz & Stegun, section 5:
4086	   http://people.math.sfu.ca/~cbm/aands/page_228.htm
4087	
4088	3. Asymptotic expansion for Ei:
4089	   http://mathworld.wolfram.com/En-Function.html
4090	"""
4091	
4092	li = r"""

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/function_docs.py:4092
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
4091	
4092	li = r"""
4093	Computes the logarithmic integral or li-function
4094	`\mathrm{li}(x)`, defined by
4095	
4096	.. math ::
4097	
4098	    \mathrm{li}(x) = \int_0^x \frac{1}{\log t} \, dt
4099	
4100	The logarithmic integral has a singularity at `x = 1`.
4101	
4102	Alternatively, ``li(x, offset=True)`` computes the offset
4103	logarithmic integral (used in number theory)
4104	
4105	.. math ::
4106	
4107	    \mathrm{Li}(x) = \int_2^x \frac{1}{\log t} \, dt.
4108	
4109	These two functions are related via the simple identity
4110	`\mathrm{Li}(x) = \mathrm{li}(x) - \mathrm{li}(2)`.
4111	
4112	The logarithmic integral should also not be confused with
4113	the polylogarithm (also denoted by Li), which is implemented
4114	as :func:`~mpmath.polylog`.
4115	
4116	**Examples**
4117	
4118	Some basic values and limits::
4119	
4120	    >>> from mpmath import mp, li, findroot, ei, log, quad, inf, ln
4121	    >>> mp.dps = 30; mp.pretty = True
4122	    >>> li(0)
4123	    0.0
4124	    >>> li(1)
4125	    -inf
4126	    >>> li(1)
4127	    -inf
4128	    >>> li(2)
4129	    1.04516378011749278484458888919
4130	    >>> findroot(li, 2)
4131	    1.45136923488338105028396848589
4132	    >>> li(inf)
4133	    inf
4134	    >>> li(2, offset=True)
4135	    0.0
4136	    >>> li(1, offset=True)
4137	    -inf
4138	    >>> li(0, offset=True)
4139	    -1.04516378011749278484458888919
4140	    >>> li(10, offset=True)
4141	    5.12043572466980515267839286347
4142	
4143	The logarithmic integral can be evaluated for arbitrary
4144	complex arguments::
4145	
4146	    >>> mp.dps = 20
4147	    >>> li(3+4j)
4148	    (3.1343755504645775265 + 2.6769247817778742392j)
4149	
4150	The logarithmic integral is related to the exponential integral::
4151	
4152	    >>> ei(log(3))
4153	    2.1635885946671919729
4154	    >>> li(3)
4155	    2.1635885946671919729
4156	
4157	The logarithmic integral grows like `O(x/\log(x))`::
4158	
4159	    >>> mp.dps = 15
4160	    >>> x = 10**100
4161	    >>> x/log(x)
4162	    4.34294481903252e+97
4163	    >>> li(x)
4164	    4.3619719871407e+97
4165	
4166	The prime number theorem states that the number of primes less
4167	than `x` is asymptotic to `\mathrm{Li}(x)` (equivalently
4168	`\mathrm{li}(x)`). For example, it is known that there are
4169	exactly 1,925,320,391,606,803,968,923 prime numbers less than
4170	`10^{23}` [1]. The logarithmic integral provides a very
4171	accurate estimate::
4172	
4173	    >>> li(10**23, offset=True)
4174	    1.92532039161405e+21
4175	
4176	A definite integral is::
4177	
4178	    >>> quad(li, [0, 1])
4179	    -0.693147180559945
4180	    >>> -ln(2)
4181	    -0.693147180559945
4182	
4183	**References**
4184	
4185	1. http://mathworld.wolfram.com/PrimeCountingFunction.html
4186	
4187	2. http://mathworld.wolfram.com/LogarithmicIntegral.html
4188	
4189	"""
4190	
4191	ci = r"""

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/function_docs.py:6365
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
6364	
6365	barnesg = r"""
6366	Evaluates the Barnes G-function, which generalizes the
6367	superfactorial (:func:`~mpmath.superfac`) and by extension also the
6368	hyperfactorial (:func:`~mpmath.hyperfac`) to the complex numbers
6369	in an analogous way to how the gamma function generalizes
6370	the ordinary factorial.
6371	
6372	The Barnes G-function may be defined in terms of a Weierstrass
6373	product:
6374	
6375	.. math ::
6376	
6377	    G(z+1) = (2\pi)^{z/2} e^{-[z(z+1)+\gamma z^2]/2}
6378	    \prod_{n=1}^\infty
6379	    \left[\left(1+\frac{z}{n}\right)^ne^{-z+z^2/(2n)}\right]
6380	
6381	For positive integers `n`, we have have relation to superfactorials
6382	`G(n) = \mathrm{sf}(n-2) = 0! \cdot 1! \cdots (n-2)!`.
6383	
6384	**Examples**
6385	
6386	Some elementary values and limits of the Barnes G-function::
6387	
6388	    >>> from mpmath import (mp, barnesg, sqrt, exp, log, glaisher, inf,
6389	    ...                     catalan, pi, nthroot, gamma, limit, mpf, psi, diff)
6390	    >>> mp.pretty = True
6391	    >>> barnesg(1), barnesg(2), barnesg(3)
6392	    (1.0, 1.0, 1.0)
6393	    >>> barnesg(4)
6394	    2.0
6395	    >>> barnesg(5)
6396	    12.0
6397	    >>> barnesg(6)
6398	    288.0
6399	    >>> barnesg(7)
6400	    34560.0
6401	    >>> barnesg(8)
6402	    24883200.0
6403	    >>> barnesg(inf)
6404	    inf
6405	    >>> barnesg(0), barnesg(-1), barnesg(-2)
6406	    (0.0, 0.0, 0.0)
6407	
6408	Closed-form values are known for some rational arguments::
6409	
6410	    >>> barnesg('1/2')
6411	    0.603244281209446
6412	    >>> sqrt(exp(0.25+log(2)/12)/sqrt(pi)/glaisher**3)
6413	    0.603244281209446
6414	    >>> barnesg('1/4')
6415	    0.29375596533861
6416	    >>> nthroot(exp('3/8')/exp(catalan/pi)/
6417	    ...      gamma(0.25)**3/sqrt(glaisher)**9, 4)
6418	    0.29375596533861
6419	
6420	The Barnes G-function satisfies the functional equation
6421	`G(z+1) = \Gamma(z) G(z)`::
6422	
6423	    >>> z = pi
6424	    >>> barnesg(z+1)
6425	    2.39292119327948
6426	    >>> gamma(z)*barnesg(z)
6427	    2.39292119327948
6428	
6429	The asymptotic growth rate of the Barnes G-function is related to
6430	the Glaisher-Kinkelin constant::
6431	
6432	    >>> limit(lambda n: barnesg(n+1)/(n**(n**2/2-mpf(1)/12)*
6433	    ...     (2*pi)**(n/2)*exp(-3*n**2/4)), inf)
6434	    0.847536694177301
6435	    >>> exp('1/12')/glaisher
6436	    0.847536694177301
6437	
6438	The Barnes G-function can be differentiated in closed form::
6439	
6440	    >>> z = 3
6441	    >>> diff(barnesg, z)
6442	    0.264507203401607
6443	    >>> barnesg(z)*((z-1)*psi(0,z)-z+(log(2*pi)+1)/2)
6444	    0.264507203401607
6445	
6446	Evaluation is supported for arbitrary arguments and at arbitrary
6447	precision::
6448	
6449	    >>> barnesg(6.5)
6450	    2548.7457695685
6451	    >>> barnesg(-pi)
6452	    0.00535976768353037
6453	    >>> barnesg(3+4j)
6454	    (-0.000676375932234244 - 4.42236140124728e-5j)
6455	    >>> mp.dps = 50
6456	    >>> barnesg(1/sqrt(2))
6457	    0.81305501090451340843586085064413533788206204124732
6458	    >>> q = barnesg(10j)
6459	    >>> q.real
6460	    0.000000000021852360840356557241543036724799812371995850552234
6461	    >>> q.imag
6462	    -0.00000000000070035335320062304849020654215545839053210041457588
6463	    >>> mp.dps = 15
6464	    >>> barnesg(100)
6465	    3.10361006263698e+6626
6466	    >>> barnesg(-101)
6467	    0.0
6468	    >>> barnesg(-10.5)
6469	    5.94463017605008e+25
6470	    >>> barnesg(-10000.5)
6471	    -6.14322868174828e+167480422
6472	    >>> barnesg(1000j)
6473	    (5.21133054865546e-1173597 + 4.27461836811016e-1173597j)
6474	    >>> barnesg(-1000+1000j)
6475	    (2.43114569750291e+1026623 + 2.24851410674842e+1026623j)
6476	
6477	
6478	**References**
6479	
6480	1. Whittaker & Watson, *A Course of Modern Analysis*,
6481	   Cambridge University Press, 4th edition (1927), p.264
6482	2. http://en.wikipedia.org/wiki/Barnes_G-function
6483	3. http://mathworld.wolfram.com/BarnesG-Function.html
6484	
6485	"""
6486	
6487	superfac = r"""

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/function_docs.py:6487
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
6486	
6487	superfac = r"""
6488	Computes the superfactorial, defined as the product of
6489	consecutive factorials
6490	
6491	.. math ::
6492	
6493	    \mathrm{sf}(n) = \prod_{k=1}^n k!
6494	
6495	For general complex `z`, `\mathrm{sf}(z)` is defined
6496	in terms of the Barnes G-function (see :func:`~mpmath.barnesg`).
6497	
6498	**Examples**
6499	
6500	The first few superfactorials are (OEIS A000178)::
6501	
6502	    >>> from mpmath import mp, superfac, pi, diff
6503	    >>> mp.pretty = True
6504	    >>> for n in range(10):
6505	    ...     print("%s %s" % (n, superfac(n)))
6506	    ...
6507	    0 1.0
6508	    1 1.0
6509	    2 2.0
6510	    3 12.0
6511	    4 288.0
6512	    5 34560.0
6513	    6 24883200.0
6514	    7 125411328000.0
6515	    8 5.05658474496e+15
6516	    9 1.83493347225108e+21
6517	
6518	Superfactorials grow very rapidly::
6519	
6520	    >>> superfac(1000)
6521	    3.24570818422368e+1177245
6522	    >>> superfac(10**10)
6523	    2.61398543581249e+467427913956904067453
6524	
6525	Evaluation is supported for arbitrary arguments::
6526	
6527	    >>> mp.dps = 25
6528	    >>> superfac(pi)
6529	    17.20051550121297985285333
6530	    >>> superfac(2+3j)
6531	    (-0.005915485633199789627466468 + 0.008156449464604044948738263j)
6532	    >>> diff(superfac, 1)
6533	    0.2645072034016070205673056
6534	
6535	**References**
6536	
6537	1. http://oeis.org/A000178
6538	
6539	"""
6540	
6541	
6542	hyperfac = r"""

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/function_docs.py:6542
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
6541	
6542	hyperfac = r"""
6543	Computes the hyperfactorial, defined for integers as the product
6544	
6545	.. math ::
6546	
6547	    H(n) = \prod_{k=1}^n k^k.
6548	
6549	
6550	The hyperfactorial satisfies the recurrence formula `H(z) = z^z H(z-1)`.
6551	It can be defined more generally in terms of the Barnes G-function (see
6552	:func:`~mpmath.barnesg`) and the gamma function by the formula
6553	
6554	.. math ::
6555	
6556	    H(z) = \frac{\Gamma(z+1)^z}{G(z)}.
6557	
6558	The extension to complex numbers can also be done via
6559	the integral representation
6560	
6561	.. math ::
6562	
6563	    H(z) = (2\pi)^{-z/2} \exp \left[
6564	        {z+1 \choose 2} + \int_0^z \log(t!)\,dt
6565	        \right].
6566	
6567	**Examples**
6568	
6569	The rapidly-growing sequence of hyperfactorials begins
6570	(OEIS A002109)::
6571	
6572	    >>> from mpmath import (mp, hyperfac, diff, pi, mpf, chop, exp, quad,
6573	    ...                     binomial, loggamma, sqrt, j)
6574	    >>> mp.pretty = True
6575	    >>> for n in range(10):
6576	    ...     print("%s %s" % (n, hyperfac(n)))
6577	    ...
6578	    0 1.0
6579	    1 1.0
6580	    2 4.0
6581	    3 108.0
6582	    4 27648.0
6583	    5 86400000.0
6584	    6 4031078400000.0
6585	    7 3.3197663987712e+18
6586	    8 5.56964379417266e+25
6587	    9 2.15779412229419e+34
6588	
6589	Some even larger hyperfactorials are::
6590	
6591	    >>> hyperfac(1000)
6592	    5.46458120882585e+1392926
6593	    >>> hyperfac(10**10)
6594	    4.60408207642219e+489142638002418704309
6595	
6596	The hyperfactorial can be evaluated for arbitrary arguments::
6597	
6598	    >>> hyperfac(0.5)
6599	    0.880449235173423
6600	    >>> diff(hyperfac, 1)
6601	    0.581061466795327
6602	    >>> hyperfac(pi)
6603	    205.211134637462
6604	    >>> hyperfac(-10+1j)
6605	    (3.01144471378225e+46 - 2.45285242480185e+46j)
6606	
6607	The recurrence property of the hyperfactorial holds
6608	generally::
6609	
6610	    >>> z = 3-4*j
6611	    >>> hyperfac(z)
6612	    (-4.49795891462086e-7 - 6.33262283196162e-7j)
6613	    >>> z**z * hyperfac(z-1)
6614	    (-4.49795891462086e-7 - 6.33262283196162e-7j)
6615	    >>> z = mpf(-0.6)
6616	    >>> chop(z**z * hyperfac(z-1))
6617	    1.28170142849352
6618	    >>> hyperfac(z)
6619	    1.28170142849352
6620	
6621	The hyperfactorial may also be computed using the integral
6622	definition::
6623	
6624	    >>> z = 2.5
6625	    >>> hyperfac(z)
6626	    15.9842119922237
6627	    >>> (2*pi)**(-z/2)*exp(binomial(z+1,2) +
6628	    ...     quad(lambda t: loggamma(t+1), [0, z]))
6629	    15.9842119922237
6630	
6631	:func:`~mpmath.hyperfac` supports arbitrary-precision evaluation::
6632	
6633	    >>> mp.dps = 50
6634	    >>> hyperfac(10)
6635	    215779412229418562091680268288000000000000000.0
6636	    >>> hyperfac(1/sqrt(2))
6637	    0.89404818005227001975423476035729076375705084390942
6638	
6639	**References**
6640	
6641	1. http://oeis.org/A002109
6642	2. http://mathworld.wolfram.com/Hyperfactorial.html
6643	
6644	"""
6645	
6646	rgamma = r"""

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/function_docs.py:6842
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
6841	
6842	grampoint = r"""
6843	Gives the `n`-th Gram point `g_n`, defined as the solution
6844	to the equation `\theta(g_n) = \pi n` where `\theta(t)`
6845	is the Riemann-Siegel theta function (:func:`~mpmath.siegeltheta`).
6846	
6847	The first few Gram points are::
6848	
6849	    >>> from mpmath import mp, grampoint, siegeltheta, pi, findroot
6850	    >>> mp.dps = 25; mp.pretty = True
6851	    >>> grampoint(0)
6852	    17.84559954041086081682634
6853	    >>> grampoint(1)
6854	    23.17028270124630927899664
6855	    >>> grampoint(2)
6856	    27.67018221781633796093849
6857	    >>> grampoint(3)
6858	    31.71797995476405317955149
6859	
6860	Checking the definition::
6861	
6862	    >>> siegeltheta(grampoint(3))
6863	    9.42477796076937971538793
6864	    >>> 3*pi
6865	    9.42477796076937971538793
6866	
6867	A large Gram point::
6868	
6869	    >>> grampoint(10**10)
6870	    3293531632.728335454561153
6871	
6872	Gram points are useful when studying the Z-function
6873	(:func:`~mpmath.siegelz`). See the documentation of that function
6874	for additional examples.
6875	
6876	:func:`~mpmath.grampoint` can solve the defining equation for
6877	nonintegral `n`. There is a fixed point where `g(x) = x`::
6878	
6879	    >>> findroot(lambda x: grampoint(x) - x, 10000)
6880	    9146.698193171459265866198
6881	
6882	**References**
6883	
6884	1. http://mathworld.wolfram.com/GramPoint.html
6885	
6886	"""
6887	
6888	siegelz = r"""

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/function_docs.py:7252
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
7251	
7252	polylog = r"""
7253	Computes the polylogarithm, defined by the sum
7254	
7255	.. math ::
7256	
7257	    \mathrm{Li}_s(z) = \sum_{k=1}^{\infty} \frac{z^k}{k^s}.
7258	
7259	This series is convergent only for `|z| < 1`, so elsewhere
7260	the analytic continuation is implied.
7261	
7262	The polylogarithm should not be confused with the logarithmic
7263	integral (also denoted by Li or li), which is implemented
7264	as :func:`~mpmath.li`.
7265	
7266	**Examples**
7267	
7268	The polylogarithm satisfies a huge number of functional identities.
7269	A sample of polylogarithm evaluations is shown below::
7270	
7271	    >>> from mpmath import (mp, polylog, log, pi, phi, zeta, j, catalan, exp,
7272	    ...                     zeta, quad, diff, taylor, altzeta, nsum, inf, nprint)
7273	    >>> mp.pretty = True
7274	    >>> polylog(1,0.5), log(2)
7275	    (0.693147180559945, 0.693147180559945)
7276	    >>> polylog(2,0.5), (pi**2-6*log(2)**2)/12
7277	    (0.582240526465012, 0.582240526465012)
7278	    >>> polylog(2,-phi), -log(phi)**2-pi**2/10
7279	    (-1.21852526068613, -1.21852526068613)
7280	    >>> polylog(3,0.5), 7*zeta(3)/8-pi**2*log(2)/12+log(2)**3/6
7281	    (0.53721319360804, 0.53721319360804)
7282	
7283	:func:`~mpmath.polylog` can evaluate the analytic continuation of the
7284	polylogarithm when `s` is an integer::
7285	
7286	    >>> polylog(2, 10)
7287	    (0.536301287357863 - 7.23378441241546j)
7288	    >>> polylog(2, -10)
7289	    -4.1982778868581
7290	    >>> polylog(2, 10j)
7291	    (-3.05968879432873 + 3.71678149306807j)
7292	    >>> polylog(-2, 10)
7293	    -0.150891632373114
7294	    >>> polylog(-2, -10)
7295	    0.067618332081142
7296	    >>> polylog(-2, 10j)
7297	    (0.0384353698579347 + 0.0912451798066779j)
7298	
7299	Some more examples, with arguments on the unit circle (note that
7300	the series definition cannot be used for computation here)::
7301	
7302	    >>> polylog(2,j)
7303	    (-0.205616758356028 + 0.915965594177219j)
7304	    >>> j*catalan-pi**2/48
7305	    (-0.205616758356028 + 0.915965594177219j)
7306	    >>> polylog(3,exp(2*pi*j/3))
7307	    (-0.534247512515375 + 0.765587078525922j)
7308	    >>> -4*zeta(3)/9 + 2*j*pi**3/81
7309	    (-0.534247512515375 + 0.765587078525921j)
7310	
7311	Polylogarithms of different order are related by integration
7312	and differentiation::
7313	
7314	    >>> s, z = 3, 0.5
7315	    >>> polylog(s+1, z)
7316	    0.517479061673899
7317	    >>> quad(lambda t: polylog(s,t)/t, [0, z])
7318	    0.517479061673899
7319	    >>> z*diff(lambda t: polylog(s+2,t), z)
7320	    0.517479061673899
7321	
7322	Taylor series expansions around `z = 0` are::
7323	
7324	    >>> for n in range(-3, 4):
7325	    ...     nprint(taylor(lambda x: polylog(n,x), 0, 5))
7326	    ...
7327	    [0.0, 1.0, 8.0, 27.0, 64.0, 125.0]
7328	    [0.0, 1.0, 4.0, 9.0, 16.0, 25.0]
7329	    [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]
7330	    [0.0, 1.0, 1.0, 1.0, 1.0, 1.0]
7331	    [0.0, 1.0, 0.5, 0.333333, 0.25, 0.2]
7332	    [0.0, 1.0, 0.25, 0.111111, 0.0625, 0.04]
7333	    [0.0, 1.0, 0.125, 0.037037, 0.015625, 0.008]
7334	
7335	The series defining the polylogarithm is simultaneously
7336	a Taylor series and an L-series. For certain values of `z`, the
7337	polylogarithm reduces to a pure zeta function::
7338	
7339	    >>> polylog(pi, 1), zeta(pi)
7340	    (1.17624173838258, 1.17624173838258)
7341	    >>> polylog(pi, -1), -altzeta(pi)
7342	    (-0.909670702980385, -0.909670702980385)
7343	
7344	Evaluation for arbitrary, nonintegral `s` is supported
7345	for `z` within the unit circle:
7346	
7347	    >>> polylog(3+4j, 0.25)
7348	    (0.24258605789446 - 0.00222938275488344j)
7349	    >>> nsum(lambda k: 0.25**k / k**(3+4j), [1,inf])
7350	    (0.24258605789446 - 0.00222938275488344j)
7351	
7352	It is also supported outside of the unit circle::
7353	
7354	    >>> polylog(1+j, 20+40j)
7355	    (-7.1421172179728 - 3.92726697721369j)
7356	    >>> polylog(1+j, 200+400j)
7357	    (-5.41934747194626 - 9.94037752563927j)
7358	
7359	**References**
7360	
7361	1. Richard Crandall, "Note on fast polylogarithm computation"
7362	   http://www.reed.edu/physics/faculty/crandall/papers/Polylog.pdf
7363	2. http://en.wikipedia.org/wiki/Polylogarithm
7364	3. http://mathworld.wolfram.com/Polylogarithm.html
7365	
7366	"""
7367	
7368	bell = r"""

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/function_docs.py:7368
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
7367	
7368	bell = r"""
7369	For `n` a nonnegative integer, ``bell(n,x)`` evaluates the Bell
7370	polynomial `B_n(x)`, the first few of which are
7371	
7372	.. math ::
7373	
7374	    B_0(x) = 1
7375	
7376	    B_1(x) = x
7377	
7378	    B_2(x) = x^2+x
7379	
7380	    B_3(x) = x^3+3x^2+x
7381	
7382	If `x = 1` or :func:`~mpmath.bell` is called with only one argument, it
7383	gives the `n`-th Bell number `B_n`, which is the number of
7384	partitions of a set with `n` elements. By setting the precision to
7385	at least `\log_{10} B_n` digits, :func:`~mpmath.bell` provides fast
7386	calculation of exact Bell numbers.
7387	
7388	In general, :func:`~mpmath.bell` computes
7389	
7390	.. math ::
7391	
7392	    B_n(x) = e^{-x} \left(\mathrm{sinc}(\pi n) + E_n(x)\right)
7393	
7394	where `E_n(x)` is the generalized exponential function implemented
7395	by :func:`~mpmath.polyexp`. This is an extension of Dobinski's formula [1],
7396	where the modification is the sinc term ensuring that `B_n(x)` is
7397	continuous in `n`; :func:`~mpmath.bell` can thus be evaluated,
7398	differentiated, etc for arbitrary complex arguments.
7399	
7400	**Examples**
7401	
7402	Simple evaluations::
7403	
7404	    >>> from mpmath import mp, bell, nprint, taylor, det, superfac
7405	    >>> mp.dps = 25; mp.pretty = True
7406	    >>> bell(0, 2.5)
7407	    1.0
7408	    >>> bell(1, 2.5)
7409	    2.5
7410	    >>> bell(2, 2.5)
7411	    8.75
7412	
7413	Evaluation for arbitrary complex arguments::
7414	
7415	    >>> bell(5.75+1j, 2-3j)
7416	    (-10767.71345136587098445143 - 15449.55065599872579097221j)
7417	
7418	The first few Bell polynomials::
7419	
7420	    >>> for k in range(7):
7421	    ...     nprint(taylor(lambda x: bell(k,x), 0, k))
7422	    ...
7423	    [1.0]
7424	    [0.0, 1.0]
7425	    [0.0, 1.0, 1.0]
7426	    [0.0, 1.0, 3.0, 1.0]
7427	    [0.0, 1.0, 7.0, 6.0, 1.0]
7428	    [0.0, 1.0, 15.0, 25.0, 10.0, 1.0]
7429	    [0.0, 1.0, 31.0, 90.0, 65.0, 15.0, 1.0]
7430	
7431	The first few Bell numbers and complementary Bell numbers::
7432	
7433	    >>> [int(bell(k)) for k in range(10)]
7434	    [1, 1, 2, 5, 15, 52, 203, 877, 4140, 21147]
7435	    >>> [int(bell(k,-1)) for k in range(10)]
7436	    [1, -1, 0, 1, 1, -2, -9, -9, 50, 267]
7437	
7438	Large Bell numbers::
7439	
7440	    >>> mp.dps = 50
7441	    >>> bell(50)
7442	    185724268771078270438257767181908917499221852770.0
7443	    >>> bell(50,-1)
7444	    -29113173035759403920216141265491160286912.0
7445	
7446	Some even larger values::
7447	
7448	    >>> mp.dps = 25
7449	    >>> bell(1000,-1)
7450	    -1.237132026969293954162816e+1869
7451	    >>> bell(1000)
7452	    2.989901335682408421480422e+1927
7453	    >>> bell(1000,2)
7454	    6.591553486811969380442171e+1987
7455	    >>> bell(1000,100.5)
7456	    9.101014101401543575679639e+2529
7457	
7458	A determinant identity satisfied by Bell numbers::
7459	
7460	    >>> mp.dps = 15
7461	    >>> N = 8
7462	    >>> det([[bell(k+j) for j in range(N)] for k in range(N)])
7463	    125411328000.0
7464	    >>> superfac(N-1)
7465	    125411328000.0
7466	
7467	**References**
7468	
7469	1. http://mathworld.wolfram.com/DobinskisFormula.html
7470	
7471	"""
7472	
7473	polyexp = r"""

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/function_docs.py:7623
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
7622	
7623	meijerg = r"""
7624	Evaluates the Meijer G-function, defined as
7625	
7626	.. math ::
7627	
7628	    G^{m,n}_{p,q} \left( \left. \begin{matrix}
7629	         a_1, \dots, a_n ; a_{n+1} \dots a_p \\
7630	         b_1, \dots, b_m ; b_{m+1} \dots b_q
7631	    \end{matrix}\; \right| \; z ; r \right) =
7632	    \frac{1}{2 \pi i} \int_L
7633	    \frac{\prod_{j=1}^m \Gamma(b_j+s) \prod_{j=1}^n\Gamma(1-a_j-s)}
7634	         {\prod_{j=n+1}^{p}\Gamma(a_j+s) \prod_{j=m+1}^q \Gamma(1-b_j-s)}
7635	         z^{-s/r} ds
7636	
7637	for an appropriate choice of the contour `L` (see references).
7638	
7639	There are `p` elements `a_j`.
7640	The argument *a_s* should be a pair of lists, the first containing the
7641	`n` elements `a_1, \ldots, a_n` and the second containing
7642	the `p-n` elements `a_{n+1}, \ldots a_p`.
7643	
7644	There are `q` elements `b_j`.
7645	The argument *b_s* should be a pair of lists, the first containing the
7646	`m` elements `b_1, \ldots, b_m` and the second containing
7647	the `q-m` elements `b_{m+1}, \ldots b_q`.
7648	
7649	The implicit tuple `(m, n, p, q)` constitutes the order or degree of the
7650	Meijer G-function, and is determined by the lengths of the coefficient
7651	vectors. Confusingly, the indices in this tuple appear in a different order
7652	from the coefficients, but this notation is standard. The many examples
7653	given below should hopefully clear up any potential confusion.
7654	
7655	**Algorithm**
7656	
7657	The Meijer G-function is evaluated as a combination of hypergeometric series.
7658	There are two versions of the function, which can be selected with
7659	the optional *series* argument.
7660	
7661	*series=1* uses a sum of `m` `\,_pF_{q-1}` functions of `z`
7662	
7663	*series=2* uses a sum of `n` `\,_qF_{p-1}` functions of `1/z`
7664	
7665	The default series is chosen based on the degree and `|z|` in order
7666	to be consistent with Mathematica's. This definition of the Meijer G-function
7667	has a discontinuity at `|z| = 1` for some orders, which can
7668	be avoided by explicitly specifying a series.
7669	
7670	Keyword arguments are forwarded to :func:`~mpmath.hypercomb`.
7671	
7672	**Examples**
7673	
7674	Many standard functions are special cases of the Meijer G-function
7675	(possibly rescaled and/or with branch cut corrections). We define
7676	some test parameters::
7677	
7678	    >>> from mpmath import (mp, mpf, meijerg, exp, log, sin, cos, sqrt, pi,
7679	    ...                     besselj, bessely, chop, gamma, expint, besseli,
7680	    ...                     besselk, erfc)
7681	    >>> mp.dps = 25; mp.pretty = True
7682	    >>> a = mpf(0.75)
7683	    >>> b = mpf(1.5)
7684	    >>> z = mpf(2.25)
7685	
7686	The exponential function:
7687	`e^z = G^{1,0}_{0,1} \left( \left. \begin{matrix} - \\ 0 \end{matrix} \;
7688	\right| \; -z \right)`
7689	
7690	    >>> meijerg([[],[]], [[0],[]], -z)
7691	    9.487735836358525720550369
7692	    >>> exp(z)
7693	    9.487735836358525720550369
7694	
7695	The natural logarithm:
7696	`\log(1+z) = G^{1,2}_{2,2} \left( \left. \begin{matrix} 1, 1 \\ 1, 0
7697	\end{matrix} \; \right| \; -z \right)`
7698	
7699	    >>> meijerg([[1,1],[]], [[1],[0]], z)
7700	    1.178654996341646117219023
7701	    >>> log(1+z)
7702	    1.178654996341646117219023
7703	
7704	A rational function:
7705	`\frac{z}{z+1} = G^{1,2}_{2,2} \left( \left. \begin{matrix} 1, 1 \\ 1, 1
7706	\end{matrix} \; \right| \; z \right)`
7707	
7708	    >>> meijerg([[1,1],[]], [[1],[1]], z)
7709	    0.6923076923076923076923077
7710	    >>> z/(z+1)
7711	    0.6923076923076923076923077
7712	
7713	The sine and cosine functions:
7714	
7715	`\frac{1}{\sqrt \pi} \sin(2 \sqrt z) = G^{1,0}_{0,2} \left( \left. \begin{matrix}
7716	- \\ \frac{1}{2}, 0 \end{matrix} \; \right| \; z \right)`
7717	
7718	`\frac{1}{\sqrt \pi} \cos(2 \sqrt z) = G^{1,0}_{0,2} \left( \left. \begin{matrix}
7719	- \\ 0, \frac{1}{2} \end{matrix} \; \right| \; z \right)`
7720	
7721	    >>> meijerg([[],[]], [[0.5],[0]], (z/2)**2)
7722	    0.4389807929218676682296453
7723	    >>> sin(z)/sqrt(pi)
7724	    0.4389807929218676682296453
7725	    >>> meijerg([[],[]], [[0],[0.5]], (z/2)**2)
7726	    -0.3544090145996275423331762
7727	    >>> cos(z)/sqrt(pi)
7728	    -0.3544090145996275423331762
7729	
7730	Bessel functions:
7731	
7732	`J_a(2 \sqrt z) = G^{1,0}_{0,2} \left( \left.
7733	\begin{matrix} - \\ \frac{a}{2}, -\frac{a}{2}
7734	\end{matrix} \; \right| \; z \right)`
7735	
7736	`Y_a(2 \sqrt z) = G^{2,0}_{1,3} \left( \left.
7737	\begin{matrix} \frac{-a-1}{2} \\ \frac{a}{2}, -\frac{a}{2}, \frac{-a-1}{2}
7738	\end{matrix} \; \right| \; z \right)`
7739	
7740	`(-z)^{a/2} z^{-a/2} I_a(2 \sqrt z) = G^{1,0}_{0,2} \left( \left.
7741	\begin{matrix} - \\ \frac{a}{2}, -\frac{a}{2}
7742	\end{matrix} \; \right| \; -z \right)`
7743	
7744	`2 K_a(2 \sqrt z) = G^{2,0}_{0,2} \left( \left.
7745	\begin{matrix} - \\ \frac{a}{2}, -\frac{a}{2}
7746	\end{matrix} \; \right| \; z \right)`
7747	
7748	As the example with the Bessel *I* function shows, a branch
7749	factor is required for some arguments when inverting the square root.
7750	
7751	    >>> meijerg([[],[]], [[a/2],[-a/2]], (z/2)**2)
7752	    0.5059425789597154858527264
7753	    >>> besselj(a,z)
7754	    0.5059425789597154858527264
7755	    >>> meijerg([[],[(-a-1)/2]], [[a/2,-a/2],[(-a-1)/2]], (z/2)**2)
7756	    0.1853868950066556941442559
7757	    >>> bessely(a, z)
7758	    0.1853868950066556941442559
7759	    >>> meijerg([[],[]], [[a/2],[-a/2]], -(z/2)**2)
7760	    (0.8685913322427653875717476 + 2.096964974460199200551738j)
7761	    >>> (-z)**(a/2) / z**(a/2) * besseli(a, z)
7762	    (0.8685913322427653875717476 + 2.096964974460199200551738j)
7763	    >>> 0.5*meijerg([[],[]], [[a/2,-a/2],[]], (z/2)**2)
7764	    0.09334163695597828403796071
7765	    >>> besselk(a,z)
7766	    0.09334163695597828403796071
7767	
7768	Error functions:
7769	
7770	`\sqrt{\pi} z^{2(a-1)} \mathrm{erfc}(z) = G^{2,0}_{1,2} \left( \left.
7771	\begin{matrix} a \\ a-1, a-\frac{1}{2}
7772	\end{matrix} \; \right| \; z, \frac{1}{2} \right)`
7773	
7774	    >>> meijerg([[],[a]], [[a-1,a-0.5],[]], z, 0.5)
7775	    0.00172839843123091957468712
7776	    >>> sqrt(pi) * z**(2*a-2) * erfc(z)
7777	    0.00172839843123091957468712
7778	
7779	A Meijer G-function of higher degree, (1,1,2,3):
7780	
7781	    >>> meijerg([[a],[b]], [[a],[b,a-1]], z)
7782	    1.55984467443050210115617
7783	    >>> sin((b-a)*pi)/pi*(exp(z)-1)*z**(a-1)
7784	    1.55984467443050210115617
7785	
7786	A Meijer G-function of still higher degree, (4,1,2,4), that can
7787	be expanded as a messy combination of exponential integrals:
7788	
7789	    >>> meijerg([[a],[2*b-a]], [[b,a,b-0.5,-1-a+2*b],[]], z)
7790	    0.3323667133658557271898061
7791	    >>> chop(4**(a-b+1)*sqrt(pi)*gamma(2*b-2*a)*z**a*\
7792	    ...     expint(2*b-2*a, -2*sqrt(-z))*expint(2*b-2*a, 2*sqrt(-z)))
7793	    0.3323667133658557271898061
7794	
7795	In the following case, different series give different values::
7796	
7797	    >>> chop(meijerg([[1],[0.25]],[[3],[0.5]],-2))
7798	    -0.06417628097442437076207337
7799	    >>> meijerg([[1],[0.25]],[[3],[0.5]],-2,series=1)
7800	    0.1428699426155117511873047
7801	    >>> chop(meijerg([[1],[0.25]],[[3],[0.5]],-2,series=2))
7802	    -0.06417628097442437076207337
7803	
7804	**References**
7805	
7806	1. http://en.wikipedia.org/wiki/Meijer_G-function
7807	
7808	2. http://mathworld.wolfram.com/MeijerG-Function.html
7809	
7810	3. http://functions.wolfram.com/HypergeometricFunctions/MeijerG/
7811	
7812	4. http://functions.wolfram.com/HypergeometricFunctions/MeijerG1/
7813	
7814	"""
7815	
7816	clsin = r"""

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/function_docs.py:8376
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
8375	
8376	appellf1 = r"""
8377	Gives the Appell F1 hypergeometric function of two variables,
8378	
8379	.. math ::
8380	
8381	    F_1(a,b_1,b_2,c,x,y) = \sum_{m=0}^{\infty} \sum_{n=0}^{\infty}
8382	        \frac{(a)_{m+n} (b_1)_m (b_2)_n}{(c)_{m+n}}
8383	        \frac{x^m y^n}{m! n!}.
8384	
8385	This series is only generally convergent when `|x| < 1` and `|y| < 1`,
8386	although :func:`~mpmath.appellf1` can evaluate an analytic continuation
8387	with respecto to either variable, and sometimes both.
8388	
8389	**Examples**
8390	
8391	Evaluation is supported for real and complex parameters::
8392	
8393	    >>> from mpmath import (mp, appellf1, hyp2f1, chop, diff, mpmathify,
8394	    ...                     quad, ellipe, re, pi, mpf, sin, sqrt, j)
8395	    >>> mp.dps = 25; mp.pretty = True
8396	    >>> appellf1(1,0,0.5,1,0.5,0.25)
8397	    1.154700538379251529018298
8398	    >>> appellf1(1,1+j,0.5,1,0.5,0.5j)
8399	    (1.138403860350148085179415 + 1.510544741058517621110615j)
8400	
8401	For some integer parameters, the F1 series reduces to a polynomial::
8402	
8403	    >>> appellf1(2,-4,-3,1,2,5)
8404	    -816.0
8405	    >>> appellf1(-5,1,2,1,4,5)
8406	    -20528.0
8407	
8408	The analytic continuation with respect to either `x` or `y`,
8409	and sometimes with respect to both, can be evaluated::
8410	
8411	    >>> appellf1(2,3,4,5,100,0.5)
8412	    (0.0006231042714165329279738662 + 0.0000005769149277148425774499857j)
8413	    >>> appellf1('1.1', '0.3', '0.2+2j', '0.4', '0.2', 1.5+3j)
8414	    (-0.1782604566893954897128702 + 0.002472407104546216117161499j)
8415	    >>> appellf1(1,2,3,4,10,12)
8416	    -0.07122993830066776374929313
8417	
8418	For certain arguments, F1 reduces to an ordinary hypergeometric function::
8419	
8420	    >>> appellf1(1,2,3,5,0.5,0.25)
8421	    1.547902270302684019335555
8422	    >>> 4*hyp2f1(1,2,5,'1/3')/3
8423	    1.547902270302684019335555
8424	    >>> appellf1(1,2,3,4,0,1.5)
8425	    (-1.717202506168937502740238 - 2.792526803190927323077905j)
8426	    >>> hyp2f1(1,3,4,1.5)
8427	    (-1.717202506168937502740238 - 2.792526803190927323077905j)
8428	
8429	The F1 function satisfies a system of partial differential equations::
8430	
8431	    >>> a,b1,b2,c,x,y = map(mpf, [1,0.5,0.25,1.125,0.25,-0.25])
8432	    >>> F = lambda x,y: appellf1(a,b1,b2,c,x,y)
8433	    >>> chop(x*(1-x)*diff(F,(x,y),(2,0)) +
8434	    ...      y*(1-x)*diff(F,(x,y),(1,1)) +
8435	    ...      (c-(a+b1+1)*x)*diff(F,(x,y),(1,0)) -
8436	    ...      b1*y*diff(F,(x,y),(0,1)) -
8437	    ...      a*b1*F(x,y))
8438	    0.0
8439	    >>>
8440	    >>> chop(y*(1-y)*diff(F,(x,y),(0,2)) +
8441	    ...      x*(1-y)*diff(F,(x,y),(1,1)) +
8442	    ...      (c-(a+b2+1)*y)*diff(F,(x,y),(0,1)) -
8443	    ...      b2*x*diff(F,(x,y),(1,0)) -
8444	    ...      a*b2*F(x,y))
8445	    0.0
8446	
8447	The Appell F1 function allows for closed-form evaluation of various
8448	integrals, such as any integral of the form
8449	`\int x^r (x+a)^p (x+b)^q dx`::
8450	
8451	    >>> def integral(a,b,p,q,r,x1,x2):
8452	    ...     a,b,p,q,r,x1,x2 = map(mpmathify, [a,b,p,q,r,x1,x2])
8453	    ...     f = lambda x: x**r * (x+a)**p * (x+b)**q
8454	    ...     def F(x):
8455	    ...         v = x**(r+1)/(r+1) * (a+x)**p * (b+x)**q
8456	    ...         v *= (1+x/a)**(-p)
8457	    ...         v *= (1+x/b)**(-q)
8458	    ...         v *= appellf1(r+1,-p,-q,2+r,-x/a,-x/b)
8459	    ...         return v
8460	    ...     print("Num. quad: %s" % quad(f, [x1,x2]))
8461	    ...     print("Appell F1: %s" % (F(x2)-F(x1)))
8462	    ...
8463	    >>> integral('1/5','4/3','-2','3','1/2',0,1)
8464	    Num. quad: 9.073335358785776206576981
8465	    Appell F1: 9.073335358785776206576981
8466	    >>> integral('3/2','4/3','-2','3','1/2',0,1)
8467	    Num. quad: 1.092829171999626454344678
8468	    Appell F1: 1.092829171999626454344678
8469	    >>> integral('3/2','4/3','-2','3','1/2',12,25)
8470	    Num. quad: 1106.323225040235116498927
8471	    Appell F1: 1106.323225040235116498927
8472	
8473	Also incomplete elliptic integrals fall into this category [1]::
8474	
8475	    >>> def E(z, m):
8476	    ...     if (pi/2).ae(z):
8477	    ...         return ellipe(m)
8478	    ...     return 2*round(re(z)/pi)*ellipe(m) + mpf(-1)**round(re(z)/pi)*\
8479	    ...         sin(z)*appellf1(0.5,0.5,-0.5,1.5,sin(z)**2,m*sin(z)**2)
8480	    ...
8481	    >>> z, m = 1, 0.5
8482	    >>> E(z,m); quad(lambda t: sqrt(1-m*sin(t)**2), [0,pi/4,3*pi/4,z])
8483	    0.9273298836244400669659042
8484	    0.9273298836244400669659042
8485	    >>> z, m = 3, 2
8486	    >>> E(z,m); quad(lambda t: sqrt(1-m*sin(t)**2), [0,pi/4,3*pi/4,z])
8487	    (1.057495752337234229715836 + 1.198140234735592207439922j)
8488	    (1.057495752337234229715836 + 1.198140234735592207439922j)
8489	
8490	**References**
8491	
8492	1. [WolframFunctions]_ http://functions.wolfram.com/EllipticIntegrals/EllipticE2/26/01/
8493	2. [SrivastavaKarlsson]_
8494	3. [CabralRosetti]_
8495	4. [Vidunas]_
8496	5. [Slater]_
8497	
8498	"""
8499	
8500	angerj = r"""

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/function_docs.py:8627
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
8626	
8627	lommels1 = r"""
8628	Gives the Lommel function `s_{\mu,\nu}` or `s^{(1)}_{\mu,\nu}`
8629	
8630	.. math ::
8631	
8632	    s_{\mu,\nu}(z) = \frac{z^{\mu+1}}{(\mu-\nu+1)(\mu+\nu+1)}
8633	        \,_1F_2\left(1; \frac{\mu-\nu+3}{2}, \frac{\mu+\nu+3}{2};
8634	        -\frac{z^2}{4} \right)
8635	
8636	which solves the inhomogeneous Bessel equation
8637	
8638	.. math ::
8639	
8640	    z^2 f''(z) + z f'(z) + (z^2-\nu^2) f(z) = z^{\mu+1}.
8641	
8642	A second solution is given by :func:`~mpmath.lommels2`.
8643	
8644	**Plots**
8645	
8646	.. literalinclude :: /plots/lommels1.py
8647	.. image :: /plots/lommels1.png
8648	
8649	**Examples**
8650	
8651	An integral representation::
8652	
8653	    >>> from mpmath import (mp, mpf, lommels1, quad, bessely, besselj, pi,
8654	    ...                     gamma, sqrt, power, struveh, diff)
8655	    >>> mp.dps = 25; mp.pretty = True
8656	    >>> u,v,z = 0.25, 0.125, mpf(0.75)
8657	    >>> lommels1(u,v,z)
8658	    0.4276243877565150372999126
8659	    >>> (bessely(v,z)*quad(lambda t: t**u*besselj(v,t), [0,z]) - \
8660	    ...  besselj(v,z)*quad(lambda t: t**u*bessely(v,t), [0,z]))*(pi/2)
8661	    0.4276243877565150372999126
8662	
8663	A special value::
8664	
8665	    >>> lommels1(v,v,z)
8666	    0.5461221367746048054932553
8667	    >>> gamma(v+0.5)*sqrt(pi)*power(2,v-1)*struveh(v,z)
8668	    0.5461221367746048054932553
8669	
8670	Verifying the differential equation::
8671	
8672	    >>> f = lambda z: lommels1(u,v,z)
8673	    >>> z**2*diff(f,z,2) + z*diff(f,z) + (z**2-v**2)*f(z)
8674	    0.6979536443265746992059141
8675	    >>> z**(u+1)
8676	    0.6979536443265746992059141
8677	
8678	**References**
8679	
8680	1. [GradshteynRyzhik]_
8681	2. [Weisstein]_ http://mathworld.wolfram.com/LommelFunction.html
8682	"""
8683	
8684	lommels2 = r"""

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/function_docs.py:8684
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
8683	
8684	lommels2 = r"""
8685	Gives the second Lommel function `S_{\mu,\nu}` or `s^{(2)}_{\mu,\nu}`
8686	
8687	.. math ::
8688	
8689	    S_{\mu,\nu}(z) = s_{\mu,\nu}(z) + 2^{\mu-1}
8690	        \Gamma\left(\tfrac{1}{2}(\mu-\nu+1)\right)
8691	        \Gamma\left(\tfrac{1}{2}(\mu+\nu+1)\right) \times
8692	
8693	        \left[\sin(\tfrac{1}{2}(\mu-\nu)\pi) J_{\nu}(z) -
8694	              \cos(\tfrac{1}{2}(\mu-\nu)\pi) Y_{\nu}(z)
8695	        \right]
8696	
8697	which solves the same differential equation as
8698	:func:`~mpmath.lommels1`.
8699	
8700	**Plots**
8701	
8702	.. literalinclude :: /plots/lommels2.py
8703	.. image :: /plots/lommels2.png
8704	
8705	**Examples**
8706	
8707	For large `|z|`, `S_{\mu,\nu} \sim z^{\mu-1}`::
8708	
8709	    >>> from mpmath import (mp, lommels2, power, struveh, bessely, power,
8710	    ...                     sqrt, pi, gamma, diff, mpf)
8711	    >>> mp.dps = 25; mp.pretty = True
8712	    >>> lommels2(10,2,30000)
8713	    1.968299831601008419949804e+40
8714	    >>> power(30000,9)
8715	    1.9683e+40
8716	
8717	A special value::
8718	
8719	    >>> u,v,z = 0.5, 0.125, mpf(0.75)
8720	    >>> lommels2(v,v,z)
8721	    0.9589683199624672099969765
8722	    >>> (struveh(v,z)-bessely(v,z))*power(2,v-1)*sqrt(pi)*gamma(v+0.5)
8723	    0.9589683199624672099969765
8724	
8725	Verifying the differential equation::
8726	
8727	    >>> f = lambda z: lommels2(u,v,z)
8728	    >>> z**2*diff(f,z,2) + z*diff(f,z) + (z**2-v**2)*f(z)
8729	    0.6495190528383289850727924
8730	    >>> z**(u+1)
8731	    0.6495190528383289850727924
8732	
8733	**References**
8734	
8735	1. [GradshteynRyzhik]_
8736	2. [Weisstein]_ http://mathworld.wolfram.com/LommelFunction.html
8737	"""
8738	
8739	appellf2 = r"""

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/function_docs.py:8925
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
8924	
8925	zeta = r"""
8926	Computes the Riemann zeta function
8927	
8928	.. math ::
8929	
8930	  \zeta(s) = 1+\frac{1}{2^s}+\frac{1}{3^s}+\frac{1}{4^s}+\ldots
8931	
8932	or, with `a \ne 1`, the more general Hurwitz zeta function
8933	
8934	.. math ::
8935	
8936	    \zeta(s,a) = \sum_{k=0}^\infty \frac{1}{(a+k)^s}.
8937	
8938	Optionally, ``zeta(s, a, n)`` computes the `n`-th derivative with
8939	respect to `s`,
8940	
8941	.. math ::
8942	
8943	    \zeta^{(n)}(s,a) = (-1)^n \sum_{k=0}^\infty \frac{\log^n(a+k)}{(a+k)^s}.
8944	
8945	Although these series only converge for `\Re(s) > 1`, the Riemann and Hurwitz
8946	zeta functions are defined through analytic continuation for arbitrary
8947	complex `s \ne 1` (`s = 1` is a pole).
8948	
8949	The implementation uses three algorithms: the Borwein algorithm for
8950	the Riemann zeta function when `s` is close to the real line;
8951	the Riemann-Siegel formula for the Riemann zeta function when `s` is
8952	large imaginary, and Euler-Maclaurin summation in all other cases.
8953	The reflection formula for `\Re(s) < 0` is implemented in some cases.
8954	The algorithm can be chosen with ``method = 'borwein'``,
8955	``method='riemann-siegel'`` or ``method = 'euler-maclaurin'``.
8956	
8957	The parameter `a` is usually a rational number `a = p/q`, and may be specified
8958	as such by passing an integer tuple `(p, q)`. Evaluation is supported for
8959	arbitrary complex `a`, but may be slow and/or inaccurate when `\Re(s) < 0` for
8960	nonrational `a` or when computing derivatives.
8961	
8962	**Examples**
8963	
8964	Some values of the Riemann zeta function::
8965	
8966	    >>> from mpmath import (mp, zeta, pi, inf, euler, j, zetazero, findroot,
8967	    ...                     chop, catalan, psi, ln, loggamma, fac, mpf, diff,
8968	    ...                     nsum)
8969	    >>> mp.dps = 25; mp.pretty = True
8970	    >>> zeta(2); pi**2 / 6
8971	    1.644934066848226436472415
8972	    1.644934066848226436472415
8973	    >>> zeta(0)
8974	    -0.5
8975	    >>> zeta(-1)
8976	    -0.08333333333333333333333333
8977	    >>> zeta(-2)
8978	    0.0
8979	
8980	For large positive `s`, `\zeta(s)` rapidly approaches 1::
8981	
8982	    >>> zeta(50)
8983	    1.000000000000000888178421
8984	    >>> zeta(100)
8985	    1.0
8986	    >>> zeta(inf)
8987	    1.0
8988	    >>> 1-sum((zeta(k)-1)/k for k in range(2,85)); +euler
8989	    0.5772156649015328606065121
8990	    0.5772156649015328606065121
8991	    >>> nsum(lambda k: zeta(k)-1, [2, inf])
8992	    1.0
8993	
8994	Evaluation is supported for complex `s` and `a`:
8995	
8996	    >>> zeta(-3+4j)
8997	    (-0.03373057338827757067584698 + 0.2774499251557093745297677j)
8998	    >>> zeta(2+3j, -1+j)
8999	    (389.6841230140842816370741 + 295.2674610150305334025962j)
9000	
9001	The Riemann zeta function has so-called nontrivial zeros on
9002	the critical line `s = 1/2 + it`::
9003	
9004	    >>> findroot(zeta, 0.5+14j); zetazero(1)
9005	    (0.5 + 14.13472514173469379045725j)
9006	    (0.5 + 14.13472514173469379045725j)
9007	    >>> findroot(zeta, 0.5+21j); zetazero(2)
9008	    (0.5 + 21.02203963877155499262848j)
9009	    (0.5 + 21.02203963877155499262848j)
9010	    >>> findroot(zeta, 0.5+25j); zetazero(3)
9011	    (0.5 + 25.01085758014568876321379j)
9012	    (0.5 + 25.01085758014568876321379j)
9013	    >>> chop(zeta(zetazero(10)))
9014	    0.0
9015	
9016	Evaluation on and near the critical line is supported for large
9017	heights `t` by means of the Riemann-Siegel formula (currently
9018	for `a = 1`, `n \le 4`)::
9019	
9020	    >>> zeta(0.5+100000j)
9021	    (1.073032014857753132114076 + 5.780848544363503984261041j)
9022	    >>> zeta(0.75+1000000j)
9023	    (0.9535316058375145020351559 + 0.9525945894834273060175651j)
9024	    >>> zeta(0.5+10000000j)
9025	    (11.45804061057709254500227 - 8.643437226836021723818215j)
9026	    >>> zeta(0.5+100000000j, derivative=1)
9027	    (51.12433106710194942681869 + 43.87221167872304520599418j)
9028	    >>> zeta(0.5+100000000j, derivative=2)
9029	    (-444.2760822795430400549229 - 896.3789978119185981665403j)
9030	    >>> zeta(0.5+100000000j, derivative=3)
9031	    (3230.72682687670422215339 + 14374.36950073615897616781j)
9032	    >>> zeta(0.5+100000000j, derivative=4)
9033	    (-11967.35573095046402130602 - 218945.7817789262839266148j)
9034	    >>> zeta(1+10000000j)    # off the line
9035	    (2.859846483332530337008882 + 0.491808047480981808903986j)
9036	    >>> zeta(1+10000000j, derivative=1)
9037	    (-4.333835494679647915673205 - 0.08405337962602933636096103j)
9038	    >>> zeta(1+10000000j, derivative=4)
9039	    (453.2764822702057701894278 - 581.963625832768189140995j)
9040	
9041	For investigation of the zeta function zeros, the Riemann-Siegel
9042	Z-function is often more convenient than working with the Riemann
9043	zeta function directly (see :func:`~mpmath.siegelz`).
9044	
9045	Some values of the Hurwitz zeta function::
9046	
9047	    >>> zeta(2, 3); -5./4 + pi**2/6
9048	    0.3949340668482264364724152
9049	    0.3949340668482264364724152
9050	    >>> zeta(2, (3,4)); pi**2 - 8*catalan
9051	    2.541879647671606498397663
9052	    2.541879647671606498397663
9053	
9054	For positive integer values of `s`, the Hurwitz zeta function is
9055	equivalent to a polygamma function (except for a normalizing factor)::
9056	
9057	    >>> zeta(4, (1,5)); psi(3, '1/5')/6
9058	    625.5408324774542966919938
9059	    625.5408324774542966919938
9060	
9061	Evaluation of derivatives::
9062	
9063	    >>> zeta(0, 3+4j, 1); loggamma(3+4j) - ln(2*pi)/2
9064	    (-2.675565317808456852310934 + 4.742664438034657928194889j)
9065	    (-2.675565317808456852310934 + 4.742664438034657928194889j)
9066	    >>> zeta(2, 1, 20)
9067	    2432902008176640000.000242
9068	    >>> zeta(3+4j, 5.5+2j, 4)
9069	    (-0.140075548947797130681075 - 0.3109263360275413251313634j)
9070	    >>> zeta(0.5+100000j, 1, 4)
9071	    (-10407.16081931495861539236 + 13777.78669862804508537384j)
9072	    >>> zeta(-100+0.5j, (1,3), derivative=4)
9073	    (4.007180821099823942702249e+79 + 4.916117957092593868321778e+78j)
9074	
9075	Generating a Taylor series at `s = 2` using derivatives::
9076	
9077	    >>> for k in range(11): print("%s * (s-2)^%i" % (zeta(2,1,k)/fac(k), k))
9078	    ...
9079	    1.644934066848226436472415 * (s-2)^0
9080	    -0.9375482543158437537025741 * (s-2)^1
9081	    0.9946401171494505117104293 * (s-2)^2
9082	    -1.000024300473840810940657 * (s-2)^3
9083	    1.000061933072352565457512 * (s-2)^4
9084	    -1.000006869443931806408941 * (s-2)^5
9085	    1.000000173233769531820592 * (s-2)^6
9086	    -0.9999999569989868493432399 * (s-2)^7
9087	    0.9999999937218844508684206 * (s-2)^8
9088	    -0.9999999996355013916608284 * (s-2)^9
9089	    1.000000000004610645020747 * (s-2)^10
9090	
9091	Evaluation at zero and for negative integer `s`::
9092	
9093	    >>> zeta(0, 10)
9094	    -9.5
9095	    >>> zeta(-2, (2,3)); mpf(1)/81
9096	    0.01234567901234567901234568
9097	    0.01234567901234567901234568
9098	    >>> zeta(-3+4j, (5,4))
9099	    (0.2899236037682695182085988 + 0.06561206166091757973112783j)
9100	    >>> zeta(-3.25, 1/pi)
9101	    -0.0005117269627574430494396877
9102	    >>> zeta(-3.5, pi, 1)
9103	    11.156360390440003294709
9104	    >>> zeta(-100.5, (8,3))
9105	    -4.68162300487989766727122e+77
9106	    >>> zeta(-10.5, (-8,3))
9107	    (-0.01521913704446246609237979 + 29907.72510874248161608216j)
9108	    >>> zeta(-1000.5, (-8,3))
9109	    (1.031911949062334538202567e+1770 + 1.519555750556794218804724e+426j)
9110	    >>> zeta(-1+j, 3+4j)
9111	    (-16.32988355630802510888631 - 22.17706465801374033261383j)
9112	    >>> zeta(-1+j, 3+4j, 2)
9113	    (32.48985276392056641594055 - 51.11604466157397267043655j)
9114	    >>> diff(lambda s: zeta(s, 3+4j), -1+j, 2)
9115	    (32.48985276392056641594055 - 51.11604466157397267043655j)
9116	
9117	**References**
9118	
9119	1. http://mathworld.wolfram.com/RiemannZetaFunction.html
9120	
9121	2. http://mathworld.wolfram.com/HurwitzZetaFunction.html
9122	
9123	3. [BorweinZeta]_
9124	
9125	"""
9126	
9127	dirichlet = r"""

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/function_docs.py:9202
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
9201	
9202	coulombf = r"""
9203	Calculates the regular Coulomb wave function
9204	
9205	.. math ::
9206	
9207	    F_l(\eta,z) = C_l(\eta) z^{l+1} e^{-iz} \,_1F_1(l+1-i\eta, 2l+2, 2iz)
9208	
9209	where the normalization constant `C_l(\eta)` is as calculated by
9210	:func:`~mpmath.coulombc`. This function solves the differential equation
9211	
9212	.. math ::
9213	
9214	    f''(z) + \left(1-\frac{2\eta}{z}-\frac{l(l+1)}{z^2}\right) f(z) = 0.
9215	
9216	A second linearly independent solution is given by the irregular
9217	Coulomb wave function `G_l(\eta,z)` (see :func:`~mpmath.coulombg`)
9218	and thus the general solution is
9219	`f(z) = C_1 F_l(\eta,z) + C_2 G_l(\eta,z)` for arbitrary
9220	constants `C_1`, `C_2`.
9221	Physically, the Coulomb wave functions give the radial solution
9222	to the Schrodinger equation for a point particle in a `1/z` potential; `z` is
9223	then the radius and `l`, `\eta` are quantum numbers.
9224	
9225	The Coulomb wave functions with real parameters are defined
9226	in Abramowitz & Stegun, section 14. However, all parameters are permitted
9227	to be complex in this implementation (see references).
9228	
9229	**Plots**
9230	
9231	.. literalinclude :: /plots/coulombf.py
9232	.. image :: /plots/coulombf.png
9233	.. literalinclude :: /plots/coulombf_c.py
9234	.. image :: /plots/coulombf_c.png
9235	
9236	**Examples**
9237	
9238	Evaluation is supported for arbitrary magnitudes of `z`::
9239	
9240	    >>> from mpmath import  (mp, coulombf, mpf, chop, diff, coulombg, sqrt,
9241	    ...                      exp, j, quad, coulombc, fac, inf)
9242	    >>> mp.dps = 25; mp.pretty = True
9243	    >>> coulombf(2, 1.5, 3.5)
9244	    0.4080998961088761187426445
9245	    >>> coulombf(-2, 1.5, 3.5)
9246	    0.7103040849492536747533465
9247	    >>> coulombf(2, 1.5, '1e-10')
9248	    4.143324917492256448770769e-33
9249	    >>> coulombf(2, 1.5, 1000)
9250	    0.4482623140325567050716179
9251	    >>> coulombf(2, 1.5, 10**10)
9252	    -0.066804196437694360046619
9253	
9254	Verifying the differential equation::
9255	
9256	    >>> l, eta, z = 2, 3, mpf(2.75)
9257	    >>> A, B = 1, 2
9258	    >>> f = lambda z: A*coulombf(l,eta,z) + B*coulombg(l,eta,z)
9259	    >>> chop(diff(f,z,2) + (1-2*eta/z - l*(l+1)/z**2)*f(z))
9260	    0.0
9261	
9262	A Wronskian relation satisfied by the Coulomb wave functions::
9263	
9264	    >>> l = 2
9265	    >>> eta = 1.5
9266	    >>> F = lambda z: coulombf(l,eta,z)
9267	    >>> G = lambda z: coulombg(l,eta,z)
9268	    >>> for z in [3.5, -1, 2+3j]:
9269	    ...     chop(diff(F,z)*G(z) - F(z)*diff(G,z))
9270	    ...
9271	    1.0
9272	    1.0
9273	    1.0
9274	
9275	Another Wronskian relation::
9276	
9277	    >>> F = coulombf
9278	    >>> G = coulombg
9279	    >>> for z in [3.5, -1, 2+3j]:
9280	    ...     chop(F(l-1,eta,z)*G(l,eta,z)-F(l,eta,z)*G(l-1,eta,z) - l/sqrt(l**2+eta**2))
9281	    ...
9282	    0.0
9283	    0.0
9284	    0.0
9285	
9286	An integral identity connecting the regular and irregular wave functions::
9287	
9288	    >>> l, eta, z = 4+j, 2-j, 5+2j
9289	    >>> coulombf(l,eta,z) + j*coulombg(l,eta,z)
9290	    (0.7997977752284033239714479 + 0.9294486669502295512503127j)
9291	    >>> g = lambda t: exp(-t)*t**(l-j*eta)*(t+2*j*z)**(l+j*eta)
9292	    >>> j*exp(-j*z)*z**(-l)/fac(2*l+1)/coulombc(l,eta)*quad(g, [0,inf])
9293	    (0.7997977752284033239714479 + 0.9294486669502295512503127j)
9294	
9295	Some test case with complex parameters, taken from Michel [2]::
9296	
9297	    >>> mp.dps = 15
9298	    >>> coulombf(1+0.1j, 50+50j, 100.156)
9299	    (-1.02107292320897e+15 - 2.83675545731519e+15j)
9300	    >>> coulombg(1+0.1j, 50+50j, 100.156)
9301	    (2.83675545731519e+15 - 1.02107292320897e+15j)
9302	    >>> coulombf(1e-5j, 10+1e-5j, 0.1+1e-6j)
9303	    (4.30566371247811e-14 - 9.03347835361657e-19j)
9304	    >>> coulombg(1e-5j, 10+1e-5j, 0.1+1e-6j)
9305	    (778709182061.134 + 18418936.2660553j)
9306	
9307	The following reproduces a table in Abramowitz & Stegun, at twice
9308	the precision::
9309	
9310	    >>> mp.dps = 10
9311	    >>> eta = 2; z = 5
9312	    >>> for l in [5, 4, 3, 2, 1, 0]:
9313	    ...     print("%s %s %s" % (l, coulombf(l,eta,z),
9314	    ...         diff(lambda z: coulombf(l,eta,z), z)))
9315	    ...
9316	    5 0.09079533488 0.1042553261
9317	    4 0.2148205331 0.2029591779
9318	    3 0.4313159311 0.320534053
9319	    2 0.7212774133 0.3952408216
9320	    1 0.9935056752 0.3708676452
9321	    0 1.143337392 0.2937960375
9322	
9323	**References**
9324	
9325	1. I.J. Thompson & A.R. Barnett, "Coulomb and Bessel Functions of Complex
9326	   Arguments and Order", J. Comp. Phys., vol 64, no. 2, June 1986.
9327	
9328	2. N. Michel, "Precise Coulomb wave functions for a wide range of
9329	   complex `l`, `\eta` and `z`", http://arxiv.org/abs/physics/0702051v1
9330	
9331	"""
9332	
9333	coulombg = r"""

--------------------------------------------------
>> Issue: [B818:urlopen] urllib.request.urlopen
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/functions/zeta.py:186
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b818_urlopen.html
185	    import urllib
186	    d = urllib.urlopen(url)
187	    L = [float(x) for x in d.readlines()]

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/functions/zeta.py:193
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
192	@defun
193	def oldzetazero(ctx, n, url='http://www.dtc.umn.edu/~odlyzko/zeta_tables/zeros1'):
194	    n = int(n)

--------------------------------------------------
>> Issue: [B800:exec_used] exec
   Severity: Medium   Confidence: High
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/libmp/libhyper.py:288
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b800_exec_used.html
287	
288	    exec(source, globals(), namespace)
289	

--------------------------------------------------
>> Issue: [B841:cdll] ctypes.CDLL
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/mpmath-1.4.0a4/mpmath-1.4.0a4/mpmath/tests/test_format.py:819
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b841_cdll.html
818	try:
819	    libc = ctypes.CDLL("libc.so.6")
820	except OSError:

--------------------------------------------------

Code scanned:
	Total lines of code: 50398
	Total lines skipped (#nosec): 0

Run metrics:
	Total issues (by severity):
		Undefined: 0.0
		Low: 0.0
		Medium: 30.0
		High: 3.0
	Total issues (by confidence):
		Undefined: 0.0
		Low: 0.0
		Medium: 31.0
		High: 2.0
Files skipped (0):
