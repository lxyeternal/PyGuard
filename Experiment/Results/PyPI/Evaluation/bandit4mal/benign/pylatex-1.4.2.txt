Run started:2025-05-25 13:03:42.634500

Test results:
>> Issue: [B836:rmtree] shutil.rmtree
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/pylatex-1.4.2/PyLaTeX-1.4.2/pylatex/utils.py:353
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b836_rmtree.html
352	    if _tmp_path:
353	        shutil.rmtree(_tmp_path)
354	        _tmp_path = None

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/pylatex-1.4.2/PyLaTeX-1.4.2/setup.py:110
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
109	    description="A Python library for creating LaTeX files and snippets",
110	    long_description=open("README.rst").read(),
111	    package_dir={"": source_dir},

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/pylatex-1.4.2/PyLaTeX-1.4.2/setup.py:113
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
112	    packages=["pylatex", "pylatex.base_classes"],
113	    url="https://github.com/JelteF/PyLaTeX",
114	    license="MIT",

--------------------------------------------------
>> Issue: [B836:rmtree] shutil.rmtree
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/pylatex-1.4.2/PyLaTeX-1.4.2/tests/test_jobname.py:25
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b836_rmtree.html
24	    assert os.path.isfile(path + ".pdf")
25	    shutil.rmtree(folder)
26	

--------------------------------------------------
>> Issue: [B836:rmtree] shutil.rmtree
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/pylatex-1.4.2/PyLaTeX-1.4.2/tests/test_jobname.py:36
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b836_rmtree.html
35	
36	    shutil.rmtree(folder)

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/pylatex-1.4.2/PyLaTeX-1.4.2/versioneer.py:508
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
507	
508	LONG_VERSION_PY['git'] = r'''
509	# This file helps to compute a version number in source trees obtained from
510	# git-archive tarball (such as those provided by githubs download-from-tag
511	# feature). Distribution tarballs (built by setup.py sdist) and build
512	# directories (produced by setup.py build) will contain a much shorter file
513	# that just contains the computed version number.
514	
515	# This file is released into the public domain.
516	# Generated by versioneer-0.29
517	# https://github.com/python-versioneer/python-versioneer
518	
519	"""Git implementation of _version.py."""
520	
521	import errno
522	import os
523	import re
524	import subprocess
525	import sys
526	from typing import Any, Callable, Dict, List, Optional, Tuple
527	import functools
528	
529	
530	def get_keywords() -> Dict[str, str]:
531	    """Get the keywords needed to look up the version information."""
532	    # these strings will be replaced by git during git-archive.
533	    # setup.py/versioneer.py will grep for the variable names, so they must
534	    # each be defined on a line of their own. _version.py will just call
535	    # get_keywords().
536	    git_refnames = "%(DOLLAR)sFormat:%%d%(DOLLAR)s"
537	    git_full = "%(DOLLAR)sFormat:%%H%(DOLLAR)s"
538	    git_date = "%(DOLLAR)sFormat:%%ci%(DOLLAR)s"
539	    keywords = {"refnames": git_refnames, "full": git_full, "date": git_date}
540	    return keywords
541	
542	
543	class VersioneerConfig:
544	    """Container for Versioneer configuration parameters."""
545	
546	    VCS: str
547	    style: str
548	    tag_prefix: str
549	    parentdir_prefix: str
550	    versionfile_source: str
551	    verbose: bool
552	
553	
554	def get_config() -> VersioneerConfig:
555	    """Create, populate and return the VersioneerConfig() object."""
556	    # these strings are filled in when 'setup.py versioneer' creates
557	    # _version.py
558	    cfg = VersioneerConfig()
559	    cfg.VCS = "git"
560	    cfg.style = "%(STYLE)s"
561	    cfg.tag_prefix = "%(TAG_PREFIX)s"
562	    cfg.parentdir_prefix = "%(PARENTDIR_PREFIX)s"
563	    cfg.versionfile_source = "%(VERSIONFILE_SOURCE)s"
564	    cfg.verbose = False
565	    return cfg
566	
567	
568	class NotThisMethod(Exception):
569	    """Exception raised if a method is not valid for the current scenario."""
570	
571	
572	LONG_VERSION_PY: Dict[str, str] = {}
573	HANDLERS: Dict[str, Dict[str, Callable]] = {}
574	
575	
576	def register_vcs_handler(vcs: str, method: str) -> Callable:  # decorator
577	    """Create decorator to mark a method as the handler of a VCS."""
578	    def decorate(f: Callable) -> Callable:
579	        """Store f in HANDLERS[vcs][method]."""
580	        if vcs not in HANDLERS:
581	            HANDLERS[vcs] = {}
582	        HANDLERS[vcs][method] = f
583	        return f
584	    return decorate
585	
586	
587	def run_command(
588	    commands: List[str],
589	    args: List[str],
590	    cwd: Optional[str] = None,
591	    verbose: bool = False,
592	    hide_stderr: bool = False,
593	    env: Optional[Dict[str, str]] = None,
594	) -> Tuple[Optional[str], Optional[int]]:
595	    """Call the given command(s)."""
596	    assert isinstance(commands, list)
597	    process = None
598	
599	    popen_kwargs: Dict[str, Any] = {}
600	    if sys.platform == "win32":
601	        # This hides the console window if pythonw.exe is used
602	        startupinfo = subprocess.STARTUPINFO()
603	        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
604	        popen_kwargs["startupinfo"] = startupinfo
605	
606	    for command in commands:
607	        try:
608	            dispcmd = str([command] + args)
609	            # remember shell=False, so use git.cmd on windows, not just git
610	            process = subprocess.Popen([command] + args, cwd=cwd, env=env,
611	                                       stdout=subprocess.PIPE,
612	                                       stderr=(subprocess.PIPE if hide_stderr
613	                                               else None), **popen_kwargs)
614	            break
615	        except OSError as e:
616	            if e.errno == errno.ENOENT:
617	                continue
618	            if verbose:
619	                print("unable to run %%s" %% dispcmd)
620	                print(e)
621	            return None, None
622	    else:
623	        if verbose:
624	            print("unable to find command, tried %%s" %% (commands,))
625	        return None, None
626	    stdout = process.communicate()[0].strip().decode()
627	    if process.returncode != 0:
628	        if verbose:
629	            print("unable to run %%s (error)" %% dispcmd)
630	            print("stdout was %%s" %% stdout)
631	        return None, process.returncode
632	    return stdout, process.returncode
633	
634	
635	def versions_from_parentdir(
636	    parentdir_prefix: str,
637	    root: str,
638	    verbose: bool,
639	) -> Dict[str, Any]:
640	    """Try to determine the version from the parent directory name.
641	
642	    Source tarballs conventionally unpack into a directory that includes both
643	    the project name and a version string. We will also support searching up
644	    two directory levels for an appropriately named parent directory
645	    """
646	    rootdirs = []
647	
648	    for _ in range(3):
649	        dirname = os.path.basename(root)
650	        if dirname.startswith(parentdir_prefix):
651	            return {"version": dirname[len(parentdir_prefix):],
652	                    "full-revisionid": None,
653	                    "dirty": False, "error": None, "date": None}
654	        rootdirs.append(root)
655	        root = os.path.dirname(root)  # up a level
656	
657	    if verbose:
658	        print("Tried directories %%s but none started with prefix %%s" %%
659	              (str(rootdirs), parentdir_prefix))
660	    raise NotThisMethod("rootdir doesn't start with parentdir_prefix")
661	
662	
663	@register_vcs_handler("git", "get_keywords")
664	def git_get_keywords(versionfile_abs: str) -> Dict[str, str]:
665	    """Extract version information from the given file."""
666	    # the code embedded in _version.py can just fetch the value of these
667	    # keywords. When used from setup.py, we don't want to import _version.py,
668	    # so we do it with a regexp instead. This function is not used from
669	    # _version.py.
670	    keywords: Dict[str, str] = {}
671	    try:
672	        with open(versionfile_abs, "r") as fobj:
673	            for line in fobj:
674	                if line.strip().startswith("git_refnames ="):
675	                    mo = re.search(r'=\s*"(.*)"', line)
676	                    if mo:
677	                        keywords["refnames"] = mo.group(1)
678	                if line.strip().startswith("git_full ="):
679	                    mo = re.search(r'=\s*"(.*)"', line)
680	                    if mo:
681	                        keywords["full"] = mo.group(1)
682	                if line.strip().startswith("git_date ="):
683	                    mo = re.search(r'=\s*"(.*)"', line)
684	                    if mo:
685	                        keywords["date"] = mo.group(1)
686	    except OSError:
687	        pass
688	    return keywords
689	
690	
691	@register_vcs_handler("git", "keywords")
692	def git_versions_from_keywords(
693	    keywords: Dict[str, str],
694	    tag_prefix: str,
695	    verbose: bool,
696	) -> Dict[str, Any]:
697	    """Get version information from git keywords."""
698	    if "refnames" not in keywords:
699	        raise NotThisMethod("Short version file found")
700	    date = keywords.get("date")
701	    if date is not None:
702	        # Use only the last line.  Previous lines may contain GPG signature
703	        # information.
704	        date = date.splitlines()[-1]
705	
706	        # git-2.2.0 added "%%cI", which expands to an ISO-8601 -compliant
707	        # datestamp. However we prefer "%%ci" (which expands to an "ISO-8601
708	        # -like" string, which we must then edit to make compliant), because
709	        # it's been around since git-1.5.3, and it's too difficult to
710	        # discover which version we're using, or to work around using an
711	        # older one.
712	        date = date.strip().replace(" ", "T", 1).replace(" ", "", 1)
713	    refnames = keywords["refnames"].strip()
714	    if refnames.startswith("$Format"):
715	        if verbose:
716	            print("keywords are unexpanded, not using")
717	        raise NotThisMethod("unexpanded keywords, not a git-archive tarball")
718	    refs = {r.strip() for r in refnames.strip("()").split(",")}
719	    # starting in git-1.8.3, tags are listed as "tag: foo-1.0" instead of
720	    # just "foo-1.0". If we see a "tag: " prefix, prefer those.
721	    TAG = "tag: "
722	    tags = {r[len(TAG):] for r in refs if r.startswith(TAG)}
723	    if not tags:
724	        # Either we're using git < 1.8.3, or there really are no tags. We use
725	        # a heuristic: assume all version tags have a digit. The old git %%d
726	        # expansion behaves like git log --decorate=short and strips out the
727	        # refs/heads/ and refs/tags/ prefixes that would let us distinguish
728	        # between branches and tags. By ignoring refnames without digits, we
729	        # filter out many common branch names like "release" and
730	        # "stabilization", as well as "HEAD" and "master".
731	        tags = {r for r in refs if re.search(r'\d', r)}
732	        if verbose:
733	            print("discarding '%%s', no digits" %% ",".join(refs - tags))
734	    if verbose:
735	        print("likely tags: %%s" %% ",".join(sorted(tags)))
736	    for ref in sorted(tags):
737	        # sorting will prefer e.g. "2.0" over "2.0rc1"
738	        if ref.startswith(tag_prefix):
739	            r = ref[len(tag_prefix):]
740	            # Filter out refs that exactly match prefix or that don't start
741	            # with a number once the prefix is stripped (mostly a concern
742	            # when prefix is '')
743	            if not re.match(r'\d', r):
744	                continue
745	            if verbose:
746	                print("picking %%s" %% r)
747	            return {"version": r,
748	                    "full-revisionid": keywords["full"].strip(),
749	                    "dirty": False, "error": None,
750	                    "date": date}
751	    # no suitable tags, so version is "0+unknown", but full hex is still there
752	    if verbose:
753	        print("no suitable tags, using unknown + full revision id")
754	    return {"version": "0+unknown",
755	            "full-revisionid": keywords["full"].strip(),
756	            "dirty": False, "error": "no suitable tags", "date": None}
757	
758	
759	@register_vcs_handler("git", "pieces_from_vcs")
760	def git_pieces_from_vcs(
761	    tag_prefix: str,
762	    root: str,
763	    verbose: bool,
764	    runner: Callable = run_command
765	) -> Dict[str, Any]:
766	    """Get version from 'git describe' in the root of the source tree.
767	
768	    This only gets called if the git-archive 'subst' keywords were *not*
769	    expanded, and _version.py hasn't already been rewritten with a short
770	    version string, meaning we're inside a checked out source tree.
771	    """
772	    GITS = ["git"]
773	    if sys.platform == "win32":
774	        GITS = ["git.cmd", "git.exe"]
775	
776	    # GIT_DIR can interfere with correct operation of Versioneer.
777	    # It may be intended to be passed to the Versioneer-versioned project,
778	    # but that should not change where we get our version from.
779	    env = os.environ.copy()
780	    env.pop("GIT_DIR", None)
781	    runner = functools.partial(runner, env=env)
782	
783	    _, rc = runner(GITS, ["rev-parse", "--git-dir"], cwd=root,
784	                   hide_stderr=not verbose)
785	    if rc != 0:
786	        if verbose:
787	            print("Directory %%s not under git control" %% root)
788	        raise NotThisMethod("'git rev-parse --git-dir' returned error")
789	
790	    # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]
791	    # if there isn't one, this yields HEX[-dirty] (no NUM)
792	    describe_out, rc = runner(GITS, [
793	        "describe", "--tags", "--dirty", "--always", "--long",
794	        "--match", f"{tag_prefix}[[:digit:]]*"
795	    ], cwd=root)
796	    # --long was added in git-1.5.5
797	    if describe_out is None:
798	        raise NotThisMethod("'git describe' failed")
799	    describe_out = describe_out.strip()
800	    full_out, rc = runner(GITS, ["rev-parse", "HEAD"], cwd=root)
801	    if full_out is None:
802	        raise NotThisMethod("'git rev-parse' failed")
803	    full_out = full_out.strip()
804	
805	    pieces: Dict[str, Any] = {}
806	    pieces["long"] = full_out
807	    pieces["short"] = full_out[:7]  # maybe improved later
808	    pieces["error"] = None
809	
810	    branch_name, rc = runner(GITS, ["rev-parse", "--abbrev-ref", "HEAD"],
811	                             cwd=root)
812	    # --abbrev-ref was added in git-1.6.3
813	    if rc != 0 or branch_name is None:
814	        raise NotThisMethod("'git rev-parse --abbrev-ref' returned error")
815	    branch_name = branch_name.strip()
816	
817	    if branch_name == "HEAD":
818	        # If we aren't exactly on a branch, pick a branch which represents
819	        # the current commit. If all else fails, we are on a branchless
820	        # commit.
821	        branches, rc = runner(GITS, ["branch", "--contains"], cwd=root)
822	        # --contains was added in git-1.5.4
823	        if rc != 0 or branches is None:
824	            raise NotThisMethod("'git branch --contains' returned error")
825	        branches = branches.split("\n")
826	
827	        # Remove the first line if we're running detached
828	        if "(" in branches[0]:
829	            branches.pop(0)
830	
831	        # Strip off the leading "* " from the list of branches.
832	        branches = [branch[2:] for branch in branches]
833	        if "master" in branches:
834	            branch_name = "master"
835	        elif not branches:
836	            branch_name = None
837	        else:
838	            # Pick the first branch that is returned. Good or bad.
839	            branch_name = branches[0]
840	
841	    pieces["branch"] = branch_name
842	
843	    # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]
844	    # TAG might have hyphens.
845	    git_describe = describe_out
846	
847	    # look for -dirty suffix
848	    dirty = git_describe.endswith("-dirty")
849	    pieces["dirty"] = dirty
850	    if dirty:
851	        git_describe = git_describe[:git_describe.rindex("-dirty")]
852	
853	    # now we have TAG-NUM-gHEX or HEX
854	
855	    if "-" in git_describe:
856	        # TAG-NUM-gHEX
857	        mo = re.search(r'^(.+)-(\d+)-g([0-9a-f]+)$', git_describe)
858	        if not mo:
859	            # unparsable. Maybe git-describe is misbehaving?
860	            pieces["error"] = ("unable to parse git-describe output: '%%s'"
861	                               %% describe_out)
862	            return pieces
863	
864	        # tag
865	        full_tag = mo.group(1)
866	        if not full_tag.startswith(tag_prefix):
867	            if verbose:
868	                fmt = "tag '%%s' doesn't start with prefix '%%s'"
869	                print(fmt %% (full_tag, tag_prefix))
870	            pieces["error"] = ("tag '%%s' doesn't start with prefix '%%s'"
871	                               %% (full_tag, tag_prefix))
872	            return pieces
873	        pieces["closest-tag"] = full_tag[len(tag_prefix):]
874	
875	        # distance: number of commits since tag
876	        pieces["distance"] = int(mo.group(2))
877	
878	        # commit: short hex revision ID
879	        pieces["short"] = mo.group(3)
880	
881	    else:
882	        # HEX: no tags
883	        pieces["closest-tag"] = None
884	        out, rc = runner(GITS, ["rev-list", "HEAD", "--left-right"], cwd=root)
885	        pieces["distance"] = len(out.split())  # total number of commits
886	
887	    # commit date: see ISO-8601 comment in git_versions_from_keywords()
888	    date = runner(GITS, ["show", "-s", "--format=%%ci", "HEAD"], cwd=root)[0].strip()
889	    # Use only the last line.  Previous lines may contain GPG signature
890	    # information.
891	    date = date.splitlines()[-1]
892	    pieces["date"] = date.strip().replace(" ", "T", 1).replace(" ", "", 1)
893	
894	    return pieces
895	
896	
897	def plus_or_dot(pieces: Dict[str, Any]) -> str:
898	    """Return a + if we don't already have one, else return a ."""
899	    if "+" in pieces.get("closest-tag", ""):
900	        return "."
901	    return "+"
902	
903	
904	def render_pep440(pieces: Dict[str, Any]) -> str:
905	    """Build up version string, with post-release "local version identifier".
906	
907	    Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you
908	    get a tagged build and then dirty it, you'll get TAG+0.gHEX.dirty
909	
910	    Exceptions:
911	    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]
912	    """
913	    if pieces["closest-tag"]:
914	        rendered = pieces["closest-tag"]
915	        if pieces["distance"] or pieces["dirty"]:
916	            rendered += plus_or_dot(pieces)
917	            rendered += "%%d.g%%s" %% (pieces["distance"], pieces["short"])
918	            if pieces["dirty"]:
919	                rendered += ".dirty"
920	    else:
921	        # exception #1
922	        rendered = "0+untagged.%%d.g%%s" %% (pieces["distance"],
923	                                          pieces["short"])
924	        if pieces["dirty"]:
925	            rendered += ".dirty"
926	    return rendered
927	
928	
929	def render_pep440_branch(pieces: Dict[str, Any]) -> str:
930	    """TAG[[.dev0]+DISTANCE.gHEX[.dirty]] .
931	
932	    The ".dev0" means not master branch. Note that .dev0 sorts backwards
933	    (a feature branch will appear "older" than the master branch).
934	
935	    Exceptions:
936	    1: no tags. 0[.dev0]+untagged.DISTANCE.gHEX[.dirty]
937	    """
938	    if pieces["closest-tag"]:
939	        rendered = pieces["closest-tag"]
940	        if pieces["distance"] or pieces["dirty"]:
941	            if pieces["branch"] != "master":
942	                rendered += ".dev0"
943	            rendered += plus_or_dot(pieces)
944	            rendered += "%%d.g%%s" %% (pieces["distance"], pieces["short"])
945	            if pieces["dirty"]:
946	                rendered += ".dirty"
947	    else:
948	        # exception #1
949	        rendered = "0"
950	        if pieces["branch"] != "master":
951	            rendered += ".dev0"
952	        rendered += "+untagged.%%d.g%%s" %% (pieces["distance"],
953	                                          pieces["short"])
954	        if pieces["dirty"]:
955	            rendered += ".dirty"
956	    return rendered
957	
958	
959	def pep440_split_post(ver: str) -> Tuple[str, Optional[int]]:
960	    """Split pep440 version string at the post-release segment.
961	
962	    Returns the release segments before the post-release and the
963	    post-release version number (or -1 if no post-release segment is present).
964	    """
965	    vc = str.split(ver, ".post")
966	    return vc[0], int(vc[1] or 0) if len(vc) == 2 else None
967	
968	
969	def render_pep440_pre(pieces: Dict[str, Any]) -> str:
970	    """TAG[.postN.devDISTANCE] -- No -dirty.
971	
972	    Exceptions:
973	    1: no tags. 0.post0.devDISTANCE
974	    """
975	    if pieces["closest-tag"]:
976	        if pieces["distance"]:
977	            # update the post release segment
978	            tag_version, post_version = pep440_split_post(pieces["closest-tag"])
979	            rendered = tag_version
980	            if post_version is not None:
981	                rendered += ".post%%d.dev%%d" %% (post_version + 1, pieces["distance"])
982	            else:
983	                rendered += ".post0.dev%%d" %% (pieces["distance"])
984	        else:
985	            # no commits, use the tag as the version
986	            rendered = pieces["closest-tag"]
987	    else:
988	        # exception #1
989	        rendered = "0.post0.dev%%d" %% pieces["distance"]
990	    return rendered
991	
992	
993	def render_pep440_post(pieces: Dict[str, Any]) -> str:
994	    """TAG[.postDISTANCE[.dev0]+gHEX] .
995	
996	    The ".dev0" means dirty. Note that .dev0 sorts backwards
997	    (a dirty tree will appear "older" than the corresponding clean one),
998	    but you shouldn't be releasing software with -dirty anyways.
999	
1000	    Exceptions:
1001	    1: no tags. 0.postDISTANCE[.dev0]
1002	    """
1003	    if pieces["closest-tag"]:
1004	        rendered = pieces["closest-tag"]
1005	        if pieces["distance"] or pieces["dirty"]:
1006	            rendered += ".post%%d" %% pieces["distance"]
1007	            if pieces["dirty"]:
1008	                rendered += ".dev0"
1009	            rendered += plus_or_dot(pieces)
1010	            rendered += "g%%s" %% pieces["short"]
1011	    else:
1012	        # exception #1
1013	        rendered = "0.post%%d" %% pieces["distance"]
1014	        if pieces["dirty"]:
1015	            rendered += ".dev0"
1016	        rendered += "+g%%s" %% pieces["short"]
1017	    return rendered
1018	
1019	
1020	def render_pep440_post_branch(pieces: Dict[str, Any]) -> str:
1021	    """TAG[.postDISTANCE[.dev0]+gHEX[.dirty]] .
1022	
1023	    The ".dev0" means not master branch.
1024	
1025	    Exceptions:
1026	    1: no tags. 0.postDISTANCE[.dev0]+gHEX[.dirty]
1027	    """
1028	    if pieces["closest-tag"]:
1029	        rendered = pieces["closest-tag"]
1030	        if pieces["distance"] or pieces["dirty"]:
1031	            rendered += ".post%%d" %% pieces["distance"]
1032	            if pieces["branch"] != "master":
1033	                rendered += ".dev0"
1034	            rendered += plus_or_dot(pieces)
1035	            rendered += "g%%s" %% pieces["short"]
1036	            if pieces["dirty"]:
1037	                rendered += ".dirty"
1038	    else:
1039	        # exception #1
1040	        rendered = "0.post%%d" %% pieces["distance"]
1041	        if pieces["branch"] != "master":
1042	            rendered += ".dev0"
1043	        rendered += "+g%%s" %% pieces["short"]
1044	        if pieces["dirty"]:
1045	            rendered += ".dirty"
1046	    return rendered
1047	
1048	
1049	def render_pep440_old(pieces: Dict[str, Any]) -> str:
1050	    """TAG[.postDISTANCE[.dev0]] .
1051	
1052	    The ".dev0" means dirty.
1053	
1054	    Exceptions:
1055	    1: no tags. 0.postDISTANCE[.dev0]
1056	    """
1057	    if pieces["closest-tag"]:
1058	        rendered = pieces["closest-tag"]
1059	        if pieces["distance"] or pieces["dirty"]:
1060	            rendered += ".post%%d" %% pieces["distance"]
1061	            if pieces["dirty"]:
1062	                rendered += ".dev0"
1063	    else:
1064	        # exception #1
1065	        rendered = "0.post%%d" %% pieces["distance"]
1066	        if pieces["dirty"]:
1067	            rendered += ".dev0"
1068	    return rendered
1069	
1070	
1071	def render_git_describe(pieces: Dict[str, Any]) -> str:
1072	    """TAG[-DISTANCE-gHEX][-dirty].
1073	
1074	    Like 'git describe --tags --dirty --always'.
1075	
1076	    Exceptions:
1077	    1: no tags. HEX[-dirty]  (note: no 'g' prefix)
1078	    """
1079	    if pieces["closest-tag"]:
1080	        rendered = pieces["closest-tag"]
1081	        if pieces["distance"]:
1082	            rendered += "-%%d-g%%s" %% (pieces["distance"], pieces["short"])
1083	    else:
1084	        # exception #1
1085	        rendered = pieces["short"]
1086	    if pieces["dirty"]:
1087	        rendered += "-dirty"
1088	    return rendered
1089	
1090	
1091	def render_git_describe_long(pieces: Dict[str, Any]) -> str:
1092	    """TAG-DISTANCE-gHEX[-dirty].
1093	
1094	    Like 'git describe --tags --dirty --always -long'.
1095	    The distance/hash is unconditional.
1096	
1097	    Exceptions:
1098	    1: no tags. HEX[-dirty]  (note: no 'g' prefix)
1099	    """
1100	    if pieces["closest-tag"]:
1101	        rendered = pieces["closest-tag"]
1102	        rendered += "-%%d-g%%s" %% (pieces["distance"], pieces["short"])
1103	    else:
1104	        # exception #1
1105	        rendered = pieces["short"]
1106	    if pieces["dirty"]:
1107	        rendered += "-dirty"
1108	    return rendered
1109	
1110	
1111	def render(pieces: Dict[str, Any], style: str) -> Dict[str, Any]:
1112	    """Render the given version pieces into the requested style."""
1113	    if pieces["error"]:
1114	        return {"version": "unknown",
1115	                "full-revisionid": pieces.get("long"),
1116	                "dirty": None,
1117	                "error": pieces["error"],
1118	                "date": None}
1119	
1120	    if not style or style == "default":
1121	        style = "pep440"  # the default
1122	
1123	    if style == "pep440":
1124	        rendered = render_pep440(pieces)
1125	    elif style == "pep440-branch":
1126	        rendered = render_pep440_branch(pieces)
1127	    elif style == "pep440-pre":
1128	        rendered = render_pep440_pre(pieces)
1129	    elif style == "pep440-post":
1130	        rendered = render_pep440_post(pieces)
1131	    elif style == "pep440-post-branch":
1132	        rendered = render_pep440_post_branch(pieces)
1133	    elif style == "pep440-old":
1134	        rendered = render_pep440_old(pieces)
1135	    elif style == "git-describe":
1136	        rendered = render_git_describe(pieces)
1137	    elif style == "git-describe-long":
1138	        rendered = render_git_describe_long(pieces)
1139	    else:
1140	        raise ValueError("unknown style '%%s'" %% style)
1141	
1142	    return {"version": rendered, "full-revisionid": pieces["long"],
1143	            "dirty": pieces["dirty"], "error": None,
1144	            "date": pieces.get("date")}
1145	
1146	
1147	def get_versions() -> Dict[str, Any]:
1148	    """Get version information or return default if unable to do so."""
1149	    # I am in _version.py, which lives at ROOT/VERSIONFILE_SOURCE. If we have
1150	    # __file__, we can work backwards from there to the root. Some
1151	    # py2exe/bbfreeze/non-CPython implementations don't do __file__, in which
1152	    # case we can only use expanded keywords.
1153	
1154	    cfg = get_config()
1155	    verbose = cfg.verbose
1156	
1157	    try:
1158	        return git_versions_from_keywords(get_keywords(), cfg.tag_prefix,
1159	                                          verbose)
1160	    except NotThisMethod:
1161	        pass
1162	
1163	    try:
1164	        root = os.path.realpath(__file__)
1165	        # versionfile_source is the relative path from the top of the source
1166	        # tree (where the .git directory might live) to this file. Invert
1167	        # this to find the root from __file__.
1168	        for _ in cfg.versionfile_source.split('/'):
1169	            root = os.path.dirname(root)
1170	    except NameError:
1171	        return {"version": "0+unknown", "full-revisionid": None,
1172	                "dirty": None,
1173	                "error": "unable to find root of source tree",
1174	                "date": None}
1175	
1176	    try:
1177	        pieces = git_pieces_from_vcs(cfg.tag_prefix, root, verbose)
1178	        return render(pieces, cfg.style)
1179	    except NotThisMethod:
1180	        pass
1181	
1182	    try:
1183	        if cfg.parentdir_prefix:
1184	            return versions_from_parentdir(cfg.parentdir_prefix, root, verbose)
1185	    except NotThisMethod:
1186	        pass
1187	
1188	    return {"version": "0+unknown", "full-revisionid": None,
1189	            "dirty": None,
1190	            "error": "unable to compute version", "date": None}
1191	'''
1192	
1193	
1194	@register_vcs_handler("git", "get_keywords")
1195	def git_get_keywords(versionfile_abs: str) -> Dict[str, str]:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/pylatex-1.4.2/PyLaTeX-1.4.2/versioneer.py:1461
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1460	        with open(".gitattributes", "a+") as fobj:
1461	            fobj.write(f"{versionfile_source} export-subst\n")
1462	        files.append(".gitattributes")

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/pylatex-1.4.2/PyLaTeX-1.4.2/versioneer.py:1516
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
1515	        with open(filename) as f:
1516	            contents = f.read()
1517	    except OSError:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/pylatex-1.4.2/PyLaTeX-1.4.2/versioneer.py:1534
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1533	    with open(filename, "w") as f:
1534	        f.write(SHORT_VERSION_PY % contents)
1535	

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/pylatex-1.4.2/PyLaTeX-1.4.2/versioneer.py:2018
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2017	                    LONG = LONG_VERSION_PY[cfg.VCS]
2018	                    f.write(LONG %
2019	                            {"DOLLAR": "$",
2020	                             "STYLE": cfg.style,
2021	                             "TAG_PREFIX": cfg.tag_prefix,
2022	                             "PARENTDIR_PREFIX": cfg.parentdir_prefix,
2023	                             "VERSIONFILE_SOURCE": cfg.versionfile_source,
2024	                             })

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/pylatex-1.4.2/PyLaTeX-1.4.2/versioneer.py:2047
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2046	                    LONG = LONG_VERSION_PY[cfg.VCS]
2047	                    f.write(LONG %
2048	                            {"DOLLAR": "$",
2049	                             "STYLE": cfg.style,
2050	                             "TAG_PREFIX": cfg.tag_prefix,
2051	                             "PARENTDIR_PREFIX": cfg.parentdir_prefix,
2052	                             "VERSIONFILE_SOURCE": cfg.versionfile_source,
2053	                             })

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/pylatex-1.4.2/PyLaTeX-1.4.2/versioneer.py:2089
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2088	            with open(manifest_filename, 'w') as fobj:
2089	                fobj.write('\n'.join(normalized))
2090	

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/pylatex-1.4.2/PyLaTeX-1.4.2/versioneer.py:2184
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2183	            with open(os.path.join(root, "setup.cfg"), "a") as f:
2184	                f.write(SAMPLE_CONFIG)
2185	        print(CONFIG_ERROR, file=sys.stderr)

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/pylatex-1.4.2/PyLaTeX-1.4.2/versioneer.py:2191
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2190	        LONG = LONG_VERSION_PY[cfg.VCS]
2191	        f.write(LONG % {"DOLLAR": "$",
2192	                        "STYLE": cfg.style,
2193	                        "TAG_PREFIX": cfg.tag_prefix,
2194	                        "PARENTDIR_PREFIX": cfg.parentdir_prefix,
2195	                        "VERSIONFILE_SOURCE": cfg.versionfile_source,
2196	                        })

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/pylatex-1.4.2/PyLaTeX-1.4.2/versioneer.py:2204
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
2203	            with open(ipy, "r") as f:
2204	                old = f.read()
2205	        except OSError:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/pylatex-1.4.2/PyLaTeX-1.4.2/versioneer.py:2212
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2211	            with open(ipy, "w") as f:
2212	                f.write(old.replace(OLD_SNIPPET, snippet))
2213	        elif snippet not in old:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/pylatex-1.4.2/PyLaTeX-1.4.2/versioneer.py:2216
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2215	            with open(ipy, "a") as f:
2216	                f.write(snippet)
2217	        else:

--------------------------------------------------

Code scanned:
	Total lines of code: 5587
	Total lines skipped (#nosec): 0

Run metrics:
	Total issues (by severity):
		Undefined: 0.0
		Low: 0.0
		Medium: 2.0
		High: 15.0
	Total issues (by confidence):
		Undefined: 0.0
		Low: 0.0
		Medium: 17.0
		High: 0.0
Files skipped (0):
