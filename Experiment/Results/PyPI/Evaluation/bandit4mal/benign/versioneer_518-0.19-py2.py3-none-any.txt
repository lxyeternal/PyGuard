Run started:2025-05-25 12:42:28.928256

Test results:
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/versioneer_518-0.19-py2.py3-none-any/versioneer.py:412
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
411	
412	LONG_VERSION_PY['git'] = r'''
413	# This file helps to compute a version number in source trees obtained from
414	# git-archive tarball (such as those provided by githubs download-from-tag
415	# feature). Distribution tarballs (built by setup.py sdist) and build
416	# directories (produced by setup.py build) will contain a much shorter file
417	# that just contains the computed version number.
418	
419	# This file is released into the public domain. Generated by
420	# versioneer-0.19 (https://github.com/python-versioneer/python-versioneer)
421	
422	"""Git implementation of _version.py."""
423	
424	import errno
425	import os
426	import re
427	import subprocess
428	import sys
429	
430	
431	def get_keywords():
432	    """Get the keywords needed to look up the version information."""
433	    # these strings will be replaced by git during git-archive.
434	    # setup.py/versioneer.py will grep for the variable names, so they must
435	    # each be defined on a line of their own. _version.py will just call
436	    # get_keywords().
437	    git_refnames = "%(DOLLAR)sFormat:%%d%(DOLLAR)s"
438	    git_full = "%(DOLLAR)sFormat:%%H%(DOLLAR)s"
439	    git_date = "%(DOLLAR)sFormat:%%ci%(DOLLAR)s"
440	    keywords = {"refnames": git_refnames, "full": git_full, "date": git_date}
441	    return keywords
442	
443	
444	class VersioneerConfig:
445	    """Container for Versioneer configuration parameters."""
446	
447	
448	def get_config():
449	    """Create, populate and return the VersioneerConfig() object."""
450	    # these strings are filled in when 'setup.py versioneer' creates
451	    # _version.py
452	    cfg = VersioneerConfig()
453	    cfg.VCS = "git"
454	    cfg.style = "%(STYLE)s"
455	    cfg.tag_prefix = "%(TAG_PREFIX)s"
456	    cfg.parentdir_prefix = "%(PARENTDIR_PREFIX)s"
457	    cfg.versionfile_source = "%(VERSIONFILE_SOURCE)s"
458	    cfg.verbose = False
459	    return cfg
460	
461	
462	class NotThisMethod(Exception):
463	    """Exception raised if a method is not valid for the current scenario."""
464	
465	
466	LONG_VERSION_PY = {}
467	HANDLERS = {}
468	
469	
470	def register_vcs_handler(vcs, method):  # decorator
471	    """Create decorator to mark a method as the handler of a VCS."""
472	    def decorate(f):
473	        """Store f in HANDLERS[vcs][method]."""
474	        if vcs not in HANDLERS:
475	            HANDLERS[vcs] = {}
476	        HANDLERS[vcs][method] = f
477	        return f
478	    return decorate
479	
480	
481	def run_command(commands, args, cwd=None, verbose=False, hide_stderr=False,
482	                env=None):
483	    """Call the given command(s)."""
484	    assert isinstance(commands, list)
485	    p = None
486	    for c in commands:
487	        try:
488	            dispcmd = str([c] + args)
489	            # remember shell=False, so use git.cmd on windows, not just git
490	            p = subprocess.Popen([c] + args, cwd=cwd, env=env,
491	                                 stdout=subprocess.PIPE,
492	                                 stderr=(subprocess.PIPE if hide_stderr
493	                                         else None))
494	            break
495	        except EnvironmentError:
496	            e = sys.exc_info()[1]
497	            if e.errno == errno.ENOENT:
498	                continue
499	            if verbose:
500	                print("unable to run %%s" %% dispcmd)
501	                print(e)
502	            return None, None
503	    else:
504	        if verbose:
505	            print("unable to find command, tried %%s" %% (commands,))
506	        return None, None
507	    stdout = p.communicate()[0].strip().decode()
508	    if p.returncode != 0:
509	        if verbose:
510	            print("unable to run %%s (error)" %% dispcmd)
511	            print("stdout was %%s" %% stdout)
512	        return None, p.returncode
513	    return stdout, p.returncode
514	
515	
516	def versions_from_parentdir(parentdir_prefix, root, verbose):
517	    """Try to determine the version from the parent directory name.
518	
519	    Source tarballs conventionally unpack into a directory that includes both
520	    the project name and a version string. We will also support searching up
521	    two directory levels for an appropriately named parent directory
522	    """
523	    rootdirs = []
524	
525	    for i in range(3):
526	        dirname = os.path.basename(root)
527	        if dirname.startswith(parentdir_prefix):
528	            return {"version": dirname[len(parentdir_prefix):],
529	                    "full-revisionid": None,
530	                    "dirty": False, "error": None, "date": None}
531	        else:
532	            rootdirs.append(root)
533	            root = os.path.dirname(root)  # up a level
534	
535	    if verbose:
536	        print("Tried directories %%s but none started with prefix %%s" %%
537	              (str(rootdirs), parentdir_prefix))
538	    raise NotThisMethod("rootdir doesn't start with parentdir_prefix")
539	
540	
541	@register_vcs_handler("git", "get_keywords")
542	def git_get_keywords(versionfile_abs):
543	    """Extract version information from the given file."""
544	    # the code embedded in _version.py can just fetch the value of these
545	    # keywords. When used from setup.py, we don't want to import _version.py,
546	    # so we do it with a regexp instead. This function is not used from
547	    # _version.py.
548	    keywords = {}
549	    try:
550	        f = open(versionfile_abs, "r")
551	        for line in f.readlines():
552	            if line.strip().startswith("git_refnames ="):
553	                mo = re.search(r'=\s*"(.*)"', line)
554	                if mo:
555	                    keywords["refnames"] = mo.group(1)
556	            if line.strip().startswith("git_full ="):
557	                mo = re.search(r'=\s*"(.*)"', line)
558	                if mo:
559	                    keywords["full"] = mo.group(1)
560	            if line.strip().startswith("git_date ="):
561	                mo = re.search(r'=\s*"(.*)"', line)
562	                if mo:
563	                    keywords["date"] = mo.group(1)
564	        f.close()
565	    except EnvironmentError:
566	        pass
567	    return keywords
568	
569	
570	@register_vcs_handler("git", "keywords")
571	def git_versions_from_keywords(keywords, tag_prefix, verbose):
572	    """Get version information from git keywords."""
573	    if not keywords:
574	        raise NotThisMethod("no keywords at all, weird")
575	    date = keywords.get("date")
576	    if date is not None:
577	        # Use only the last line.  Previous lines may contain GPG signature
578	        # information.
579	        date = date.splitlines()[-1]
580	
581	        # git-2.2.0 added "%%cI", which expands to an ISO-8601 -compliant
582	        # datestamp. However we prefer "%%ci" (which expands to an "ISO-8601
583	        # -like" string, which we must then edit to make compliant), because
584	        # it's been around since git-1.5.3, and it's too difficult to
585	        # discover which version we're using, or to work around using an
586	        # older one.
587	        date = date.strip().replace(" ", "T", 1).replace(" ", "", 1)
588	    refnames = keywords["refnames"].strip()
589	    if refnames.startswith("$Format"):
590	        if verbose:
591	            print("keywords are unexpanded, not using")
592	        raise NotThisMethod("unexpanded keywords, not a git-archive tarball")
593	    refs = set([r.strip() for r in refnames.strip("()").split(",")])
594	    # starting in git-1.8.3, tags are listed as "tag: foo-1.0" instead of
595	    # just "foo-1.0". If we see a "tag: " prefix, prefer those.
596	    TAG = "tag: "
597	    tags = set([r[len(TAG):] for r in refs if r.startswith(TAG)])
598	    if not tags:
599	        # Either we're using git < 1.8.3, or there really are no tags. We use
600	        # a heuristic: assume all version tags have a digit. The old git %%d
601	        # expansion behaves like git log --decorate=short and strips out the
602	        # refs/heads/ and refs/tags/ prefixes that would let us distinguish
603	        # between branches and tags. By ignoring refnames without digits, we
604	        # filter out many common branch names like "release" and
605	        # "stabilization", as well as "HEAD" and "master".
606	        tags = set([r for r in refs if re.search(r'\d', r)])
607	        if verbose:
608	            print("discarding '%%s', no digits" %% ",".join(refs - tags))
609	    if verbose:
610	        print("likely tags: %%s" %% ",".join(sorted(tags)))
611	    for ref in sorted(tags):
612	        # sorting will prefer e.g. "2.0" over "2.0rc1"
613	        if ref.startswith(tag_prefix):
614	            r = ref[len(tag_prefix):]
615	            if verbose:
616	                print("picking %%s" %% r)
617	            return {"version": r,
618	                    "full-revisionid": keywords["full"].strip(),
619	                    "dirty": False, "error": None,
620	                    "date": date}
621	    # no suitable tags, so version is "0+unknown", but full hex is still there
622	    if verbose:
623	        print("no suitable tags, using unknown + full revision id")
624	    return {"version": "0+unknown",
625	            "full-revisionid": keywords["full"].strip(),
626	            "dirty": False, "error": "no suitable tags", "date": None}
627	
628	
629	@register_vcs_handler("git", "pieces_from_vcs")
630	def git_pieces_from_vcs(tag_prefix, root, verbose, run_command=run_command):
631	    """Get version from 'git describe' in the root of the source tree.
632	
633	    This only gets called if the git-archive 'subst' keywords were *not*
634	    expanded, and _version.py hasn't already been rewritten with a short
635	    version string, meaning we're inside a checked out source tree.
636	    """
637	    GITS = ["git"]
638	    if sys.platform == "win32":
639	        GITS = ["git.cmd", "git.exe"]
640	
641	    out, rc = run_command(GITS, ["rev-parse", "--git-dir"], cwd=root,
642	                          hide_stderr=True)
643	    if rc != 0:
644	        if verbose:
645	            print("Directory %%s not under git control" %% root)
646	        raise NotThisMethod("'git rev-parse --git-dir' returned error")
647	
648	    # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]
649	    # if there isn't one, this yields HEX[-dirty] (no NUM)
650	    describe_out, rc = run_command(GITS, ["describe", "--tags", "--dirty",
651	                                          "--always", "--long",
652	                                          "--match", "%%s*" %% tag_prefix],
653	                                   cwd=root)
654	    # --long was added in git-1.5.5
655	    if describe_out is None:
656	        raise NotThisMethod("'git describe' failed")
657	    describe_out = describe_out.strip()
658	    full_out, rc = run_command(GITS, ["rev-parse", "HEAD"], cwd=root)
659	    if full_out is None:
660	        raise NotThisMethod("'git rev-parse' failed")
661	    full_out = full_out.strip()
662	
663	    pieces = {}
664	    pieces["long"] = full_out
665	    pieces["short"] = full_out[:7]  # maybe improved later
666	    pieces["error"] = None
667	
668	    # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]
669	    # TAG might have hyphens.
670	    git_describe = describe_out
671	
672	    # look for -dirty suffix
673	    dirty = git_describe.endswith("-dirty")
674	    pieces["dirty"] = dirty
675	    if dirty:
676	        git_describe = git_describe[:git_describe.rindex("-dirty")]
677	
678	    # now we have TAG-NUM-gHEX or HEX
679	
680	    if "-" in git_describe:
681	        # TAG-NUM-gHEX
682	        mo = re.search(r'^(.+)-(\d+)-g([0-9a-f]+)$', git_describe)
683	        if not mo:
684	            # unparseable. Maybe git-describe is misbehaving?
685	            pieces["error"] = ("unable to parse git-describe output: '%%s'"
686	                               %% describe_out)
687	            return pieces
688	
689	        # tag
690	        full_tag = mo.group(1)
691	        if not full_tag.startswith(tag_prefix):
692	            if verbose:
693	                fmt = "tag '%%s' doesn't start with prefix '%%s'"
694	                print(fmt %% (full_tag, tag_prefix))
695	            pieces["error"] = ("tag '%%s' doesn't start with prefix '%%s'"
696	                               %% (full_tag, tag_prefix))
697	            return pieces
698	        pieces["closest-tag"] = full_tag[len(tag_prefix):]
699	
700	        # distance: number of commits since tag
701	        pieces["distance"] = int(mo.group(2))
702	
703	        # commit: short hex revision ID
704	        pieces["short"] = mo.group(3)
705	
706	    else:
707	        # HEX: no tags
708	        pieces["closest-tag"] = None
709	        count_out, rc = run_command(GITS, ["rev-list", "HEAD", "--count"],
710	                                    cwd=root)
711	        pieces["distance"] = int(count_out)  # total number of commits
712	
713	    # commit date: see ISO-8601 comment in git_versions_from_keywords()
714	    date = run_command(GITS, ["show", "-s", "--format=%%ci", "HEAD"],
715	                       cwd=root)[0].strip()
716	    # Use only the last line.  Previous lines may contain GPG signature
717	    # information.
718	    date = date.splitlines()[-1]
719	    pieces["date"] = date.strip().replace(" ", "T", 1).replace(" ", "", 1)
720	
721	    return pieces
722	
723	
724	def plus_or_dot(pieces):
725	    """Return a + if we don't already have one, else return a ."""
726	    if "+" in pieces.get("closest-tag", ""):
727	        return "."
728	    return "+"
729	
730	
731	def render_pep440(pieces):
732	    """Build up version string, with post-release "local version identifier".
733	
734	    Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you
735	    get a tagged build and then dirty it, you'll get TAG+0.gHEX.dirty
736	
737	    Exceptions:
738	    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]
739	    """
740	    if pieces["closest-tag"]:
741	        rendered = pieces["closest-tag"]
742	        if pieces["distance"] or pieces["dirty"]:
743	            rendered += plus_or_dot(pieces)
744	            rendered += "%%d.g%%s" %% (pieces["distance"], pieces["short"])
745	            if pieces["dirty"]:
746	                rendered += ".dirty"
747	    else:
748	        # exception #1
749	        rendered = "0+untagged.%%d.g%%s" %% (pieces["distance"],
750	                                          pieces["short"])
751	        if pieces["dirty"]:
752	            rendered += ".dirty"
753	    return rendered
754	
755	
756	def render_pep440_pre(pieces):
757	    """TAG[.post0.devDISTANCE] -- No -dirty.
758	
759	    Exceptions:
760	    1: no tags. 0.post0.devDISTANCE
761	    """
762	    if pieces["closest-tag"]:
763	        rendered = pieces["closest-tag"]
764	        if pieces["distance"]:
765	            rendered += ".post0.dev%%d" %% pieces["distance"]
766	    else:
767	        # exception #1
768	        rendered = "0.post0.dev%%d" %% pieces["distance"]
769	    return rendered
770	
771	
772	def render_pep440_post(pieces):
773	    """TAG[.postDISTANCE[.dev0]+gHEX] .
774	
775	    The ".dev0" means dirty. Note that .dev0 sorts backwards
776	    (a dirty tree will appear "older" than the corresponding clean one),
777	    but you shouldn't be releasing software with -dirty anyways.
778	
779	    Exceptions:
780	    1: no tags. 0.postDISTANCE[.dev0]
781	    """
782	    if pieces["closest-tag"]:
783	        rendered = pieces["closest-tag"]
784	        if pieces["distance"] or pieces["dirty"]:
785	            rendered += ".post%%d" %% pieces["distance"]
786	            if pieces["dirty"]:
787	                rendered += ".dev0"
788	            rendered += plus_or_dot(pieces)
789	            rendered += "g%%s" %% pieces["short"]
790	    else:
791	        # exception #1
792	        rendered = "0.post%%d" %% pieces["distance"]
793	        if pieces["dirty"]:
794	            rendered += ".dev0"
795	        rendered += "+g%%s" %% pieces["short"]
796	    return rendered
797	
798	
799	def render_pep440_old(pieces):
800	    """TAG[.postDISTANCE[.dev0]] .
801	
802	    The ".dev0" means dirty.
803	
804	    Exceptions:
805	    1: no tags. 0.postDISTANCE[.dev0]
806	    """
807	    if pieces["closest-tag"]:
808	        rendered = pieces["closest-tag"]
809	        if pieces["distance"] or pieces["dirty"]:
810	            rendered += ".post%%d" %% pieces["distance"]
811	            if pieces["dirty"]:
812	                rendered += ".dev0"
813	    else:
814	        # exception #1
815	        rendered = "0.post%%d" %% pieces["distance"]
816	        if pieces["dirty"]:
817	            rendered += ".dev0"
818	    return rendered
819	
820	
821	def render_git_describe(pieces):
822	    """TAG[-DISTANCE-gHEX][-dirty].
823	
824	    Like 'git describe --tags --dirty --always'.
825	
826	    Exceptions:
827	    1: no tags. HEX[-dirty]  (note: no 'g' prefix)
828	    """
829	    if pieces["closest-tag"]:
830	        rendered = pieces["closest-tag"]
831	        if pieces["distance"]:
832	            rendered += "-%%d-g%%s" %% (pieces["distance"], pieces["short"])
833	    else:
834	        # exception #1
835	        rendered = pieces["short"]
836	    if pieces["dirty"]:
837	        rendered += "-dirty"
838	    return rendered
839	
840	
841	def render_git_describe_long(pieces):
842	    """TAG-DISTANCE-gHEX[-dirty].
843	
844	    Like 'git describe --tags --dirty --always -long'.
845	    The distance/hash is unconditional.
846	
847	    Exceptions:
848	    1: no tags. HEX[-dirty]  (note: no 'g' prefix)
849	    """
850	    if pieces["closest-tag"]:
851	        rendered = pieces["closest-tag"]
852	        rendered += "-%%d-g%%s" %% (pieces["distance"], pieces["short"])
853	    else:
854	        # exception #1
855	        rendered = pieces["short"]
856	    if pieces["dirty"]:
857	        rendered += "-dirty"
858	    return rendered
859	
860	
861	def render(pieces, style):
862	    """Render the given version pieces into the requested style."""
863	    if pieces["error"]:
864	        return {"version": "unknown",
865	                "full-revisionid": pieces.get("long"),
866	                "dirty": None,
867	                "error": pieces["error"],
868	                "date": None}
869	
870	    if not style or style == "default":
871	        style = "pep440"  # the default
872	
873	    if style == "pep440":
874	        rendered = render_pep440(pieces)
875	    elif style == "pep440-pre":
876	        rendered = render_pep440_pre(pieces)
877	    elif style == "pep440-post":
878	        rendered = render_pep440_post(pieces)
879	    elif style == "pep440-old":
880	        rendered = render_pep440_old(pieces)
881	    elif style == "git-describe":
882	        rendered = render_git_describe(pieces)
883	    elif style == "git-describe-long":
884	        rendered = render_git_describe_long(pieces)
885	    else:
886	        raise ValueError("unknown style '%%s'" %% style)
887	
888	    return {"version": rendered, "full-revisionid": pieces["long"],
889	            "dirty": pieces["dirty"], "error": None,
890	            "date": pieces.get("date")}
891	
892	
893	def get_versions():
894	    """Get version information or return default if unable to do so."""
895	    # I am in _version.py, which lives at ROOT/VERSIONFILE_SOURCE. If we have
896	    # __file__, we can work backwards from there to the root. Some
897	    # py2exe/bbfreeze/non-CPython implementations don't do __file__, in which
898	    # case we can only use expanded keywords.
899	
900	    cfg = get_config()
901	    verbose = cfg.verbose
902	
903	    try:
904	        return git_versions_from_keywords(get_keywords(), cfg.tag_prefix,
905	                                          verbose)
906	    except NotThisMethod:
907	        pass
908	
909	    try:
910	        root = os.path.realpath(__file__)
911	        # versionfile_source is the relative path from the top of the source
912	        # tree (where the .git directory might live) to this file. Invert
913	        # this to find the root from __file__.
914	        for i in cfg.versionfile_source.split('/'):
915	            root = os.path.dirname(root)
916	    except NameError:
917	        return {"version": "0+unknown", "full-revisionid": None,
918	                "dirty": None,
919	                "error": "unable to find root of source tree",
920	                "date": None}
921	
922	    try:
923	        pieces = git_pieces_from_vcs(cfg.tag_prefix, root, verbose)
924	        return render(pieces, cfg.style)
925	    except NotThisMethod:
926	        pass
927	
928	    try:
929	        if cfg.parentdir_prefix:
930	            return versions_from_parentdir(cfg.parentdir_prefix, root, verbose)
931	    except NotThisMethod:
932	        pass
933	
934	    return {"version": "0+unknown", "full-revisionid": None,
935	            "dirty": None,
936	            "error": "unable to compute version", "date": None}
937	'''
938	
939	
940	@register_vcs_handler("git", "get_keywords")
941	def git_get_keywords(versionfile_abs):

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/versioneer_518-0.19-py2.py3-none-any/versioneer.py:1155
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1154	        f = open(".gitattributes", "a+")
1155	        f.write("%s export-subst\n" % versionfile_source)
1156	        f.close()

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/versioneer_518-0.19-py2.py3-none-any/versioneer.py:1208
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
1207	        with open(filename) as f:
1208	            contents = f.read()
1209	    except EnvironmentError:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/versioneer_518-0.19-py2.py3-none-any/versioneer.py:1227
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1226	    with open(filename, "w") as f:
1227	        f.write(SHORT_VERSION_PY % contents)
1228	

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/versioneer_518-0.19-py2.py3-none-any/versioneer.py:1618
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1617	                    LONG = LONG_VERSION_PY[cfg.VCS]
1618	                    f.write(LONG %
1619	                            {"DOLLAR": "$",
1620	                             "STYLE": cfg.style,
1621	                             "TAG_PREFIX": cfg.tag_prefix,
1622	                             "PARENTDIR_PREFIX": cfg.parentdir_prefix,
1623	                             "VERSIONFILE_SOURCE": cfg.versionfile_source,
1624	                             })

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/versioneer_518-0.19-py2.py3-none-any/versioneer.py:1644
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1643	                    LONG = LONG_VERSION_PY[cfg.VCS]
1644	                    f.write(LONG %
1645	                            {"DOLLAR": "$",
1646	                             "STYLE": cfg.style,
1647	                             "TAG_PREFIX": cfg.tag_prefix,
1648	                             "PARENTDIR_PREFIX": cfg.parentdir_prefix,
1649	                             "VERSIONFILE_SOURCE": cfg.versionfile_source,
1650	                             })

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/versioneer_518-0.19-py2.py3-none-any/versioneer.py:1741
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1740	            with open(os.path.join(root, "setup.cfg"), "a") as f:
1741	                f.write(SAMPLE_CONFIG)
1742	        print(CONFIG_ERROR, file=sys.stderr)

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/versioneer_518-0.19-py2.py3-none-any/versioneer.py:1748
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1747	        LONG = LONG_VERSION_PY[cfg.VCS]
1748	        f.write(LONG % {"DOLLAR": "$",
1749	                        "STYLE": cfg.style,
1750	                        "TAG_PREFIX": cfg.tag_prefix,
1751	                        "PARENTDIR_PREFIX": cfg.parentdir_prefix,
1752	                        "VERSIONFILE_SOURCE": cfg.versionfile_source,
1753	                        })

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/versioneer_518-0.19-py2.py3-none-any/versioneer.py:1760
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
1759	            with open(ipy, "r") as f:
1760	                old = f.read()
1761	        except EnvironmentError:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/versioneer_518-0.19-py2.py3-none-any/versioneer.py:1766
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1765	            with open(ipy, "a") as f:
1766	                f.write(INIT_PY_SNIPPET)
1767	        else:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/versioneer_518-0.19-py2.py3-none-any/versioneer.py:1794
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1793	        with open(manifest_in, "a") as f:
1794	            f.write("include versioneer.py\n")
1795	    else:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home2/blue/Documents/PyPIAgent/Dataset/evaluation/unzip_benign/versioneer_518-0.19-py2.py3-none-any/versioneer.py:1801
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1800	        with open(manifest_in, "a") as f:
1801	            f.write("include %s\n" % cfg.versionfile_source)
1802	    else:

--------------------------------------------------

Code scanned:
	Total lines of code: 1341
	Total lines skipped (#nosec): 0

Run metrics:
	Total issues (by severity):
		Undefined: 0.0
		Low: 0.0
		Medium: 1.0
		High: 11.0
	Total issues (by confidence):
		Undefined: 0.0
		Low: 0.0
		Medium: 12.0
		High: 0.0
Files skipped (0):
