{
  "metadata": {
    "package_name": "oscrypto-1",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/oscrypto-1.3.0.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "tls.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/oscrypto-1.3.0/oscrypto-1.3.0/oscrypto/_win/tls.py",
      "line_number": "769",
      "type_description": "B809:recv",
      "context_snippet": "def _handshake(self, renegotiate=False):\n    \"\"\"\n    Perform an initial TLS handshake, or a renegotiation\n\n    :param renegotiate:\n        If the handshake is for a renegotiation\n    \"\"\"\n\n    in_buffers = None\n    out_buffers = None\n    new_context_handle_pointer = None\n\n    try:\n        if renegotiate:\n            temp_context_handle_pointer = self._context_handle_pointer\n        else:\n            new_context_handle_pointer = new(secur32, 'CtxtHandle *')\n            temp_context_handle_pointer = new_context_handle_pointer\n\n        requested_flags = {\n            Secur32Const.ISC_REQ_REPLAY_DETECT: 'replay detection',\n            Secur32Const.ISC_REQ_SEQUENCE_DETECT: 'sequence detection',\n            Secur32Const.ISC_REQ_CONFIDENTIALITY: 'confidentiality',\n            Secur32Const.ISC_REQ_ALLOCATE_MEMORY: 'memory allocation',\n            Secur32Const.ISC_REQ_INTEGRITY: 'integrity',\n            Secur32Const.ISC_REQ_STREAM: 'stream orientation',\n            Secur32Const.ISC_REQ_USE_SUPPLIED_CREDS: 'disable automatic client auth',\n        }\n\n        self._context_flags = 0\n        for flag in requested_flags:\n            self._context_flags |= flag\n\n        in_sec_buffer_desc_pointer, in_buffers = self._create_buffers(2)\n        in_buffers[0].BufferType = Secur32Const.SECBUFFER_TOKEN\n\n        out_sec_buffer_desc_pointer, out_buffers = self._create_buffers(2)\n        out_buffers[0].BufferType = Secur32Const.SECBUFFER_TOKEN\n        out_buffers[1].BufferType = Secur32Const.SECBUFFER_ALERT\n\n        output_context_flags_pointer = new(secur32, 'ULONG *')\n\n        if renegotiate:\n            first_handle = temp_context_handle_pointer\n            second_handle = null()\n        else:\n            first_handle = null()\n            second_handle = temp_context_handle_pointer\n\n        result = secur32.InitializeSecurityContextW(\n            self._session._credentials_handle,\n            first_handle,\n            self._hostname,\n            self._context_flags,\n            0,\n            0,\n            null(),\n            0,\n            second_handle,\n            out_sec_buffer_desc_pointer,\n            output_context_flags_pointer,\n            null()\n        )\n        if result not in set([Secur32Const.SEC_E_OK, Secur32Const.SEC_I_CONTINUE_NEEDED]):\n            handle_error(result, TLSError)\n\n        if not renegotiate:\n            temp_context_handle_pointer = second_handle\n        else:\n            temp_context_handle_pointer = first_handle\n\n        handshake_server_bytes = b''\n        handshake_client_bytes = b''\n\n        if out_buffers[0].cbBuffer > 0:\n            token = bytes_from_buffer(out_buffers[0].pvBuffer, out_buffers[0].cbBuffer)\n            handshake_client_bytes += token\n            self._socket.send(token)\n            out_buffers[0].cbBuffer = 0\n            secur32.FreeContextBuffer(out_buffers[0].pvBuffer)\n            out_buffers[0].pvBuffer = null()\n\n        in_data_buffer = buffer_from_bytes(32768)\n        in_buffers[0].pvBuffer = cast(secur32, 'BYTE *', in_data_buffer)\n\n        bytes_read = b''\n        while result != Secur32Const.SEC_E_OK:\n            try:\n                fail_late = False\n                bytes_read = self._socket.recv(8192)\n                if bytes_read == b'':\n                    raise_disconnection()\n            except (socket_error_cls):\n                fail_late = True\n            handshake_server_bytes += bytes_read\n            self._received_bytes += bytes_read\n\n            in_buffers[0].cbBuffer = len(self._received_bytes)\n            write_to_buffer(in_data_buffer, self._received_bytes)\n\n            result = secur32.InitializeSecurityContextW(\n                self._session._credentials_handle,\n                temp_context_handle_pointer,\n                self._hostname,\n                self._context_flags,\n                0,\n                0,\n                in_sec_buffer_desc_pointer,\n                0,\n                null(),\n                out_sec_buffer_desc_pointer,\n                output_context_flags_pointer,\n                null()\n            )\n\n            if result == Secur32Const.SEC_E_INCOMPLETE_MESSAGE:\n                in_buffers[0].BufferType = Secur32Const.SECBUFFER_TOKEN\n                # Windows 10 seems to fill the second input buffer with\n                # a BufferType of SECBUFFER_MISSING (4), which if not\n                # cleared causes the handshake to fail.\n                if in_buffers[1].BufferType != Secur32Const.SECBUFFER_EMPTY:\n                    in_buffers[1].BufferType = Secur32Const.SECBUFFER_EMPTY\n                    in_buffers[1].cbBuffer = 0\n                    if not is_null(in_buffers[1].pvBuffer):\n                        secur32.FreeContextBuffer(in_buffers[1].pvBuffer)\n                        in_buffers[1].pvBuffer = null()\n\n                if fail_late:\n                    raise_disconnection()\n\n                continue\n\n            if result == Secur32Const.SEC_E_ILLEGAL_MESSAGE:\n                if detect_client_auth_request(handshake_server_bytes):\n                    raise_client_auth()\n                alert_info = parse_alert(handshake_server_bytes)\n                if alert_info and alert_info == (2, 70):\n                    raise_protocol_version()\n                raise_handshake()\n\n            if result == Secur32Const.SEC_E_WRONG_PRINCIPAL:\n                chain = extract_chain(handshake_server_bytes)\n                raise_hostname(chain[0], self._hostname)\n\n            if result == Secur32Const.SEC_E_CERT_EXPIRED:\n                chain = extract_chain(handshake_server_bytes)\n                raise_expired_not_yet_valid(chain[0])\n\n            if result == Secur32Const.SEC_E_UNTRUSTED_ROOT:\n                chain = extract_chain(handshake_server_bytes)\n                cert = chain[0]\n                oscrypto_cert = load_certificate(cert)\n                if not oscrypto_cert.self_signed:\n                    raise_no_issuer(cert)\n                raise_self_signed(cert)\n\n            if result == Secur32Const.SEC_E_INTERNAL_ERROR:\n                if get_dh_params_length(handshake_server_bytes) < 1024:\n                    raise_dh_params()\n\n            if result == Secur32Const.SEC_I_INCOMPLETE_CREDENTIALS:\n                raise_client_auth()\n\n            if result == Crypt32Const.TRUST_E_CERT_SIGNATURE:\n                raise_weak_signature(cert)\n\n            if result == Secur32Const.SEC_E_INVALID_TOKEN:\n                # If an alert it present, there may have been a handshake\n                # error due to the server using a certificate path with a\n                # trust root using MD2 or MD5 combined with TLS 1.2. To\n                # work around this, if the user allows anything other than\n                # TLS 1.2, we just remove it from the acceptable protocols\n                # and try again.\n                if out_buffers[1].cbBuffer > 0:\n                    alert_bytes = bytes_from_buffer(out_buffers[1].pvBuffer, out_buffers[1].cbBuffer)\n                    handshake_client_bytes += alert_bytes\n                    alert_number = alert_bytes[6:7]\n                    if alert_number == b'\\x28' or alert_number == b'\\x2b':\n                        if 'TLSv1.2' in self._session._protocols and len(self._session._protocols) > 1:\n                            chain = extract_chain(handshake_server_bytes)\n                            raise _TLSDowngradeError(\n                                'Server certificate verification failed - weak certificate signature algorithm',\n                                chain[0]\n                            )\n                if detect_client_auth_request(handshake_server_bytes):\n                    raise_client_auth()\n                if detect_other_protocol(handshake_server_bytes):\n                    raise_protocol_error(handshake_server_bytes)\n                raise_handshake()\n\n            # These are semi-common errors with TLSv1.2 on Windows 7 an 8\n            # that appears to be due to poor handling of the\n            # ServerKeyExchange for DHE_RSA cipher suites. The solution\n            # is to retry the handshake.\n            if result == Secur32Const.SEC_E_BUFFER_TOO_SMALL or result == Secur32Const.SEC_E_MESSAGE_ALTERED:\n                if 'TLSv1.2' in self._session._protocols:\n                    raise _TLSRetryError('TLS handshake failed')\n\n            if fail_late:\n                raise_disconnection()\n\n            if result == Secur32Const.SEC_E_INVALID_PARAMETER:\n                if get_dh_params_length(handshake_server_bytes) < 1024:\n                    raise_dh_params()\n\n            if result not in set([Secur32Const.SEC_E_OK, Secur32Const.SEC_I_CONTINUE_NEEDED]):\n                handle_error(result, TLSError)\n\n            if out_buffers[0].cbBuffer > 0:\n                token = bytes_from_buffer(out_buffers[0].pvBuffer, out_buffers[0].cbBuffer)\n                handshake_client_bytes += token\n                self._socket.send(token)\n                out_buffers[0].cbBuffer = 0\n                secur32.FreeContextBuffer(out_buffers[0].pvBuffer)\n                out_buffers[0].pvBuffer = null()\n\n            if in_buffers[1].BufferType == Secur32Const.SECBUFFER_EXTRA:\n                extra_amount = in_buffers[1].cbBuffer\n                self._received_bytes = self._received_bytes[-extra_amount:]\n                in_buffers[1].BufferType = Secur32Const.SECBUFFER_EMPTY\n                in_buffers[1].cbBuffer = 0\n                secur32.FreeContextBuffer(in_buffers[1].pvBuffer)\n                in_buffers[1].pvBuffer = null()\n\n                # The handshake is complete, so discard any extra bytes\n                if result == Secur32Const.SEC_E_OK:\n                    handshake_server_bytes = handshake_server_bytes[-extra_amount:]\n\n            else:\n                self._received_bytes = b''\n\n        connection_info_pointer = struct(secur32, 'SecPkgContext_ConnectionInfo')\n        result = secur32.QueryContextAttributesW(\n            temp_context_handle_pointer,\n            Secur32Const.SECPKG_ATTR_CONNECTION_INFO,\n            connection_info_pointer\n        )\n        handle_error(result, TLSError)\n\n        connection_info = unwrap(connection_info_pointer)\n\n        self._protocol = {\n            Secur32Const.SP_PROT_SSL2_CLIENT: 'SSLv2',\n            Secur32Const.SP_PROT_SSL3_CLIENT: 'SSLv3',\n            Secur32Const.SP_PROT_TLS1_CLIENT: 'TLSv1',\n            Secur32Const.SP_PROT_TLS1_1_CLIENT: 'TLSv1.1',\n            Secur32Const.SP_PROT_TLS1_2_CLIENT: 'TLSv1.2',\n        }.get(native(int, connection_info.dwProtocol), str_cls(connection_info.dwProtocol))\n\n        if self._protocol in set(['SSLv3', 'TLSv1', 'TLSv1.1', 'TLSv1.2']):\n            session_info = parse_session_info(handshake_server_bytes, handshake_client_bytes)\n            self._cipher_suite = session_info['cipher_suite']\n            self._compression = session_info['compression']\n            self._session_id = session_info['session_id']\n            self._session_ticket = session_info['session_ticket']\n\n        output_context_flags = deref(output_context_flags_pointer)\n\n        for flag in requested_flags:\n            if (flag | output_context_flags) == 0:\n                raise OSError(pretty_message(\n                    '''\n                    Unable to obtain a credential context with the property %s\n                    ''' ,\n                    requested_flags[flag]\n                ))\n\n        if not renegotiate:\n            self._context_handle_pointer = temp_context_handle_pointer\n            new_context_handle_pointer = None\n\n            stream_sizes_pointer = struct(secur32, 'SecPkgContext_StreamSizes')\n            result = secur32.QueryContextAttributesW(\n                self._context_handle_pointer,\n                Secur32Const.SECPKG_ATTR_STREAM_SIZES,\n                stream_sizes_pointer\n            )\n            handle_error(result)\n\n            stream_sizes = unwrap(stream_sizes_pointer)\n            self._header_size = native(int, stream_sizes.cbHeader)\n            self._message_size = native(int, stream_sizes.cbMaximumMessage)\n            self._trailer_size = native(int, stream_sizes.cbTrailer)\n            self._buffer_size = self._header_size + self._message_size + self._trailer_size\n\n        if self._session._extra_trust_roots:\n            self._extra_trust_root_validation()\n\n    except (OSError, socket_.error):\n        self.close()\n\n        raise\n\n    finally:\n        if out_buffers:\n            if not is_null(out_buffers[0].pvBuffer):\n                secur32.FreeContextBuffer(out_buffers[0].pvBuffer)\n            if not is_null(out_buffers[1].pvBuffer):\n                secur32.FreeContextBuffer(out_buffers[1].pvBuffer)\n        if new_context_handle_pointer:\n            secur32.DeleteSecurityContext(new_context_handle_pointer)",
      "hash_value": "d5b3d2604fdfd962ac6a29a386d6dd6b",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "def _handshake(self, renegotiate=False):\n    \"\"\"\n    Perform an initial TLS handshake, or a renegotiation\n\n    :param renegotiate:\n        If the handshake is for a renegotiation\n    \"\"\"\n\n    in_buffers = None\n    out_buffers = None\n    new_context_handle_pointer = None\n\n    try:\n        if renegotiate:\n            temp_context_handle_pointer = self._context_handle_pointer\n        else:\n            new_context_handle_pointer = new(secur32, 'CtxtHandle *')\n            temp_context_handle_pointer = new_context_handle_pointer\n\n        requested_flags = {\n            Secur32Const.ISC_REQ_REPLAY_DETECT: 'replay detection',\n            Secur32Const.ISC_REQ_SEQUENCE_DETECT: 'sequence detection',\n            Secur32Const.ISC_REQ_CONFIDENTIALITY: 'confidentiality',\n            Secur32Const.ISC_REQ_ALLOCATE_MEMORY: 'memory allocation',\n            Secur32Const.ISC_REQ_INTEGRITY: 'integrity',\n            Secur32Const.ISC_REQ_STREAM: 'stream orientation',\n            Secur32Const.ISC_REQ_USE_SUPPLIED_CREDS: 'disable automatic client auth',\n        }\n\n        self._context_flags = 0\n        for flag in requested_flags:\n            self._context_flags |= flag\n\n        in_sec_buffer_desc_pointer, in_buffers = self._create_buffers(2)\n        in_buffers[0].BufferType = Secur32Const.SECBUFFER_TOKEN\n\n        out_sec_buffer_desc_pointer, out_buffers = self._create_buffers(2)\n        out_buffers[0].BufferType = Secur32Const.SECBUFFER_TOKEN\n        out_buffers[1].BufferType = Secur32Const.SECBUFFER_ALERT\n\n        output_context_flags_pointer = new(secur32, 'ULONG *')\n\n        if renegotiate:\n            first_handle = temp_context_handle_pointer\n            second_handle = null()\n        else:\n            first_handle = null()\n            second_handle = temp_context_handle_pointer\n\n        result = secur32.InitializeSecurityContextW(\n            self._session._credentials_handle,\n            first_handle,\n            self._hostname,\n            self._context_flags,\n            0,\n            0,\n            null(),\n            0,\n            second_handle,\n            out_sec_buffer_desc_pointer,\n            output_context_flags_pointer,\n            null()\n        )\n        if result not in set([Secur32Const.SEC_E_OK, Secur32Const.SEC_I_CONTINUE_NEEDED]):\n            handle_error(result, TLSError)\n\n        if not renegotiate:\n            temp_context_handle_pointer = second_handle\n        else:\n            temp_context_handle_pointer = first_handle\n\n        handshake_server_bytes = b''\n        handshake_client_bytes = b''\n\n        if out_buffers[0].cbBuffer > 0:\n            token = bytes_from_buffer(out_buffers[0].pvBuffer, out_buffers[0].cbBuffer)\n            handshake_client_bytes += token\n            self._socket.send(token)\n            out_buffers[0].cbBuffer = 0\n            secur32.FreeContextBuffer(out_buffers[0].pvBuffer)\n            out_buffers[0].pvBuffer = null()\n\n        in_data_buffer = buffer_from_bytes(32768)\n        in_buffers[0].pvBuffer = cast(secur32, 'BYTE *', in_data_buffer)\n\n        bytes_read = b''\n        while result != Secur32Const.SEC_E_OK:\n            try:\n                fail_late = False\n                bytes_read = self._socket.recv(8192)\n                if bytes_read == b'':\n                    raise_disconnection()\n            except (socket_error_cls):\n                fail_late = True\n            handshake_server_bytes += bytes_read\n            self._received_bytes += bytes_read\n\n            in_buffers[0].cbBuffer = len(self._received_bytes)\n            write_to_buffer(in_data_buffer, self._received_bytes)\n\n            result = secur32.InitializeSecurityContextW(\n                self._session._credentials_handle,\n                temp_context_handle_pointer,\n                self._hostname,\n                self._context_flags,\n                0,\n                0,\n                in_sec_buffer_desc_pointer,\n                0,\n                null(),\n                out_sec_buffer_desc_pointer,\n                output_context_flags_pointer,\n                null()\n            )\n\n            if result == Secur32Const.SEC_E_INCOMPLETE_MESSAGE:\n                in_buffers[0].BufferType = Secur32Const.SECBUFFER_TOKEN\n                # Windows 10 seems to fill the second input buffer with\n                # a BufferType of SECBUFFER_MISSING (4), which if not\n                # cleared causes the handshake to fail.\n                if in_buffers[1].BufferType != Secur32Const.SECBUFFER_EMPTY:\n                    in_buffers[1].BufferType = Secur32Const.SECBUFFER_EMPTY\n                    in_buffers[1].cbBuffer = 0\n                    if not is_null(in_buffers[1].pvBuffer):\n                        secur32.FreeContextBuffer(in_buffers[1].pvBuffer)\n                        in_buffers[1].pvBuffer = null()\n\n                if fail_late:\n                    raise_disconnection()\n\n                continue\n\n            if result == Secur32Const.SEC_E_ILLEGAL_MESSAGE:\n                if detect_client_auth_request(handshake_server_bytes):\n                    raise_client_auth()\n                alert_info = parse_alert(handshake_server_bytes)\n                if alert_info and alert_info == (2, 70):\n                    raise_protocol_version()\n                raise_handshake()\n\n            if result == Secur32Const.SEC_E_WRONG_PRINCIPAL:\n                chain = extract_chain(handshake_server_bytes)\n                raise_hostname(chain[0], self._hostname)\n\n            if result == Secur32Const.SEC_E_CERT_EXPIRED:\n                chain = extract_chain(handshake_server_bytes)\n                raise_expired_not_yet_valid(chain[0])\n\n            if result == Secur32Const.SEC_E_UNTRUSTED_ROOT:\n                chain = extract_chain(handshake_server_bytes)\n                cert = chain[0]\n                oscrypto_cert = load_certificate(cert)\n                if not oscrypto_cert.self_signed:\n                    raise_no_issuer(cert)\n                raise_self_signed(cert)\n\n            if result == Secur32Const.SEC_E_INTERNAL_ERROR:\n                if get_dh_params_length(handshake_server_bytes) < 1024:\n                    raise_dh_params()\n\n            if result == Secur32Const.SEC_I_INCOMPLETE_CREDENTIALS:\n                raise_client_auth()\n\n            if result == Crypt32Const.TRUST_E_CERT_SIGNATURE:\n                raise_weak_signature(cert)\n\n            if result == Secur32Const.SEC_E_INVALID_TOKEN:\n                # If an alert it present, there may have been a handshake\n                # error due to the server using a certificate path with a\n                # trust root using MD2 or MD5 combined with TLS 1.2. To\n                # work around this, if the user allows anything other than\n                # TLS 1.2, we just remove it from the acceptable protocols\n                # and try again.\n                if out_buffers[1].cbBuffer > 0:\n                    alert_bytes = bytes_from_buffer(out_buffers[1].pvBuffer, out_buffers[1].cbBuffer)\n                    handshake_client_bytes += alert_bytes\n                    alert_number = alert_bytes[6:7]\n                    if alert_number == b'\\x28' or alert_number == b'\\x2b':\n                        if 'TLSv1.2' in self._session._protocols and len(self._session._protocols) > 1:\n                            chain = extract_chain(handshake_server_bytes)\n                            raise _TLSDowngradeError(\n                                'Server certificate verification failed - weak certificate signature algorithm',\n                                chain[0]\n                            )\n                if detect_client_auth_request(handshake_server_bytes):\n                    raise_client_auth()\n                if detect_other_protocol(handshake_server_bytes):\n                    raise_protocol_error(handshake_server_bytes)\n                raise_handshake()\n\n            # These are semi-common errors with TLSv1.2 on Windows 7 an 8\n            # that appears to be due to poor handling of the\n            # ServerKeyExchange for DHE_RSA cipher suites. The solution\n            # is to retry the handshake.\n            if result == Secur32Const.SEC_E_BUFFER_TOO_SMALL or result == Secur32Const.SEC_E_MESSAGE_ALTERED:\n                if 'TLSv1.2' in self._session._protocols:\n                    raise _TLSRetryError('TLS handshake failed')\n\n            if fail_late:\n                raise_disconnection()\n\n            if result == Secur32Const.SEC_E_INVALID_PARAMETER:\n                if get_dh_params_length(handshake_server_bytes) < 1024:\n                    raise_dh_params()\n\n            if result not in set([Secur32Const.SEC_E_OK, Secur32Const.SEC_I_CONTINUE_NEEDED]):\n                handle_error(result, TLSError)\n\n            if out_buffers[0].cbBuffer > 0:\n                token = bytes_from_buffer(out_buffers[0].pvBuffer, out_buffers[0].cbBuffer)\n                handshake_client_bytes += token\n                self._socket.send(token)\n                out_buffers[0].cbBuffer = 0\n                secur32.FreeContextBuffer(out_buffers[0].pvBuffer)\n                out_buffers[0].pvBuffer = null()\n\n            if in_buffers[1].BufferType == Secur32Const.SECBUFFER_EXTRA:\n                extra_amount = in_buffers[1].cbBuffer\n                self._received_bytes = self._received_bytes[-extra_amount:]\n                in_buffers[1].BufferType = Secur32Const.SECBUFFER_EMPTY\n                in_buffers[1].cbBuffer = 0\n                secur32.FreeContextBuffer(in_buffers[1].pvBuffer)\n                in_buffers[1].pvBuffer = null()\n\n                # The handshake is complete, so discard any extra bytes\n                if result == Secur32Const.SEC_E_OK:\n                    handshake_server_bytes = handshake_server_bytes[-extra_amount:]\n\n            else:\n                self._received_bytes = b''\n\n        connection_info_pointer = struct(secur32, 'SecPkgContext_ConnectionInfo')\n        result = secur32.QueryContextAttributesW(\n            temp_context_handle_pointer,\n            Secur32Const.SECPKG_ATTR_CONNECTION_INFO,\n            connection_info_pointer\n        )\n        handle_error(result, TLSError)\n\n        connection_info = unwrap(connection_info_pointer)\n\n        self._protocol = {\n            Secur32Const.SP_PROT_SSL2_CLIENT: 'SSLv2',\n            Secur32Const.SP_PROT_SSL3_CLIENT: 'SSLv3',\n            Secur32Const.SP_PROT_TLS1_CLIENT: 'TLSv1',\n            Secur32Const.SP_PROT_TLS1_1_CLIENT: 'TLSv1.1',\n            Secur32Const.SP_PROT_TLS1_2_CLIENT: 'TLSv1.2',\n        }.get(native(int, connection_info.dwProtocol), str_cls(connection_info.dwProtocol))\n\n        if self._protocol in set(['SSLv3', 'TLSv1', 'TLSv1.1', 'TLSv1.2']):\n            session_info = parse_session_info(handshake_server_bytes, handshake_client_bytes)\n            self._cipher_suite = session_info['cipher_suite']\n            self._compression = session_info['compression']\n            self._session_id = session_info['session_id']\n            self._session_ticket = session_info['session_ticket']\n\n        output_context_flags = deref(output_context_flags_pointer)\n\n        for flag in requested_flags:\n            if (flag | output_context_flags) == 0:\n                raise OSError(pretty_message(\n                    '''\n                    Unable to obtain a credential context with the property %s\n                    ''' ,\n                    requested_flags[flag]\n                ))\n\n        if not renegotiate:\n            self._context_handle_pointer = temp_context_handle_pointer\n            new_context_handle_pointer = None\n\n            stream_sizes_pointer = struct(secur32, 'SecPkgContext_StreamSizes')\n            result = secur32.QueryContextAttributesW(\n                self._context_handle_pointer,\n                Secur32Const.SECPKG_ATTR_STREAM_SIZES,\n                stream_sizes_pointer\n            )\n            handle_error(result)\n\n            stream_sizes = unwrap(stream_sizes_pointer)\n            self._header_size = native(int, stream_sizes.cbHeader)\n            self._message_size = native(int, stream_sizes.cbMaximumMessage)\n            self._trailer_size = native(int, stream_sizes.cbTrailer)\n            self._buffer_size = self._header_size + self._message_size + self._trailer_size\n\n        if self._session._extra_trust_roots:\n            self._extra_trust_root_validation()\n\n    except (OSError, socket_.error):\n        self.close()\n\n        raise\n\n    finally:\n        if out_buffers:\n            if not is_null(out_buffers[0].pvBuffer):\n                secur32.FreeContextBuffer(out_buffers[0].pvBuffer)\n            if not is_null(out_buffers[1].pvBuffer):\n                secur32.FreeContextBuffer(out_buffers[1].pvBuffer)\n        if new_context_handle_pointer:\n            secur32.DeleteSecurityContext(new_context_handle_pointer)",
          "triple_sequences": [
            {
              "action_api": "secur32.InitializeSecurityContextW()",
              "action_description": "Wraps socket for SSL/TLS communication",
              "action_id": "wrap_socket_ssl",
              "object": "self._session._credentials_handle, first_handle, self._hostname, self._context_flags, 0, 0, null(), 0, second_handle, out_sec_buffer_desc_pointer, output_context_flags_pointer, null()",
              "object_description": "Socket address",
              "object_id": "socket_address",
              "intention_description": "Establish connection",
              "intention_id": "establish_connection"
            },
            {
              "action_api": "self._socket.send()",
              "action_description": "Sends data over socket connection",
              "action_id": "send_socket_data",
              "object": "token",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Establish connection",
              "intention_id": "establish_connection"
            },
            {
              "action_api": "self._socket.recv()",
              "action_description": "Receives data from socket connection",
              "action_id": "receive_socket_data",
              "object": "8192",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Establish connection",
              "intention_id": "establish_connection"
            },
            {
              "action_api": "secur32.FreeContextBuffer()",
              "action_description": "Frees memory allocated by LocalAlloc",
              "action_id": "free_local_memory",
              "object": "out_buffers[0].pvBuffer",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Release system resource",
              "intention_id": "release_system_resource"
            },
            {
              "action_api": "secur32.QueryContextAttributesW()",
              "action_description": "Retrieves local address of the socket",
              "action_id": "get_socket_local_addr",
              "object": "temp_context_handle_pointer, Secur32Const.SECPKG_ATTR_CONNECTION_INFO, connection_info_pointer",
              "object_description": "Socket address",
              "object_id": "socket_address",
              "intention_description": "Get system info",
              "intention_id": "get_system_info"
            },
            {
              "action_api": "unwrap()",
              "action_description": "Deserializes Python object from bytes",
              "action_id": "deserialize_from_bytes",
              "object": "connection_info_pointer",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "parse_session_info()",
              "action_description": "Deserializes Python object from bytes",
              "action_id": "deserialize_from_bytes",
              "object": "handshake_server_bytes, handshake_client_bytes",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "secur32.QueryContextAttributesW()",
              "action_description": "Retrieves local address of the socket",
              "action_id": "get_socket_local_addr",
              "object": "self._context_handle_pointer, Secur32Const.SECPKG_ATTR_STREAM_SIZES, stream_sizes_pointer",
              "object_description": "Socket address",
              "object_id": "socket_address",
              "intention_description": "Get system info",
              "intention_id": "get_system_info"
            },
            {
              "action_api": "unwrap()",
              "action_description": "Deserializes Python object from bytes",
              "action_id": "deserialize_from_bytes",
              "object": "stream_sizes_pointer",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "secur32.FreeContextBuffer()",
              "action_description": "Frees memory allocated by LocalAlloc",
              "action_id": "free_local_memory",
              "object": "out_buffers[1].pvBuffer",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Release system resource",
              "intention_id": "release_system_resource"
            },
            {
              "action_api": "secur32.DeleteSecurityContext()",
              "action_description": "Closes the socket connection",
              "action_id": "close_socket",
              "object": "new_context_handle_pointer",
              "object_description": "Socket address",
              "object_id": "socket_address",
              "intention_description": "Release system resource",
              "intention_id": "release_system_resource"
            }
          ]
        }
      ]
    }
  ]
}