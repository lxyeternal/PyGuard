{
  "metadata": {
    "package_name": "aliyun-python-sdk-core-2",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/aliyun-python-sdk-core-2.16.0.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "connection.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/aliyun-python-sdk-core-2.16.0/aliyun-python-sdk-core-2.16.0/aliyunsdkcore/vendored/requests/packages/urllib3/connection.py",
      "line_number": "220",
      "type_description": "B805:send",
      "context_snippet": "def request_chunked(self, method, url, body=None, headers=None):\n    \"\"\"\n    Alternative to the common request method, which sends the\n    body with chunked encoding and not as one block\n    \"\"\"\n    headers = HTTPHeaderDict(headers if headers is not None else {})\n    skip_accept_encoding = 'accept-encoding' in headers\n    skip_host = 'host' in headers\n    self.putrequest(\n        method,\n        url,\n        skip_accept_encoding=skip_accept_encoding,\n        skip_host=skip_host\n    )\n    for header, value in headers.items():\n        self.putheader(header, value)\n    if 'transfer-encoding' not in headers:\n        self.putheader('Transfer-Encoding', 'chunked')\n    self.endheaders()\n\n    if body is not None:\n        stringish_types = six.string_types + (bytes,)\n        if isinstance(body, stringish_types):\n            body = (body,)\n        for chunk in body:\n            if not chunk:\n                continue\n            if not isinstance(chunk, bytes):\n                chunk = chunk.encode('utf8')\n            len_str = hex(len(chunk))[2:]\n            self.send(len_str.encode('utf-8'))\n            self.send(b'\\r\\n')\n            self.send(chunk)\n            self.send(b'\\r\\n')\n\n    # After the if clause, to always have a closed body\n    self.send(b'0\\r\\n\\r\\n')",
      "hash_value": "307bc1a53d8c1071f5b96cbb7225d892",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "def request_chunked(self, method, url, body=None, headers=None):\n    \"\"\"\n    Alternative to the common request method, which sends the\n    body with chunked encoding and not as one block\n    \"\"\"\n    headers = HTTPHeaderDict(headers if headers is not None else {})\n    skip_accept_encoding = 'accept-encoding' in headers\n    skip_host = 'host' in headers\n    self.putrequest(\n        method,\n        url,\n        skip_accept_encoding=skip_accept_encoding,\n        skip_host=skip_host\n    )\n    for header, value in headers.items():\n        self.putheader(header, value)\n    if 'transfer-encoding' not in headers:\n        self.putheader('Transfer-Encoding', 'chunked')\n    self.endheaders()\n\n    if body is not None:\n        stringish_types = six.string_types + (bytes,)\n        if isinstance(body, stringish_types):\n            body = (body,)\n        for chunk in body:\n            if not chunk:\n                continue\n            if not isinstance(chunk, bytes):\n                chunk = chunk.encode('utf8')\n            len_str = hex(len(chunk))[2:]\n            self.send(len_str.encode('utf-8'))\n            self.send(b'\\r\\n')\n            self.send(chunk)\n            self.send(b'\\r\\n')\n\n    # After the if clause, to always have a closed body\n    self.send(b'0\\r\\n\\r\\n')",
          "triple_sequences": [
            {
              "action_api": "HTTPHeaderDict()",
              "action_description": "Creates HTTP header to request object",
              "action_id": "add_http_header",
              "object": "headers if headers is not None else {}",
              "object_description": "HTTP request/response headers",
              "object_id": "http_headers",
              "intention_description": "Prepare URL for HTTP request",
              "intention_id": "prepare_url_http_request"
            },
            {
              "action_api": "self.putrequest()",
              "action_description": "Creates HTTP request object with specified URL, data, and headers",
              "action_id": "create_http_request",
              "object": "method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Prepare URL for HTTP request",
              "intention_id": "prepare_url_http_request"
            },
            {
              "action_api": "self.putheader()",
              "action_description": "Adds HTTP header to request object",
              "action_id": "add_http_header",
              "object": "header, value",
              "object_description": "HTTP header",
              "object_id": "http_header",
              "intention_description": "Prepare URL for HTTP request",
              "intention_id": "prepare_url_http_request"
            },
            {
              "action_api": "self.putheader()",
              "action_description": "Adds HTTP header to request object",
              "action_id": "add_http_header",
              "object": "'Transfer-Encoding', 'chunked'",
              "object_description": "Transfer encoding type",
              "object_id": "transfer_encoding",
              "intention_description": "Prepare URL for HTTP request",
              "intention_id": "prepare_url_http_request"
            },
            {
              "action_api": "self.endheaders()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Establish connection",
              "intention_id": "establish_connection"
            },
            {
              "action_api": "isinstance()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "body, stringish_types",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "chunk.encode()",
              "action_description": "Encodes string to bytes using default encoding",
              "action_id": "encode_string_to_bytes",
              "object": "chunk",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "hex()",
              "action_description": "Converts integer to hexadecimal string",
              "action_id": "convert_int_to_hex",
              "object": "len(chunk)",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "str.encode()",
              "action_description": "Encodes string to bytes using default encoding",
              "action_id": "encode_string_to_bytes",
              "object": "len_str",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "self.send()",
              "action_description": "Sends data over socket connection",
              "action_id": "send_socket_data",
              "object": "len_str.encode('utf-8')",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Transmit encoded data via HTTP POST",
              "intention_id": "transmit_data_http_post"
            },
            {
              "action_api": "self.send()",
              "action_description": "Sends data over socket connection",
              "action_id": "send_socket_data",
              "object": "b'\\r\\n'",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Transmit encoded data via HTTP POST",
              "intention_id": "transmit_data_http_post"
            },
            {
              "action_api": "self.send()",
              "action_description": "Sends data over socket connection",
              "action_id": "send_socket_data",
              "object": "chunk",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Transmit encoded data via HTTP POST",
              "intention_id": "transmit_data_http_post"
            },
            {
              "action_api": "self.send()",
              "action_description": "Sends data over socket connection",
              "action_id": "send_socket_data",
              "object": "b'\\r\\n'",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Transmit encoded data via HTTP POST",
              "intention_id": "transmit_data_http_post"
            },
            {
              "action_api": "self.send()",
              "action_description": "Sends data over socket connection",
              "action_id": "send_socket_data",
              "object": "b'0\\r\\n\\r\\n'",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Transmit encoded data via HTTP POST",
              "intention_id": "transmit_data_http_post"
            }
          ]
        }
      ]
    }
  ]
}