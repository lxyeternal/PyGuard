{
  "metadata": {
    "package_name": "shrike-2",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/shrike-2.0.0rc2.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "dask.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/shrike-2.0.0rc2/shrike-2.0.0rc2/shrike/distributed/dask.py",
      "line_number": "128",
      "type_description": "B803:gethostname",
      "context_snippet": "@experimental(message=EXPERIMENTAL_WARNING_MSG)\ndef setup_head_node(self):\n    \"\"\"Setup to run only on head node\"\"\"\n    self._log_info_publicly(EXPERIMENTAL_WARNING_MSG)\n    self._log_info_publicly(\n        f\"{self.__class__.__name__}.setup_head_node() called to set up HEAD node.\"\n    )\n    # create setup config\n    self.head_address = socket.gethostbyname(socket.gethostname())\n\n    # record what's needed to setup cluster nodes\n    self.setup_config_add_key(\"head_address\", self.head_address)\n\n    self.pid = os.fork()  # type: ignore\n    if self.pid > 0:\n        self.rank = \"0.1\"\n\n        async def run_scheduler():\n            async with Scheduler(\n                port=self.head_port, scheduler_file=\"scheduler.json\"\n            ) as scheduler:\n                await scheduler.finished()\n\n        asyncio.get_event_loop().run_until_complete(run_scheduler())\n        self._log_info_publicly(f\"[R{self.rank}]SCHEDULER IS OFFLINE\")\n        self.multinode_driver.finalize()\n        sys.exit(0)\n",
      "hash_value": "0dd9965e83831b484f05a212906f4e43",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "@experimental(message=EXPERIMENTAL_WARNING_MSG)\ndef setup_head_node(self):\n    \"\"\"Setup to run only on head node\"\"\"\n    self._log_info_publicly(EXPERIMENTAL_WARNING_MSG)\n    self._log_info_publicly(\n        f\"{self.__class__.__name__}.setup_head_node() called to set up HEAD node.\"\n    )\n    # create setup config\n    self.head_address = socket.gethostbyname(socket.gethostname())\n\n    # record what's needed to setup cluster nodes\n    self.setup_config_add_key(\"head_address\", self.head_address)\n\n    self.pid = os.fork()  # type: ignore\n    if self.pid > 0:\n        self.rank = \"0.1\"\n\n        async def run_scheduler():\n            async with Scheduler(\n                port=self.head_port, scheduler_file=\"scheduler.json\"\n            ) as scheduler:\n                await scheduler.finished()\n\n        asyncio.get_event_loop().run_until_complete(run_scheduler())\n        self._log_info_publicly(f\"[R{self.rank}]SCHEDULER IS OFFLINE\")\n        self.multinode_driver.finalize()\n        sys.exit(0)\n",
          "triple_sequences": [
            {
              "action_api": "socket.gethostname()",
              "action_description": "Retrieves current host name",
              "action_id": "get_hostname",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get system hostname",
              "intention_id": "get_system_hostname"
            },
            {
              "action_api": "socket.gethostbyname()",
              "action_description": "Resolves host name to IPv4 address",
              "action_id": "resolve_hostname",
              "object": "socket.gethostname()",
              "object_description": "System hostname",
              "object_id": "system_hostname",
              "intention_description": "Resolve hostname to IP address",
              "intention_id": "resolve_hostname_ip"
            },
            {
              "action_api": "self.setup_config_add_key()",
              "action_description": "Sets value for registry key",
              "action_id": "set_registry_value",
              "object": "\"head_address\", self.head_address",
              "object_description": "Registry value",
              "object_id": "registry_value",
              "intention_description": "Access configuration value",
              "intention_id": "access_configuration_value"
            },
            {
              "action_api": "os.fork()",
              "action_description": "Creates child process",
              "action_id": "create_child_process",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Create child process",
              "intention_id": "create_child_process"
            },
            {
              "action_api": "asyncio.get_event_loop()",
              "action_description": "Runs asynchronous function until completion",
              "action_id": "run_async_function",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for events",
              "intention_id": "wait_for_events"
            },
            {
              "action_api": "asyncio.get_event_loop().run_until_complete()",
              "action_description": "Runs asynchronous function until completion",
              "action_id": "run_async_function",
              "object": "run_scheduler()",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Wait for events",
              "intention_id": "wait_for_events"
            },
            {
              "action_api": "self.multinode_driver.finalize()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Release system resource",
              "intention_id": "release_system_resource"
            },
            {
              "action_api": "sys.exit()",
              "action_description": "Exits program",
              "action_id": "exit_program",
              "object": "0",
              "object_description": "",
              "object_id": "",
              "intention_description": "Terminate program execution",
              "intention_id": "terminate_program_execution"
            }
          ]
        }
      ]
    }
  ]
}