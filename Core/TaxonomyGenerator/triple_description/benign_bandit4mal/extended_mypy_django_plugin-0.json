{
  "metadata": {
    "package_name": "extended_mypy_django_plugin-0",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/extended_mypy_django_plugin-0.8.0.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "pyproject.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/extended_mypy_django_plugin-0.8.0/extended_mypy_django_plugin-0.8.0/tools/.bootstrap-venv/lib/python3.10/site-packages/pip/_internal/pyproject.py",
      "line_number": "64",
      "type_description": "B814:read",
      "context_snippet": "def load_pyproject_toml(\n    use_pep517: Optional[bool], pyproject_toml: str, setup_py: str, req_name: str\n) -> Optional[BuildSystemDetails]:\n    \"\"\"Load the pyproject.toml file.\n\n    Parameters:\n        use_pep517 - Has the user requested PEP 517 processing? None\n                     means the user hasn't explicitly specified.\n        pyproject_toml - Location of the project's pyproject.toml file\n        setup_py - Location of the project's setup.py file\n        req_name - The name of the requirement we're processing (for\n                   error reporting)\n\n    Returns:\n        None if we should use the legacy code path, otherwise a tuple\n        (\n            requirements from pyproject.toml,\n            name of PEP 517 backend,\n            requirements we should check are installed after setting\n                up the build environment\n            directory paths to import the backend from (backend-path),\n                relative to the project root.\n        )\n    \"\"\"\n    has_pyproject = os.path.isfile(pyproject_toml)\n    has_setup = os.path.isfile(setup_py)\n\n    if not has_pyproject and not has_setup:\n        raise InstallationError(\n            f\"{req_name} does not appear to be a Python project: \"\n            f\"neither 'setup.py' nor 'pyproject.toml' found.\"\n        )\n\n    if has_pyproject:\n        with open(pyproject_toml, encoding=\"utf-8\") as f:\n            pp_toml = tomli.loads(f.read())\n        build_system = pp_toml.get(\"build-system\")\n    else:\n        build_system = None\n\n    # The following cases must use PEP 517\n    # We check for use_pep517 being non-None and falsey because that means\n    # the user explicitly requested --no-use-pep517.  The value 0 as\n    # opposed to False can occur when the value is provided via an\n    # environment variable or config file option (due to the quirk of\n    # strtobool() returning an integer in pip's configuration code).\n    if has_pyproject and not has_setup:\n        if use_pep517 is not None and not use_pep517:\n            raise InstallationError(\n                \"Disabling PEP 517 processing is invalid: \"\n                \"project does not have a setup.py\"\n            )\n        use_pep517 = True\n    elif build_system and \"build-backend\" in build_system:\n        if use_pep517 is not None and not use_pep517:\n            raise InstallationError(\n                \"Disabling PEP 517 processing is invalid: \"\n                \"project specifies a build backend of {} \"\n                \"in pyproject.toml\".format(build_system[\"build-backend\"])\n            )\n        use_pep517 = True\n\n    # If we haven't worked out whether to use PEP 517 yet,\n    # and the user hasn't explicitly stated a preference,\n    # we do so if the project has a pyproject.toml file\n    # or if we cannot import setuptools.\n\n    # We fallback to PEP 517 when without setuptools,\n    # so setuptools can be installed as a default build backend.\n    # For more info see:\n    # https://discuss.python.org/t/pip-without-setuptools-could-the-experience-be-improved/11810/9\n    elif use_pep517 is None:\n        use_pep517 = has_pyproject or not importlib.util.find_spec(\"setuptools\")\n\n    # At this point, we know whether we're going to use PEP 517.\n    assert use_pep517 is not None\n\n    # If we're using the legacy code path, there is nothing further\n    # for us to do here.\n    if not use_pep517:\n        return None\n\n    if build_system is None:\n        # Either the user has a pyproject.toml with no build-system\n        # section, or the user has no pyproject.toml, but has opted in\n        # explicitly via --use-pep517.\n        # In the absence of any explicit backend specification, we\n        # assume the setuptools backend that most closely emulates the\n        # traditional direct setup.py execution, and require wheel and\n        # a version of setuptools that supports that backend.\n\n        build_system = {\n            \"requires\": [\"setuptools>=40.8.0\", \"wheel\"],\n            \"build-backend\": \"setuptools.build_meta:__legacy__\",\n        }\n\n    # If we're using PEP 517, we have build system information (either\n    # from pyproject.toml, or defaulted by the code above).\n    # Note that at this point, we do not know if the user has actually\n    # specified a backend, though.\n    assert build_system is not None\n\n    # Ensure that the build-system section in pyproject.toml conforms\n    # to PEP 518.\n\n    # Specifying the build-system table but not the requires key is invalid\n    if \"requires\" not in build_system:\n        raise MissingPyProjectBuildRequires(package=req_name)\n\n    # Error out if requires is not a list of strings\n    requires = build_system[\"requires\"]\n    if not _is_list_of_str(requires):\n        raise InvalidPyProjectBuildRequires(\n            package=req_name,\n            reason=\"It is not a list of strings.\",\n        )\n\n    # Each requirement must be valid as per PEP 508\n    for requirement in requires:\n        try:\n            Requirement(requirement)\n        except InvalidRequirement as error:\n            raise InvalidPyProjectBuildRequires(\n                package=req_name,\n                reason=f\"It contains an invalid requirement: {requirement!r}\",\n            ) from error\n\n    backend = build_system.get(\"build-backend\")\n    backend_path = build_system.get(\"backend-path\", [])\n    check: List[str] = []\n    if backend is None:\n        # If the user didn't specify a backend, we assume they want to use\n        # the setuptools backend. But we can't be sure they have included\n        # a version of setuptools which supplies the backend. So we\n        # make a note to check that this requirement is present once\n        # we have set up the environment.\n        # This is quite a lot of work to check for a very specific case. But\n        # the problem is, that case is potentially quite common - projects that\n        # adopted PEP 518 early for the ability to specify requirements to\n        # execute setup.py, but never considered needing to mention the build\n        # tools themselves. The original PEP 518 code had a similar check (but\n        # implemented in a different way).\n        backend = \"setuptools.build_meta:__legacy__\"\n        check = [\"setuptools>=40.8.0\"]\n\n    return BuildSystemDetails(requires, backend, check, backend_path)\n",
      "hash_value": "16e3c6c2e126f73b4110e4f7a7dfc755",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "def load_pyproject_toml(\n    use_pep517: Optional[bool], pyproject_toml: str, setup_py: str, req_name: str\n) -> Optional[BuildSystemDetails]:\n    \"\"\"Load the pyproject.toml file.\n\n    Parameters:\n        use_pep517 - Has the user requested PEP 517 processing? None\n                     means the user hasn't explicitly specified.\n        pyproject_toml - Location of the project's pyproject.toml file\n        setup_py - Location of the project's setup.py file\n        req_name - The name of the requirement we're processing (for\n                   error reporting)\n\n    Returns:\n        None if we should use the legacy code path, otherwise a tuple\n        (\n            requirements from pyproject.toml,\n            name of PEP 517 backend,\n            requirements we should check are installed after setting\n                up the build environment\n            directory paths to import the backend from (backend-path),\n                relative to the project root.\n        )\n    \"\"\"\n    has_pyproject = os.path.isfile(pyproject_toml)\n    has_setup = os.path.isfile(setup_py)\n\n    if not has_pyproject and not has_setup:\n        raise InstallationError(\n            f\"{req_name} does not appear to be a Python project: \"\n            f\"neither 'setup.py' nor 'pyproject.toml' found.\"\n        )\n\n    if has_pyproject:\n        with open(pyproject_toml, encoding=\"utf-8\") as f:\n            pp_toml = tomli.loads(f.read())\n        build_system = pp_toml.get(\"build-system\")\n    else:\n        build_system = None\n\n    # The following cases must use PEP 517\n    # We check for use_pep517 being non-None and falsey because that means\n    # the user explicitly requested --no-use-pep517.  The value 0 as\n    # opposed to False can occur when the value is provided via an\n    # environment variable or config file option (due to the quirk of\n    # strtobool() returning an integer in pip's configuration code).\n    if has_pyproject and not has_setup:\n        if use_pep517 is not None and not use_pep517:\n            raise InstallationError(\n                \"Disabling PEP 517 processing is invalid: \"\n                \"project does not have a setup.py\"\n            )\n        use_pep517 = True\n    elif build_system and \"build-backend\" in build_system:\n        if use_pep517 is not None and not use_pep517:\n            raise InstallationError(\n                \"Disabling PEP 517 processing is invalid: \"\n                \"project specifies a build backend of {} \"\n                \"in pyproject.toml\".format(build_system[\"build-backend\"])\n            )\n        use_pep517 = True\n\n    # If we haven't worked out whether to use PEP 517 yet,\n    # and the user hasn't explicitly stated a preference,\n    # we do so if the project has a pyproject.toml file\n    # or if we cannot import setuptools.\n\n    # We fallback to PEP 517 when without setuptools,\n    # so setuptools can be installed as a default build backend.\n    # For more info see:\n    # https://discuss.python.org/t/pip-without-setuptools-could-the-experience-be-improved/11810/9\n    elif use_pep517 is None:\n        use_pep517 = has_pyproject or not importlib.util.find_spec(\"setuptools\")\n\n    # At this point, we know whether we're going to use PEP 517.\n    assert use_pep517 is not None\n\n    # If we're using the legacy code path, there is nothing further\n    # for us to do here.\n    if not use_pep517:\n        return None\n\n    if build_system is None:\n        # Either the user has a pyproject.toml with no build-system\n        # section, or the user has no pyproject.toml, but has opted in\n        # explicitly via --use-pep517.\n        # In the absence of any explicit backend specification, we\n        # assume the setuptools backend that most closely emulates the\n        # traditional direct setup.py execution, and require wheel and\n        # a version of setuptools that supports that backend.\n\n        build_system = {\n            \"requires\": [\"setuptools>=40.8.0\", \"wheel\"],\n            \"build-backend\": \"setuptools.build_meta:__legacy__\",\n        }\n\n    # If we're using PEP 517, we have build system information (either\n    # from pyproject.toml, or defaulted by the code above).\n    # Note that at this point, we do not know if the user has actually\n    # specified a backend, though.\n    assert build_system is not None\n\n    # Ensure that the build-system section in pyproject.toml conforms\n    # to PEP 518.\n\n    # Specifying the build-system table but not the requires key is invalid\n    if \"requires\" not in build_system:\n        raise MissingPyProjectBuildRequires(package=req_name)\n\n    # Error out if requires is not a list of strings\n    requires = build_system[\"requires\"]\n    if not _is_list_of_str(requires):\n        raise InvalidPyProjectBuildRequires(\n            package=req_name,\n            reason=\"It is not a list of strings.\",\n        )\n\n    # Each requirement must be valid as per PEP 508\n    for requirement in requires:\n        try:\n            Requirement(requirement)\n        except InvalidRequirement as error:\n            raise InvalidPyProjectBuildRequires(\n                package=req_name,\n                reason=f\"It contains an invalid requirement: {requirement!r}\",\n            ) from error\n\n    backend = build_system.get(\"build-backend\")\n    backend_path = build_system.get(\"backend-path\", [])\n    check: List[str] = []\n    if backend is None:\n        # If the user didn't specify a backend, we assume they want to use\n        # the setuptools backend. But we can't be sure they have included\n        # a version of setuptools which supplies the backend. So we\n        # make a note to check that this requirement is present once\n        # we have set up the environment.\n        # This is quite a lot of work to check for a very specific case. But\n        # the problem is, that case is potentially quite common - projects that\n        # adopted PEP 518 early for the ability to specify requirements to\n        # execute setup.py, but never considered needing to mention the build\n        # tools themselves. The original PEP 518 code had a similar check (but\n        # implemented in a different way).\n        backend = \"setuptools.build_meta:__legacy__\"\n        check = [\"setuptools>=40.8.0\"]\n\n    return BuildSystemDetails(requires, backend, check, backend_path)\n",
          "triple_sequences": [
            {
              "action_api": "os.path.isfile()",
              "action_description": "Checks if specified path exists and is a file",
              "action_id": "check_file_is_file",
              "object": "pyproject_toml",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Determine_file_presence",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "os.path.isfile()",
              "action_description": "Checks if specified path exists and is a file",
              "action_id": "check_file_is_file",
              "object": "setup_py",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Determine_file_presence",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "pyproject_toml",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Open_file_reading",
              "intention_id": "open_file_reading"
            },
            {
              "action_api": "f.read()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Read_file_content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "tomli.loads()",
              "action_description": "Deserializes JSON string to Python object",
              "action_id": "deserialize_from_json",
              "object": "f.read()",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Parse_json_data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "pp_toml.get()",
              "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
              "action_id": "path_object_operations",
              "object": "\"build-system\"",
              "object_description": "String containing environment data",
              "object_id": "string_environment_data",
              "intention_description": "Access_configuration_value",
              "intention_id": "access_configuration_value"
            },
            {
              "action_api": "importlib.util.find_spec()",
              "action_description": "Dynamically imports specified module",
              "action_id": "import_dynamic",
              "object": "\"setuptools\"",
              "object_description": "Module name string",
              "object_id": "module_name_string",
              "intention_description": "Determine_required_module_presence",
              "intention_id": "determine_required_module_presence"
            },
            {
              "action_api": "build_system.get()",
              "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
              "action_id": "path_object_operations",
              "object": "\"build-backend\"",
              "object_description": "String containing environment data",
              "object_id": "string_environment_data",
              "intention_description": "Access_configuration_value",
              "intention_id": "access_configuration_value"
            },
            {
              "action_api": "build_system.get()",
              "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
              "action_id": "path_object_operations",
              "object": "\"backend-path\", []",
              "object_description": "String containing environment data",
              "object_id": "string_environment_data",
              "intention_description": "Access_configuration_value",
              "intention_id": "access_configuration_value"
            }
          ]
        }
      ]
    }
  ]
}