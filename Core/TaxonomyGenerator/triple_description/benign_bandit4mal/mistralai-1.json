{
  "metadata": {
    "package_name": "mistralai-1",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/mistralai-1.6.0.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "basesdk.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/mistralai-1.6.0/mistralai-1.6.0/packages/mistralai_gcp/src/mistralai_gcp/basesdk.py",
      "line_number": "199",
      "type_description": "B825:request",
      "context_snippet": "def _build_request_with_client(\n    self,\n    client,\n    method,\n    path,\n    base_url,\n    url_variables,\n    request,\n    request_body_required,\n    request_has_path_params,\n    request_has_query_params,\n    user_agent_header,\n    accept_header_value,\n    _globals=None,\n    security=None,\n    timeout_ms: Optional[int] = None,\n    get_serialized_body: Optional[\n        Callable[[], Optional[SerializedRequestBody]]\n    ] = None,\n    url_override: Optional[str] = None,\n    http_headers: Optional[Mapping[str, str]] = None,\n) -> httpx.Request:\n    query_params = {}\n\n    url = url_override\n    if url is None:\n        url = utils.generate_url(\n            self._get_url(base_url, url_variables),\n            path,\n            request if request_has_path_params else None,\n            _globals if request_has_path_params else None,\n        )\n\n        query_params = utils.get_query_params(\n            request if request_has_query_params else None,\n            _globals if request_has_query_params else None,\n        )\n    else:\n        # Pick up the query parameter from the override so they can be\n        # preserved when building the request later on (necessary as of\n        # httpx 0.28).\n        parsed_override = urlparse(str(url_override))\n        query_params = parse_qs(parsed_override.query, keep_blank_values=True)\n\n    headers = utils.get_headers(request, _globals)\n    headers[\"Accept\"] = accept_header_value\n    headers[user_agent_header] = self.sdk_configuration.user_agent\n\n    if security is not None:\n        if callable(security):\n            security = security()\n\n    if security is not None:\n        security_headers, security_query_params = utils.get_security(security)\n        headers = {**headers, **security_headers}\n        query_params = {**query_params, **security_query_params}\n\n    serialized_request_body = SerializedRequestBody()\n    if get_serialized_body is not None:\n        rb = get_serialized_body()\n        if request_body_required and rb is None:\n            raise ValueError(\"request body is required\")\n\n        if rb is not None:\n            serialized_request_body = rb\n\n    if (\n        serialized_request_body.media_type is not None\n        and serialized_request_body.media_type\n        not in (\n            \"multipart/form-data\",\n            \"multipart/mixed\",\n        )\n    ):\n        headers[\"content-type\"] = serialized_request_body.media_type\n\n    if http_headers is not None:\n        for header, value in http_headers.items():\n            headers[header] = value\n\n    timeout = timeout_ms / 1000 if timeout_ms is not None else None\n\n    return client.build_request(\n        method,\n        url,\n        params=query_params,\n        content=serialized_request_body.content,\n        data=serialized_request_body.data,\n        files=serialized_request_body.files,\n        headers=headers,\n        timeout=timeout,\n    )",
      "hash_value": "0e1b4a3f5728904fc16c9e5201a3004f",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "def _build_request_with_client(\n    self,\n    client,\n    method,\n    path,\n    base_url,\n    url_variables,\n    request,\n    request_body_required,\n    request_has_path_params,\n    request_has_query_params,\n    user_agent_header,\n    accept_header_value,\n    _globals=None,\n    security=None,\n    timeout_ms: Optional[int] = None,\n    get_serialized_body: Optional[\n        Callable[[], Optional[SerializedRequestBody]]\n    ] = None,\n    url_override: Optional[str] = None,\n    http_headers: Optional[Mapping[str, str]] = None,\n) -> httpx.Request:\n    query_params = {}\n\n    url = url_override\n    if url is None:\n        url = utils.generate_url(\n            self._get_url(base_url, url_variables),\n            path,\n            request if request_has_path_params else None,\n            _globals if request_has_path_params else None,\n        )\n\n        query_params = utils.get_query_params(\n            request if request_has_query_params else None,\n            _globals if request_has_query_params else None,\n        )\n    else:\n        # Pick up the query parameter from the override so they can be\n        # preserved when building the request later on (necessary as of\n        # httpx 0.28).\n        parsed_override = urlparse(str(url_override))\n        query_params = parse_qs(parsed_override.query, keep_blank_values=True)\n\n    headers = utils.get_headers(request, _globals)\n    headers[\"Accept\"] = accept_header_value\n    headers[user_agent_header] = self.sdk_configuration.user_agent\n\n    if security is not None:\n        if callable(security):\n            security = security()\n\n    if security is not None:\n        security_headers, security_query_params = utils.get_security(security)\n        headers = {**headers, **security_headers}\n        query_params = {**query_params, **security_query_params}\n\n    serialized_request_body = SerializedRequestBody()\n    if get_serialized_body is not None:\n        rb = get_serialized_body()\n        if request_body_required and rb is None:\n            raise ValueError(\"request body is required\")\n\n        if rb is not None:\n            serialized_request_body = rb\n\n    if (\n        serialized_request_body.media_type is not None\n        and serialized_request_body.media_type\n        not in (\n            \"multipart/form-data\",\n            \"multipart/mixed\",\n        )\n    ):\n        headers[\"content-type\"] = serialized_request_body.media_type\n\n    if http_headers is not None:\n        for header, value in http_headers.items():\n            headers[header] = value\n\n    timeout = timeout_ms / 1000 if timeout_ms is not None else None\n\n    return client.build_request(\n        method,\n        url,\n        params=query_params,\n        content=serialized_request_body.content,\n        data=serialized_request_body.data,\n        files=serialized_request_body.files,\n        headers=headers,\n        timeout=timeout,\n    )",
          "triple_sequences": [
            {
              "action_api": "utils.generate_url()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "self._get_url(base_url, url_variables), path, request if request_has_path_params else None, _globals if request_has_path_params else None",
              "object_description": "URL string",
              "object_id": "url_string",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            },
            {
              "action_api": "utils.get_query_params()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "request if request_has_query_params else None, _globals if request_has_query_params else None",
              "object_description": "Query parameter",
              "object_id": "query_parameter",
              "intention_description": "Prepare URL for HTTP request",
              "intention_id": "prepare_url_http_request"
            },
            {
              "action_api": "urlparse()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "str(url_override)",
              "object_description": "URL string",
              "object_id": "url_string",
              "intention_description": "Prepare URL for HTTP request",
              "intention_id": "prepare_url_http_request"
            },
            {
              "action_api": "parse_qs()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "parsed_override.query, keep_blank_values=True",
              "object_description": "Query parameter",
              "object_id": "query_parameter",
              "intention_description": "Prepare URL for HTTP request",
              "intention_id": "prepare_url_http_request"
            },
            {
              "action_api": "utils.get_headers()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "request, _globals",
              "object_description": "HTTP headers",
              "object_id": "http_headers",
              "intention_description": "Prepare URL for HTTP request",
              "intention_id": "prepare_url_http_request"
            },
            {
              "action_api": "self.sdk_configuration.user_agent",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "",
              "object_description": "User agent string",
              "object_id": "user_agent_string",
              "intention_description": "Prepare URL for HTTP request",
              "intention_id": "prepare_url_http_request"
            },
            {
              "action_api": "utils.get_security()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "security",
              "object_description": "API key or token",
              "object_id": "api_key",
              "intention_description": "Prepare URL for HTTP request",
              "intention_id": "prepare_url_http_request"
            },
            {
              "action_api": "SerializedRequestBody()",
              "action_description": "Create bytes object from encoded string",
              "action_id": "create_bytes_encoded",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "get_serialized_body()",
              "action_description": "Create bytes object from encoded string",
              "action_id": "create_bytes_encoded",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "client.build_request()",
              "action_description": "Creates HTTP request object with specified URL, data, and headers",
              "action_id": "create_http_request",
              "object": "method, url, params=query_params, content=serialized_request_body.content, data=serialized_request_body.data, files=serialized_request_body.files, headers=headers, timeout=timeout",
              "object_description": "Request object for external domain",
              "object_id": "request_external_domain",
              "intention_description": "Prepare URL for HTTP request",
              "intention_id": "prepare_url_http_request"
            }
          ]
        }
      ]
    }
  ]
}