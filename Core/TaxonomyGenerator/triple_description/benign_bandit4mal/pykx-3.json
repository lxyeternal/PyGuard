{
  "metadata": {
    "package_name": "pykx-3",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/pykx-3.1.2-cp39-cp39-win_amd64.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "license.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pykx-3.1.2-cp39-cp39-win_amd64/pykx/license.py",
      "line_number": "104",
      "type_description": "B814:read",
      "context_snippet": "import base64\nimport os\nimport shutil\nfrom pathlib import Path\nfrom typing import Optional\n\nfrom . import licensed\nfrom .config import lic_type, qlic\n\n\ndef check(license: str,\n          *,\n          format: Optional[str] = 'FILE',\n          license_type: Optional[str] = lic_type\n) -> bool:\n    \"\"\"\n    Validate the license key information you provided matches the license\n        saved to disk which is read by PyKX\n\n    Parameters:\n        license: If using \"FILE\" format this is the location of the file being used for comparison.\n            If \"STRING\" this is the base64 encoded string provided in your license email\n        format: Is the license check being completed using a downloaded file or base64\n            encoded string. Accepted inputs are \"FILE\"(default) or \"STRING\".\n        license_type: The license file type/name which is to be checked, by default this\n            is 'kc.lic' which is the version provided with personal and commercial\n            evaluation licenses but can be changed to 'k4.lic' or 'kx.lic' if appropriate\n\n    Returns:\n        A boolean indicating if the license is correct or not and a printed message describing\n            the issue\n\n    Examples:\n\n    Validate that a provided license matches an existing persisted license\n\n    ```python\n    >>> import pykx as kx\n    >>> kx.license.check('/usr/location/kc.lic')\n    True\n    ```\n\n    Attempt to check a new license against an existing installed license\n\n    ```python\n    >>> import pykx as kx\n    >>> check = kx.license.check('/usr/location/kc.lic')\n    Supplied license information does not match.\n    Please consider reinstalling your license using pykx.license.install\n\n    Installed license representation:\n    b'iIXSiEWzCNTkkCWK5Gggy..'\n    User expected license representation:\n    b'IyEvdXNyL2Jpbi9lbngDf..'\n    >>> check\n    False\n    ```\n\n    Attempt to check a license in the case no license is currently installed\n\n    ```python\n    >>> import pykx as kx\n    >>> check = kx.license.check('setup.py', license_type='kc.lic')\n    Unable to find an installed license: kc.lic at location: /usr/local/anaconda3/envs/qenv/q.\n    Please consider installing your license again using pykx.license.install\n    >>> check\n    False\n    ```\n    \"\"\"\n    format = format.lower()\n    if format not in ('file', 'string'):\n        raise Exception('Unsupported option provided for format parameter')\n\n    if license_type not in ('kx.lic', 'kc.lic', 'k4.lic'):\n        raise Exception(f'License type {license_type} not supported.')\n\n    license_located = False\n    installed_lic = qlic/license_type\n    if os.path.exists(installed_lic):\n        license_located = True\n\n    if not license_located:\n        print(f'Unable to find an installed license: {license_type} at location: {str(qlic)}.\\n'\n              'Please consider installing your license again using pykx.license.install')\n        return False\n\n    with open(installed_lic, 'rb') as f:\n        license_content = base64.encodebytes(f.read()).decode('utf-8')\n        license_content = license_content.replace('\\n', '')\n        license_content = bytes(license_content, 'utf-8')\n\n    if format == 'file':\n        license_path = Path(os.path.expanduser(license))\n        if os.path.exists(license_path):\n            with open(str(license_path), 'rb') as f:\n                license = base64.encodebytes(f.read()).decode('utf-8')\n                license = license.replace('\\n', '')\n        else:\n            print(f'Unable to locate license {license_path} for comparison')\n            return False\n\n    if isinstance(license, str):\n        license = license.replace('\\n', '')\n        license = bytes(license, 'utf-8')\n\n    if not license_content == license:\n        print('Supplied license information does not match.\\n'\n              'Please consider reinstalling your license using pykx.license.install\\n\\n'\n              f'Installed license representation:\\n{license_content}\\n\\n'\n              f'User expected license representation:\\n{license}')\n        return False\n\n    return True",
      "hash_value": "69f7993993fbd15cc09d23fe498d3568",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "import base64\nimport os\nimport shutil\nfrom pathlib import Path\nfrom typing import Optional\n\nfrom . import licensed\nfrom .config import lic_type, qlic\n\n\ndef check(license: str,\n          *,\n          format: Optional[str] = 'FILE',\n          license_type: Optional[str] = lic_type\n) -> bool:\n    \"\"\"\n    Validate the license key information you provided matches the license\n        saved to disk which is read by PyKX\n\n    Parameters:\n        license: If using \"FILE\" format this is the location of the file being used for comparison.\n            If \"STRING\" this is the base64 encoded string provided in your license email\n        format: Is the license check being completed using a downloaded file or base64\n            encoded string. Accepted inputs are \"FILE\"(default) or \"STRING\".\n        license_type: The license file type/name which is to be checked, by default this\n            is 'kc.lic' which is the version provided with personal and commercial\n            evaluation licenses but can be changed to 'k4.lic' or 'kx.lic' if appropriate\n\n    Returns:\n        A boolean indicating if the license is correct or not and a printed message describing\n            the issue\n\n    Examples:\n\n    Validate that a provided license matches an existing persisted license\n\n    ```python\n    >>> import pykx as kx\n    >>> kx.license.check('/usr/location/kc.lic')\n    True\n    ```\n\n    Attempt to check a new license against an existing installed license\n\n    ```python\n    >>> import pykx as kx\n    >>> check = kx.license.check('/usr/location/kc.lic')\n    Supplied license information does not match.\n    Please consider reinstalling your license using pykx.license.install\n\n    Installed license representation:\n    b'iIXSiEWzCNTkkCWK5Gggy..'\n    User expected license representation:\n    b'IyEvdXNyL2Jpbi9lbngDf..'\n    >>> check\n    False\n    ```\n\n    Attempt to check a license in the case no license is currently installed\n\n    ```python\n    >>> import pykx as kx\n    >>> check = kx.license.check('setup.py', license_type='kc.lic')\n    Unable to find an installed license: kc.lic at location: /usr/local/anaconda3/envs/qenv/q.\n    Please consider installing your license again using pykx.license.install\n    >>> check\n    False\n    ```\n    \"\"\"\n    format = format.lower()\n    if format not in ('file', 'string'):\n        raise Exception('Unsupported option provided for format parameter')\n\n    if license_type not in ('kx.lic', 'kc.lic', 'k4.lic'):\n        raise Exception(f'License type {license_type} not supported.')\n\n    license_located = False\n    installed_lic = qlic/license_type\n    if os.path.exists(installed_lic):\n        license_located = True\n\n    if not license_located:\n        print(f'Unable to find an installed license: {license_type} at location: {str(qlic)}.\\n'\n              'Please consider installing your license again using pykx.license.install')\n        return False\n\n    with open(installed_lic, 'rb') as f:\n        license_content = base64.encodebytes(f.read()).decode('utf-8')\n        license_content = license_content.replace('\\n', '')\n        license_content = bytes(license_content, 'utf-8')\n\n    if format == 'file':\n        license_path = Path(os.path.expanduser(license))\n        if os.path.exists(license_path):\n            with open(str(license_path), 'rb') as f:\n                license = base64.encodebytes(f.read()).decode('utf-8')\n                license = license.replace('\\n', '')\n        else:\n            print(f'Unable to locate license {license_path} for comparison')\n            return False\n\n    if isinstance(license, str):\n        license = license.replace('\\n', '')\n        license = bytes(license, 'utf-8')\n\n    if not license_content == license:\n        print('Supplied license information does not match.\\n'\n              'Please consider reinstalling your license using pykx.license.install\\n\\n'\n              f'Installed license representation:\\n{license_content}\\n\\n'\n              f'User expected license representation:\\n{license}')\n        return False\n\n    return True",
          "triple_sequences": [
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "installed_lic",
              "object_description": "Local file or directory",
              "object_id": "local_file_or_directory",
              "intention_description": "Determine local file presence",
              "intention_id": "determine_local_file_presence"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "installed_lic, 'rb'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "f.read()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "base64.encodebytes()",
              "action_description": "Encodes bytes to base64-encoded bytes",
              "action_id": "encode_bytes_to_base64",
              "object": "f.read()",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Prepare data for base64 encoding",
              "intention_id": "prepare_data_base64_encoding"
            },
            {
              "action_api": "str.replace()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "'\\n', ''",
              "object_description": "String containing environment data",
              "object_id": "string_environment_data",
              "intention_description": "Prepare string for further processing",
              "intention_id": "prepare_string_processing"
            },
            {
              "action_api": "bytes()",
              "action_description": "Creates bytes object from encoded string",
              "action_id": "create_bytes_encoded",
              "object": "license_content, 'utf-8'",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Encode string to bytes",
              "intention_id": "encode_string_to_bytes"
            },
            {
              "action_api": "Path()",
              "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
              "action_id": "path_object_operations",
              "object": "os.path.expanduser(license)",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "license_path",
              "object_description": "Local file or directory",
              "object_id": "local_file_or_directory",
              "intention_description": "Determine local file presence",
              "intention_id": "determine_local_file_presence"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "str(license_path), 'rb'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "f.read()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "base64.encodebytes()",
              "action_description": "Encodes bytes to base64-encoded bytes",
              "action_id": "encode_bytes_to_base64",
              "object": "f.read()",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Prepare data for base64 encoding",
              "intention_id": "prepare_data_base64_encoding"
            },
            {
              "action_api": "str.replace()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "'\\n', ''",
              "object_description": "String containing environment data",
              "object_id": "string_environment_data",
              "intention_description": "Prepare string for further processing",
              "intention_id": "prepare_string_processing"
            },
            {
              "action_api": "str.replace()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "'\\n', ''",
              "object_description": "String containing environment data",
              "object_id": "string_environment_data",
              "intention_description": "Prepare string for further processing",
              "intention_id": "prepare_string_processing"
            },
            {
              "action_api": "bytes()",
              "action_description": "Creates bytes object from encoded string",
              "action_id": "create_bytes_encoded",
              "object": "license, 'utf-8'",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Encode string to bytes",
              "intention_id": "encode_string_to_bytes"
            },
            {
              "action_api": "isinstance()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "license, str",
              "object_description": "String containing environment data",
              "object_id": "string_environment_data",
              "intention_description": "Prepare string for further processing",
              "intention_id": "prepare_string_processing"
            },
            {
              "action_api": "str.replace()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "'\\n', ''",
              "object_description": "String containing environment data",
              "object_id": "string_environment_data",
              "intention_description": "Prepare string for further processing",
              "intention_id": "prepare_string_processing"
            },
            {
              "action_api": "bytes()",
              "action_description": "Creates bytes object from encoded string",
              "action_id": "create_bytes_encoded",
              "object": "license, 'utf-8'",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Encode string to bytes",
              "intention_id": "encode_string_to_bytes"
            }
          ]
        }
      ]
    }
  ]
}