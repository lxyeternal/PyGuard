{
  "metadata": {
    "package_name": "gekko-1",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/gekko-1.3.0.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "gekko.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gekko-1.3.0/gekko-1.3.0/gekko/gekko.py",
      "line_number": "1274",
      "type_description": "B815:write",
      "context_snippet": "def qobj(self,b,A=[],x=None,otype='min',sparse=False):\n    \"\"\"Create quadratic objective  = 0.5 x^T A x + c^T x\n    Usage: x = m.qobj(c,Q=[2d array],otype=['min','max'],sparse=[True,False])\n    Input: b = numpy 1D array or list in dense or sparse form\n           A = numpy 2D array or list in dense or sparse form\n           x = array of gekko variables (optional). If None on entry\n                 then the array is created and returned.\n           etype = ['=','<','>','>=','<='] for equality or inequality form\n           sparse = True if data is in sparse form, otherwise dense\n             sparse matrices are stored in COO form with [row,col,value] with\n             starting index 1 for optional matrix A and in [row,value] for\n             vector b\n           sparse matrices must have 3 columns\n    Output: GEKKO variables x\n    \"\"\"\n\n    #verify data input types\n    if not isinstance(b, (list,np.ndarray)):\n        raise TypeError(\"QOBJ input b must be a python list or numpy array\")\n\n    if not any(otype[0:min(3,len(otype))].lower()==t for t in ['min','max']):\n        raise TypeError(\"otype must start with either, 'min' or 'max'\")\n\n    b = np.array(b,dtype=float)\n    if sparse:\n        b = b.T\n        m = np.size(b,0)\n        n = np.size(b,1)\n        if (n!=2):\n            raise Exception('The b vector must be in COO form as [row,value] with 2 rows')\n    else:\n        b = b.flatten()\n\n    if (len(A)>=1):\n        if not isinstance(A, (list,np.ndarray)):\n            raise TypeError(\"QOBJ input A must be a python list or numpy array\")\n        A = np.array(A,dtype=float).T\n        # check sizes\n        if sparse:\n            m = np.size(A,0)\n            n = np.size(A,1)\n            if (n!=3):\n                raise Exception('The A matrix must be in COO form as [row,col,value] with 3 rows')\n\n        if sparse:\n            # sparse matrix size\n            r_max = np.max(A[:,0])\n            c_max = np.max(A[:,1])\n        else:\n            # dense matrix check\n            r_max = np.size(A,0)\n            c_max = np.size(A,1)\n            if (r_max!=c_max):\n                raise Exception('QOBJ: A matrix must have same number of rows and columns')\n\n    if x==None:\n        # create x variable array if none given\n        if sparse:\n            # maximum row index\n            nx = int(np.max(b[:,0]))\n        else:\n            nx = np.size(b)\n        xin = self.Array(self.Var,(nx))\n    else:\n        if not isinstance(x, (list,np.ndarray)):\n            raise TypeError(\"Optional x must be a python list or numpy array of GEKKO variables or parameters\")\n        nx = len(x)\n        if sparse:\n            if (nx!=int(np.max(b[:,0]))):\n                raise TypeError(\"Optional x must have same dimension as sparse b\")\n        else:\n            if nx!=np.size(b):\n                raise TypeError(\"Optional x must have same dimension as b\")\n        if len(A)>=1:\n            if nx!=c_max:\n                raise TypeError(\"Optional x must have same dimension as A\")\n        for i in range(nx):\n            if not isinstance(x[i],(GKVariable,GKParameter)):\n                raise TypeError(\"List x must be composed of GEKKO parameters or variables\")\n        xin = x\n\n    #build qobj object with unique object name\n    qobj_name = 'qobj' + str(len(self._objects) + 1)\n    self._objects.append(qobj_name + ' = qobj')\n\n    # write header file\n    filename = qobj_name+'.txt'\n    fid = open(os.path.join(self._path,filename),'w')\n    if sparse:\n        fid.write('sparse, ')\n    else:\n        fid.write('dense, ')\n    if (otype[0:min(3,len(otype))].lower()=='min'):\n        fid.write('minimize\\n')\n    else:\n        fid.write('maximize\\n')\n    fid.write(str(int(nx)) + ' ! n = number of variables \\n')\n    fid.close()\n    self._extra_files.append(filename)\n\n    # write A file\n    if (len(A)>=1):\n        filename = qobj_name+'.a.txt'\n        np.savetxt(os.path.join(self._path,filename), A, delimiter=\",\", fmt='%1.25s')\n        self._extra_files.append(qobj_name+'.a.txt')\n\n    # write b file\n    filename = qobj_name+'.b.txt'\n    np.savetxt(os.path.join(self._path,filename), b, delimiter=\",\", fmt='%1.25s')\n    self._extra_files.append(qobj_name+'.b.txt')\n\n    #Add connections between x and qobj object x (index 1)\n    for i in range(nx):\n        self._connections.append(xin[i].name + ' = ' + qobj_name+'.x['+str(i+1)+']')\n\n    if x==None:\n        return xin\n    else:\n        return",
      "hash_value": "2e4cf655c471490bba658bb0be3bcb02",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "def qobj(self,b,A=[],x=None,otype='min',sparse=False):\n    \"\"\"Create quadratic objective  = 0.5 x^T A x + c^T x\n    Usage: x = m.qobj(c,Q=[2d array],otype=['min','max'],sparse=[True,False])\n    Input: b = numpy 1D array or list in dense or sparse form\n           A = numpy 2D array or list in dense or sparse form\n           x = array of gekko variables (optional). If None on entry\n                 then the array is created and returned.\n           etype = ['=','<','>','>=','<='] for equality or inequality form\n           sparse = True if data is in sparse form, otherwise dense\n             sparse matrices are stored in COO form with [row,col,value] with\n             starting index 1 for optional matrix A and in [row,value] for\n             vector b\n           sparse matrices must have 3 columns\n    Output: GEKKO variables x\n    \"\"\"\n\n    #verify data input types\n    if not isinstance(b, (list,np.ndarray)):\n        raise TypeError(\"QOBJ input b must be a python list or numpy array\")\n\n    if not any(otype[0:min(3,len(otype))].lower()==t for t in ['min','max']):\n        raise TypeError(\"otype must start with either, 'min' or 'max'\")\n\n    b = np.array(b,dtype=float)\n    if sparse:\n        b = b.T\n        m = np.size(b,0)\n        n = np.size(b,1)\n        if (n!=2):\n            raise Exception('The b vector must be in COO form as [row,value] with 2 rows')\n    else:\n        b = b.flatten()\n\n    if (len(A)>=1):\n        if not isinstance(A, (list,np.ndarray)):\n            raise TypeError(\"QOBJ input A must be a python list or numpy array\")\n        A = np.array(A,dtype=float).T\n        # check sizes\n        if sparse:\n            m = np.size(A,0)\n            n = np.size(A,1)\n            if (n!=3):\n                raise Exception('The A matrix must be in COO form as [row,col,value] with 3 rows')\n\n        if sparse:\n            # sparse matrix size\n            r_max = np.max(A[:,0])\n            c_max = np.max(A[:,1])\n        else:\n            # dense matrix check\n            r_max = np.size(A,0)\n            c_max = np.size(A,1)\n            if (r_max!=c_max):\n                raise Exception('QOBJ: A matrix must have same number of rows and columns')\n\n    if x==None:\n        # create x variable array if none given\n        if sparse:\n            # maximum row index\n            nx = int(np.max(b[:,0]))\n        else:\n            nx = np.size(b)\n        xin = self.Array(self.Var,(nx))\n    else:\n        if not isinstance(x, (list,np.ndarray)):\n            raise TypeError(\"Optional x must be a python list or numpy array of GEKKO variables or parameters\")\n        nx = len(x)\n        if sparse:\n            if (nx!=int(np.max(b[:,0]))):\n                raise TypeError(\"Optional x must have same dimension as sparse b\")\n        else:\n            if nx!=np.size(b):\n                raise TypeError(\"Optional x must have same dimension as b\")\n        if len(A)>=1:\n            if nx!=c_max:\n                raise TypeError(\"Optional x must have same dimension as A\")\n        for i in range(nx):\n            if not isinstance(x[i],(GKVariable,GKParameter)):\n                raise TypeError(\"List x must be composed of GEKKO parameters or variables\")\n        xin = x\n\n    #build qobj object with unique object name\n    qobj_name = 'qobj' + str(len(self._objects) + 1)\n    self._objects.append(qobj_name + ' = qobj')\n\n    # write header file\n    filename = qobj_name+'.txt'\n    fid = open(os.path.join(self._path,filename),'w')\n    if sparse:\n        fid.write('sparse, ')\n    else:\n        fid.write('dense, ')\n    if (otype[0:min(3,len(otype))].lower()=='min'):\n        fid.write('minimize\\n')\n    else:\n        fid.write('maximize\\n')\n    fid.write(str(int(nx)) + ' ! n = number of variables \\n')\n    fid.close()\n    self._extra_files.append(filename)\n\n    # write A file\n    if (len(A)>=1):\n        filename = qobj_name+'.a.txt'\n        np.savetxt(os.path.join(self._path,filename), A, delimiter=\",\", fmt='%1.25s')\n        self._extra_files.append(qobj_name+'.a.txt')\n\n    # write b file\n    filename = qobj_name+'.b.txt'\n    np.savetxt(os.path.join(self._path,filename), b, delimiter=\",\", fmt='%1.25s')\n    self._extra_files.append(qobj_name+'.b.txt')\n\n    #Add connections between x and qobj object x (index 1)\n    for i in range(nx):\n        self._connections.append(xin[i].name + ' = ' + qobj_name+'.x['+str(i+1)+']')\n\n    if x==None:\n        return xin\n    else:\n        return",
          "triple_sequences": [
            {
              "action_api": "isinstance()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "b, (list, np.ndarray)",
              "object_description": "",
              "object_id": "",
              "intention_description": "Stop execution on invalid input",
              "intention_id": "stop_execution_invalid_input"
            },
            {
              "action_api": "isinstance()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "A, (list, np.ndarray)",
              "object_description": "",
              "object_id": "",
              "intention_description": "Stop execution on invalid input",
              "intention_id": "stop_execution_invalid_input"
            },
            {
              "action_api": "isinstance()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "x, (list, np.ndarray)",
              "object_description": "",
              "object_id": "",
              "intention_description": "Stop execution on invalid input",
              "intention_id": "stop_execution_invalid_input"
            },
            {
              "action_api": "isinstance()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "x[i], (GKVariable, GKParameter)",
              "object_description": "",
              "object_id": "",
              "intention_description": "Stop execution on invalid input",
              "intention_id": "stop_execution_invalid_input"
            },
            {
              "action_api": "np.array()",
              "action_description": "Creates bytes object from encoded string",
              "action_id": "create_bytes_encoded",
              "object": "b, dtype=float",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "np.array()",
              "action_description": "Creates bytes object from encoded string",
              "action_id": "create_bytes_encoded",
              "object": "A, dtype=float",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "np.size()",
              "action_description": "Retrieves file size",
              "action_id": "get_file_size",
              "object": "b, 0",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "np.size()",
              "action_description": "Retrieves file size",
              "action_id": "get_file_size",
              "object": "b, 1",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "np.size()",
              "action_description": "Retrieves file size",
              "action_id": "get_file_size",
              "object": "A, 0",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "np.size()",
              "action_description": "Retrieves file size",
              "action_id": "get_file_size",
              "object": "A, 1",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "np.max()",
              "action_description": "Generate random number",
              "action_id": "generate_random_number",
              "object": "A[:,0]",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "np.max()",
              "action_description": "Generate random number",
              "action_id": "generate_random_number",
              "object": "A[:,1]",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "np.max()",
              "action_description": "Generate random number",
              "action_id": "generate_random_number",
              "object": "b[:,0]",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "self.Array()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "self.Var, (nx)",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "os.path.join(self._path,filename), 'w'",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Open file for writing",
              "intention_id": "open_file_writing"
            },
            {
              "action_api": "fid.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "'sparse, ' or 'dense, '",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "fid.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "'minimize\\n' or 'maximize\\n'",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "fid.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "str(int(nx)) + ' ! n = number of variables \\n'",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "fid.close()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close file",
              "intention_id": "close_file"
            },
            {
              "action_api": "np.savetxt()",
              "action_description": "Saves image to file",
              "action_id": "save_image_file",
              "object": "os.path.join(self._path,filename), A, delimiter=\",\", fmt='%1.25s'",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "np.savetxt()",
              "action_description": "Saves image to file",
              "action_id": "save_image_file",
              "object": "os.path.join(self._path,filename), b, delimiter=\",\", fmt='%1.25s'",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            }
          ]
        }
      ]
    }
  ]
}