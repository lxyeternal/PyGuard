{
  "metadata": {
    "package_name": "execnet-2",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/execnet-2.1.1.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "gateway_base.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/execnet-2.1.1/execnet-2.1.1/src/execnet/gateway_base.py",
      "line_number": "1761",
      "type_description": "B815:write",
      "context_snippet": "class _Serializer:\n    _dispatch: dict[type, Callable[[_Serializer, object], None]] = {}\n\n    def __init__(self, write: Callable[[bytes], None] | None = None) -> None:\n        if write is None:\n            self._streamlist: list[bytes] = []\n            write = self._streamlist.append\n        self._write = write\n\n    def save(self, obj: object, versioned: bool = False) -> bytes | None:\n        # calling here is not re-entrant but multiple instances\n        # may write to the same stream because of the common platform\n        # atomic-write guarantee (concurrent writes each happen atomically)\n        if versioned:\n            self._write(DUMPFORMAT_VERSION)\n        self._save(obj)\n        self._write(opcode.STOP)\n        try:\n            streamlist = self._streamlist\n        except AttributeError:\n            return None\n        return b\"\".join(streamlist)\n\n    def _save(self, obj: object) -> None:\n        tp = type(obj)\n        try:\n            dispatch = self._dispatch[tp]\n        except KeyError:\n            methodname = \"save_\" + tp.__name__\n            meth: Callable[[_Serializer, object], None] | None = getattr(\n                self.__class__, methodname, None\n            )\n            if meth is None:\n                raise DumpError(f\"can't serialize {tp}\") from None\n            dispatch = self._dispatch[tp] = meth\n        dispatch(self, obj)\n\n    def save_NoneType(self, non: None) -> None:\n        self._write(opcode.NONE)\n\n    def save_bool(self, boolean: bool) -> None:\n        if boolean:\n            self._write(opcode.TRUE)\n        else:\n            self._write(opcode.FALSE)\n\n    def save_bytes(self, bytes_: bytes) -> None:\n        self._write(opcode.BYTES)\n        self._write_byte_sequence(bytes_)\n\n    def save_str(self, s: str) -> None:\n        self._write(opcode.PY3STRING)\n        self._write_unicode_string(s)\n\n    def _write_unicode_string(self, s: str) -> None:\n        try:\n            as_bytes = s.encode(\"utf-8\")\n        except UnicodeEncodeError as e:\n            raise DumpError(\"strings must be utf-8 encodable\") from e\n        self._write_byte_sequence(as_bytes)\n\n    def _write_byte_sequence(self, bytes_: bytes) -> None:\n        self._write_int4(len(bytes_), \"string is too long\")\n        self._write(bytes_)\n\n    def _save_integral(self, i: int, short_op: bytes, long_op: bytes) -> None:\n        if i <= FOUR_BYTE_INT_MAX:\n            self._write(short_op)\n            self._write_int4(i)\n        else:\n            self._write(long_op)\n            self._write_byte_sequence(str(i).rstrip(\"L\").encode(\"ascii\"))\n\n    def save_int(self, i: int) -> None:\n        self._save_integral(i, opcode.INT, opcode.LONGINT)\n\n    def save_long(self, l: int) -> None:\n        self._save_integral(l, opcode.LONG, opcode.LONGLONG)\n\n    def save_float(self, flt: float) -> None:\n        self._write(opcode.FLOAT)\n        self._write(struct.pack(FLOAT_FORMAT, flt))\n\n    def save_complex(self, cpx: complex) -> None:\n        self._write(opcode.COMPLEX)\n        self._write(struct.pack(COMPLEX_FORMAT, cpx.real, cpx.imag))\n\n    def _write_int4(\n        self, i: int, error: str = \"int must be less than %i\" % (FOUR_BYTE_INT_MAX,)\n    ) -> None:\n        if i > FOUR_BYTE_INT_MAX:\n            raise DumpError(error)\n        self._write(struct.pack(\"!i\", i))\n\n    def save_list(self, L: list[object]) -> None:\n        self._write(opcode.NEWLIST)\n        self._write_int4(len(L), \"list is too long\")\n        for i, item in enumerate(L):\n            self._write_setitem(i, item)\n\n    def _write_setitem(self, key: object, value: object) -> None:\n        self._save(key)\n        self._save(value)\n        self._write(opcode.SETITEM)\n\n    def save_dict(self, d: dict[object, object]) -> None:\n        self._write(opcode.NEWDICT)\n        for key, value in d.items():\n            self._write_setitem(key, value)\n\n    def save_tuple(self, tup: tuple[object, ...]) -> None:\n        for item in tup:\n            self._save(item)\n        self._write(opcode.BUILDTUPLE)\n        self._write_int4(len(tup), \"tuple is too long\")\n\n    def _write_set(self, s: set[object] | frozenset[object], op: bytes) -> None:\n        for item in s:\n            self._save(item)\n        self._write(op)\n        self._write_int4(len(s), \"set is too long\")\n\n    def save_set(self, s: set[object]) -> None:\n        self._write_set(s, opcode.SET)\n\n    def save_frozenset(self, s: frozenset[object]) -> None:\n        self._write_set(s, opcode.FROZENSET)\n\n    def save_Channel(self, channel: Channel) -> None:\n        self._write(opcode.CHANNEL)\n        self._write_int4(channel.id)",
      "hash_value": "90dc232efe2ca2dba20c5fb1411a3aff",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "class _Serializer:\n    _dispatch: dict[type, Callable[[_Serializer, object], None]] = {}\n\n    def __init__(self, write: Callable[[bytes], None] | None = None) -> None:\n        if write is None:\n            self._streamlist: list[bytes] = []\n            write = self._streamlist.append\n        self._write = write\n\n    def save(self, obj: object, versioned: bool = False) -> bytes | None:\n        # calling here is not re-entrant but multiple instances\n        # may write to the same stream because of the common platform\n        # atomic-write guarantee (concurrent writes each happen atomically)\n        if versioned:\n            self._write(DUMPFORMAT_VERSION)\n        self._save(obj)\n        self._write(opcode.STOP)\n        try:\n            streamlist = self._streamlist\n        except AttributeError:\n            return None\n        return b\"\".join(streamlist)\n\n    def _save(self, obj: object) -> None:\n        tp = type(obj)\n        try:\n            dispatch = self._dispatch[tp]\n        except KeyError:\n            methodname = \"save_\" + tp.__name__\n            meth: Callable[[_Serializer, object], None] | None = getattr(\n                self.__class__, methodname, None\n            )\n            if meth is None:\n                raise DumpError(f\"can't serialize {tp}\") from None\n            dispatch = self._dispatch[tp] = meth\n        dispatch(self, obj)\n\n    def save_NoneType(self, non: None) -> None:\n        self._write(opcode.NONE)\n\n    def save_bool(self, boolean: bool) -> None:\n        if boolean:\n            self._write(opcode.TRUE)\n        else:\n            self._write(opcode.FALSE)\n\n    def save_bytes(self, bytes_: bytes) -> None:\n        self._write(opcode.BYTES)\n        self._write_byte_sequence(bytes_)\n\n    def save_str(self, s: str) -> None:\n        self._write(opcode.PY3STRING)\n        self._write_unicode_string(s)\n\n    def _write_unicode_string(self, s: str) -> None:\n        try:\n            as_bytes = s.encode(\"utf-8\")\n        except UnicodeEncodeError as e:\n            raise DumpError(\"strings must be utf-8 encodable\") from e\n        self._write_byte_sequence(as_bytes)\n\n    def _write_byte_sequence(self, bytes_: bytes) -> None:\n        self._write_int4(len(bytes_), \"string is too long\")\n        self._write(bytes_)\n\n    def _save_integral(self, i: int, short_op: bytes, long_op: bytes) -> None:\n        if i <= FOUR_BYTE_INT_MAX:\n            self._write(short_op)\n            self._write_int4(i)\n        else:\n            self._write(long_op)\n            self._write_byte_sequence(str(i).rstrip(\"L\").encode(\"ascii\"))\n\n    def save_int(self, i: int) -> None:\n        self._save_integral(i, opcode.INT, opcode.LONGINT)\n\n    def save_long(self, l: int) -> None:\n        self._save_integral(l, opcode.LONG, opcode.LONGLONG)\n\n    def save_float(self, flt: float) -> None:\n        self._write(opcode.FLOAT)\n        self._write(struct.pack(FLOAT_FORMAT, flt))\n\n    def save_complex(self, cpx: complex) -> None:\n        self._write(opcode.COMPLEX)\n        self._write(struct.pack(COMPLEX_FORMAT, cpx.real, cpx.imag))\n\n    def _write_int4(\n        self, i: int, error: str = \"int must be less than %i\" % (FOUR_BYTE_INT_MAX,)\n    ) -> None:\n        if i > FOUR_BYTE_INT_MAX:\n            raise DumpError(error)\n        self._write(struct.pack(\"!i\", i))\n\n    def save_list(self, L: list[object]) -> None:\n        self._write(opcode.NEWLIST)\n        self._write_int4(len(L), \"list is too long\")\n        for i, item in enumerate(L):\n            self._write_setitem(i, item)\n\n    def _write_setitem(self, key: object, value: object) -> None:\n        self._save(key)\n        self._save(value)\n        self._write(opcode.SETITEM)\n\n    def save_dict(self, d: dict[object, object]) -> None:\n        self._write(opcode.NEWDICT)\n        for key, value in d.items():\n            self._write_setitem(key, value)\n\n    def save_tuple(self, tup: tuple[object, ...]) -> None:\n        for item in tup:\n            self._save(item)\n        self._write(opcode.BUILDTUPLE)\n        self._write_int4(len(tup), \"tuple is too long\")\n\n    def _write_set(self, s: set[object] | frozenset[object], op: bytes) -> None:\n        for item in s:\n            self._save(item)\n        self._write(op)\n        self._write_int4(len(s), \"set is too long\")\n\n    def save_set(self, s: set[object]) -> None:\n        self._write_set(s, opcode.SET)\n\n    def save_frozenset(self, s: frozenset[object]) -> None:\n        self._write_set(s, opcode.FROZENSET)\n\n    def save_Channel(self, channel: Channel) -> None:\n        self._write(opcode.CHANNEL)\n        self._write_int4(channel.id)",
          "triple_sequences": [
            {
              "action_api": "str.encode()",
              "action_description": "Encodes string to bytes using default encoding",
              "action_id": "encode_string_to_bytes",
              "object": "\"utf-8\"",
              "object_description": "Character encoding type",
              "object_id": "character_encoding_type",
              "intention_description": "Encode string to bytes",
              "intention_id": "encode_string_to_bytes"
            },
            {
              "action_api": "struct.pack()",
              "action_description": "Packs values into bytes using specified format",
              "action_id": "pack_values",
              "object": "FLOAT_FORMAT, flt",
              "object_description": "Compression format specification",
              "object_id": "compression_format",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "struct.pack()",
              "action_description": "Packs values into bytes using specified format",
              "action_id": "pack_values",
              "object": "COMPLEX_FORMAT, cpx.real, cpx.imag",
              "object_description": "Compression format specification",
              "object_id": "compression_format",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "struct.pack()",
              "action_description": "Packs values into bytes using specified format",
              "action_id": "pack_values",
              "object": "\"!i\", i",
              "object_description": "Compression format specification",
              "object_id": "compression_format",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "str.rstrip()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "\"L\"",
              "object_description": "Character from obfuscated string",
              "object_id": "character_from_obfuscated_string",
              "intention_description": "Prepare character for further processing",
              "intention_id": "prepare_character_processing"
            },
            {
              "action_api": "str.encode()",
              "action_description": "Encodes string to bytes using default encoding",
              "action_id": "encode_string_to_bytes",
              "object": "\"ascii\"",
              "object_description": "Character encoding type",
              "object_id": "character_encoding_type",
              "intention_description": "Encode string to bytes",
              "intention_id": "encode_string_to_bytes"
            },
            {
              "action_api": "list.append()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "self._streamlist.append",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Serialize data",
              "intention_id": "serialize_data"
            },
            {
              "action_api": "b\"\".join()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "streamlist",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Serialize data",
              "intention_id": "serialize_data"
            }
          ]
        }
      ]
    }
  ]
}