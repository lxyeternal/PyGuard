{
  "metadata": {
    "package_name": "kafka_python-2",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/kafka_python-2.1.5.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "client_async.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/kafka_python-2.1.5/kafka_python-2.1.5/kafka/client_async.py",
      "line_number": "607",
      "type_description": "B804:connect",
      "context_snippet": "def send(self, node_id, request, wakeup=True, request_timeout_ms=None):\n    \"\"\"Send a request to a specific node. Bytes are placed on an\n    internal per-connection send-queue. Actual network I/O will be\n    triggered in a subsequent call to .poll()\n\n    Arguments:\n        node_id (int): destination node\n        request (Struct): request object (not-encoded)\n\n    Keyword Arguments:\n        wakeup (bool, optional): optional flag to disable thread-wakeup.\n        request_timeout_ms (int, optional): Provide custom timeout in milliseconds.\n            If response is not processed before timeout, client will fail the\n            request and close the connection.\n            Default: None (uses value from client configuration)\n\n    Raises:\n        AssertionError: if node_id is not in current cluster metadata\n\n    Returns:\n        Future: resolves to Response struct or Error\n    \"\"\"\n    conn = self._conns.get(node_id)\n    if not conn or not self._can_send_request(node_id):\n        self.maybe_connect(node_id, wakeup=wakeup)\n        return Future().failure(Errors.NodeNotReadyError(node_id))\n\n    # conn.send will queue the request internally\n    # we will need to call send_pending_requests()\n    # to trigger network I/O\n    future = conn.send(request, blocking=False, request_timeout_ms=request_timeout_ms)\n    if not future.is_done:\n        self._sending.add(conn)\n\n    # Wakeup signal is useful in case another thread is\n    # blocked waiting for incoming network traffic while holding\n    # the client lock in poll().\n    if wakeup:\n        self.wakeup()\n\n    return future",
      "hash_value": "8a6df83606210ddc0a068a227d99dcef",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "def send(self, node_id, request, wakeup=True, request_timeout_ms=None):\n    \"\"\"Send a request to a specific node. Bytes are placed on an\n    internal per-connection send-queue. Actual network I/O will be\n    triggered in a subsequent call to .poll()\n\n    Arguments:\n        node_id (int): destination node\n        request (Struct): request object (not-encoded)\n\n    Keyword Arguments:\n        wakeup (bool, optional): optional flag to disable thread-wakeup.\n        request_timeout_ms (int, optional): Provide custom timeout in milliseconds.\n            If response is not processed before timeout, client will fail the\n            request and close the connection.\n            Default: None (uses value from client configuration)\n\n    Raises:\n        AssertionError: if node_id is not in current cluster metadata\n\n    Returns:\n        Future: resolves to Response struct or Error\n    \"\"\"\n    conn = self._conns.get(node_id)\n    if not conn or not self._can_send_request(node_id):\n        self.maybe_connect(node_id, wakeup=wakeup)\n        return Future().failure(Errors.NodeNotReadyError(node_id))\n\n    # conn.send will queue the request internally\n    # we will need to call send_pending_requests()\n    # to trigger network I/O\n    future = conn.send(request, blocking=False, request_timeout_ms=request_timeout_ms)\n    if not future.is_done:\n        self._sending.add(conn)\n\n    # Wakeup signal is useful in case another thread is\n    # blocked waiting for incoming network traffic while holding\n    # the client lock in poll().\n    if wakeup:\n        self.wakeup()\n\n    return future",
          "triple_sequences": [
            {
              "action_api": "self._conns.get()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "node_id",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Access configuration value",
              "intention_id": "access_configuration_value"
            },
            {
              "action_api": "self._can_send_request()",
              "action_description": "Checks if process is running with administrator privileges",
              "action_id": "check_admin_privileges",
              "object": "node_id",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Determine_required_module_presence",
              "intention_id": "determine_required_module_presence"
            },
            {
              "action_api": "self.maybe_connect()",
              "action_description": "Establishes TCP connection to specified address",
              "action_id": "establish_tcp_connection",
              "object": "node_id, wakeup=wakeup",
              "object_description": "Socket address",
              "object_id": "socket_address",
              "intention_description": "Establish connection",
              "intention_id": "establish_connection"
            },
            {
              "action_api": "Future().failure()",
              "action_description": "Raises HTTPError if response status code indicates error",
              "action_id": "raise_http_error",
              "object": "Errors.NodeNotReadyError(node_id)",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Stop execution on invalid input",
              "intention_id": "stop_execution_invalid_input"
            },
            {
              "action_api": "conn.send()",
              "action_description": "Sends data over socket connection",
              "action_id": "send_socket_data",
              "object": "request, blocking=False, request_timeout_ms=request_timeout_ms",
              "object_description": "Request object for external domain",
              "object_id": "request_external_domain",
              "intention_description": "Send data to server",
              "intention_id": "send_data_server"
            },
            {
              "action_api": "self._sending.add()",
              "action_description": "Adds field to multipart HTTP request",
              "action_id": "add_multipart_field",
              "object": "conn",
              "object_description": "Socket address",
              "object_id": "socket_address",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "future.is_done",
              "action_description": "Checks if process has terminated",
              "action_id": "check_process_terminated",
              "object": "future",
              "object_description": "",
              "object_id": "",
              "intention_description": "Finalize file for later use",
              "intention_id": "finalize_file_later_use"
            },
            {
              "action_api": "self.wakeup()",
              "action_description": "Waits for events",
              "action_id": "wait_for_events",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for events",
              "intention_id": "wait_for_events"
            }
          ]
        }
      ]
    }
  ]
}