{
  "metadata": {
    "package_name": "kazoo-2",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/kazoo-2.10.0.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "test_client.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/kazoo-2.10.0/kazoo-2.10.0/kazoo/tests/test_client.py",
      "line_number": "425",
      "type_description": "B807:close",
      "context_snippet": "def test_closed(self):\n    client = self.client\n    client.stop()\n\n    write_sock = client._connection._write_sock\n\n    # close the connection to free the socket\n    client.close()\n    assert client._connection._write_sock is None\n\n    # sneak in and patch client to simulate race between a thread\n    # calling stop(); close() and one running a command\n    oldstate = client._state\n    client._state = KeeperState.CONNECTED\n    client._connection._write_sock = write_sock\n\n    try:\n        # simulate call made after write socket is closed\n        with pytest.raises(ConnectionClosedError):\n            client.exists(\"/\")\n\n        # simulate call made after write socket is set to None\n        client._connection._write_sock = None\n\n        with pytest.raises(ConnectionClosedError):\n            client.exists(\"/\")\n\n    finally:\n        # reset for teardown\n        client._state = oldstate\n        client._connection._write_sock = None",
      "hash_value": "ac2ae12db0be1e6841139c48443b5f7f",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "def test_closed(self):\n    client = self.client\n    client.stop()\n\n    write_sock = client._connection._write_sock\n\n    # close the connection to free the socket\n    client.close()\n    assert client._connection._write_sock is None\n\n    # sneak in and patch client to simulate race between a thread\n    # calling stop(); close() and one running a command\n    oldstate = client._state\n    client._state = KeeperState.CONNECTED\n    client._connection._write_sock = write_sock\n\n    try:\n        # simulate call made after write socket is closed\n        with pytest.raises(ConnectionClosedError):\n            client.exists(\"/\")\n\n        # simulate call made after write socket is set to None\n        client._connection._write_sock = None\n\n        with pytest.raises(ConnectionClosedError):\n            client.exists(\"/\")\n\n    finally:\n        # reset for teardown\n        client._state = oldstate\n        client._connection._write_sock = None",
          "triple_sequences": [
            {
              "action_api": "client.stop()",
              "action_description": "Terminates the process",
              "action_id": "terminate_process",
              "object": "client",
              "object_description": "User process",
              "object_id": "user_process",
              "intention_description": "Terminate process",
              "intention_id": "terminate_process"
            },
            {
              "action_api": "client.close()",
              "action_description": "Closes the socket connection",
              "action_id": "close_socket",
              "object": "client._connection._write_sock",
              "object_description": "Socket address",
              "object_id": "socket_address",
              "intention_description": "Release connection resource",
              "intention_id": "release_connection_resource"
            },
            {
              "action_api": "client.exists(\"/\")",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "\"/\"",
              "object_description": "Root directory",
              "object_id": "root_directory",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            }
          ]
        }
      ]
    }
  ]
}