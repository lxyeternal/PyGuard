{
  "metadata": {
    "package_name": "tinybird_cli-5",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/tinybird_cli-5.20.1.dev0.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "datafile.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/tinybird_cli-5.20.1.dev0/tinybird_cli-5.20.1.dev0/tinybird/datafile.py",
      "line_number": "2915",
      "type_description": "B820:get",
      "context_snippet": "async def new_pipe(\n    p,\n    tb_client: TinyB,\n    force: bool = False,\n    check: bool = True,\n    populate: bool = False,\n    populate_subset=None,\n    populate_condition=None,\n    unlink_on_populate_error: bool = False,\n    wait_populate: bool = False,\n    skip_tokens: bool = False,\n    ignore_sql_errors: bool = False,\n    only_response_times: bool = False,\n    run_tests: bool = False,\n    as_standard: bool = False,\n    tests_to_run: int = 0,\n    tests_relative_change: float = 0.01,\n    tests_to_sample_by_params: int = 0,\n    tests_filter_by: Optional[List[str]] = None,\n    tests_failfast: bool = False,\n    tests_ignore_order: bool = False,\n    tests_validate_processed_bytes: bool = False,\n    override_datasource: bool = False,\n    tests_check_requests_from_branch: bool = False,\n    config: Any = None,\n    fork_downstream: Optional[bool] = False,\n    fork: Optional[bool] = False,\n):\n    # TODO use tb_client instead of calling the urls directly.\n    host = tb_client.host\n    token = tb_client.token\n\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n\n    cli_params = {}\n    cli_params[\"cli_version\"] = tb_client.version\n    cli_params[\"description\"] = p.get(\"description\", \"\")\n    cli_params[\"ignore_sql_errors\"] = \"true\" if ignore_sql_errors else \"false\"\n\n    r: requests.Response = await requests_get(f\"{host}/v0/pipes/{p['name']}?{urlencode(cli_params)}\", headers=headers)\n\n    current_pipe = r.json() if r.status_code == 200 else None\n    pipe_exists = current_pipe is not None\n\n    is_materialized = any([node.get(\"params\", {}).get(\"type\", None) == \"materialized\" for node in p[\"nodes\"]])\n    copy_node = next((node for node in p[\"nodes\"] if node.get(\"params\", {}).get(\"type\", None) == \"copy\"), None)\n    sink_node = next((node for node in p[\"nodes\"] if node.get(\"params\", {}).get(\"type\", None) == \"sink\"), None)\n    stream_node = next((node for node in p[\"nodes\"] if node.get(\"params\", {}).get(\"type\", None) == \"stream\"), None)\n\n    for node in p[\"nodes\"]:\n        if node[\"params\"][\"name\"] == p[\"name\"]:\n            raise click.ClickException(FeedbackManager.error_pipe_node_same_name(name=p[\"name\"]))\n\n    if pipe_exists:\n        if force or run_tests:\n            # TODO: this should create a different node and rename it to the final one on success\n            if check and not populate:\n                if not is_materialized and not copy_node and not sink_node and not stream_node:\n                    await check_pipe(\n                        p,\n                        host,\n                        token,\n                        populate,\n                        tb_client,\n                        only_response_times=only_response_times,\n                        limit=tests_to_run,\n                        relative_change=tests_relative_change,\n                        sample_by_params=tests_to_sample_by_params,\n                        matches=tests_filter_by,\n                        failfast=tests_failfast,\n                        validate_processed_bytes=tests_validate_processed_bytes,\n                        ignore_order=tests_ignore_order,\n                        token_for_requests_to_check=(\n                            await get_token_from_main_branch(tb_client)\n                            if not tests_check_requests_from_branch\n                            else None\n                        ),\n                        current_pipe=current_pipe,\n                    )\n                else:\n                    if is_materialized:\n                        await check_materialized(\n                            p,\n                            host,\n                            token,\n                            tb_client,\n                            override_datasource=override_datasource,\n                            current_pipe=current_pipe,\n                        )\n                    if copy_node:\n                        await check_copy_pipe(pipe=current_pipe, copy_node=copy_node, tb_client=tb_client)\n                    if sink_node:\n                        await check_sink_pipe(pipe=current_pipe, sink_node=sink_node, tb_client=tb_client)\n                    if stream_node:\n                        await check_stream_pipe(pipe=current_pipe, stream_node=stream_node, tb_client=tb_client)\n            if run_tests:\n                logging.info(f\"skipping force override of {p['name']}\")\n                return\n        else:\n            raise click.ClickException(FeedbackManager.error_pipe_already_exists(pipe=p[\"name\"]))\n    elif not pipe_exists and check:\n        if is_materialized:\n            await check_materialized(\n                p, host, token, tb_client, override_datasource=override_datasource, current_pipe=current_pipe\n            )\n        if copy_node:\n            await check_copy_pipe(pipe=current_pipe, copy_node=copy_node, tb_client=tb_client)\n\n    params = {}\n    params.update(cli_params)\n    if force:\n        params[\"force\"] = \"true\"\n    if populate:\n        params[\"populate\"] = \"true\"\n    if populate_condition:\n        params[\"populate_condition\"] = populate_condition\n    if populate_subset:\n        params[\"populate_subset\"] = populate_subset\n    params[\"unlink_on_populate_error\"] = \"true\" if unlink_on_populate_error else \"false\"\n    params[\"branch_mode\"] = \"fork\" if fork_downstream or fork else \"None\"\n\n    body = {\"name\": p[\"name\"], \"description\": p.get(\"description\", \"\")}\n\n    def parse_node(node):\n        if \"params\" in node:\n            node.update(node[\"params\"])\n            if node.get(\"type\", \"\") == \"materialized\" and override_datasource:\n                node[\"override_datasource\"] = \"true\"\n            del node[\"params\"]\n        return node\n\n    if p[\"nodes\"]:\n        body[\"nodes\"] = [parse_node(n) for n in p[\"nodes\"]]\n\n    if copy_node:\n        body[\"target_datasource\"] = copy_node.get(\"target_datasource\", None)\n        # We will update the schedule cron later\n        body[\"schedule_cron\"] = None\n\n    if sink_node:\n        body.update(sink_node.get(\"export_params\", {}))\n\n    if stream_node:\n        body.update(stream_node.get(\"export_params\", {}))\n\n    post_headers = {\"Content-Type\": \"application/json\"}\n\n    post_headers.update(headers)\n\n    try:\n        data = await tb_client._req(\n            f\"/v0/pipes?{urlencode(params)}\", method=\"POST\", headers=post_headers, data=json.dumps(body)\n        )\n    except Exception as e:\n        raise click.ClickException(FeedbackManager.error_pushing_pipe(pipe=p[\"name\"], error=str(e)))\n\n    datasource = data.get(\"datasource\", None)\n    created_datasource = data.get(\"created_datasource\", None)\n\n    if datasource and created_datasource:\n        if copy_node:\n            click.echo(FeedbackManager.info_copy_datasource_created(pipe=p[\"name\"], datasource=datasource[\"name\"]))\n        else:\n            click.echo(\n                FeedbackManager.info_materialized_datasource_created(pipe=p[\"name\"], datasource=datasource[\"name\"])\n            )\n    elif datasource and not created_datasource:\n        if copy_node:\n            click.echo(FeedbackManager.info_copy_datasource_used(pipe=p[\"name\"], datasource=datasource[\"name\"]))\n        else:\n            click.echo(FeedbackManager.info_materialized_datasource_used(pipe=p[\"name\"], datasource=datasource[\"name\"]))\n\n    if datasource and populate and not copy_node:\n        job_url = data.get(\"job\", {}).get(\"job_url\", None)\n        job_id = data.get(\"job\", {}).get(\"job_id\", None)\n        if populate_subset:\n            click.echo(FeedbackManager.info_populate_subset_job_url(url=job_url, subset=populate_subset))\n        elif populate_condition:\n            click.echo(\n                FeedbackManager.info_populate_condition_job_url(url=job_url, populate_condition=populate_condition)\n            )\n        else:\n            click.echo(FeedbackManager.info_populate_job_url(url=job_url))\n\n        if wait_populate:\n            result = await wait_job(tb_client, job_id, job_url, \"Populating\")\n            click.echo(FeedbackManager.info_populate_job_result(result=result))\n    else:\n        if data.get(\"type\") == \"default\" and not skip_tokens and not as_standard and not copy_node and not sink_node:\n            # FIXME: set option to add last node as endpoint in the API\n            endpoint_node = next(\n                (node for node in data.get(\"nodes\", []) if node.get(\"type\") == \"endpoint\"), data.get(\"nodes\", [])[-1]\n            )\n            try:\n                data = await tb_client._req(\n                    f\"/v0/pipes/{p['name']}/nodes/{endpoint_node.get('id')}/endpoint?{urlencode(cli_params)}\",\n                    method=\"POST\",\n                    headers=headers,\n                )\n            except Exception as e:\n                raise Exception(\n                    FeedbackManager.error_creating_endpoint(\n                        node=endpoint_node.get(\"name\"), pipe=p[\"name\"], error=str(e)\n                    )\n                )\n\n            click.echo(FeedbackManager.success_test_endpoint_no_token(host=host, pipe=p[\"name\"]))\n\n    if copy_node:\n        pipe_id = data[\"id\"]\n        node = next((node for node in data[\"nodes\"] if node[\"node_type\"] == \"copy\"), None)\n        if node:\n            copy_params = {\"pipe_name_or_id\": pipe_id, \"node_id\": node[\"id\"]}\n            try:\n                target_datasource = copy_node.get(CopyParameters.TARGET_DATASOURCE, None)\n                schedule_cron = copy_node.get(CopyParameters.COPY_SCHEDULE, None)\n                mode = copy_node.get(\"mode\", CopyModes.APPEND)\n                schedule_cron = None if schedule_cron == ON_DEMAND else schedule_cron\n                current_target_datasource_id = data[\"copy_target_datasource\"]\n                target_datasource_response = await tb_client.get_datasource(target_datasource)\n                target_datasource_to_send = (\n                    target_datasource\n                    if target_datasource_response.get(\"id\", target_datasource) != current_target_datasource_id\n                    else None\n                )\n                copy_params[CopyParameters.TARGET_DATASOURCE] = target_datasource_to_send\n                current_schedule = data.get(\"schedule\", {})\n                current_schedule_cron = current_schedule.get(\"cron\", None) if current_schedule else None\n                schedule_cron_should_be_removed = current_schedule_cron and not schedule_cron\n                copy_params[\"schedule_cron\"] = \"None\" if schedule_cron_should_be_removed else schedule_cron\n                copy_params[\"mode\"] = mode\n                await tb_client.pipe_update_copy(**copy_params)\n            except Exception as e:\n                raise Exception(\n                    FeedbackManager.error_setting_copy_node(node=copy_node.get(\"name\"), pipe=p[\"name\"], error=str(e))\n                )\n\n    if p[\"tokens\"] and not skip_tokens and not as_standard and data.get(\"type\") in [\"endpoint\", \"copy\"]:\n        # search for token with specified name and adds it if not found or adds permissions to it\n        t = None\n        for tk in p[\"tokens\"]:\n            token_name = tk[\"token_name\"]\n            t = await tb_client.get_token_by_name(token_name)\n            if t:\n                click.echo(FeedbackManager.info_create_found_token(token=token_name))\n                scopes = [f\"PIPES:{tk['permissions']}:{p['name']}\"]\n                for x in t[\"scopes\"]:\n                    sc = x[\"type\"] if \"resource\" not in x else f\"{x['type']}:{x['resource']}\"\n                    scopes.append(sc)\n                try:\n                    r = await tb_client.alter_tokens(token_name, scopes)\n                    token = r[\"token\"]  # type: ignore\n                except Exception as e:\n                    raise click.ClickException(FeedbackManager.error_creating_pipe(error=e))\n            else:\n                token_name = tk[\"token_name\"]\n                click.echo(FeedbackManager.info_create_not_found_token(token=token_name))\n                try:\n                    r = await tb_client.create_token(\n                        token_name, [f\"PIPES:{tk['permissions']}:{p['name']}\"], \"P\", p[\"name\"]\n                    )\n                    token = r[\"token\"]  # type: ignore\n                except Exception as e:\n                    raise click.ClickException(FeedbackManager.error_creating_pipe(error=e))\n\n        if data.get(\"type\") == \"endpoint\":\n            click.echo(FeedbackManager.success_test_endpoint_no_token(host=host, pipe=p[\"name\"]))\n",
      "hash_value": "9c5b0ddd14b7363dbb3103e1a2ba4bc3",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "async def new_pipe(\n    p,\n    tb_client: TinyB,\n    force: bool = False,\n    check: bool = True,\n    populate: bool = False,\n    populate_subset=None,\n    populate_condition=None,\n    unlink_on_populate_error: bool = False,\n    wait_populate: bool = False,\n    skip_tokens: bool = False,\n    ignore_sql_errors: bool = False,\n    only_response_times: bool = False,\n    run_tests: bool = False,\n    as_standard: bool = False,\n    tests_to_run: int = 0,\n    tests_relative_change: float = 0.01,\n    tests_to_sample_by_params: int = 0,\n    tests_filter_by: Optional[List[str]] = None,\n    tests_failfast: bool = False,\n    tests_ignore_order: bool = False,\n    tests_validate_processed_bytes: bool = False,\n    override_datasource: bool = False,\n    tests_check_requests_from_branch: bool = False,\n    config: Any = None,\n    fork_downstream: Optional[bool] = False,\n    fork: Optional[bool] = False,\n):\n    # TODO use tb_client instead of calling the urls directly.\n    host = tb_client.host\n    token = tb_client.token\n\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n\n    cli_params = {}\n    cli_params[\"cli_version\"] = tb_client.version\n    cli_params[\"description\"] = p.get(\"description\", \"\")\n    cli_params[\"ignore_sql_errors\"] = \"true\" if ignore_sql_errors else \"false\"\n\n    r: requests.Response = await requests_get(f\"{host}/v0/pipes/{p['name']}?{urlencode(cli_params)}\", headers=headers)\n\n    current_pipe = r.json() if r.status_code == 200 else None\n    pipe_exists = current_pipe is not None\n\n    is_materialized = any([node.get(\"params\", {}).get(\"type\", None) == \"materialized\" for node in p[\"nodes\"]])\n    copy_node = next((node for node in p[\"nodes\"] if node.get(\"params\", {}).get(\"type\", None) == \"copy\"), None)\n    sink_node = next((node for node in p[\"nodes\"] if node.get(\"params\", {}).get(\"type\", None) == \"sink\"), None)\n    stream_node = next((node for node in p[\"nodes\"] if node.get(\"params\", {}).get(\"type\", None) == \"stream\"), None)\n\n    for node in p[\"nodes\"]:\n        if node[\"params\"][\"name\"] == p[\"name\"]:\n            raise click.ClickException(FeedbackManager.error_pipe_node_same_name(name=p[\"name\"]))\n\n    if pipe_exists:\n        if force or run_tests:\n            # TODO: this should create a different node and rename it to the final one on success\n            if check and not populate:\n                if not is_materialized and not copy_node and not sink_node and not stream_node:\n                    await check_pipe(\n                        p,\n                        host,\n                        token,\n                        populate,\n                        tb_client,\n                        only_response_times=only_response_times,\n                        limit=tests_to_run,\n                        relative_change=tests_relative_change,\n                        sample_by_params=tests_to_sample_by_params,\n                        matches=tests_filter_by,\n                        failfast=tests_failfast,\n                        validate_processed_bytes=tests_validate_processed_bytes,\n                        ignore_order=tests_ignore_order,\n                        token_for_requests_to_check=(\n                            await get_token_from_main_branch(tb_client)\n                            if not tests_check_requests_from_branch\n                            else None\n                        ),\n                        current_pipe=current_pipe,\n                    )\n                else:\n                    if is_materialized:\n                        await check_materialized(\n                            p,\n                            host,\n                            token,\n                            tb_client,\n                            override_datasource=override_datasource,\n                            current_pipe=current_pipe,\n                        )\n                    if copy_node:\n                        await check_copy_pipe(pipe=current_pipe, copy_node=copy_node, tb_client=tb_client)\n                    if sink_node:\n                        await check_sink_pipe(pipe=current_pipe, sink_node=sink_node, tb_client=tb_client)\n                    if stream_node:\n                        await check_stream_pipe(pipe=current_pipe, stream_node=stream_node, tb_client=tb_client)\n            if run_tests:\n                logging.info(f\"skipping force override of {p['name']}\")\n                return\n        else:\n            raise click.ClickException(FeedbackManager.error_pipe_already_exists(pipe=p[\"name\"]))\n    elif not pipe_exists and check:\n        if is_materialized:\n            await check_materialized(\n                p, host, token, tb_client, override_datasource=override_datasource, current_pipe=current_pipe\n            )\n        if copy_node:\n            await check_copy_pipe(pipe=current_pipe, copy_node=copy_node, tb_client=tb_client)\n\n    params = {}\n    params.update(cli_params)\n    if force:\n        params[\"force\"] = \"true\"\n    if populate:\n        params[\"populate\"] = \"true\"\n    if populate_condition:\n        params[\"populate_condition\"] = populate_condition\n    if populate_subset:\n        params[\"populate_subset\"] = populate_subset\n    params[\"unlink_on_populate_error\"] = \"true\" if unlink_on_populate_error else \"false\"\n    params[\"branch_mode\"] = \"fork\" if fork_downstream or fork else \"None\"\n\n    body = {\"name\": p[\"name\"], \"description\": p.get(\"description\", \"\")}\n\n    def parse_node(node):\n        if \"params\" in node:\n            node.update(node[\"params\"])\n            if node.get(\"type\", \"\") == \"materialized\" and override_datasource:\n                node[\"override_datasource\"] = \"true\"\n            del node[\"params\"]\n        return node\n\n    if p[\"nodes\"]:\n        body[\"nodes\"] = [parse_node(n) for n in p[\"nodes\"]]\n\n    if copy_node:\n        body[\"target_datasource\"] = copy_node.get(\"target_datasource\", None)\n        # We will update the schedule cron later\n        body[\"schedule_cron\"] = None\n\n    if sink_node:\n        body.update(sink_node.get(\"export_params\", {}))\n\n    if stream_node:\n        body.update(stream_node.get(\"export_params\", {}))\n\n    post_headers = {\"Content-Type\": \"application/json\"}\n\n    post_headers.update(headers)\n\n    try:\n        data = await tb_client._req(\n            f\"/v0/pipes?{urlencode(params)}\", method=\"POST\", headers=post_headers, data=json.dumps(body)\n        )\n    except Exception as e:\n        raise click.ClickException(FeedbackManager.error_pushing_pipe(pipe=p[\"name\"], error=str(e)))\n\n    datasource = data.get(\"datasource\", None)\n    created_datasource = data.get(\"created_datasource\", None)\n\n    if datasource and created_datasource:\n        if copy_node:\n            click.echo(FeedbackManager.info_copy_datasource_created(pipe=p[\"name\"], datasource=datasource[\"name\"]))\n        else:\n            click.echo(\n                FeedbackManager.info_materialized_datasource_created(pipe=p[\"name\"], datasource=datasource[\"name\"])\n            )\n    elif datasource and not created_datasource:\n        if copy_node:\n            click.echo(FeedbackManager.info_copy_datasource_used(pipe=p[\"name\"], datasource=datasource[\"name\"]))\n        else:\n            click.echo(FeedbackManager.info_materialized_datasource_used(pipe=p[\"name\"], datasource=datasource[\"name\"]))\n\n    if datasource and populate and not copy_node:\n        job_url = data.get(\"job\", {}).get(\"job_url\", None)\n        job_id = data.get(\"job\", {}).get(\"job_id\", None)\n        if populate_subset:\n            click.echo(FeedbackManager.info_populate_subset_job_url(url=job_url, subset=populate_subset))\n        elif populate_condition:\n            click.echo(\n                FeedbackManager.info_populate_condition_job_url(url=job_url, populate_condition=populate_condition)\n            )\n        else:\n            click.echo(FeedbackManager.info_populate_job_url(url=job_url))\n\n        if wait_populate:\n            result = await wait_job(tb_client, job_id, job_url, \"Populating\")\n            click.echo(FeedbackManager.info_populate_job_result(result=result))\n    else:\n        if data.get(\"type\") == \"default\" and not skip_tokens and not as_standard and not copy_node and not sink_node:\n            # FIXME: set option to add last node as endpoint in the API\n            endpoint_node = next(\n                (node for node in data.get(\"nodes\", []) if node.get(\"type\") == \"endpoint\"), data.get(\"nodes\", [])[-1]\n            )\n            try:\n                data = await tb_client._req(\n                    f\"/v0/pipes/{p['name']}/nodes/{endpoint_node.get('id')}/endpoint?{urlencode(cli_params)}\",\n                    method=\"POST\",\n                    headers=headers,\n                )\n            except Exception as e:\n                raise Exception(\n                    FeedbackManager.error_creating_endpoint(\n                        node=endpoint_node.get(\"name\"), pipe=p[\"name\"], error=str(e)\n                    )\n                )\n\n            click.echo(FeedbackManager.success_test_endpoint_no_token(host=host, pipe=p[\"name\"]))\n\n    if copy_node:\n        pipe_id = data[\"id\"]\n        node = next((node for node in data[\"nodes\"] if node[\"node_type\"] == \"copy\"), None)\n        if node:\n            copy_params = {\"pipe_name_or_id\": pipe_id, \"node_id\": node[\"id\"]}\n            try:\n                target_datasource = copy_node.get(CopyParameters.TARGET_DATASOURCE, None)\n                schedule_cron = copy_node.get(CopyParameters.COPY_SCHEDULE, None)\n                mode = copy_node.get(\"mode\", CopyModes.APPEND)\n                schedule_cron = None if schedule_cron == ON_DEMAND else schedule_cron\n                current_target_datasource_id = data[\"copy_target_datasource\"]\n                target_datasource_response = await tb_client.get_datasource(target_datasource)\n                target_datasource_to_send = (\n                    target_datasource\n                    if target_datasource_response.get(\"id\", target_datasource) != current_target_datasource_id\n                    else None\n                )\n                copy_params[CopyParameters.TARGET_DATASOURCE] = target_datasource_to_send\n                current_schedule = data.get(\"schedule\", {})\n                current_schedule_cron = current_schedule.get(\"cron\", None) if current_schedule else None\n                schedule_cron_should_be_removed = current_schedule_cron and not schedule_cron\n                copy_params[\"schedule_cron\"] = \"None\" if schedule_cron_should_be_removed else schedule_cron\n                copy_params[\"mode\"] = mode\n                await tb_client.pipe_update_copy(**copy_params)\n            except Exception as e:\n                raise Exception(\n                    FeedbackManager.error_setting_copy_node(node=copy_node.get(\"name\"), pipe=p[\"name\"], error=str(e))\n                )\n\n    if p[\"tokens\"] and not skip_tokens and not as_standard and data.get(\"type\") in [\"endpoint\", \"copy\"]:\n        # search for token with specified name and adds it if not found or adds permissions to it\n        t = None\n        for tk in p[\"tokens\"]:\n            token_name = tk[\"token_name\"]\n            t = await tb_client.get_token_by_name(token_name)\n            if t:\n                click.echo(FeedbackManager.info_create_found_token(token=token_name))\n                scopes = [f\"PIPES:{tk['permissions']}:{p['name']}\"]\n                for x in t[\"scopes\"]:\n                    sc = x[\"type\"] if \"resource\" not in x else f\"{x['type']}:{x['resource']}\"\n                    scopes.append(sc)\n                try:\n                    r = await tb_client.alter_tokens(token_name, scopes)\n                    token = r[\"token\"]  # type: ignore\n                except Exception as e:\n                    raise click.ClickException(FeedbackManager.error_creating_pipe(error=e))\n            else:\n                token_name = tk[\"token_name\"]\n                click.echo(FeedbackManager.info_create_not_found_token(token=token_name))\n                try:\n                    r = await tb_client.create_token(\n                        token_name, [f\"PIPES:{tk['permissions']}:{p['name']}\"], \"P\", p[\"name\"]\n                    )\n                    token = r[\"token\"]  # type: ignore\n                except Exception as e:\n                    raise click.ClickException(FeedbackManager.error_creating_pipe(error=e))\n\n        if data.get(\"type\") == \"endpoint\":\n            click.echo(FeedbackManager.success_test_endpoint_no_token(host=host, pipe=p[\"name\"]))\n",
          "triple_sequences": [
            {
              "action_api": "requests_get()",
              "action_description": "Sends HTTP GET request to URL",
              "action_id": "open_url_get",
              "object": "f\"{host}/v0/pipes/{p['name']}?{urlencode(cli_params)}\", headers=headers",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "requests.Response.json()",
              "action_description": "Deserializes JSON response body to Python object",
              "action_id": "deserialize_json_response",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "any()",
              "action_description": "Iterates over all running processes",
              "action_id": "iterate_processes",
              "object": "[node.get(\"params\", {}).get(\"type\", None) == \"materialized\" for node in p[\"nodes\"]]",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine presence of directory",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "next()",
              "action_description": "Iterates over all running processes",
              "action_id": "iterate_processes",
              "object": "(node for node in p[\"nodes\"] if node.get(\"params\", {}).get(\"type\", None) == \"copy\")",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine presence of directory",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "next()",
              "action_description": "Iterates over all running processes",
              "action_id": "iterate_processes",
              "object": "(node for node in p[\"nodes\"] if node.get(\"params\", {}).get(\"type\", None) == \"sink\")",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine presence of directory",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "next()",
              "action_description": "Iterates over all running processes",
              "action_id": "iterate_processes",
              "object": "(node for node in p[\"nodes\"] if node.get(\"params\", {}).get(\"type\", None) == \"stream\")",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine presence of directory",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "raise click.ClickException()",
              "action_description": "Raises HTTPError if response status code indicates error",
              "action_id": "raise_http_error",
              "object": "FeedbackManager.error_pipe_node_same_name(name=p[\"name\"])",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Stop execution on invalid input",
              "intention_id": "stop_execution_invalid_input"
            },
            {
              "action_api": "await check_pipe()",
              "action_description": "Runs asynchronous function until completion",
              "action_id": "run_async_function",
              "object": "p, host, token, populate, tb_client, only_response_times=only_response_times, limit=tests_to_run, relative_change=tests_relative_change, sample_by_params=tests_to_sample_by_params, matches=tests_filter_by, failfast=tests_failfast, validate_processed_bytes=tests_validate_processed_bytes, ignore_order=tests_ignore_order, token_for_requests_to_check=(await get_token_from_main_branch(tb_client) if not tests_check_requests_from_branch else None), current_pipe=current_pipe",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Evaluate constructed code",
              "intention_id": "evaluate_constructed_code"
            },
            {
              "action_api": "await check_materialized()",
              "action_description": "Runs asynchronous function until completion",
              "action_id": "run_async_function",
              "object": "p, host, token, tb_client, override_datasource=override_datasource, current_pipe=current_pipe",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Evaluate constructed code",
              "intention_id": "evaluate_constructed_code"
            },
            {
              "action_api": "await check_copy_pipe()",
              "action_description": "Runs asynchronous function until completion",
              "action_id": "run_async_function",
              "object": "pipe=current_pipe, copy_node=copy_node, tb_client=tb_client",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Evaluate constructed code",
              "intention_id": "evaluate_constructed_code"
            },
            {
              "action_api": "await check_sink_pipe()",
              "action_description": "Runs asynchronous function until completion",
              "action_id": "run_async_function",
              "object": "pipe=current_pipe, sink_node=sink_node, tb_client=tb_client",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Evaluate constructed code",
              "intention_id": "evaluate_constructed_code"
            },
            {
              "action_api": "await check_stream_pipe()",
              "action_description": "Runs asynchronous function until completion",
              "action_id": "run_async_function",
              "object": "pipe=current_pipe, stream_node=stream_node, tb_client=tb_client",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Evaluate constructed code",
              "intention_id": "evaluate_constructed_code"
            },
            {
              "action_api": "logging.info()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "f\"skipping force override of {p['name']}\"",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Acknowledge keylogger start/stop",
              "intention_id": "acknowledge_keylogger_status"
            },
            {
              "action_api": "raise click.ClickException()",
              "action_description": "Raises HTTPError if response status code indicates error",
              "action_id": "raise_http_error",
              "object": "FeedbackManager.error_pipe_already_exists(pipe=p[\"name\"])",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Stop execution on invalid input",
              "intention_id": "stop_execution_invalid_input"
            },
            {
              "action_api": "params.update()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "cli_params",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "json.dumps()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "body",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "await tb_client._req()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "f\"/v0/pipes?{urlencode(params)}\", method=\"POST\", headers=post_headers, data=json.dumps(body)",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "raise click.ClickException()",
              "action_description": "Raises HTTPError if response status code indicates error",
              "action_id": "raise_http_error",
              "object": "FeedbackManager.error_pushing_pipe(pipe=p[\"name\"], error=str(e))",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Stop execution on invalid input",
              "intention_id": "stop_execution_invalid_input"
            },
            {
              "action_api": "click.echo()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "FeedbackManager.info_copy_datasource_created(pipe=p[\"name\"], datasource=datasource[\"name\"])",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Acknowledge keylogger start/stop",
              "intention_id": "acknowledge_keylogger_status"
            },
            {
              "action_api": "click.echo()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "FeedbackManager.info_materialized_datasource_created(pipe=p[\"name\"], datasource=datasource[\"name\"])",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Acknowledge keylogger start/stop",
              "intention_id": "acknowledge_keylogger_status"
            },
            {
              "action_api": "click.echo()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "FeedbackManager.info_copy_datasource_used(pipe=p[\"name\"], datasource=datasource[\"name\"])",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Acknowledge keylogger start/stop",
              "intention_id": "acknowledge_keylogger_status"
            },
            {
              "action_api": "click.echo()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "FeedbackManager.info_materialized_datasource_used(pipe=p[\"name\"], datasource=datasource[\"name\"])",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Acknowledge keylogger start/stop",
              "intention_id": "acknowledge_keylogger_status"
            },
            {
              "action_api": "click.echo()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "FeedbackManager.info_populate_subset_job_url(url=job_url, subset=populate_subset)",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Acknowledge keylogger start/stop",
              "intention_id": "acknowledge_keylogger_status"
            },
            {
              "action_api": "click.echo()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "FeedbackManager.info_populate_condition_job_url(url=job_url, populate_condition=populate_condition)",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Acknowledge keylogger start/stop",
              "intention_id": "acknowledge_keylogger_status"
            },
            {
              "action_api": "click.echo()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "FeedbackManager.info_populate_job_url(url=job_url)",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Acknowledge keylogger start/stop",
              "intention_id": "acknowledge_keylogger_status"
            },
            {
              "action_api": "await wait_job()",
              "action_description": "Runs asynchronous function until completion",
              "action_id": "run_async_function",
              "object": "tb_client, job_id, job_url, \"Populating\"",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Wait for events",
              "intention_id": "wait_for_events"
            },
            {
              "action_api": "click.echo()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "FeedbackManager.info_populate_job_result(result=result)",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Acknowledge keylogger start/stop",
              "intention_id": "acknowledge_keylogger_status"
            },
            {
              "action_api": "next()",
              "action_description": "Iterates over all running processes",
              "action_id": "iterate_processes",
              "object": "(node for node in data.get(\"nodes\", []) if node.get(\"type\") == \"endpoint\"), data.get(\"nodes\", [])[-1]",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine presence of directory",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "await tb_client._req()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "f\"/v0/pipes/{p['name']}/nodes/{endpoint_node.get('id')}/endpoint?{urlencode(cli_params)}\", method=\"POST\", headers=headers",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "raise Exception()",
              "action_description": "Raises HTTPError if response status code indicates error",
              "action_id": "raise_http_error",
              "object": "FeedbackManager.error_creating_endpoint(node=endpoint_node.get(\"name\"), pipe=p[\"name\"], error=str(e))",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Stop execution on invalid input",
              "intention_id": "stop_execution_invalid_input"
            },
            {
              "action_api": "click.echo()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "FeedbackManager.success_test_endpoint_no_token(host=host, pipe=p[\"name\"])",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Acknowledge keylogger start/stop",
              "intention_id": "acknowledge_keylogger_status"
            },
            {
              "action_api": "await tb_client.get_datasource()",
              "action_description": "Runs asynchronous function until completion",
              "action_id": "run_async_function",
              "object": "target_datasource",
              "object_description": "",
              "object_id": "",
              "intention_description": "Evaluate constructed code",
              "intention_id": "evaluate_constructed_code"
            },
            {
              "action_api": "await tb_client.pipe_update_copy()",
              "action_description": "Runs asynchronous function until completion",
              "action_id": "run_async_function",
              "object": "**copy_params",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Evaluate constructed code",
              "intention_id": "evaluate_constructed_code"
            },
            {
              "action_api": "raise Exception()",
              "action_description": "Raises HTTPError if response status code indicates error",
              "action_id": "raise_http_error",
              "object": "FeedbackManager.error_setting_copy_node(node=copy_node.get(\"name\"), pipe=p[\"name\"], error=str(e))",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Stop execution on invalid input",
              "intention_id": "stop_execution_invalid_input"
            },
            {
              "action_api": "await tb_client.get_token_by_name()",
              "action_description": "Runs asynchronous function until completion",
              "action_id": "run_async_function",
              "object": "token_name",
              "object_description": "API key or token",
              "object_id": "api_key",
              "intention_description": "Determine presence of valid authentication",
              "intention_id": "determine_valid_authentication_presence"
            },
            {
              "action_api": "click.echo()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "FeedbackManager.info_create_found_token(token=token_name)",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Acknowledge keylogger start/stop",
              "intention_id": "acknowledge_keylogger_status"
            },
            {
              "action_api": "await tb_client.alter_tokens()",
              "action_description": "Runs asynchronous function until completion",
              "action_id": "run_async_function",
              "object": "token_name, scopes",
              "object_description": "API key or token",
              "object_id": "api_key",
              "intention_description": "Evaluate constructed code",
              "intention_id": "evaluate_constructed_code"
            },
            {
              "action_api": "raise click.ClickException()",
              "action_description": "Raises HTTPError if response status code indicates error",
              "action_id": "raise_http_error",
              "object": "FeedbackManager.error_creating_pipe(error=e)",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Stop execution on invalid input",
              "intention_id": "stop_execution_invalid_input"
            },
            {
              "action_api": "click.echo()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "FeedbackManager.info_create_not_found_token(token=token_name)",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Acknowledge keylogger start/stop",
              "intention_id": "acknowledge_keylogger_status"
            },
            {
              "action_api": "await tb_client.create_token()",
              "action_description": "Runs asynchronous function until completion",
              "action_id": "run_async_function",
              "object": "token_name, [f\"PIPES:{tk['permissions']}:{p['name']}\"], \"P\", p[\"name\"]",
              "object_description": "API key or token",
              "object_id": "api_key",
              "intention_description": "Evaluate constructed code",
              "intention_id": "evaluate_constructed_code"
            },
            {
              "action_api": "raise click.ClickException()",
              "action_description": "Raises HTTPError if response status code indicates error",
              "action_id": "raise_http_error",
              "object": "FeedbackManager.error_creating_pipe(error=e)",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Stop execution on invalid input",
              "intention_id": "stop_execution_invalid_input"
            },
            {
              "action_api": "click.echo()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "FeedbackManager.success_test_endpoint_no_token(host=host, pipe=p[\"name\"])",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Acknowledge keylogger start/stop",
              "intention_id": "acknowledge_keylogger_status"
            }
          ]
        }
      ]
    }
  ]
}