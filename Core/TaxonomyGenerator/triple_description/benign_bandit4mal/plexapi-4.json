{
  "metadata": {
    "package_name": "plexapi-4",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/plexapi-4.16.1.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "gdm.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/plexapi-4.16.1/plexapi-4.16.1/plexapi/gdm.py",
      "line_number": "92",
      "type_description": "B808:settimeout",
      "context_snippet": "def update(self, scan_for_clients):\n    \"\"\"Scan for new GDM services.\n\n    Examples of the dict list assigned to self.entries by this function:\n\n        Server:\n\n            [{'data': {\n                 'Content-Type': 'plex/media-server',\n                 'Host': '53f4b5b6023d41182fe88a99b0e714ba.plex.direct',\n                 'Name': 'myfirstplexserver',\n                 'Port': '32400',\n                 'Resource-Identifier': '646ab0aa8a01c543e94ba975f6fd6efadc36b7',\n                 'Updated-At': '1585769946',\n                 'Version': '1.18.8.2527-740d4c206',\n            },\n             'from': ('10.10.10.100', 32414)}]\n\n        Clients:\n\n            [{'data': {'Content-Type': 'plex/media-player',\n                 'Device-Class': 'stb',\n                 'Name': 'plexamp',\n                 'Port': '36000',\n                 'Product': 'Plexamp',\n                 'Protocol': 'plex',\n                 'Protocol-Capabilities': 'timeline,playback,playqueues,playqueues-creation',\n                 'Protocol-Version': '1',\n                 'Resource-Identifier': 'b6e57a3f-e0f8-494f-8884-f4b58501467e',\n                 'Version': '1.1.0',\n            },\n             'from': ('10.10.10.101', 32412)}]\n    \"\"\"\n\n    gdm_msg = 'M-SEARCH * HTTP/1.0'.encode('ascii')\n    gdm_timeout = 1\n\n    self.entries = []\n    known_responses = []\n\n    # setup socket for discovery -> multicast message\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.settimeout(gdm_timeout)\n\n    # Set the time-to-live for messages for local network\n    sock.setsockopt(socket.IPPROTO_IP,\n                    socket.IP_MULTICAST_TTL,\n                    struct.pack(\"B\", gdm_timeout))\n\n    if scan_for_clients:\n        # setup socket for broadcast to Plex clients\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n        gdm_ip = '255.255.255.255'\n        gdm_port = 32412\n    else:\n        # setup socket for multicast to Plex server(s)\n        gdm_ip = '239.0.0.250'\n        gdm_port = 32414\n\n    try:\n        # Send data to the multicast group\n        sock.sendto(gdm_msg, (gdm_ip, gdm_port))\n\n        # Look for responses from all recipients\n        while True:\n            try:\n                bdata, host = sock.recvfrom(1024)\n                data = bdata.decode('utf-8')\n                if '200 OK' in data.splitlines()[0]:\n                    ddata = {k: v.strip() for (k, v) in (\n                        line.split(':') for line in\n                        data.splitlines() if ':' in line)}\n                    identifier = ddata.get('Resource-Identifier')\n                    if identifier and identifier in known_responses:\n                        continue\n                    known_responses.append(identifier)\n                    self.entries.append({'data': ddata,\n                                         'from': host})\n            except socket.timeout:\n                break\n    finally:\n        sock.close()",
      "hash_value": "2c67442b1be237721fc2b8e1add56ede",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "def update(self, scan_for_clients):\n    \"\"\"Scan for new GDM services.\n\n    Examples of the dict list assigned to self.entries by this function:\n\n        Server:\n\n            [{'data': {\n                 'Content-Type': 'plex/media-server',\n                 'Host': '53f4b5b6023d41182fe88a99b0e714ba.plex.direct',\n                 'Name': 'myfirstplexserver',\n                 'Port': '32400',\n                 'Resource-Identifier': '646ab0aa8a01c543e94ba975f6fd6efadc36b7',\n                 'Updated-At': '1585769946',\n                 'Version': '1.18.8.2527-740d4c206',\n            },\n             'from': ('10.10.10.100', 32414)}]\n\n        Clients:\n\n            [{'data': {'Content-Type': 'plex/media-player',\n                 'Device-Class': 'stb',\n                 'Name': 'plexamp',\n                 'Port': '36000',\n                 'Product': 'Plexamp',\n                 'Protocol': 'plex',\n                 'Protocol-Capabilities': 'timeline,playback,playqueues,playqueues-creation',\n                 'Protocol-Version': '1',\n                 'Resource-Identifier': 'b6e57a3f-e0f8-494f-8884-f4b58501467e',\n                 'Version': '1.1.0',\n            },\n             'from': ('10.10.10.101', 32412)}]\n    \"\"\"\n\n    gdm_msg = 'M-SEARCH * HTTP/1.0'.encode('ascii')\n    gdm_timeout = 1\n\n    self.entries = []\n    known_responses = []\n\n    # setup socket for discovery -> multicast message\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.settimeout(gdm_timeout)\n\n    # Set the time-to-live for messages for local network\n    sock.setsockopt(socket.IPPROTO_IP,\n                    socket.IP_MULTICAST_TTL,\n                    struct.pack(\"B\", gdm_timeout))\n\n    if scan_for_clients:\n        # setup socket for broadcast to Plex clients\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n        gdm_ip = '255.255.255.255'\n        gdm_port = 32412\n    else:\n        # setup socket for multicast to Plex server(s)\n        gdm_ip = '239.0.0.250'\n        gdm_port = 32414\n\n    try:\n        # Send data to the multicast group\n        sock.sendto(gdm_msg, (gdm_ip, gdm_port))\n\n        # Look for responses from all recipients\n        while True:\n            try:\n                bdata, host = sock.recvfrom(1024)\n                data = bdata.decode('utf-8')\n                if '200 OK' in data.splitlines()[0]:\n                    ddata = {k: v.strip() for (k, v) in (\n                        line.split(':') for line in\n                        data.splitlines() if ':' in line)}\n                    identifier = ddata.get('Resource-Identifier')\n                    if identifier and identifier in known_responses:\n                        continue\n                    known_responses.append(identifier)\n                    self.entries.append({'data': ddata,\n                                         'from': host})\n            except socket.timeout:\n                break\n    finally:\n        sock.close()",
          "triple_sequences": [
            {
              "action_api": "socket.socket()",
              "action_description": "Creates new socket object",
              "action_id": "create_socket",
              "object": "socket.AF_INET, socket.SOCK_DGRAM",
              "object_description": "Socket address",
              "object_id": "socket_address",
              "intention_description": "Establish connection",
              "intention_id": "establish_connection"
            },
            {
              "action_api": "socket.settimeout()",
              "action_description": "Sets timeout for socket operations",
              "action_id": "set_socket_timeout",
              "object": "gdm_timeout",
              "object_description": "Timeout duration value",
              "object_id": "timeout_value",
              "intention_description": "Delay next operation",
              "intention_id": "delay_next_operation"
            },
            {
              "action_api": "socket.setsockopt()",
              "action_description": "Performs device-specific input/output control",
              "action_id": "perform_device_io",
              "object": "socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, struct.pack(\"B\", gdm_timeout)",
              "object_description": "Timeout duration value",
              "object_id": "timeout_value",
              "intention_description": "Establish connection",
              "intention_id": "establish_connection"
            },
            {
              "action_api": "socket.setsockopt()",
              "action_description": "Performs device-specific input/output control",
              "action_id": "perform_device_io",
              "object": "socket.SOL_SOCKET, socket.SO_REUSEADDR, 1",
              "object_description": "Socket address",
              "object_id": "socket_address",
              "intention_description": "Establish connection",
              "intention_id": "establish_connection"
            },
            {
              "action_api": "socket.setsockopt()",
              "action_description": "Performs device-specific input/output control",
              "action_id": "perform_device_io",
              "object": "socket.SOL_SOCKET, socket.SO_BROADCAST, 1",
              "object_description": "Socket address",
              "object_id": "socket_address",
              "intention_description": "Establish connection",
              "intention_id": "establish_connection"
            },
            {
              "action_api": "socket.sendto()",
              "action_description": "Sends data over socket connection",
              "action_id": "send_socket_data",
              "object": "gdm_msg, (gdm_ip, gdm_port)",
              "object_description": "Socket address",
              "object_id": "socket_address",
              "intention_description": "Send DNS request",
              "intention_id": "send_dns_request"
            },
            {
              "action_api": "socket.recvfrom()",
              "action_description": "Receives data from socket connection",
              "action_id": "receive_socket_data",
              "object": "1024",
              "object_description": "Timeout duration value",
              "object_id": "timeout_value",
              "intention_description": "Receive command from server",
              "intention_id": "receive_command_from_server"
            },
            {
              "action_api": "bytes.decode()",
              "action_description": "Decodes bytes using default codec",
              "action_id": "decode_bytes_default",
              "object": "'utf-8'",
              "object_description": "Character encoding type",
              "object_id": "character_encoding_type",
              "intention_description": "Decode bytes to string",
              "intention_id": "decode_bytes_to_string"
            },
            {
              "action_api": "socket.close()",
              "action_description": "Closes the socket connection",
              "action_id": "close_socket",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Release connection resource",
              "intention_id": "release_connection_resource"
            }
          ]
        }
      ]
    }
  ]
}