{
  "metadata": {
    "package_name": "pyatlan-6",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/pyatlan-6.0.2.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "atlan.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyatlan-6.0.2/pyatlan-6.0.2/pyatlan/client/atlan.py",
      "line_number": "546",
      "type_description": "B820:get",
      "context_snippet": "def _call_api_internal(\n        self,\n        api,\n        path,\n        params,\n        binary_data=None,\n        download_file_path=None,\n        text_response=False,\n    ):\n        token = request_id_var.set(str(uuid.uuid4()))\n        try:\n            params[\"headers\"][\"X-Atlan-Request-Id\"] = request_id_var.get()\n            if binary_data:\n                response = self._session.request(\n                    api.method.value,\n                    path,\n                    data=binary_data,\n                    **params,\n                    timeout=(self.connect_timeout, self.read_timeout),\n                )\n            elif api.consumes == EVENT_STREAM and api.produces == EVENT_STREAM:\n                response = self._session.request(\n                    api.method.value,\n                    path,\n                    **params,\n                    stream=True,\n                    timeout=(self.connect_timeout, self.read_timeout),\n                )\n                if download_file_path:\n                    return self._handle_file_download(response.raw, download_file_path)\n            else:\n                response = self._session.request(\n                    api.method.value,\n                    path,\n                    **params,\n                    timeout=(self.connect_timeout, self.read_timeout),\n                )\n            if response is not None:\n                LOGGER.debug(\"HTTP Status: %s\", response.status_code)\n            if response is None:\n                return None\n\n            # Reset `has_retried` flag if:\n            # - SDK already attempted a 401 token refresh (`has_retried = True`)\n            # - and the current response status code is NOT 401\n            #\n            # Real-world scenario:\n            # - First 401 triggers `_handle_401_token_refresh`, setting `has_retried = True`\n            # - If the next response is also 401 → SDK returns 401 (won’t retry again)\n            # - But if the next response is != 401 (e.g. 403), and `has_retried = True`,\n            # then we should reset `has_retried = False` so that future 401s can trigger a new token refresh.\n            if (\n                self._401_tls.has_retried\n                and response.status_code\n                != ErrorCode.AUTHENTICATION_PASSTHROUGH.http_error_code\n            ):\n                self._401_tls.has_retried = False\n\n            if response.status_code == api.expected_status:\n                try:\n                    if (\n                        response.content is None\n                        or response.content == \"null\"\n                        or len(response.content) == 0\n                        or response.status_code == HTTPStatus.NO_CONTENT\n                    ):\n                        return None\n                    events = []\n                    if LOGGER.isEnabledFor(logging.DEBUG):\n                        LOGGER.debug(\n                            \"<== __call_api(%s,%s), result = %s\",\n                            vars(api),\n                            params,\n                            response,\n                        )\n                    if api.consumes == EVENT_STREAM and api.produces == EVENT_STREAM:\n                        for line in response.iter_lines(decode_unicode=True):\n                            if not line:\n                                continue\n                            if not line.startswith(\"data: \"):\n                                raise ErrorCode.UNABLE_TO_DESERIALIZE.exception_with_parameters(\n                                    line\n                                )\n                            events.append(json.loads(line.split(\"data: \")[1]))\n                    if text_response:\n                        response_ = response.text\n                    else:\n                        response_ = events if events else response.json()\n                    LOGGER.debug(\"response: %s\", response_)\n                    return response_\n                except (\n                    requests.exceptions.JSONDecodeError,\n                    json.decoder.JSONDecodeError,\n                ) as e:\n                    raise ErrorCode.JSON_ERROR.exception_with_parameters(\n                        response.text, response.status_code, str(e)\n                    ) from e\n            elif response.status_code == HTTPStatus.SERVICE_UNAVAILABLE:\n                LOGGER.error(\n                    \"Atlas Service unavailable. HTTP Status: %s\",\n                    HTTPStatus.SERVICE_UNAVAILABLE,\n                )\n\n                return None\n            else:\n                with contextlib.suppress(ValueError, json.decoder.JSONDecodeError):\n                    error_info = json.loads(response.text)\n                    error_code = (\n                        error_info.get(\"errorCode\", 0)\n                        or error_info.get(\"code\", 0)\n                        or error_info.get(\"status\")\n                    )\n                    error_message = error_info.get(\n                        \"errorMessage\", \"\"\n                    ) or error_info.get(\"message\", \"\")\n                    error_doc = (\n                        error_info.get(\"doc\")\n                        or error_info.get(\"errorDoc\")\n                        or error_info.get(\"errorDocument\")\n                        or error_info.get(\"errorDocumentation\")\n                    )\n                    error_cause = error_info.get(\"errorCause\", [])\n                    causes = error_info.get(\"causes\", [])\n                    backend_error_id = error_info.get(\"errorId\")\n\n                    # Handle the causes and format them for exception\n                    error_cause_details = [\n                        f\"ErrorType: {cause.get('errorType', 'Unknown')}, \"\n                        f\"Message: {cause.get('errorMessage', 'No additional information provided')}, \"\n                        f\"Location: {cause.get('location', 'Unknown location')}\"\n                        for cause in causes\n                    ]\n                    # Join the error cause details into a single string, separated by newlines\n                    error_cause_details_str = (\n                        \"\\n\".join(error_cause_details) if error_cause_details else \"\"\n                    )\n\n                    # Retry with impersonation (if _user_id is present)\n                    # on authentication failure (token may have expired)\n                    if (\n                        self._user_id\n                        and not self._401_tls.has_retried\n                        and response.status_code\n                        == ErrorCode.AUTHENTICATION_PASSTHROUGH.http_error_code\n                    ):\n                        try:\n                            LOGGER.debug(\"Starting 401 automatic token refresh.\")\n                            return self._handle_401_token_refresh(\n                                api,\n                                path,\n                                params,\n                                binary_data=binary_data,\n                                download_file_path=download_file_path,\n                                text_response=text_response,\n                            )\n                        except Exception as e:\n                            LOGGER.debug(\n                                \"API call failed after a successful 401 token refresh. Error details: %s\",\n                                e,\n                            )\n                            raise\n\n                    if error_code and error_message:\n                        error = ERROR_CODE_FOR_HTTP_STATUS.get(\n                            response.status_code, ErrorCode.ERROR_PASSTHROUGH\n                        )\n                        # Raise exception with error details and causes\n                        raise error.exception_with_parameters(\n                            error_code,\n                            error_message,\n                            error_cause_details_str,\n                            error_cause=error_cause,\n                            backend_error_id=backend_error_id,\n                            error_doc=error_doc,\n                        )\n                raise AtlanError(\n                    SimpleNamespace(\n                        http_error_code=response.status_code,\n                        error_id=f\"ATLAN-PYTHON-{response.status_code}-000\",\n                        error_message=response.text,\n                        user_action=ErrorCode.ERROR_PASSTHROUGH.user_action,\n                    )\n                )\n        finally:\n            request_id_var.reset(token)\n",
      "hash_value": "ca9481e311613ebc7fa2c126b8036a2e",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "def _call_api_internal(\n        self,\n        api,\n        path,\n        params,\n        binary_data=None,\n        download_file_path=None,\n        text_response=False,\n    ):\n        token = request_id_var.set(str(uuid.uuid4()))\n        try:\n            params[\"headers\"][\"X-Atlan-Request-Id\"] = request_id_var.get()\n            if binary_data:\n                response = self._session.request(\n                    api.method.value,\n                    path,\n                    data=binary_data,\n                    **params,\n                    timeout=(self.connect_timeout, self.read_timeout),\n                )\n            elif api.consumes == EVENT_STREAM and api.produces == EVENT_STREAM:\n                response = self._session.request(\n                    api.method.value,\n                    path,\n                    **params,\n                    stream=True,\n                    timeout=(self.connect_timeout, self.read_timeout),\n                )\n                if download_file_path:\n                    return self._handle_file_download(response.raw, download_file_path)\n            else:\n                response = self._session.request(\n                    api.method.value,\n                    path,\n                    **params,\n                    timeout=(self.connect_timeout, self.read_timeout),\n                )\n            if response is not None:\n                LOGGER.debug(\"HTTP Status: %s\", response.status_code)\n            if response is None:\n                return None\n\n            # Reset `has_retried` flag if:\n            # - SDK already attempted a 401 token refresh (`has_retried = True`)\n            # - and the current response status code is NOT 401\n            #\n            # Real-world scenario:\n            # - First 401 triggers `_handle_401_token_refresh`, setting `has_retried = True`\n            # - If the next response is also 401 → SDK returns 401 (won’t retry again)\n            # - But if the next response is != 401 (e.g. 403), and `has_retried = True`,\n            # then we should reset `has_retried = False` so that future 401s can trigger a new token refresh.\n            if (\n                self._401_tls.has_retried\n                and response.status_code\n                != ErrorCode.AUTHENTICATION_PASSTHROUGH.http_error_code\n            ):\n                self._401_tls.has_retried = False\n\n            if response.status_code == api.expected_status:\n                try:\n                    if (\n                        response.content is None\n                        or response.content == \"null\"\n                        or len(response.content) == 0\n                        or response.status_code == HTTPStatus.NO_CONTENT\n                    ):\n                        return None\n                    events = []\n                    if LOGGER.isEnabledFor(logging.DEBUG):\n                        LOGGER.debug(\n                            \"<== __call_api(%s,%s), result = %s\",\n                            vars(api),\n                            params,\n                            response,\n                        )\n                    if api.consumes == EVENT_STREAM and api.produces == EVENT_STREAM:\n                        for line in response.iter_lines(decode_unicode=True):\n                            if not line:\n                                continue\n                            if not line.startswith(\"data: \"):\n                                raise ErrorCode.UNABLE_TO_DESERIALIZE.exception_with_parameters(\n                                    line\n                                )\n                            events.append(json.loads(line.split(\"data: \")[1]))\n                    if text_response:\n                        response_ = response.text\n                    else:\n                        response_ = events if events else response.json()\n                    LOGGER.debug(\"response: %s\", response_)\n                    return response_\n                except (\n                    requests.exceptions.JSONDecodeError,\n                    json.decoder.JSONDecodeError,\n                ) as e:\n                    raise ErrorCode.JSON_ERROR.exception_with_parameters(\n                        response.text, response.status_code, str(e)\n                    ) from e\n            elif response.status_code == HTTPStatus.SERVICE_UNAVAILABLE:\n                LOGGER.error(\n                    \"Atlas Service unavailable. HTTP Status: %s\",\n                    HTTPStatus.SERVICE_UNAVAILABLE,\n                )\n\n                return None\n            else:\n                with contextlib.suppress(ValueError, json.decoder.JSONDecodeError):\n                    error_info = json.loads(response.text)\n                    error_code = (\n                        error_info.get(\"errorCode\", 0)\n                        or error_info.get(\"code\", 0)\n                        or error_info.get(\"status\")\n                    )\n                    error_message = error_info.get(\n                        \"errorMessage\", \"\"\n                    ) or error_info.get(\"message\", \"\")\n                    error_doc = (\n                        error_info.get(\"doc\")\n                        or error_info.get(\"errorDoc\")\n                        or error_info.get(\"errorDocument\")\n                        or error_info.get(\"errorDocumentation\")\n                    )\n                    error_cause = error_info.get(\"errorCause\", [])\n                    causes = error_info.get(\"causes\", [])\n                    backend_error_id = error_info.get(\"errorId\")\n\n                    # Handle the causes and format them for exception\n                    error_cause_details = [\n                        f\"ErrorType: {cause.get('errorType', 'Unknown')}, \"\n                        f\"Message: {cause.get('errorMessage', 'No additional information provided')}, \"\n                        f\"Location: {cause.get('location', 'Unknown location')}\"\n                        for cause in causes\n                    ]\n                    # Join the error cause details into a single string, separated by newlines\n                    error_cause_details_str = (\n                        \"\\n\".join(error_cause_details) if error_cause_details else \"\"\n                    )\n\n                    # Retry with impersonation (if _user_id is present)\n                    # on authentication failure (token may have expired)\n                    if (\n                        self._user_id\n                        and not self._401_tls.has_retried\n                        and response.status_code\n                        == ErrorCode.AUTHENTICATION_PASSTHROUGH.http_error_code\n                    ):\n                        try:\n                            LOGGER.debug(\"Starting 401 automatic token refresh.\")\n                            return self._handle_401_token_refresh(\n                                api,\n                                path,\n                                params,\n                                binary_data=binary_data,\n                                download_file_path=download_file_path,\n                                text_response=text_response,\n                            )\n                        except Exception as e:\n                            LOGGER.debug(\n                                \"API call failed after a successful 401 token refresh. Error details: %s\",\n                                e,\n                            )\n                            raise\n\n                    if error_code and error_message:\n                        error = ERROR_CODE_FOR_HTTP_STATUS.get(\n                            response.status_code, ErrorCode.ERROR_PASSTHROUGH\n                        )\n                        # Raise exception with error details and causes\n                        raise error.exception_with_parameters(\n                            error_code,\n                            error_message,\n                            error_cause_details_str,\n                            error_cause=error_cause,\n                            backend_error_id=backend_error_id,\n                            error_doc=error_doc,\n                        )\n                raise AtlanError(\n                    SimpleNamespace(\n                        http_error_code=response.status_code,\n                        error_id=f\"ATLAN-PYTHON-{response.status_code}-000\",\n                        error_message=response.text,\n                        user_action=ErrorCode.ERROR_PASSTHROUGH.user_action,\n                    )\n                )\n        finally:\n            request_id_var.reset(token)\n",
          "triple_sequences": [
            {
              "action_api": "request_id_var.set()",
              "action_description": "Sets attribute on builtins object",
              "action_id": "set_builtin_attr",
              "object": "str(uuid.uuid4())",
              "object_description": "Random string",
              "object_id": "random_string",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "request_id_var.get()",
              "action_description": "Sets attribute on builtins object",
              "action_id": "set_builtin_attr",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "self._session.request()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "api.method.value, path, data=binary_data, **params, timeout=(self.connect_timeout, self.read_timeout)",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "self._session.request()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "api.method.value, path, **params, stream=True, timeout=(self.connect_timeout, self.read_timeout)",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "self._handle_file_download()",
              "action_description": "Downloads file from URL to local path",
              "action_id": "download_file_url",
              "object": "response.raw, download_file_path",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write downloaded content to file",
              "intention_id": "write_downloaded_content_file"
            },
            {
              "action_api": "self._session.request()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "api.method.value, path, **params, timeout=(self.connect_timeout, self.read_timeout)",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "LOGGER.debug()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "\"HTTP Status: %s\", response.status_code",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "response.status_code",
              "action_description": "Retrieves HTTP response status code",
              "action_id": "get_http_status",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "self._401_tls.has_retried",
              "action_description": "Retrieves attribute value",
              "action_id": "set_builtin_attr",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "response.status_code",
              "action_description": "Retrieves HTTP response status code",
              "action_id": "get_http_status",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "LOGGER.debug()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "\"<== __call_api(%s,%s), result = %s\", vars(api), params, response",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "response.iter_lines()",
              "action_description": "Iterates over response content in chunks",
              "action_id": "iterate_response_chunks",
              "object": "decode_unicode=True",
              "object_description": "HTTP response content from remote server",
              "object_id": "http_response_remote_content",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "json.loads()",
              "action_description": "Deserializes JSON string to Python object",
              "action_id": "deserialize_from_json",
              "object": "line.split(\"data: \")[1]",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "response.text",
              "action_description": "Process HTTP response content",
              "action_id": "process_http_response",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "response.json()",
              "action_description": "Deserializes JSON response body to Python object",
              "action_id": "deserialize_json_response",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "LOGGER.debug()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "\"response: %s\", response_",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "json.loads()",
              "action_description": "Deserializes JSON string to Python object",
              "action_id": "deserialize_from_json",
              "object": "response.text",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "error_info.get()",
              "action_description": "Retrieves attribute value",
              "action_id": "set_builtin_attr",
              "object": "\"errorCode\", 0",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "error_info.get()",
              "action_description": "Retrieves attribute value",
              "action_id": "set_builtin_attr",
              "object": "\"errorMessage\", \"\"",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "error_info.get()",
              "action_description": "Retrieves attribute value",
              "action_id": "set_builtin_attr",
              "object": "\"doc\"",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "error_info.get()",
              "action_description": "Retrieves attribute value",
              "action_id": "set_builtin_attr",
              "object": "\"errorCause\", []",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "error_info.get()",
              "action_description": "Retrieves attribute value",
              "action_id": "set_builtin_attr",
              "object": "\"causes\", []",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "error_info.get()",
              "action_description": "Retrieves attribute value",
              "action_id": "set_builtin_attr",
              "object": "\"errorId\"",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "self._handle_401_token_refresh()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "api, path, params, binary_data=binary_data, download_file_path=download_file_path, text_response=text_response",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "LOGGER.debug()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "\"API call failed after a successful 401 token refresh. Error details: %s\", e",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "ERROR_CODE_FOR_HTTP_STATUS.get()",
              "action_description": "Retrieves attribute value",
              "action_id": "set_builtin_attr",
              "object": "response.status_code, ErrorCode.ERROR_PASSTHROUGH",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "error.exception_with_parameters()",
              "action_description": "Raises HTTPError if response status code indicates error",
              "action_id": "raise_http_error",
              "object": "error_code, error_message, error_cause_details_str, error_cause=error_cause, backend_error_id=backend_error_id, error_doc=error_doc",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "AtlanError()",
              "action_description": "Raises HTTPError if response status code indicates error",
              "action_id": "raise_http_error",
              "object": "SimpleNamespace(http_error_code=response.status_code, error_id=f\"ATLAN-PYTHON-{response.status_code}-000\", error_message=response.text, user_action=ErrorCode.ERROR_PASSTHROUGH.user_action)",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "request_id_var.reset()",
              "action_description": "Sets attribute on builtins object",
              "action_id": "set_builtin_attr",
              "object": "token",
              "object_description": "Random string",
              "object_id": "random_string",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            }
          ]
        }
      ]
    }
  ]
}