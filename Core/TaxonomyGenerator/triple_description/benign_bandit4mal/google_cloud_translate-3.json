{
  "metadata": {
    "package_name": "google_cloud_translate-3",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/google_cloud_translate-3.20.2.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "rest.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_translate-3.20.2/google_cloud_translate-3.20.2/google/cloud/translate_v3/services/translation_service/transports/rest.py",
      "line_number": "9366",
      "type_description": "B822:request",
      "context_snippet": "class _WaitOperation(\n    _BaseTranslationServiceRestTransport._BaseWaitOperation,\n    TranslationServiceRestStub,\n):\n    def __hash__(self):\n        return hash(\"TranslationServiceRestTransport.WaitOperation\")\n\n    @staticmethod\n    def _get_response(\n        host,\n        metadata,\n        query_params,\n        session,\n        timeout,\n        transcoded_request,\n        body=None,\n    ):\n        uri = transcoded_request[\"uri\"]\n        method = transcoded_request[\"method\"]\n        headers = dict(metadata)\n        headers[\"Content-Type\"] = \"application/json\"\n        response = getattr(session, method)(\n            \"{host}{uri}\".format(host=host, uri=uri),\n            timeout=timeout,\n            headers=headers,\n            params=rest_helpers.flatten_query_params(query_params, strict=True),\n            data=body,\n        )\n        return response\n\n    def __call__(\n        self,\n        request: operations_pb2.WaitOperationRequest,\n        *,\n        retry: OptionalRetry = gapic_v1.method.DEFAULT,\n        timeout: Optional[float] = None,\n        metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n    ) -> operations_pb2.Operation:\n        r\"\"\"Call the wait operation method over HTTP.\n\n        Args:\n            request (operations_pb2.WaitOperationRequest):\n                The request object for WaitOperation method.\n            retry (google.api_core.retry.Retry): Designation of what errors, if any,\n                should be retried.\n            timeout (float): The timeout for this request.\n            metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n                sent along with the request as metadata. Normally, each value must be of type `str`,\n                but for metadata keys ending with the suffix `-bin`, the corresponding values must\n                be of type `bytes`.\n\n        Returns:\n            operations_pb2.Operation: Response from WaitOperation method.\n        \"\"\"\n\n        http_options = (\n            _BaseTranslationServiceRestTransport._BaseWaitOperation._get_http_options()\n        )\n\n        request, metadata = self._interceptor.pre_wait_operation(request, metadata)\n        transcoded_request = _BaseTranslationServiceRestTransport._BaseWaitOperation._get_transcoded_request(\n            http_options, request\n        )\n\n        body = _BaseTranslationServiceRestTransport._BaseWaitOperation._get_request_body_json(\n            transcoded_request\n        )\n\n        # Jsonify the query params\n        query_params = _BaseTranslationServiceRestTransport._BaseWaitOperation._get_query_params_json(\n            transcoded_request\n        )\n\n        if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n            logging.DEBUG\n        ):  # pragma: NO COVER\n            request_url = \"{host}{uri}\".format(\n                host=self._host, uri=transcoded_request[\"uri\"]\n            )\n            method = transcoded_request[\"method\"]\n            try:\n                request_payload = json_format.MessageToJson(request)\n            except:\n                request_payload = None\n            http_request = {\n                \"payload\": request_payload,\n                \"requestMethod\": method,\n                \"requestUrl\": request_url,\n                \"headers\": dict(metadata),\n            }\n            _LOGGER.debug(\n                f\"Sending request for google.cloud.translation_v3.TranslationServiceClient.WaitOperation\",\n                extra={\n                    \"serviceName\": \"google.cloud.translation.v3.TranslationService\",\n                    \"rpcName\": \"WaitOperation\",\n                    \"httpRequest\": http_request,\n                    \"metadata\": http_request[\"headers\"],\n                },\n            )\n\n        # Send the request\n        response = TranslationServiceRestTransport._WaitOperation._get_response(\n            self._host,\n            metadata,\n            query_params,\n            self._session,\n            timeout,\n            transcoded_request,\n            body,\n        )\n\n        # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n        # subclass.\n        if response.status_code >= 400:\n            raise core_exceptions.from_http_response(response)\n\n        content = response.content.decode(\"utf-8\")\n        resp = operations_pb2.Operation()\n        resp = json_format.Parse(content, resp)\n        resp = self._interceptor.post_wait_operation(resp)\n        if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n            logging.DEBUG\n        ):  # pragma: NO COVER\n            try:\n                response_payload = json_format.MessageToJson(resp)\n            except:\n                response_payload = None\n            http_response = {\n                \"payload\": response_payload,\n                \"headers\": dict(response.headers),\n                \"status\": response.status_code,\n            }\n            _LOGGER.debug(\n                \"Received response for google.cloud.translation_v3.TranslationServiceAsyncClient.WaitOperation\",\n                extra={\n                    \"serviceName\": \"google.cloud.translation.v3.TranslationService\",\n                    \"rpcName\": \"WaitOperation\",\n                    \"httpResponse\": http_response,\n                    \"metadata\": http_response[\"headers\"],\n                },\n            )\n        return resp",
      "hash_value": "226e1afc4ebe779b0a8640390804723f",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "class _WaitOperation(\n    _BaseTranslationServiceRestTransport._BaseWaitOperation,\n    TranslationServiceRestStub,\n):\n    def __hash__(self):\n        return hash(\"TranslationServiceRestTransport.WaitOperation\")\n\n    @staticmethod\n    def _get_response(\n        host,\n        metadata,\n        query_params,\n        session,\n        timeout,\n        transcoded_request,\n        body=None,\n    ):\n        uri = transcoded_request[\"uri\"]\n        method = transcoded_request[\"method\"]\n        headers = dict(metadata)\n        headers[\"Content-Type\"] = \"application/json\"\n        response = getattr(session, method)(\n            \"{host}{uri}\".format(host=host, uri=uri),\n            timeout=timeout,\n            headers=headers,\n            params=rest_helpers.flatten_query_params(query_params, strict=True),\n            data=body,\n        )\n        return response\n\n    def __call__(\n        self,\n        request: operations_pb2.WaitOperationRequest,\n        *,\n        retry: OptionalRetry = gapic_v1.method.DEFAULT,\n        timeout: Optional[float] = None,\n        metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n    ) -> operations_pb2.Operation:\n        r\"\"\"Call the wait operation method over HTTP.\n\n        Args:\n            request (operations_pb2.WaitOperationRequest):\n                The request object for WaitOperation method.\n            retry (google.api_core.retry.Retry): Designation of what errors, if any,\n                should be retried.\n            timeout (float): The timeout for this request.\n            metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n                sent along with the request as metadata. Normally, each value must be of type `str`,\n                but for metadata keys ending with the suffix `-bin`, the corresponding values must\n                be of type `bytes`.\n\n        Returns:\n            operations_pb2.Operation: Response from WaitOperation method.\n        \"\"\"\n\n        http_options = (\n            _BaseTranslationServiceRestTransport._BaseWaitOperation._get_http_options()\n        )\n\n        request, metadata = self._interceptor.pre_wait_operation(request, metadata)\n        transcoded_request = _BaseTranslationServiceRestTransport._BaseWaitOperation._get_transcoded_request(\n            http_options, request\n        )\n\n        body = _BaseTranslationServiceRestTransport._BaseWaitOperation._get_request_body_json(\n            transcoded_request\n        )\n\n        # Jsonify the query params\n        query_params = _BaseTranslationServiceRestTransport._BaseWaitOperation._get_query_params_json(\n            transcoded_request\n        )\n\n        if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n            logging.DEBUG\n        ):  # pragma: NO COVER\n            request_url = \"{host}{uri}\".format(\n                host=self._host, uri=transcoded_request[\"uri\"]\n            )\n            method = transcoded_request[\"method\"]\n            try:\n                request_payload = json_format.MessageToJson(request)\n            except:\n                request_payload = None\n            http_request = {\n                \"payload\": request_payload,\n                \"requestMethod\": method,\n                \"requestUrl\": request_url,\n                \"headers\": dict(metadata),\n            }\n            _LOGGER.debug(\n                f\"Sending request for google.cloud.translation_v3.TranslationServiceClient.WaitOperation\",\n                extra={\n                    \"serviceName\": \"google.cloud.translation.v3.TranslationService\",\n                    \"rpcName\": \"WaitOperation\",\n                    \"httpRequest\": http_request,\n                    \"metadata\": http_request[\"headers\"],\n                },\n            )\n\n        # Send the request\n        response = TranslationServiceRestTransport._WaitOperation._get_response(\n            self._host,\n            metadata,\n            query_params,\n            self._session,\n            timeout,\n            transcoded_request,\n            body,\n        )\n\n        # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n        # subclass.\n        if response.status_code >= 400:\n            raise core_exceptions.from_http_response(response)\n\n        content = response.content.decode(\"utf-8\")\n        resp = operations_pb2.Operation()\n        resp = json_format.Parse(content, resp)\n        resp = self._interceptor.post_wait_operation(resp)\n        if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n            logging.DEBUG\n        ):  # pragma: NO COVER\n            try:\n                response_payload = json_format.MessageToJson(resp)\n            except:\n                response_payload = None\n            http_response = {\n                \"payload\": response_payload,\n                \"headers\": dict(response.headers),\n                \"status\": response.status_code,\n            }\n            _LOGGER.debug(\n                \"Received response for google.cloud.translation_v3.TranslationServiceAsyncClient.WaitOperation\",\n                extra={\n                    \"serviceName\": \"google.cloud.translation.v3.TranslationService\",\n                    \"rpcName\": \"WaitOperation\",\n                    \"httpResponse\": http_response,\n                    \"metadata\": http_response[\"headers\"],\n                },\n            )\n        return resp",
          "triple_sequences": [
            {
              "action_api": "dict()",
              "action_description": "Creates dictionary object",
              "action_id": "create_dict_object",
              "object": "metadata",
              "object_description": "HTTP request/response headers",
              "object_id": "http_headers",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "getattr()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "{host}{uri}.format(host=host, uri=uri)",
              "object_description": "External domain",
              "object_id": "external_domain",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "rest_helpers.flatten_query_params()",
              "action_description": "Encodes mapping object to URL query string",
              "action_id": "encode_url_query",
              "object": "query_params, strict=True",
              "object_description": "Query parameter",
              "object_id": "query_parameter",
              "intention_description": "Prepare URL for HTTP request",
              "intention_id": "prepare_url_http_request"
            },
            {
              "action_api": "json_format.MessageToJson()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "request",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Serialize data",
              "intention_id": "serialize_data"
            },
            {
              "action_api": "_LOGGER.debug()",
              "action_description": "Logs debug message",
              "action_id": "log_debug_message",
              "object": "httpRequest",
              "object_description": "HTTP request/response headers",
              "object_id": "http_headers",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "TranslationServiceRestTransport._WaitOperation._get_response()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self._host, metadata, query_params, self._session, timeout, transcoded_request, body",
              "object_description": "External domain",
              "object_id": "external_domain",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "core_exceptions.from_http_response()",
              "action_description": "Raises HTTPError if response status code indicates error",
              "action_id": "raise_http_error",
              "object": "response",
              "object_description": "HTTP response content from remote server",
              "object_id": "http_response_remote_content",
              "intention_description": "Stop execution on invalid input",
              "intention_id": "stop_execution_invalid_input"
            },
            {
              "action_api": "response.content.decode()",
              "action_description": "Decodes bytes using default codec",
              "action_id": "decode_bytes_default",
              "object": "\"utf-8\"",
              "object_description": "Character encoding type",
              "object_id": "character_encoding_type",
              "intention_description": "Decode downloaded content",
              "intention_id": "decode_downloaded_content"
            },
            {
              "action_api": "json_format.Parse()",
              "action_description": "Deserializes JSON string to Python object",
              "action_id": "deserialize_from_json",
              "object": "content, resp",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "self._interceptor.post_wait_operation()",
              "action_description": "Runs post-processing function",
              "action_id": "run_post_install_function",
              "object": "resp",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "json_format.MessageToJson()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "resp",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Serialize data",
              "intention_id": "serialize_data"
            },
            {
              "action_api": "_LOGGER.debug()",
              "action_description": "Logs debug message",
              "action_id": "log_debug_message",
              "object": "httpResponse",
              "object_description": "HTTP request/response headers",
              "object_id": "http_headers",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            }
          ]
        }
      ]
    }
  ]
}