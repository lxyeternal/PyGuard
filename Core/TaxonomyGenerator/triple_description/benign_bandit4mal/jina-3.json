{
  "metadata": {
    "package_name": "jina-3",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/jina-3.34.0.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "asyncio.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/jina-3.34.0/jina-3.34.0/jina/serve/runtimes/asyncio.py",
      "line_number": "215",
      "type_description": "B827:httpserver",
      "context_snippet": "def _get_server(self):\n    # construct server type based on protocol (and potentially req handler class to keep backwards compatibility)\n    from jina.enums import ProtocolType, ProviderType\n\n    if self.req_handler_cls.__name__ == 'GatewayRequestHandler':\n        self.timeout_send = self.args.timeout_send\n        if self.timeout_send:\n            self.timeout_send /= 1e3  # convert ms to seconds\n        if not self.args.port:\n            self.args.port = random_ports(len(self.args.protocol))\n        _set_gateway_uses(\n            self.args, gateway_load_balancer=self.gateway_load_balancer\n        )\n        uses_with = self.args.uses_with or {}\n        non_defaults = ArgNamespace.get_non_defaults_args(\n            self.args, set_gateway_parser()\n        )\n        if 'title' not in non_defaults:\n            uses_with['title'] = self.args.title\n        if 'description' not in non_defaults:\n            uses_with['description'] = self.args.description\n        if 'no_debug_endpoints' not in non_defaults:\n            uses_with['no_debug_endpoints'] = self.args.no_debug_endpoints\n        if 'no_crud_endpoints' not in non_defaults:\n            uses_with['no_crud_endpoints'] = self.args.no_crud_endpoints\n        if 'expose_endpoints' not in non_defaults:\n            uses_with['expose_endpoints'] = self.args.expose_endpoints\n        if 'expose_graphql_endpoint' not in non_defaults:\n            uses_with['expose_graphql_endpoint'] = self.args.expose_graphql_endpoint\n        if 'cors' not in non_defaults:\n            uses_with['cors'] = self.args.cors\n        server = BaseGateway.load_config(\n            self.args.uses,\n            uses_with=dict(\n                **non_defaults,\n                **uses_with,\n            ),\n            uses_metas={},\n            runtime_args={  # these are not parsed to the yaml config file but are pass directly during init\n                **vars(self.args),\n                'default_port': getattr(self.args, 'default_port', False),\n                'gateway_load_balancer': self.gateway_load_balancer,\n                'timeout_send': self.timeout_send,\n            },\n            py_modules=self.args.py_modules,\n            extra_search_paths=self.args.extra_search_paths,\n        )\n        if isinstance(server, BaseServer):\n            server.is_cancel = self.is_cancel\n        return server\n    elif (\n        hasattr(self.args, 'provider')\n        and self.args.provider == ProviderType.SAGEMAKER\n    ):\n        from jina.serve.runtimes.servers.http import SagemakerHTTPServer\n\n        return SagemakerHTTPServer(\n            name=self.args.name,\n            runtime_args=self.args,\n            req_handler_cls=self.req_handler_cls,\n            proxy=getattr(self.args, 'proxy', None),\n            uvicorn_kwargs=getattr(self.args, 'uvicorn_kwargs', None),\n            ssl_keyfile=getattr(self.args, 'ssl_keyfile', None),\n            ssl_certfile=getattr(self.args, 'ssl_certfile', None),\n            cors=getattr(self.args, 'cors', None),\n            is_cancel=self.is_cancel,\n        )\n    elif (\n        hasattr(self.args, 'provider')\n        and self.args.provider == ProviderType.AZURE\n    ):\n        from jina.serve.runtimes.servers.http import AzureHTTPServer\n\n        return AzureHTTPServer(\n            name=self.args.name,\n            runtime_args=self.args,\n            req_handler_cls=self.req_handler_cls,\n            proxy=getattr(self.args, 'proxy', None),\n            uvicorn_kwargs=getattr(self.args, 'uvicorn_kwargs', None),\n            ssl_keyfile=getattr(self.args, 'ssl_keyfile', None),\n            ssl_certfile=getattr(self.args, 'ssl_certfile', None),\n            cors=getattr(self.args, 'cors', None),\n            is_cancel=self.is_cancel,\n        )\n    elif not hasattr(self.args, 'protocol') or (\n        len(self.args.protocol) == 1 and self.args.protocol[0] == ProtocolType.GRPC\n    ):\n        from jina.serve.runtimes.servers.grpc import GRPCServer\n\n        return GRPCServer(\n            name=self.args.name,\n            runtime_args=self.args,\n            req_handler_cls=self.req_handler_cls,\n            grpc_server_options=self.args.grpc_server_options,\n            ssl_keyfile=getattr(self.args, 'ssl_keyfile', None),\n            ssl_certfile=getattr(self.args, 'ssl_certfile', None),\n            proxy=getattr(self.args, 'proxy', None),\n        )\n\n    elif (\n        len(self.args.protocol) == 1 and self.args.protocol[0] == ProtocolType.HTTP\n    ):\n        from jina.serve.runtimes.servers.http import (\n            HTTPServer,  # we need a concrete implementation of this\n        )\n\n        return HTTPServer(\n            name=self.args.name,\n            runtime_args=self.args,\n            req_handler_cls=self.req_handler_cls,\n            proxy=getattr(self.args, 'proxy', None),\n            uvicorn_kwargs=getattr(self.args, 'uvicorn_kwargs', None),\n            ssl_keyfile=getattr(self.args, 'ssl_keyfile', None),\n            ssl_certfile=getattr(self.args, 'ssl_certfile', None),\n            cors=getattr(self.args, 'cors', None),\n            is_cancel=self.is_cancel,\n        )\n    elif (\n        len(self.args.protocol) == 1\n        and self.args.protocol[0] == ProtocolType.WEBSOCKET\n    ):\n        from jina.serve.runtimes.servers.websocket import (\n            WebSocketServer,  # we need a concrete implementation of this\n        )\n\n        return WebSocketServer(\n            name=self.args.name,\n            runtime_args=self.args,\n            req_handler_cls=self.req_handler_cls,\n            proxy=getattr(self.args, 'proxy', None),\n            uvicorn_kwargs=getattr(self.args, 'uvicorn_kwargs', None),\n            ssl_keyfile=getattr(self.args, 'ssl_keyfile', None),\n            ssl_certfile=getattr(self.args, 'ssl_certfile', None),\n            is_cancel=self.is_cancel,\n        )\n    elif len(self.args.protocol) > 1:\n        from jina.serve.runtimes.servers.composite import (\n            CompositeServer,  # we need a concrete implementation of this\n        )\n\n        return CompositeServer(\n            name=self.args.name,\n            runtime_args=self.args,\n            req_handler_cls=self.req_handler_cls,\n            ssl_keyfile=getattr(self.args, 'ssl_keyfile', None),\n            ssl_certfile=getattr(self.args, 'ssl_certfile', None),\n            is_cancel=self.is_cancel,\n        )",
      "hash_value": "9801a054435a91dd2e1bd035c67eb81c",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "def _get_server(self):\n    # construct server type based on protocol (and potentially req handler class to keep backwards compatibility)\n    from jina.enums import ProtocolType, ProviderType\n\n    if self.req_handler_cls.__name__ == 'GatewayRequestHandler':\n        self.timeout_send = self.args.timeout_send\n        if self.timeout_send:\n            self.timeout_send /= 1e3  # convert ms to seconds\n        if not self.args.port:\n            self.args.port = random_ports(len(self.args.protocol))\n        _set_gateway_uses(\n            self.args, gateway_load_balancer=self.gateway_load_balancer\n        )\n        uses_with = self.args.uses_with or {}\n        non_defaults = ArgNamespace.get_non_defaults_args(\n            self.args, set_gateway_parser()\n        )\n        if 'title' not in non_defaults:\n            uses_with['title'] = self.args.title\n        if 'description' not in non_defaults:\n            uses_with['description'] = self.args.description\n        if 'no_debug_endpoints' not in non_defaults:\n            uses_with['no_debug_endpoints'] = self.args.no_debug_endpoints\n        if 'no_crud_endpoints' not in non_defaults:\n            uses_with['no_crud_endpoints'] = self.args.no_crud_endpoints\n        if 'expose_endpoints' not in non_defaults:\n            uses_with['expose_endpoints'] = self.args.expose_endpoints\n        if 'expose_graphql_endpoint' not in non_defaults:\n            uses_with['expose_graphql_endpoint'] = self.args.expose_graphql_endpoint\n        if 'cors' not in non_defaults:\n            uses_with['cors'] = self.args.cors\n        server = BaseGateway.load_config(\n            self.args.uses,\n            uses_with=dict(\n                **non_defaults,\n                **uses_with,\n            ),\n            uses_metas={},\n            runtime_args={  # these are not parsed to the yaml config file but are pass directly during init\n                **vars(self.args),\n                'default_port': getattr(self.args, 'default_port', False),\n                'gateway_load_balancer': self.gateway_load_balancer,\n                'timeout_send': self.timeout_send,\n            },\n            py_modules=self.args.py_modules,\n            extra_search_paths=self.args.extra_search_paths,\n        )\n        if isinstance(server, BaseServer):\n            server.is_cancel = self.is_cancel\n        return server\n    elif (\n        hasattr(self.args, 'provider')\n        and self.args.provider == ProviderType.SAGEMAKER\n    ):\n        from jina.serve.runtimes.servers.http import SagemakerHTTPServer\n\n        return SagemakerHTTPServer(\n            name=self.args.name,\n            runtime_args=self.args,\n            req_handler_cls=self.req_handler_cls,\n            proxy=getattr(self.args, 'proxy', None),\n            uvicorn_kwargs=getattr(self.args, 'uvicorn_kwargs', None),\n            ssl_keyfile=getattr(self.args, 'ssl_keyfile', None),\n            ssl_certfile=getattr(self.args, 'ssl_certfile', None),\n            cors=getattr(self.args, 'cors', None),\n            is_cancel=self.is_cancel,\n        )\n    elif (\n        hasattr(self.args, 'provider')\n        and self.args.provider == ProviderType.AZURE\n    ):\n        from jina.serve.runtimes.servers.http import AzureHTTPServer\n\n        return AzureHTTPServer(\n            name=self.args.name,\n            runtime_args=self.args,\n            req_handler_cls=self.req_handler_cls,\n            proxy=getattr(self.args, 'proxy', None),\n            uvicorn_kwargs=getattr(self.args, 'uvicorn_kwargs', None),\n            ssl_keyfile=getattr(self.args, 'ssl_keyfile', None),\n            ssl_certfile=getattr(self.args, 'ssl_certfile', None),\n            cors=getattr(self.args, 'cors', None),\n            is_cancel=self.is_cancel,\n        )\n    elif not hasattr(self.args, 'protocol') or (\n        len(self.args.protocol) == 1 and self.args.protocol[0] == ProtocolType.GRPC\n    ):\n        from jina.serve.runtimes.servers.grpc import GRPCServer\n\n        return GRPCServer(\n            name=self.args.name,\n            runtime_args=self.args,\n            req_handler_cls=self.req_handler_cls,\n            grpc_server_options=self.args.grpc_server_options,\n            ssl_keyfile=getattr(self.args, 'ssl_keyfile', None),\n            ssl_certfile=getattr(self.args, 'ssl_certfile', None),\n            proxy=getattr(self.args, 'proxy', None),\n        )\n\n    elif (\n        len(self.args.protocol) == 1 and self.args.protocol[0] == ProtocolType.HTTP\n    ):\n        from jina.serve.runtimes.servers.http import (\n            HTTPServer,  # we need a concrete implementation of this\n        )\n\n        return HTTPServer(\n            name=self.args.name,\n            runtime_args=self.args,\n            req_handler_cls=self.req_handler_cls,\n            proxy=getattr(self.args, 'proxy', None),\n            uvicorn_kwargs=getattr(self.args, 'uvicorn_kwargs', None),\n            ssl_keyfile=getattr(self.args, 'ssl_keyfile', None),\n            ssl_certfile=getattr(self.args, 'ssl_certfile', None),\n            cors=getattr(self.args, 'cors', None),\n            is_cancel=self.is_cancel,\n        )\n    elif (\n        len(self.args.protocol) == 1\n        and self.args.protocol[0] == ProtocolType.WEBSOCKET\n    ):\n        from jina.serve.runtimes.servers.websocket import (\n            WebSocketServer,  # we need a concrete implementation of this\n        )\n\n        return WebSocketServer(\n            name=self.args.name,\n            runtime_args=self.args,\n            req_handler_cls=self.req_handler_cls,\n            proxy=getattr(self.args, 'proxy', None),\n            uvicorn_kwargs=getattr(self.args, 'uvicorn_kwargs', None),\n            ssl_keyfile=getattr(self.args, 'ssl_keyfile', None),\n            ssl_certfile=getattr(self.args, 'ssl_certfile', None),\n            is_cancel=self.is_cancel,\n        )\n    elif len(self.args.protocol) > 1:\n        from jina.serve.runtimes.servers.composite import (\n            CompositeServer,  # we need a concrete implementation of this\n        )\n\n        return CompositeServer(\n            name=self.args.name,\n            runtime_args=self.args,\n            req_handler_cls=self.req_handler_cls,\n            ssl_keyfile=getattr(self.args, 'ssl_keyfile', None),\n            ssl_certfile=getattr(self.args, 'ssl_certfile', None),\n            is_cancel=self.is_cancel,\n        )",
          "triple_sequences": [
            {
              "action_api": "random_ports()",
              "action_description": "Generate random integer",
              "action_id": "generate_random_integer",
              "object": "len(self.args.protocol)",
              "object_description": "Thread function arguments",
              "object_id": "thread_arguments",
              "intention_description": "Generate random number",
              "intention_id": "generate_random_number"
            },
            {
              "action_api": "_set_gateway_uses()",
              "action_description": "Instantiates Setup class",
              "action_id": "init_setup_class",
              "object": "self.args, gateway_load_balancer=self.gateway_load_balancer",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Trigger main behavioral logic",
              "intention_id": "trigger_main_behavioral_logic"
            },
            {
              "action_api": "ArgNamespace.get_non_defaults_args()",
              "action_description": "Instantiates Setup class",
              "action_id": "init_setup_class",
              "object": "self.args, set_gateway_parser()",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "set_gateway_parser()",
              "action_description": "Instantiates Setup class",
              "action_id": "init_setup_class",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "BaseGateway.load_config()",
              "action_description": "Instantiates Setup class",
              "action_id": "init_setup_class",
              "object": "self.args.uses, uses_with=dict(**non_defaults, **uses_with,), uses_metas={}, runtime_args={**vars(self.args), 'default_port': getattr(self.args, 'default_port', False), 'gateway_load_balancer': self.gateway_load_balancer, 'timeout_send': self.timeout_send,}, py_modules=self.args.py_modules, extra_search_paths=self.args.extra_search_paths",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Trigger main behavioral logic",
              "intention_id": "trigger_main_behavioral_logic"
            },
            {
              "action_api": "isinstance()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "server, BaseServer",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "hasattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "self.args, 'provider'",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "getattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "self.args, 'proxy', None",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "getattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "self.args, 'uvicorn_kwargs', None",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "getattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "self.args, 'ssl_keyfile', None",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "getattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "self.args, 'ssl_certfile', None",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "getattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "self.args, 'cors', None",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            }
          ]
        }
      ]
    }
  ]
}