{
  "metadata": {
    "package_name": "nibabel-5",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/nibabel-5.3.2.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "parse_gifti_fast.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/nibabel-5.3.2/nibabel-5.3.2/nibabel/gifti/parse_gifti_fast.py",
      "line_number": "128",
      "type_description": "B801:b64decode",
      "context_snippet": "import base64\nimport zlib\nimport numpy as np\nfrom io import StringIO\nfrom .util import array_index_order_codes, gifti_encoding_codes, gifti_endian_codes\nfrom ..nifti1 import data_type_codes\n\ndef read_data_block(darray, fname, data, mmap):\n    \"\"\"Parses data from a <Data> element, or loads from an external file.\n\n    Parameters\n    ----------\n    darray : GiftiDataArray\n         GiftiDataArray object representing the parent <DataArray> of this\n         <Data> element\n\n    fname : str or None\n         Name of GIFTI file being loaded, or None if in-memory\n\n    data : str or None\n         Data to parse, or None if data is in an external file\n\n    mmap : {True, False, 'c', 'r', 'r+'}\n        Controls the use of numpy memory mapping for reading data.  Only has\n        an effect when loading GIFTI images with data stored in external files\n        (``DataArray`` elements with an ``Encoding`` equal to\n        ``ExternalFileBinary``).  If ``False``, do not try numpy ``memmap``\n        for data array.  If one of ``{'c', 'r', 'r+'}``, try numpy ``memmap``\n        with ``mode=mmap``.  A `mmap` value of ``True`` gives the same\n        behavior as ``mmap='c'``.  If the file cannot be memory-mapped, ignore\n        `mmap` value and read array from file.\n\n    Returns\n    -------\n    ``numpy.ndarray`` or ``numpy.memmap`` containing the parsed data\n    \"\"\"\n    if mmap not in (True, False, 'c', 'r', 'r+'):\n        raise ValueError(\"mmap value should be one of True, False, 'c', 'r', 'r+'\")\n    if mmap is True:\n        mmap = 'c'\n    enclabel = gifti_encoding_codes.label[darray.encoding]\n\n    if enclabel not in ('ASCII', 'B64BIN', 'B64GZ', 'External'):\n        raise GiftiParseError(f'Unknown encoding {darray.encoding}')\n\n    # Encode the endianness in the dtype\n    byteorder = gifti_endian_codes.byteorder[darray.endian]\n    dtype = data_type_codes.dtype[darray.datatype].newbyteorder(byteorder)\n\n    shape = tuple(darray.dims)\n    order = array_index_order_codes.npcode[darray.ind_ord]\n\n    # GIFTI_ENCODING_ASCII\n    if enclabel == 'ASCII':\n        return np.loadtxt(StringIO(data), dtype=dtype, ndmin=1).reshape(shape, order=order)\n\n    # We assume that the external data file is raw uncompressed binary, with\n    # the data type/endianness/ordering specified by the other DataArray\n    # attributes\n    if enclabel == 'External':\n        if fname is None:\n            raise GiftiParseError(\n                'ExternalFileBinary is not supported when loading from in-memory XML'\n            )\n        ext_fname = op.join(op.dirname(fname), darray.ext_fname)\n        if not op.exists(ext_fname):\n            raise GiftiParseError('Cannot locate external file ' + ext_fname)\n        # We either create a memmap, or load into memory\n        newarr = None\n        if mmap:\n            try:\n                return np.memmap(\n                    ext_fname,\n                    dtype=dtype,\n                    mode=mmap,\n                    offset=darray.ext_offset,\n                    shape=shape,\n                    order=order,\n                )\n            # If the memmap fails, we ignore the error and load the data into\n            # memory below\n            except (AttributeError, TypeError, ValueError):\n                pass\n        # mmap=False or np.memmap failed\n        if newarr is None:\n            return np.fromfile(\n                ext_fname,\n                dtype=dtype,\n                count=np.prod(darray.dims),\n                offset=darray.ext_offset,\n            ).reshape(shape, order=order)\n\n    # Numpy arrays created from bytes objects are read-only.\n    # Neither b64decode nor decompress will return bytearrays, and there\n    # are not equivalents to fobj.readinto to allow us to pass them, so\n    # there is not a simple way to avoid making copies.\n    # If this becomes a problem, we should write a decoding interface with\n    # a tunable chunk size.\n    dec = base64.b64decode(data.encode('ascii'))\n    if enclabel == 'B64BIN':\n        buff = bytearray(dec)\n    else:\n        # GIFTI_ENCODING_B64GZ\n        buff = bytearray(zlib.decompress(dec))\n    del dec\n    return np.frombuffer(buff, dtype=dtype).reshape(shape, order=order)",
      "hash_value": "5f6285cd9df35241b541fa33300ecc16",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "import base64\nimport zlib\nimport numpy as np\nfrom io import StringIO\nfrom .util import array_index_order_codes, gifti_encoding_codes, gifti_endian_codes\nfrom ..nifti1 import data_type_codes\n\ndef read_data_block(darray, fname, data, mmap):\n    \"\"\"Parses data from a <Data> element, or loads from an external file.\n\n    Parameters\n    ----------\n    darray : GiftiDataArray\n         GiftiDataArray object representing the parent <DataArray> of this\n         <Data> element\n\n    fname : str or None\n         Name of GIFTI file being loaded, or None if in-memory\n\n    data : str or None\n         Data to parse, or None if data is in an external file\n\n    mmap : {True, False, 'c', 'r', 'r+'}\n        Controls the use of numpy memory mapping for reading data.  Only has\n        an effect when loading GIFTI images with data stored in external files\n        (``DataArray`` elements with an ``Encoding`` equal to\n        ``ExternalFileBinary``).  If ``False``, do not try numpy ``memmap``\n        for data array.  If one of ``{'c', 'r', 'r+'}``, try numpy ``memmap``\n        with ``mode=mmap``.  A `mmap` value of ``True`` gives the same\n        behavior as ``mmap='c'``.  If the file cannot be memory-mapped, ignore\n        `mmap` value and read array from file.\n\n    Returns\n    -------\n    ``numpy.ndarray`` or ``numpy.memmap`` containing the parsed data\n    \"\"\"\n    if mmap not in (True, False, 'c', 'r', 'r+'):\n        raise ValueError(\"mmap value should be one of True, False, 'c', 'r', 'r+'\")\n    if mmap is True:\n        mmap = 'c'\n    enclabel = gifti_encoding_codes.label[darray.encoding]\n\n    if enclabel not in ('ASCII', 'B64BIN', 'B64GZ', 'External'):\n        raise GiftiParseError(f'Unknown encoding {darray.encoding}')\n\n    # Encode the endianness in the dtype\n    byteorder = gifti_endian_codes.byteorder[darray.endian]\n    dtype = data_type_codes.dtype[darray.datatype].newbyteorder(byteorder)\n\n    shape = tuple(darray.dims)\n    order = array_index_order_codes.npcode[darray.ind_ord]\n\n    # GIFTI_ENCODING_ASCII\n    if enclabel == 'ASCII':\n        return np.loadtxt(StringIO(data), dtype=dtype, ndmin=1).reshape(shape, order=order)\n\n    # We assume that the external data file is raw uncompressed binary, with\n    # the data type/endianness/ordering specified by the other DataArray\n    # attributes\n    if enclabel == 'External':\n        if fname is None:\n            raise GiftiParseError(\n                'ExternalFileBinary is not supported when loading from in-memory XML'\n            )\n        ext_fname = op.join(op.dirname(fname), darray.ext_fname)\n        if not op.exists(ext_fname):\n            raise GiftiParseError('Cannot locate external file ' + ext_fname)\n        # We either create a memmap, or load into memory\n        newarr = None\n        if mmap:\n            try:\n                return np.memmap(\n                    ext_fname,\n                    dtype=dtype,\n                    mode=mmap,\n                    offset=darray.ext_offset,\n                    shape=shape,\n                    order=order,\n                )\n            # If the memmap fails, we ignore the error and load the data into\n            # memory below\n            except (AttributeError, TypeError, ValueError):\n                pass\n        # mmap=False or np.memmap failed\n        if newarr is None:\n            return np.fromfile(\n                ext_fname,\n                dtype=dtype,\n                count=np.prod(darray.dims),\n                offset=darray.ext_offset,\n            ).reshape(shape, order=order)\n\n    # Numpy arrays created from bytes objects are read-only.\n    # Neither b64decode nor decompress will return bytearrays, and there\n    # are not equivalents to fobj.readinto to allow us to pass them, so\n    # there is not a simple way to avoid making copies.\n    # If this becomes a problem, we should write a decoding interface with\n    # a tunable chunk size.\n    dec = base64.b64decode(data.encode('ascii'))\n    if enclabel == 'B64BIN':\n        buff = bytearray(dec)\n    else:\n        # GIFTI_ENCODING_B64GZ\n        buff = bytearray(zlib.decompress(dec))\n    del dec\n    return np.frombuffer(buff, dtype=dtype).reshape(shape, order=order)",
          "triple_sequences": [
            {
              "action_api": "base64.b64decode()",
              "action_description": "Decodes base64-encoded string to bytes",
              "action_id": "decode_base64_to_bytes",
              "object": "data.encode('ascii')",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Decode base64 data",
              "intention_id": "decode_base64_data"
            },
            {
              "action_api": "zlib.decompress()",
              "action_description": "Decompresses zlib-compressed data",
              "action_id": "decompress_data_zlib",
              "object": "dec",
              "object_description": "Decompressed data",
              "object_id": "decompressed_data",
              "intention_description": "Decompress zlib data",
              "intention_id": "decompress_zlib_data"
            },
            {
              "action_api": "np.loadtxt()",
              "action_description": "Reads frame from video capture device",
              "action_id": "read_video_frame",
              "object": "StringIO(data)",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "np.memmap()",
              "action_description": "Creates temporary file that is not deleted on close",
              "action_id": "create_temp_file",
              "object": "ext_fname",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Create temporary file",
              "intention_id": "create_temporary_file"
            },
            {
              "action_api": "np.fromfile()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "ext_fname",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Open file for reading",
              "intention_id": "open_file_reading"
            },
            {
              "action_api": "np.frombuffer()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "buff",
              "object_description": "Decompressed data",
              "object_id": "decompressed_data",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            }
          ]
        }
      ]
    }
  ]
}