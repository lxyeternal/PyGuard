{
  "metadata": {
    "package_name": "crytic_compile-0",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/crytic_compile-0.3.8.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "etherscan.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/crytic_compile-0.3.8/crytic_compile-0.3.8/crytic_compile/platform/etherscan.py",
      "line_number": "342",
      "type_description": "B814:read",
      "context_snippet": "def compile(self, crytic_compile: \"CryticCompile\", **kwargs: str) -> None:\n    \"\"\"Run the compilation\n\n    Args:\n        crytic_compile (CryticCompile): Associated CryticCompile object\n        **kwargs: optional arguments. Used \"solc\", \"etherscan_only_source_code\", \"etherscan_only_bytecode\",\n            \"etherscan_api_key\", \"export_dir\"\n\n    Raises:\n        InvalidCompilation: if etherscan returned an error, or its results were not correctly parsed\n    \"\"\"\n\n    target = self._target\n\n    api_key_required = None\n\n    if target.startswith(tuple(SUPPORTED_NETWORK_V2)):\n        api_key_required = 2\n        prefix, addr = target.split(\":\", 2)\n        chainid, prefix_bytecode = SUPPORTED_NETWORK_V2[prefix]\n        etherscan_url = ETHERSCAN_BASE_V2 % (chainid, addr)\n        etherscan_bytecode_url = ETHERSCAN_BASE_BYTECODE % (prefix_bytecode, addr)\n    elif target.startswith(tuple(SUPPORTED_NETWORK_V1)):\n        api_key_required = 1\n        prefix = SUPPORTED_NETWORK_V1[target[: target.find(\":\") + 1]][0]\n        prefix_bytecode = SUPPORTED_NETWORK_V1[target[: target.find(\":\") + 1]][1]\n        addr = target[target.find(\":\") + 1 :]\n        etherscan_url = ETHERSCAN_BASE_V1 % (prefix, addr)\n        etherscan_bytecode_url = ETHERSCAN_BASE_BYTECODE % (prefix_bytecode, addr)\n    else:\n        api_key_required = 2\n        etherscan_url = ETHERSCAN_BASE_V2 % (\"1\", target)\n        etherscan_bytecode_url = ETHERSCAN_BASE_BYTECODE % (\"etherscan.io\", target)\n        addr = target\n        prefix = None\n\n    only_source = kwargs.get(\"etherscan_only_source_code\", False)\n    only_bytecode = kwargs.get(\"etherscan_only_bytecode\", False)\n\n    etherscan_api_key = kwargs.get(\"etherscan_api_key\", None)\n    if etherscan_api_key is None:\n        etherscan_api_key = os.getenv(\"ETHERSCAN_API_KEY\")\n\n    export_dir = kwargs.get(\"export_dir\", \"crytic-export\")\n    export_dir = os.path.join(\n        export_dir, kwargs.get(\"etherscan_export_dir\", \"etherscan-contracts\")\n    )\n\n    if api_key_required == 2 and etherscan_api_key:\n        etherscan_url += f\"&apikey={etherscan_api_key}\"\n        etherscan_bytecode_url += f\"&apikey={etherscan_api_key}\"\n    # API key handling for external tracers would be here e.g.\n    # elif api_key_required == 1 and avax_api_key and \"snowtrace\" in etherscan_url:\n    #    etherscan_url += f\"&apikey={avax_api_key}\"\n    #    etherscan_bytecode_url += f\"&apikey={avax_api_key}\"\n\n    source_code: str = \"\"\n    result: Dict[str, Union[bool, str, int]] = {}\n    contract_name: str = \"\"\n\n    if not only_bytecode:\n        # build object with headers, then send request\n        new_etherscan_url = urllib.request.Request(\n            etherscan_url,\n            headers={\n                \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.80 Safari/537.36 crytic-compile/0\"\n            },\n        )\n        with urllib.request.urlopen(new_etherscan_url) as response:\n            html = response.read()\n\n        info = json.loads(html)\n\n        if (\n            \"result\" in info\n            and \"rate limit reached\" in info[\"result\"]\n            and \"message\" in info\n            and info[\"message\"] == \"NOTOK\"\n        ):\n            LOGGER.error(\"Etherscan API rate limit exceeded\")\n            raise InvalidCompilation(\"Etherscan API rate limit exceeded\")\n\n        if \"message\" not in info:\n            LOGGER.error(\"Incorrect etherscan request\")\n            raise InvalidCompilation(\"Incorrect etherscan request \" + etherscan_url)\n\n        if not info[\"message\"].startswith(\"OK\") and \"Invalid API Key\" in info[\"result\"]:\n            LOGGER.error(\"Invalid etherscan API Key\")\n            raise InvalidCompilation(\"Invalid etherscan API Key: \" + etherscan_url)\n\n        if not info[\"message\"].startswith(\"OK\"):\n            LOGGER.error(\"Contract has no public source code\")\n            raise InvalidCompilation(\"Contract has no public source code: \" + etherscan_url)\n\n        if \"result\" not in info:\n            LOGGER.error(\"Contract has no public source code\")\n            raise InvalidCompilation(\"Contract has no public source code: \" + etherscan_url)\n\n        result = info[\"result\"][0]\n        # Assert to help mypy\n        assert isinstance(result[\"SourceCode\"], str)\n        assert isinstance(result[\"ContractName\"], str)\n        source_code = result[\"SourceCode\"]\n        contract_name = result[\"ContractName\"]\n\n    if source_code == \"\" and not only_source:\n        LOGGER.info(\"Source code not available, try to fetch the bytecode only\")\n\n        req = urllib.request.Request(\n            etherscan_bytecode_url, headers={\"User-Agent\": \"Mozilla/5.0\"}\n        )\n        with urllib.request.urlopen(req) as response:\n            html = response.read()\n\n        _handle_bytecode(crytic_compile, target, html)\n        return\n\n    if source_code == \"\":\n        LOGGER.error(\"Contract has no public source code\")\n        raise InvalidCompilation(\"Contract has no public source code: \" + etherscan_url)\n\n    if not os.path.exists(export_dir):\n        os.makedirs(export_dir)\n\n    # Assert to help mypy\n    assert isinstance(result[\"CompilerVersion\"], str)\n\n    compiler_version = re.findall(\n        r\"\\d+\\.\\d+\\.\\d+\", _convert_version(result[\"CompilerVersion\"])\n    )[0]\n\n    # etherscan can report \"default\" which is not a valid EVM version\n    evm_version: Optional[str] = None\n    if \"EVMVersion\" in result:\n        assert isinstance(result[\"EVMVersion\"], str)\n        evm_version = result[\"EVMVersion\"] if result[\"EVMVersion\"] != \"Default\" else None\n\n    optimization_used: bool = result[\"OptimizationUsed\"] == \"1\"\n\n    optimize_runs = None\n    if optimization_used:\n        optimize_runs = int(result[\"Runs\"])\n\n    working_dir: Optional[str] = None\n    remappings: Optional[List[str]] = None\n\n    dict_source_code: Optional[Dict] = None\n    try:\n        # etherscan might return an object with two curly braces, {{ content }}\n        dict_source_code = json.loads(source_code[1:-1])\n        assert isinstance(dict_source_code, dict)\n        filenames, working_dir, remappings = _handle_multiple_files(\n            dict_source_code, addr, prefix, contract_name, export_dir\n        )\n    except JSONDecodeError:\n        try:\n            # or etherscan might return an object with single curly braces, { content }\n            dict_source_code = json.loads(source_code)\n            assert isinstance(dict_source_code, dict)\n            filenames, working_dir, remappings = _handle_multiple_files(\n                dict_source_code, addr, prefix, contract_name, export_dir\n            )\n        except JSONDecodeError:\n            filenames = [\n                _handle_single_file(source_code, addr, prefix, contract_name, export_dir)\n            ]\n\n    # viaIR is not exposed on the top level JSON offered by etherscan, so we need to inspect the settings\n    via_ir_enabled: Optional[bool] = None\n    if isinstance(dict_source_code, dict):\n        via_ir_enabled = dict_source_code.get(\"settings\", {}).get(\"viaIR\", None)\n\n    compilation_unit = CompilationUnit(crytic_compile, contract_name)\n\n    compilation_unit.compiler_version = CompilerVersion(\n        compiler=kwargs.get(\"solc\", \"solc\"),\n        version=compiler_version,\n        optimized=optimization_used,\n        optimize_runs=optimize_runs,\n    )\n    compilation_unit.compiler_version.look_for_installed_version()\n\n    if \"Proxy\" in result and result[\"Proxy\"] == \"1\":\n        assert \"Implementation\" in result\n        implementation = str(result[\"Implementation\"])\n        if target.startswith(tuple(SUPPORTED_NETWORK)):\n            implementation = f\"{target[:target.find(':')]}:{implementation}\"\n        compilation_unit.implementation_address = implementation\n\n    solc_standard_json.standalone_compile(\n        filenames,\n        compilation_unit,\n        working_dir=working_dir,\n        remappings=remappings,\n        evm_version=evm_version,\n        via_ir=via_ir_enabled,\n    )\n\n    metadata_config = {\n        \"solc_remaps\": remappings if remappings else {},\n        \"solc_solcs_select\": compiler_version,\n        \"solc_args\": \" \".join(\n            filter(\n                None,\n                [\n                    \"--via-ir\" if via_ir_enabled else \"\",\n                    \"--optimize --optimize-runs \" + str(optimize_runs) if optimize_runs else \"\",\n                    \"--evm-version \" + evm_version if evm_version else \"\",\n                ],\n            )\n        ),\n    }\n\n    with open(\n        os.path.join(working_dir if working_dir else export_dir, \"crytic_compile.config.json\"),\n        \"w\",\n        encoding=\"utf-8\",\n    ) as f:\n        json.dump(metadata_config, f)\n",
      "hash_value": "ff37f8a871fed54c83230793d8c5b3db",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "def compile(self, crytic_compile: \"CryticCompile\", **kwargs: str) -> None:\n    \"\"\"Run the compilation\n\n    Args:\n        crytic_compile (CryticCompile): Associated CryticCompile object\n        **kwargs: optional arguments. Used \"solc\", \"etherscan_only_source_code\", \"etherscan_only_bytecode\",\n            \"etherscan_api_key\", \"export_dir\"\n\n    Raises:\n        InvalidCompilation: if etherscan returned an error, or its results were not correctly parsed\n    \"\"\"\n\n    target = self._target\n\n    api_key_required = None\n\n    if target.startswith(tuple(SUPPORTED_NETWORK_V2)):\n        api_key_required = 2\n        prefix, addr = target.split(\":\", 2)\n        chainid, prefix_bytecode = SUPPORTED_NETWORK_V2[prefix]\n        etherscan_url = ETHERSCAN_BASE_V2 % (chainid, addr)\n        etherscan_bytecode_url = ETHERSCAN_BASE_BYTECODE % (prefix_bytecode, addr)\n    elif target.startswith(tuple(SUPPORTED_NETWORK_V1)):\n        api_key_required = 1\n        prefix = SUPPORTED_NETWORK_V1[target[: target.find(\":\") + 1]][0]\n        prefix_bytecode = SUPPORTED_NETWORK_V1[target[: target.find(\":\") + 1]][1]\n        addr = target[target.find(\":\") + 1 :]\n        etherscan_url = ETHERSCAN_BASE_V1 % (prefix, addr)\n        etherscan_bytecode_url = ETHERSCAN_BASE_BYTECODE % (prefix_bytecode, addr)\n    else:\n        api_key_required = 2\n        etherscan_url = ETHERSCAN_BASE_V2 % (\"1\", target)\n        etherscan_bytecode_url = ETHERSCAN_BASE_BYTECODE % (\"etherscan.io\", target)\n        addr = target\n        prefix = None\n\n    only_source = kwargs.get(\"etherscan_only_source_code\", False)\n    only_bytecode = kwargs.get(\"etherscan_only_bytecode\", False)\n\n    etherscan_api_key = kwargs.get(\"etherscan_api_key\", None)\n    if etherscan_api_key is None:\n        etherscan_api_key = os.getenv(\"ETHERSCAN_API_KEY\")\n\n    export_dir = kwargs.get(\"export_dir\", \"crytic-export\")\n    export_dir = os.path.join(\n        export_dir, kwargs.get(\"etherscan_export_dir\", \"etherscan-contracts\")\n    )\n\n    if api_key_required == 2 and etherscan_api_key:\n        etherscan_url += f\"&apikey={etherscan_api_key}\"\n        etherscan_bytecode_url += f\"&apikey={etherscan_api_key}\"\n    # API key handling for external tracers would be here e.g.\n    # elif api_key_required == 1 and avax_api_key and \"snowtrace\" in etherscan_url:\n    #    etherscan_url += f\"&apikey={avax_api_key}\"\n    #    etherscan_bytecode_url += f\"&apikey={avax_api_key}\"\n\n    source_code: str = \"\"\n    result: Dict[str, Union[bool, str, int]] = {}\n    contract_name: str = \"\"\n\n    if not only_bytecode:\n        # build object with headers, then send request\n        new_etherscan_url = urllib.request.Request(\n            etherscan_url,\n            headers={\n                \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.80 Safari/537.36 crytic-compile/0\"\n            },\n        )\n        with urllib.request.urlopen(new_etherscan_url) as response:\n            html = response.read()\n\n        info = json.loads(html)\n\n        if (\n            \"result\" in info\n            and \"rate limit reached\" in info[\"result\"]\n            and \"message\" in info\n            and info[\"message\"] == \"NOTOK\"\n        ):\n            LOGGER.error(\"Etherscan API rate limit exceeded\")\n            raise InvalidCompilation(\"Etherscan API rate limit exceeded\")\n\n        if \"message\" not in info:\n            LOGGER.error(\"Incorrect etherscan request\")\n            raise InvalidCompilation(\"Incorrect etherscan request \" + etherscan_url)\n\n        if not info[\"message\"].startswith(\"OK\") and \"Invalid API Key\" in info[\"result\"]:\n            LOGGER.error(\"Invalid etherscan API Key\")\n            raise InvalidCompilation(\"Invalid etherscan API Key: \" + etherscan_url)\n\n        if not info[\"message\"].startswith(\"OK\"):\n            LOGGER.error(\"Contract has no public source code\")\n            raise InvalidCompilation(\"Contract has no public source code: \" + etherscan_url)\n\n        if \"result\" not in info:\n            LOGGER.error(\"Contract has no public source code\")\n            raise InvalidCompilation(\"Contract has no public source code: \" + etherscan_url)\n\n        result = info[\"result\"][0]\n        # Assert to help mypy\n        assert isinstance(result[\"SourceCode\"], str)\n        assert isinstance(result[\"ContractName\"], str)\n        source_code = result[\"SourceCode\"]\n        contract_name = result[\"ContractName\"]\n\n    if source_code == \"\" and not only_source:\n        LOGGER.info(\"Source code not available, try to fetch the bytecode only\")\n\n        req = urllib.request.Request(\n            etherscan_bytecode_url, headers={\"User-Agent\": \"Mozilla/5.0\"}\n        )\n        with urllib.request.urlopen(req) as response:\n            html = response.read()\n\n        _handle_bytecode(crytic_compile, target, html)\n        return\n\n    if source_code == \"\":\n        LOGGER.error(\"Contract has no public source code\")\n        raise InvalidCompilation(\"Contract has no public source code: \" + etherscan_url)\n\n    if not os.path.exists(export_dir):\n        os.makedirs(export_dir)\n\n    # Assert to help mypy\n    assert isinstance(result[\"CompilerVersion\"], str)\n\n    compiler_version = re.findall(\n        r\"\\d+\\.\\d+\\.\\d+\", _convert_version(result[\"CompilerVersion\"])\n    )[0]\n\n    # etherscan can report \"default\" which is not a valid EVM version\n    evm_version: Optional[str] = None\n    if \"EVMVersion\" in result:\n        assert isinstance(result[\"EVMVersion\"], str)\n        evm_version = result[\"EVMVersion\"] if result[\"EVMVersion\"] != \"Default\" else None\n\n    optimization_used: bool = result[\"OptimizationUsed\"] == \"1\"\n\n    optimize_runs = None\n    if optimization_used:\n        optimize_runs = int(result[\"Runs\"])\n\n    working_dir: Optional[str] = None\n    remappings: Optional[List[str]] = None\n\n    dict_source_code: Optional[Dict] = None\n    try:\n        # etherscan might return an object with two curly braces, {{ content }}\n        dict_source_code = json.loads(source_code[1:-1])\n        assert isinstance(dict_source_code, dict)\n        filenames, working_dir, remappings = _handle_multiple_files(\n            dict_source_code, addr, prefix, contract_name, export_dir\n        )\n    except JSONDecodeError:\n        try:\n            # or etherscan might return an object with single curly braces, { content }\n            dict_source_code = json.loads(source_code)\n            assert isinstance(dict_source_code, dict)\n            filenames, working_dir, remappings = _handle_multiple_files(\n                dict_source_code, addr, prefix, contract_name, export_dir\n            )\n        except JSONDecodeError:\n            filenames = [\n                _handle_single_file(source_code, addr, prefix, contract_name, export_dir)\n            ]\n\n    # viaIR is not exposed on the top level JSON offered by etherscan, so we need to inspect the settings\n    via_ir_enabled: Optional[bool] = None\n    if isinstance(dict_source_code, dict):\n        via_ir_enabled = dict_source_code.get(\"settings\", {}).get(\"viaIR\", None)\n\n    compilation_unit = CompilationUnit(crytic_compile, contract_name)\n\n    compilation_unit.compiler_version = CompilerVersion(\n        compiler=kwargs.get(\"solc\", \"solc\"),\n        version=compiler_version,\n        optimized=optimization_used,\n        optimize_runs=optimize_runs,\n    )\n    compilation_unit.compiler_version.look_for_installed_version()\n\n    if \"Proxy\" in result and result[\"Proxy\"] == \"1\":\n        assert \"Implementation\" in result\n        implementation = str(result[\"Implementation\"])\n        if target.startswith(tuple(SUPPORTED_NETWORK)):\n            implementation = f\"{target[:target.find(':')]}:{implementation}\"\n        compilation_unit.implementation_address = implementation\n\n    solc_standard_json.standalone_compile(\n        filenames,\n        compilation_unit,\n        working_dir=working_dir,\n        remappings=remappings,\n        evm_version=evm_version,\n        via_ir=via_ir_enabled,\n    )\n\n    metadata_config = {\n        \"solc_remaps\": remappings if remappings else {},\n        \"solc_solcs_select\": compiler_version,\n        \"solc_args\": \" \".join(\n            filter(\n                None,\n                [\n                    \"--via-ir\" if via_ir_enabled else \"\",\n                    \"--optimize --optimize-runs \" + str(optimize_runs) if optimize_runs else \"\",\n                    \"--evm-version \" + evm_version if evm_version else \"\",\n                ],\n            )\n        ),\n    }\n\n    with open(\n        os.path.join(working_dir if working_dir else export_dir, \"crytic_compile.config.json\"),\n        \"w\",\n        encoding=\"utf-8\",\n    ) as f:\n        json.dump(metadata_config, f)\n",
          "triple_sequences": [
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"ETHERSCAN_API_KEY\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.path.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "export_dir, kwargs.get(\"etherscan_export_dir\", \"etherscan-contracts\")",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Prepare directory path",
              "intention_id": "prepare_directory_path"
            },
            {
              "action_api": "urllib.request.Request()",
              "action_description": "Creates HTTP request object with specified URL, data, and headers",
              "action_id": "create_http_request",
              "object": "etherscan_url, headers={\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.80 Safari/537.36 crytic-compile/0\"}",
              "object_description": "Request object for external domain",
              "object_id": "request_external_domain",
              "intention_description": "Prepare URL for HTTP request",
              "intention_id": "prepare_url_http_request"
            },
            {
              "action_api": "urllib.request.urlopen()",
              "action_description": "Opens URL with GET parameters",
              "action_id": "open_url_get",
              "object": "new_etherscan_url",
              "object_description": "Request object for external domain",
              "object_id": "request_external_domain",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "response.read()",
              "action_description": "Reads all bytes from process standard output",
              "action_id": "read_process_stdout",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Decode downloaded content",
              "intention_id": "decode_downloaded_content"
            },
            {
              "action_api": "json.loads()",
              "action_description": "Deserializes JSON string to Python object",
              "action_id": "deserialize_from_json",
              "object": "html",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "export_dir",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "os.makedirs()",
              "action_description": "Creates directory, ignoring if it already exists",
              "action_id": "create_directory",
              "object": "export_dir",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Ensure directory exists",
              "intention_id": "ensure_directory_exists"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "r\"\\d+\\.\\d+\\.\\d+\", _convert_version(result[\"CompilerVersion\"])",
              "object_description": "Regex pattern",
              "object_id": "regex_pattern",
              "intention_description": "Prepare string processing",
              "intention_id": "prepare_string_processing"
            },
            {
              "action_api": "json.loads()",
              "action_description": "Deserializes JSON string to Python object",
              "action_id": "deserialize_from_json",
              "object": "source_code[1:-1]",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "json.loads()",
              "action_description": "Deserializes JSON string to Python object",
              "action_id": "deserialize_from_json",
              "object": "source_code",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "os.path.join(working_dir if working_dir else export_dir, \"crytic_compile.config.json\"), \"w\", encoding=\"utf-8\"",
              "object_description": "Script file path",
              "object_id": "script_file_path",
              "intention_description": "Prepare file for writing",
              "intention_id": "prepare_file_writing"
            },
            {
              "action_api": "json.dump()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "metadata_config, f",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Serialize data",
              "intention_id": "serialize_data"
            }
          ]
        }
      ]
    }
  ]
}