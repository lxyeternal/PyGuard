{
  "metadata": {
    "package_name": "pyshp-2",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/pyshp-2.3.1.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "shapefile.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyshp-2.3.1/pyshp-2.3.1/shapefile.py",
      "line_number": "2141",
      "type_description": "B815:write",
      "context_snippet": "def __shpRecord(self, s):\n    f = self.__getFileObj(self.shp)\n    offset = f.tell()\n    # Record number, Content length place holder\n    self.shpNum += 1\n    f.write(pack(\">2i\", self.shpNum, 0))\n    start = f.tell()\n    # Shape Type\n    if self.shapeType is None and s.shapeType != NULL:\n        self.shapeType = s.shapeType\n    if s.shapeType != NULL and s.shapeType != self.shapeType:\n        raise Exception(\"The shape's type (%s) must match the type of the shapefile (%s).\" % (s.shapeType, self.shapeType))\n    f.write(pack(\"<i\", s.shapeType))\n\n    # For point just update bbox of the whole shapefile\n    if s.shapeType in (1,11,21):\n        self.__bbox(s)\n    # All shape types capable of having a bounding box\n    if s.shapeType in (3,5,8,13,15,18,23,25,28,31):\n        try:\n            f.write(pack(\"<4d\", *self.__bbox(s)))\n        except error:\n            raise ShapefileException(\"Failed to write bounding box for record %s. Expected floats.\" % self.shpNum)\n    # Shape types with parts\n    if s.shapeType in (3,5,13,15,23,25,31):\n        # Number of parts\n        f.write(pack(\"<i\", len(s.parts)))\n    # Shape types with multiple points per record\n    if s.shapeType in (3,5,8,13,15,18,23,25,28,31):\n        # Number of points\n        f.write(pack(\"<i\", len(s.points)))\n    # Write part indexes\n    if s.shapeType in (3,5,13,15,23,25,31):\n        for p in s.parts:\n            f.write(pack(\"<i\", p))\n    # Part types for Multipatch (31)\n    if s.shapeType == 31:\n        for pt in s.partTypes:\n            f.write(pack(\"<i\", pt))\n    # Write points for multiple-point records\n    if s.shapeType in (3,5,8,13,15,18,23,25,28,31):\n        try:\n            [f.write(pack(\"<2d\", *p[:2])) for p in s.points]\n        except error:\n            raise ShapefileException(\"Failed to write points for record %s. Expected floats.\" % self.shpNum)\n    # Write z extremes and values\n    # Note: missing z values are autoset to 0, but not sure if this is ideal.\n    if s.shapeType in (13,15,18,31):\n        try:\n            f.write(pack(\"<2d\", *self.__zbox(s)))\n        except error:\n            raise ShapefileException(\"Failed to write elevation extremes for record %s. Expected floats.\" % self.shpNum)\n        try:\n            if hasattr(s,\"z\"):\n                # if z values are stored in attribute\n                f.write(pack(\"<%sd\" % len(s.z), *s.z))\n            else:\n                # if z values are stored as 3rd dimension\n                [f.write(pack(\"<d\", p[2] if len(p) > 2 else 0)) for p in s.points]  \n        except error:\n            raise ShapefileException(\"Failed to write elevation values for record %s. Expected floats.\" % self.shpNum)\n    # Write m extremes and values\n    # When reading a file, pyshp converts NODATA m values to None, so here we make sure to convert them back to NODATA\n    # Note: missing m values are autoset to NODATA.\n    if s.shapeType in (13,15,18,23,25,28,31):\n        try:\n            f.write(pack(\"<2d\", *self.__mbox(s)))\n        except error:\n            raise ShapefileException(\"Failed to write measure extremes for record %s. Expected floats\" % self.shpNum)\n        try:\n            if hasattr(s,\"m\"): \n                # if m values are stored in attribute\n                f.write(pack(\"<%sd\" % len(s.m), *[m if m is not None else NODATA for m in s.m]))\n            else:\n                # if m values are stored as 3rd/4th dimension\n                # 0-index position of m value is 3 if z type (x,y,z,m), or 2 if m type (x,y,m)\n                mpos = 3 if s.shapeType in (13,15,18,31) else 2\n                [f.write(pack(\"<d\", p[mpos] if len(p) > mpos and p[mpos] is not None else NODATA)) for p in s.points]\n        except error:\n            raise ShapefileException(\"Failed to write measure values for record %s. Expected floats\" % self.shpNum)\n    # Write a single point\n    if s.shapeType in (1,11,21):\n        try:\n            f.write(pack(\"<2d\", s.points[0][0], s.points[0][1]))\n        except error:\n            raise ShapefileException(\"Failed to write point for record %s. Expected floats.\" % self.shpNum)\n    # Write a single Z value\n    # Note: missing z values are autoset to 0, but not sure if this is ideal.\n    if s.shapeType == 11:\n        # update the global z box\n        self.__zbox(s)\n        # then write value\n        if hasattr(s, \"z\"):\n            # if z values are stored in attribute\n            try:\n                if not s.z:\n                    s.z = (0,)\n                f.write(pack(\"<d\", s.z[0]))\n            except error:\n                raise ShapefileException(\"Failed to write elevation value for record %s. Expected floats.\" % self.shpNum)\n        else:\n            # if z values are stored as 3rd dimension\n            try:\n                if len(s.points[0]) < 3:\n                    s.points[0].append(0)\n                f.write(pack(\"<d\", s.points[0][2]))\n            except error:\n                raise ShapefileException(\"Failed to write elevation value for record %s. Expected floats.\" % self.shpNum)\n    # Write a single M value\n    # Note: missing m values are autoset to NODATA.\n    if s.shapeType in (11,21):\n        # update the global m box\n        self.__mbox(s)\n        # then write value\n        if hasattr(s, \"m\"):\n            # if m values are stored in attribute\n            try:\n                if not s.m or s.m[0] is None:\n                    s.m = (NODATA,) \n                f.write(pack(\"<1d\", s.m[0]))\n            except error:\n                raise ShapefileException(\"Failed to write measure value for record %s. Expected floats.\" % self.shpNum)\n        else:\n            # if m values are stored as 3rd/4th dimension\n            # 0-index position of m value is 3 if z type (x,y,z,m), or 2 if m type (x,y,m)\n            try:\n                mpos = 3 if s.shapeType == 11 else 2\n                if len(s.points[0]) < mpos+1:\n                    s.points[0].append(NODATA)\n                elif s.points[0][mpos] is None:\n                    s.points[0][mpos] = NODATA\n                f.write(pack(\"<1d\", s.points[0][mpos]))\n            except error:\n                raise ShapefileException(\"Failed to write measure value for record %s. Expected floats.\" % self.shpNum)\n    # Finalize record length as 16-bit words\n    finish = f.tell()\n    length = (finish - start) // 2\n    # start - 4 bytes is the content length field\n    f.seek(start-4)\n    f.write(pack(\">i\", length))\n    f.seek(finish)\n    return offset,length",
      "hash_value": "c798c9fc02616af581d53edcd46fe206",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "def __shpRecord(self, s):\n    f = self.__getFileObj(self.shp)\n    offset = f.tell()\n    # Record number, Content length place holder\n    self.shpNum += 1\n    f.write(pack(\">2i\", self.shpNum, 0))\n    start = f.tell()\n    # Shape Type\n    if self.shapeType is None and s.shapeType != NULL:\n        self.shapeType = s.shapeType\n    if s.shapeType != NULL and s.shapeType != self.shapeType:\n        raise Exception(\"The shape's type (%s) must match the type of the shapefile (%s).\" % (s.shapeType, self.shapeType))\n    f.write(pack(\"<i\", s.shapeType))\n\n    # For point just update bbox of the whole shapefile\n    if s.shapeType in (1,11,21):\n        self.__bbox(s)\n    # All shape types capable of having a bounding box\n    if s.shapeType in (3,5,8,13,15,18,23,25,28,31):\n        try:\n            f.write(pack(\"<4d\", *self.__bbox(s)))\n        except error:\n            raise ShapefileException(\"Failed to write bounding box for record %s. Expected floats.\" % self.shpNum)\n    # Shape types with parts\n    if s.shapeType in (3,5,13,15,23,25,31):\n        # Number of parts\n        f.write(pack(\"<i\", len(s.parts)))\n    # Shape types with multiple points per record\n    if s.shapeType in (3,5,8,13,15,18,23,25,28,31):\n        # Number of points\n        f.write(pack(\"<i\", len(s.points)))\n    # Write part indexes\n    if s.shapeType in (3,5,13,15,23,25,31):\n        for p in s.parts:\n            f.write(pack(\"<i\", p))\n    # Part types for Multipatch (31)\n    if s.shapeType == 31:\n        for pt in s.partTypes:\n            f.write(pack(\"<i\", pt))\n    # Write points for multiple-point records\n    if s.shapeType in (3,5,8,13,15,18,23,25,28,31):\n        try:\n            [f.write(pack(\"<2d\", *p[:2])) for p in s.points]\n        except error:\n            raise ShapefileException(\"Failed to write points for record %s. Expected floats.\" % self.shpNum)\n    # Write z extremes and values\n    # Note: missing z values are autoset to 0, but not sure if this is ideal.\n    if s.shapeType in (13,15,18,31):\n        try:\n            f.write(pack(\"<2d\", *self.__zbox(s)))\n        except error:\n            raise ShapefileException(\"Failed to write elevation extremes for record %s. Expected floats.\" % self.shpNum)\n        try:\n            if hasattr(s,\"z\"):\n                # if z values are stored in attribute\n                f.write(pack(\"<%sd\" % len(s.z), *s.z))\n            else:\n                # if z values are stored as 3rd dimension\n                [f.write(pack(\"<d\", p[2] if len(p) > 2 else 0)) for p in s.points]  \n        except error:\n            raise ShapefileException(\"Failed to write elevation values for record %s. Expected floats.\" % self.shpNum)\n    # Write m extremes and values\n    # When reading a file, pyshp converts NODATA m values to None, so here we make sure to convert them back to NODATA\n    # Note: missing m values are autoset to NODATA.\n    if s.shapeType in (13,15,18,23,25,28,31):\n        try:\n            f.write(pack(\"<2d\", *self.__mbox(s)))\n        except error:\n            raise ShapefileException(\"Failed to write measure extremes for record %s. Expected floats\" % self.shpNum)\n        try:\n            if hasattr(s,\"m\"): \n                # if m values are stored in attribute\n                f.write(pack(\"<%sd\" % len(s.m), *[m if m is not None else NODATA for m in s.m]))\n            else:\n                # if m values are stored as 3rd/4th dimension\n                # 0-index position of m value is 3 if z type (x,y,z,m), or 2 if m type (x,y,m)\n                mpos = 3 if s.shapeType in (13,15,18,31) else 2\n                [f.write(pack(\"<d\", p[mpos] if len(p) > mpos and p[mpos] is not None else NODATA)) for p in s.points]\n        except error:\n            raise ShapefileException(\"Failed to write measure values for record %s. Expected floats\" % self.shpNum)\n    # Write a single point\n    if s.shapeType in (1,11,21):\n        try:\n            f.write(pack(\"<2d\", s.points[0][0], s.points[0][1]))\n        except error:\n            raise ShapefileException(\"Failed to write point for record %s. Expected floats.\" % self.shpNum)\n    # Write a single Z value\n    # Note: missing z values are autoset to 0, but not sure if this is ideal.\n    if s.shapeType == 11:\n        # update the global z box\n        self.__zbox(s)\n        # then write value\n        if hasattr(s, \"z\"):\n            # if z values are stored in attribute\n            try:\n                if not s.z:\n                    s.z = (0,)\n                f.write(pack(\"<d\", s.z[0]))\n            except error:\n                raise ShapefileException(\"Failed to write elevation value for record %s. Expected floats.\" % self.shpNum)\n        else:\n            # if z values are stored as 3rd dimension\n            try:\n                if len(s.points[0]) < 3:\n                    s.points[0].append(0)\n                f.write(pack(\"<d\", s.points[0][2]))\n            except error:\n                raise ShapefileException(\"Failed to write elevation value for record %s. Expected floats.\" % self.shpNum)\n    # Write a single M value\n    # Note: missing m values are autoset to NODATA.\n    if s.shapeType in (11,21):\n        # update the global m box\n        self.__mbox(s)\n        # then write value\n        if hasattr(s, \"m\"):\n            # if m values are stored in attribute\n            try:\n                if not s.m or s.m[0] is None:\n                    s.m = (NODATA,) \n                f.write(pack(\"<1d\", s.m[0]))\n            except error:\n                raise ShapefileException(\"Failed to write measure value for record %s. Expected floats.\" % self.shpNum)\n        else:\n            # if m values are stored as 3rd/4th dimension\n            # 0-index position of m value is 3 if z type (x,y,z,m), or 2 if m type (x,y,m)\n            try:\n                mpos = 3 if s.shapeType == 11 else 2\n                if len(s.points[0]) < mpos+1:\n                    s.points[0].append(NODATA)\n                elif s.points[0][mpos] is None:\n                    s.points[0][mpos] = NODATA\n                f.write(pack(\"<1d\", s.points[0][mpos]))\n            except error:\n                raise ShapefileException(\"Failed to write measure value for record %s. Expected floats.\" % self.shpNum)\n    # Finalize record length as 16-bit words\n    finish = f.tell()\n    length = (finish - start) // 2\n    # start - 4 bytes is the content length field\n    f.seek(start-4)\n    f.write(pack(\">i\", length))\n    f.seek(finish)\n    return offset,length",
          "triple_sequences": [
            {
              "action_api": "self.__getFileObj()",
              "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
              "action_id": "path_object_operations",
              "object": "self.shp",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Open file",
              "intention_id": "open_file"
            },
            {
              "action_api": "f.tell()",
              "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
              "action_id": "path_object_operations",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get file size",
              "intention_id": "get_file_size"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "pack(\">2i\", self.shpNum, 0)",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.tell()",
              "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
              "action_id": "path_object_operations",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get file size",
              "intention_id": "get_file_size"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "pack(\"<i\", s.shapeType)",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "self.__bbox()",
              "action_description": "Collect hardware information",
              "action_id": "collect_hardware_info",
              "object": "s",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "pack(\"<4d\", *self.__bbox(s))",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "pack(\"<i\", len(s.parts))",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "pack(\"<i\", len(s.points))",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "pack(\"<i\", p)",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "pack(\"<i\", pt)",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "pack(\"<2d\", *p[:2])",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "pack(\"<2d\", *self.__zbox(s))",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "pack(\"<%sd\" % len(s.z), *s.z)",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "pack(\"<d\", p[2] if len(p) > 2 else 0)",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "pack(\"<2d\", *self.__mbox(s))",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "pack(\"<%sd\" % len(s.m), *[m if m is not None else NODATA for m in s.m])",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "pack(\"<d\", p[mpos] if len(p) > mpos and p[mpos] is not None else NODATA)",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "pack(\"<2d\", s.points[0][0], s.points[0][1])",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "self.__zbox()",
              "action_description": "Collect hardware information",
              "action_id": "collect_hardware_info",
              "object": "s",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "pack(\"<d\", s.z[0])",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "pack(\"<d\", s.points[0][2])",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "self.__mbox()",
              "action_description": "Collect hardware information",
              "action_id": "collect_hardware_info",
              "object": "s",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "pack(\"<1d\", s.m[0])",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "pack(\"<1d\", s.points[0][mpos])",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.seek()",
              "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
              "action_id": "path_object_operations",
              "object": "start-4",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare file for writing",
              "intention_id": "prepare_file_writing"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "pack(\">i\", length)",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.seek()",
              "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
              "action_id": "path_object_operations",
              "object": "finish",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare file for writing",
              "intention_id": "prepare_file_writing"
            }
          ]
        }
      ]
    }
  ]
}