{
  "metadata": {
    "package_name": "aioredis-2",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/aioredis-2.0.1.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "connection.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/aioredis-2.0.1/aioredis-2.0.1/aioredis/connection.py",
      "line_number": "1416",
      "type_description": "B804:connect",
      "context_snippet": "async def get_connection(self, command_name, *keys, **options):\n    \"\"\"Get a connection from the pool\"\"\"\n    self._checkpid()\n    async with self._lock:\n        try:\n            connection = self._available_connections.pop()\n        except IndexError:\n            connection = self.make_connection()\n        self._in_use_connections.add(connection)\n\n    try:\n        # ensure this connection is connected to Redis\n        await connection.connect()\n        # connections that the pool provides should be ready to send\n        # a command. if not, the connection was either returned to the\n        # pool before all data has been read or the socket has been\n        # closed. either way, reconnect and verify everything is good.\n        try:\n            if await connection.can_read():\n                raise ConnectionError(\"Connection has data\") from None\n        except ConnectionError:\n            await connection.disconnect()\n            await connection.connect()\n            if await connection.can_read():\n                raise ConnectionError(\"Connection not ready\") from None\n    except BaseException:\n        # release the connection back to the pool so that we don't\n        # leak it\n        await self.release(connection)\n        raise\n\n    return connection",
      "hash_value": "4847852a1d66d6e9413e488c5067b871",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "async def get_connection(self, command_name, *keys, **options):\n    \"\"\"Get a connection from the pool\"\"\"\n    self._checkpid()\n    async with self._lock:\n        try:\n            connection = self._available_connections.pop()\n        except IndexError:\n            connection = self.make_connection()\n        self._in_use_connections.add(connection)\n\n    try:\n        # ensure this connection is connected to Redis\n        await connection.connect()\n        # connections that the pool provides should be ready to send\n        # a command. if not, the connection was either returned to the\n        # pool before all data has been read or the socket has been\n        # closed. either way, reconnect and verify everything is good.\n        try:\n            if await connection.can_read():\n                raise ConnectionError(\"Connection has data\") from None\n        except ConnectionError:\n            await connection.disconnect()\n            await connection.connect()\n            if await connection.can_read():\n                raise ConnectionError(\"Connection not ready\") from None\n    except BaseException:\n        # release the connection back to the pool so that we don't\n        # leak it\n        await self.release(connection)\n        raise\n\n    return connection",
          "triple_sequences": [
            {
              "action_api": "self._checkpid()",
              "action_description": "Checks if process has terminated",
              "action_id": "check_process_terminated",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine presence of required module",
              "intention_id": "determine_required_module_presence"
            },
            {
              "action_api": "self._lock.acquire()",
              "action_description": "Waits for events",
              "action_id": "wait_for_events",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for events",
              "intention_id": "wait_for_events"
            },
            {
              "action_api": "self._available_connections.pop()",
              "action_description": "Iterates over all running processes",
              "action_id": "iterate_processes",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Release system resource",
              "intention_id": "release_system_resource"
            },
            {
              "action_api": "self.make_connection()",
              "action_description": "Creates new socket object",
              "action_id": "create_socket",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Establish connection",
              "intention_id": "establish_connection"
            },
            {
              "action_api": "self._in_use_connections.add(connection)",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "connection",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "connection.connect()",
              "action_description": "Establishes TCP connection to specified address",
              "action_id": "establish_tcp_connection",
              "object": "connection",
              "object_description": "",
              "object_id": "",
              "intention_description": "Establish connection",
              "intention_id": "establish_connection"
            },
            {
              "action_api": "connection.can_read()",
              "action_description": "Receives data from socket connection",
              "action_id": "receive_socket_data",
              "object": "connection",
              "object_description": "",
              "object_id": "",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "connection.disconnect()",
              "action_description": "Disconnects from remote server",
              "action_id": "disconnect_remote_server",
              "object": "connection",
              "object_description": "",
              "object_id": "",
              "intention_description": "Disconnect from remote server",
              "intention_id": "disconnect_remote_server"
            },
            {
              "action_api": "self.release(connection)",
              "action_description": "Releases the socket connection",
              "action_id": "close_socket",
              "object": "connection",
              "object_description": "",
              "object_id": "",
              "intention_description": "Release connection resource",
              "intention_id": "release_connection_resource"
            }
          ]
        }
      ]
    }
  ]
}