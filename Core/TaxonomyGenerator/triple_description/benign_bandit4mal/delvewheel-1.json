{
  "metadata": {
    "package_name": "delvewheel-1",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/delvewheel-1.10.0.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "_wheel_repair.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/delvewheel-1.10.0/delvewheel-1.10.0/delvewheel/_wheel_repair.py",
      "line_number": "390",
      "type_description": "B832:write",
      "context_snippet": "def _patch_py_file(self, py_path: str, libs_dir: str, load_order_filename: typing.Optional[str], depth: int) -> None:\n    \"\"\"Given the path to a .py file, create or patch the file so that\n    vendored DLLs can be loaded at runtime. The patch is placed at the\n    topmost location after the shebang (if any), docstring or header\n    comments (if any), and any \"from __future__ import\" statements.\n\n    py_path is the path to the .py file to create or patch\n    libs_dir is the name of the directory where DLLs are stored.\n    load_order_filename is the name of the .load-order file, or None if the\n        file is not used\n    depth is the number of parent directories to traverse to reach the\n        site-packages directory at runtime starting from the directory\n        containing the .py file\"\"\"\n    print(f'patching {os.path.relpath(py_path, self._extract_dir)}')\n\n    py_name = os.path.basename(py_path)\n    if py_name.lower() == '__init__.py':\n        package_dir = os.path.dirname(os.path.relpath(py_path, self._extract_dir))\n        if os.path.isfile(py_path):\n            search = (\n                \"__path__=__import__('pkgutil').extend_path(__path__,__name__)\",\n                '__path__=__import__(\"pkgutil\").extend_path(__path__,__name__)',\n                \"__import__('pkg_resources').declare_namespace(__name__)\",\n                '__import__(\"pkg_resources\").declare_namespace(__name__)'\n            )\n            with open(py_path) as file:\n                for line in file:\n                    if line.rstrip().replace(' ', '') in search:\n                        warnings.warn(\n                            f'{package_dir} appears to be a namespace '\n                            f'package. If so, use the --namespace-pkg '\n                            f'option.')\n                        break\n        else:\n            warnings.warn(\n                f'{package_dir} does not contain __init__.py. If it is a '\n                f'namespace package, use the --namespace-pkg option. '\n                f'Otherwise, create an empty __init__.py file to silence '\n                f'this warning.')\n\n    open(py_path, 'a+').close()  # create file if it doesn't exist\n    with open(py_path, newline='') as file:\n        line = file.readline()\n    for newline in ('\\r\\n', '\\r', '\\n'):\n        if line.endswith(newline):\n            break\n    else:\n        newline = '\\r\\n'\n\n    with open(py_path) as file:\n        py_contents = file.read()\n    node = ast.parse(py_contents)\n    docstring = ast.get_docstring(node, False)\n    children = list(ast.iter_child_nodes(node))\n    for child in reversed(children):\n        if isinstance(child, ast.ImportFrom) and child.module == '__future__':\n            future_import_lineno = child.lineno\n            break\n    else:\n        future_import_lineno = 0  # no \"from __future__ import\" statement found\n\n    if future_import_lineno > 0:\n        # insert patch after the last __future__ import\n        patch_py_contents = self._patch_py_contents(False, libs_dir, load_order_filename, depth)\n        py_contents_split = py_contents.splitlines(True)\n        with open(py_path, 'w', newline=newline) as file:\n            file.write(''.join(py_contents_split[:future_import_lineno]).rstrip())\n            file.write('\\n\\n\\n')\n            file.write(patch_py_contents)\n            if remainder := ''.join(py_contents_split[future_import_lineno:]).lstrip():\n                file.write('\\n')\n                file.write(remainder)\n    elif docstring is not None:\n        # place patch just after docstring\n        patch_py_contents = self._patch_py_contents(False, libs_dir, load_order_filename, depth)\n        if len(children) == 0 or not isinstance(children[0], ast.Expr) or ast.literal_eval(children[0].value) != docstring:\n            # verify that the first child node is the docstring\n            raise ValueError(f'Error parsing {py_name}: docstring exists but is not the first element of the parse tree')\n        if len(children) == 1:\n            # append patch\n            with open(py_path, 'w', newline=newline) as file:\n                file.write(py_contents.rstrip())\n                file.write('\\n\\n\\n')\n                file.write(patch_py_contents)\n        else:\n            # insert patch after docstring\n            py_contents = '\\n'.join(py_contents.splitlines())  # normalize line endings\n            docstring_search_start_index = 0\n            for line in py_contents.splitlines(True):\n                if line.lstrip().startswith('#'):\n                    # ignore comments at start of file\n                    docstring_search_start_index += len(line)\n                else:\n                    break\n            pattern = (r'\"\"\"([^\\\\]|\\\\.)*?\"\"\"|'  # 3 double quotes\n                       r\"'''([^\\\\]|\\\\.)*?'''|\"  # 3 single quotes\n                       r'\"([^\\\\\\n]|\\\\.)*?\"|'  # 1 double quote\n                       r\"'([^\\\\\\n]|\\\\.)*?'\" )  # 1 single quote\n            if not (match := re.search(pattern, py_contents[docstring_search_start_index:], re.DOTALL)):\n                raise ValueError(f'Error parsing {py_name}: docstring exists but was not found')\n            docstring_end_index = docstring_search_start_index + match.end()\n            docstring_end_line = py_contents.find('\\n', docstring_end_index)\n            if docstring_end_line == -1:\n                docstring_end_line = len(py_contents)\n            if (extra_text := py_contents[docstring_end_index: docstring_end_line]) and not extra_text.isspace():\n                raise ValueError(f'Error parsing {py_name}: extra text {extra_text!r} is on the line where the docstring ends. Move the extra text to a new line and try again.')\n            with open(py_path, 'w', newline=newline) as file:\n                file.write(py_contents[:docstring_end_index].rstrip())\n                file.write('\\n\\n\\n')\n                file.write(patch_py_contents)\n                file.write('\\n')\n                file.write(py_contents[docstring_end_index:].lstrip())\n    else:\n        py_contents_lines = py_contents.splitlines()\n        start = 0\n        if py_contents_lines and py_contents_lines[0].startswith('#!'):\n            start = 1\n        while start < len(py_contents_lines) and py_contents_lines[start].strip() in ('', '#'):\n            start += 1\n        if start < len(py_contents_lines) and py_contents_lines[start][:1] == '#':\n            # insert patch after header comments\n            end = start + 1\n            while end < len(py_contents_lines) and py_contents_lines[end][:1] == '#':\n                end += 1\n            patch_py_contents = self._patch_py_contents(False, libs_dir, load_order_filename, depth)\n            with open(py_path, 'w', newline=newline) as file:\n                file.write('\\n'.join(py_contents_lines[:end]).rstrip())\n                file.write('\\n\\n\\n')\n                file.write(patch_py_contents)\n                if remainder := '\\n'.join(py_contents_lines[end:]).lstrip():\n                    file.write('\\n')\n                    file.write(remainder)\n                    if not remainder.endswith('\\n'):\n                        file.write('\\n')\n        elif py_contents_lines and py_contents_lines[0].startswith('#!'):\n            # insert patch after shebang\n            patch_py_contents = self._patch_py_contents(False, libs_dir, load_order_filename, depth)\n            with open(py_path, 'w', newline=newline) as file:\n                file.write(py_contents_lines[0].rstrip())\n                file.write('\\n\\n\\n')\n                file.write(patch_py_contents)\n                if remainder := '\\n'.join(py_contents_lines[1:]).lstrip():\n                    file.write('\\n')\n                    file.write(remainder)\n                    if not remainder.endswith('\\n'):\n                        file.write('\\n')\n        else:\n            # prepend patch\n            patch_py_contents = self._patch_py_contents(True, libs_dir, load_order_filename, depth)\n            with open(py_path, 'w', newline=newline) as file:\n                file.write(patch_py_contents)\n                if remainder := py_contents.lstrip():\n                    file.write('\\n')\n                    file.write(remainder)\n                    if not remainder.endswith('\\n'):\n                        file.write('\\n')\n\n    # verify that the file can be parsed properly\n    with open(py_path) as file:\n        try:\n            ast.parse(file.read())\n        except SyntaxError:\n            raise ValueError(f'Error parsing {py_name}: Patch failed. This might occur if a node is split across multiple lines.')",
      "hash_value": "40e2a8c1aac0b7aba2e280417474abcf",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "def _patch_py_file(self, py_path: str, libs_dir: str, load_order_filename: typing.Optional[str], depth: int) -> None:\n    \"\"\"Given the path to a .py file, create or patch the file so that\n    vendored DLLs can be loaded at runtime. The patch is placed at the\n    topmost location after the shebang (if any), docstring or header\n    comments (if any), and any \"from __future__ import\" statements.\n\n    py_path is the path to the .py file to create or patch\n    libs_dir is the name of the directory where DLLs are stored.\n    load_order_filename is the name of the .load-order file, or None if the\n        file is not used\n    depth is the number of parent directories to traverse to reach the\n        site-packages directory at runtime starting from the directory\n        containing the .py file\"\"\"\n    print(f'patching {os.path.relpath(py_path, self._extract_dir)}')\n\n    py_name = os.path.basename(py_path)\n    if py_name.lower() == '__init__.py':\n        package_dir = os.path.dirname(os.path.relpath(py_path, self._extract_dir))\n        if os.path.isfile(py_path):\n            search = (\n                \"__path__=__import__('pkgutil').extend_path(__path__,__name__)\",\n                '__path__=__import__(\"pkgutil\").extend_path(__path__,__name__)',\n                \"__import__('pkg_resources').declare_namespace(__name__)\",\n                '__import__(\"pkg_resources\").declare_namespace(__name__)'\n            )\n            with open(py_path) as file:\n                for line in file:\n                    if line.rstrip().replace(' ', '') in search:\n                        warnings.warn(\n                            f'{package_dir} appears to be a namespace '\n                            f'package. If so, use the --namespace-pkg '\n                            f'option.')\n                        break\n        else:\n            warnings.warn(\n                f'{package_dir} does not contain __init__.py. If it is a '\n                f'namespace package, use the --namespace-pkg option. '\n                f'Otherwise, create an empty __init__.py file to silence '\n                f'this warning.')\n\n    open(py_path, 'a+').close()  # create file if it doesn't exist\n    with open(py_path, newline='') as file:\n        line = file.readline()\n    for newline in ('\\r\\n', '\\r', '\\n'):\n        if line.endswith(newline):\n            break\n    else:\n        newline = '\\r\\n'\n\n    with open(py_path) as file:\n        py_contents = file.read()\n    node = ast.parse(py_contents)\n    docstring = ast.get_docstring(node, False)\n    children = list(ast.iter_child_nodes(node))\n    for child in reversed(children):\n        if isinstance(child, ast.ImportFrom) and child.module == '__future__':\n            future_import_lineno = child.lineno\n            break\n    else:\n        future_import_lineno = 0  # no \"from __future__ import\" statement found\n\n    if future_import_lineno > 0:\n        # insert patch after the last __future__ import\n        patch_py_contents = self._patch_py_contents(False, libs_dir, load_order_filename, depth)\n        py_contents_split = py_contents.splitlines(True)\n        with open(py_path, 'w', newline=newline) as file:\n            file.write(''.join(py_contents_split[:future_import_lineno]).rstrip())\n            file.write('\\n\\n\\n')\n            file.write(patch_py_contents)\n            if remainder := ''.join(py_contents_split[future_import_lineno:]).lstrip():\n                file.write('\\n')\n                file.write(remainder)\n    elif docstring is not None:\n        # place patch just after docstring\n        patch_py_contents = self._patch_py_contents(False, libs_dir, load_order_filename, depth)\n        if len(children) == 0 or not isinstance(children[0], ast.Expr) or ast.literal_eval(children[0].value) != docstring:\n            # verify that the first child node is the docstring\n            raise ValueError(f'Error parsing {py_name}: docstring exists but is not the first element of the parse tree')\n        if len(children) == 1:\n            # append patch\n            with open(py_path, 'w', newline=newline) as file:\n                file.write(py_contents.rstrip())\n                file.write('\\n\\n\\n')\n                file.write(patch_py_contents)\n        else:\n            # insert patch after docstring\n            py_contents = '\\n'.join(py_contents.splitlines())  # normalize line endings\n            docstring_search_start_index = 0\n            for line in py_contents.splitlines(True):\n                if line.lstrip().startswith('#'):\n                    # ignore comments at start of file\n                    docstring_search_start_index += len(line)\n                else:\n                    break\n            pattern = (r'\"\"\"([^\\\\]|\\\\.)*?\"\"\"|'  # 3 double quotes\n                       r\"'''([^\\\\]|\\\\.)*?'''|\"  # 3 single quotes\n                       r'\"([^\\\\\\n]|\\\\.)*?\"|'  # 1 double quote\n                       r\"'([^\\\\\\n]|\\\\.)*?'\" )  # 1 single quote\n            if not (match := re.search(pattern, py_contents[docstring_search_start_index:], re.DOTALL)):\n                raise ValueError(f'Error parsing {py_name}: docstring exists but was not found')\n            docstring_end_index = docstring_search_start_index + match.end()\n            docstring_end_line = py_contents.find('\\n', docstring_end_index)\n            if docstring_end_line == -1:\n                docstring_end_line = len(py_contents)\n            if (extra_text := py_contents[docstring_end_index: docstring_end_line]) and not extra_text.isspace():\n                raise ValueError(f'Error parsing {py_name}: extra text {extra_text!r} is on the line where the docstring ends. Move the extra text to a new line and try again.')\n            with open(py_path, 'w', newline=newline) as file:\n                file.write(py_contents[:docstring_end_index].rstrip())\n                file.write('\\n\\n\\n')\n                file.write(patch_py_contents)\n                file.write('\\n')\n                file.write(py_contents[docstring_end_index:].lstrip())\n    else:\n        py_contents_lines = py_contents.splitlines()\n        start = 0\n        if py_contents_lines and py_contents_lines[0].startswith('#!'):\n            start = 1\n        while start < len(py_contents_lines) and py_contents_lines[start].strip() in ('', '#'):\n            start += 1\n        if start < len(py_contents_lines) and py_contents_lines[start][:1] == '#':\n            # insert patch after header comments\n            end = start + 1\n            while end < len(py_contents_lines) and py_contents_lines[end][:1] == '#':\n                end += 1\n            patch_py_contents = self._patch_py_contents(False, libs_dir, load_order_filename, depth)\n            with open(py_path, 'w', newline=newline) as file:\n                file.write('\\n'.join(py_contents_lines[:end]).rstrip())\n                file.write('\\n\\n\\n')\n                file.write(patch_py_contents)\n                if remainder := '\\n'.join(py_contents_lines[end:]).lstrip():\n                    file.write('\\n')\n                    file.write(remainder)\n                    if not remainder.endswith('\\n'):\n                        file.write('\\n')\n        elif py_contents_lines and py_contents_lines[0].startswith('#!'):\n            # insert patch after shebang\n            patch_py_contents = self._patch_py_contents(False, libs_dir, load_order_filename, depth)\n            with open(py_path, 'w', newline=newline) as file:\n                file.write(py_contents_lines[0].rstrip())\n                file.write('\\n\\n\\n')\n                file.write(patch_py_contents)\n                if remainder := '\\n'.join(py_contents_lines[1:]).lstrip():\n                    file.write('\\n')\n                    file.write(remainder)\n                    if not remainder.endswith('\\n'):\n                        file.write('\\n')\n        else:\n            # prepend patch\n            patch_py_contents = self._patch_py_contents(True, libs_dir, load_order_filename, depth)\n            with open(py_path, 'w', newline=newline) as file:\n                file.write(patch_py_contents)\n                if remainder := py_contents.lstrip():\n                    file.write('\\n')\n                    file.write(remainder)\n                    if not remainder.endswith('\\n'):\n                        file.write('\\n')\n\n    # verify that the file can be parsed properly\n    with open(py_path) as file:\n        try:\n            ast.parse(file.read())\n        except SyntaxError:\n            raise ValueError(f'Error parsing {py_name}: Patch failed. This might occur if a node is split across multiple lines.')",
          "triple_sequences": [
            {
              "action_api": "os.path.relpath()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "py_path, self._extract_dir",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            },
            {
              "action_api": "os.path.basename()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "py_path",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Extract executable name",
              "intention_id": "extract_executable_name"
            },
            {
              "action_api": "os.path.dirname()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "os.path.relpath(py_path, self._extract_dir)",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            },
            {
              "action_api": "os.path.isfile()",
              "action_description": "Checks if specified path exists and is a file",
              "action_id": "check_file_is_file",
              "object": "py_path",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Determine file presence",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "py_path",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Open file for reading",
              "intention_id": "open_file_reading"
            },
            {
              "action_api": "file.readline()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "py_path",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Open file for reading",
              "intention_id": "open_file_reading"
            },
            {
              "action_api": "file.read()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "ast.parse()",
              "action_description": "Compiles source code string into executable code object",
              "action_id": "compile_code_object",
              "object": "py_contents",
              "object_description": "Script file content",
              "object_id": "script_file_content",
              "intention_description": "Evaluate constructed code",
              "intention_id": "evaluate_constructed_code"
            },
            {
              "action_api": "ast.get_docstring()",
              "action_description": "Compiles source code string into executable code object",
              "action_id": "compile_code_object",
              "object": "node, False",
              "object_description": "Compiled Python code",
              "object_id": "compiled_python_code",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "ast.iter_child_nodes()",
              "action_description": "Compiles source code string into executable code object",
              "action_id": "compile_code_object",
              "object": "node",
              "object_description": "Compiled Python code",
              "object_id": "compiled_python_code",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "isinstance()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "child, ast.ImportFrom",
              "object_description": "Exception type name",
              "object_id": "exception_type",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "py_path, 'w', newline=newline",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Open file for writing",
              "intention_id": "open_file_writing"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "''.join(py_contents_split[:future_import_lineno]).rstrip()",
              "object_description": "Script file content",
              "object_id": "script_file_content",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "'\\n\\n\\n'",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "patch_py_contents",
              "object_description": "Script file content",
              "object_id": "script_file_content",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "'\\n'",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "remainder",
              "object_description": "Script file content",
              "object_id": "script_file_content",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "py_path, 'a+'",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Open file for writing",
              "intention_id": "open_file_writing"
            },
            {
              "action_api": "file.close()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close file",
              "intention_id": "close_file"
            },
            {
              "action_api": "re.search()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "pattern, py_contents[docstring_search_start_index:], re.DOTALL",
              "object_description": "Regex file content",
              "object_id": "regex_file_content",
              "intention_description": "Browser profile detection preparation",
              "intention_id": "browser_profile_detection_preparation"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "py_path, 'w', newline=newline",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Open file for writing",
              "intention_id": "open_file_writing"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "py_contents[:docstring_end_index].rstrip()",
              "object_description": "Script file content",
              "object_id": "script_file_content",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "'\\n\\n\\n'",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "patch_py_contents",
              "object_description": "Script file content",
              "object_id": "script_file_content",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "'\\n'",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "py_contents[docstring_end_index:].lstrip()",
              "object_description": "Script file content",
              "object_id": "script_file_content",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "py_path, 'w', newline=newline",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Open file for writing",
              "intention_id": "open_file_writing"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "'\\n'.join(py_contents_lines[:end]).rstrip()",
              "object_description": "Script file content",
              "object_id": "script_file_content",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "'\\n\\n\\n'",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "patch_py_contents",
              "object_description": "Script file content",
              "object_id": "script_file_content",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "'\\n'",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "remainder",
              "object_description": "Script file content",
              "object_id": "script_file_content",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "py_path, 'w', newline=newline",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Open file for writing",
              "intention_id": "open_file_writing"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "py_contents_lines[0].rstrip()",
              "object_description": "Script file content",
              "object_id": "script_file_content",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "'\\n\\n\\n'",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "patch_py_contents",
              "object_description": "Script file content",
              "object_id": "script_file_content",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "'\\n'",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "remainder",
              "object_description": "Script file content",
              "object_id": "script_file_content",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "py_path, 'w', newline=newline",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Open file for writing",
              "intention_id": "open_file_writing"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "patch_py_contents",
              "object_description": "Script file content",
              "object_id": "script_file_content",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "'\\n'",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "remainder",
              "object_description": "Script file content",
              "object_id": "script_file_content",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "py_path",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Open file for reading",
              "intention_id": "open_file_reading"
            },
            {
              "action_api": "file.read()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "ast.parse()",
              "action_description": "Compiles source code string into executable code object",
              "action_id": "compile_code_object",
              "object": "file.read()",
              "object_description": "Script file content",
              "object_id": "script_file_content",
              "intention_description": "Evaluate constructed code",
              "intention_id": "evaluate_constructed_code"
            }
          ]
        }
      ]
    }
  ]
}