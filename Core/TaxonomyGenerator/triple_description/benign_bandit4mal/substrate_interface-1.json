{
  "metadata": {
    "package_name": "substrate_interface-1",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/substrate_interface-1.8.0a0-py3-none-any.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "base.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/substrate_interface-1.8.0a0-py3-none-any/substrateinterface/base.py",
      "line_number": "709",
      "type_description": "B820:get",
      "context_snippet": "def init_runtime(self, block_hash=None, block_id=None):\n    \"\"\"\n    This method is used by all other methods that deals with metadata and types defined in the type registry.\n    It optionally retrieves the block_hash when block_id is given and sets the applicable metadata for that\n    block_hash. Also it applies all the versioned types at the time of the block_hash.\n\n    Because parsing of metadata and type registry is quite heavy, the result will be cached per runtime id.\n    In the future there could be support for caching backends like Redis to make this cache more persistent.\n\n    Parameters\n    ----------\n    block_hash\n    block_id\n\n    Returns\n    -------\n\n    \"\"\"\n\n    if block_id and block_hash:\n        raise ValueError('Cannot provide block_hash and block_id at the same time')\n\n    # Check if runtime state already set to current block\n    if (block_hash and block_hash == self.block_hash) or (block_id and block_id == self.block_id):\n        return\n\n    if block_id is not None:\n        block_hash = self.get_block_hash(block_id)\n\n    if not block_hash:\n        block_hash = self.get_chain_head()\n\n    self.block_hash = block_hash\n    self.block_id = block_id\n\n    # In fact calls and storage functions are decoded against runtime of previous block, therefor retrieve\n    # metadata and apply type registry of runtime of parent block\n    block_header = self.rpc_request('chain_getHeader', [self.block_hash])\n\n    if block_header['result'] is None:\n        raise BlockNotFound(f'Block not found for \"{self.block_hash}\"')\n\n    parent_block_hash = block_header['result']['parentHash']\n\n    if parent_block_hash == '0x0000000000000000000000000000000000000000000000000000000000000000':\n        runtime_block_hash = self.block_hash\n    else:\n        runtime_block_hash = parent_block_hash\n\n    runtime_info = self.get_block_runtime_version(block_hash=runtime_block_hash)\n\n    if runtime_info is None:\n        raise SubstrateRequestException(f\"No runtime information for block '{block_hash}'\")\n\n    # Check if runtime state already set to current block\n    if runtime_info.get(\"specVersion\") == self.runtime_version:\n        return\n\n    self.runtime_version = runtime_info.get(\"specVersion\")\n    self.transaction_version = runtime_info.get(\"transactionVersion\")\n\n    if self.cache_region and self.runtime_version not in self.__metadata_cache:\n        # Try to retrieve metadata from Dogpile cache\n        cached_metadata = self.cache_region.get('METADATA_{}'.format(self.runtime_version))\n        if cached_metadata:\n            self.debug_message('Retrieved metadata for {} from Redis'.format(self.runtime_version))\n            self.__metadata_cache[self.runtime_version] = cached_metadata\n\n    if self.runtime_version in self.__metadata_cache:\n        # Get metadata from cache\n        self.debug_message('Retrieved metadata for {} from memory'.format(self.runtime_version))\n        self.metadata = self.__metadata_cache[self.runtime_version]\n    else:\n        self.metadata = self.get_block_metadata(block_hash=runtime_block_hash, decode=True)\n        self.debug_message('Retrieved metadata for {} from Substrate node'.format(self.runtime_version))\n\n        # Update metadata cache\n        self.__metadata_cache[self.runtime_version] = self.metadata\n\n        if self.cache_region:\n            self.debug_message('Stored metadata for {} in Redis'.format(self.runtime_version))\n            self.cache_region.set('METADATA_{}'.format(self.runtime_version), self.metadata)\n\n    # Update type registry\n    self.reload_type_registry(\n        use_remote_preset=self.config.get('use_remote_preset'),\n        auto_discover=self.config.get('auto_discover')\n    )\n\n    # Check if PortableRegistry is present in metadata (V14+), otherwise fall back on legacy type registry (<V14)\n    if self.implements_scaleinfo():\n        self.debug_message('Add PortableRegistry from metadata to type registry')\n        self.runtime_config.add_portable_registry(self.metadata)\n\n    # Set active runtime version\n    self.runtime_config.set_active_spec_version_id(self.runtime_version)\n\n    # Check and apply runtime constants\n    ss58_prefix_constant = self.get_constant(\"System\", \"SS58Prefix\", block_hash=block_hash)\n\n    if ss58_prefix_constant:\n        self.ss58_format = ss58_prefix_constant.value\n\n    # Set runtime compatibility flags\n    try:\n        _ = self.runtime_config.create_scale_object(\"sp_weights::weight_v2::Weight\")\n        self.config['is_weight_v2'] = True\n        self.runtime_config.update_type_registry_types({'Weight': 'sp_weights::weight_v2::Weight'})\n    except NotImplementedError:\n        self.config['is_weight_v2'] = False\n        self.runtime_config.update_type_registry_types({'Weight': 'WeightV1'})",
      "hash_value": "be120f681ff4c0e49f752a577d80e0c0",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "def init_runtime(self, block_hash=None, block_id=None):\n    \"\"\"\n    This method is used by all other methods that deals with metadata and types defined in the type registry.\n    It optionally retrieves the block_hash when block_id is given and sets the applicable metadata for that\n    block_hash. Also it applies all the versioned types at the time of the block_hash.\n\n    Because parsing of metadata and type registry is quite heavy, the result will be cached per runtime id.\n    In the future there could be support for caching backends like Redis to make this cache more persistent.\n\n    Parameters\n    ----------\n    block_hash\n    block_id\n\n    Returns\n    -------\n\n    \"\"\"\n\n    if block_id and block_hash:\n        raise ValueError('Cannot provide block_hash and block_id at the same time')\n\n    # Check if runtime state already set to current block\n    if (block_hash and block_hash == self.block_hash) or (block_id and block_id == self.block_id):\n        return\n\n    if block_id is not None:\n        block_hash = self.get_block_hash(block_id)\n\n    if not block_hash:\n        block_hash = self.get_chain_head()\n\n    self.block_hash = block_hash\n    self.block_id = block_id\n\n    # In fact calls and storage functions are decoded against runtime of previous block, therefor retrieve\n    # metadata and apply type registry of runtime of parent block\n    block_header = self.rpc_request('chain_getHeader', [self.block_hash])\n\n    if block_header['result'] is None:\n        raise BlockNotFound(f'Block not found for \"{self.block_hash}\"')\n\n    parent_block_hash = block_header['result']['parentHash']\n\n    if parent_block_hash == '0x0000000000000000000000000000000000000000000000000000000000000000':\n        runtime_block_hash = self.block_hash\n    else:\n        runtime_block_hash = parent_block_hash\n\n    runtime_info = self.get_block_runtime_version(block_hash=runtime_block_hash)\n\n    if runtime_info is None:\n        raise SubstrateRequestException(f\"No runtime information for block '{block_hash}'\")\n\n    # Check if runtime state already set to current block\n    if runtime_info.get(\"specVersion\") == self.runtime_version:\n        return\n\n    self.runtime_version = runtime_info.get(\"specVersion\")\n    self.transaction_version = runtime_info.get(\"transactionVersion\")\n\n    if self.cache_region and self.runtime_version not in self.__metadata_cache:\n        # Try to retrieve metadata from Dogpile cache\n        cached_metadata = self.cache_region.get('METADATA_{}'.format(self.runtime_version))\n        if cached_metadata:\n            self.debug_message('Retrieved metadata for {} from Redis'.format(self.runtime_version))\n            self.__metadata_cache[self.runtime_version] = cached_metadata\n\n    if self.runtime_version in self.__metadata_cache:\n        # Get metadata from cache\n        self.debug_message('Retrieved metadata for {} from memory'.format(self.runtime_version))\n        self.metadata = self.__metadata_cache[self.runtime_version]\n    else:\n        self.metadata = self.get_block_metadata(block_hash=runtime_block_hash, decode=True)\n        self.debug_message('Retrieved metadata for {} from Substrate node'.format(self.runtime_version))\n\n        # Update metadata cache\n        self.__metadata_cache[self.runtime_version] = self.metadata\n\n        if self.cache_region:\n            self.debug_message('Stored metadata for {} in Redis'.format(self.runtime_version))\n            self.cache_region.set('METADATA_{}'.format(self.runtime_version), self.metadata)\n\n    # Update type registry\n    self.reload_type_registry(\n        use_remote_preset=self.config.get('use_remote_preset'),\n        auto_discover=self.config.get('auto_discover')\n    )\n\n    # Check if PortableRegistry is present in metadata (V14+), otherwise fall back on legacy type registry (<V14)\n    if self.implements_scaleinfo():\n        self.debug_message('Add PortableRegistry from metadata to type registry')\n        self.runtime_config.add_portable_registry(self.metadata)\n\n    # Set active runtime version\n    self.runtime_config.set_active_spec_version_id(self.runtime_version)\n\n    # Check and apply runtime constants\n    ss58_prefix_constant = self.get_constant(\"System\", \"SS58Prefix\", block_hash=block_hash)\n\n    if ss58_prefix_constant:\n        self.ss58_format = ss58_prefix_constant.value\n\n    # Set runtime compatibility flags\n    try:\n        _ = self.runtime_config.create_scale_object(\"sp_weights::weight_v2::Weight\")\n        self.config['is_weight_v2'] = True\n        self.runtime_config.update_type_registry_types({'Weight': 'sp_weights::weight_v2::Weight'})\n    except NotImplementedError:\n        self.config['is_weight_v2'] = False\n        self.runtime_config.update_type_registry_types({'Weight': 'WeightV1'})",
          "triple_sequences": [
            {
              "action_api": "self.get_block_hash()",
              "action_description": "Retrieves value and data type for registry value",
              "action_id": "get_registry_value",
              "object": "block_id",
              "object_description": "Process ID",
              "object_id": "process_id",
              "intention_description": "Extract structured file data",
              "intention_id": "extract_structured_file_data"
            },
            {
              "action_api": "self.get_chain_head()",
              "action_description": "Retrieves value and data type for registry value",
              "action_id": "get_registry_value",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Extract_structured_file_data",
              "intention_id": "extract_structured_file_data"
            },
            {
              "action_api": "self.rpc_request()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "'chain_getHeader', [self.block_hash]",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "self.get_block_runtime_version()",
              "action_description": "Retrieves value and data type for registry value",
              "action_id": "get_registry_value",
              "object": "block_hash=runtime_block_hash",
              "object_description": "Process ID",
              "object_id": "process_id",
              "intention_description": "Extract structured file data",
              "intention_id": "extract_structured_file_data"
            },
            {
              "action_api": "self.cache_region.get()",
              "action_description": "Retrieves value and data type for registry value",
              "action_id": "get_registry_value",
              "object": "'METADATA_{}'.format(self.runtime_version)",
              "object_description": "Registry value name",
              "object_id": "registry_value_name",
              "intention_description": "Access_registry_value",
              "intention_id": "access_registry_value"
            },
            {
              "action_api": "self.debug_message()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "'Retrieved metadata for {} from Redis'.format(self.runtime_version)",
              "object_description": "Log level",
              "object_id": "log_level",
              "intention_description": "Access_attribute_value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "self.get_block_metadata()",
              "action_description": "Retrieves value and data type for registry value",
              "action_id": "get_registry_value",
              "object": "block_hash=runtime_block_hash, decode=True",
              "object_description": "Process ID",
              "object_id": "process_id",
              "intention_description": "Extract_structured_file_data",
              "intention_id": "extract_structured_file_data"
            },
            {
              "action_api": "self.debug_message()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "'Retrieved metadata for {} from Substrate node'.format(self.runtime_version)",
              "object_description": "Log level",
              "object_id": "log_level",
              "intention_description": "Access_attribute_value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "self.cache_region.set()",
              "action_description": "Sets value for registry key",
              "action_id": "set_registry_value",
              "object": "'METADATA_{}'.format(self.runtime_version), self.metadata",
              "object_description": "Registry value",
              "object_id": "registry_value",
              "intention_description": "Access_registry_value",
              "intention_id": "access_registry_value"
            },
            {
              "action_api": "self.reload_type_registry()",
              "action_description": "Instantiates WMI interface for system management",
              "action_id": "instantiate_wmi",
              "object": "use_remote_preset=self.config.get('use_remote_preset'), auto_discover=self.config.get('auto_discover')",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Access_configuration_value",
              "intention_id": "access_configuration_value"
            },
            {
              "action_api": "self.implements_scaleinfo()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine_required_module_presence",
              "intention_id": "determine_required_module_presence"
            },
            {
              "action_api": "self.runtime_config.add_portable_registry()",
              "action_description": "Sets value for registry key",
              "action_id": "set_registry_value",
              "object": "self.metadata",
              "object_description": "Structured_file_data",
              "object_id": "structured_file_data",
              "intention_description": "Access_registry_value",
              "intention_id": "access_registry_value"
            },
            {
              "action_api": "self.runtime_config.set_active_spec_version_id()",
              "action_description": "Sets value for registry key",
              "action_id": "set_registry_value",
              "object": "self.runtime_version",
              "object_description": "Registry value",
              "object_id": "registry_value",
              "intention_description": "Access_registry_value",
              "intention_id": "access_registry_value"
            },
            {
              "action_api": "self.get_constant()",
              "action_description": "Retrieves value and data type for registry value",
              "action_id": "get_registry_value",
              "object": "\"System\", \"SS58Prefix\", block_hash=block_hash",
              "object_description": "Registry value name",
              "object_id": "registry_value_name",
              "intention_description": "Access_registry_value",
              "intention_id": "access_registry_value"
            },
            {
              "action_api": "self.runtime_config.create_scale_object()",
              "action_description": "Creates new socket object",
              "action_id": "create_socket",
              "object": "\"sp_weights::weight_v2::Weight\"",
              "object_description": "Module name string",
              "object_id": "module_name_string",
              "intention_description": "Access_attribute_value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "self.runtime_config.update_type_registry_types()",
              "action_description": "Sets value for registry key",
              "action_id": "set_registry_value",
              "object": "{'Weight': 'sp_weights::weight_v2::Weight'}",
              "object_description": "Registry value",
              "object_id": "registry_value",
              "intention_description": "Access_registry_value",
              "intention_id": "access_registry_value"
            },
            {
              "action_api": "self.runtime_config.update_type_registry_types()",
              "action_description": "Sets value for registry key",
              "action_id": "set_registry_value",
              "object": "{'Weight': 'WeightV1'}",
              "object_description": "Registry value",
              "object_id": "registry_value",
              "intention_description": "Access_registry_value",
              "intention_id": "access_registry_value"
            }
          ]
        }
      ]
    }
  ]
}