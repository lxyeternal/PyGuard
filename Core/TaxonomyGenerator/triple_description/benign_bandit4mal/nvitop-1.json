{
  "metadata": {
    "package_name": "nvitop-1",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/nvitop-1.4.2.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "libcuda.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/nvitop-1.4.2/nvitop-1.4.2/nvitop/api/libcuda.py",
      "line_number": "428",
      "type_description": "B841:cdll",
      "context_snippet": "def __LoadCudaLibrary() -> None:\n    \"\"\"Load the library if it isn't loaded already.\n\n    Raises:\n        CUDAError_NotInitialized:\n            If cannot found the CUDA driver library.\n    \"\"\"\n    global __cudaLib  # pylint: disable=global-statement\n\n    if __cudaLib is None:\n        # Lock to ensure only one caller loads the library\n        with __libLoadLock:\n            # Ensure the library still isn't loaded\n            if __cudaLib is None:\n                # Platform specific libcuda location\n                system = _platform.system()\n                if system == 'Darwin':\n                    lib_filenames = [\n                        'libcuda.1.dylib',  # check library path first\n                        'libcuda.dylib',\n                        '/usr/local/cuda/lib/libcuda.1.dylib',\n                        '/usr/local/cuda/lib/libcuda.dylib',\n                    ]\n                elif system == 'Linux':\n                    lib_filenames = [\n                        'libcuda.so',  # check library path first\n                        '/usr/lib64/nvidia/libcuda.so',  # Redhat/CentOS/Fedora\n                        '/usr/lib/x86_64-linux-gnu/libcuda.so',  # Ubuntu\n                        '/usr/lib/wsl/lib/libcuda.so',  # WSL\n                    ]\n                    # Also add libraries with version suffix `.1`\n                    lib_filenames = list(\n                        _itertools.chain.from_iterable((f'{lib}.1', lib) for lib in lib_filenames),\n                    )\n                elif system == 'Windows':\n                    bits = 8 * _ctypes.sizeof(_ctypes.c_void_p)  # 64 or 32\n                    lib_filenames = [f'nvcuda{bits}.dll', 'nvcuda.dll']\n                # Open library\n                for lib_filename in lib_filenames:\n                    try:\n                        __cudaLib = _ctypes.CDLL(lib_filename)\n                        break\n                    except OSError:\n                        pass\n                if __cudaLib is None:\n                    _cudaCheckReturn(CUDA_ERROR_NOT_INITIALIZED)",
      "hash_value": "f5fce87f8f4e2974df6eb90b4a52c77a",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "def __LoadCudaLibrary() -> None:\n    \"\"\"Load the library if it isn't loaded already.\n\n    Raises:\n        CUDAError_NotInitialized:\n            If cannot found the CUDA driver library.\n    \"\"\"\n    global __cudaLib  # pylint: disable=global-statement\n\n    if __cudaLib is None:\n        # Lock to ensure only one caller loads the library\n        with __libLoadLock:\n            # Ensure the library still isn't loaded\n            if __cudaLib is None:\n                # Platform specific libcuda location\n                system = _platform.system()\n                if system == 'Darwin':\n                    lib_filenames = [\n                        'libcuda.1.dylib',  # check library path first\n                        'libcuda.dylib',\n                        '/usr/local/cuda/lib/libcuda.1.dylib',\n                        '/usr/local/cuda/lib/libcuda.dylib',\n                    ]\n                elif system == 'Linux':\n                    lib_filenames = [\n                        'libcuda.so',  # check library path first\n                        '/usr/lib64/nvidia/libcuda.so',  # Redhat/CentOS/Fedora\n                        '/usr/lib/x86_64-linux-gnu/libcuda.so',  # Ubuntu\n                        '/usr/lib/wsl/lib/libcuda.so',  # WSL\n                    ]\n                    # Also add libraries with version suffix `.1`\n                    lib_filenames = list(\n                        _itertools.chain.from_iterable((f'{lib}.1', lib) for lib in lib_filenames),\n                    )\n                elif system == 'Windows':\n                    bits = 8 * _ctypes.sizeof(_ctypes.c_void_p)  # 64 or 32\n                    lib_filenames = [f'nvcuda{bits}.dll', 'nvcuda.dll']\n                # Open library\n                for lib_filename in lib_filenames:\n                    try:\n                        __cudaLib = _ctypes.CDLL(lib_filename)\n                        break\n                    except OSError:\n                        pass\n                if __cudaLib is None:\n                    _cudaCheckReturn(CUDA_ERROR_NOT_INITIALIZED)",
          "triple_sequences": [
            {
              "action_api": "_platform.system()",
              "action_description": "Retrieves operating system identifier",
              "action_id": "get_os_id",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine operating system",
              "intention_id": "determine_operating_system"
            },
            {
              "action_api": "_ctypes.sizeof()",
              "action_description": "Retrieves size of object in bytes",
              "action_id": "get_buffer_bytes",
              "object": "_ctypes.c_void_p",
              "object_description": "Dynamic library name",
              "object_id": "library_name",
              "intention_description": "Prepare executable string",
              "intention_id": "prepare_executable_string"
            },
            {
              "action_api": "_ctypes.CDLL()",
              "action_description": "Instantiates dynamic library object",
              "action_id": "import_dynamic",
              "object": "lib_filename",
              "object_description": "Dynamic library name",
              "object_id": "library_name",
              "intention_description": "Import required module",
              "intention_id": "import_required_module"
            }
          ]
        }
      ]
    }
  ]
}