{
  "metadata": {
    "package_name": "requests_toolbelt-1",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/requests_toolbelt-1.0.0-py2.py3-none-any.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "decoder.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/requests_toolbelt-1.0.0-py2.py3-none-any/requests_toolbelt/multipart/decoder.py",
      "line_number": "155",
      "type_description": "B820:get",
      "context_snippet": "class MultipartDecoder(object):\n    \"\"\"\n\n    The ``MultipartDecoder`` object parses the multipart payload of\n    a bytestring into a tuple of ``Response``-like ``BodyPart`` objects.\n\n    The basic usage is::\n\n        import requests\n        from requests_toolbelt import MultipartDecoder\n\n        response = requests.get(url)\n        decoder = MultipartDecoder.from_response(response)\n        for part in decoder.parts:\n            print(part.headers['content-type'])\n\n    If the multipart content is not from a response, basic usage is::\n\n        from requests_toolbelt import MultipartDecoder\n\n        decoder = MultipartDecoder(content, content_type)\n        for part in decoder.parts:\n            print(part.headers['content-type'])\n\n    For both these usages, there is an optional ``encoding`` parameter. This is\n    a string, which is the name of the unicode codec to use (default is\n    ``'utf-8'``).\n\n    \"\"\"\n    def __init__(self, content, content_type, encoding='utf-8'):\n        #: Original Content-Type header\n        self.content_type = content_type\n        #: Response body encoding\n        self.encoding = encoding\n        #: Parsed parts of the multipart response body\n        self.parts = tuple()\n        self._find_boundary()\n        self._parse_body(content)\n\n    def _find_boundary(self):\n        ct_info = tuple(x.strip() for x in self.content_type.split(';'))\n        mimetype = ct_info[0]\n        if mimetype.split('/')[0].lower() != 'multipart':\n            raise NonMultipartContentTypeException(\n                \"Unexpected mimetype in content-type: '{}'\".format(mimetype)\n            )\n        for item in ct_info[1:]:\n            attr, value = _split_on_find(\n                item,\n                '='\n            )\n            if attr.lower() == 'boundary':\n                self.boundary = encode_with(value.strip('\"'), self.encoding)\n\n    @staticmethod\n    def _fix_first_part(part, boundary_marker):\n        bm_len = len(boundary_marker)\n        if boundary_marker == part[:bm_len]:\n            return part[bm_len:]\n        else:\n            return part\n\n    def _parse_body(self, content):\n        boundary = b''.join((b'--', self.boundary))\n\n        def body_part(part):\n            fixed = MultipartDecoder._fix_first_part(part, boundary)\n            return BodyPart(fixed, self.encoding)\n\n        def test_part(part):\n            return (part != b'' and\n                    part != b'\\r\\n' and\n                    part[:4] != b'--\\r\\n' and\n                    part != b'--')\n\n        parts = content.split(b''.join((b'\\r\\n', boundary)))\n        self.parts = tuple(body_part(x) for x in parts if test_part(x))\n\n    @classmethod\n    def from_response(cls, response, encoding='utf-8'):\n        content = response.content\n        content_type = response.headers.get('content-type', None)\n        return cls(content, content_type, encoding)",
      "hash_value": "9d24d6abb7de2655690cadbe907ac054",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "class MultipartDecoder(object):\n    \"\"\"\n\n    The ``MultipartDecoder`` object parses the multipart payload of\n    a bytestring into a tuple of ``Response``-like ``BodyPart`` objects.\n\n    The basic usage is::\n\n        import requests\n        from requests_toolbelt import MultipartDecoder\n\n        response = requests.get(url)\n        decoder = MultipartDecoder.from_response(response)\n        for part in decoder.parts:\n            print(part.headers['content-type'])\n\n    If the multipart content is not from a response, basic usage is::\n\n        from requests_toolbelt import MultipartDecoder\n\n        decoder = MultipartDecoder(content, content_type)\n        for part in decoder.parts:\n            print(part.headers['content-type'])\n\n    For both these usages, there is an optional ``encoding`` parameter. This is\n    a string, which is the name of the unicode codec to use (default is\n    ``'utf-8'``).\n\n    \"\"\"\n    def __init__(self, content, content_type, encoding='utf-8'):\n        #: Original Content-Type header\n        self.content_type = content_type\n        #: Response body encoding\n        self.encoding = encoding\n        #: Parsed parts of the multipart response body\n        self.parts = tuple()\n        self._find_boundary()\n        self._parse_body(content)\n\n    def _find_boundary(self):\n        ct_info = tuple(x.strip() for x in self.content_type.split(';'))\n        mimetype = ct_info[0]\n        if mimetype.split('/')[0].lower() != 'multipart':\n            raise NonMultipartContentTypeException(\n                \"Unexpected mimetype in content-type: '{}'\".format(mimetype)\n            )\n        for item in ct_info[1:]:\n            attr, value = _split_on_find(\n                item,\n                '='\n            )\n            if attr.lower() == 'boundary':\n                self.boundary = encode_with(value.strip('\"'), self.encoding)\n\n    @staticmethod\n    def _fix_first_part(part, boundary_marker):\n        bm_len = len(boundary_marker)\n        if boundary_marker == part[:bm_len]:\n            return part[bm_len:]\n        else:\n            return part\n\n    def _parse_body(self, content):\n        boundary = b''.join((b'--', self.boundary))\n\n        def body_part(part):\n            fixed = MultipartDecoder._fix_first_part(part, boundary)\n            return BodyPart(fixed, self.encoding)\n\n        def test_part(part):\n            return (part != b'' and\n                    part != b'\\r\\n' and\n                    part[:4] != b'--\\r\\n' and\n                    part != b'--')\n\n        parts = content.split(b''.join((b'\\r\\n', boundary)))\n        self.parts = tuple(body_part(x) for x in parts if test_part(x))\n\n    @classmethod\n    def from_response(cls, response, encoding='utf-8'):\n        content = response.content\n        content_type = response.headers.get('content-type', None)\n        return cls(content, content_type, encoding)",
          "triple_sequences": [
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP GET request to URL",
              "action_id": "open_url_get",
              "object": "url",
              "object_description": "URL string",
              "object_id": "url_string",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "response.content",
              "action_description": "Process HTTP response content",
              "action_id": "process_http_response",
              "object": "response.content",
              "object_description": "HTTP response content from remote server",
              "object_id": "http_response_remote_content",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "response.headers.get()",
              "action_description": "Process HTTP response content",
              "action_id": "process_http_response",
              "object": "'content-type'",
              "object_description": "HTTP header",
              "object_id": "http_header",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "MultipartDecoder.from_response()",
              "action_description": "Creates multipart writer for HTTP requests",
              "action_id": "create_multipart_writer",
              "object": "response, encoding='utf-8'",
              "object_description": "HTTP response content from remote server",
              "object_id": "http_response_remote_content",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "MultipartDecoder()",
              "action_description": "Creates multipart writer for HTTP requests",
              "action_id": "create_multipart_writer",
              "object": "content, content_type, encoding",
              "object_description": "HTTP response content from remote server",
              "object_id": "http_response_remote_content",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "str.split()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "self.content_type, ';'",
              "object_description": "Content type string",
              "object_id": "content_type",
              "intention_description": "Prepare string processing",
              "intention_id": "prepare_string_processing"
            },
            {
              "action_api": "str.strip()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "x",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare string processing",
              "intention_id": "prepare_string_processing"
            },
            {
              "action_api": "str.split()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "mimetype, '/'",
              "object_description": "MIME type string",
              "object_id": "mime_type",
              "intention_description": "Prepare string processing",
              "intention_id": "prepare_string_processing"
            },
            {
              "action_api": "_split_on_find()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "item, '='",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare string processing",
              "intention_id": "prepare_string_processing"
            },
            {
              "action_api": "encode_with()",
              "action_description": "Encodes string to bytes using default encoding",
              "action_id": "encode_string_to_bytes",
              "object": "value.strip('\"'), self.encoding",
              "object_description": "Character encoding type",
              "object_id": "character_encoding_type",
              "intention_description": "Encode string to bytes",
              "intention_id": "encode_string_to_bytes"
            },
            {
              "action_api": "content.split()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "b''.join((b'\\r\\n', boundary))",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "len()",
              "action_description": "Generate product of sequence",
              "action_id": "generate_sequence_product",
              "object": "boundary_marker",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data processing",
              "intention_id": "prepare_data_processing"
            }
          ]
        }
      ]
    }
  ]
}