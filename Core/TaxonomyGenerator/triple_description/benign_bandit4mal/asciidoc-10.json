{
  "metadata": {
    "package_name": "asciidoc-10",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/asciidoc-10.2.1.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "asciidoc.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/asciidoc-10.2.1/asciidoc-10.2.1/asciidoc/asciidoc.py",
      "line_number": "2828",
      "type_description": "B815:write",
      "context_snippet": "def translate(self):\n    AbstractBlock.translate(self)\n    reader.read()   # Discard delimiter.\n    self.merge_attributes(AttributeList.attrs)\n    if 'skip' not in self.parameters.options:\n        BlockTitle.consume(self.attributes)\n        AttributeList.consume()\n    if 'options' in self.attributes:\n        options = parse_options(self.attributes['options'], (), 'illegal option name')\n        for option in options:\n            self.attributes[option + '-option'] = ''\n    self.push_blockname()\n    options = self.parameters.options\n    if 'skip' in options:\n        reader.read_until(self.delimiter, same_file=True)\n    elif safe() and self.defname == 'blockdef-backend':\n        message.unsafe('Backend Block')\n        reader.read_until(self.delimiter, same_file=True)\n    else:\n        template = self.parameters.template\n        template = subs_attrs(template, self.attributes)\n        name = self.short_name() + ' block'\n        if 'sectionbody' in options:\n            # The body is treated like a section body.\n            stag, etag = config.section2tags(template, self.attributes)\n            writer.write(stag, trace=name + ' open')\n            Section.translate_body(self)\n            writer.write(etag, trace=name + ' close')\n        else:\n            stag = config.section2tags(template, self.attributes, skipend=True)[0]\n            body = reader.read_until(self.delimiter, same_file=True)\n            presubs = self.parameters.presubs\n            postsubs = self.parameters.postsubs\n            body = Lex.subs(body, presubs)\n            if self.parameters.filter:\n                body = filter_lines(self.parameters.filter, body, self.attributes)\n            body = Lex.subs(body, postsubs)\n            # Write start tag, content, end tag.\n            etag = config.section2tags(template, self.attributes, skipstart=True)[1]\n            writer.write(utils.dovetail_tags(stag, body, etag), trace=name)\n        trace(self.short_name() + ' block close', etag)\n    if reader.eof():\n        self.error('missing closing delimiter', self.start)\n    else:\n        delimiter = reader.read()   # Discard delimiter line.\n        assert re.match(self.delimiter, delimiter)\n    self.pop_blockname()",
      "hash_value": "e3dfc43043452bced5de1174ea04b015",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "def translate(self):\n    AbstractBlock.translate(self)\n    reader.read()   # Discard delimiter.\n    self.merge_attributes(AttributeList.attrs)\n    if 'skip' not in self.parameters.options:\n        BlockTitle.consume(self.attributes)\n        AttributeList.consume()\n    if 'options' in self.attributes:\n        options = parse_options(self.attributes['options'], (), 'illegal option name')\n        for option in options:\n            self.attributes[option + '-option'] = ''\n    self.push_blockname()\n    options = self.parameters.options\n    if 'skip' in options:\n        reader.read_until(self.delimiter, same_file=True)\n    elif safe() and self.defname == 'blockdef-backend':\n        message.unsafe('Backend Block')\n        reader.read_until(self.delimiter, same_file=True)\n    else:\n        template = self.parameters.template\n        template = subs_attrs(template, self.attributes)\n        name = self.short_name() + ' block'\n        if 'sectionbody' in options:\n            # The body is treated like a section body.\n            stag, etag = config.section2tags(template, self.attributes)\n            writer.write(stag, trace=name + ' open')\n            Section.translate_body(self)\n            writer.write(etag, trace=name + ' close')\n        else:\n            stag = config.section2tags(template, self.attributes, skipend=True)[0]\n            body = reader.read_until(self.delimiter, same_file=True)\n            presubs = self.parameters.presubs\n            postsubs = self.parameters.postsubs\n            body = Lex.subs(body, presubs)\n            if self.parameters.filter:\n                body = filter_lines(self.parameters.filter, body, self.attributes)\n            body = Lex.subs(body, postsubs)\n            # Write start tag, content, end tag.\n            etag = config.section2tags(template, self.attributes, skipstart=True)[1]\n            writer.write(utils.dovetail_tags(stag, body, etag), trace=name)\n        trace(self.short_name() + ' block close', etag)\n    if reader.eof():\n        self.error('missing closing delimiter', self.start)\n    else:\n        delimiter = reader.read()   # Discard delimiter line.\n        assert re.match(self.delimiter, delimiter)\n    self.pop_blockname()",
          "triple_sequences": [
            {
              "action_api": "reader.read()",
              "action_description": "Reads all bytes from process standard output",
              "action_id": "read_process_stdout",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "self.merge_attributes()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "AttributeList.attrs",
              "object_description": "Structured file data",
              "object_id": "structured_file_data",
              "intention_description": "Prepare data processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "BlockTitle.consume()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "self.attributes",
              "object_description": "Attribute value",
              "object_id": "access_attribute_value",
              "intention_description": "Prepare character processing",
              "intention_id": "prepare_character_processing"
            },
            {
              "action_api": "AttributeList.consume()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare character processing",
              "intention_id": "prepare_character_processing"
            },
            {
              "action_api": "parse_options()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "self.attributes['options'], (), 'illegal option name'",
              "object_description": "Attribute value",
              "object_id": "access_attribute_value",
              "intention_description": "Prepare data processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "self.push_blockname()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "reader.read_until()",
              "action_description": "Reads all bytes from process standard output",
              "action_id": "read_process_stdout",
              "object": "self.delimiter, same_file=True",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "message.unsafe()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "'Backend Block'",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Prepare data processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "reader.read_until()",
              "action_description": "Reads all bytes from process standard output",
              "action_id": "read_process_stdout",
              "object": "self.delimiter, same_file=True",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "subs_attrs()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "template, self.attributes",
              "object_description": "Structured file data",
              "object_id": "structured_file_data",
              "intention_description": "Prepare data processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "config.section2tags()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "template, self.attributes",
              "object_description": "Structured file data",
              "object_id": "structured_file_data",
              "intention_description": "Prepare data processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "writer.write()",
              "action_description": "Saves image to file",
              "action_id": "save_image_file",
              "object": "stag, trace=name + ' open'",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "Section.translate_body()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "self",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "writer.write()",
              "action_description": "Saves image to file",
              "action_id": "save_image_file",
              "object": "etag, trace=name + ' close'",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "config.section2tags()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "template, self.attributes, skipend=True",
              "object_description": "Structured file data",
              "object_id": "structured_file_data",
              "intention_description": "Prepare data processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "reader.read_until()",
              "action_description": "Reads all bytes from process standard output",
              "action_id": "read_process_stdout",
              "object": "self.delimiter, same_file=True",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "Lex.subs()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "body, presubs",
              "object_description": "Structured file data",
              "object_id": "structured_file_data",
              "intention_description": "Prepare data processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "filter_lines()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "self.parameters.filter, body, self.attributes",
              "object_description": "Attribute value",
              "object_id": "access_attribute_value",
              "intention_description": "Prepare data processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "Lex.subs()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "body, postsubs",
              "object_description": "Structured file data",
              "object_id": "structured_file_data",
              "intention_description": "Prepare data processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "config.section2tags()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "template, self.attributes, skipstart=True",
              "object_description": "Structured file data",
              "object_id": "structured_file_data",
              "intention_description": "Prepare data processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "writer.write()",
              "action_description": "Saves image to file",
              "action_id": "save_image_file",
              "object": "utils.dovetail_tags(stag, body, etag), trace=name",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "trace()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "self.short_name() + ' block close', etag",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Prepare data processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "reader.eof()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Check file existence",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "self.error()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "'missing closing delimiter', self.start",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Prepare data processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "reader.read()",
              "action_description": "Reads all bytes from process standard output",
              "action_id": "read_process_stdout",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "re.match()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "self.delimiter, delimiter",
              "object_description": "Regex_pattern",
              "object_id": "regex_pattern",
              "intention_description": "Prepare character processing",
              "intention_id": "prepare_character_processing"
            },
            {
              "action_api": "self.pop_blockname()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Release system resource",
              "intention_id": "release_system_resource"
            }
          ]
        }
      ]
    }
  ]
}