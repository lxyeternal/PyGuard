{
  "metadata": {
    "package_name": "geocoder-1",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/geocoder-1.38.1.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "cli.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/geocoder-1.38.1/geocoder-1.38.1/geocoder/cli.py",
      "line_number": "45",
      "type_description": "B833:input",
      "context_snippet": "@click.command()\n@click.argument('location', nargs=-1)\n@click.option('--provider', '-p', default='osm', type=click.Choice(providers))\n@click.option('--method', '-m', default='geocode', type=click.Choice(methods))\n@click.option('--output', '-o', default='json', type=click.Choice(outputs))\n@click.option('--units', '-u', default='kilometers', type=click.Choice(units))\n@click.option('--timeout', '-t', default=5.0)\n@click.option('--distance', is_flag=True)\n@click.option('--language', default='')\n@click.option('--url', default='')\n@click.option('--proxies')\n@click.option('--key')\n# following are for Tamu provider\n@click.option('--city', '-c', default='')\n@click.option('--state', '-s', default='')\n@click.option('--zipcode', '-z', default='')\ndef cli(location, **kwargs):\n    \"\"\"Geocode an arbitrary number of strings from Command Line.\"\"\"\n\n    locations = []\n\n    # Read Standard Input\n    # $ cat foo.txt | geocode\n    try:\n        for line in fileinput.input():\n            locations.append(line.strip())\n    except:\n        pass\n\n    # Read multiple files & user input location\n    for item in location:\n        if os.path.exists(item):\n            with open(item, 'rb') as f:\n                locations += f.read().splitlines()\n        else:\n            locations.append(item)\n\n    # Distance calculation\n    if kwargs['distance']:\n        d = geocoder.distance(locations, **kwargs)\n        click.echo(d)\n        return\n\n    # Geocode results from user input\n    for location in locations:\n        g = geocoder.get(location.strip(), **kwargs)\n        try:\n            click.echo(json.dumps(getattr(g, kwargs['output'])))\n        except IOError:\n            # When invalid command is entered a broken pipe error occurs\n            return",
      "hash_value": "f0afa1626e74967a49e4d1116a042938",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "@click.command()\n@click.argument('location', nargs=-1)\n@click.option('--provider', '-p', default='osm', type=click.Choice(providers))\n@click.option('--method', '-m', default='geocode', type=click.Choice(methods))\n@click.option('--output', '-o', default='json', type=click.Choice(outputs))\n@click.option('--units', '-u', default='kilometers', type=click.Choice(units))\n@click.option('--timeout', '-t', default=5.0)\n@click.option('--distance', is_flag=True)\n@click.option('--language', default='')\n@click.option('--url', default='')\n@click.option('--proxies')\n@click.option('--key')\n# following are for Tamu provider\n@click.option('--city', '-c', default='')\n@click.option('--state', '-s', default='')\n@click.option('--zipcode', '-z', default='')\ndef cli(location, **kwargs):\n    \"\"\"Geocode an arbitrary number of strings from Command Line.\"\"\"\n\n    locations = []\n\n    # Read Standard Input\n    # $ cat foo.txt | geocode\n    try:\n        for line in fileinput.input():\n            locations.append(line.strip())\n    except:\n        pass\n\n    # Read multiple files & user input location\n    for item in location:\n        if os.path.exists(item):\n            with open(item, 'rb') as f:\n                locations += f.read().splitlines()\n        else:\n            locations.append(item)\n\n    # Distance calculation\n    if kwargs['distance']:\n        d = geocoder.distance(locations, **kwargs)\n        click.echo(d)\n        return\n\n    # Geocode results from user input\n    for location in locations:\n        g = geocoder.get(location.strip(), **kwargs)\n        try:\n            click.echo(json.dumps(getattr(g, kwargs['output'])))\n        except IOError:\n            # When invalid command is entered a broken pipe error occurs\n            return",
          "triple_sequences": [
            {
              "action_api": "fileinput.input()",
              "action_description": "Reads user input from standard input",
              "action_id": "read_user_input",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect user input",
              "intention_id": "collect_user_input"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "item",
              "object_description": "Local file or directory name",
              "object_id": "local_file_or_directory_name",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "item",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "f.read()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "item",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "geocoder.distance()",
              "action_description": "Creates new function to process data (custom function)",
              "action_id": "create_async_task",
              "object": "locations, **kwargs",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Generate product of sequence",
              "intention_id": "generate_sequence_product"
            },
            {
              "action_api": "click.echo()",
              "action_description": "Writes output to standard output stream",
              "action_id": "get_stdout_stream",
              "object": "d",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect command output",
              "intention_id": "collect_command_output"
            },
            {
              "action_api": "geocoder.get()",
              "action_description": "Creates new function to process data (custom function)",
              "action_id": "create_async_task",
              "object": "location.strip(), **kwargs",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Access remote data",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "json.dumps()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "getattr(g, kwargs['output'])",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Serialize data",
              "intention_id": "serialize_data"
            },
            {
              "action_api": "click.echo()",
              "action_description": "Writes output to standard output stream",
              "action_id": "get_stdout_stream",
              "object": "json.dumps(getattr(g, kwargs['output']))",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Collect command output",
              "intention_id": "collect_command_output"
            }
          ]
        }
      ]
    }
  ]
}