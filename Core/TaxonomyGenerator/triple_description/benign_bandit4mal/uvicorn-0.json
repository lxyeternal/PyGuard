{
  "metadata": {
    "package_name": "uvicorn-0",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/uvicorn-0.34.0.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "test_websocket.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/uvicorn-0.34.0/uvicorn-0.34.0/tests/protocols/test_websocket.py",
      "line_number": "454",
      "type_description": "B805:send",
      "context_snippet": "async def test_asgi_return_value(ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int):\n    \"\"\"\n    The ASGI callable should return 'None'. If it doesn't, make sure that\n    the connection is closed with an error condition.\n    \"\"\"\n\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        await send({\"type\": \"websocket.accept\"})\n        return 123\n\n    config = Config(app=app, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        async with websockets.client.connect(f\"ws://127.0.0.1:{unused_tcp_port}\") as websocket:\n            with pytest.raises(websockets.exceptions.ConnectionClosed):\n                _ = await websocket.recv()\n        assert websocket.close_code == 1006",
      "hash_value": "0c76ae48ceef4b95c99e0a399b73d1f3",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "async def test_asgi_return_value(ws_protocol_cls: WSProtocol, http_protocol_cls: HTTPProtocol, unused_tcp_port: int):\n    \"\"\"\n    The ASGI callable should return 'None'. If it doesn't, make sure that\n    the connection is closed with an error condition.\n    \"\"\"\n\n    async def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable):\n        await send({\"type\": \"websocket.accept\"})\n        return 123\n\n    config = Config(app=app, ws=ws_protocol_cls, http=http_protocol_cls, lifespan=\"off\", port=unused_tcp_port)\n    async with run_server(config):\n        async with websockets.client.connect(f\"ws://127.0.0.1:{unused_tcp_port}\") as websocket:\n            with pytest.raises(websockets.exceptions.ConnectionClosed):\n                _ = await websocket.recv()\n        assert websocket.close_code == 1006",
          "triple_sequences": [
            {
              "action_api": "send()",
              "action_description": "Sends data over socket connection",
              "action_id": "send_socket_data",
              "object": "{\"type\": \"websocket.accept\"}",
              "object_description": "Command output",
              "object_id": "command_output",
              "intention_description": "Establish connection",
              "intention_id": "establish_connection"
            },
            {
              "action_api": "run_server()",
              "action_description": "Runs asynchronous function until completion",
              "action_id": "run_async_function",
              "object": "config",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "Trigger main behavioral logic",
              "intention_id": "trigger_main_behavioral_logic"
            },
            {
              "action_api": "websockets.client.connect()",
              "action_description": "Establishes TCP connection to specified address",
              "action_id": "establish_tcp_connection",
              "object": "f\"ws://127.0.0.1:{unused_tcp_port}\"",
              "object_description": "Localhost address",
              "object_id": "localhost_address",
              "intention_description": "Establish connection",
              "intention_id": "establish_connection"
            },
            {
              "action_api": "websocket.recv()",
              "action_description": "Receives data from socket connection",
              "action_id": "receive_socket_data",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Receive command from server",
              "intention_id": "receive_command_from_server"
            },
            {
              "action_api": "pytest.raises()",
              "action_description": "Handles socket timeout exception",
              "action_id": "handle_socket_timeout",
              "object": "websockets.exceptions.ConnectionClosed",
              "object_description": "Exception type name",
              "object_id": "exception_type",
              "intention_description": "Stop execution on invalid input",
              "intention_id": "stop_execution_invalid_input"
            }
          ]
        }
      ]
    }
  ]
}