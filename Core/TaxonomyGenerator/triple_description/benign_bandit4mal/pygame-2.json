{
  "metadata": {
    "package_name": "pygame-2",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/pygame-2.6.1.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "png.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pygame-2.6.1/pygame-2.6.1/test/test_utils/png.py",
      "line_number": "3748",
      "type_description": "B815:write",
      "context_snippet": "def write_pnm(file, width, height, pixels, meta):\n    \"\"\"Write a Netpbm PNM/PAM file.\"\"\"\n\n    bitdepth = meta[\"bitdepth\"]\n    maxval = 2**bitdepth - 1\n    # Rudely, the number of image planes can be used to determine\n    # whether we are L (PGM), LA (PAM), RGB (PPM), or RGBA (PAM).\n    planes = meta[\"planes\"]\n    # Can be an assert as long as we assume that pixels and meta came\n    # from a PNG file.\n    assert planes in (1, 2, 3, 4)\n    if planes in (1, 3):\n        if 1 == planes:\n            # PGM\n            # Could generate PBM if maxval is 1, but we don't (for one\n            # thing, we'd have to convert the data, not just blat it\n            # out).\n            fmt = \"P5\"\n        else:\n            # PPM\n            fmt = \"P6\"\n        file.write(\"%s %d %d %d\\n\" % (fmt, width, height, maxval))\n    if planes in (2, 4):\n        # PAM\n        # See http://netpbm.sourceforge.net/doc/pam.html\n        if 2 == planes:\n            tupltype = \"GRAYSCALE_ALPHA\"\n        else:\n            tupltype = \"RGB_ALPHA\"\n        file.write(\n            \"P7\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %d\\nMAXVAL %d\\n\"\n            \"TUPLTYPE %s\\nENDHDR\\n\" % (width, height, planes, maxval, tupltype)\n        )\n    # Values per row\n    vpr = planes * width\n    # struct format\n    fmt = \">%d\" % vpr\n    if maxval > 0xFF:\n        fmt = fmt + \"H\"\n    else:\n        fmt = fmt + \"B\"\n    for row in pixels:\n        file.write(struct.pack(fmt, *row))\n    file.flush()",
      "hash_value": "4dfb7e6541395b264b96ddfd71c87f18",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "def write_pnm(file, width, height, pixels, meta):\n    \"\"\"Write a Netpbm PNM/PAM file.\"\"\"\n\n    bitdepth = meta[\"bitdepth\"]\n    maxval = 2**bitdepth - 1\n    # Rudely, the number of image planes can be used to determine\n    # whether we are L (PGM), LA (PAM), RGB (PPM), or RGBA (PAM).\n    planes = meta[\"planes\"]\n    # Can be an assert as long as we assume that pixels and meta came\n    # from a PNG file.\n    assert planes in (1, 2, 3, 4)\n    if planes in (1, 3):\n        if 1 == planes:\n            # PGM\n            # Could generate PBM if maxval is 1, but we don't (for one\n            # thing, we'd have to convert the data, not just blat it\n            # out).\n            fmt = \"P5\"\n        else:\n            # PPM\n            fmt = \"P6\"\n        file.write(\"%s %d %d %d\\n\" % (fmt, width, height, maxval))\n    if planes in (2, 4):\n        # PAM\n        # See http://netpbm.sourceforge.net/doc/pam.html\n        if 2 == planes:\n            tupltype = \"GRAYSCALE_ALPHA\"\n        else:\n            tupltype = \"RGB_ALPHA\"\n        file.write(\n            \"P7\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %d\\nMAXVAL %d\\n\"\n            \"TUPLTYPE %s\\nENDHDR\\n\" % (width, height, planes, maxval, tupltype)\n        )\n    # Values per row\n    vpr = planes * width\n    # struct format\n    fmt = \">%d\" % vpr\n    if maxval > 0xFF:\n        fmt = fmt + \"H\"\n    else:\n        fmt = fmt + \"B\"\n    for row in pixels:\n        file.write(struct.pack(fmt, *row))\n    file.flush()",
          "triple_sequences": [
            {
              "action_api": "file.write()",
              "action_description": "Saves image to file",
              "action_id": "save_image_file",
              "object": "\"%s %d %d %d\\n\" % (fmt, width, height, maxval)",
              "object_description": "Image file",
              "object_id": "image_file",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "Saves image to file",
              "action_id": "save_image_file",
              "object": "\"P7\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %d\\nMAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\" % (width, height, planes, maxval, tupltype)",
              "object_description": "Image file",
              "object_id": "image_file",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "struct.pack()",
              "action_description": "Packs values into bytes using specified format",
              "action_id": "pack_values",
              "object": "fmt, *row",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "file.write()",
              "action_description": "Saves image to file",
              "action_id": "save_image_file",
              "object": "struct.pack(fmt, *row)",
              "object_description": "Image file",
              "object_id": "image_file",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.flush()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close file",
              "intention_id": "close_file"
            }
          ]
        }
      ]
    }
  ]
}