{
  "metadata": {
    "package_name": "clearml-1",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/clearml-1.18.0-py2.py3-none-any.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "mp.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/clearml-1.18.0-py2.py3-none-any/clearml/utilities/process/mp.py",
      "line_number": "276",
      "type_description": "B839:pool",
      "context_snippet": "class SafeQueue(object):\n    \"\"\"\n    Many writers Single Reader multiprocessing safe Queue\n    \"\"\"\n    __thread_pool = SingletonThreadPool()\n\n    def __init__(self, *args, **kwargs):\n        self._reader_thread = None\n        self._reader_thread_started = False\n        # Fix the python Queue and Use SimpleQueue write so it uses a single OS write,\n        # making it atomic message passing\n        self._q = SimpleQueue(*args, **kwargs)\n\n        # on Windows, queue communication is done via pipes, no need to override the _send_bytes method\n        if sys.platform != 'win32':\n            # noinspection PyBroadException\n            try:\n                # noinspection PyUnresolvedReferences,PyProtectedMember\n                self._q._writer._send_bytes = partial(SafeQueue._pipe_override_send_bytes, self._q._writer)\n            except Exception:\n                pass\n\n        self._internal_q = None\n        # Note we should Never! assign a new object to `self._q_size`, just work with the initial object\n        self._q_size = []  # list of PIDs we pushed, so this is atomic.\n\n    def empty(self):\n        return self._q.empty() and (not self._internal_q or self._internal_q.empty())\n\n    def is_pending(self):\n        # check if we have pending requests to be pushed (it does not mean they were pulled)\n        # only call from main put process\n        return self._get_q_size_len() > 0\n\n    def close(self, event, timeout=3.0):\n        # wait until all pending requests pushed\n        tic = time()\n        pid = os.getpid()\n        prev_q_size = self._get_q_size_len(pid)\n        while self.is_pending():\n            if event:\n                event.set()\n            if not self.__thread_pool.is_active():\n                break\n            sleep(0.1)\n            # timeout is for the maximum time to pull a single object from the queue,\n            # this way if we get stuck we notice quickly and abort\n            if timeout and (time()-tic) > timeout:\n                if prev_q_size == self._get_q_size_len(pid):\n                    break\n                else:\n                    prev_q_size = self._get_q_size_len(pid)\n                    tic = time()\n\n    def get(self, *args, **kwargs):\n        return self._get_internal_queue(*args, **kwargs)\n\n    def batch_get(self, max_items=1000, timeout=0.2, throttle_sleep=0.1):\n        buffer = []\n        timeout_count = int(timeout/throttle_sleep)\n        empty_count = timeout_count\n        while len(buffer) < max_items:\n            while not self.empty() and len(buffer) < max_items:\n                try:\n                    buffer.append(self._get_internal_queue(block=False))\n                    empty_count = 0\n                except Empty:\n                    break\n            empty_count += 1\n            if empty_count > timeout_count or len(buffer) >= max_items:\n                break\n            sleep(throttle_sleep)\n        return buffer\n\n    def put(self, obj):\n        # not atomic when forking for the first time\n        # GIL will make sure it is atomic\n        self._q_size.append(os.getpid())\n        try:\n            # make sure the block put is done in the thread pool i.e. in the background\n            obj = pickle.dumps(obj)\n            if BackgroundMonitor.get_at_exit_state():\n                self._q_put(obj)\n                return\n            self.__thread_pool.get().apply_async(self._q_put, args=(obj, False))\n        except:  # noqa\n            pid = os.getpid()\n            p = None\n            while p != pid and self._q_size:\n                p = self._q_size.pop()\n\n    def _get_q_size_len(self, pid=None):\n        pid = pid or os.getpid()\n        return len([p for p in self._q_size if p == pid])\n\n    def _q_put(self, obj, allow_raise=True):\n        # noinspection PyBroadException\n        try:\n            self._q.put(obj)\n        except BaseException:\n            # make sure we zero the _q_size of the process dies (i.e. queue put fails)\n            self._q_size.clear()\n            if allow_raise:\n                raise\n            return\n        pid = os.getpid()\n        # GIL will make sure it is atomic\n        # pop the First \"counter\" that is ours (i.e. pid == os.getpid())\n        p = None\n        while p != pid and self._q_size:\n            p = self._q_size.pop()\n\n    def _init_reader_thread(self):\n        if not self._internal_q:\n            self._internal_q = ForkQueue()\n        if not self._reader_thread or not self._reader_thread.is_alive():\n            # read before we start the thread\n            self._reader_thread = Thread(target=self._reader_daemon)\n            self._reader_thread.daemon = True\n            self._reader_thread.start()\n            # if we have waiting results\n            # wait until thread is up and pushed some results\n            while not self._reader_thread_started:\n                sleep(0.2)\n            # just in case make sure we pulled some stuff if we had any\n            # todo: wait until a queue is not empty, but for some reason that might fail\n            sleep(1.0)\n\n    def _get_internal_queue(self, *args, **kwargs):\n        self._init_reader_thread()\n        obj = self._internal_q.get(*args, **kwargs)\n        # deserialize\n        return pickle.loads(obj)\n\n    def _reader_daemon(self):\n        self._reader_thread_started = True\n        # pull from process queue and push into thread queue\n        while True:\n            # noinspection PyBroadException\n            try:\n                obj = self._q.get()\n                if obj is None:\n                    break\n            except Exception:\n                break\n            self._internal_q.put(obj)\n\n    @staticmethod\n    def _pipe_override_send_bytes(self, buf):\n        n = len(buf)\n        # For wire compatibility with 3.2 and lower\n        header = struct.pack(\"!i\", n)\n        # Issue #20540: concatenate before sending, to avoid delays due\n        # to Nagle's algorithm on a TCP socket.\n        # Also note we want to avoid sending a 0-length buffer separately,\n        # to avoid \"broken pipe\" errors if the other end closed the pipe.\n        self._send(header + buf)\n",
      "hash_value": "bb644b1fdc77c3932c0ae57372d1ae2a",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "class SafeQueue(object):\n    \"\"\"\n    Many writers Single Reader multiprocessing safe Queue\n    \"\"\"\n    __thread_pool = SingletonThreadPool()\n\n    def __init__(self, *args, **kwargs):\n        self._reader_thread = None\n        self._reader_thread_started = False\n        # Fix the python Queue and Use SimpleQueue write so it uses a single OS write,\n        # making it atomic message passing\n        self._q = SimpleQueue(*args, **kwargs)\n\n        # on Windows, queue communication is done via pipes, no need to override the _send_bytes method\n        if sys.platform != 'win32':\n            # noinspection PyBroadException\n            try:\n                # noinspection PyUnresolvedReferences,PyProtectedMember\n                self._q._writer._send_bytes = partial(SafeQueue._pipe_override_send_bytes, self._q._writer)\n            except Exception:\n                pass\n\n        self._internal_q = None\n        # Note we should Never! assign a new object to `self._q_size`, just work with the initial object\n        self._q_size = []  # list of PIDs we pushed, so this is atomic.\n\n    def empty(self):\n        return self._q.empty() and (not self._internal_q or self._internal_q.empty())\n\n    def is_pending(self):\n        # check if we have pending requests to be pushed (it does not mean they were pulled)\n        # only call from main put process\n        return self._get_q_size_len() > 0\n\n    def close(self, event, timeout=3.0):\n        # wait until all pending requests pushed\n        tic = time()\n        pid = os.getpid()\n        prev_q_size = self._get_q_size_len(pid)\n        while self.is_pending():\n            if event:\n                event.set()\n            if not self.__thread_pool.is_active():\n                break\n            sleep(0.1)\n            # timeout is for the maximum time to pull a single object from the queue,\n            # this way if we get stuck we notice quickly and abort\n            if timeout and (time()-tic) > timeout:\n                if prev_q_size == self._get_q_size_len(pid):\n                    break\n                else:\n                    prev_q_size = self._get_q_size_len(pid)\n                    tic = time()\n\n    def get(self, *args, **kwargs):\n        return self._get_internal_queue(*args, **kwargs)\n\n    def batch_get(self, max_items=1000, timeout=0.2, throttle_sleep=0.1):\n        buffer = []\n        timeout_count = int(timeout/throttle_sleep)\n        empty_count = timeout_count\n        while len(buffer) < max_items:\n            while not self.empty() and len(buffer) < max_items:\n                try:\n                    buffer.append(self._get_internal_queue(block=False))\n                    empty_count = 0\n                except Empty:\n                    break\n            empty_count += 1\n            if empty_count > timeout_count or len(buffer) >= max_items:\n                break\n            sleep(throttle_sleep)\n        return buffer\n\n    def put(self, obj):\n        # not atomic when forking for the first time\n        # GIL will make sure it is atomic\n        self._q_size.append(os.getpid())\n        try:\n            # make sure the block put is done in the thread pool i.e. in the background\n            obj = pickle.dumps(obj)\n            if BackgroundMonitor.get_at_exit_state():\n                self._q_put(obj)\n                return\n            self.__thread_pool.get().apply_async(self._q_put, args=(obj, False))\n        except:  # noqa\n            pid = os.getpid()\n            p = None\n            while p != pid and self._q_size:\n                p = self._q_size.pop()\n\n    def _get_q_size_len(self, pid=None):\n        pid = pid or os.getpid()\n        return len([p for p in self._q_size if p == pid])\n\n    def _q_put(self, obj, allow_raise=True):\n        # noinspection PyBroadException\n        try:\n            self._q.put(obj)\n        except BaseException:\n            # make sure we zero the _q_size of the process dies (i.e. queue put fails)\n            self._q_size.clear()\n            if allow_raise:\n                raise\n            return\n        pid = os.getpid()\n        # GIL will make sure it is atomic\n        # pop the First \"counter\" that is ours (i.e. pid == os.getpid())\n        p = None\n        while p != pid and self._q_size:\n            p = self._q_size.pop()\n\n    def _init_reader_thread(self):\n        if not self._internal_q:\n            self._internal_q = ForkQueue()\n        if not self._reader_thread or not self._reader_thread.is_alive():\n            # read before we start the thread\n            self._reader_thread = Thread(target=self._reader_daemon)\n            self._reader_thread.daemon = True\n            self._reader_thread.start()\n            # if we have waiting results\n            # wait until thread is up and pushed some results\n            while not self._reader_thread_started:\n                sleep(0.2)\n            # just in case make sure we pulled some stuff if we had any\n            # todo: wait until a queue is not empty, but for some reason that might fail\n            sleep(1.0)\n\n    def _get_internal_queue(self, *args, **kwargs):\n        self._init_reader_thread()\n        obj = self._internal_q.get(*args, **kwargs)\n        # deserialize\n        return pickle.loads(obj)\n\n    def _reader_daemon(self):\n        self._reader_thread_started = True\n        # pull from process queue and push into thread queue\n        while True:\n            # noinspection PyBroadException\n            try:\n                obj = self._q.get()\n                if obj is None:\n                    break\n            except Exception:\n                break\n            self._internal_q.put(obj)\n\n    @staticmethod\n    def _pipe_override_send_bytes(self, buf):\n        n = len(buf)\n        # For wire compatibility with 3.2 and lower\n        header = struct.pack(\"!i\", n)\n        # Issue #20540: concatenate before sending, to avoid delays due\n        # to Nagle's algorithm on a TCP socket.\n        # Also note we want to avoid sending a 0-length buffer separately,\n        # to avoid \"broken pipe\" errors if the other end closed the pipe.\n        self._send(header + buf)\n",
          "triple_sequences": [
            {
              "action_api": "SimpleQueue()",
              "action_description": "Creates temporary file that is not deleted on close",
              "action_id": "create_temp_file",
              "object": "*args, **kwargs",
              "object_description": "",
              "object_id": "",
              "intention_description": "Create temporary file",
              "intention_id": "create_temporary_file"
            },
            {
              "action_api": "os.getpid()",
              "action_description": "Retrieves process information",
              "action_id": "get_process_info",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect current username",
              "intention_id": "collect_current_username"
            },
            {
              "action_api": "self._q.empty()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "self._internal_q.empty()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "self._get_q_size_len()",
              "action_description": "Retrieves process information",
              "action_id": "get_process_info",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect current username",
              "intention_id": "collect_current_username"
            },
            {
              "action_api": "time()",
              "action_description": "Returns current time",
              "action_id": "get_current_time",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Pause execution",
              "intention_id": "pause_execution"
            },
            {
              "action_api": "os.getpid()",
              "action_description": "Retrieves process information",
              "action_id": "get_process_info",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect current username",
              "intention_id": "collect_current_username"
            },
            {
              "action_api": "self.is_pending()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "event.set()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "event",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for events",
              "intention_id": "wait_for_events"
            },
            {
              "action_api": "self.__thread_pool.is_active()",
              "action_description": "Lists all currently alive threads",
              "action_id": "list_threads",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for events",
              "intention_id": "wait_for_events"
            },
            {
              "action_api": "sleep(0.1)",
              "action_description": "Suspends execution",
              "action_id": "suspend_execution",
              "object": "0.1",
              "object_description": "Delay interval value",
              "object_id": "delay_interval",
              "intention_description": "Pause execution",
              "intention_id": "pause_execution"
            },
            {
              "action_api": "self._get_q_size_len(pid)",
              "action_description": "Retrieves process information",
              "action_id": "get_process_info",
              "object": "pid",
              "object_description": "Process ID",
              "object_id": "process_id",
              "intention_description": "Collect current username",
              "intention_id": "collect_current_username"
            },
            {
              "action_api": "self._get_internal_queue()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect user input",
              "intention_id": "collect_user_input"
            },
            {
              "action_api": "self._get_internal_queue(block=False)",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "block=False",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect user input",
              "intention_id": "collect_user_input"
            },
            {
              "action_api": "sleep(throttle_sleep)",
              "action_description": "Suspends execution",
              "action_id": "suspend_execution",
              "object": "throttle_sleep",
              "object_description": "Delay interval value",
              "object_id": "delay_interval",
              "intention_description": "Pause execution",
              "intention_id": "pause_execution"
            },
            {
              "action_api": "self._q_size.append(os.getpid())",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "os.getpid()",
              "object_description": "",
              "object_id": "",
              "intention_description": "Create child process",
              "intention_id": "create_child_process"
            },
            {
              "action_api": "pickle.dumps(obj)",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "obj",
              "object_description": "",
              "object_id": "",
              "intention_description": "Serialize data",
              "intention_id": "serialize_data"
            },
            {
              "action_api": "BackgroundMonitor.get_at_exit_state()",
              "action_description": "Registers function to be called at program exit",
              "action_id": "register_exit_function",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for events",
              "intention_id": "wait_for_events"
            },
            {
              "action_api": "self._q_put(obj)",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "obj",
              "object_description": "",
              "object_id": "",
              "intention_description": "Create child process",
              "intention_id": "create_child_process"
            },
            {
              "action_api": "self.__thread_pool.get().apply_async(self._q_put, args=(obj, False))",
              "action_description": "Submits function to thread pool",
              "action_id": "submit_thread_function",
              "object": "self._q_put, args=(obj, False)",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Run function in thread pool",
              "intention_id": "run_function_thread_pool"
            },
            {
              "action_api": "self._q_size.pop()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Delete file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "self._q.put(obj)",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "obj",
              "object_description": "",
              "object_id": "",
              "intention_description": "Create child process",
              "intention_id": "create_child_process"
            },
            {
              "action_api": "self._q_size.clear()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Delete file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "self._internal_q = ForkQueue()",
              "action_description": "Creates temporary directory and returns its path",
              "action_id": "create_temp_dir",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Create temporary directory",
              "intention_id": "create_temporary_directory"
            },
            {
              "action_api": "Thread(target=self._reader_daemon)",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=self._reader_daemon",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Run function in child process",
              "intention_id": "run_function_child_process"
            },
            {
              "action_api": "self._reader_thread.start()",
              "action_description": "Starts thread execution",
              "action_id": "start_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for events",
              "intention_id": "wait_for_events"
            },
            {
              "action_api": "sleep(0.2)",
              "action_description": "Suspends execution",
              "action_id": "suspend_execution",
              "object": "0.2",
              "object_description": "Delay interval value",
              "object_id": "delay_interval",
              "intention_description": "Pause execution",
              "intention_id": "pause_execution"
            },
            {
              "action_api": "sleep(1.0)",
              "action_description": "Suspends execution",
              "action_id": "suspend_execution",
              "object": "1.0",
              "object_description": "Delay interval value",
              "object_id": "delay_interval",
              "intention_description": "Pause execution",
              "intention_id": "pause_execution"
            },
            {
              "action_api": "self._internal_q.get(*args, **kwargs)",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "*args, **kwargs",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect user input",
              "intention_id": "collect_user_input"
            },
            {
              "action_api": "pickle.loads(obj)",
              "action_description": "Deserializes Python object from bytes",
              "action_id": "deserialize_from_bytes",
              "object": "obj",
              "object_description": "",
              "object_id": "",
              "intention_description": "Decode bytes to string",
              "intention_id": "decode_bytes_to_string"
            },
            {
              "action_api": "self._q.get()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect user input",
              "intention_id": "collect_user_input"
            },
            {
              "action_api": "self._internal_q.put(obj)",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "obj",
              "object_description": "",
              "object_id": "",
              "intention_description": "Create child process",
              "intention_id": "create_child_process"
            },
            {
              "action_api": "len(buf)",
              "action_description": "Retrieves process information",
              "action_id": "get_process_info",
              "object": "buf",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get file size",
              "intention_id": "get_file_size"
            },
            {
              "action_api": "struct.pack(\"!i\", n)",
              "action_description": "Packs values into bytes using specified format",
              "action_id": "pack_values",
              "object": "\"!i\", n",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "self._send(header + buf)",
              "action_description": "Sends data over socket connection",
              "action_id": "send_socket_data",
              "object": "header + buf",
              "object_description": "",
              "object_id": "",
              "intention_description": "Transmit file data to server",
              "intention_id": "transmit_file_data_server"
            }
          ]
        }
      ]
    }
  ]
}