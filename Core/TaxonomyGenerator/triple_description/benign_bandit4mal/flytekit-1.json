{
  "metadata": {
    "package_name": "flytekit-1",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign_bandit4mal/flytekit-1.16.0b6.json",
    "dataset_type": "benign_bandit4mal"
  },
  "code_files": [
    {
      "pyfile": "auth_client.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/flytekit-1.16.0b6/flytekit-1.16.0b6/flytekit/clients/auth/auth_client.py",
      "line_number": "370",
      "type_description": "B825:request",
      "context_snippet": "def get_creds_from_remote(self) -> Credentials:\n    \"\"\"\n    This is the entrypoint method. It will kickoff the full authentication\n    flow and trigger a web-browser to retrieve credentials. Because this\n    needs to open a port on localhost and may be called from a\n    multithreaded context (e.g. pyflyte register), this call may block\n    multiple threads and return a cached result for up to 60 seconds.\n    \"\"\"\n    # In the absence of globally-set token values, initiate the token request flow\n    with self._lock:\n        # Clear cache if it's been more than 60 seconds since the last check\n        cache_ttl_s = 60\n        if self._cached_credentials_ts is not None and self._cached_credentials_ts + cache_ttl_s < time.monotonic():\n            self._cached_credentials = None\n\n        if self._cached_credentials is not None:\n            return self._cached_credentials\n        q = Queue()\n\n        # First prepare the callback server in the background\n        server = self._create_callback_server()\n\n        self._request_authorization_code()\n\n        server.handle_request(q)\n        server.server_close()\n\n        # Send the call to request the authorization code in the background\n\n        # Request the access token once the auth code has been received.\n        auth_code = q.get()\n        self._cached_credentials = self._request_access_token(auth_code)\n        self._cached_credentials_ts = time.monotonic()\n        return self._cached_credentials",
      "hash_value": "25d51411ece8049ec4c26d13c1af28f8",
      "severity": "High",
      "confidence": "Medium",
      "code_snippets": [
        {
          "snippet": "def get_creds_from_remote(self) -> Credentials:\n    \"\"\"\n    This is the entrypoint method. It will kickoff the full authentication\n    flow and trigger a web-browser to retrieve credentials. Because this\n    needs to open a port on localhost and may be called from a\n    multithreaded context (e.g. pyflyte register), this call may block\n    multiple threads and return a cached result for up to 60 seconds.\n    \"\"\"\n    # In the absence of globally-set token values, initiate the token request flow\n    with self._lock:\n        # Clear cache if it's been more than 60 seconds since the last check\n        cache_ttl_s = 60\n        if self._cached_credentials_ts is not None and self._cached_credentials_ts + cache_ttl_s < time.monotonic():\n            self._cached_credentials = None\n\n        if self._cached_credentials is not None:\n            return self._cached_credentials\n        q = Queue()\n\n        # First prepare the callback server in the background\n        server = self._create_callback_server()\n\n        self._request_authorization_code()\n\n        server.handle_request(q)\n        server.server_close()\n\n        # Send the call to request the authorization code in the background\n\n        # Request the access token once the auth code has been received.\n        auth_code = q.get()\n        self._cached_credentials = self._request_access_token(auth_code)\n        self._cached_credentials_ts = time.monotonic()\n        return self._cached_credentials",
          "triple_sequences": [
            {
              "action_api": "time.monotonic()",
              "action_description": "Returns current time",
              "action_id": "get_current_time",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get datetime epoch",
              "intention_id": "get_datetime_epoch"
            },
            {
              "action_api": "Queue()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Concurrent_execution_preparation",
              "intention_id": "concurrent_execution_preparation"
            },
            {
              "action_api": "self._create_callback_server()",
              "action_description": "Creates new socket object",
              "action_id": "create_socket",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Establish connection",
              "intention_id": "establish_connection"
            },
            {
              "action_api": "self._request_authorization_code()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Connect remote server",
              "intention_id": "connect_remote_server"
            },
            {
              "action_api": "server.handle_request(q)",
              "action_description": "Receives data from socket connection",
              "action_id": "receive_socket_data",
              "object": "q",
              "object_description": "",
              "object_id": "",
              "intention_description": "Receive command from server",
              "intention_id": "receive_command_from_server"
            },
            {
              "action_api": "server.server_close()",
              "action_description": "Closes the socket connection",
              "action_id": "close_socket",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Release connection resource",
              "intention_id": "release_connection_resource"
            },
            {
              "action_api": "q.get()",
              "action_description": "Reads user input from standard input",
              "action_id": "read_user_input",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect user input",
              "intention_id": "collect_user_input"
            },
            {
              "action_api": "self._request_access_token(auth_code)",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "auth_code",
              "object_description": "API key or token",
              "object_id": "api_key",
              "intention_description": "Connect remote server",
              "intention_id": "connect_remote_server"
            },
            {
              "action_api": "time.monotonic()",
              "action_description": "Returns current time",
              "action_id": "get_current_time",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get datetime epoch",
              "intention_id": "get_datetime_epoch"
            }
          ]
        }
      ]
    }
  ]
}