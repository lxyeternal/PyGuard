{
  "metadata": {
    "package_name": "psycopg2-2",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/psycopg2-2.9.10.json",
    "dataset_type": "benign"
  },
  "code_files": [
    {
      "pyfile": "setup.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/psycopg2-2.9.10/psycopg2-2.9.10/setup.py",
      "line_number": "109",
      "type_description": "code-execution",
      "context_snippet": "import subprocess\n\nclass PostgresConfig:\n    def __init__(self, build_ext):\n        self.build_ext = build_ext\n        self.pg_config_exe = self.build_ext.pg_config\n        if not self.pg_config_exe:\n            self.pg_config_exe = self.autodetect_pg_config_path()\n        if self.pg_config_exe is None:\n            sys.stderr.write(\"\"\"\nError: pg_config executable not found.\n\npg_config is required to build psycopg2 from source.  Please add the directory\ncontaining pg_config to the $PATH or specify the full executable path with the\noption:\n\n    python setup.py build_ext --pg-config /path/to/pg_config build ...\n\nor with the pg_config option in 'setup.cfg'.\n\nIf you prefer to avoid building psycopg2 from source, please install the PyPI\n'psycopg2-binary' package instead.\n\nFor further information please check the 'doc/src/install.rst' file (also at\n<https://www.psycopg.org/docs/install.html>).\n\n\"\"\")\n            sys.exit(1)\n\n    def query(self, attr_name, *, empty_ok=False):\n        \"\"\"Spawn the pg_config executable, querying for the given config\n        name, and return the printed value, sanitized. \"\"\"\n        try:\n            pg_config_process = subprocess.run(\n                [self.pg_config_exe, \"--\" + attr_name],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE)\n        except OSError:\n            raise Warning(\n                f\"Unable to find 'pg_config' file in '{self.pg_config_exe}'\")\n        if pg_config_process.returncode:\n            err = pg_config_process.stderr.decode(errors='backslashreplace')\n            raise Warning(f\"pg_config --{attr_name} failed: {err}\")\n        result = pg_config_process.stdout.decode().strip()\n        if not result and not empty_ok:\n            raise Warning(f\"pg_config --{attr_name} is empty\")\n        return result\n\n    def find_on_path(self, exename, path_directories=None):\n        if not path_directories:\n            path_directories = os.environ['PATH'].split(os.pathsep)\n        for dir_name in path_directories:\n            fullpath = os.path.join(dir_name, exename)\n            if os.path.isfile(fullpath):\n                return fullpath\n        return None\n\n    def autodetect_pg_config_path(self):\n        \"\"\"Find and return the path to the pg_config executable.\"\"\"\n        if PLATFORM_IS_WINDOWS:\n            return self.autodetect_pg_config_path_windows()\n        else:\n            return self.find_on_path('pg_config')\n\n    def autodetect_pg_config_path_windows(self):\n        \"\"\"Attempt several different ways of finding the pg_config\n        executable on Windows, and return its full path, if found.\"\"\"\n\n        # This code only runs if they have not specified a pg_config option\n        # in the config file or via the commandline.\n\n        # First, check for pg_config.exe on the PATH, and use that if found.\n        pg_config_exe = self.find_on_path('pg_config.exe')\n        if pg_config_exe:\n            return pg_config_exe\n\n        # Now, try looking in the Windows Registry to find a PostgreSQL\n        # installation, and infer the path from that.\n        pg_config_exe = self._get_pg_config_from_registry()\n        if pg_config_exe:\n            return pg_config_exe\n\n        return None\n\n    def _get_pg_config_from_registry(self):\n        import winreg\n\n        reg = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)\n        try:\n            pg_inst_list_key = winreg.OpenKey(reg,\n                'SOFTWARE\\\\PostgreSQL\\\\Installations')\n        except OSError:\n            # No PostgreSQL installation, as best as we can tell.\n            return None\n\n        try:\n            # Determine the name of the first subkey, if any:\n            try:\n                first_sub_key_name = winreg.EnumKey(pg_inst_list_key, 0)\n            except OSError:\n                return None\n\n            pg_first_inst_key = winreg.OpenKey(reg,\n                'SOFTWARE\\\\PostgreSQL\\\\Installations\\\\' + first_sub_key_name)\n            try:\n                pg_inst_base_dir = winreg.QueryValueEx(\n                    pg_first_inst_key, 'Base Directory')[0]\n            finally:\n                winreg.CloseKey(pg_first_inst_key)\n\n        finally:\n            winreg.CloseKey(pg_inst_list_key)\n\n        pg_config_path = os.path.join(\n            pg_inst_base_dir, 'bin', 'pg_config.exe')\n        if not os.path.exists(pg_config_path):\n            return None\n\n        return pg_config_path",
      "hash_value": "8080409c475e2af8588b6048db56144f",
      "detection_index": 1,
      "code_snippets": [
        {
          "snippet": "import subprocess\n\nclass PostgresConfig:\n    def __init__(self, build_ext):\n        self.build_ext = build_ext\n        self.pg_config_exe = self.build_ext.pg_config\n        if not self.pg_config_exe:\n            self.pg_config_exe = self.autodetect_pg_config_path()\n        if self.pg_config_exe is None:\n            sys.stderr.write(\"\"\"\nError: pg_config executable not found.\n\npg_config is required to build psycopg2 from source.  Please add the directory\ncontaining pg_config to the $PATH or specify the full executable path with the\noption:\n\n    python setup.py build_ext --pg-config /path/to/pg_config build ...\n\nor with the pg_config option in 'setup.cfg'.\n\nIf you prefer to avoid building psycopg2 from source, please install the PyPI\n'psycopg2-binary' package instead.\n\nFor further information please check the 'doc/src/install.rst' file (also at\n<https://www.psycopg.org/docs/install.html>).\n\n\"\"\")\n            sys.exit(1)\n\n    def query(self, attr_name, *, empty_ok=False):\n        \"\"\"Spawn the pg_config executable, querying for the given config\n        name, and return the printed value, sanitized. \"\"\"\n        try:\n            pg_config_process = subprocess.run(\n                [self.pg_config_exe, \"--\" + attr_name],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE)\n        except OSError:\n            raise Warning(\n                f\"Unable to find 'pg_config' file in '{self.pg_config_exe}'\")\n        if pg_config_process.returncode:\n            err = pg_config_process.stderr.decode(errors='backslashreplace')\n            raise Warning(f\"pg_config --{attr_name} failed: {err}\")\n        result = pg_config_process.stdout.decode().strip()\n        if not result and not empty_ok:\n            raise Warning(f\"pg_config --{attr_name} is empty\")\n        return result\n\n    def find_on_path(self, exename, path_directories=None):\n        if not path_directories:\n            path_directories = os.environ['PATH'].split(os.pathsep)\n        for dir_name in path_directories:\n            fullpath = os.path.join(dir_name, exename)\n            if os.path.isfile(fullpath):\n                return fullpath\n        return None\n\n    def autodetect_pg_config_path(self):\n        \"\"\"Find and return the path to the pg_config executable.\"\"\"\n        if PLATFORM_IS_WINDOWS:\n            return self.autodetect_pg_config_path_windows()\n        else:\n            return self.find_on_path('pg_config')\n\n    def autodetect_pg_config_path_windows(self):\n        \"\"\"Attempt several different ways of finding the pg_config\n        executable on Windows, and return its full path, if found.\"\"\"\n\n        # This code only runs if they have not specified a pg_config option\n        # in the config file or via the commandline.\n\n        # First, check for pg_config.exe on the PATH, and use that if found.\n        pg_config_exe = self.find_on_path('pg_config.exe')\n        if pg_config_exe:\n            return pg_config_exe\n\n        # Now, try looking in the Windows Registry to find a PostgreSQL\n        # installation, and infer the path from that.\n        pg_config_exe = self._get_pg_config_from_registry()\n        if pg_config_exe:\n            return pg_config_exe\n\n        return None\n\n    def _get_pg_config_from_registry(self):\n        import winreg\n\n        reg = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)\n        try:\n            pg_inst_list_key = winreg.OpenKey(reg,\n                'SOFTWARE\\\\PostgreSQL\\\\Installations')\n        except OSError:\n            # No PostgreSQL installation, as best as we can tell.\n            return None\n\n        try:\n            # Determine the name of the first subkey, if any:\n            try:\n                first_sub_key_name = winreg.EnumKey(pg_inst_list_key, 0)\n            except OSError:\n                return None\n\n            pg_first_inst_key = winreg.OpenKey(reg,\n                'SOFTWARE\\\\PostgreSQL\\\\Installations\\\\' + first_sub_key_name)\n            try:\n                pg_inst_base_dir = winreg.QueryValueEx(\n                    pg_first_inst_key, 'Base Directory')[0]\n            finally:\n                winreg.CloseKey(pg_first_inst_key)\n\n        finally:\n            winreg.CloseKey(pg_inst_list_key)\n\n        pg_config_path = os.path.join(\n            pg_inst_base_dir, 'bin', 'pg_config.exe')\n        if not os.path.exists(pg_config_path):\n            return None\n\n        return pg_config_path",
          "triple_sequences": [
            {
              "action_api": "os.environ.__getitem__()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'PATH'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.pathsep",
              "action_description": "Retrieves operating system path separator",
              "action_id": "get_os_path_sep",
              "object": "",
              "object_description": "Directory path separator",
              "object_id": "directory_separator",
              "intention_description": "Prepare directory path",
              "intention_id": "prepare_directory_path"
            },
            {
              "action_api": "str.split()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "os.environ['PATH']",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Prepare directory path",
              "intention_id": "prepare_directory_path"
            },
            {
              "action_api": "os.path.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "dir_name, exename",
              "object_description": "Directory path and file name",
              "object_id": "directory_path_with_file",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            },
            {
              "action_api": "os.path.isfile()",
              "action_description": "Checks if specified path exists and is a file",
              "action_id": "check_file_is_file",
              "object": "fullpath",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "subprocess.run()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "[self.pg_config_exe, '--' + attr_name]",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Collect command output",
              "intention_id": "collect_command_output"
            },
            {
              "action_api": "pg_config_process.stderr.decode()",
              "action_description": "Decodes bytes using default codec",
              "action_id": "decode_bytes_default",
              "object": "pg_config_process.stderr",
              "object_description": "Command output",
              "object_id": "command_output",
              "intention_description": "Decode command output",
              "intention_id": "decode_command_output"
            },
            {
              "action_api": "pg_config_process.stdout.decode()",
              "action_description": "Decodes bytes using default codec",
              "action_id": "decode_bytes_default",
              "object": "pg_config_process.stdout",
              "object_description": "Command output",
              "object_id": "command_output",
              "intention_description": "Decode command output",
              "intention_id": "decode_command_output"
            },
            {
              "action_api": "str.strip()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "pg_config_process.stdout.decode()",
              "object_description": "Command output",
              "object_id": "command_output",
              "intention_description": "Prepare string for further processing",
              "intention_id": "prepare_string_processing"
            },
            {
              "action_api": "winreg.ConnectRegistry()",
              "action_description": "Opens registry key",
              "action_id": "open_registry_key",
              "object": "None, winreg.HKEY_LOCAL_MACHINE",
              "object_description": "Windows registry key",
              "object_id": "windows_registry_key",
              "intention_description": "Access Windows registry key",
              "intention_id": "access_registry_key"
            },
            {
              "action_api": "winreg.OpenKey()",
              "action_description": "Opens registry key",
              "action_id": "open_registry_key",
              "object": "reg, 'SOFTWARE\\\\PostgreSQL\\\\Installations'",
              "object_description": "Windows registry key",
              "object_id": "windows_registry_key",
              "intention_description": "Access Windows registry key",
              "intention_id": "access_registry_key"
            },
            {
              "action_api": "winreg.EnumKey()",
              "action_description": "Retrieves value and data type for registry value",
              "action_id": "get_registry_value",
              "object": "pg_inst_list_key, 0",
              "object_description": "Registry value",
              "object_id": "registry_value",
              "intention_description": "Access registry value",
              "intention_id": "access_registry_value"
            },
            {
              "action_api": "winreg.OpenKey()",
              "action_description": "Opens registry key",
              "action_id": "open_registry_key",
              "object": "reg, 'SOFTWARE\\\\PostgreSQL\\\\Installations\\\\' + first_sub_key_name",
              "object_description": "Windows registry key",
              "object_id": "windows_registry_key",
              "intention_description": "Access Windows registry key",
              "intention_id": "access_registry_key"
            },
            {
              "action_api": "winreg.QueryValueEx()",
              "action_description": "Retrieves value and data type for registry value",
              "action_id": "get_registry_value",
              "object": "pg_first_inst_key, 'Base Directory'",
              "object_description": "Registry value",
              "object_id": "registry_value",
              "intention_description": "Access registry value",
              "intention_id": "access_registry_value"
            },
            {
              "action_api": "winreg.CloseKey()",
              "action_description": "Closes the opened registry key",
              "action_id": "close_registry_key",
              "object": "pg_first_inst_key",
              "object_description": "Registry key handle",
              "object_id": "registry_key_handle",
              "intention_description": "Release system resource",
              "intention_id": "release_system_resource"
            },
            {
              "action_api": "winreg.CloseKey()",
              "action_description": "Closes the opened registry key",
              "action_id": "close_registry_key",
              "object": "pg_inst_list_key",
              "object_description": "Registry key handle",
              "object_id": "registry_key_handle",
              "intention_description": "Release system resource",
              "intention_id": "release_system_resource"
            },
            {
              "action_api": "os.path.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "pg_inst_base_dir, 'bin', 'pg_config.exe'",
              "object_description": "Directory path and file name",
              "object_id": "directory_path_with_file",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "pg_config_path",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            }
          ]
        }
      ]
    }
  ]
}