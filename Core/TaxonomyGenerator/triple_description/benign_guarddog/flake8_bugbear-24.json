{
  "metadata": {
    "package_name": "flake8_bugbear-24",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/flake8_bugbear-24.12.12.json",
    "dataset_type": "benign"
  },
  "code_files": [
    {
      "pyfile": "bugbear.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/flake8_bugbear-24.12.12/flake8_bugbear-24.12.12/bugbear.py",
      "line_number": "268",
      "type_description": "obfuscation",
      "context_snippet": "def _check_redundant_excepthandlers(names: Sequence[str], node, in_trystar):\n    # See if any of the given exception names could be removed, e.g. from:\n    #    (MyError, MyError)  # duplicate names\n    #    (MyError, BaseException)  # everything derives from the Base\n    #    (Exception, TypeError)  # builtins where one subclasses another\n    #    (IOError, OSError)  # IOError is an alias of OSError since Python3.3\n    # but note that other cases are impractical to handle from the AST.\n    # We expect this is mostly useful for users who do not have the\n    # builtin exception hierarchy memorised, and include a 'shadowed'\n    # subtype without realising that it's redundant.\n    good = sorted(set(names), key=names.index)\n    if \"BaseException\" in good:\n        good = [\"BaseException\"]\n    # Remove redundant exceptions that the automatic system either handles\n    # poorly (usually aliases) or can't be checked (e.g. it's not an\n    # built-in exception).\n    for primary, equivalents in B014_REDUNDANT_EXCEPTIONS.items():\n        if primary in good:\n            good = [g for g in good if g not in equivalents]\n\n    for name, other in itertools.permutations(tuple(good), 2):\n        if _typesafe_issubclass(\n            getattr(builtins, name, type), getattr(builtins, other, ())\n        ):\n            if name in good:\n                good.remove(name)\n    if good != names:\n        desc = good[0] if len(good) == 1 else \"({})\".format(\", \".join(good))\n        as_ = \" as \" + node.name if node.name is not None else \"\"\n        return B014(\n            node.lineno,\n            node.col_offset,\n            vars=(\", \".join(names), as_, desc, in_trystar),\n        )\n    return None",
      "hash_value": "a47df1f696d0f6a3efd2af71ba6b5453",
      "detection_index": 1,
      "code_snippets": [
        {
          "snippet": "def _check_redundant_excepthandlers(names: Sequence[str], node, in_trystar):\n    # See if any of the given exception names could be removed, e.g. from:\n    #    (MyError, MyError)  # duplicate names\n    #    (MyError, BaseException)  # everything derives from the Base\n    #    (Exception, TypeError)  # builtins where one subclasses another\n    #    (IOError, OSError)  # IOError is an alias of OSError since Python3.3\n    # but note that other cases are impractical to handle from the AST.\n    # We expect this is mostly useful for users who do not have the\n    # builtin exception hierarchy memorised, and include a 'shadowed'\n    # subtype without realising that it's redundant.\n    good = sorted(set(names), key=names.index)\n    if \"BaseException\" in good:\n        good = [\"BaseException\"]\n    # Remove redundant exceptions that the automatic system either handles\n    # poorly (usually aliases) or can't be checked (e.g. it's not an\n    # built-in exception).\n    for primary, equivalents in B014_REDUNDANT_EXCEPTIONS.items():\n        if primary in good:\n            good = [g for g in good if g not in equivalents]\n\n    for name, other in itertools.permutations(tuple(good), 2):\n        if _typesafe_issubclass(\n            getattr(builtins, name, type), getattr(builtins, other, ())\n        ):\n            if name in good:\n                good.remove(name)\n    if good != names:\n        desc = good[0] if len(good) == 1 else \"({})\".format(\", \".join(good))\n        as_ = \" as \" + node.name if node.name is not None else \"\"\n        return B014(\n            node.lineno,\n            node.col_offset,\n            vars=(\", \".join(names), as_, desc, in_trystar),\n        )\n    return None",
          "triple_sequences": [
            {
              "action_api": "sorted()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "set(names)",
              "object_description": "Character code array",
              "object_id": "character_code_array",
              "intention_description": "Prepare character processing",
              "intention_id": "prepare_character_processing"
            },
            {
              "action_api": "names.index",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "names",
              "object_description": "Character code array",
              "object_id": "character_code_array",
              "intention_description": "Prepare character processing",
              "intention_id": "prepare_character_processing"
            },
            {
              "action_api": "itertools.permutations()",
              "action_description": "Generate product of sequence",
              "action_id": "generate_sequence_product",
              "object": "tuple(good), 2",
              "object_description": "Character code array",
              "object_id": "character_code_array",
              "intention_description": "Generate product of sequence",
              "intention_id": "generate_sequence_product"
            },
            {
              "action_api": "getattr()",
              "action_description": "Access attribute value",
              "action_id": "access_attribute_value",
              "object": "builtins, name, type",
              "object_description": "Exception type name",
              "object_id": "exception_type",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "getattr()",
              "action_description": "Access attribute value",
              "action_id": "access_attribute_value",
              "object": "builtins, other, ()",
              "object_description": "Exception type name",
              "object_id": "exception_type",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "_typesafe_issubclass()",
              "action_description": "Check instance type",
              "action_id": "check_instance_type",
              "object": "getattr(builtins, name, type), getattr(builtins, other, ())",
              "object_description": "Exception type name",
              "object_id": "exception_type",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "good.remove()",
              "action_description": "Delete file",
              "action_id": "delete_file",
              "object": "name",
              "object_description": "Exception type name",
              "object_id": "exception_type",
              "intention_description": "Delete function from global namespace",
              "intention_id": "delete_function_global_namespace"
            },
            {
              "action_api": "B014()",
              "action_description": "Instantiates custom class",
              "action_id": "init_evil_class",
              "object": "node.lineno, node.col_offset, vars=(', '.join(names), as_, desc, in_trystar)",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            }
          ]
        }
      ]
    }
  ]
}