{
  "metadata": {
    "package_name": "pyglove-0",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyglove-0.4.5.dev202504100810.json",
    "dataset_type": "benign"
  },
  "code_files": [
    {
      "pyfile": "annotation_conversion.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyglove-0.4.5.dev202504100810/pyglove-0.4.5.dev202504100810/pyglove/core/typing/annotation_conversion.py",
      "line_number": "208",
      "type_description": "obfuscation",
      "context_snippet": "def _resolve(type_id: str):\n\n    def _as_forward_ref() -> typing.ForwardRef:\n      return typing.ForwardRef(type_id, False, parent_module)  # pytype: disable=not-callable\n\n    def _resolve_name(name: str, parent_obj: typing.Any):\n      if name == 'None':\n        return None, True\n      if parent_obj is not None and hasattr(parent_obj, name):\n        return getattr(parent_obj, name), False\n      if hasattr(builtins, name):\n        return getattr(builtins, name), True\n      if type_id == '...':\n        return ..., True\n      return utils.MISSING_VALUE, False\n\n    names = type_id.split('.')\n    if len(names) == 1:\n      reference, is_builtin = _resolve_name(names[0], parent_module)\n      if is_builtin:\n        return reference\n      if not is_builtin and (\n          # When reference is not found, we should treat it as a forward\n          # reference.\n          reference == utils.MISSING_VALUE\n          # When module is being reloaded, we should treat all non-builtin\n          # references as forward references.\n          or getattr(parent_module, '__reloading__', False)\n      ):\n        return _as_forward_ref()\n      return reference\n\n    root_obj, _ = _resolve_name(names[0], parent_module)\n    # When root object is not found, we should treat it as a forward reference.\n    if root_obj == utils.MISSING_VALUE:\n      return _as_forward_ref()\n\n    parent_obj = root_obj\n    # When root object is a module, we should treat reference to its children\n    # as non-forward references.\n    if inspect.ismodule(root_obj):\n      for name in names[1:]:\n        parent_obj, _ = _resolve_name(name, parent_obj)\n        if parent_obj == utils.MISSING_VALUE:\n          raise TypeError(f'{type_id!r} does not exist.')\n      return parent_obj\n    # When root object is non-module variable of current module, and when the\n    # module is being reloaded, we should treat reference to its children as\n    # forward references.\n    elif getattr(parent_module, '__reloading__', False):\n      return _as_forward_ref()\n    # When root object is non-module variable of current module, we should treat\n    # unresolved reference to its children as forward references.\n    else:\n      for name in names[1:]:\n        parent_obj, _ = _resolve_name(name, parent_obj)\n        if parent_obj == utils.MISSING_VALUE:\n          return _as_forward_ref()\n      return parent_obj",
      "hash_value": "e347d6dd44147b8fce2345c554a05f17",
      "detection_index": 1,
      "code_snippets": [
        {
          "snippet": "def _resolve(type_id: str):\n\n    def _as_forward_ref() -> typing.ForwardRef:\n      return typing.ForwardRef(type_id, False, parent_module)  # pytype: disable=not-callable\n\n    def _resolve_name(name: str, parent_obj: typing.Any):\n      if name == 'None':\n        return None, True\n      if parent_obj is not None and hasattr(parent_obj, name):\n        return getattr(parent_obj, name), False\n      if hasattr(builtins, name):\n        return getattr(builtins, name), True\n      if type_id == '...':\n        return ..., True\n      return utils.MISSING_VALUE, False\n\n    names = type_id.split('.')\n    if len(names) == 1:\n      reference, is_builtin = _resolve_name(names[0], parent_module)\n      if is_builtin:\n        return reference\n      if not is_builtin and (\n          # When reference is not found, we should treat it as a forward\n          # reference.\n          reference == utils.MISSING_VALUE\n          # When module is being reloaded, we should treat all non-builtin\n          # references as forward references.\n          or getattr(parent_module, '__reloading__', False)\n      ):\n        return _as_forward_ref()\n      return reference\n\n    root_obj, _ = _resolve_name(names[0], parent_module)\n    # When root object is not found, we should treat it as a forward reference.\n    if root_obj == utils.MISSING_VALUE:\n      return _as_forward_ref()\n\n    parent_obj = root_obj\n    # When root object is a module, we should treat reference to its children\n    # as non-forward references.\n    if inspect.ismodule(root_obj):\n      for name in names[1:]:\n        parent_obj, _ = _resolve_name(name, parent_obj)\n        if parent_obj == utils.MISSING_VALUE:\n          raise TypeError(f'{type_id!r} does not exist.')\n      return parent_obj\n    # When root object is non-module variable of current module, and when the\n    # module is being reloaded, we should treat reference to its children as\n    # forward references.\n    elif getattr(parent_module, '__reloading__', False):\n      return _as_forward_ref()\n    # When root object is non-module variable of current module, we should treat\n    # unresolved reference to its children as forward references.\n    else:\n      for name in names[1:]:\n        parent_obj, _ = _resolve_name(name, parent_obj)\n        if parent_obj == utils.MISSING_VALUE:\n          return _as_forward_ref()\n      return parent_obj",
          "triple_sequences": [
            {
              "action_api": "str.split()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "type_id",
              "object_description": "String containing environment data",
              "object_id": "string_environment_data",
              "intention_description": "Prepare string for further processing",
              "intention_id": "prepare_string_processing"
            },
            {
              "action_api": "hasattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "parent_obj, name",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "getattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "parent_obj, name",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "hasattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "builtins, name",
              "object_description": "Built-in module or package",
              "object_id": "builtin_module",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "getattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "builtins, name",
              "object_description": "Built-in module or package",
              "object_id": "builtin_module",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "getattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "parent_module, '__reloading__', False",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "typing.ForwardRef()",
              "action_description": "Dynamically imports specified module",
              "action_id": "import_dynamic",
              "object": "type_id, False, parent_module",
              "object_description": "Module name string",
              "object_id": "module_name_string",
              "intention_description": "Import module dynamically",
              "intention_id": "import_module_dynamically"
            },
            {
              "action_api": "inspect.ismodule()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "root_obj",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "raise TypeError",
              "action_description": "Raises HTTPError if response status code indicates error",
              "action_id": "raise_http_error",
              "object": "f'{type_id!r} does not exist.'",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Stop execution on invalid input",
              "intention_id": "stop_execution_invalid_input"
            }
          ]
        }
      ]
    }
  ]
}