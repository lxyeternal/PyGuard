{
  "metadata": {
    "package_name": "flask_cloudflared-0",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/flask_cloudflared-0.0.14.json",
    "dataset_type": "benign"
  },
  "code_files": [
    {
      "pyfile": "flask_cloudflared.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/flask_cloudflared-0.0.14/flask_cloudflared-0.0.14/flask_cloudflared.py",
      "line_number": "132",
      "type_description": "shady-links",
      "context_snippet": "import atexit\nimport requests\nimport subprocess\nimport tarfile\nimport tempfile\nimport shutil\nimport os\nimport platform\nimport time\nimport re\nfrom random import randint\nfrom threading import Timer\nfrom pathlib import Path\n\n# ... (CLOUDFLARED_CONFIG and helper functions omitted for brevity)\n\ndef _run_cloudflared(port, metrics_port, tunnel_id=None, config_path=None):\n    system, machine = platform.system(), platform.machine()\n    command = _get_command(system, machine)\n    cloudflared_path = str(Path(tempfile.gettempdir()))\n    if system == \"Darwin\":\n        _download_cloudflared(cloudflared_path, \"cloudflared-darwin-amd64.tgz\")\n        _extract_tarball(cloudflared_path, \"cloudflared-darwin-amd64.tgz\")\n    else:\n        _download_cloudflared(cloudflared_path, command)\n\n    executable = str(Path(cloudflared_path, command))\n    os.chmod(executable, 0o777)\n\n    cloudflared_command = [executable, 'tunnel', '--metrics', f'127.0.0.1:{metrics_port}']\n    if config_path:\n        cloudflared_command += ['--config', config_path, 'run']\n    elif tunnel_id:\n        cloudflared_command += ['--url', f'http://127.0.0.1:{port}', 'run', tunnel_id]\n    else:\n        cloudflared_command += ['--url', f'http://127.0.0.1:{port}']\n\n    if system == \"Darwin\" and machine == \"arm64\":\n        cloudflared = subprocess.Popen(['arch', '-x86_64'] + cloudflared_command, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n    else:\n        cloudflared = subprocess.Popen(cloudflared_command, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n\n    atexit.register(cloudflared.terminate)\n    localhost_url = f\"http://127.0.0.1:{metrics_port}/metrics\"\n\n    for _ in range(10):\n        try:\n            metrics = requests.get(localhost_url).text\n            if tunnel_id or config_path:\n                # If tunnel_id or config_path is provided, we check for cloudflared_tunnel_ha_connections, as no tunnel URL is available in the metrics\n                if re.search(\"cloudflared_tunnel_ha_connections\\s\\d\", metrics):\n                    # No tunnel URL is available in the metrics, so we return a generic text\n                    tunnel_url = \"preconfigured tunnel URL\"\n                    break\n            else:\n                # If neither tunnel_id nor config_path is provided, we check for the tunnel URL in the metrics\n                tunnel_url = (re.search(\"(?P<url>https?:\\/\\/[\\^\\s]+.trycloudflare.com)\", metrics).group(\"url\"))\n                break\n        except:\n            time.sleep(3)\n    else:\n        raise Exception(f\"! Can't connect to Cloudflare Edge\")\n\n    return tunnel_url",
      "hash_value": "af28a6bbe878e8756cd95250ab797bbd",
      "detection_index": 1,
      "code_snippets": [
        {
          "snippet": "import atexit\nimport requests\nimport subprocess\nimport tarfile\nimport tempfile\nimport shutil\nimport os\nimport platform\nimport time\nimport re\nfrom random import randint\nfrom threading import Timer\nfrom pathlib import Path\n\n# ... (CLOUDFLARED_CONFIG and helper functions omitted for brevity)\n\ndef _run_cloudflared(port, metrics_port, tunnel_id=None, config_path=None):\n    system, machine = platform.system(), platform.machine()\n    command = _get_command(system, machine)\n    cloudflared_path = str(Path(tempfile.gettempdir()))\n    if system == \"Darwin\":\n        _download_cloudflared(cloudflared_path, \"cloudflared-darwin-amd64.tgz\")\n        _extract_tarball(cloudflared_path, \"cloudflared-darwin-amd64.tgz\")\n    else:\n        _download_cloudflared(cloudflared_path, command)\n\n    executable = str(Path(cloudflared_path, command))\n    os.chmod(executable, 0o777)\n\n    cloudflared_command = [executable, 'tunnel', '--metrics', f'127.0.0.1:{metrics_port}']\n    if config_path:\n        cloudflared_command += ['--config', config_path, 'run']\n    elif tunnel_id:\n        cloudflared_command += ['--url', f'http://127.0.0.1:{port}', 'run', tunnel_id]\n    else:\n        cloudflared_command += ['--url', f'http://127.0.0.1:{port}']\n\n    if system == \"Darwin\" and machine == \"arm64\":\n        cloudflared = subprocess.Popen(['arch', '-x86_64'] + cloudflared_command, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n    else:\n        cloudflared = subprocess.Popen(cloudflared_command, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n\n    atexit.register(cloudflared.terminate)\n    localhost_url = f\"http://127.0.0.1:{metrics_port}/metrics\"\n\n    for _ in range(10):\n        try:\n            metrics = requests.get(localhost_url).text\n            if tunnel_id or config_path:\n                # If tunnel_id or config_path is provided, we check for cloudflared_tunnel_ha_connections, as no tunnel URL is available in the metrics\n                if re.search(\"cloudflared_tunnel_ha_connections\\s\\d\", metrics):\n                    # No tunnel URL is available in the metrics, so we return a generic text\n                    tunnel_url = \"preconfigured tunnel URL\"\n                    break\n            else:\n                # If neither tunnel_id nor config_path is provided, we check for the tunnel URL in the metrics\n                tunnel_url = (re.search(\"(?P<url>https?:\\/\\/[\\^\\s]+.trycloudflare.com)\", metrics).group(\"url\"))\n                break\n        except:\n            time.sleep(3)\n    else:\n        raise Exception(f\"! Can't connect to Cloudflare Edge\")\n\n    return tunnel_url",
          "triple_sequences": [
            {
              "action_api": "platform.system()",
              "action_description": "Retrieves operating system identifier",
              "action_id": "get_os_id",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine operating system",
              "intention_id": "determine_operating_system"
            },
            {
              "action_api": "platform.machine()",
              "action_description": "Retrieves machine type",
              "action_id": "get_machine_type",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Gather system information",
              "intention_id": "gather_system_information"
            },
            {
              "action_api": "tempfile.gettempdir()",
              "action_description": "Creates temporary directory and returns its path",
              "action_id": "create_temp_dir",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Collect temporary directory path",
              "intention_id": "collect_temp_directory_path"
            },
            {
              "action_api": "Path()",
              "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
              "action_id": "path_object_operations",
              "object": "tempfile.gettempdir()",
              "object_description": "Temporary directory",
              "object_id": "temporary_directory",
              "intention_description": "Prepare directory path",
              "intention_id": "prepare_directory_path"
            },
            {
              "action_api": "os.chmod()",
              "action_description": "Changes file mode to add execute permission",
              "action_id": "change_file_mode_execute",
              "object": "executable",
              "object_description": "Executable file",
              "object_id": "executable_file",
              "intention_description": "Modify file attributes",
              "intention_id": "modify_file_attributes"
            },
            {
              "action_api": "subprocess.Popen()",
              "action_description": "Spawns new process to execute command with shell access",
              "action_id": "spawn_process_shell",
              "object": "cloudflared_command",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Create child process",
              "intention_id": "create_child_process"
            },
            {
              "action_api": "atexit.register()",
              "action_description": "Registers function to be called at program exit",
              "action_id": "register_exit_function",
              "object": "cloudflared.terminate",
              "object_description": "Function and arguments",
              "object_id": "function_with_arguments",
              "intention_description": "Release system resource",
              "intention_id": "release_system_resource"
            },
            {
              "action_api": "requests.get()",
              "action_description": "Sends HTTP GET request to URL",
              "action_id": "open_url_get",
              "object": "http://127.0.0.1:{metrics_port}/metrics",
              "object_description": "Localhost address",
              "object_id": "localhost_address",
              "intention_description": "Download remote content",
              "intention_id": "download_remote_content"
            },
            {
              "action_api": "re.search()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "\"cloudflared_tunnel_ha_connections\\s\\d\", metrics",
              "object_description": "Regular expression and file content",
              "object_id": "regex_file_content",
              "intention_description": "Detect shortcut files",
              "intention_id": "detect_shortcut_files"
            },
            {
              "action_api": "re.search()",
              "action_description": "Compiles regular expression pattern",
              "action_id": "compile_regex",
              "object": "\"(?P<url>https?:\\/\\/[\\^\\s]+.trycloudflare.com)\", metrics",
              "object_description": "Regular expression and file content",
              "object_id": "regex_file_content",
              "intention_description": "Extract structured data from file",
              "intention_id": "extract_structured_file_data"
            },
            {
              "action_api": "time.sleep()",
              "action_description": "Suspends execution",
              "action_id": "suspend_execution",
              "object": "3",
              "object_description": "Delay duration in seconds",
              "object_id": "delay_duration",
              "intention_description": "Delay next operation",
              "intention_id": "delay_next_operation"
            }
          ]
        }
      ]
    }
  ]
}