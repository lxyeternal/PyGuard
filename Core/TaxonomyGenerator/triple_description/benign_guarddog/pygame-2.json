{
  "metadata": {
    "package_name": "pygame-2",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pygame-2.6.1.json",
    "dataset_type": "benign"
  },
  "code_files": [
    {
      "pyfile": "setup.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pygame-2.6.1/pygame-2.6.1/setup.py",
      "line_number": "126",
      "type_description": "code-execution",
      "context_snippet": "if os.environ.get('PYGAME_DETECT_AVX2', '') != '':\n    import distutils.ccompiler\n\n    avx2_filenames = ['simd_blitters_avx2']\n\n    compiler_options = {\n        'unix': ('-mavx2',),\n        'msvc': ('/arch:AVX2',)\n    }\n\n    def spawn(self, cmd, **kwargs):\n        should_use_avx2 = False\n        # try to be thorough in detecting that we are on a platform that potentially supports AVX2\n        machine_name = platform.machine()\n        if ((machine_name.startswith((\"x86\", \"i686\")) or\n            machine_name.lower() == \"amd64\") and\n                os.environ.get(\"MAC_ARCH\") != \"arm64\"):\n            should_use_avx2 = True\n\n        if should_use_avx2:\n            extra_options = compiler_options.get(self.compiler_type)\n            if extra_options is not None:\n                # filenames are closer to the end of command line\n                for argument in reversed(cmd):\n                    # Check if argument contains a filename. We must check for all\n                    # possible extensions; checking for target extension is faster.\n                    if not argument.endswith(self.obj_extension):\n                        continue\n\n                    # check for a filename only to avoid building a new string\n                    # with variable extension\n                    for filename in avx2_filenames:\n                        off_end = -len(self.obj_extension)\n                        off_start = -len(filename) + off_end\n                        if argument.endswith(filename, off_start, off_end):\n                            if self.compiler_type == 'bcpp':\n                                # Borland accepts a source file name at the end,\n                                # insert the options before it\n                                cmd[-1:-1] = extra_options\n                            else:\n                                cmd += extra_options\n\n                    # filename is found, no need to search any further\n                    break\n\n        distutils.ccompiler.spawn(cmd, dry_run=self.dry_run, **kwargs)\n\n    distutils.ccompiler.CCompiler.__spawn = distutils.ccompiler.CCompiler.spawn\n    distutils.ccompiler.CCompiler.spawn = spawn",
      "hash_value": "d7bdf7c3d4f16b4137ed03bc0447ef40",
      "detection_index": 1,
      "code_snippets": [
        {
          "snippet": "if os.environ.get('PYGAME_DETECT_AVX2', '') != '':\n    import distutils.ccompiler\n\n    avx2_filenames = ['simd_blitters_avx2']\n\n    compiler_options = {\n        'unix': ('-mavx2',),\n        'msvc': ('/arch:AVX2',)\n    }\n\n    def spawn(self, cmd, **kwargs):\n        should_use_avx2 = False\n        # try to be thorough in detecting that we are on a platform that potentially supports AVX2\n        machine_name = platform.machine()\n        if ((machine_name.startswith((\"x86\", \"i686\")) or\n            machine_name.lower() == \"amd64\") and\n                os.environ.get(\"MAC_ARCH\") != \"arm64\"):\n            should_use_avx2 = True\n\n        if should_use_avx2:\n            extra_options = compiler_options.get(self.compiler_type)\n            if extra_options is not None:\n                # filenames are closer to the end of command line\n                for argument in reversed(cmd):\n                    # Check if argument contains a filename. We must check for all\n                    # possible extensions; checking for target extension is faster.\n                    if not argument.endswith(self.obj_extension):\n                        continue\n\n                    # check for a filename only to avoid building a new string\n                    # with variable extension\n                    for filename in avx2_filenames:\n                        off_end = -len(self.obj_extension)\n                        off_start = -len(filename) + off_end\n                        if argument.endswith(filename, off_start, off_end):\n                            if self.compiler_type == 'bcpp':\n                                # Borland accepts a source file name at the end,\n                                # insert the options before it\n                                cmd[-1:-1] = extra_options\n                            else:\n                                cmd += extra_options\n\n                    # filename is found, no need to search any further\n                    break\n\n        distutils.ccompiler.spawn(cmd, dry_run=self.dry_run, **kwargs)\n\n    distutils.ccompiler.CCompiler.__spawn = distutils.ccompiler.CCompiler.spawn\n    distutils.ccompiler.CCompiler.spawn = spawn",
          "triple_sequences": [
            {
              "action_api": "os.environ.get()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'PYGAME_DETECT_AVX2'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "import distutils.ccompiler",
              "action_description": "Dynamically imports specified module",
              "action_id": "import_dynamic",
              "object": "distutils.ccompiler",
              "object_description": "Module name string",
              "object_id": "module_name_string",
              "intention_description": "Import module dynamically",
              "intention_id": "import_module_dynamically"
            },
            {
              "action_api": "platform.machine()",
              "action_description": "Retrieves machine type",
              "action_id": "get_machine_type",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get hardware UUID",
              "intention_id": "get_hardware_uuid"
            },
            {
              "action_api": "os.environ.get()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'MAC_ARCH'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "distutils.ccompiler.spawn()",
              "action_description": "Spawns new process to execute command without shell access",
              "action_id": "spawn_process_no_shell",
              "object": "cmd",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Execute command",
              "intention_id": "execute_command"
            },
            {
              "action_api": "distutils.ccompiler.CCompiler.__spawn = distutils.ccompiler.CCompiler.spawn",
              "action_description": "Sets attribute on builtins object",
              "action_id": "set_builtin_attr",
              "object": "distutils.ccompiler.CCompiler.__spawn",
              "object_description": "Attribute value",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "distutils.ccompiler.CCompiler.spawn = spawn",
              "action_description": "Sets attribute on builtins object",
              "action_id": "set_builtin_attr",
              "object": "distutils.ccompiler.CCompiler.spawn",
              "object_description": "Attribute value",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            }
          ]
        }
      ]
    }
  ]
}