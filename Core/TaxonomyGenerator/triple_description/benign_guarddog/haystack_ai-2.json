{
  "metadata": {
    "package_name": "haystack_ai-2",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/haystack_ai-2.12.1.json",
    "dataset_type": "benign"
  },
  "code_files": [
    {
      "pyfile": "type_serialization.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/haystack_ai-2.12.1/haystack_ai-2.12.1/haystack/utils/type_serialization.py",
      "line_number": "142",
      "type_description": "obfuscation",
      "context_snippet": "import builtins\nimport typing\nfrom haystack.core.errors import DeserializationError\n\ndef deserialize_type(type_str: str) -> Any:  # pylint: disable=too-many-return-statements\n    \"\"\"\n    Deserializes a type given its full import path as a string, including nested generic types.\n\n    This function will dynamically import the module if it's not already imported\n    and then retrieve the type object from it. It also handles nested generic types like\n    `typing.List[typing.Dict[int, str]]`.\n\n    :param type_str:\n        The string representation of the type's full import path.\n    :returns:\n        The deserialized type object.\n    :raises DeserializationError:\n        If the type cannot be deserialized due to missing module or type.\n    \"\"\"\n\n    type_mapping = {\n        list: typing.List,\n        dict: typing.Dict,\n        set: typing.Set,\n        tuple: typing.Tuple,\n        frozenset: typing.FrozenSet,\n    }\n\n    # Handle generics\n    if \"[\" in type_str and type_str.endswith(\"]\"):\n        main_type_str, generics_str = type_str.split(\"[\", 1)\n        generics_str = generics_str[:-1]\n\n        main_type = deserialize_type(main_type_str)\n        generic_args = [deserialize_type(arg) for arg in _parse_generic_args(generics_str)]\n\n        # Reconstruct\n        try:\n            if sys.version_info >= (3, 9) or repr(main_type).startswith(\"typing.\"):\n                return main_type[tuple(generic_args) if len(generic_args) > 1 else generic_args[0]]\n            else:\n                return type_mapping[main_type][tuple(generic_args) if len(generic_args) > 1 else generic_args[0]]\n        except (TypeError, AttributeError) as e:\n            raise DeserializationError(f\"Could not apply arguments {generic_args} to type {main_type}\") from e\n\n    # Handle non-generic types\n    # First, check if there's a module prefix\n    if \".\" in type_str:\n        parts = type_str.split(\".\")\n        module_name = \".\".join(parts[:-1])\n        type_name = parts[-1]\n\n        module = sys.modules.get(module_name)\n        if module is None:\n            try:\n                module = thread_safe_import(module_name)\n            except ImportError as e:\n                raise DeserializationError(f\"Could not import the module: {module_name}\") from e\n\n        # Get the class from the module\n        if hasattr(module, type_name):\n            return getattr(module, type_name)\n\n        raise DeserializationError(f\"Could not locate the type: {type_name} in the module: {module_name}\")\n\n    # No module prefix, check builtins and typing\n    # First check builtins\n    if hasattr(builtins, type_str):\n        return getattr(builtins, type_str)\n\n    # Then check typing\n    if hasattr(typing, type_str):\n        return getattr(typing, type_str)\n\n    # Special case for NoneType\n    if type_str == \"NoneType\":\n        return type(None)\n\n    # Special case for None\n    if type_str == \"None\":\n        return None\n\n    raise DeserializationError(f\"Could not deserialize type: {type_str}\")",
      "hash_value": "f99500deda7ceb92078c0dd3c5fcfc2b",
      "detection_index": 1,
      "code_snippets": [
        {
          "snippet": "import builtins\nimport typing\nfrom haystack.core.errors import DeserializationError\n\ndef deserialize_type(type_str: str) -> Any:  # pylint: disable=too-many-return-statements\n    \"\"\"\n    Deserializes a type given its full import path as a string, including nested generic types.\n\n    This function will dynamically import the module if it's not already imported\n    and then retrieve the type object from it. It also handles nested generic types like\n    `typing.List[typing.Dict[int, str]]`.\n\n    :param type_str:\n        The string representation of the type's full import path.\n    :returns:\n        The deserialized type object.\n    :raises DeserializationError:\n        If the type cannot be deserialized due to missing module or type.\n    \"\"\"\n\n    type_mapping = {\n        list: typing.List,\n        dict: typing.Dict,\n        set: typing.Set,\n        tuple: typing.Tuple,\n        frozenset: typing.FrozenSet,\n    }\n\n    # Handle generics\n    if \"[\" in type_str and type_str.endswith(\"]\"):\n        main_type_str, generics_str = type_str.split(\"[\", 1)\n        generics_str = generics_str[:-1]\n\n        main_type = deserialize_type(main_type_str)\n        generic_args = [deserialize_type(arg) for arg in _parse_generic_args(generics_str)]\n\n        # Reconstruct\n        try:\n            if sys.version_info >= (3, 9) or repr(main_type).startswith(\"typing.\"):\n                return main_type[tuple(generic_args) if len(generic_args) > 1 else generic_args[0]]\n            else:\n                return type_mapping[main_type][tuple(generic_args) if len(generic_args) > 1 else generic_args[0]]\n        except (TypeError, AttributeError) as e:\n            raise DeserializationError(f\"Could not apply arguments {generic_args} to type {main_type}\") from e\n\n    # Handle non-generic types\n    # First, check if there's a module prefix\n    if \".\" in type_str:\n        parts = type_str.split(\".\")\n        module_name = \".\".join(parts[:-1])\n        type_name = parts[-1]\n\n        module = sys.modules.get(module_name)\n        if module is None:\n            try:\n                module = thread_safe_import(module_name)\n            except ImportError as e:\n                raise DeserializationError(f\"Could not import the module: {module_name}\") from e\n\n        # Get the class from the module\n        if hasattr(module, type_name):\n            return getattr(module, type_name)\n\n        raise DeserializationError(f\"Could not locate the type: {type_name} in the module: {module_name}\")\n\n    # No module prefix, check builtins and typing\n    # First check builtins\n    if hasattr(builtins, type_str):\n        return getattr(builtins, type_str)\n\n    # Then check typing\n    if hasattr(typing, type_str):\n        return getattr(typing, type_str)\n\n    # Special case for NoneType\n    if type_str == \"NoneType\":\n        return type(None)\n\n    # Special case for None\n    if type_str == \"None\":\n        return None\n\n    raise DeserializationError(f\"Could not deserialize type: {type_str}\")",
          "triple_sequences": [
            {
              "action_api": "str.split()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "type_str.split(\"[\", 1)",
              "object_description": "String containing environment data",
              "object_id": "string_environment_data",
              "intention_description": "Prepare string for further processing",
              "intention_id": "prepare_string_processing"
            },
            {
              "action_api": "str.endswith()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "type_str.endswith(\"]\")",
              "object_description": "String containing environment data",
              "object_id": "string_environment_data",
              "intention_description": "Prepare string for further processing",
              "intention_id": "prepare_string_processing"
            },
            {
              "action_api": "deserialize_type()",
              "action_description": "Dynamically imports specified module",
              "action_id": "import_dynamic",
              "object": "main_type_str",
              "object_description": "Module name string",
              "object_id": "module_name_string",
              "intention_description": "Import module dynamically",
              "intention_id": "import_module_dynamically"
            },
            {
              "action_api": "_parse_generic_args()",
              "action_description": "Dynamically imports specified module",
              "action_id": "import_dynamic",
              "object": "generics_str",
              "object_description": "String containing environment data",
              "object_id": "string_environment_data",
              "intention_description": "Prepare string for further processing",
              "intention_id": "prepare_string_processing"
            },
            {
              "action_api": "deserialize_type()",
              "action_description": "Dynamically imports specified module",
              "action_id": "import_dynamic",
              "object": "arg",
              "object_description": "Module name string",
              "object_id": "module_name_string",
              "intention_description": "Import module dynamically",
              "intention_id": "import_module_dynamically"
            },
            {
              "action_api": "sys.version_info",
              "action_description": "Retrieves operating system version",
              "action_id": "get_os_version",
              "object": "sys.version_info",
              "object_description": "System info",
              "object_id": "system_info",
              "intention_description": "Get operating system version",
              "intention_id": "get_operating_system_version"
            },
            {
              "action_api": "repr()",
              "action_description": "Serializes Python object to JSON string",
              "action_id": "serialize_to_json",
              "object": "main_type",
              "object_description": "",
              "object_id": "",
              "intention_description": "Serialize data",
              "intention_id": "serialize_data"
            },
            {
              "action_api": "sys.modules.get()",
              "action_description": "Dynamically imports specified module",
              "action_id": "import_dynamic",
              "object": "module_name",
              "object_description": "Module name string",
              "object_id": "module_name_string",
              "intention_description": "Import module dynamically",
              "intention_id": "import_module_dynamically"
            },
            {
              "action_api": "thread_safe_import()",
              "action_description": "Dynamically imports specified module",
              "action_id": "import_dynamic",
              "object": "module_name",
              "object_description": "Module name string",
              "object_id": "module_name_string",
              "intention_description": "Import module dynamically",
              "intention_id": "import_module_dynamically"
            },
            {
              "action_api": "hasattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "module, type_name",
              "object_description": "Module name string",
              "object_id": "module_name_string",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "getattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "module, type_name",
              "object_description": "Module name string",
              "object_id": "module_name_string",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "hasattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "builtins, type_str",
              "object_description": "Built-in module or package",
              "object_id": "builtin_module",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "getattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "builtins, type_str",
              "object_description": "Built-in module or package",
              "object_id": "builtin_module",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "hasattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "typing, type_str",
              "object_description": "Module name string",
              "object_id": "module_name_string",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "getattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "typing, type_str",
              "object_description": "Module name string",
              "object_id": "module_name_string",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            }
          ]
        }
      ]
    }
  ]
}