{
  "metadata": {
    "package_name": "newrelic-10",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/newrelic-10.8.1.json",
    "dataset_type": "benign"
  },
  "code_files": [
    {
      "pyfile": "object_names.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/newrelic-10.8.1/newrelic-10.8.1/newrelic/common/object_names.py",
      "line_number": "274",
      "type_description": "obfuscation",
      "context_snippet": "import builtins\n\ndef expand_builtin_exception_name(name):\n    # Convert name to module:name format, if it's a builtin Exception.\n    # Otherwise, return it unchanged.\n\n    try:\n        exception = getattr(builtins, name)\n    except AttributeError:\n        pass\n    else:\n        if type(exception) is type and issubclass(exception, BaseException):\n            return callable_name(exception)\n\n    return name\n\ndef callable_name(object, separator=\":\"):  # noqa: A002\n    \"\"\"Returns a string name identifying the supplied object. This will be\n    of the form 'module:object_path'.\n\n    If object were a function, then the name would be 'module:function. If\n    a class, 'module:class'. If a member function, 'module:class.function'.\n\n    By default the separator between the module path and the object path is\n    ':' but can be overridden if necessary. The convention used by the\n    Python Agent is that of using a ':' so it is clearer which part is the\n    module name and which is the name of the object.\n\n    \"\"\"\n\n    # The details are the module name and path. Join them with\n    # the specified separator.\n\n    return separator.join(object_context(object))\n\ndef object_context(target):\n    \"\"\"Returns a tuple identifying the supplied object. This will be of\n    the form (module, object_path).\n\n    \"\"\"\n\n    # Check whether the target is a functools.partial so we\n    # can actually extract the contained function and use it.\n\n    if isinstance(target, functools.partial):\n        target = target.func\n\n    # Check whether we have previously calculated the name\n    # details for the target object and cached it against the\n    # actual target object.\n\n    details = getattr(target, \"_nr_object_path\", None)\n\n    # Disallow cache lookup for methods. In the case where the method\n    # is defined on a parent class, the name of the parent class is incorrectly\n    # returned. Avoid this by recalculating the details each time.\n\n    if details and not inspect.ismethod(target):\n        return details\n\n    # Check whether the object is actually one of our own\n    # wrapper classes. For these we use the convention that the\n    # attribute _nr_last_object refers to the wrapped object\n    # beneath the wrappers, there possibly being more than one\n    # wrapper. We use the wrapped object when deriving the name\n    # details and so bypass that chained calls that would need\n    # to occur through the wrappers to get the attributes of the\n    # original. For good measure, check that this wrapped object\n    # didn't have the name details cached against it already.\n\n    source = getattr(target, \"_nr_last_object\", None)\n\n    if source:\n        details = getattr(source, \"_nr_object_path\", None)\n\n        if details and not inspect.ismethod(source):\n            return details\n\n    else:\n        source = target\n\n    # If it wasn't cached we generate the name details and then\n    # attempt to cache them against the object.\n    details = _object_context(source)\n\n    try:\n        # If the original target is not the same as the source we\n        # derive the name details from, then we are dealing with\n        # a wrapper.\n\n        if target is not source:\n            # Although the original target could be a bound\n            # wrapper still cache it against it anyway, in case\n            # the bound wrapper is actually cached by the program\n            # and used more than the one time.\n\n            target._nr_object_path = details\n\n        # Finally attempt to cache the name details against what\n        # we derived them from. We may not be able to cache it if\n        # it is a type implemented as C code or an object with\n        # slots, which doesn't allow arbitrary addition of extra\n        # attributes. In that case, if we actually have to rely\n        # on the name details being cached against it and it fails,\n        # we have no choice but to recalculate them every time.\n        #\n        # XXX We could consider for the case where it fails\n        # storing it in a dictionary where the key is a weak\n        # function proxy with a callback to remove the entry if\n        # it ever expires. That would be another lookup we would\n        # have to make and we are already doing a lot so would\n        # have to properly benchmarks overhead before making that\n        # choice.\n\n        source._nr_object_path = details\n\n    except Exception:\n        pass\n\n    return details\n\ndef _object_context(object):  # noqa: A002\n    if inspect.ismethod(object):\n        # In Python 3, ismethod() returns True for bound methods. We\n        # need to distinguish between class methods and instance methods.\n        #\n        # First, test for class methods.\n\n        cname = getattr(object.__self__, \"__qualname__\", None)\n\n        # If it's not a class method, it must be an instance method.\n\n        if cname is None:\n            cname = object.__self__.__class__.__qualname__\n\n        path = f\"{cname}.{object.__name__}\"\n\n    else:\n        # For functions, the __qualname__ attribute gives us the name.\n        # This will be a qualified name including the context in which\n        # the function is defined in, such as an outer function in the\n        # case of a nested function.\n\n        path = getattr(object, \"__qualname__\", None)\n\n        # If there is no __qualname__ it should mean it is a type\n        # object of some sort. In this case we use the name from the\n        # __class__. That also can be nested so need to use the\n        # qualified name.\n\n        if path is None and hasattr(object, \"__class__\"):\n            path = object.__class__.__qualname__\n\n    # Now calculate the name of the module object is defined in.\n\n    owner = None\n\n    if inspect.ismethod(object):\n        if object.__self__ is not None:\n            cname = getattr(object.__self__, \"__name__\", None)\n            if cname is None:\n                owner = object.__self__.__class__  # bound method\n            else:\n                owner = object.__self__  # class method\n\n    mname = _module_name(owner or object)\n\n    return (mname, path)\n\ndef _module_name(object):  # noqa: A002\n    mname = None\n\n    # For the module name we first need to deal with the special\n    # case of getset and member descriptors. In this case we\n    # grab the module name from the class the descriptor was\n    # being used in which is held in __objclass__.\n\n    if hasattr(object, \"__objclass__\"):\n        mname = getattr(object.__objclass__, \"__module__\", None)\n\n    # The standard case is that we can just grab the __module__\n    # attribute from the object.\n\n    if mname is None:\n        mname = getattr(object, \"__module__\", None)\n\n    # An exception to that is builtins or any types which are\n    # implemented in C code. For that we need to grab the module\n    # name from the __class__. In doing this though, we need to\n    # ensure we check for case of a bound method. In that case\n    # we need to grab the module from the class of the instance\n    # to which the method is bound.\n\n    if mname is None:\n        self = getattr(object, \"__self__\", None)\n        if self is not None and hasattr(self, \"__class__\"):\n            mname = getattr(self.__class__, \"__module__\", None)\n\n    if mname is None and hasattr(object, \"__class__\"):\n        mname = getattr(object.__class__, \"__module__\", None)\n\n    # Finally, if the module name isn't in sys.modules, we will\n    # format it within '<>' to denote that it is a generated\n    # class of some sort where a fake namespace was used. This\n    # happens for example with namedtuple classes in Python 3.\n\n    if mname and mname not in sys.modules:\n        mname = f\"<{mname}>\"\n\n    # If unable to derive the module name, fallback to unknown.\n\n    if not mname:\n        mname = \"<unknown>\"\n\n    return mname\n",
      "hash_value": "389c56d26ce23f5ab71120b199d7fa22",
      "detection_index": 1,
      "code_snippets": [
        {
          "snippet": "import builtins\n\ndef expand_builtin_exception_name(name):\n    # Convert name to module:name format, if it's a builtin Exception.\n    # Otherwise, return it unchanged.\n\n    try:\n        exception = getattr(builtins, name)\n    except AttributeError:\n        pass\n    else:\n        if type(exception) is type and issubclass(exception, BaseException):\n            return callable_name(exception)\n\n    return name\n\ndef callable_name(object, separator=\":\"):  # noqa: A002\n    \"\"\"Returns a string name identifying the supplied object. This will be\n    of the form 'module:object_path'.\n\n    If object were a function, then the name would be 'module:function. If\n    a class, 'module:class'. If a member function, 'module:class.function'.\n\n    By default the separator between the module path and the object path is\n    ':' but can be overridden if necessary. The convention used by the\n    Python Agent is that of using a ':' so it is clearer which part is the\n    module name and which is the name of the object.\n\n    \"\"\"\n\n    # The details are the module name and path. Join them with\n    # the specified separator.\n\n    return separator.join(object_context(object))\n\ndef object_context(target):\n    \"\"\"Returns a tuple identifying the supplied object. This will be of\n    the form (module, object_path).\n\n    \"\"\"\n\n    # Check whether the target is a functools.partial so we\n    # can actually extract the contained function and use it.\n\n    if isinstance(target, functools.partial):\n        target = target.func\n\n    # Check whether we have previously calculated the name\n    # details for the target object and cached it against the\n    # actual target object.\n\n    details = getattr(target, \"_nr_object_path\", None)\n\n    # Disallow cache lookup for methods. In the case where the method\n    # is defined on a parent class, the name of the parent class is incorrectly\n    # returned. Avoid this by recalculating the details each time.\n\n    if details and not inspect.ismethod(target):\n        return details\n\n    # Check whether the object is actually one of our own\n    # wrapper classes. For these we use the convention that the\n    # attribute _nr_last_object refers to the wrapped object\n    # beneath the wrappers, there possibly being more than one\n    # wrapper. We use the wrapped object when deriving the name\n    # details and so bypass that chained calls that would need\n    # to occur through the wrappers to get the attributes of the\n    # original. For good measure, check that this wrapped object\n    # didn't have the name details cached against it already.\n\n    source = getattr(target, \"_nr_last_object\", None)\n\n    if source:\n        details = getattr(source, \"_nr_object_path\", None)\n\n        if details and not inspect.ismethod(source):\n            return details\n\n    else:\n        source = target\n\n    # If it wasn't cached we generate the name details and then\n    # attempt to cache them against the object.\n    details = _object_context(source)\n\n    try:\n        # If the original target is not the same as the source we\n        # derive the name details from, then we are dealing with\n        # a wrapper.\n\n        if target is not source:\n            # Although the original target could be a bound\n            # wrapper still cache it against it anyway, in case\n            # the bound wrapper is actually cached by the program\n            # and used more than the one time.\n\n            target._nr_object_path = details\n\n        # Finally attempt to cache the name details against what\n        # we derived them from. We may not be able to cache it if\n        # it is a type implemented as C code or an object with\n        # slots, which doesn't allow arbitrary addition of extra\n        # attributes. In that case, if we actually have to rely\n        # on the name details being cached against it and it fails,\n        # we have no choice but to recalculate them every time.\n        #\n        # XXX We could consider for the case where it fails\n        # storing it in a dictionary where the key is a weak\n        # function proxy with a callback to remove the entry if\n        # it ever expires. That would be another lookup we would\n        # have to make and we are already doing a lot so would\n        # have to properly benchmarks overhead before making that\n        # choice.\n\n        source._nr_object_path = details\n\n    except Exception:\n        pass\n\n    return details\n\ndef _object_context(object):  # noqa: A002\n    if inspect.ismethod(object):\n        # In Python 3, ismethod() returns True for bound methods. We\n        # need to distinguish between class methods and instance methods.\n        #\n        # First, test for class methods.\n\n        cname = getattr(object.__self__, \"__qualname__\", None)\n\n        # If it's not a class method, it must be an instance method.\n\n        if cname is None:\n            cname = object.__self__.__class__.__qualname__\n\n        path = f\"{cname}.{object.__name__}\"\n\n    else:\n        # For functions, the __qualname__ attribute gives us the name.\n        # This will be a qualified name including the context in which\n        # the function is defined in, such as an outer function in the\n        # case of a nested function.\n\n        path = getattr(object, \"__qualname__\", None)\n\n        # If there is no __qualname__ it should mean it is a type\n        # object of some sort. In this case we use the name from the\n        # __class__. That also can be nested so need to use the\n        # qualified name.\n\n        if path is None and hasattr(object, \"__class__\"):\n            path = object.__class__.__qualname__\n\n    # Now calculate the name of the module object is defined in.\n\n    owner = None\n\n    if inspect.ismethod(object):\n        if object.__self__ is not None:\n            cname = getattr(object.__self__, \"__name__\", None)\n            if cname is None:\n                owner = object.__self__.__class__  # bound method\n            else:\n                owner = object.__self__  # class method\n\n    mname = _module_name(owner or object)\n\n    return (mname, path)\n\ndef _module_name(object):  # noqa: A002\n    mname = None\n\n    # For the module name we first need to deal with the special\n    # case of getset and member descriptors. In this case we\n    # grab the module name from the class the descriptor was\n    # being used in which is held in __objclass__.\n\n    if hasattr(object, \"__objclass__\"):\n        mname = getattr(object.__objclass__, \"__module__\", None)\n\n    # The standard case is that we can just grab the __module__\n    # attribute from the object.\n\n    if mname is None:\n        mname = getattr(object, \"__module__\", None)\n\n    # An exception to that is builtins or any types which are\n    # implemented in C code. For that we need to grab the module\n    # name from the __class__. In doing this though, we need to\n    # ensure we check for case of a bound method. In that case\n    # we need to grab the module from the class of the instance\n    # to which the method is bound.\n\n    if mname is None:\n        self = getattr(object, \"__self__\", None)\n        if self is not None and hasattr(self, \"__class__\"):\n            mname = getattr(self.__class__, \"__module__\", None)\n\n    if mname is None and hasattr(object, \"__class__\"):\n        mname = getattr(object.__class__, \"__module__\", None)\n\n    # Finally, if the module name isn't in sys.modules, we will\n    # format it within '<>' to denote that it is a generated\n    # class of some sort where a fake namespace was used. This\n    # happens for example with namedtuple classes in Python 3.\n\n    if mname and mname not in sys.modules:\n        mname = f\"<{mname}>\"\n\n    # If unable to derive the module name, fallback to unknown.\n\n    if not mname:\n        mname = \"<unknown>\"\n\n    return mname\n",
          "triple_sequences": [
            {
              "action_api": "getattr()",
              "action_description": "Retrieves value of attribute from object",
              "action_id": "access_attribute_value",
              "object": "builtins, name",
              "object_description": "Built-in module or package",
              "object_id": "builtin_module",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "type()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "exception",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine presence of required module",
              "intention_id": "determine_required_module_presence"
            },
            {
              "action_api": "issubclass()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "exception, BaseException",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine presence of required module",
              "intention_id": "determine_required_module_presence"
            },
            {
              "action_api": "callable_name()",
              "action_description": "Constructs Python code string",
              "action_id": "construct_python_code",
              "object": "exception",
              "object_description": "Exception type name",
              "object_id": "exception_type",
              "intention_description": "Construct Python code string",
              "intention_id": "construct_python_code"
            },
            {
              "action_api": "separator.join()",
              "action_description": "Joins characters into string",
              "action_id": "join_characters_into_string",
              "object": "object_context(object)",
              "object_description": "",
              "object_id": "",
              "intention_description": "Join characters into string",
              "intention_id": "join_characters_into_string"
            },
            {
              "action_api": "object_context()",
              "action_description": "Constructs Python code string",
              "action_id": "construct_python_code",
              "object": "object",
              "object_description": "",
              "object_id": "",
              "intention_description": "Construct Python code string",
              "intention_id": "construct_python_code"
            },
            {
              "action_api": "isinstance()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "target, functools.partial",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine presence of required module",
              "intention_id": "determine_required_module_presence"
            },
            {
              "action_api": "getattr()",
              "action_description": "Retrieves value of attribute from object",
              "action_id": "access_attribute_value",
              "object": "target, '_nr_object_path', None",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "inspect.ismethod()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "target",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine presence of required module",
              "intention_id": "determine_required_module_presence"
            },
            {
              "action_api": "getattr()",
              "action_description": "Retrieves value of attribute from object",
              "action_id": "access_attribute_value",
              "object": "target, '_nr_last_object', None",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "getattr()",
              "action_description": "Retrieves value of attribute from object",
              "action_id": "access_attribute_value",
              "object": "source, '_nr_object_path', None",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "inspect.ismethod()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "source",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine presence of required module",
              "intention_id": "determine_required_module_presence"
            },
            {
              "action_api": "_object_context()",
              "action_description": "Constructs Python code string",
              "action_id": "construct_python_code",
              "object": "source",
              "object_description": "",
              "object_id": "",
              "intention_description": "Construct Python code string",
              "intention_id": "construct_python_code"
            },
            {
              "action_api": "setattr()",
              "action_description": "Sets attribute on builtins object",
              "action_id": "set_builtin_attr",
              "object": "target, '_nr_object_path', details",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "setattr()",
              "action_description": "Sets attribute on builtins object",
              "action_id": "set_builtin_attr",
              "object": "source, '_nr_object_path', details",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "inspect.ismethod()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "object",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine presence of required module",
              "intention_id": "determine_required_module_presence"
            },
            {
              "action_api": "getattr()",
              "action_description": "Retrieves value of attribute from object",
              "action_id": "access_attribute_value",
              "object": "object.__self__, '__qualname__', None",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "getattr()",
              "action_description": "Retrieves value of attribute from object",
              "action_id": "access_attribute_value",
              "object": "object.__self__, '__class__', None",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "getattr()",
              "action_description": "Retrieves value of attribute from object",
              "action_id": "access_attribute_value",
              "object": "object, '__name__', None",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "getattr()",
              "action_description": "Retrieves value of attribute from object",
              "action_id": "access_attribute_value",
              "object": "object, '__qualname__', None",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "hasattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "object, '__class__'",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine presence of required module",
              "intention_id": "determine_required_module_presence"
            },
            {
              "action_api": "getattr()",
              "action_description": "Retrieves value of attribute from object",
              "action_id": "access_attribute_value",
              "object": "object.__class__, '__qualname__'",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "getattr()",
              "action_description": "Retrieves value of attribute from object",
              "action_id": "access_attribute_value",
              "object": "object, '__self__', None",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "getattr()",
              "action_description": "Retrieves value of attribute from object",
              "action_id": "access_attribute_value",
              "object": "object.__self__, '__name__', None",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "getattr()",
              "action_description": "Retrieves value of attribute from object",
              "action_id": "access_attribute_value",
              "object": "object.__self__, '__class__', None",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "_module_name()",
              "action_description": "Constructs Python code string",
              "action_id": "construct_python_code",
              "object": "owner or object",
              "object_description": "",
              "object_id": "",
              "intention_description": "Construct Python code string",
              "intention_id": "construct_python_code"
            },
            {
              "action_api": "hasattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "object, '__objclass__'",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine presence of required module",
              "intention_id": "determine_required_module_presence"
            },
            {
              "action_api": "getattr()",
              "action_description": "Retrieves value of attribute from object",
              "action_id": "access_attribute_value",
              "object": "object.__objclass__, '__module__', None",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "getattr()",
              "action_description": "Retrieves value of attribute from object",
              "action_id": "access_attribute_value",
              "object": "object, '__module__', None",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "getattr()",
              "action_description": "Retrieves value of attribute from object",
              "action_id": "access_attribute_value",
              "object": "object, '__self__', None",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "hasattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "self, '__class__'",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine presence of required module",
              "intention_id": "determine_required_module_presence"
            },
            {
              "action_api": "getattr()",
              "action_description": "Retrieves value of attribute from object",
              "action_id": "access_attribute_value",
              "object": "self.__class__, '__module__', None",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "hasattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "object, '__class__'",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine presence of required module",
              "intention_id": "determine_required_module_presence"
            },
            {
              "action_api": "getattr()",
              "action_description": "Retrieves value of attribute from object",
              "action_id": "access_attribute_value",
              "object": "object.__class__, '__module__', None",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            }
          ]
        }
      ]
    }
  ]
}