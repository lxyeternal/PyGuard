{
  "metadata": {
    "package_name": "pure_eval-0",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pure_eval-0.2.3.json",
    "dataset_type": "benign"
  },
  "code_files": [
    {
      "pyfile": "core.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pure_eval-0.2.3/pure_eval-0.2.3/pure_eval/core.py",
      "line_number": "418",
      "type_description": "obfuscation",
      "context_snippet": "def is_expression_interesting(node: ast.expr, value: Any) -> bool:\n    \"\"\"\n    Determines if an expression is potentially interesting, at least in my opinion.\n    Returns False for the following expressions whose value is generally obvious:\n        - Literals (e.g. 123, 'abc', [1, 2, 3], {'a': (), 'b': ([1, 2], [3])})\n        - Variables or attributes whose name is equal to the value's __name__.\n            For example, a function `def foo(): ...` is not interesting when referred to\n            as `foo` as it usually would, but `bar` can be interesting if `bar is foo`.\n            Similarly the method `self.foo` is not interesting.\n        - Builtins (e.g. `len`) referred to by their usual name.\n\n    This is a low level API, typically you will use `interesting_expressions_grouped`.\n\n    :param node: an AST expression\n    :param value: the value of the node\n    :return: a boolean: True if the expression is interesting, False otherwise\n    \"\"\"\n\n    with suppress(ValueError):\n        ast.literal_eval(node)\n        return False\n\n    # TODO exclude inner modules, e.g. numpy.random.__name__ == 'numpy.random' != 'random'\n    # TODO exclude common module abbreviations, e.g. numpy as np, pandas as pd\n    if has_ast_name(value, node):\n        return False\n\n    if (\n            isinstance(node, ast.Name)\n            and getattr(builtins, node.id, object()) is value\n    ):\n        return False\n\n    return True",
      "hash_value": "a16dd15063ef85153a088014cc0138f9",
      "detection_index": 1,
      "code_snippets": [
        {
          "snippet": "def is_expression_interesting(node: ast.expr, value: Any) -> bool:\n    \"\"\"\n    Determines if an expression is potentially interesting, at least in my opinion.\n    Returns False for the following expressions whose value is generally obvious:\n        - Literals (e.g. 123, 'abc', [1, 2, 3], {'a': (), 'b': ([1, 2], [3])})\n        - Variables or attributes whose name is equal to the value's __name__.\n            For example, a function `def foo(): ...` is not interesting when referred to\n            as `foo` as it usually would, but `bar` can be interesting if `bar is foo`.\n            Similarly the method `self.foo` is not interesting.\n        - Builtins (e.g. `len`) referred to by their usual name.\n\n    This is a low level API, typically you will use `interesting_expressions_grouped`.\n\n    :param node: an AST expression\n    :param value: the value of the node\n    :return: a boolean: True if the expression is interesting, False otherwise\n    \"\"\"\n\n    with suppress(ValueError):\n        ast.literal_eval(node)\n        return False\n\n    # TODO exclude inner modules, e.g. numpy.random.__name__ == 'numpy.random' != 'random'\n    # TODO exclude common module abbreviations, e.g. numpy as np, pandas as pd\n    if has_ast_name(value, node):\n        return False\n\n    if (\n            isinstance(node, ast.Name)\n            and getattr(builtins, node.id, object()) is value\n    ):\n        return False\n\n    return True",
          "triple_sequences": [
            {
              "action_api": "ast.literal_eval()",
              "action_description": "Compiles source code string into executable code object",
              "action_id": "compile_code_object",
              "object": "node",
              "object_description": "",
              "object_id": "",
              "intention_description": "Decode obfuscated code content",
              "intention_id": "decode_obfuscated_code"
            },
            {
              "action_api": "has_ast_name()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "value, node",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine presence of required module",
              "intention_id": "determine_required_module_presence"
            },
            {
              "action_api": "isinstance()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "node, ast.Name",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine presence of required module",
              "intention_id": "determine_required_module_presence"
            },
            {
              "action_api": "getattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "builtins, node.id, object()",
              "object_description": "Built-in module or package",
              "object_id": "builtin_module",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            }
          ]
        }
      ]
    }
  ]
}