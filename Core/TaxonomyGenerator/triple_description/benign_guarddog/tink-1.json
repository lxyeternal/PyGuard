{
  "metadata": {
    "package_name": "tink-1",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/tink-1.11.0.json",
    "dataset_type": "benign"
  },
  "code_files": [
    {
      "pyfile": "setup.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/tink-1.11.0/tink-1.11.0/setup.py",
      "line_number": "145",
      "type_description": "code-execution",
      "context_snippet": "class BuildBazelExtension(build_ext.build_ext):\n  \"\"\"A command that runs Bazel to build a C/C++ extension.\"\"\"\n\n  def __init__(self, dist: str) -> None:\n    super().__init__(dist)\n    self.bazel_command = _get_bazel_command()\n\n  def run(self) -> None:\n    for ext in self.extensions:\n      self.bazel_build(ext)\n    build_ext.build_ext.run(self)\n\n  def bazel_build(self, ext: str) -> None:\n    if not os.path.exists(self.build_temp):\n      os.makedirs(self.build_temp)\n\n    # Ensure no artifacts from previous builds are reused (i.e. from builds\n    # using a different Python version).\n    self.spawn([self.bazel_command, 'clean', '--expunge'])\n\n    bazel_startup_args = []\n    bazel_build_args = [\n        'build',\n        ext.bazel_target,\n        '--compilation_mode=' + ('dbg' if self.debug else 'opt'),\n    ]\n\n    target_arch = os.getenv('TARGET_ARCH', '')\n    target_os = os.getenv('TARGET_OS', '')\n    if target_arch and target_os:\n      bazel_build_args += [f'--config={target_os}_{target_arch}']\n\n    lib_extension = '.so'\n    if platform.system() == 'Windows':\n      # Required to build protobuf. See\n      # https://github.com/protocolbuffers/protobuf/issues/12947\n      bazel_startup_args += [r'--output_base=C:\\O']\n      # Needed by pybind11_bazel.\n      os.environ['PYTHON_BIN_PATH'] = sys.executable\n      os.environ['PYTHON_LIB_PATH'] = os.path.join(sys.exec_prefix, 'lib')\n      lib_extension = '.pyd'\n\n    if 'TINK_PYTHON_BAZEL_REMOTE_CACHE_GCS_BUCKET_URL' in os.environ:\n      if 'TINK_PYTHON_BAZEL_REMOTE_CACHE_SERVICE_KEY_PATH' not in os.environ:\n        raise ValueError(\n            'TINK_PYTHON_BAZEL_REMOTE_CACHE_SERVICE_KEY_PATH must be set.'\n        )\n      remote_cache_gcs_bucket_url = os.environ[\n          'TINK_PYTHON_BAZEL_REMOTE_CACHE_GCS_BUCKET_URL'\n      ]\n      remote_cache_gcs_service_key_path = os.path.abspath(\n          os.environ['TINK_PYTHON_BAZEL_REMOTE_CACHE_SERVICE_KEY_PATH']\n      )\n      bazel_build_args += [\n          f'--remote_cache={remote_cache_gcs_bucket_url}',\n          f'--google_credentials={remote_cache_gcs_service_key_path}',\n      ]\n\n    # Run build command.\n    self.spawn([self.bazel_command] + bazel_startup_args + bazel_build_args)\n\n    ext_bazel_bin_path = os.path.join(\n        'bazel-bin', ext.relpath, ext.target_name + lib_extension\n    )\n    ext_dest_path = self.get_ext_fullpath(ext.name)\n    ext_dest_dir = os.path.dirname(ext_dest_path)\n    if not os.path.exists(ext_dest_dir):\n      os.makedirs(ext_dest_dir)\n    shutil.copyfile(ext_bazel_bin_path, ext_dest_path)\n\n# Helper function used in __init__\ndef _get_bazel_command() -> str:\n  \"\"\"Finds the bazel command.\"\"\"\n  if shutil.which('bazelisk'):\n    return 'bazelisk'\n  elif shutil.which('bazel'):\n    return 'bazel'\n  raise FileNotFoundError(\n      'Could not find bazel executable. Please install '\n      'bazel to compile the Tink Python package.'\n  )",
      "hash_value": "fc0c9f45dd5bd0b8fc1a4b062c598c0b",
      "detection_index": 1,
      "code_snippets": [
        {
          "snippet": "class BuildBazelExtension(build_ext.build_ext):\n  \"\"\"A command that runs Bazel to build a C/C++ extension.\"\"\"\n\n  def __init__(self, dist: str) -> None:\n    super().__init__(dist)\n    self.bazel_command = _get_bazel_command()\n\n  def run(self) -> None:\n    for ext in self.extensions:\n      self.bazel_build(ext)\n    build_ext.build_ext.run(self)\n\n  def bazel_build(self, ext: str) -> None:\n    if not os.path.exists(self.build_temp):\n      os.makedirs(self.build_temp)\n\n    # Ensure no artifacts from previous builds are reused (i.e. from builds\n    # using a different Python version).\n    self.spawn([self.bazel_command, 'clean', '--expunge'])\n\n    bazel_startup_args = []\n    bazel_build_args = [\n        'build',\n        ext.bazel_target,\n        '--compilation_mode=' + ('dbg' if self.debug else 'opt'),\n    ]\n\n    target_arch = os.getenv('TARGET_ARCH', '')\n    target_os = os.getenv('TARGET_OS', '')\n    if target_arch and target_os:\n      bazel_build_args += [f'--config={target_os}_{target_arch}']\n\n    lib_extension = '.so'\n    if platform.system() == 'Windows':\n      # Required to build protobuf. See\n      # https://github.com/protocolbuffers/protobuf/issues/12947\n      bazel_startup_args += [r'--output_base=C:\\O']\n      # Needed by pybind11_bazel.\n      os.environ['PYTHON_BIN_PATH'] = sys.executable\n      os.environ['PYTHON_LIB_PATH'] = os.path.join(sys.exec_prefix, 'lib')\n      lib_extension = '.pyd'\n\n    if 'TINK_PYTHON_BAZEL_REMOTE_CACHE_GCS_BUCKET_URL' in os.environ:\n      if 'TINK_PYTHON_BAZEL_REMOTE_CACHE_SERVICE_KEY_PATH' not in os.environ:\n        raise ValueError(\n            'TINK_PYTHON_BAZEL_REMOTE_CACHE_SERVICE_KEY_PATH must be set.'\n        )\n      remote_cache_gcs_bucket_url = os.environ[\n          'TINK_PYTHON_BAZEL_REMOTE_CACHE_GCS_BUCKET_URL'\n      ]\n      remote_cache_gcs_service_key_path = os.path.abspath(\n          os.environ['TINK_PYTHON_BAZEL_REMOTE_CACHE_SERVICE_KEY_PATH']\n      )\n      bazel_build_args += [\n          f'--remote_cache={remote_cache_gcs_bucket_url}',\n          f'--google_credentials={remote_cache_gcs_service_key_path}',\n      ]\n\n    # Run build command.\n    self.spawn([self.bazel_command] + bazel_startup_args + bazel_build_args)\n\n    ext_bazel_bin_path = os.path.join(\n        'bazel-bin', ext.relpath, ext.target_name + lib_extension\n    )\n    ext_dest_path = self.get_ext_fullpath(ext.name)\n    ext_dest_dir = os.path.dirname(ext_dest_path)\n    if not os.path.exists(ext_dest_dir):\n      os.makedirs(ext_dest_dir)\n    shutil.copyfile(ext_bazel_bin_path, ext_dest_path)\n\n# Helper function used in __init__\ndef _get_bazel_command() -> str:\n  \"\"\"Finds the bazel command.\"\"\"\n  if shutil.which('bazelisk'):\n    return 'bazelisk'\n  elif shutil.which('bazel'):\n    return 'bazel'\n  raise FileNotFoundError(\n      'Could not find bazel executable. Please install '\n      'bazel to compile the Tink Python package.'\n  )",
          "triple_sequences": [
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "self.build_temp",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "os.makedirs()",
              "action_description": "Creates directory, ignoring if it already exists",
              "action_id": "create_directory",
              "object": "self.build_temp",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Ensure directory exists",
              "intention_id": "ensure_directory_exists"
            },
            {
              "action_api": "self.spawn()",
              "action_description": "Spawns new process to execute command with shell access",
              "action_id": "spawn_process_shell",
              "object": "[self.bazel_command, 'clean', '--expunge']",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Execute command",
              "intention_id": "execute_command"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'TARGET_ARCH', ''",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'TARGET_OS', ''",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "platform.system()",
              "action_description": "Retrieves operating system identifier",
              "action_id": "get_os_id",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get operating system name",
              "intention_id": "get_operating_system_name"
            },
            {
              "action_api": "os.environ.__setitem__()",
              "action_description": "Sets value for registry key",
              "action_id": "set_registry_value",
              "object": "'PYTHON_BIN_PATH', sys.executable",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.environ.__setitem__()",
              "action_description": "Sets value for registry key",
              "action_id": "set_registry_value",
              "object": "'PYTHON_LIB_PATH', os.path.join(sys.exec_prefix, 'lib')",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.environ.__contains__()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "'TINK_PYTHON_BAZEL_REMOTE_CACHE_GCS_BUCKET_URL'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Determine presence of valid authentication",
              "intention_id": "determine_valid_authentication_presence"
            },
            {
              "action_api": "os.environ.__contains__()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "'TINK_PYTHON_BAZEL_REMOTE_CACHE_SERVICE_KEY_PATH'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Determine presence of valid authentication",
              "intention_id": "determine_valid_authentication_presence"
            },
            {
              "action_api": "os.environ.__getitem__()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'TINK_PYTHON_BAZEL_REMOTE_CACHE_GCS_BUCKET_URL'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.path.abspath()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "os.environ['TINK_PYTHON_BAZEL_REMOTE_CACHE_SERVICE_KEY_PATH']",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Prepare path for file operations",
              "intention_id": "prepare_path_file_operations"
            },
            {
              "action_api": "self.spawn()",
              "action_description": "Spawns new process to execute command with shell access",
              "action_id": "spawn_process_shell",
              "object": "[self.bazel_command] + bazel_startup_args + bazel_build_args",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Execute command",
              "intention_id": "execute_command"
            },
            {
              "action_api": "os.path.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "'bazel-bin', ext.relpath, ext.target_name + lib_extension",
              "object_description": "Directory path with file",
              "object_id": "directory_path_with_file",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            },
            {
              "action_api": "self.get_ext_fullpath()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "ext.name",
              "object_description": "Local file or directory name",
              "object_id": "local_file_or_directory_name",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            },
            {
              "action_api": "os.path.dirname()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "ext_dest_path",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Prepare directory path",
              "intention_id": "prepare_directory_path"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "ext_dest_dir",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "os.makedirs()",
              "action_description": "Creates directory, ignoring if it already exists",
              "action_id": "create_directory",
              "object": "ext_dest_dir",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Ensure directory exists",
              "intention_id": "ensure_directory_exists"
            },
            {
              "action_api": "shutil.copyfile()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "ext_bazel_bin_path, ext_dest_path",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Move file to destination",
              "intention_id": "move_file_destination"
            },
            {
              "action_api": "shutil.which()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "'bazelisk'",
              "object_description": "Executable file",
              "object_id": "executable_file",
              "intention_description": "Determine presence of required module",
              "intention_id": "determine_required_module_presence"
            },
            {
              "action_api": "shutil.which()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "'bazel'",
              "object_description": "Executable file",
              "object_id": "executable_file",
              "intention_description": "Determine presence of required module",
              "intention_id": "determine_required_module_presence"
            }
          ]
        }
      ]
    }
  ]
}