{
  "metadata": {
    "package_name": "clr_loader-0",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/clr_loader-0.2.7.post0.json",
    "dataset_type": "benign"
  },
  "code_files": [
    {
      "pyfile": "setup.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/clr_loader-0.2.7.post0/clr_loader-0.2.7.post0/setup.py",
      "line_number": "74",
      "type_description": "code-execution",
      "context_snippet": "class build_dotnet(Command):\n    \"\"\"Build command for dotnet-cli based builds\"\"\"\n\n    description = \"Build DLLs with dotnet-cli\"\n    user_options = [\n        (\"dotnet-config=\", None, \"dotnet build configuration\"),\n        (\n            \"inplace\",\n            \"i\",\n            \"ignore build-lib and put compiled extensions into the source \"\n            + \"directory alongside your pure Python modules\",\n        ),\n    ]\n\n    def initialize_options(self):\n        self.dotnet_config = None\n        self.build_lib = None\n        self.inplace = False\n\n    def finalize_options(self):\n        if self.dotnet_config is None:\n            self.dotnet_config = \"release\"\n\n        build = self.distribution.get_command_obj(\"build\")\n        build.ensure_finalized()\n        if self.inplace:\n            self.build_lib = \".\"\n        else:\n            self.build_lib = build.build_lib\n\n    def run(self):\n        dotnet_modules = self.distribution.dotnet_libs\n\n        for lib in dotnet_modules:\n            output = os.path.join(\n                os.path.abspath(self.build_lib), lib.args.pop(\"output\")\n            )\n            rename = lib.args.pop(\"rename\", {})\n\n            opts = sum(\n                [\n                    [\"--\" + name.replace(\"_\", \"-\"), value]\n                    for name, value in lib.args.items()\n                ],\n                [],\n            )\n\n            opts.extend([\"--configuration\", self.dotnet_config])\n            opts.extend([\"--output\", output])\n\n            self.announce(\"Running dotnet build...\", level=distutils.log.INFO)\n            self.spawn([\"dotnet\", \"build\", lib.path] + opts)\n\n            for k, v in rename.items():\n                source = os.path.join(output, k)\n                dest = os.path.join(output, v)\n\n                if os.path.isfile(source):\n                    try:\n                        os.remove(dest)\n                    except OSError:\n                        pass\n\n                    self.move_file(src=source, dst=dest, level=distutils.log.INFO)\n                else:\n                    self.warn(\n                        \"Can't find file to rename: {}, current dir: {}\".format(\n                            source, os.getcwd()\n                        )\n                    )",
      "hash_value": "b0a3a699f2f02cb76e3cec4dd30286bf",
      "detection_index": 1,
      "code_snippets": [
        {
          "snippet": "class build_dotnet(Command):\n    \"\"\"Build command for dotnet-cli based builds\"\"\"\n\n    description = \"Build DLLs with dotnet-cli\"\n    user_options = [\n        (\"dotnet-config=\", None, \"dotnet build configuration\"),\n        (\n            \"inplace\",\n            \"i\",\n            \"ignore build-lib and put compiled extensions into the source \"\n            + \"directory alongside your pure Python modules\",\n        ),\n    ]\n\n    def initialize_options(self):\n        self.dotnet_config = None\n        self.build_lib = None\n        self.inplace = False\n\n    def finalize_options(self):\n        if self.dotnet_config is None:\n            self.dotnet_config = \"release\"\n\n        build = self.distribution.get_command_obj(\"build\")\n        build.ensure_finalized()\n        if self.inplace:\n            self.build_lib = \".\"\n        else:\n            self.build_lib = build.build_lib\n\n    def run(self):\n        dotnet_modules = self.distribution.dotnet_libs\n\n        for lib in dotnet_modules:\n            output = os.path.join(\n                os.path.abspath(self.build_lib), lib.args.pop(\"output\")\n            )\n            rename = lib.args.pop(\"rename\", {})\n\n            opts = sum(\n                [\n                    [\"--\" + name.replace(\"_\", \"-\"), value]\n                    for name, value in lib.args.items()\n                ],\n                [],\n            )\n\n            opts.extend([\"--configuration\", self.dotnet_config])\n            opts.extend([\"--output\", output])\n\n            self.announce(\"Running dotnet build...\", level=distutils.log.INFO)\n            self.spawn([\"dotnet\", \"build\", lib.path] + opts)\n\n            for k, v in rename.items():\n                source = os.path.join(output, k)\n                dest = os.path.join(output, v)\n\n                if os.path.isfile(source):\n                    try:\n                        os.remove(dest)\n                    except OSError:\n                        pass\n\n                    self.move_file(src=source, dst=dest, level=distutils.log.INFO)\n                else:\n                    self.warn(\n                        \"Can't find file to rename: {}, current dir: {}\".format(\n                            source, os.getcwd()\n                        )\n                    )",
          "triple_sequences": [
            {
              "action_api": "os.path.abspath()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "self.build_lib",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Prepare directory path",
              "intention_id": "prepare_directory_path"
            },
            {
              "action_api": "os.path.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "os.path.abspath(self.build_lib), lib.args.pop(\"output\")",
              "object_description": "Directory path and file name",
              "object_id": "directory_path_with_file",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            },
            {
              "action_api": "lib.args.pop()",
              "action_description": "Deserialize JSON string to Python object",
              "action_id": "deserialize_from_json",
              "object": "\"output\"",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "lib.args.pop()",
              "action_description": "Deserialize JSON string to Python object",
              "action_id": "deserialize_from_json",
              "object": "\"rename\", {}",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "self.announce()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "\"Running dotnet build...\", level=distutils.log.INFO",
              "object_description": "Command output",
              "object_id": "command_output",
              "intention_description": "Collect command output",
              "intention_id": "collect_command_output"
            },
            {
              "action_api": "self.spawn()",
              "action_description": "Spawns new process to execute command with shell access",
              "action_id": "spawn_process_shell",
              "object": "[\"dotnet\", \"build\", lib.path] + opts",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Execute command",
              "intention_id": "execute_command"
            },
            {
              "action_api": "os.path.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "output, k",
              "object_description": "Directory path and file name",
              "object_id": "directory_path_with_file",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            },
            {
              "action_api": "os.path.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "output, v",
              "object_description": "Directory path and file name",
              "object_id": "directory_path_with_file",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            },
            {
              "action_api": "os.path.isfile()",
              "action_description": "Checks if specified path exists and is a file",
              "action_id": "check_file_is_file",
              "object": "source",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Determine presence of file",
              "intention_id": "determine_file_presence"
            },
            {
              "action_api": "os.remove()",
              "action_description": "Deletes specified file from filesystem",
              "action_id": "delete_file",
              "object": "dest",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Delete file",
              "intention_id": "delete_file"
            },
            {
              "action_api": "self.move_file()",
              "action_description": "Moves file to destination",
              "action_id": "move_file",
              "object": "src=source, dst=dest, level=distutils.log.INFO",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Move file to destination",
              "intention_id": "move_file_destination"
            },
            {
              "action_api": "self.warn()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "\"Can't find file to rename: {}, current dir: {}\".format(source, os.getcwd())",
              "object_description": "Command output",
              "object_id": "command_output",
              "intention_description": "Collect command output",
              "intention_id": "collect_command_output"
            },
            {
              "action_api": "os.getcwd()",
              "action_description": "Returns current working directory",
              "action_id": "get_working_dir",
              "object": "",
              "object_description": "Current working directory",
              "object_id": "current_working_directory",
              "intention_description": "Collect working directory",
              "intention_id": "collect_working_directory"
            }
          ]
        }
      ]
    }
  ]
}