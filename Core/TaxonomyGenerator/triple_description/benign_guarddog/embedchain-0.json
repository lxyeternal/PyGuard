{
  "metadata": {
    "package_name": "embedchain-0",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/embedchain-0.1.128.json",
    "dataset_type": "benign"
  },
  "code_files": [
    {
      "pyfile": "add_config.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/embedchain-0.1.128/embedchain-0.1.128/embedchain/config/add_config.py",
      "line_number": "42",
      "type_description": "obfuscation",
      "context_snippet": "import builtins\nimport logging\nfrom collections.abc import Callable\nfrom importlib import import_module\nfrom typing import Optional\n\nfrom embedchain.config.base_config import BaseConfig\nfrom embedchain.helpers.json_serializable import register_deserializable\n\n\n@register_deserializable\nclass ChunkerConfig(BaseConfig):\n    \"\"\"\n    Config for the chunker used in `add` method\n    \"\"\"\n\n    def __init__(\n        self,\n        chunk_size: Optional[int] = 2000,\n        chunk_overlap: Optional[int] = 0,\n        length_function: Optional[Callable[[str], int]] = None,\n        min_chunk_size: Optional[int] = 0,\n    ):\n        self.chunk_size = chunk_size\n        self.chunk_overlap = chunk_overlap\n        self.min_chunk_size = min_chunk_size\n        if self.min_chunk_size >= self.chunk_size:\n            raise ValueError(f\"min_chunk_size {min_chunk_size} should be less than chunk_size {chunk_size}\")\n        if self.min_chunk_size < self.chunk_overlap:\n            logging.warning(\n                f\"min_chunk_size {min_chunk_size} should be greater than chunk_overlap {chunk_overlap}, otherwise it is redundant.\"  # noqa:E501\n            )\n\n        if isinstance(length_function, str):\n            self.length_function = self.load_func(length_function)\n        else:\n            self.length_function = length_function if length_function else len\n\n    @staticmethod\n    def load_func(dotpath: str):\n        if \".\" not in dotpath:\n            return getattr(builtins, dotpath)\n        else:\n            module_, func = dotpath.rsplit(\".\", maxsplit=1)\n            m = import_module(module_)\n            return getattr(m, func)",
      "hash_value": "034d145ab60ee73d9ef94d717895bcab",
      "detection_index": 1,
      "code_snippets": [
        {
          "snippet": "import builtins\nimport logging\nfrom collections.abc import Callable\nfrom importlib import import_module\nfrom typing import Optional\n\nfrom embedchain.config.base_config import BaseConfig\nfrom embedchain.helpers.json_serializable import register_deserializable\n\n\n@register_deserializable\nclass ChunkerConfig(BaseConfig):\n    \"\"\"\n    Config for the chunker used in `add` method\n    \"\"\"\n\n    def __init__(\n        self,\n        chunk_size: Optional[int] = 2000,\n        chunk_overlap: Optional[int] = 0,\n        length_function: Optional[Callable[[str], int]] = None,\n        min_chunk_size: Optional[int] = 0,\n    ):\n        self.chunk_size = chunk_size\n        self.chunk_overlap = chunk_overlap\n        self.min_chunk_size = min_chunk_size\n        if self.min_chunk_size >= self.chunk_size:\n            raise ValueError(f\"min_chunk_size {min_chunk_size} should be less than chunk_size {chunk_size}\")\n        if self.min_chunk_size < self.chunk_overlap:\n            logging.warning(\n                f\"min_chunk_size {min_chunk_size} should be greater than chunk_overlap {chunk_overlap}, otherwise it is redundant.\"  # noqa:E501\n            )\n\n        if isinstance(length_function, str):\n            self.length_function = self.load_func(length_function)\n        else:\n            self.length_function = length_function if length_function else len\n\n    @staticmethod\n    def load_func(dotpath: str):\n        if \".\" not in dotpath:\n            return getattr(builtins, dotpath)\n        else:\n            module_, func = dotpath.rsplit(\".\", maxsplit=1)\n            m = import_module(module_)\n            return getattr(m, func)",
          "triple_sequences": [
            {
              "action_api": "logging.warning()",
              "action_description": "Logs warning message",
              "action_id": "set_builtin_attr",
              "object": "f\"min_chunk_size {min_chunk_size} should be greater than chunk_overlap {chunk_overlap}, otherwise it is redundant.\"",
              "object_description": "Error message text",
              "object_id": "error_message",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "isinstance()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "length_function, str",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine required module presence",
              "intention_id": "determine_required_module_presence"
            },
            {
              "action_api": "ChunkerConfig.load_func()",
              "action_description": "Dynamically imports specified module",
              "action_id": "import_dynamic",
              "object": "dotpath",
              "object_description": "Module name string",
              "object_id": "module_name_string",
              "intention_description": "Import module dynamically",
              "intention_id": "import_module_dynamically"
            },
            {
              "action_api": "getattr()",
              "action_description": "Sets attribute on builtins object",
              "action_id": "set_builtin_attr",
              "object": "builtins, dotpath",
              "object_description": "Built-in module or package",
              "object_id": "builtin_module",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "str.rsplit()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "dotpath, maxsplit=1",
              "object_description": "Module name string",
              "object_id": "module_name_string",
              "intention_description": "Prepare string for further processing",
              "intention_id": "prepare_string_processing"
            },
            {
              "action_api": "import_module()",
              "action_description": "Dynamically imports specified module",
              "action_id": "import_dynamic",
              "object": "module_",
              "object_description": "Module name string",
              "object_id": "module_name_string",
              "intention_description": "Import module dynamically",
              "intention_id": "import_module_dynamically"
            },
            {
              "action_api": "getattr()",
              "action_description": "Sets attribute on builtins object",
              "action_id": "set_builtin_attr",
              "object": "m, func",
              "object_description": "Module name string",
              "object_id": "module_name_string",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            }
          ]
        }
      ]
    }
  ]
}