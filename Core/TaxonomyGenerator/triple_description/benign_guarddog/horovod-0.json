{
  "metadata": {
    "package_name": "horovod-0",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/horovod-0.28.1.json",
    "dataset_type": "benign"
  },
  "code_files": [
    {
      "pyfile": "setup.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/horovod-0.28.1/horovod-0.28.1/setup.py",
      "line_number": "145",
      "type_description": "code-execution",
      "context_snippet": "class custom_build_ext(build_ext):\n    def build_extensions(self):\n        if os.getenv('HOROVOD_SKIP_COMPILE') == '1':\n            # Skip building extensions using CMake\n            print(\"Horovod is being installed without native libraries\")\n            return\n\n        cmake_bin = get_cmake_bin()\n\n        config = 'Debug' if self.debug or os.environ.get('HOROVOD_DEBUG') == \"1\" else 'RelWithDebInfo'\n\n        ext_name = self.extensions[0].name\n        build_dir = self.get_ext_fullpath(ext_name).replace(self.get_ext_filename(ext_name), '')\n        build_dir = os.path.abspath(build_dir)\n\n        cmake_args = ['-DCMAKE_BUILD_TYPE=' + config,\n                      '-DCMAKE_LIBRARY_OUTPUT_DIRECTORY_{}={}'.format(config.upper(), build_dir),\n                      '-DPYTHON_EXECUTABLE:FILEPATH=' + sys.executable]\n\n        make_args = ['-j8'] if not os.environ.get('MAKEFLAGS') else []\n        if self.verbose:\n            make_args.append('VERBOSE=1')\n\n        cmake_build_args = ['--config', config]\n        if make_args:\n            # -- specifies that these args are going to the native build tool: make\n            cmake_build_args += ['--'] + make_args\n\n        cmake_build_dir = os.path.join(self.build_temp, config)\n        if not os.path.exists(cmake_build_dir):\n            os.makedirs(cmake_build_dir)\n\n        config_and_build_commands = [\n            [cmake_bin, self.extensions[0].cmake_lists_dir] + cmake_args,\n            [cmake_bin, '--build', '.'] + cmake_build_args\n        ]\n\n        if self.verbose:\n            print(f\"Running CMake in {cmake_build_dir}:\")\n            for command in config_and_build_commands:\n                print(\" \".join(command))\n            sys.stdout.flush()\n\n        # Config and build the extension\n        try:\n            for command in config_and_build_commands:\n                subprocess.check_call(command, cwd=cmake_build_dir)\n        except OSError as e:\n            raise RuntimeError('CMake failed: {}'.format(str(e)))\n\n        if sys.argv[1].startswith('develop'):\n            # Copy over metadata.json file from build directory\n            shutil.copyfile(os.path.join(build_dir, _FRAMEWORK_METADATA_FILE),\n                            os.path.join(self.extensions[0].cmake_lists_dir, _FRAMEWORK_METADATA_FILE))\n            # Remove unfound frameworks, otherwise develop mode will fail the install\n            self.extensions = [x for x in self.extensions if os.path.exists(self.get_ext_fullpath(x.name))]",
      "hash_value": "0cf5ae0c3872ed8791271807e74e5d03",
      "detection_index": 1,
      "code_snippets": [
        {
          "snippet": "class custom_build_ext(build_ext):\n    def build_extensions(self):\n        if os.getenv('HOROVOD_SKIP_COMPILE') == '1':\n            # Skip building extensions using CMake\n            print(\"Horovod is being installed without native libraries\")\n            return\n\n        cmake_bin = get_cmake_bin()\n\n        config = 'Debug' if self.debug or os.environ.get('HOROVOD_DEBUG') == \"1\" else 'RelWithDebInfo'\n\n        ext_name = self.extensions[0].name\n        build_dir = self.get_ext_fullpath(ext_name).replace(self.get_ext_filename(ext_name), '')\n        build_dir = os.path.abspath(build_dir)\n\n        cmake_args = ['-DCMAKE_BUILD_TYPE=' + config,\n                      '-DCMAKE_LIBRARY_OUTPUT_DIRECTORY_{}={}'.format(config.upper(), build_dir),\n                      '-DPYTHON_EXECUTABLE:FILEPATH=' + sys.executable]\n\n        make_args = ['-j8'] if not os.environ.get('MAKEFLAGS') else []\n        if self.verbose:\n            make_args.append('VERBOSE=1')\n\n        cmake_build_args = ['--config', config]\n        if make_args:\n            # -- specifies that these args are going to the native build tool: make\n            cmake_build_args += ['--'] + make_args\n\n        cmake_build_dir = os.path.join(self.build_temp, config)\n        if not os.path.exists(cmake_build_dir):\n            os.makedirs(cmake_build_dir)\n\n        config_and_build_commands = [\n            [cmake_bin, self.extensions[0].cmake_lists_dir] + cmake_args,\n            [cmake_bin, '--build', '.'] + cmake_build_args\n        ]\n\n        if self.verbose:\n            print(f\"Running CMake in {cmake_build_dir}:\")\n            for command in config_and_build_commands:\n                print(\" \".join(command))\n            sys.stdout.flush()\n\n        # Config and build the extension\n        try:\n            for command in config_and_build_commands:\n                subprocess.check_call(command, cwd=cmake_build_dir)\n        except OSError as e:\n            raise RuntimeError('CMake failed: {}'.format(str(e)))\n\n        if sys.argv[1].startswith('develop'):\n            # Copy over metadata.json file from build directory\n            shutil.copyfile(os.path.join(build_dir, _FRAMEWORK_METADATA_FILE),\n                            os.path.join(self.extensions[0].cmake_lists_dir, _FRAMEWORK_METADATA_FILE))\n            # Remove unfound frameworks, otherwise develop mode will fail the install\n            self.extensions = [x for x in self.extensions if os.path.exists(self.get_ext_fullpath(x.name))]",
          "triple_sequences": [
            {
              "action_api": "os.getenv()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'HOROVOD_SKIP_COMPILE'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.environ.get()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'HOROVOD_DEBUG'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "sys.executable",
              "action_description": "Retrieves Python interpreter version",
              "action_id": "get_python_version",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Get Python executable path",
              "intention_id": "get_python_executable_path"
            },
            {
              "action_api": "os.environ.get()",
              "action_description": "Retrieves value of environment variable",
              "action_id": "get_env_var",
              "object": "'MAKEFLAGS'",
              "object_description": "Environment variable",
              "object_id": "environment_variable",
              "intention_description": "Collect environment variable",
              "intention_id": "collect_environment_variable"
            },
            {
              "action_api": "os.path.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "self.build_temp, config",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "cmake_build_dir",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Check if file or directory exists",
              "intention_id": "check_file_existence"
            },
            {
              "action_api": "os.makedirs()",
              "action_description": "Creates directory, ignoring if it already exists",
              "action_id": "create_directory",
              "object": "cmake_build_dir",
              "object_description": "Directory path",
              "object_id": "directory_path",
              "intention_description": "Ensure directory exists",
              "intention_id": "ensure_directory_exists"
            },
            {
              "action_api": "subprocess.check_call()",
              "action_description": "Executes shell command",
              "action_id": "execute_shell_command",
              "object": "command, cwd=cmake_build_dir",
              "object_description": "Shell command",
              "object_id": "shell_command",
              "intention_description": "Execute command",
              "intention_id": "execute_command"
            },
            {
              "action_api": "sys.argv",
              "action_description": "Retrieves command-line arguments passed to script",
              "action_id": "get_cmd_args",
              "object": "",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access command line arguments",
              "intention_id": "access_command_line_arguments"
            },
            {
              "action_api": "os.path.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "build_dir, _FRAMEWORK_METADATA_FILE",
              "object_description": "Directory path and file name",
              "object_id": "directory_path_with_file",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            },
            {
              "action_api": "os.path.join()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "self.extensions[0].cmake_lists_dir, _FRAMEWORK_METADATA_FILE",
              "object_description": "Directory path and file name",
              "object_id": "directory_path_with_file",
              "intention_description": "Construct file or directory path",
              "intention_id": "construct_file_path"
            },
            {
              "action_api": "shutil.copyfile()",
              "action_description": "Copies file to destination",
              "action_id": "copy_file",
              "object": "os.path.join(build_dir, _FRAMEWORK_METADATA_FILE), os.path.join(self.extensions[0].cmake_lists_dir, _FRAMEWORK_METADATA_FILE)",
              "object_description": "Local file",
              "object_id": "local_file",
              "intention_description": "Copy file to destination",
              "intention_id": "move_file_destination"
            },
            {
              "action_api": "os.path.exists()",
              "action_description": "Checks if specified path exists in filesystem",
              "action_id": "check_path_exists",
              "object": "self.get_ext_fullpath(x.name)",
              "object_description": "File path",
              "object_id": "file_path",
              "intention_description": "Determine presence of file",
              "intention_id": "determine_file_presence"
            }
          ]
        }
      ]
    }
  ]
}