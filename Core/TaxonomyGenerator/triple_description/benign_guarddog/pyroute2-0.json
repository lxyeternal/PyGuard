{
  "metadata": {
    "package_name": "pyroute2-0",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyroute2-0.9.1.json",
    "dataset_type": "benign"
  },
  "code_files": [
    {
      "pyfile": "__init__.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyroute2-0.9.1/pyroute2-0.9.1/pyroute2/plan9/__init__.py",
      "line_number": "419",
      "type_description": "obfuscation",
      "context_snippet": "import builtins\nimport json\n\nclass Plan9Exit(Exception):\n    pass\n\ndef parse(self, data, seq=None, callback=None, skip_alien_seq=False):\n    offset = 0\n    while offset <= len(data) - 5:\n        (length, key, tag) = struct.unpack_from('=IBH', data, offset)\n        if skip_alien_seq and tag != seq:\n            continue\n        if not 0 < length <= len(data):\n            break\n        parser = self.get_parser(key, 0, tag)\n        msg = parser(data, offset, length)\n        if key == Rerror:\n            spec = json.loads(msg['ename'])\n            if spec['class'] in dir(builtins):\n                cls = getattr(builtins, spec['class'])\n            elif spec['class'] == 'Plan9Exit':\n                cls = Plan9Exit\n            else:\n                cls = Exception\n            if not spec.get('argv'):\n                spec['argv'] = [spec['str']]\n            raise cls(*spec['argv'])\n        offset += length\n        if msg is None:\n            continue\n        yield msg",
      "hash_value": "5e5a7b7565c7f4edad3bb8f61872f579",
      "detection_index": 1,
      "code_snippets": [
        {
          "snippet": "import builtins\nimport json\n\nclass Plan9Exit(Exception):\n    pass\n\ndef parse(self, data, seq=None, callback=None, skip_alien_seq=False):\n    offset = 0\n    while offset <= len(data) - 5:\n        (length, key, tag) = struct.unpack_from('=IBH', data, offset)\n        if skip_alien_seq and tag != seq:\n            continue\n        if not 0 < length <= len(data):\n            break\n        parser = self.get_parser(key, 0, tag)\n        msg = parser(data, offset, length)\n        if key == Rerror:\n            spec = json.loads(msg['ename'])\n            if spec['class'] in dir(builtins):\n                cls = getattr(builtins, spec['class'])\n            elif spec['class'] == 'Plan9Exit':\n                cls = Plan9Exit\n            else:\n                cls = Exception\n            if not spec.get('argv'):\n                spec['argv'] = [spec['str']]\n            raise cls(*spec['argv'])\n        offset += length\n        if msg is None:\n            continue\n        yield msg",
          "triple_sequences": [
            {
              "action_api": "struct.unpack_from()",
              "action_description": "Packs values into bytes using specified format",
              "action_id": "pack_values",
              "object": "'=IBH', data, offset",
              "object_description": "Encoded string to bytes",
              "object_id": "encoded_string_bytes",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "self.get_parser()",
              "action_description": "Import module dynamically",
              "action_id": "import_dynamic",
              "object": "key, 0, tag",
              "object_description": "",
              "object_id": "",
              "intention_description": "Import module dynamically",
              "intention_id": "import_module_dynamically"
            },
            {
              "action_api": "parser()",
              "action_description": "Deserialize Python object from bytes",
              "action_id": "deserialize_from_bytes",
              "object": "data, offset, length",
              "object_description": "Decompressed data",
              "object_id": "decompressed_data",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "json.loads()",
              "action_description": "Deserializes JSON string to Python object",
              "action_id": "deserialize_from_json",
              "object": "msg['ename']",
              "object_description": "JSON string",
              "object_id": "json_string",
              "intention_description": "Parse JSON data",
              "intention_id": "parse_json_data"
            },
            {
              "action_api": "dir()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "builtins",
              "object_description": "Built-in module or package",
              "object_id": "builtin_module",
              "intention_description": "Determine presence of required module",
              "intention_id": "determine_required_module_presence"
            },
            {
              "action_api": "getattr()",
              "action_description": "Access attribute value",
              "action_id": "set_builtin_attr",
              "object": "builtins, spec['class']",
              "object_description": "Attribute value",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "raise cls(*spec['argv'])",
              "action_description": "Raises HTTPError if response status code indicates error",
              "action_id": "raise_http_error",
              "object": "cls(*spec['argv'])",
              "object_description": "Exception type name",
              "object_id": "exception_type",
              "intention_description": "Stop execution on invalid input",
              "intention_id": "stop_execution_invalid_input"
            }
          ]
        }
      ]
    }
  ]
}