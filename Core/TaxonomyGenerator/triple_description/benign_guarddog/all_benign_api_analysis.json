{
  "benign_reports": [
    {
      "metadata": {
        "package_name": "platformio-6",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/platformio-6.1.18.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "app.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/platformio-6.1.18/platformio-6.1.18/platformio/app.py",
          "line_number": "50",
          "type_description": "shady-links",
          "context_snippet": "DEFAULT_SETTINGS = {\n    \"check_platformio_interval\": {\n        \"description\": \"Check for the new PlatformIO Core interval (days)\",\n        \"value\": 7,\n    },\n    \"check_prune_system_threshold\": {\n        \"description\": \"Check for pruning unnecessary data threshold (megabytes)\",\n        \"value\": 1024,\n    },\n    \"enable_cache\": {\n        \"description\": \"Enable caching for HTTP API requests\",\n        \"value\": True,\n    },\n    \"enable_telemetry\": {\n        \"description\": (\"Telemetry service <https://bit.ly/pio-telemetry> (Yes/No)\"),\n        \"value\": True,\n    },\n    \"force_verbose\": {\n        \"description\": \"Force verbose output when processing environments\",\n        \"value\": False,\n    },\n    \"projects_dir\": {\n        \"description\": \"Default location for PlatformIO projects (PlatformIO Home)\",\n        \"value\": get_default_projects_dir(),\n        \"validator\": projects_dir_validate,\n    },\n    \"enable_proxy_strict_ssl\": {\n        \"description\": \"Verify the proxy server certificate against the list of supplied CAs\",\n        \"value\": True,\n    },\n}\n\n# Data dependencies:\n# - DEFAULT_SETTINGS is a global constant dictionary\n# - The flagged line is the value for the 'description' key in the 'enable_telemetry' setting\n# - get_default_projects_dir and projects_dir_validate are helper functions used in other settings\n# - No control flow, this is a static data structure\n# - No function context, this is a global variable assignment\n# - Relevant imports: none required for this dictionary definition",
          "hash_value": "efa0398ea758d42a7d4c9cefd9dd7fbe",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "DEFAULT_SETTINGS = {\n    \"check_platformio_interval\": {\n        \"description\": \"Check for the new PlatformIO Core interval (days)\",\n        \"value\": 7,\n    },\n    \"check_prune_system_threshold\": {\n        \"description\": \"Check for pruning unnecessary data threshold (megabytes)\",\n        \"value\": 1024,\n    },\n    \"enable_cache\": {\n        \"description\": \"Enable caching for HTTP API requests\",\n        \"value\": True,\n    },\n    \"enable_telemetry\": {\n        \"description\": (\"Telemetry service <https://bit.ly/pio-telemetry> (Yes/No)\"),\n        \"value\": True,\n    },\n    \"force_verbose\": {\n        \"description\": \"Force verbose output when processing environments\",\n        \"value\": False,\n    },\n    \"projects_dir\": {\n        \"description\": \"Default location for PlatformIO projects (PlatformIO Home)\",\n        \"value\": get_default_projects_dir(),\n        \"validator\": projects_dir_validate,\n    },\n    \"enable_proxy_strict_ssl\": {\n        \"description\": \"Verify the proxy server certificate against the list of supplied CAs\",\n        \"value\": True,\n    },\n}\n\n# Data dependencies:\n# - DEFAULT_SETTINGS is a global constant dictionary\n# - The flagged line is the value for the 'description' key in the 'enable_telemetry' setting\n# - get_default_projects_dir and projects_dir_validate are helper functions used in other settings\n# - No control flow, this is a static data structure\n# - No function context, this is a global variable assignment\n# - Relevant imports: none required for this dictionary definition",
              "triple_sequences": []
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "curlify-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/curlify-2.2.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/curlify-2.2.1/curlify-2.2.1/setup.py",
          "line_number": "18",
          "type_description": "code-execution",
          "context_snippet": "import os\nfrom setuptools import setup, Command\n\nclass CleanCommand(Command):\n    \"\"\"Custom clean command to tidy up the project root.\"\"\"\n    user_options = []\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        os.system('rm -vrf ./build ./dist ./*.pyc ./*.tgz ./*.egg-info')",
          "hash_value": "d2809eb601f2b8e195d59d7a138c5bad",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nfrom setuptools import setup, Command\n\nclass CleanCommand(Command):\n    \"\"\"Custom clean command to tidy up the project root.\"\"\"\n    user_options = []\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        os.system('rm -vrf ./build ./dist ./*.pyc ./*.tgz ./*.egg-info')",
              "triple_sequences": [
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "rm -vrf ./build ./dist ./*.pyc ./*.tgz ./*.egg-info",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Delete directory content",
                  "intention_id": "delete_directory_content"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pyramid_mako-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyramid_mako-1.1.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "compat.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyramid_mako-1.1.0/pyramid_mako-1.1.0/pyramid_mako/compat.py",
          "line_number": "68",
          "type_description": "obfuscation",
          "context_snippet": "else:  # pragma: no cover\n    import builtins\n\n    exec_ = getattr(builtins, \"exec\")\n\n    def reraise(tp, value, tb=None):\n        if value is None:\n            value = tp\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value\n\n    del builtins",
          "hash_value": "7a6c2fe975e75427062ad18793feeda6",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "else:  # pragma: no cover\n    import builtins\n\n    exec_ = getattr(builtins, \"exec\")\n\n    def reraise(tp, value, tb=None):\n        if value is None:\n            value = tp\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value\n\n    del builtins",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "builtins, \"exec\"",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "del builtins",
                  "action_description": "Deletes function from global namespace",
                  "action_id": "delete_function_global_namespace",
                  "object": "builtins",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Release system resource",
                  "intention_id": "release_system_resource"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "dictknife-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/dictknife-0.14.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "env.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/dictknife-0.14.1/dictknife-0.14.1/dictknife/loading/env.py",
          "line_number": "33",
          "type_description": "obfuscation",
          "context_snippet": "def parse_value(v, builtins=sys.modules[\"builtins\"]):\n    if \":\" not in v:\n        return v, None\n\n    name, fnname = v.rsplit(\":\", 1)\n    if not hasattr(builtins, fnname):\n        return v, None\n    else:\n        return name, getattr(builtins, fnname)",
          "hash_value": "c2b688c5b8f96076c48ed763ce6319bb",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def parse_value(v, builtins=sys.modules[\"builtins\"]):\n    if \":\" not in v:\n        return v, None\n\n    name, fnname = v.rsplit(\":\", 1)\n    if not hasattr(builtins, fnname):\n        return v, None\n    else:\n        return name, getattr(builtins, fnname)",
              "triple_sequences": [
                {
                  "action_api": "hasattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, fnname",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Determine required module presence",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, fnname",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "open_interpreter-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/open_interpreter-0.4.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "clipboard.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/open_interpreter-0.4.3/open_interpreter-0.4.3/interpreter/core/computer/clipboard/clipboard.py",
          "line_number": "20",
          "type_description": "clipboard-access",
          "context_snippet": "import platform\nfrom ...utils.lazy_import import lazy_import\n\n# Lazy import of optional packages\npyperclip = lazy_import('pyperclip')\n\nclass Clipboard:\n    def __init__(self, computer):\n        self.computer = computer\n\n        if platform.system() == \"Windows\" or platform.system() == \"Linux\":\n            self.modifier_key = \"ctrl\"\n        else:\n            self.modifier_key = \"command\"\n\n    def view(self):\n        \"\"\"\n        Returns the current content of on the clipboard.\n        \"\"\"\n        return pyperclip.paste()",
          "hash_value": "9ad9d6b7bd54be5543351c4412f0861b",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import platform\nfrom ...utils.lazy_import import lazy_import\n\n# Lazy import of optional packages\npyperclip = lazy_import('pyperclip')\n\nclass Clipboard:\n    def __init__(self, computer):\n        self.computer = computer\n\n        if platform.system() == \"Windows\" or platform.system() == \"Linux\":\n            self.modifier_key = \"ctrl\"\n        else:\n            self.modifier_key = \"command\"\n\n    def view(self):\n        \"\"\"\n        Returns the current content of on the clipboard.\n        \"\"\"\n        return pyperclip.paste()",
              "triple_sequences": [
                {
                  "action_api": "platform.system()",
                  "action_description": "Retrieves operating system identifier",
                  "action_id": "get_os_id",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine operating system",
                  "intention_id": "get_operating_system_name"
                },
                {
                  "action_api": "pyperclip.paste()",
                  "action_description": "Retrieves text from system clipboard",
                  "action_id": "get_clipboard_text",
                  "object": "",
                  "object_description": "Clipboard content data",
                  "object_id": "clipboard_data",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pyobjc-11",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyobjc-11.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyobjc-11.0/pyobjc-11.0/setup.py",
          "line_number": "698",
          "type_description": "cmd-overwrite",
          "context_snippet": "setup(\n    name=\"pyobjc\",\n    version=VERSION,\n    description=\"Python<->ObjC Interoperability Module\",\n    long_description=LONG_DESCRIPTION,\n    long_description_content_type=\"text/x-rst; charset=UTF-8\",\n    author=\"Ronald Oussoren\",\n    author_email=\"pyobjc-dev@lists.sourceforge.net\",\n    url=\"https://github.com/ronaldoussoren/pyobjc\",\n    platforms=[\"macOS\"],\n    packages=[],\n    install_requires=BASE_REQUIRES + framework_requires(),\n    extras_require={\n        \"allbindings\": BASE_REQUIRES + framework_requires(include_all=True)\n    },\n    python_requires=\">=3.9\",\n    setup_requires=[],\n    classifiers=CLASSIFIERS,\n    license=\"MIT License\",\n    zip_safe=True,\n    # workaround for setuptools 0.6b4 bug\n    dependency_links=[],\n    keywords=[\"Objective-C\", \"bridge\", \"Cocoa\"],\n    cmdclass={\"test\": oc_test, \"egg_info\": oc_egg_info},\n)\n\n# Data dependencies:\n# - VERSION: declared as VERSION = \"11.0\"\n# - LONG_DESCRIPTION: declared as LONG_DESCRIPTION = \"\"\"...\"\"\"\n# - BASE_REQUIRES: declared as BASE_REQUIRES = [\"pyobjc-core==\" + VERSION]\n# - framework_requires: function defined above\n# - CLASSIFIERS: declared as CLASSIFIERS = list(filter(None, ...))\n# - oc_test: class defined above\n# - oc_egg_info: class defined above",
          "hash_value": "3eb891cda4601d189c6d48f653ca6c8e",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "setup(\n    name=\"pyobjc\",\n    version=VERSION,\n    description=\"Python<->ObjC Interoperability Module\",\n    long_description=LONG_DESCRIPTION,\n    long_description_content_type=\"text/x-rst; charset=UTF-8\",\n    author=\"Ronald Oussoren\",\n    author_email=\"pyobjc-dev@lists.sourceforge.net\",\n    url=\"https://github.com/ronaldoussoren/pyobjc\",\n    platforms=[\"macOS\"],\n    packages=[],\n    install_requires=BASE_REQUIRES + framework_requires(),\n    extras_require={\n        \"allbindings\": BASE_REQUIRES + framework_requires(include_all=True)\n    },\n    python_requires=\">=3.9\",\n    setup_requires=[],\n    classifiers=CLASSIFIERS,\n    license=\"MIT License\",\n    zip_safe=True,\n    # workaround for setuptools 0.6b4 bug\n    dependency_links=[],\n    keywords=[\"Objective-C\", \"bridge\", \"Cocoa\"],\n    cmdclass={\"test\": oc_test, \"egg_info\": oc_egg_info},\n)\n\n# Data dependencies:\n# - VERSION: declared as VERSION = \"11.0\"\n# - LONG_DESCRIPTION: declared as LONG_DESCRIPTION = \"\"\"...\"\"\"\n# - BASE_REQUIRES: declared as BASE_REQUIRES = [\"pyobjc-core==\" + VERSION]\n# - framework_requires: function defined above\n# - CLASSIFIERS: declared as CLASSIFIERS = list(filter(None, ...))\n# - oc_test: class defined above\n# - oc_egg_info: class defined above",
              "triple_sequences": [
                {
                  "action_api": "setup()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "name=\"pyobjc\", version=VERSION, description=\"Python<->ObjC Interoperability Module\", long_description=LONG_DESCRIPTION, long_description_content_type=\"text/x-rst; charset=UTF-8\", author=\"Ronald Oussoren\", author_email=\"pyobjc-dev@lists.sourceforge.net\", url=\"https://github.com/ronaldoussoren/pyobjc\", platforms=[\"macOS\"], packages=[], install_requires=BASE_REQUIRES + framework_requires(), extras_require={\"allbindings\": BASE_REQUIRES + framework_requires(include_all=True)}, python_requires=\">=3.9\", setup_requires=[], classifiers=CLASSIFIERS, license=\"MIT License\", zip_safe=True, dependency_links=[], keywords=[\"Objective-C\", \"bridge\", \"Cocoa\"], cmdclass={\"test\": oc_test, \"egg_info\": oc_egg_info}",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "coqpit-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/coqpit-0.0.17.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/coqpit-0.0.17/coqpit-0.0.17/setup.py",
          "line_number": "38",
          "type_description": "cmd-overwrite",
          "context_snippet": "setup(\n    name=\"coqpit\",\n    version=version,\n    url=\"https://github.com/erogol/coqpit\",\n    author=\"Eren Gölge\",\n    author_email=\"egolge@coqui.ai\",\n    description=\"Simple (maybe too simple), light-weight config management through python data-classes.\",\n    long_description=README,\n    long_description_content_type=\"text/markdown\",\n    license=\"\",\n    include_package_data=True,\n    packages=find_packages(include=[\"coqpit*\"]),\n    project_urls={\n        \"Tracker\": \"https://github.com/coqui-ai/coqpit/issues\",\n        \"Repository\": \"https://github.com/coqui-ai/coqpit\",\n        \"Discussions\": \"https://github.com/coqui-ai/coqpit/discussions\",\n    },\n    cmdclass={\n        \"build_py\": build_py,\n        \"develop\": develop,\n    },\n    install_requires=requirements,\n    python_requires=\">=3.7.0\",\n    classifiers=[\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Operating System :: POSIX :: Linux\",\n        \"Operating System :: MacOS\",\n        \"Operating System :: Microsoft :: Windows\",\n    ],\n    zip_safe=False,\n)\n\n# Data dependencies:\n# - version: loaded from VERSION file at top\n# - README: loaded from README.md\n# - requirements: loaded from requirements.txt\n# - build_py, develop: custom classes defined above\n# - find_packages: imported from setuptools\n# - All relevant imports: os, setuptools, find_packages, setup",
          "hash_value": "6d59d7fd62d32e3bd156fb809f1d930f",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "setup(\n    name=\"coqpit\",\n    version=version,\n    url=\"https://github.com/erogol/coqpit\",\n    author=\"Eren Gölge\",\n    author_email=\"egolge@coqui.ai\",\n    description=\"Simple (maybe too simple), light-weight config management through python data-classes.\",\n    long_description=README,\n    long_description_content_type=\"text/markdown\",\n    license=\"\",\n    include_package_data=True,\n    packages=find_packages(include=[\"coqpit*\"]),\n    project_urls={\n        \"Tracker\": \"https://github.com/coqui-ai/coqpit/issues\",\n        \"Repository\": \"https://github.com/coqui-ai/coqpit\",\n        \"Discussions\": \"https://github.com/coqui-ai/coqpit/discussions\",\n    },\n    cmdclass={\n        \"build_py\": build_py,\n        \"develop\": develop,\n    },\n    install_requires=requirements,\n    python_requires=\">=3.7.0\",\n    classifiers=[\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Operating System :: POSIX :: Linux\",\n        \"Operating System :: MacOS\",\n        \"Operating System :: Microsoft :: Windows\",\n    ],\n    zip_safe=False,\n)\n\n# Data dependencies:\n# - version: loaded from VERSION file at top\n# - README: loaded from README.md\n# - requirements: loaded from requirements.txt\n# - build_py, develop: custom classes defined above\n# - find_packages: imported from setuptools\n# - All relevant imports: os, setuptools, find_packages, setup",
              "triple_sequences": [
                {
                  "action_api": "setup()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "name=\"coqpit\", version=version, url=\"https://github.com/erogol/coqpit\", author=\"Eren Gölge\", author_email=\"egolge@coqui.ai\", description=\"Simple (maybe too simple), light-weight config management through python data-classes.\", long_description=README, long_description_content_type=\"text/markdown\", license=\"\", include_package_data=True, packages=find_packages(include=[\"coqpit*\"]), project_urls={\"Tracker\": \"https://github.com/coqui-ai/coqpit/issues\", \"Repository\": \"https://github.com/coqui-ai/coqpit\", \"Discussions\": \"https://github.com/coqui-ai/coqpit/discussions\"}, cmdclass={\"build_py\": build_py, \"develop\": develop}, install_requires=requirements, python_requires=\">=3.7.0\", classifiers=[\"Programming Language :: Python\", \"Programming Language :: Python :: 3\", \"Development Status :: 4 - Beta\", \"Intended Audience :: Developers\", \"Operating System :: POSIX :: Linux\", \"Operating System :: MacOS\", \"Operating System :: Microsoft :: Windows\"], zip_safe=False",
                  "object_description": "Python command",
                  "object_id": "python_command",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                },
                {
                  "action_api": "find_packages()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "include=[\"coqpit*\"]",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Install multiple Python packages",
                  "intention_id": "install_multiple_python_packages"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "asn1crypto-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/asn1crypto-1.5.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/asn1crypto-1.5.1/asn1crypto-1.5.1/setup.py",
          "line_number": "102",
          "type_description": "cmd-overwrite",
          "context_snippet": "import setuptools\nfrom setuptools import setup, Command\nfrom setuptools.command.egg_info import egg_info\n\nPACKAGE_NAME = 'asn1crypto'\nPACKAGE_VERSION = '1.5.1'\nPACKAGE_ROOT = os.path.dirname(os.path.abspath(__file__))\n\n# ... (other code omitted for brevity)\n\nreadme = ''\nwith codecs.open(os.path.join(PACKAGE_ROOT, 'readme.md'), 'r', 'utf-8') as f:\n    readme = f.read()\n\nsetup(\n    name=PACKAGE_NAME,\n    version=PACKAGE_VERSION,\n\n    description=(\n        'Fast ASN.1 parser and serializer with definitions for private keys, '\n        'public keys, certificates, CRL, OCSP, CMS, PKCS#3, PKCS#7, PKCS#8, '\n        'PKCS#12, PKCS#5, X.509 and TSP'\n    ),\n    long_description=readme,\n    long_description_content_type='text/markdown',\n\n    url='https://github.com/wbond/asn1crypto',\n\n    author='wbond',\n    author_email='will@wbond.net',\n\n    license='MIT',\n\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: MIT License',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 2.6',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.2',\n        'Programming Language :: Python :: 3.3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: Implementation :: CPython',\n        'Programming Language :: Python :: Implementation :: PyPy',\n        'Topic :: Security :: Cryptography',\n    ],\n\n    keywords='asn1 crypto pki x509 certificate rsa dsa ec dh',\n\n    packages=[PACKAGE_NAME],\n    package_data=package_data,\n\n    tests_require=tests_require,\n    test_suite=test_suite,\n\n    cmdclass={\n        'clean': CleanCommand,\n        'egg_info': EggInfoCommand,\n    }\n)\n",
          "hash_value": "b1e6e80ed8dd977ceef30bc9621f1702",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import setuptools\nfrom setuptools import setup, Command\nfrom setuptools.command.egg_info import egg_info\n\nPACKAGE_NAME = 'asn1crypto'\nPACKAGE_VERSION = '1.5.1'\nPACKAGE_ROOT = os.path.dirname(os.path.abspath(__file__))\n\n# ... (other code omitted for brevity)\n\nreadme = ''\nwith codecs.open(os.path.join(PACKAGE_ROOT, 'readme.md'), 'r', 'utf-8') as f:\n    readme = f.read()\n\nsetup(\n    name=PACKAGE_NAME,\n    version=PACKAGE_VERSION,\n\n    description=(\n        'Fast ASN.1 parser and serializer with definitions for private keys, '\n        'public keys, certificates, CRL, OCSP, CMS, PKCS#3, PKCS#7, PKCS#8, '\n        'PKCS#12, PKCS#5, X.509 and TSP'\n    ),\n    long_description=readme,\n    long_description_content_type='text/markdown',\n\n    url='https://github.com/wbond/asn1crypto',\n\n    author='wbond',\n    author_email='will@wbond.net',\n\n    license='MIT',\n\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: MIT License',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 2.6',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.2',\n        'Programming Language :: Python :: 3.3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: Implementation :: CPython',\n        'Programming Language :: Python :: Implementation :: PyPy',\n        'Topic :: Security :: Cryptography',\n    ],\n\n    keywords='asn1 crypto pki x509 certificate rsa dsa ec dh',\n\n    packages=[PACKAGE_NAME],\n    package_data=package_data,\n\n    tests_require=tests_require,\n    test_suite=test_suite,\n\n    cmdclass={\n        'clean': CleanCommand,\n        'egg_info': EggInfoCommand,\n    }\n)\n",
              "triple_sequences": [
                {
                  "action_api": "os.path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Get script file path",
                  "intention_id": "get_script_file_path"
                },
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.abspath(__file__)",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "PACKAGE_ROOT, 'readme.md'",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "codecs.open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "os.path.join(PACKAGE_ROOT, 'readme.md'), 'r', 'utf-8'",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "setuptools.setup()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "name=PACKAGE_NAME, version=PACKAGE_VERSION, ...",
                  "object_description": "Package data",
                  "object_id": "",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "llvmlite-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/llvmlite-0.44.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/llvmlite-0.44.0/llvmlite-0.44.0/setup.py",
          "line_number": "68",
          "type_description": "code-execution",
          "context_snippet": "from distutils.spawn import spawn\nimport os\nimport sys\n\nhere_dir = os.path.dirname(os.path.abspath(__file__))\n\ndef build_library_files(dry_run):\n    cmd = [sys.executable, os.path.join(here_dir, 'ffi', 'build.py')]\n    # Turn on -fPIC for building on Linux, BSD, OS X, and GNU platforms\n    plt = sys.platform\n    if 'linux' in plt or 'bsd' in plt or 'darwin' in plt or 'gnu' in plt:\n        os.environ['CXXFLAGS'] = os.environ.get('CXXFLAGS', '') + ' -fPIC'\n    spawn(cmd, dry_run=dry_run)",
          "hash_value": "fe65109ec43ef58a5e7d2c2c6218d561",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from distutils.spawn import spawn\nimport os\nimport sys\n\nhere_dir = os.path.dirname(os.path.abspath(__file__))\n\ndef build_library_files(dry_run):\n    cmd = [sys.executable, os.path.join(here_dir, 'ffi', 'build.py')]\n    # Turn on -fPIC for building on Linux, BSD, OS X, and GNU platforms\n    plt = sys.platform\n    if 'linux' in plt or 'bsd' in plt or 'darwin' in plt or 'gnu' in plt:\n        os.environ['CXXFLAGS'] = os.environ.get('CXXFLAGS', '') + ' -fPIC'\n    spawn(cmd, dry_run=dry_run)",
              "triple_sequences": [
                {
                  "action_api": "os.path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Get script file path",
                  "intention_id": "get_script_file_path"
                },
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.abspath(__file__)",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "[here_dir, 'ffi', 'build.py']",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "sys.platform",
                  "action_description": "Retrieves platform information",
                  "action_id": "get_platform_info",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get operating system name",
                  "intention_id": "get_operating_system_name"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "CXXFLAGS",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.__setitem__()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "CXXFLAGS",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Prepare environment variable for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "spawn()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "[sys.executable, os.path.join(here_dir, 'ffi', 'build.py')]",
                  "object_description": "Python command",
                  "object_id": "python_command",
                  "intention_description": "Create child process",
                  "intention_id": "create_child_process"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "shyaml-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/shyaml-0.6.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/shyaml-0.6.2/shyaml-0.6.2/setup.py",
          "line_number": "40",
          "type_description": "code-execution",
          "context_snippet": "if \"0.6.2\".startswith(\"%%\"):\n    import os.path\n    import sys\n    WIN32 = sys.platform == 'win32'\n    autogen = os.path.join(\".\", \"autogen.sh\")\n    if not os.path.exists(autogen):\n        sys.stderr.write(\n            \"This source repository was not configured.\\n\"\n            \"Please ensure ``./autogen.sh`` exists and that you are running \"\n            \"``setup.py`` from the project root directory.\\n\")\n        sys.exit(1)\n    if os.path.exists('.autogen.sh.output'):\n        sys.stderr.write(\n            \"It seems that ``./autogen.sh`` couldn't do its job as expected.\\n\"\n            \"Please try to launch ``./autogen.sh`` manualy, and send the \"\n            \"results to the\\nmaintainer of this package.\\n\"\n            \"Package will not be installed !\\n\")\n        sys.exit(1)\n    sys.stderr.write(\"Missing version information: \"\n                     \"running './autogen.sh'...\\n\")\n    import os\n    import subprocess\n    os.system('%s%s > .autogen.sh.output'\n              % (\"bash \" if WIN32 else \"\",\n                 autogen))\n    cmdline = sys.argv[:]\n    if cmdline[0] == \"-c\":\n        ## for some reason, this is needed when launched from pip\n        cmdline[0] = \"setup.py\"\n    errlvl = subprocess.call([\"python\", ] + cmdline)\n    os.unlink(\".autogen.sh.output\")\n    sys.exit(errlvl)",
          "hash_value": "9c2b8846c31efc23eba9fbb80081ac8a",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "if \"0.6.2\".startswith(\"%%\"):\n    import os.path\n    import sys\n    WIN32 = sys.platform == 'win32'\n    autogen = os.path.join(\".\", \"autogen.sh\")\n    if not os.path.exists(autogen):\n        sys.stderr.write(\n            \"This source repository was not configured.\\n\"\n            \"Please ensure ``./autogen.sh`` exists and that you are running \"\n            \"``setup.py`` from the project root directory.\\n\")\n        sys.exit(1)\n    if os.path.exists('.autogen.sh.output'):\n        sys.stderr.write(\n            \"It seems that ``./autogen.sh`` couldn't do its job as expected.\\n\"\n            \"Please try to launch ``./autogen.sh`` manualy, and send the \"\n            \"results to the\\nmaintainer of this package.\\n\"\n            \"Package will not be installed !\\n\")\n        sys.exit(1)\n    sys.stderr.write(\"Missing version information: \"\n                     \"running './autogen.sh'...\\n\")\n    import os\n    import subprocess\n    os.system('%s%s > .autogen.sh.output'\n              % (\"bash \" if WIN32 else \"\",\n                 autogen))\n    cmdline = sys.argv[:]\n    if cmdline[0] == \"-c\":\n        ## for some reason, this is needed when launched from pip\n        cmdline[0] = \"setup.py\"\n    errlvl = subprocess.call([\"python\", ] + cmdline)\n    os.unlink(\".autogen.sh.output\")\n    sys.exit(errlvl)",
              "triple_sequences": [
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "[\".\", \"autogen.sh\"]",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "autogen",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "sys.stderr.write()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "\"This source repository was not configured.\\nPlease ensure ``./autogen.sh`` exists and that you are running ``setup.py`` from the project root directory.\\n\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "1",
                  "object_description": "Status code",
                  "object_id": "status_code",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "'.autogen.sh.output'",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "sys.stderr.write()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "\"It seems that ``./autogen.sh`` couldn't do its job as expected.\\nPlease try to launch ``./autogen.sh`` manualy, and send the results to the\\nmaintainer of this package.\\nPackage will not be installed !\\n\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "1",
                  "object_description": "Status code",
                  "object_id": "status_code",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                },
                {
                  "action_api": "sys.stderr.write()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "\"Missing version information: running './autogen.sh'...\\n\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "%s%s > .autogen.sh.output",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"python\", ] + cmdline",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.unlink()",
                  "action_description": "Deletes specified file from filesystem",
                  "action_id": "delete_file",
                  "object": "\".autogen.sh.output\"",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Delete file",
                  "intention_id": "delete_file"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "errlvl",
                  "object_description": "Status code",
                  "object_id": "status_code",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "github_heatmap-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/github_heatmap-1.2.7.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "dota2_loader.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/github_heatmap-1.2.7/github_heatmap-1.2.7/github_heatmap/loader/dota2_loader.py",
          "line_number": "28",
          "type_description": "shady-links",
          "context_snippet": "    @classmethod\n    def add_loader_arguments(cls, parser, optional):\n        parser.add_argument(\n            \"--dota2_id\",\n            dest=\"dota2_id\",\n            type=str,\n            required=optional,\n            help=\"Check your dota2-id in-game or on the website(steamid32): \"\n            \"https://steamid.xyz/\",\n        )",
          "hash_value": "b785169c07e899031271c2e12c59ab66",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "    @classmethod\n    def add_loader_arguments(cls, parser, optional):\n        parser.add_argument(\n            \"--dota2_id\",\n            dest=\"dota2_id\",\n            type=str,\n            required=optional,\n            help=\"Check your dota2-id in-game or on the website(steamid32): \"\n            \"https://steamid.xyz/\",\n        )",
              "triple_sequences": [
                {
                  "action_api": "parser.add_argument()",
                  "action_description": "Reads user input from standard input",
                  "action_id": "read_user_input",
                  "object": "--dota2_id",
                  "object_description": "Command-line arguments passed to script",
                  "object_id": "cmd_args",
                  "intention_description": "Access command line arguments",
                  "intention_id": "access_command_line_arguments"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "schema_salad-8",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/schema_salad-8.9.20250408123006.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "cpp_codegen.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/schema_salad-8.9.20250408123006/schema_salad-8.9.20250408123006/schema_salad/cpp_codegen.py",
          "line_number": "88",
          "type_description": "shady-links",
          "context_snippet": "def split_name(s: str) -> tuple[str, str]:\n    \"\"\"Split url name into its components.\n\n    Splits names like https://xyz.xyz/blub#cwl/class\n    into its class path and non class path\n    \"\"\"\n    t = s.split(\"#\")\n    if len(t) != 2:\n        raise ValueError(\"Expected field to be formatted as 'https://xyz.xyz/blub#cwl/class'.\")\n    return (t[0], t[1])",
          "hash_value": "4857d863671143949f80f362325b3cfd",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def split_name(s: str) -> tuple[str, str]:\n    \"\"\"Split url name into its components.\n\n    Splits names like https://xyz.xyz/blub#cwl/class\n    into its class path and non class path\n    \"\"\"\n    t = s.split(\"#\")\n    if len(t) != 2:\n        raise ValueError(\"Expected field to be formatted as 'https://xyz.xyz/blub#cwl/class'.\")\n    return (t[0], t[1])",
              "triple_sequences": [
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "#",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Prepare path for file operations",
                  "intention_id": "prepare_path_file_operations"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pyogrio-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyogrio-0.10.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyogrio-0.10.0/pyogrio-0.10.0/setup.py",
          "line_number": "39",
          "type_description": "code-execution",
          "context_snippet": "import subprocess\n\ndef read_response(cmd):\n    return subprocess.check_output(cmd).decode(\"utf\").strip()",
          "hash_value": "962d7002a6cdb79cab9edb308a9366d9",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import subprocess\n\ndef read_response(cmd):\n    return subprocess.check_output(cmd).decode(\"utf\").strip()",
              "triple_sequences": [
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "cmd",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "bytes.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "\"utf\"",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                },
                {
                  "action_api": "str.strip()",
                  "action_description": "Basic string operations (strip, split, join, etc.)",
                  "action_id": "path_string_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "qiskit_ibm_provider-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/qiskit_ibm_provider-0.11.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "provider_buttons.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/qiskit_ibm_provider-0.11.0/qiskit_ibm_provider-0.11.0/qiskit_ibm_provider/jupyter/dashboard/provider_buttons.py",
          "line_number": "32",
          "type_description": "clipboard-access",
          "context_snippet": "import pyperclip\nimport time\nimport ipyvuetify as vue\n\ndef _copy_text_thread(button: vue.Btn) -> None:\n    \"\"\"A function that signals button text was copied to clipboard.\n\n    Args:\n        button: Button whose text is to be copied.\n    \"\"\"\n    old_text = button.children[0]\n    hub, group, project = old_text.split(\"/\")\n    pyperclip.copy(\n        f\"IBMProvider(hub='{hub}', group='{group}', project='{project}')\".format(\n            hub=hub, group=group, project=project\n        )\n    )\n    button.children = [\"Copied to clipboard.\"]\n    time.sleep(1)\n    button.children = [old_text]",
          "hash_value": "2adad312d230be886c7972bd32a1bdbe",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import pyperclip\nimport time\nimport ipyvuetify as vue\n\ndef _copy_text_thread(button: vue.Btn) -> None:\n    \"\"\"A function that signals button text was copied to clipboard.\n\n    Args:\n        button: Button whose text is to be copied.\n    \"\"\"\n    old_text = button.children[0]\n    hub, group, project = old_text.split(\"/\")\n    pyperclip.copy(\n        f\"IBMProvider(hub='{hub}', group='{group}', project='{project}')\".format(\n            hub=hub, group=group, project=project\n        )\n    )\n    button.children = [\"Copied to clipboard.\"]\n    time.sleep(1)\n    button.children = [old_text]",
              "triple_sequences": [
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "old_text.split(\"/\")",
                  "object_description": "String containing environment data",
                  "object_id": "string_environment_data",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "pyperclip.copy()",
                  "action_description": "Copies specified text to system clipboard",
                  "action_id": "copy_to_clipboard",
                  "object": "f\"IBMProvider(hub='{hub}', group='{group}', project='{project}')\".format(hub=hub, group=group, project=project)",
                  "object_description": "Encoded clipboard content",
                  "object_id": "encoded_clipboard_content",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                },
                {
                  "action_api": "time.sleep()",
                  "action_description": "Suspends execution",
                  "action_id": "suspend_execution",
                  "object": "1",
                  "object_description": "Delay duration in seconds",
                  "object_id": "delay_duration",
                  "intention_description": "Delay next operation",
                  "intention_id": "delay_next_operation"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "mdx_truly_sane_lists-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/mdx_truly_sane_lists-1.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/mdx_truly_sane_lists-1.3/mdx_truly_sane_lists-1.3/setup.py",
          "line_number": "17",
          "type_description": "shady-links",
          "context_snippet": "import os.path as path\nfrom setuptools import setup\n\n\ndef get_readme(filename):\n    if not path.exists(filename):\n        return \"\"\n\n    with open(path.join(path.dirname(__file__), filename)) as readme:\n        content = readme.read()\n    return content\n\n\nsetup(name=\"mdx_truly_sane_lists\",\n      version=\"1.3\",\n      author='radude',\n      author_email='admin@rentry.co',\n      description=\"Extension for Python-Markdown that makes lists truly sane. Custom indents for nested lists and fix for messy linebreaks.\",\n      license=\"MIT\",\n      keywords=[\"markdown extension\", 'markup', 'lists', 'markdown'],\n      url=\"https://github.com/radude/mdx_truly_sane_lists\",\n      packages=[\"mdx_truly_sane_lists\"],\n      long_description=get_readme(\"README.md\"),\n      long_description_content_type='text/markdown',\n      classifiers=[\n          \"Topic :: Text Processing :: Markup\",\n          \"Topic :: Text Processing :: Markup :: Markdown\",\n          \"Topic :: Utilities\",\n          \"Programming Language :: Python :: 3.3\",\n          \"Programming Language :: Python :: 3.4\",\n          \"Programming Language :: Python :: 3.5\",\n          \"Programming Language :: Python :: 3.6\",\n          \"Programming Language :: Python :: 3.7\",\n          \"Programming Language :: Python :: 3.8\",\n          \"Programming Language :: Python :: 3.9\",\n          \"Programming Language :: Python :: 3.10\",\n          \"License :: OSI Approved :: MIT License\",\n      ],\n      install_requires=[\"Markdown>=2.6\"],\n      test_suite=\"mdx_truly_sane_lists.tests\")",
          "hash_value": "506dbfa25ef65ea3ef0d099b79294eb4",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os.path as path\nfrom setuptools import setup\n\n\ndef get_readme(filename):\n    if not path.exists(filename):\n        return \"\"\n\n    with open(path.join(path.dirname(__file__), filename)) as readme:\n        content = readme.read()\n    return content\n\n\nsetup(name=\"mdx_truly_sane_lists\",\n      version=\"1.3\",\n      author='radude',\n      author_email='admin@rentry.co',\n      description=\"Extension for Python-Markdown that makes lists truly sane. Custom indents for nested lists and fix for messy linebreaks.\",\n      license=\"MIT\",\n      keywords=[\"markdown extension\", 'markup', 'lists', 'markdown'],\n      url=\"https://github.com/radude/mdx_truly_sane_lists\",\n      packages=[\"mdx_truly_sane_lists\"],\n      long_description=get_readme(\"README.md\"),\n      long_description_content_type='text/markdown',\n      classifiers=[\n          \"Topic :: Text Processing :: Markup\",\n          \"Topic :: Text Processing :: Markup :: Markdown\",\n          \"Topic :: Utilities\",\n          \"Programming Language :: Python :: 3.3\",\n          \"Programming Language :: Python :: 3.4\",\n          \"Programming Language :: Python :: 3.5\",\n          \"Programming Language :: Python :: 3.6\",\n          \"Programming Language :: Python :: 3.7\",\n          \"Programming Language :: Python :: 3.8\",\n          \"Programming Language :: Python :: 3.9\",\n          \"Programming Language :: Python :: 3.10\",\n          \"License :: OSI Approved :: MIT License\",\n      ],\n      install_requires=[\"Markdown>=2.6\"],\n      test_suite=\"mdx_truly_sane_lists.tests\")",
              "triple_sequences": [
                {
                  "action_api": "path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "filename",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "path.dirname(__file__), filename",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "path.join(path.dirname(__file__), filename)",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "readme.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "name=\"mdx_truly_sane_lists\", version=\"1.3\", author='radude', author_email='admin@rentry.co', description=\"Extension for Python-Markdown that makes lists truly sane. Custom indents for nested lists and fix for messy linebreaks.\", license=\"MIT\", keywords=[\"markdown extension\", 'markup', 'lists', 'markdown'], url=\"https://github.com/radude/mdx_truly_sane_lists\", packages=[\"mdx_truly_sane_lists\"], long_description=get_readme(\"README.md\"), long_description_content_type='text/markdown', classifiers=[...], install_requires=[\"Markdown>=2.6\"], test_suite=\"mdx_truly_sane_lists.tests\"",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "bip_utils-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/bip_utils-2.9.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/bip_utils-2.9.3/bip_utils-2.9.3/setup.py",
          "line_number": "105",
          "type_description": "cmd-overwrite",
          "context_snippet": "import setuptools\n\n# Load version\ndef load_version(*path_parts):\n    version_file = os.path.join(*path_parts)\n    version_line = open(os.path.join(*path_parts)).read().rstrip()\n    vre = re.compile(r'__version__: str = \"([^\"]+)\"')\n    matches = vre.findall(version_line)\n\n    if matches and len(matches) > 0:\n        return matches[0]\n\n    raise RuntimeError(f\"Cannot find version string in {version_file}\")\n\n# Setup configuration\nsetuptools.setup(\n    name=\"bip_utils\",\n    version=version,\n    author=\"Emanuele Bellocchia\",\n    author_email=\"ebellocchia@gmail.com\",\n    maintainer=\"Emanuele Bellocchia\",\n    maintainer_email=\"ebellocchia@gmail.com\",\n    description=\"Generation of mnemonics, seeds, private/public keys and addresses for different types of cryptocurrencies\",\n    long_description=load_long_description(\"README.md\"),\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/ebellocchia/bip_utils\",\n    download_url=\"https://github.com/ebellocchia/bip_utils/archive/v%s.tar.gz\" % version,\n    license=\"MIT\",\n    test_suite=\"tests\",\n    cmdclass={\n        \"install\": InstallCommand,\n        \"develop\": DevelopCommand,\n    },\n    install_requires=load_requirements(\"requirements.txt\"),\n    extras_require={\n        \"develop\": load_requirements(\"requirements-dev.txt\"),\n    },\n    packages=setuptools.find_packages(exclude=[\"*tests*\"]),\n    package_data={\n        \"bip_utils\": [\n            # BIP39\n            \"bip/bip39/wordlist/english.txt\",\n            \"bip/bip39/wordlist/italian.txt\",\n            \"bip/bip39/wordlist/french.txt\",\n            \"bip/bip39/wordlist/spanish.txt\",\n            \"bip/bip39/wordlist/portuguese.txt\",\n            \"bip/bip39/wordlist/czech.txt\",\n            \"bip/bip39/wordlist/chinese_simplified.txt\",\n            \"bip/bip39/wordlist/chinese_traditional.txt\",\n            \"bip/bip39/wordlist/korean.txt\",\n            # Electrum\n            \"electrum/mnemonic_v1/wordlist/english.txt\",\n            # Monero\n            \"monero/mnemonic/wordlist/chinese_simplified.txt\",\n            \"monero/mnemonic/wordlist/dutch.txt\",\n            \"monero/mnemonic/wordlist/english.txt\",\n            \"monero/mnemonic/wordlist/french.txt\",\n            \"monero/mnemonic/wordlist/german.txt\",\n            \"monero/mnemonic/wordlist/italian.txt\",\n            \"monero/mnemonic/wordlist/japanese.txt\",\n            \"monero/mnemonic/wordlist/portuguese.txt\",\n            \"monero/mnemonic/wordlist/russian.txt\",\n            \"monero/mnemonic/wordlist/spanish.txt\",\n        ]\n    },\n    keywords=load_keywords(\"keywords.txt\"),\n    platforms=[\"any\"],\n    classifiers=[\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.12\",\n        \"Development Status :: 5 - Production/Stable\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n        \"Intended Audience :: Developers\",\n    ],\n    python_requires=\">=3.7\",\n)\n",
          "hash_value": "fc566efc2e5cb97b4e9e31f36a9c4633",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import setuptools\n\n# Load version\ndef load_version(*path_parts):\n    version_file = os.path.join(*path_parts)\n    version_line = open(os.path.join(*path_parts)).read().rstrip()\n    vre = re.compile(r'__version__: str = \"([^\"]+)\"')\n    matches = vre.findall(version_line)\n\n    if matches and len(matches) > 0:\n        return matches[0]\n\n    raise RuntimeError(f\"Cannot find version string in {version_file}\")\n\n# Setup configuration\nsetuptools.setup(\n    name=\"bip_utils\",\n    version=version,\n    author=\"Emanuele Bellocchia\",\n    author_email=\"ebellocchia@gmail.com\",\n    maintainer=\"Emanuele Bellocchia\",\n    maintainer_email=\"ebellocchia@gmail.com\",\n    description=\"Generation of mnemonics, seeds, private/public keys and addresses for different types of cryptocurrencies\",\n    long_description=load_long_description(\"README.md\"),\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/ebellocchia/bip_utils\",\n    download_url=\"https://github.com/ebellocchia/bip_utils/archive/v%s.tar.gz\" % version,\n    license=\"MIT\",\n    test_suite=\"tests\",\n    cmdclass={\n        \"install\": InstallCommand,\n        \"develop\": DevelopCommand,\n    },\n    install_requires=load_requirements(\"requirements.txt\"),\n    extras_require={\n        \"develop\": load_requirements(\"requirements-dev.txt\"),\n    },\n    packages=setuptools.find_packages(exclude=[\"*tests*\"]),\n    package_data={\n        \"bip_utils\": [\n            # BIP39\n            \"bip/bip39/wordlist/english.txt\",\n            \"bip/bip39/wordlist/italian.txt\",\n            \"bip/bip39/wordlist/french.txt\",\n            \"bip/bip39/wordlist/spanish.txt\",\n            \"bip/bip39/wordlist/portuguese.txt\",\n            \"bip/bip39/wordlist/czech.txt\",\n            \"bip/bip39/wordlist/chinese_simplified.txt\",\n            \"bip/bip39/wordlist/chinese_traditional.txt\",\n            \"bip/bip39/wordlist/korean.txt\",\n            # Electrum\n            \"electrum/mnemonic_v1/wordlist/english.txt\",\n            # Monero\n            \"monero/mnemonic/wordlist/chinese_simplified.txt\",\n            \"monero/mnemonic/wordlist/dutch.txt\",\n            \"monero/mnemonic/wordlist/english.txt\",\n            \"monero/mnemonic/wordlist/french.txt\",\n            \"monero/mnemonic/wordlist/german.txt\",\n            \"monero/mnemonic/wordlist/italian.txt\",\n            \"monero/mnemonic/wordlist/japanese.txt\",\n            \"monero/mnemonic/wordlist/portuguese.txt\",\n            \"monero/mnemonic/wordlist/russian.txt\",\n            \"monero/mnemonic/wordlist/spanish.txt\",\n        ]\n    },\n    keywords=load_keywords(\"keywords.txt\"),\n    platforms=[\"any\"],\n    classifiers=[\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.12\",\n        \"Development Status :: 5 - Production/Stable\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n        \"Intended Audience :: Developers\",\n    ],\n    python_requires=\">=3.7\",\n)\n",
              "triple_sequences": [
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "*path_parts",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "os.path.join(*path_parts)",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "str.rstrip()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "re.compile()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "r'__version__: str = \"([^\"]+)\"'",
                  "object_description": "Regular expression pattern",
                  "object_id": "regex_pattern",
                  "intention_description": "Browser profile detection preparation",
                  "intention_id": "browser_profile_detection_preparation"
                },
                {
                  "action_api": "regex.findall()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "version_line",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Extract structured data from file",
                  "intention_id": "extract_structured_file_data"
                },
                {
                  "action_api": "setuptools.setup()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "setup configuration dictionary",
                  "object_description": "Structured file data",
                  "object_id": "structured_file_data",
                  "intention_description": "Trigger main behavioral logic",
                  "intention_id": "trigger_main_behavioral_logic"
                },
                {
                  "action_api": "setuptools.find_packages()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "exclude=[\"*tests*\"]",
                  "object_description": "Structured file data",
                  "object_id": "structured_file_data",
                  "intention_description": "Trigger main behavioral logic",
                  "intention_id": "trigger_main_behavioral_logic"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pyexcel-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyexcel-0.7.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyexcel-0.7.2/pyexcel-0.7.2/setup.py",
          "line_number": "128",
          "type_description": "code-execution",
          "context_snippet": "class PublishCommand(Command):\n    \"\"\"Support setup.py upload.\"\"\"\n\n    description = \"Build and publish the package on github and pypi\"\n    user_options = []\n\n    @staticmethod\n    def status(s):\n        \"\"\"Prints things in bold.\"\"\"\n        print(\"\\033[1m{0}\\033[0m\".format(s))\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        try:\n            self.status(\"Removing previous builds...\")\n            rmtree(os.path.join(HERE, \"dist\"))\n            rmtree(os.path.join(HERE, \"build\"))\n            rmtree(os.path.join(HERE, \"pyexcel.egg-info\"))\n        except OSError:\n            pass\n\n        self.status(\"Building Source and Wheel (universal) distribution...\")\n        run_status = True\n        if has_gease():\n            run_status = os.system(GS_COMMAND) == 0\n        else:\n            self.status(NO_GS_MESSAGE)\n        if run_status:\n            if os.system(PUBLISH_COMMAND) != 0:\n                self.status(UPLOAD_FAILED_MSG)\n\n        sys.exit()\n\n# Data dependencies:\n# - os: imported at top\n# - GS_COMMAND: defined as GS_COMMAND = (\"gease pyexcel v0.7.2 \" + \"Find 0.7.2 in changelog for more details\")\n# - has_gease(): defined below\n# - self.status: defined as staticmethod above\n# - rmtree: imported from shutil\n# - HERE: defined as os.path.abspath(os.path.dirname(__file__))\n# - NO_GS_MESSAGE, PUBLISH_COMMAND, UPLOAD_FAILED_MSG: all defined above",
          "hash_value": "d87d17d93e602c0c40efa7db7241b79f",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class PublishCommand(Command):\n    \"\"\"Support setup.py upload.\"\"\"\n\n    description = \"Build and publish the package on github and pypi\"\n    user_options = []\n\n    @staticmethod\n    def status(s):\n        \"\"\"Prints things in bold.\"\"\"\n        print(\"\\033[1m{0}\\033[0m\".format(s))\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        try:\n            self.status(\"Removing previous builds...\")\n            rmtree(os.path.join(HERE, \"dist\"))\n            rmtree(os.path.join(HERE, \"build\"))\n            rmtree(os.path.join(HERE, \"pyexcel.egg-info\"))\n        except OSError:\n            pass\n\n        self.status(\"Building Source and Wheel (universal) distribution...\")\n        run_status = True\n        if has_gease():\n            run_status = os.system(GS_COMMAND) == 0\n        else:\n            self.status(NO_GS_MESSAGE)\n        if run_status:\n            if os.system(PUBLISH_COMMAND) != 0:\n                self.status(UPLOAD_FAILED_MSG)\n\n        sys.exit()\n\n# Data dependencies:\n# - os: imported at top\n# - GS_COMMAND: defined as GS_COMMAND = (\"gease pyexcel v0.7.2 \" + \"Find 0.7.2 in changelog for more details\")\n# - has_gease(): defined below\n# - self.status: defined as staticmethod above\n# - rmtree: imported from shutil\n# - HERE: defined as os.path.abspath(os.path.dirname(__file__))\n# - NO_GS_MESSAGE, PUBLISH_COMMAND, UPLOAD_FAILED_MSG: all defined above",
              "triple_sequences": [
                {
                  "action_api": "print()",
                  "action_description": "Prints things in bold.",
                  "action_id": "print_bold_text",
                  "object": "\"\\033[1m{0}\\033[0m\".format(s)",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Acknowledge keylogger start/stop",
                  "intention_id": "acknowledge_keylogger_status"
                },
                {
                  "action_api": "rmtree()",
                  "action_description": "Recursively deletes directory and its contents",
                  "action_id": "delete_directory",
                  "object": "os.path.join(HERE, \"dist\")",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Delete directory content",
                  "intention_id": "delete_directory_content"
                },
                {
                  "action_api": "rmtree()",
                  "action_description": "Recursively deletes directory and its contents",
                  "action_id": "delete_directory",
                  "object": "os.path.join(HERE, \"build\")",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Delete directory content",
                  "intention_id": "delete_directory_content"
                },
                {
                  "action_api": "rmtree()",
                  "action_description": "Recursively deletes directory and its contents",
                  "action_id": "delete_directory",
                  "object": "os.path.join(HERE, \"pyexcel.egg-info\")",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Delete directory content",
                  "intention_id": "delete_directory_content"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "HERE, \"dist\"",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "HERE, \"build\"",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "HERE, \"pyexcel.egg-info\"",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "GS_COMMAND",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "PUBLISH_COMMAND",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "slumber-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/slumber-0.7.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/slumber-0.7.1/slumber-0.7.1/setup.py",
          "line_number": "19",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport sys\nfrom setuptools import setup\n\ninstall_requires = [\"requests\"]\ntests_require = [\"mock\", \"unittest2\"]\n\nbase_dir = os.path.dirname(os.path.abspath(__file__))\n\nversion = \"0.7.1\"\n\nif sys.argv[-1] == 'publish':\n    os.system(\"git tag -a %s -m 'v%s'\" % (version, version))\n    os.system(\"python setup.py sdist bdist_wheel upload -r pypi\")\n    print(\"Published version %s, do `git push --tags` to push new tag to remote\" % version)\n    sys.exit()\n\nif sys.argv[-1] == 'syncci':\n    os.system(\"panci --to=tox .travis.yml > tox.ini\");\n    sys.exit();",
          "hash_value": "ac082adcecff9787630f27cb26ce6a0a",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport sys\nfrom setuptools import setup\n\ninstall_requires = [\"requests\"]\ntests_require = [\"mock\", \"unittest2\"]\n\nbase_dir = os.path.dirname(os.path.abspath(__file__))\n\nversion = \"0.7.1\"\n\nif sys.argv[-1] == 'publish':\n    os.system(\"git tag -a %s -m 'v%s'\" % (version, version))\n    os.system(\"python setup.py sdist bdist_wheel upload -r pypi\")\n    print(\"Published version %s, do `git push --tags` to push new tag to remote\" % version)\n    sys.exit()\n\nif sys.argv[-1] == 'syncci':\n    os.system(\"panci --to=tox .travis.yml > tox.ini\");\n    sys.exit();",
              "triple_sequences": [
                {
                  "action_api": "os.path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Get script file path",
                  "intention_id": "get_script_file_path"
                },
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.abspath(__file__)",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "\"git tag -a %s -m 'v%s'\" % (version, version)",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "\"python setup.py sdist bdist_wheel upload -r pypi\"",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "\"panci --to=tox .travis.yml > tox.ini\"",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "dagshub-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/dagshub-0.5.9.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "server.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/dagshub-0.5.9/dagshub-0.5.9/dagshub/data_engine/voxel_plugin_server/server.py",
          "line_number": "41",
          "type_description": "shady-links",
          "context_snippet": "class PluginServer:\n    def __init__(self, state: PluginServerState):\n        self._ev_loop = asyncio.new_event_loop()\n\n        self._config = Config()\n        self._config.bind = [f\"localhost:{DEFAULT_PORT}\"]\n        self._state = state\n\n        self.set_dataset_config(self._state.voxel_session)\n\n        asyncio.set_event_loop(self._ev_loop)\n        self._shutdown_event = asyncio.Event()\n        self._thread = Thread(target=self._ev_loop.run_until_complete, args=(self.start_serve(),), daemon=True)\n        self._thread.start()\n\n    @property\n    def server_address(self):\n        return f\"http://{self._config.bind[0]}\"",
          "hash_value": "07c7d659e95afae9457c2da8b6d9c1f1",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class PluginServer:\n    def __init__(self, state: PluginServerState):\n        self._ev_loop = asyncio.new_event_loop()\n\n        self._config = Config()\n        self._config.bind = [f\"localhost:{DEFAULT_PORT}\"]\n        self._state = state\n\n        self.set_dataset_config(self._state.voxel_session)\n\n        asyncio.set_event_loop(self._ev_loop)\n        self._shutdown_event = asyncio.Event()\n        self._thread = Thread(target=self._ev_loop.run_until_complete, args=(self.start_serve(),), daemon=True)\n        self._thread.start()\n\n    @property\n    def server_address(self):\n        return f\"http://{self._config.bind[0]}\"",
              "triple_sequences": [
                {
                  "action_api": "asyncio.new_event_loop()",
                  "action_description": "Creates asynchronous task",
                  "action_id": "create_async_task",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Concurrent execution preparation",
                  "intention_id": "concurrent_execution_preparation"
                },
                {
                  "action_api": "Config()",
                  "action_description": "Instantiates Setup class",
                  "action_id": "init_setup_class",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "self._config.bind = [f\"localhost:{DEFAULT_PORT}\"]",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "[f\"localhost:{DEFAULT_PORT}\"]",
                  "object_description": "Localhost address",
                  "object_id": "localhost_address",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "self.set_dataset_config()",
                  "action_description": "Instantiates Setup class",
                  "action_id": "init_setup_class",
                  "object": "self._state.voxel_session",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "asyncio.set_event_loop()",
                  "action_description": "Creates asynchronous task",
                  "action_id": "create_async_task",
                  "object": "self._ev_loop",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Concurrent execution preparation",
                  "intention_id": "concurrent_execution_preparation"
                },
                {
                  "action_api": "asyncio.Event()",
                  "action_description": "Creates asynchronous task",
                  "action_id": "create_async_task",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Wait for events",
                  "intention_id": "wait_for_events"
                },
                {
                  "action_api": "Thread()",
                  "action_description": "Creates new thread to execute",
                  "action_id": "create_thread",
                  "object": "target=self._ev_loop.run_until_complete, args=(self.start_serve(),), daemon=True",
                  "object_description": "Thread target and arguments",
                  "object_id": "thread_target_arguments",
                  "intention_description": "Concurrent execution preparation",
                  "intention_id": "concurrent_execution_preparation"
                },
                {
                  "action_api": "self._thread.start()",
                  "action_description": "Starts thread execution",
                  "action_id": "start_thread",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Concurrent execution preparation",
                  "intention_id": "concurrent_execution_preparation"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "sagemaker_pyspark-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/sagemaker_pyspark-1.4.5.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/sagemaker_pyspark-1.4.5/sagemaker_pyspark-1.4.5/setup.py",
          "line_number": "39",
          "type_description": "code-execution",
          "context_snippet": "try:  # noqa\n    if in_sagemaker_sdk:\n        try:\n            shutil.copyfile(os.path.join(\"..\", VERSION_PATH), VERSION_PATH)\n        except OSError:\n            print(\"Could not copy VERSION file\")\n            exit(1)\n\n        try:\n            os.mkdir(TEMP_PATH)\n        except OSError:\n            print(\"Could not create dir {0}\".format(TEMP_PATH), file=sys.stderr)\n            exit(1)\n\n        p = subprocess.Popen(\n            \"sbt printClasspath\".split(),\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            cwd=\"../sagemaker-spark-sdk/\",\n        )\n\n        output, errors = p.communicate()\n\n        classpath = []\n        # Java Libraries to include.\n        java_libraries = [\"aws\", \"sagemaker\", \"hadoop\", \"htrace\"]\n        for line in output.decode(\"utf-8\").splitlines():\n            path = str(line.strip())\n            if path.endswith(\".jar\") and os.path.exists(path):\n                jar = os.path.basename(path).lower()\n                if any(lib in jar for lib in java_libraries):\n                    classpath.append(path)\n\n        os.mkdir(JARS_TARGET)\n        for jar in classpath:\n            target_path = os.path.join(JARS_TARGET, os.path.basename(jar))\n            if not os.path.exists(target_path):\n                shutil.copy(jar, target_path)\n\n        if len(classpath) == 0:\n            print(\"Failed to retrieve the jar classpath. Can't package\")\n            exit(-1)\n\n    else:\n        if not os.path.exists(JARS_TARGET):\n            print(\n                \"You need to be in the sagemaker-pyspark-sdk root folder to package\",\n                file=sys.stderr,\n            )\n            exit(-1)\n\n    setup(\n        name=\"sagemaker_pyspark\",\n        version=read_version(),\n        description=\"Amazon SageMaker PySpark Bindings\",\n        author=\"Amazon Web Services\",\n        url=\"https://github.com/aws/sagemaker-spark\",\n        license=\"Apache License 2.0\",\n        python_requires=\">= 3.7\",\n        zip_safe=False,\n        packages=[\n            \"sagemaker_pyspark\",\n            \"sagemaker_pyspark.algorithms\",\n            \"sagemaker_pyspark.transformation\",\n            \"sagemaker_pyspark.transformation.deserializers\",\n            \"sagemaker_pyspark.transformation.serializers\",\n            \"sagemaker_pyspark.jars\",\n            \"sagemaker_pyspark.licenses\",\n        ],\n        package_dir={\n            \"sagemaker_pyspark\": \"src/sagemaker_pyspark\",\n            \"sagemaker_pyspark.jars\": \"deps/jars\",\n            \"sagemaker_pyspark.licenses\": \"licenses\",\n        },\n        include_package_data=True,\n        package_data={\n            \"sagemaker_pyspark.jars\": [\"*.jar\"],\n            \"sagemaker_pyspark.licenses\": [\"*.txt\"],\n        },\n        scripts=[\"bin/sagemakerpyspark-jars\", \"bin/sagemakerpyspark-emr-jars\"],\n        install_requires=[\n            \"pyspark==3.3.0\",\n            \"numpy\",\n        ],\n    )\n\nfinally:\n    if in_sagemaker_sdk:\n        if os.path.exists(JARS_TARGET):\n            shutil.rmtree(JARS_TARGET)\n\n        if os.path.exists(TEMP_PATH):\n            os.rmdir(TEMP_PATH)\n\n        if os.path.exists(VERSION_PATH):\n            os.remove(VERSION_PATH)\n",
          "hash_value": "c6357473374e034d47a40c938589d8cb",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "try:  # noqa\n    if in_sagemaker_sdk:\n        try:\n            shutil.copyfile(os.path.join(\"..\", VERSION_PATH), VERSION_PATH)\n        except OSError:\n            print(\"Could not copy VERSION file\")\n            exit(1)\n\n        try:\n            os.mkdir(TEMP_PATH)\n        except OSError:\n            print(\"Could not create dir {0}\".format(TEMP_PATH), file=sys.stderr)\n            exit(1)\n\n        p = subprocess.Popen(\n            \"sbt printClasspath\".split(),\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            cwd=\"../sagemaker-spark-sdk/\",\n        )\n\n        output, errors = p.communicate()\n\n        classpath = []\n        # Java Libraries to include.\n        java_libraries = [\"aws\", \"sagemaker\", \"hadoop\", \"htrace\"]\n        for line in output.decode(\"utf-8\").splitlines():\n            path = str(line.strip())\n            if path.endswith(\".jar\") and os.path.exists(path):\n                jar = os.path.basename(path).lower()\n                if any(lib in jar for lib in java_libraries):\n                    classpath.append(path)\n\n        os.mkdir(JARS_TARGET)\n        for jar in classpath:\n            target_path = os.path.join(JARS_TARGET, os.path.basename(jar))\n            if not os.path.exists(target_path):\n                shutil.copy(jar, target_path)\n\n        if len(classpath) == 0:\n            print(\"Failed to retrieve the jar classpath. Can't package\")\n            exit(-1)\n\n    else:\n        if not os.path.exists(JARS_TARGET):\n            print(\n                \"You need to be in the sagemaker-pyspark-sdk root folder to package\",\n                file=sys.stderr,\n            )\n            exit(-1)\n\n    setup(\n        name=\"sagemaker_pyspark\",\n        version=read_version(),\n        description=\"Amazon SageMaker PySpark Bindings\",\n        author=\"Amazon Web Services\",\n        url=\"https://github.com/aws/sagemaker-spark\",\n        license=\"Apache License 2.0\",\n        python_requires=\">= 3.7\",\n        zip_safe=False,\n        packages=[\n            \"sagemaker_pyspark\",\n            \"sagemaker_pyspark.algorithms\",\n            \"sagemaker_pyspark.transformation\",\n            \"sagemaker_pyspark.transformation.deserializers\",\n            \"sagemaker_pyspark.transformation.serializers\",\n            \"sagemaker_pyspark.jars\",\n            \"sagemaker_pyspark.licenses\",\n        ],\n        package_dir={\n            \"sagemaker_pyspark\": \"src/sagemaker_pyspark\",\n            \"sagemaker_pyspark.jars\": \"deps/jars\",\n            \"sagemaker_pyspark.licenses\": \"licenses\",\n        },\n        include_package_data=True,\n        package_data={\n            \"sagemaker_pyspark.jars\": [\"*.jar\"],\n            \"sagemaker_pyspark.licenses\": [\"*.txt\"],\n        },\n        scripts=[\"bin/sagemakerpyspark-jars\", \"bin/sagemakerpyspark-emr-jars\"],\n        install_requires=[\n            \"pyspark==3.3.0\",\n            \"numpy\",\n        ],\n    )\n\nfinally:\n    if in_sagemaker_sdk:\n        if os.path.exists(JARS_TARGET):\n            shutil.rmtree(JARS_TARGET)\n\n        if os.path.exists(TEMP_PATH):\n            os.rmdir(TEMP_PATH)\n\n        if os.path.exists(VERSION_PATH):\n            os.remove(VERSION_PATH)\n",
              "triple_sequences": [
                {
                  "action_api": "shutil.copyfile()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "os.path.join(\"..\", VERSION_PATH), VERSION_PATH",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Copy file to temporary directory",
                  "intention_id": "copy_file_temp_directory"
                },
                {
                  "action_api": "os.mkdir()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "TEMP_PATH",
                  "object_description": "Temporary directory",
                  "object_id": "temporary_directory",
                  "intention_description": "Create temporary directory",
                  "intention_id": "create_temporary_directory"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "\"sbt printClasspath\".split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=\"../sagemaker-spark-sdk/\"",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "p.communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "output.decode()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "\"utf-8\"",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "path",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "os.path.basename()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "path",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Prepare path for file operations",
                  "intention_id": "prepare_path_file_operations"
                },
                {
                  "action_api": "os.mkdir()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "JARS_TARGET",
                  "object_description": "Custom directory",
                  "object_id": "custom_directory",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "target_path",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Determine file presence",
                  "intention_id": "determine_file_presence"
                },
                {
                  "action_api": "shutil.copy()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "jar, target_path",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Copy file to temporary directory",
                  "intention_id": "copy_file_temp_directory"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "JARS_TARGET",
                  "object_description": "Custom directory",
                  "object_id": "custom_directory",
                  "intention_description": "Determine directory presence",
                  "intention_id": "determine_directory_presence"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "name=\"sagemaker_pyspark\", ...",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "JARS_TARGET",
                  "object_description": "Custom directory",
                  "object_id": "custom_directory",
                  "intention_description": "Determine directory presence",
                  "intention_id": "determine_directory_presence"
                },
                {
                  "action_api": "shutil.rmtree()",
                  "action_description": "Recursively deletes directory and its contents",
                  "action_id": "delete_directory",
                  "object": "JARS_TARGET",
                  "object_description": "Custom directory",
                  "object_id": "custom_directory",
                  "intention_description": "Delete directory content",
                  "intention_id": "delete_directory_content"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "TEMP_PATH",
                  "object_description": "Temporary directory",
                  "object_id": "temporary_directory",
                  "intention_description": "Determine directory presence",
                  "intention_id": "determine_directory_presence"
                },
                {
                  "action_api": "os.rmdir()",
                  "action_description": "Recursively deletes directory and its contents",
                  "action_id": "delete_directory",
                  "object": "TEMP_PATH",
                  "object_description": "Temporary directory",
                  "object_id": "temporary_directory",
                  "intention_description": "Delete directory content",
                  "intention_id": "delete_directory_content"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "VERSION_PATH",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Determine file presence",
                  "intention_id": "determine_file_presence"
                },
                {
                  "action_api": "os.remove()",
                  "action_description": "Deletes specified file from filesystem",
                  "action_id": "delete_file",
                  "object": "VERSION_PATH",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Delete file",
                  "intention_id": "delete_file"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "py_cord-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/py_cord-2.6.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "abc.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/py_cord-2.6.1/py_cord-2.6.1/discord/abc.py",
          "line_number": "591",
          "type_description": "shady-links",
          "context_snippet": "@property\n    def jump_url(self) -> str:\n        \"\"\"Returns a URL that allows the client to jump to the channel.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return f\"https://discord.com/channels/{self.guild.id}/{self.id}\"",
          "hash_value": "06e46b8f27a067c64a2d3dbbda78d6f5",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "@property\n    def jump_url(self) -> str:\n        \"\"\"Returns a URL that allows the client to jump to the channel.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return f\"https://discord.com/channels/{self.guild.id}/{self.id}\"",
              "triple_sequences": [
                {
                  "action_api": "str.format()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "\"https://discord.com/channels/{self.guild.id}/{self.id}\"",
                  "object_description": "URL string",
                  "object_id": "url_string",
                  "intention_description": "Prepare URL for HTTP request",
                  "intention_id": "prepare_url_http_request"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "fastapi_sso-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/fastapi_sso-0.18.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "discord.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/fastapi_sso-0.18.0/fastapi_sso-0.18.0/fastapi_sso/sso/discord.py",
          "line_number": "38",
          "type_description": "shady-links",
          "context_snippet": "    async def get_discovery_document(self) -> DiscoveryDocument:\n        return {\n            \"authorization_endpoint\": \"https://discord.com/oauth2/authorize\",\n            \"token_endpoint\": \"https://discord.com/api/oauth2/token\",\n            \"userinfo_endpoint\": \"https://discord.com/api/users/@me\",\n        }",
          "hash_value": "9e48cfd9c241e33e9cb9cb272352f935",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "    async def get_discovery_document(self) -> DiscoveryDocument:\n        return {\n            \"authorization_endpoint\": \"https://discord.com/oauth2/authorize\",\n            \"token_endpoint\": \"https://discord.com/api/oauth2/token\",\n            \"userinfo_endpoint\": \"https://discord.com/api/users/@me\",\n        }",
              "triple_sequences": [
                {
                  "action_api": "return",
                  "action_description": "Serializes Python object to JSON string",
                  "action_id": "serialize_to_json",
                  "object": "{\"authorization_endpoint\": \"https://discord.com/oauth2/authorize\", \"token_endpoint\": \"https://discord.com/api/oauth2/token\", \"userinfo_endpoint\": \"https://discord.com/api/users/@me\"}",
                  "object_description": "JSON string",
                  "object_id": "json_string",
                  "intention_description": "Serialize data",
                  "intention_id": "serialize_data"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "zipfile2-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/zipfile2-0.0.12.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/zipfile2-0.0.12/zipfile2-0.0.12/setup.py",
          "line_number": "30",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport subprocess\n\ndef git_version():\n    def _minimal_ext_cmd(cmd):\n        # construct minimal environment\n        env = {}\n        for k in ['SYSTEMROOT', 'PATH']:\n            v = os.environ.get(k)\n            if v is not None:\n                env[k] = v\n        # LANGUAGE is used on win32\n        env['LANGUAGE'] = 'C'\n        env['LANG'] = 'C'\n        env['LC_ALL'] = 'C'\n        out = subprocess.Popen(cmd, stdout=subprocess.PIPE, env=env).communicate()[0]\n        return out\n\n    try:\n        out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])\n        git_revision = out.strip().decode('ascii')\n    except OSError:\n        git_revision = \"Unknown\"\n\n    try:\n        out = _minimal_ext_cmd(['git', 'rev-list', '--count', 'HEAD'])\n        git_count = out.strip().decode('ascii')\n    except OSError:\n        git_count = \"0\"\n\n    return git_revision, git_count",
          "hash_value": "8dbd437a46d1018bbb9162c7ecd28aad",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport subprocess\n\ndef git_version():\n    def _minimal_ext_cmd(cmd):\n        # construct minimal environment\n        env = {}\n        for k in ['SYSTEMROOT', 'PATH']:\n            v = os.environ.get(k)\n            if v is not None:\n                env[k] = v\n        # LANGUAGE is used on win32\n        env['LANGUAGE'] = 'C'\n        env['LANG'] = 'C'\n        env['LC_ALL'] = 'C'\n        out = subprocess.Popen(cmd, stdout=subprocess.PIPE, env=env).communicate()[0]\n        return out\n\n    try:\n        out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])\n        git_revision = out.strip().decode('ascii')\n    except OSError:\n        git_revision = \"Unknown\"\n\n    try:\n        out = _minimal_ext_cmd(['git', 'rev-list', '--count', 'HEAD'])\n        git_count = out.strip().decode('ascii')\n    except OSError:\n        git_count = \"0\"\n\n    return git_revision, git_count",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "k",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "['git', 'rev-parse', 'HEAD']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.Popen().communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "bytes.strip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "bytes.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "ascii",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Decode bytes to string",
                  "intention_id": "decode_bytes_to_string"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "['git', 'rev-list', '--count', 'HEAD']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.Popen().communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "bytes.strip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "bytes.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "ascii",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Decode bytes to string",
                  "intention_id": "decode_bytes_to_string"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "apache-flink-libraries-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/apache-flink-libraries-2.0.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/apache-flink-libraries-2.0.0/apache-flink-libraries-2.0.0/setup.py",
          "line_number": "181",
          "type_description": "code-execution",
          "context_snippet": "import platform\nimport subprocess\n\nTEMP_PATH = \"deps\"\nthis_directory = os.path.abspath(os.path.dirname(__file__))\n\nif exist_licenses and platform.system() != \"Windows\":\n    # regenerate the licenses directory and NOTICE file as we only copy part of the\n    # flink binary distribution.\n    collect_licenses_file_sh = os.path.abspath(os.path.join(\n        this_directory, \"..\", \"..\", \"tools\", \"releasing\", \"collect_license_files.sh\"))\n    subprocess.check_output([collect_licenses_file_sh, TEMP_PATH, TEMP_PATH])\n    # move the NOTICE file to the root of the package\n    GENERATED_NOTICE_FILE_PATH = os.path.join(TEMP_PATH, \"NOTICE\")\n    os.rename(GENERATED_NOTICE_FILE_PATH, NOTICE_FILE_TEMP_PATH)",
          "hash_value": "6b5bd6ccf3bbeebf50cc3cb30897614e",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import platform\nimport subprocess\n\nTEMP_PATH = \"deps\"\nthis_directory = os.path.abspath(os.path.dirname(__file__))\n\nif exist_licenses and platform.system() != \"Windows\":\n    # regenerate the licenses directory and NOTICE file as we only copy part of the\n    # flink binary distribution.\n    collect_licenses_file_sh = os.path.abspath(os.path.join(\n        this_directory, \"..\", \"..\", \"tools\", \"releasing\", \"collect_license_files.sh\"))\n    subprocess.check_output([collect_licenses_file_sh, TEMP_PATH, TEMP_PATH])\n    # move the NOTICE file to the root of the package\n    GENERATED_NOTICE_FILE_PATH = os.path.join(TEMP_PATH, \"NOTICE\")\n    os.rename(GENERATED_NOTICE_FILE_PATH, NOTICE_FILE_TEMP_PATH)",
              "triple_sequences": [
                {
                  "action_api": "os.path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.dirname(__file__)",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "platform.system()",
                  "action_description": "Retrieves operating system identifier",
                  "action_id": "get_os_id",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine operating system",
                  "intention_id": "determine_operating_system"
                },
                {
                  "action_api": "os.path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.join(this_directory, \"..\", \"..\", \"tools\", \"releasing\", \"collect_license_files.sh\")",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[collect_licenses_file_sh, TEMP_PATH, TEMP_PATH]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.join(TEMP_PATH, \"NOTICE\")",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "os.rename()",
                  "action_description": "Renames file or moves it to new location",
                  "action_id": "rename_file",
                  "object": "os.rename(GENERATED_NOTICE_FILE_PATH, NOTICE_FILE_TEMP_PATH)",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Move file to destination",
                  "intention_id": "move_file_destination"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pyorc-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyorc-0.10.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyorc-0.10.0/pyorc-0.10.0/setup.py",
          "line_number": "168",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport subprocess\n\nclass BuildExt(build_ext):\n    ...\n    def _get_build_envs() -> dict:\n        env = os.environ.copy()\n        if sys.platform != \"win32\":\n            env[\"CFLAGS\"] = \"-fPIC\"\n            env[\"CXXFLAGS\"] = \"-fPIC\"\n        return env\n\n    def _build_with_cmake(self) -> str:\n        build_type = \"DEBUG\" if self.debug else \"RELEASE\"\n        cmake_args = [\n            f\"-DCMAKE_BUILD_TYPE={build_type}\",\n            \"-DBUILD_JAVA=OFF\",\n            \"-DBUILD_LIBHDFSPP=OFF\",\n            \"-DCMAKE_POSITION_INDEPENDENT_CODE=ON\",\n        ]\n        if sys.platform == \"win32\":\n            cmake_args.append(\"-DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreaded\")\n        if not self.debug or sys.platform == \"win32\":\n            cmake_args.append(\"-DBUILD_TOOLS=OFF\")\n            cmake_args.append(\"-DBUILD_CPP_TESTS=OFF\")\n        env = self._get_build_envs()\n        build_dir = os.path.join(\n            self.output_dir, \"orc-{ver}\".format(ver=self.orc_version), \"build\"\n        )\n        if not os.path.exists(build_dir):\n            os.makedirs(build_dir)\n        logging.info(\"Build libraries with cmake\")\n        cmake_cmd = [\"cmake\", \"..\"] + cmake_args\n        logging.info(\"Cmake command: %s\" % cmake_cmd)\n        subprocess.check_call(cmake_cmd, cwd=build_dir, env=env)\n        if sys.platform == \"win32\":\n            subprocess.check_call(\n                [\n                    \"cmake\",\n                    \"--build\",\n                    \".\",\n                    \"--config\",\n                    build_type,\n                    \"--target\",\n                    \"PACKAGE\",\n                ],\n                cwd=build_dir,\n                env=env,\n            )\n        else:\n            j_flag = f\"-j{os.cpu_count() or 1}\"\n            subprocess.check_call([\"make\", j_flag, \"package\"], cwd=build_dir, env=env)\n        return build_dir",
          "hash_value": "3930bd4dc67d278361c153d85a053d99",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport subprocess\n\nclass BuildExt(build_ext):\n    ...\n    def _get_build_envs() -> dict:\n        env = os.environ.copy()\n        if sys.platform != \"win32\":\n            env[\"CFLAGS\"] = \"-fPIC\"\n            env[\"CXXFLAGS\"] = \"-fPIC\"\n        return env\n\n    def _build_with_cmake(self) -> str:\n        build_type = \"DEBUG\" if self.debug else \"RELEASE\"\n        cmake_args = [\n            f\"-DCMAKE_BUILD_TYPE={build_type}\",\n            \"-DBUILD_JAVA=OFF\",\n            \"-DBUILD_LIBHDFSPP=OFF\",\n            \"-DCMAKE_POSITION_INDEPENDENT_CODE=ON\",\n        ]\n        if sys.platform == \"win32\":\n            cmake_args.append(\"-DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreaded\")\n        if not self.debug or sys.platform == \"win32\":\n            cmake_args.append(\"-DBUILD_TOOLS=OFF\")\n            cmake_args.append(\"-DBUILD_CPP_TESTS=OFF\")\n        env = self._get_build_envs()\n        build_dir = os.path.join(\n            self.output_dir, \"orc-{ver}\".format(ver=self.orc_version), \"build\"\n        )\n        if not os.path.exists(build_dir):\n            os.makedirs(build_dir)\n        logging.info(\"Build libraries with cmake\")\n        cmake_cmd = [\"cmake\", \"..\"] + cmake_args\n        logging.info(\"Cmake command: %s\" % cmake_cmd)\n        subprocess.check_call(cmake_cmd, cwd=build_dir, env=env)\n        if sys.platform == \"win32\":\n            subprocess.check_call(\n                [\n                    \"cmake\",\n                    \"--build\",\n                    \".\",\n                    \"--config\",\n                    build_type,\n                    \"--target\",\n                    \"PACKAGE\",\n                ],\n                cwd=build_dir,\n                env=env,\n            )\n        else:\n            j_flag = f\"-j{os.cpu_count() or 1}\"\n            subprocess.check_call([\"make\", j_flag, \"package\"], cwd=build_dir, env=env)\n        return build_dir",
              "triple_sequences": [
                {
                  "action_api": "os.environ.copy()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "os.environ",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "self.output_dir, \"orc-{ver}\".format(ver=self.orc_version), \"build\"",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "build_dir",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "os.makedirs()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "build_dir",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "cmake_cmd, cwd=build_dir, env=env",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"cmake\", \"--build\", \".\", \"--config\", build_type, \"--target\", \"PACKAGE\"], cwd=build_dir, env=env",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.cpu_count()",
                  "action_description": "Retrieves processor name",
                  "action_id": "get_processor_name",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get system info",
                  "intention_id": "get_system_info"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"make\", j_flag, \"package\"], cwd=build_dir, env=env",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "manhole-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/manhole-1.8.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/manhole-1.8.1/manhole-1.8.1/setup.py",
          "line_number": "88",
          "type_description": "cmd-overwrite",
          "context_snippet": "from setuptools import Command\nfrom setuptools import find_packages\nfrom setuptools import setup\nfrom setuptools.command.develop import develop\nfrom setuptools.command.easy_install import easy_install\nfrom setuptools.command.editable_wheel import editable_wheel\nfrom setuptools.command.install_lib import install_lib\n\npth_file = Path(__file__).parent.joinpath('src', 'manhole.pth')\n\n# ... (class definitions omitted for brevity, see full code above)\n\ndef read(*names, **kwargs):\n    with Path(__file__).parent.joinpath(*names).open(encoding=kwargs.get('encoding', 'utf8')) as fh:\n        return fh.read()\n\nsetup(\n    name='manhole',\n    version='1.8.1',\n    license='BSD-2-Clause',\n    description='Manhole is in-process service that will accept unix domain socket connections and present the'\n    'stacktraces for all threads and an interactive prompt.',\n    long_description='{}\\n{}'.format(\n        re.compile('^.. start-badges.*^.. end-badges', re.M | re.S).sub('', read('README.rst')),\n        re.sub(':[a-z]+:`~?(.*?)`', r'``\\1``', read('CHANGELOG.rst')),\n    ),\n    author='Ionel Cristian Mărieș',\n    author_email='contact@ionelmc.ro',\n    url='https://github.com/ionelmc/python-manhole',\n    packages=find_packages('src'),\n    package_dir={'': 'src'},\n    py_modules=[path.stem for path in Path('src').glob('*.py')],\n    include_package_data=True,\n    zip_safe=False,\n    classifiers=[\n        # complete classifier list: http://pypi.python.org/pypi?%3Aaction=list_classifiers\n        'Development Status :: 5 - Production/Stable',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: BSD License',\n        'Operating System :: Unix',\n        'Operating System :: POSIX',\n        'Programming Language :: Python',\n        'Topic :: Software Development :: Debuggers',\n        'Topic :: Utilities',\n        'Topic :: System :: Monitoring',\n        'Topic :: System :: Networking',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3 :: Only',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n        'Programming Language :: Python :: 3.12',\n        'Programming Language :: Python :: Implementation :: CPython',\n        'Programming Language :: Python :: Implementation :: PyPy',\n        # uncomment if you test on these interpreters:\n        # \"Programming Language :: Python :: Implementation :: IronPython\",\n        # \"Programming Language :: Python :: Implementation :: Jython\",\n        # \"Programming Language :: Python :: Implementation :: Stackless\",\n        'Topic :: Utilities',\n    ],\n    project_urls={\n        'Documentation': 'https://python-manhole.readthedocs.io/',\n        'Changelog': 'https://python-manhole.readthedocs.io/en/latest/changelog.html',\n        'Issue Tracker': 'https://github.com/ionelmc/python-manhole/issues',\n    },\n    entry_points={\n        'console_scripts': [\n            'manhole-cli = manhole.cli:main',\n        ]\n    },\n    keywords=['debugging', 'manhole', 'thread', 'socket', 'unix domain socket'],\n    python_requires='>=3.8',\n    install_requires=[\n        # eg: \"aspectlib==1.1.1\", \"six>=1.7\",\n    ],\n    extras_require={\n        # eg:\n        #   \"rst\": [\"docutils>=0.11\"],\n        #   \":python_version==\"2.6\"\": [\"argparse\"],\n    },\n    cmdclass={\n        'build': BuildWithPTH,\n        'easy_install': EasyInstallWithPTH,\n        'install_lib': InstallLibWithPTH,\n        'develop': DevelopWithPTH,\n        'editable_wheel': EditableWheelWithPTH,\n        'genpth': GeneratePTH,\n    },\n)\n",
          "hash_value": "270b5812ca50df5b490ebd941df3bf13",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from setuptools import Command\nfrom setuptools import find_packages\nfrom setuptools import setup\nfrom setuptools.command.develop import develop\nfrom setuptools.command.easy_install import easy_install\nfrom setuptools.command.editable_wheel import editable_wheel\nfrom setuptools.command.install_lib import install_lib\n\npth_file = Path(__file__).parent.joinpath('src', 'manhole.pth')\n\n# ... (class definitions omitted for brevity, see full code above)\n\ndef read(*names, **kwargs):\n    with Path(__file__).parent.joinpath(*names).open(encoding=kwargs.get('encoding', 'utf8')) as fh:\n        return fh.read()\n\nsetup(\n    name='manhole',\n    version='1.8.1',\n    license='BSD-2-Clause',\n    description='Manhole is in-process service that will accept unix domain socket connections and present the'\n    'stacktraces for all threads and an interactive prompt.',\n    long_description='{}\\n{}'.format(\n        re.compile('^.. start-badges.*^.. end-badges', re.M | re.S).sub('', read('README.rst')),\n        re.sub(':[a-z]+:`~?(.*?)`', r'``\\1``', read('CHANGELOG.rst')),\n    ),\n    author='Ionel Cristian Mărieș',\n    author_email='contact@ionelmc.ro',\n    url='https://github.com/ionelmc/python-manhole',\n    packages=find_packages('src'),\n    package_dir={'': 'src'},\n    py_modules=[path.stem for path in Path('src').glob('*.py')],\n    include_package_data=True,\n    zip_safe=False,\n    classifiers=[\n        # complete classifier list: http://pypi.python.org/pypi?%3Aaction=list_classifiers\n        'Development Status :: 5 - Production/Stable',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: BSD License',\n        'Operating System :: Unix',\n        'Operating System :: POSIX',\n        'Programming Language :: Python',\n        'Topic :: Software Development :: Debuggers',\n        'Topic :: Utilities',\n        'Topic :: System :: Monitoring',\n        'Topic :: System :: Networking',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3 :: Only',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n        'Programming Language :: Python :: 3.12',\n        'Programming Language :: Python :: Implementation :: CPython',\n        'Programming Language :: Python :: Implementation :: PyPy',\n        # uncomment if you test on these interpreters:\n        # \"Programming Language :: Python :: Implementation :: IronPython\",\n        # \"Programming Language :: Python :: Implementation :: Jython\",\n        # \"Programming Language :: Python :: Implementation :: Stackless\",\n        'Topic :: Utilities',\n    ],\n    project_urls={\n        'Documentation': 'https://python-manhole.readthedocs.io/',\n        'Changelog': 'https://python-manhole.readthedocs.io/en/latest/changelog.html',\n        'Issue Tracker': 'https://github.com/ionelmc/python-manhole/issues',\n    },\n    entry_points={\n        'console_scripts': [\n            'manhole-cli = manhole.cli:main',\n        ]\n    },\n    keywords=['debugging', 'manhole', 'thread', 'socket', 'unix domain socket'],\n    python_requires='>=3.8',\n    install_requires=[\n        # eg: \"aspectlib==1.1.1\", \"six>=1.7\",\n    ],\n    extras_require={\n        # eg:\n        #   \"rst\": [\"docutils>=0.11\"],\n        #   \":python_version==\"2.6\"\": [\"argparse\"],\n    },\n    cmdclass={\n        'build': BuildWithPTH,\n        'easy_install': EasyInstallWithPTH,\n        'install_lib': InstallLibWithPTH,\n        'develop': DevelopWithPTH,\n        'editable_wheel': EditableWheelWithPTH,\n        'genpth': GeneratePTH,\n    },\n)\n",
              "triple_sequences": [
                {
                  "action_api": "Path(__file__).parent.joinpath().open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "Path(__file__).parent.joinpath(*names)",
                  "object_description": "Local file or directory",
                  "object_id": "local_file_or_directory",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "fh.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "fh",
                  "object_description": "Local file",
                  "object_id": "local_file",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "re.compile()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "'^.. start-badges.*^.. end-badges', re.M | re.S",
                  "object_description": "Regex pattern",
                  "object_id": "regex_pattern",
                  "intention_description": "Browser profile detection preparation",
                  "intention_id": "browser_profile_detection_preparation"
                },
                {
                  "action_api": "re.compile().sub()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "'', read('README.rst')",
                  "object_description": "Regex file content",
                  "object_id": "regex_file_content",
                  "intention_description": "Decode obfuscated code content",
                  "intention_id": "decode_obfuscated_code"
                },
                {
                  "action_api": "re.sub()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "':[a-z]+:`~?(.*?)`', r'``\\1``', read('CHANGELOG.rst')",
                  "object_description": "Regex file content",
                  "object_id": "regex_file_content",
                  "intention_description": "Decode obfuscated code content",
                  "intention_id": "decode_obfuscated_code"
                },
                {
                  "action_api": "find_packages()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "'src'",
                  "object_description": "Custom directory",
                  "object_id": "custom_directory",
                  "intention_description": "List directory files",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "Path('src').glob()",
                  "action_description": "List directory contents",
                  "action_id": "list_directory_contents",
                  "object": "'*.py'",
                  "object_description": "File extension",
                  "object_id": "file_extension",
                  "intention_description": "List directory files",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "setup(...)",
                  "object_description": "Python command",
                  "object_id": "python_command",
                  "intention_description": "Trigger main behavioral logic",
                  "intention_id": "trigger_main_behavioral_logic"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "crypto_cpp_py-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/crypto_cpp_py-1.4.5.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/crypto_cpp_py-1.4.5/crypto_cpp_py-1.4.5/setup.py",
          "line_number": "30",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport subprocess\n\nfrom setuptools import Extension, setup\nfrom setuptools.command.build_ext import build_ext\nfrom setuptools.command.build_py import build_py\n\n\nclass CryptoExtension(Extension):\n    def __init__(self):\n        self.name = \"crypto_cpp\"\n        Extension.__init__(self, self.name, sources=[])\n\n\nclass BuildPy(build_py):\n    def run(self):\n        self.run_command(\"build_ext\")\n        return super().run()\n\n\nclass BuildCrypto(build_ext):\n    already_built = False\n\n    def build_extension(self, ext):\n        if self.already_built:\n            print(\"was already built, skipping...\")\n            return\n\n        if os.name != \"nt\":\n            subprocess.run(\"chmod a+x ./build_extension.sh\", shell=True, check=True)\n            subprocess.run(\n                \"./build_extension.sh\",\n                shell=True,\n                check=True,\n            )\n        else:\n            with subprocess.Popen(\n                [\"powershell.exe\", \".\\\\build_extension.ps1\"]\n            ) as process:\n                process.wait()\n                if process.returncode != 0:\n                    raise Exception(\"Build returned a non-zero code\")\n\n        self.already_built = True",
          "hash_value": "44c8f8cc24bc6f21d1140d59c471e99d",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport subprocess\n\nfrom setuptools import Extension, setup\nfrom setuptools.command.build_ext import build_ext\nfrom setuptools.command.build_py import build_py\n\n\nclass CryptoExtension(Extension):\n    def __init__(self):\n        self.name = \"crypto_cpp\"\n        Extension.__init__(self, self.name, sources=[])\n\n\nclass BuildPy(build_py):\n    def run(self):\n        self.run_command(\"build_ext\")\n        return super().run()\n\n\nclass BuildCrypto(build_ext):\n    already_built = False\n\n    def build_extension(self, ext):\n        if self.already_built:\n            print(\"was already built, skipping...\")\n            return\n\n        if os.name != \"nt\":\n            subprocess.run(\"chmod a+x ./build_extension.sh\", shell=True, check=True)\n            subprocess.run(\n                \"./build_extension.sh\",\n                shell=True,\n                check=True,\n            )\n        else:\n            with subprocess.Popen(\n                [\"powershell.exe\", \".\\\\build_extension.ps1\"]\n            ) as process:\n                process.wait()\n                if process.returncode != 0:\n                    raise Exception(\"Build returned a non-zero code\")\n\n        self.already_built = True",
              "triple_sequences": [
                {
                  "action_api": "os.name",
                  "action_description": "Retrieves operating system identifier",
                  "action_id": "get_os_id",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine operating system",
                  "intention_id": "get_operating_system_name"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Spawns new process to execute command with shell access",
                  "action_id": "spawn_process_shell",
                  "object": "chmod a+x ./build_extension.sh",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Modify file attributes",
                  "intention_id": "modify_file_attributes"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Spawns new process to execute command with shell access",
                  "action_id": "spawn_process_shell",
                  "object": "./build_extension.sh",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute file",
                  "intention_id": "execute_file"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command with shell access",
                  "action_id": "spawn_process_shell",
                  "object": "[\"powershell.exe\", \".\\\\build_extension.ps1\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute file",
                  "intention_id": "execute_file"
                },
                {
                  "action_api": "process.wait()",
                  "action_description": "Waits for process to complete execution",
                  "action_id": "wait_process_completion",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Wait for events",
                  "intention_id": "wait_for_events"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "flaxmodels-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/flaxmodels-0.1.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "file_utils.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/flaxmodels-0.1.3/flaxmodels-0.1.3/flaxmodels/gpt2/third_party/huggingface_transformers/utils/file_utils.py",
          "line_number": "1189",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "def define_sagemaker_information():\n    try:\n        instance_data = requests.get(os.environ[\"ECS_CONTAINER_METADATA_URI\"]).json()\n        dlc_container_used = instance_data[\"Image\"]\n        dlc_tag = instance_data[\"Image\"].split(\":\")[1]\n    except Exception:\n        dlc_container_used = None\n        dlc_tag = None\n\n    sagemaker_params = json.loads(os.getenv(\"SM_FRAMEWORK_PARAMS\", \"{}\"))\n    runs_distributed_training = True if \"sagemaker_distributed_dataparallel_enabled\" in sagemaker_params else False\n    account_id = os.getenv(\"TRAINING_JOB_ARN\").split(\":\")[4] if \"TRAINING_JOB_ARN\" in os.environ else None\n\n    sagemaker_object = {\n        \"sm_framework\": os.getenv(\"SM_FRAMEWORK_MODULE\", None),\n        \"sm_region\": os.getenv(\"AWS_REGION\", None),\n        \"sm_number_gpu\": os.getenv(\"SM_NUM_GPUS\", 0),\n        \"sm_number_cpu\": os.getenv(\"SM_NUM_CPUS\", 0),\n        \"sm_distributed_training\": runs_distributed_training,\n        \"sm_deep_learning_container\": dlc_container_used,\n        \"sm_deep_learning_container_tag\": dlc_tag,\n        \"sm_account_id\": account_id,\n    }\n    return sagemaker_object",
          "hash_value": "87631b0e9fee996243ad22c4f9960d88",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def define_sagemaker_information():\n    try:\n        instance_data = requests.get(os.environ[\"ECS_CONTAINER_METADATA_URI\"]).json()\n        dlc_container_used = instance_data[\"Image\"]\n        dlc_tag = instance_data[\"Image\"].split(\":\")[1]\n    except Exception:\n        dlc_container_used = None\n        dlc_tag = None\n\n    sagemaker_params = json.loads(os.getenv(\"SM_FRAMEWORK_PARAMS\", \"{}\"))\n    runs_distributed_training = True if \"sagemaker_distributed_dataparallel_enabled\" in sagemaker_params else False\n    account_id = os.getenv(\"TRAINING_JOB_ARN\").split(\":\")[4] if \"TRAINING_JOB_ARN\" in os.environ else None\n\n    sagemaker_object = {\n        \"sm_framework\": os.getenv(\"SM_FRAMEWORK_MODULE\", None),\n        \"sm_region\": os.getenv(\"AWS_REGION\", None),\n        \"sm_number_gpu\": os.getenv(\"SM_NUM_GPUS\", 0),\n        \"sm_number_cpu\": os.getenv(\"SM_NUM_CPUS\", 0),\n        \"sm_distributed_training\": runs_distributed_training,\n        \"sm_deep_learning_container\": dlc_container_used,\n        \"sm_deep_learning_container_tag\": dlc_tag,\n        \"sm_account_id\": account_id,\n    }\n    return sagemaker_object",
              "triple_sequences": [
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP GET request to URL",
                  "action_id": "open_url_get",
                  "object": "os.environ[\"ECS_CONTAINER_METADATA_URI\"]",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "requests.get().json()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "instance_data[\"Image\"]",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "os.getenv()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"SM_FRAMEWORK_PARAMS\", \"{}\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "json.loads()",
                  "action_description": "Deserializes JSON string to Python object",
                  "action_id": "deserialize_from_json",
                  "object": "os.getenv(\"SM_FRAMEWORK_PARAMS\", \"{}\")",
                  "object_description": "JSON string",
                  "object_id": "json_string",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "os.getenv()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"TRAINING_JOB_ARN\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.getenv(\"TRAINING_JOB_ARN\")",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "os.getenv()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"SM_FRAMEWORK_MODULE\", None",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.getenv()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"AWS_REGION\", None",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.getenv()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"SM_NUM_GPUS\", 0",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.getenv()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"SM_NUM_CPUS\", 0",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "tinybird_cli-5",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/tinybird_cli-5.20.1.dev0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "common.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/tinybird_cli-5.20.1.dev0/tinybird_cli-5.20.1.dev0/tinybird/tb_cli_modules/common.py",
          "line_number": "1928",
          "type_description": "clipboard-access",
          "context_snippet": "async def validate_aws_iamrole_integration(\n    client: TinyB,\n    service: str,\n    role_arn: Optional[str],\n    region: Optional[str],\n    policy: str = \"write\",\n    no_validate: Optional[bool] = False,\n):\n    if no_validate is False:\n        access_policy, trust_policy, external_id = await get_aws_iamrole_policies(\n            client, service=service, policy=policy\n        )\n\n        if not role_arn:\n            if not click.confirm(\n                FeedbackManager.prompt_s3_iamrole_connection_login_aws(),\n                show_default=False,\n                prompt_suffix=\"Press y to continue:\",\n            ):\n                sys.exit(1)\n\n            access_policy_copied = True\n            try:\n                pyperclip.copy(access_policy)\n            except Exception:\n                access_policy_copied = False\n\n            replacements_dict = {\n                \"<bucket>\": \"<bucket> with your bucket name\",\n                \"<table_name>\": \"<table_name> with your DynamoDB table name\",\n            }\n\n            replacements = [\n                replacements_dict.get(replacement, \"\")\n                for replacement in replacements_dict.keys()\n                if replacement in access_policy\n            ]\n\n            if not click.confirm(\n                (\n                    FeedbackManager.prompt_s3_iamrole_connection_policy(\n                        access_policy=access_policy, replacements=\", \".join(replacements)\n                    )\n                    if access_policy_copied\n                    else FeedbackManager.prompt_s3_iamrole_connection_policy_not_copied(access_policy=access_policy)\n                ),\n                show_default=False,\n                prompt_suffix=\"Press y to continue:\",\n            ):\n                sys.exit(1)\n\n            trust_policy_copied = True\n            try:\n                pyperclip.copy(trust_policy)\n            except Exception:\n                trust_policy_copied = False\n\n            if not click.confirm(\n                (\n                    FeedbackManager.prompt_s3_iamrole_connection_role(trust_policy=trust_policy)\n                    if trust_policy_copied\n                    else FeedbackManager.prompt_s3_iamrole_connection_role_not_copied(trust_policy=trust_policy)\n                ),\n                show_default=False,\n                prompt_suffix=\"Press y to continue:\",\n            ):\n                sys.exit(1)\n    else:\n        try:\n            trust_policy = await client.get_trust_policy(service)\n            external_id = trust_policy[\"Statement\"][0][\"Condition\"][\"StringEquals\"][\"sts:ExternalId\"]\n        except Exception:\n            external_id = \"\"\n\n    if not role_arn:\n        role_arn = click.prompt(\"Enter the ARN of the role you just created\")\n        validate_string_connector_param(\"Role ARN\", role_arn)\n\n    if not region:\n        region_resource = \"table\" if service == DataConnectorType.AMAZON_DYNAMODB else \"bucket\"\n        region = click.prompt(f\"Enter the region where the {region_resource} is located\")\n        validate_string_connector_param(\"Region\", region)\n\n    return role_arn, region, external_id",
          "hash_value": "79a25499f2450319be0fbd51c85b1c76",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "async def validate_aws_iamrole_integration(\n    client: TinyB,\n    service: str,\n    role_arn: Optional[str],\n    region: Optional[str],\n    policy: str = \"write\",\n    no_validate: Optional[bool] = False,\n):\n    if no_validate is False:\n        access_policy, trust_policy, external_id = await get_aws_iamrole_policies(\n            client, service=service, policy=policy\n        )\n\n        if not role_arn:\n            if not click.confirm(\n                FeedbackManager.prompt_s3_iamrole_connection_login_aws(),\n                show_default=False,\n                prompt_suffix=\"Press y to continue:\",\n            ):\n                sys.exit(1)\n\n            access_policy_copied = True\n            try:\n                pyperclip.copy(access_policy)\n            except Exception:\n                access_policy_copied = False\n\n            replacements_dict = {\n                \"<bucket>\": \"<bucket> with your bucket name\",\n                \"<table_name>\": \"<table_name> with your DynamoDB table name\",\n            }\n\n            replacements = [\n                replacements_dict.get(replacement, \"\")\n                for replacement in replacements_dict.keys()\n                if replacement in access_policy\n            ]\n\n            if not click.confirm(\n                (\n                    FeedbackManager.prompt_s3_iamrole_connection_policy(\n                        access_policy=access_policy, replacements=\", \".join(replacements)\n                    )\n                    if access_policy_copied\n                    else FeedbackManager.prompt_s3_iamrole_connection_policy_not_copied(access_policy=access_policy)\n                ),\n                show_default=False,\n                prompt_suffix=\"Press y to continue:\",\n            ):\n                sys.exit(1)\n\n            trust_policy_copied = True\n            try:\n                pyperclip.copy(trust_policy)\n            except Exception:\n                trust_policy_copied = False\n\n            if not click.confirm(\n                (\n                    FeedbackManager.prompt_s3_iamrole_connection_role(trust_policy=trust_policy)\n                    if trust_policy_copied\n                    else FeedbackManager.prompt_s3_iamrole_connection_role_not_copied(trust_policy=trust_policy)\n                ),\n                show_default=False,\n                prompt_suffix=\"Press y to continue:\",\n            ):\n                sys.exit(1)\n    else:\n        try:\n            trust_policy = await client.get_trust_policy(service)\n            external_id = trust_policy[\"Statement\"][0][\"Condition\"][\"StringEquals\"][\"sts:ExternalId\"]\n        except Exception:\n            external_id = \"\"\n\n    if not role_arn:\n        role_arn = click.prompt(\"Enter the ARN of the role you just created\")\n        validate_string_connector_param(\"Role ARN\", role_arn)\n\n    if not region:\n        region_resource = \"table\" if service == DataConnectorType.AMAZON_DYNAMODB else \"bucket\"\n        region = click.prompt(f\"Enter the region where the {region_resource} is located\")\n        validate_string_connector_param(\"Region\", region)\n\n    return role_arn, region, external_id",
              "triple_sequences": [
                {
                  "action_api": "get_aws_iamrole_policies()",
                  "action_description": "Instantiates class or retrieves object with custom configuration",
                  "action_id": "create_dns_resolver",
                  "object": "client, service=service, policy=policy",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "click.confirm()",
                  "action_description": "Reads user input from standard input",
                  "action_id": "read_user_input",
                  "object": "FeedbackManager.prompt_s3_iamrole_connection_login_aws(), show_default=False, prompt_suffix=\"Press y to continue:\"",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect user input",
                  "intention_id": "collect_user_input"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "1",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                },
                {
                  "action_api": "pyperclip.copy()",
                  "action_description": "Copies specified text to system clipboard",
                  "action_id": "copy_to_clipboard",
                  "object": "access_policy",
                  "object_description": "Clipboard content data",
                  "object_id": "clipboard_data",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                },
                {
                  "action_api": "click.confirm()",
                  "action_description": "Reads user input from standard input",
                  "action_id": "read_user_input",
                  "object": "FeedbackManager.prompt_s3_iamrole_connection_policy(access_policy=access_policy, replacements=\", \".join(replacements)) or FeedbackManager.prompt_s3_iamrole_connection_policy_not_copied(access_policy=access_policy), show_default=False, prompt_suffix=\"Press y to continue:\"",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect user input",
                  "intention_id": "collect_user_input"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "1",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                },
                {
                  "action_api": "pyperclip.copy()",
                  "action_description": "Copies specified text to system clipboard",
                  "action_id": "copy_to_clipboard",
                  "object": "trust_policy",
                  "object_description": "Clipboard content data",
                  "object_id": "clipboard_data",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                },
                {
                  "action_api": "click.confirm()",
                  "action_description": "Reads user input from standard input",
                  "action_id": "read_user_input",
                  "object": "FeedbackManager.prompt_s3_iamrole_connection_role(trust_policy=trust_policy) or FeedbackManager.prompt_s3_iamrole_connection_role_not_copied(trust_policy=trust_policy), show_default=False, prompt_suffix=\"Press y to continue:\"",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect user input",
                  "intention_id": "collect_user_input"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "1",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                },
                {
                  "action_api": "client.get_trust_policy()",
                  "action_description": "Instantiates class or retrieves object with custom configuration",
                  "action_id": "create_dns_resolver",
                  "object": "service",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "click.prompt()",
                  "action_description": "Reads user input from standard input",
                  "action_id": "read_user_input",
                  "object": "\"Enter the ARN of the role you just created\"",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect user input",
                  "intention_id": "collect_user_input"
                },
                {
                  "action_api": "validate_string_connector_param()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "\"Role ARN\", role_arn",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "click.prompt()",
                  "action_description": "Reads user input from standard input",
                  "action_id": "read_user_input",
                  "object": "f\"Enter the region where the {region_resource} is located\"",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect user input",
                  "intention_id": "collect_user_input"
                },
                {
                  "action_api": "validate_string_connector_param()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "\"Region\", region",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pyhcl-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyhcl-0.4.5.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyhcl-0.4.5/pyhcl-0.4.5/setup.py",
          "line_number": "46",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport sys\nimport subprocess\n\nsetup_dir = abspath(dirname(__file__))\nversion_file = join(setup_dir, 'src', 'hcl', 'version.py')\n\n# Automatically generate a version.py based on the git version\nif exists(join(setup_dir, '.git')):\n    p = subprocess.Popen(\n        [\"git\", \"describe\", \"--tags\", \"--long\", \"--dirty=-dirty\"],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n    )\n    out, err = p.communicate()\n    # Make sure the git version has at least one tag\n    if err:\n        print(\"Error: You need to create a tag for this repo to use the builder\")\n        sys.exit(1)\n\n    # Convert git version to PEP440 compliant version\n    # - Older versions of pip choke on local identifiers, so we can't include the git commit\n    v, commits, local = out.decode('utf-8').rstrip().split('-', 2)\n    if commits != '0' or '-dirty' in local:\n        v = '%s.post0.dev%s' % (v, commits)\n\n    # Create the version.py file\n    with open(version_file, 'w') as fp:\n        fp.write(\"# Autogenerated by setup.py\\n__version__ = '{0}'\".format(v))",
          "hash_value": "38125ab94600fcf94c800cdd7b93fa48",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport sys\nimport subprocess\n\nsetup_dir = abspath(dirname(__file__))\nversion_file = join(setup_dir, 'src', 'hcl', 'version.py')\n\n# Automatically generate a version.py based on the git version\nif exists(join(setup_dir, '.git')):\n    p = subprocess.Popen(\n        [\"git\", \"describe\", \"--tags\", \"--long\", \"--dirty=-dirty\"],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n    )\n    out, err = p.communicate()\n    # Make sure the git version has at least one tag\n    if err:\n        print(\"Error: You need to create a tag for this repo to use the builder\")\n        sys.exit(1)\n\n    # Convert git version to PEP440 compliant version\n    # - Older versions of pip choke on local identifiers, so we can't include the git commit\n    v, commits, local = out.decode('utf-8').rstrip().split('-', 2)\n    if commits != '0' or '-dirty' in local:\n        v = '%s.post0.dev%s' % (v, commits)\n\n    # Create the version.py file\n    with open(version_file, 'w') as fp:\n        fp.write(\"# Autogenerated by setup.py\\n__version__ = '{0}'\".format(v))",
              "triple_sequences": [
                {
                  "action_api": "abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "dirname(__file__)",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Get script file path",
                  "intention_id": "get_script_file_path"
                },
                {
                  "action_api": "join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "setup_dir, 'src', 'hcl', 'version.py'",
                  "object_description": "Directory path with file",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "join(setup_dir, '.git')",
                  "object_description": "Directory path with file",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "[\"git\", \"describe\", \"--tags\", \"--long\", \"--dirty=-dirty\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "p.communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "print()",
                  "action_description": "Retrieves standard output stream object",
                  "action_id": "get_stdout_stream",
                  "object": "\"Error: You need to create a tag for this repo to use the builder\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "1",
                  "object_description": "Status code",
                  "object_id": "status_code",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                },
                {
                  "action_api": "out.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "'utf-8'",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Decode bytes to string",
                  "intention_id": "decode_bytes_to_string"
                },
                {
                  "action_api": "str.rstrip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "'-', 2",
                  "object_description": "Space delimiter",
                  "object_id": "space_delimiter",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for writing (normal writing, binary writing)",
                  "action_id": "basic_write_operations",
                  "object": "version_file, 'w'",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for writing",
                  "intention_id": "open_file_writing"
                },
                {
                  "action_api": "fp.write()",
                  "action_description": "File opening operations for writing (normal writing, binary writing)",
                  "action_id": "basic_write_operations",
                  "object": "\"# Autogenerated by setup.py\\n__version__ = '{0}'\".format(v)",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "oscrypto-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/oscrypto-1.3.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/oscrypto-1.3.0/oscrypto-1.3.0/setup.py",
          "line_number": "102",
          "type_description": "cmd-overwrite",
          "context_snippet": "import codecs\nimport os\nimport shutil\nimport sys\nimport warnings\n\nimport setuptools\nfrom setuptools import find_packages, setup, Command\nfrom setuptools.command.egg_info import egg_info\n\n\nPACKAGE_NAME = 'oscrypto'\nPACKAGE_VERSION = '1.3.0'\nPACKAGE_ROOT = os.path.dirname(os.path.abspath(__file__))\n\n\n# setuptools 38.6.0 and newer know about long_description_content_type, but\n# distutils still complains about it, so silence the warning\nsv = setuptools.__version__\nsvi = tuple(int(o) if o.isdigit() else o for o in sv.split('.'))\nif svi >= (38, 6):\n    warnings.filterwarnings(\n        'ignore',\n        \"Unknown distribution option: 'long_description_content_type'\",\n        module='distutils.dist'\n    )\n\n\n# Try to load the tests first from the source repository layout. If that\n# doesn't work, we assume this file is in the release package, and the tests\n# are part of the package {PACKAGE_NAME}_tests.\nif os.path.exists(os.path.join(PACKAGE_ROOT, 'tests')):\n    tests_require = []\n    test_suite = 'tests.make_suite'\nelse:\n    tests_require = ['%s_tests' % PACKAGE_NAME]\n    test_suite = '%s_tests.make_suite' % PACKAGE_NAME\n\n\n# This allows us to send the LICENSE and docs when creating a sdist. Wheels\n# automatically include the LICENSE, and don't need the docs. For these\n# to be included, the command must be \"python setup.py sdist\".\npackage_data = {}\nif sys.argv[1:] == ['sdist'] or sorted(sys.argv[1:]) == ['-q', 'sdist']:\n    package_data[PACKAGE_NAME] = [\n        '../LICENSE',\n        '../*.md',\n        '../docs/*.md',\n    ]\n\n\n# Ensures a copy of the LICENSE is included with the egg-info for\n# install and bdist_egg commands\nclass EggInfoCommand(egg_info):\n    def run(self):\n        egg_info_path = os.path.join(\n            PACKAGE_ROOT,\n            '%s.egg-info' % PACKAGE_NAME\n        )\n        if not os.path.exists(egg_info_path):\n            os.mkdir(egg_info_path)\n        shutil.copy2(\n            os.path.join(PACKAGE_ROOT, 'LICENSE'),\n            os.path.join(egg_info_path, 'LICENSE')\n        )\n        egg_info.run(self)\n\n\nclass CleanCommand(Command):\n    user_options = [\n        ('all', 'a', '(Compatibility with original clean command)'),\n    ]\n\n    def initialize_options(self):\n        self.all = False\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        sub_folders = ['build', 'temp', '%s.egg-info' % PACKAGE_NAME]\n        if self.all:\n            sub_folders.append('dist')\n        for sub_folder in sub_folders:\n            full_path = os.path.join(PACKAGE_ROOT, sub_folder)\n            if os.path.exists(full_path):\n                shutil.rmtree(full_path)\n        for root, dirs, files in os.walk(os.path.join(PACKAGE_ROOT, PACKAGE_NAME)):\n            for filename in files:\n                if filename[-4:] == '.pyc':\n                    os.unlink(os.path.join(root, filename))\n            for dirname in list(dirs):\n                if dirname == '__pycache__':\n                    shutil.rmtree(os.path.join(root, dirname))\n\n\nreadme = ''\nwith codecs.open(os.path.join(PACKAGE_ROOT, 'readme.md'), 'r', 'utf-8') as f:\n    readme = f.read()\n\n\nsetup(\n    name=PACKAGE_NAME,\n    version=PACKAGE_VERSION,\n\n    description=(\n        'TLS (SSL) sockets, key generation, encryption, decryption, signing, '\n        'verification and KDFs using the OS crypto libraries. Does not require '\n        'a compiler, and relies on the OS for patching. Works on Windows, OS X '\n        'and Linux/BSD.'\n    ),\n    long_description=readme,\n    long_description_content_type='text/markdown',\n\n    url='https://github.com/wbond/oscrypto',\n\n    author='wbond',\n    author_email='will@wbond.net',\n\n    license='MIT',\n\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n\n        'Intended Audience :: Developers',\n\n        'License :: OSI Approved :: MIT License',\n\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 2.6',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.2',\n        'Programming Language :: Python :: 3.3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: Implementation :: PyPy',\n\n        'Topic :: Security :: Cryptography',\n    ],\n\n    keywords='crypto pki tls ssl x509 certificate encrypt decrypt sign verify rsa dsa ec dh',\n\n    install_requires=['asn1crypto>=1.5.1'],\n\n    packages=find_packages(exclude=['tests*', 'dev*']),\n    package_data=package_data,\n\n    tests_require=tests_require,\n    test_suite=test_suite,\n\n    cmdclass={\n        'clean': CleanCommand,\n        'egg_info': EggInfoCommand,\n    }\n)\n",
          "hash_value": "b980cd6984f76cc8080505861bccf5c8",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import codecs\nimport os\nimport shutil\nimport sys\nimport warnings\n\nimport setuptools\nfrom setuptools import find_packages, setup, Command\nfrom setuptools.command.egg_info import egg_info\n\n\nPACKAGE_NAME = 'oscrypto'\nPACKAGE_VERSION = '1.3.0'\nPACKAGE_ROOT = os.path.dirname(os.path.abspath(__file__))\n\n\n# setuptools 38.6.0 and newer know about long_description_content_type, but\n# distutils still complains about it, so silence the warning\nsv = setuptools.__version__\nsvi = tuple(int(o) if o.isdigit() else o for o in sv.split('.'))\nif svi >= (38, 6):\n    warnings.filterwarnings(\n        'ignore',\n        \"Unknown distribution option: 'long_description_content_type'\",\n        module='distutils.dist'\n    )\n\n\n# Try to load the tests first from the source repository layout. If that\n# doesn't work, we assume this file is in the release package, and the tests\n# are part of the package {PACKAGE_NAME}_tests.\nif os.path.exists(os.path.join(PACKAGE_ROOT, 'tests')):\n    tests_require = []\n    test_suite = 'tests.make_suite'\nelse:\n    tests_require = ['%s_tests' % PACKAGE_NAME]\n    test_suite = '%s_tests.make_suite' % PACKAGE_NAME\n\n\n# This allows us to send the LICENSE and docs when creating a sdist. Wheels\n# automatically include the LICENSE, and don't need the docs. For these\n# to be included, the command must be \"python setup.py sdist\".\npackage_data = {}\nif sys.argv[1:] == ['sdist'] or sorted(sys.argv[1:]) == ['-q', 'sdist']:\n    package_data[PACKAGE_NAME] = [\n        '../LICENSE',\n        '../*.md',\n        '../docs/*.md',\n    ]\n\n\n# Ensures a copy of the LICENSE is included with the egg-info for\n# install and bdist_egg commands\nclass EggInfoCommand(egg_info):\n    def run(self):\n        egg_info_path = os.path.join(\n            PACKAGE_ROOT,\n            '%s.egg-info' % PACKAGE_NAME\n        )\n        if not os.path.exists(egg_info_path):\n            os.mkdir(egg_info_path)\n        shutil.copy2(\n            os.path.join(PACKAGE_ROOT, 'LICENSE'),\n            os.path.join(egg_info_path, 'LICENSE')\n        )\n        egg_info.run(self)\n\n\nclass CleanCommand(Command):\n    user_options = [\n        ('all', 'a', '(Compatibility with original clean command)'),\n    ]\n\n    def initialize_options(self):\n        self.all = False\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        sub_folders = ['build', 'temp', '%s.egg-info' % PACKAGE_NAME]\n        if self.all:\n            sub_folders.append('dist')\n        for sub_folder in sub_folders:\n            full_path = os.path.join(PACKAGE_ROOT, sub_folder)\n            if os.path.exists(full_path):\n                shutil.rmtree(full_path)\n        for root, dirs, files in os.walk(os.path.join(PACKAGE_ROOT, PACKAGE_NAME)):\n            for filename in files:\n                if filename[-4:] == '.pyc':\n                    os.unlink(os.path.join(root, filename))\n            for dirname in list(dirs):\n                if dirname == '__pycache__':\n                    shutil.rmtree(os.path.join(root, dirname))\n\n\nreadme = ''\nwith codecs.open(os.path.join(PACKAGE_ROOT, 'readme.md'), 'r', 'utf-8') as f:\n    readme = f.read()\n\n\nsetup(\n    name=PACKAGE_NAME,\n    version=PACKAGE_VERSION,\n\n    description=(\n        'TLS (SSL) sockets, key generation, encryption, decryption, signing, '\n        'verification and KDFs using the OS crypto libraries. Does not require '\n        'a compiler, and relies on the OS for patching. Works on Windows, OS X '\n        'and Linux/BSD.'\n    ),\n    long_description=readme,\n    long_description_content_type='text/markdown',\n\n    url='https://github.com/wbond/oscrypto',\n\n    author='wbond',\n    author_email='will@wbond.net',\n\n    license='MIT',\n\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n\n        'Intended Audience :: Developers',\n\n        'License :: OSI Approved :: MIT License',\n\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 2.6',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.2',\n        'Programming Language :: Python :: 3.3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: Implementation :: PyPy',\n\n        'Topic :: Security :: Cryptography',\n    ],\n\n    keywords='crypto pki tls ssl x509 certificate encrypt decrypt sign verify rsa dsa ec dh',\n\n    install_requires=['asn1crypto>=1.5.1'],\n\n    packages=find_packages(exclude=['tests*', 'dev*']),\n    package_data=package_data,\n\n    tests_require=tests_require,\n    test_suite=test_suite,\n\n    cmdclass={\n        'clean': CleanCommand,\n        'egg_info': EggInfoCommand,\n    }\n)\n",
              "triple_sequences": [
                {
                  "action_api": "warnings.filterwarnings()",
                  "action_description": "Disables SSL certificate warnings",
                  "action_id": "disable_ssl_warnings",
                  "object": "'ignore', \"Unknown distribution option: 'long_description_content_type'\", module='distutils.dist'",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Suppress SSL warning messages",
                  "intention_id": "suppress_ssl_warnings"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "os.path.join(PACKAGE_ROOT, 'tests')",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "os.path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Get script file path",
                  "intention_id": "get_script_file_path"
                },
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.abspath(__file__)",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "PACKAGE_ROOT, 'tests'",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "PACKAGE_ROOT, '%s.egg-info' % PACKAGE_NAME",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "egg_info_path",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Determine presence of directory",
                  "intention_id": "determine_directory_presence"
                },
                {
                  "action_api": "os.mkdir()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "egg_info_path",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "shutil.copy2()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "os.path.join(PACKAGE_ROOT, 'LICENSE'), os.path.join(egg_info_path, 'LICENSE')",
                  "object_description": "Local file",
                  "object_id": "local_file",
                  "intention_description": "Copy file to temporary directory",
                  "intention_id": "copy_file_temp_directory"
                },
                {
                  "action_api": "egg_info.run()",
                  "action_description": "Executes setuptools development procedure",
                  "action_id": "exec_setuptools_dev",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Trigger main behavioral logic",
                  "intention_id": "trigger_main_behavioral_logic"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "PACKAGE_ROOT, sub_folder",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "full_path",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Determine presence of directory",
                  "intention_id": "determine_directory_presence"
                },
                {
                  "action_api": "shutil.rmtree()",
                  "action_description": "Recursively deletes directory and its contents",
                  "action_id": "delete_directory",
                  "object": "full_path",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Delete directory content",
                  "intention_id": "delete_directory_content"
                },
                {
                  "action_api": "os.walk()",
                  "action_description": "List directory contents",
                  "action_id": "list_directory_contents",
                  "object": "os.path.join(PACKAGE_ROOT, PACKAGE_NAME)",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "List files in directory",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "os.unlink()",
                  "action_description": "Deletes specified file from filesystem",
                  "action_id": "delete_file",
                  "object": "os.path.join(root, filename)",
                  "object_description": "Local file",
                  "object_id": "local_file",
                  "intention_description": "Delete file",
                  "intention_id": "delete_file"
                },
                {
                  "action_api": "shutil.rmtree()",
                  "action_description": "Recursively deletes directory and its contents",
                  "action_id": "delete_directory",
                  "object": "os.path.join(root, dirname)",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Delete directory content",
                  "intention_id": "delete_directory_content"
                },
                {
                  "action_api": "codecs.open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "os.path.join(PACKAGE_ROOT, 'readme.md'), 'r', 'utf-8'",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "f.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "setuptools.setup()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "name=PACKAGE_NAME, version=PACKAGE_VERSION, ...",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Trigger main behavioral logic",
                  "intention_id": "trigger_main_behavioral_logic"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "disposable_email_domains-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/disposable_email_domains-0.0.126.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "__init__.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/disposable_email_domains-0.0.126/disposable_email_domains-0.0.126/disposable_email_domains/__init__.py",
          "line_number": "3995",
          "type_description": "shady-links",
          "context_snippet": "'webhook.site',\n    'webm4il.info',\n    'webmail24.top',\n    'webscash.com',\n    'webtrip.ch',\n    'webuser.in',\n    'wecp.ru',\n    'wecp.store',\n    'wee.my',\n    'wef.gr',\n    'weg-werf-email.de',\n    'wegwerf-email-addressen.de',\n    'wegwerf-email-adressen.de',\n    'wegwerf-email.at',\n    'wegwerf-email.de',\n    'wegwerf-email.net',\n    'wegwerf-emails.de',\n    'wegwerfadresse.de',\n    'wegwerfemail.com',\n    'wegwerfemail.de',\n    'wegwerfemail.info',",
          "hash_value": "e3ec7e123c7ba9c5b5f10c44f2be1804",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "'webhook.site',\n    'webm4il.info',\n    'webmail24.top',\n    'webscash.com',\n    'webtrip.ch',\n    'webuser.in',\n    'wecp.ru',\n    'wecp.store',\n    'wee.my',\n    'wef.gr',\n    'weg-werf-email.de',\n    'wegwerf-email-addressen.de',\n    'wegwerf-email-adressen.de',\n    'wegwerf-email.at',\n    'wegwerf-email.de',\n    'wegwerf-email.net',\n    'wegwerf-emails.de',\n    'wegwerfadresse.de',\n    'wegwerfemail.com',\n    'wegwerfemail.de',\n    'wegwerfemail.info',",
              "triple_sequences": []
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "flask_dance-7",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/flask_dance-7.1.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "discord.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/flask_dance-7.1.0/flask_dance-7.1.0/flask_dance/contrib/discord.py",
          "line_number": "68",
          "type_description": "shady-links",
          "context_snippet": "def make_discord_blueprint(\n    client_id=None,\n    client_secret=None,\n    *,\n    scope=None,\n    redirect_url=None,\n    redirect_to=None,\n    login_url=None,\n    authorized_url=None,\n    session_class=None,\n    storage=None,\n    prompt=\"consent\",\n    rule_kwargs=None,\n):\n    \"\"\"\n    Make a blueprint for authenticating with Discord using OAuth 2. This requires\n    a client ID and client secret from Discord. You should either pass them to\n    this constructor, or make sure that your Flask application config defines\n    them, using the variables :envvar:`DISCORD_OAUTH_CLIENT_ID` and\n    :envvar:`DISCORD_OAUTH_CLIENT_SECRET`.\n\n    Args:\n        client_id (str): The client ID for your application on Discord.\n        client_secret (str): The client secret for your application on Discord\n        scope (list, optional): list of scopes (str) for the OAuth token\n        redirect_url (str): the URL to redirect to after the authentication\n            dance is complete\n        redirect_to (str): if ``redirect_url`` is not defined, the name of the\n            view to redirect to after the authentication dance is complete.\n            The actual URL will be determined by :func:`flask.url_for`\n        login_url (str, optional): the URL path for the ``login`` view.\n            Defaults to ``/discord``\n        authorized_url (str, optional): the URL path for the ``authorized`` view.\n            Defaults to ``/discord/authorized``.\n        session_class (class, optional): The class to use for creating a\n            Requests session. Defaults to\n            :class:`~flask_dance.consumer.requests.OAuth2Session`.\n        storage: A token storage class, or an instance of a token storage\n                class, to use for this blueprint. Defaults to\n                :class:`~flask_dance.consumer.storage.session.SessionStorage`.\n        prompt (str, optional): Define authorization flow.\n            Defaults to ``consent``, setting it to ``None`` will skip user\n            interaction if the application was previously approved.\n        rule_kwargs (dict, optional): Additional arguments that should be passed when adding\n            the login and authorized routes. Defaults to ``None``.\n\n    :rtype: :class:`~flask_dance.consumer.OAuth2ConsumerBlueprint`\n    :returns: A :doc:`blueprint <flask:blueprints>` to attach to your Flask app.\n    \"\"\"\n    scope = scope or [\"identify\"]\n    authorization_url_params = {\"prompt\": \"consent\"}\n    if prompt is None:\n        authorization_url_params[\"prompt\"] = None\n    discord_bp = OAuth2ConsumerBlueprint(\n        \"discord\",\n        __name__,\n        client_id=client_id,\n        client_secret=client_secret,\n        scope=scope,\n        base_url=\"https://discord.com/\",",
          "hash_value": "22fc6822fec6896f85d47cb4d234894b",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def make_discord_blueprint(\n    client_id=None,\n    client_secret=None,\n    *,\n    scope=None,\n    redirect_url=None,\n    redirect_to=None,\n    login_url=None,\n    authorized_url=None,\n    session_class=None,\n    storage=None,\n    prompt=\"consent\",\n    rule_kwargs=None,\n):\n    \"\"\"\n    Make a blueprint for authenticating with Discord using OAuth 2. This requires\n    a client ID and client secret from Discord. You should either pass them to\n    this constructor, or make sure that your Flask application config defines\n    them, using the variables :envvar:`DISCORD_OAUTH_CLIENT_ID` and\n    :envvar:`DISCORD_OAUTH_CLIENT_SECRET`.\n\n    Args:\n        client_id (str): The client ID for your application on Discord.\n        client_secret (str): The client secret for your application on Discord\n        scope (list, optional): list of scopes (str) for the OAuth token\n        redirect_url (str): the URL to redirect to after the authentication\n            dance is complete\n        redirect_to (str): if ``redirect_url`` is not defined, the name of the\n            view to redirect to after the authentication dance is complete.\n            The actual URL will be determined by :func:`flask.url_for`\n        login_url (str, optional): the URL path for the ``login`` view.\n            Defaults to ``/discord``\n        authorized_url (str, optional): the URL path for the ``authorized`` view.\n            Defaults to ``/discord/authorized``.\n        session_class (class, optional): The class to use for creating a\n            Requests session. Defaults to\n            :class:`~flask_dance.consumer.requests.OAuth2Session`.\n        storage: A token storage class, or an instance of a token storage\n                class, to use for this blueprint. Defaults to\n                :class:`~flask_dance.consumer.storage.session.SessionStorage`.\n        prompt (str, optional): Define authorization flow.\n            Defaults to ``consent``, setting it to ``None`` will skip user\n            interaction if the application was previously approved.\n        rule_kwargs (dict, optional): Additional arguments that should be passed when adding\n            the login and authorized routes. Defaults to ``None``.\n\n    :rtype: :class:`~flask_dance.consumer.OAuth2ConsumerBlueprint`\n    :returns: A :doc:`blueprint <flask:blueprints>` to attach to your Flask app.\n    \"\"\"\n    scope = scope or [\"identify\"]\n    authorization_url_params = {\"prompt\": \"consent\"}\n    if prompt is None:\n        authorization_url_params[\"prompt\"] = None\n    discord_bp = OAuth2ConsumerBlueprint(\n        \"discord\",\n        __name__,\n        client_id=client_id,\n        client_secret=client_secret,\n        scope=scope,\n        base_url=\"https://discord.com/\",",
              "triple_sequences": [
                {
                  "action_api": "OAuth2ConsumerBlueprint()",
                  "action_description": "Creates Discord bot instance",
                  "action_id": "create_discord_bot",
                  "object": "\"discord\", __name__, client_id=client_id, client_secret=client_secret, scope=scope, base_url=\"https://discord.com/\"",
                  "object_description": "Discord bot token",
                  "object_id": "discord_bot_token",
                  "intention_description": "Establish connection",
                  "intention_id": "establish_connection"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "spherogram-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/spherogram-2.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/spherogram-2.3/spherogram-2.3/setup.py",
          "line_number": "109",
          "type_description": "code-execution",
          "context_snippet": "def check_call(args):\n    try:\n        subprocess.check_call(args)\n    except subprocess.CalledProcessError:\n        executable = args[0]\n        command = [a for a in args if not a.startswith('-')][-1]\n        raise RuntimeError(command + ' failed for ' + executable)\n\n# Data dependencies:\n# - 'subprocess' is imported at the top: import subprocess\n# - 'args' is a function argument",
          "hash_value": "b062c873ba5d90c5d52b7ad56de449cc",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def check_call(args):\n    try:\n        subprocess.check_call(args)\n    except subprocess.CalledProcessError:\n        executable = args[0]\n        command = [a for a in args if not a.startswith('-')][-1]\n        raise RuntimeError(command + ' failed for ' + executable)\n\n# Data dependencies:\n# - 'subprocess' is imported at the top: import subprocess\n# - 'args' is a function argument",
              "triple_sequences": [
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "args",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "reflex-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/reflex-0.7.7a1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "net.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/reflex-0.7.7a1/reflex-0.7.7a1/reflex/utils/net.py",
          "line_number": "86",
          "type_description": "shady-links",
          "context_snippet": "def _is_ipv6_supported() -> bool:\n    \"\"\"Determine if the system supports IPv6.\n\n    Returns:\n        True if the system supports IPv6, False otherwise.\n    \"\"\"\n    try:\n        httpx.head(\"http://[2606:4700:4700::1111]\", timeout=3)\n    except httpx.RequestError:\n        return False\n    else:\n        return True",
          "hash_value": "9ca19531ea7d04047eb356c85da09bbc",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def _is_ipv6_supported() -> bool:\n    \"\"\"Determine if the system supports IPv6.\n\n    Returns:\n        True if the system supports IPv6, False otherwise.\n    \"\"\"\n    try:\n        httpx.head(\"http://[2606:4700:4700::1111]\", timeout=3)\n    except httpx.RequestError:\n        return False\n    else:\n        return True",
              "triple_sequences": [
                {
                  "action_api": "httpx.head()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "http://[2606:4700:4700::1111]",
                  "object_description": "External domain",
                  "object_id": "external_domain",
                  "intention_description": "Establish connection",
                  "intention_id": "establish_connection"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pip_upgrader-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pip_upgrader-1.4.15.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pip_upgrader-1.4.15/pip_upgrader-1.4.15/setup.py",
          "line_number": "29",
          "type_description": "code-execution",
          "context_snippet": "from subprocess import call\n\nclass RunTests(Command):\n    \"\"\" Run all tests. \"\"\"\n    description = 'run tests'\n    user_options = []\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        \"\"\"Run all tests!\"\"\"\n        err = call(['py.test'])\n        raise SystemExit(err)",
          "hash_value": "f77b0d1a249a4a831b0f8b1dc551333d",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from subprocess import call\n\nclass RunTests(Command):\n    \"\"\" Run all tests. \"\"\"\n    description = 'run tests'\n    user_options = []\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        \"\"\"Run all tests!\"\"\"\n        err = call(['py.test'])\n        raise SystemExit(err)",
              "triple_sequences": [
                {
                  "action_api": "subprocess.call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "['py.test']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "SystemExit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "err",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "asyncssh-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/asyncssh-2.20.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "config.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/asyncssh-2.20.0/asyncssh-2.20.0/asyncssh/config.py",
          "line_number": "51",
          "type_description": "silent-process-execution",
          "context_snippet": "import subprocess\nfrom subprocess import DEVNULL\n\ndef _exec(cmd: str) -> bool:\n    \"\"\"Execute a command and return if exit status is 0\"\"\"\n\n    return subprocess.run(cmd, check=False, shell=True, stdin=DEVNULL,\n                          stdout=DEVNULL, stderr=DEVNULL).returncode == 0",
          "hash_value": "3f4c2a64b93bc3c45486362f5554734a",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import subprocess\nfrom subprocess import DEVNULL\n\ndef _exec(cmd: str) -> bool:\n    \"\"\"Execute a command and return if exit status is 0\"\"\"\n\n    return subprocess.run(cmd, check=False, shell=True, stdin=DEVNULL,\n                          stdout=DEVNULL, stderr=DEVNULL).returncode == 0",
              "triple_sequences": [
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "cmd",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "bpython-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/bpython-0.25.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "repl.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/bpython-0.25/bpython-0.25/bpython/repl.py",
          "line_number": "936",
          "type_description": "clipboard-access",
          "context_snippet": "def copy2clipboard(self) -> None:\n    \"\"\"Copy current content to clipboard.\"\"\"\n\n    if not have_pyperclip:\n        self.interact.notify(_(\"No clipboard available.\"))\n        return\n\n    content = self.get_session_formatted_for_file()\n    try:\n        pyperclip.copy(content)\n    except pyperclip.PyperclipException:\n        self.interact.notify(_(\"Could not copy to clipboard.\"))\n    else:\n        self.interact.notify(_(\"Copied content to clipboard.\"))",
          "hash_value": "3376e57b3c056ac859a64c3bad748418",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def copy2clipboard(self) -> None:\n    \"\"\"Copy current content to clipboard.\"\"\"\n\n    if not have_pyperclip:\n        self.interact.notify(_(\"No clipboard available.\"))\n        return\n\n    content = self.get_session_formatted_for_file()\n    try:\n        pyperclip.copy(content)\n    except pyperclip.PyperclipException:\n        self.interact.notify(_(\"Could not copy to clipboard.\"))\n    else:\n        self.interact.notify(_(\"Copied content to clipboard.\"))",
              "triple_sequences": [
                {
                  "action_api": "self.get_session_formatted_for_file()",
                  "action_description": "Basic read operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access file content",
                  "intention_id": "access_file_content"
                },
                {
                  "action_api": "pyperclip.copy()",
                  "action_description": "Copies specified text to system clipboard",
                  "action_id": "copy_to_clipboard",
                  "object": "content",
                  "object_description": "Clipboard content data",
                  "object_id": "clipboard_data",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "rtree-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/rtree-1.4.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/rtree-1.4.0/rtree-1.4.0/setup.py",
          "line_number": "59",
          "type_description": "cmd-overwrite",
          "context_snippet": "from setuptools import setup\nfrom setuptools.command.install import install\nfrom setuptools.dist import Distribution\nfrom wheel.bdist_wheel import bdist_wheel as _bdist_wheel\n\nclass bdist_wheel(_bdist_wheel):  # type: ignore[misc]\n    def finalize_options(self) -> None:\n        _bdist_wheel.finalize_options(self)\n        self.root_is_pure = False\n\nclass BinaryDistribution(Distribution):  # type: ignore[misc]\n    \"\"\"Distribution which always forces a binary package with platform name\"\"\"\n    def has_ext_modules(foo) -> bool:\n        return True\n\nclass InstallPlatlib(install):  # type: ignore[misc]\n    def finalize_options(self) -> None:\n        install.finalize_options(self)\n        if self.distribution.has_ext_modules():\n            self.install_lib = self.install_platlib\n        source_dir = _cwd / \"rtree\"\n        target_dir = Path(self.build_lib) / \"rtree\"\n        source_lib = source_dir / \"lib\"\n        if source_lib.is_dir():\n            target_lib = target_dir / \"lib\"\n            self.copy_tree(str(source_lib), str(target_lib))\n        source_include = source_dir / \"include\"\n        if source_include.is_dir():\n            target_include = target_dir / \"include\"\n            self.copy_tree(str(source_include), str(target_include))\n\n# See pyproject.toml for other project metadata\nsetup(\n    name=\"rtree\",\n    distclass=BinaryDistribution,\n    cmdclass={\"bdist_wheel\": bdist_wheel, \"install\": InstallPlatlib},\n)\n",
          "hash_value": "2db67b586aaec34b5f5b420e92c8515c",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from setuptools import setup\nfrom setuptools.command.install import install\nfrom setuptools.dist import Distribution\nfrom wheel.bdist_wheel import bdist_wheel as _bdist_wheel\n\nclass bdist_wheel(_bdist_wheel):  # type: ignore[misc]\n    def finalize_options(self) -> None:\n        _bdist_wheel.finalize_options(self)\n        self.root_is_pure = False\n\nclass BinaryDistribution(Distribution):  # type: ignore[misc]\n    \"\"\"Distribution which always forces a binary package with platform name\"\"\"\n    def has_ext_modules(foo) -> bool:\n        return True\n\nclass InstallPlatlib(install):  # type: ignore[misc]\n    def finalize_options(self) -> None:\n        install.finalize_options(self)\n        if self.distribution.has_ext_modules():\n            self.install_lib = self.install_platlib\n        source_dir = _cwd / \"rtree\"\n        target_dir = Path(self.build_lib) / \"rtree\"\n        source_lib = source_dir / \"lib\"\n        if source_lib.is_dir():\n            target_lib = target_dir / \"lib\"\n            self.copy_tree(str(source_lib), str(target_lib))\n        source_include = source_dir / \"include\"\n        if source_include.is_dir():\n            target_include = target_dir / \"include\"\n            self.copy_tree(str(source_include), str(target_include))\n\n# See pyproject.toml for other project metadata\nsetup(\n    name=\"rtree\",\n    distclass=BinaryDistribution,\n    cmdclass={\"bdist_wheel\": bdist_wheel, \"install\": InstallPlatlib},\n)\n",
              "triple_sequences": [
                {
                  "action_api": "setup()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "name=\"rtree\", distclass=BinaryDistribution, cmdclass={\"bdist_wheel\": bdist_wheel, \"install\": InstallPlatlib}",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                },
                {
                  "action_api": "self.copy_tree()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "str(source_lib), str(target_lib)",
                  "object_description": "Local file or directory",
                  "object_id": "local_file_or_directory",
                  "intention_description": "Copy file to temporary directory",
                  "intention_id": "copy_file_temp_directory"
                },
                {
                  "action_api": "self.copy_tree()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "str(source_include), str(target_include)",
                  "object_description": "Local file or directory",
                  "object_id": "local_file_or_directory",
                  "intention_description": "Copy file to temporary directory",
                  "intention_id": "copy_file_temp_directory"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "l18n-2021",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/l18n-2021.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/l18n-2021.3/l18n-2021.3/setup.py",
          "line_number": "68",
          "type_description": "code-execution",
          "context_snippet": "class PredistBuild(object):\n    \"\"\"\n    Mixin class to build translation files\n    \"\"\"\n    def build_trans(self):\n        log.info('building translation files')\n\n        # we need to use buildout, call the following commands in the specified\n        # order, and reverse if an issue is raised\n        cmds = [[os.path.join('bin', 'build')],\n                [os.path.join('bin', 'buildout'), 'parts=build'],\n                ['python', 'bootstrap.py']]\n        cmd = 0\n\n        try:\n            from subprocess import DEVNULL\n        except ImportError:\n            DEVNULL = open(os.devnull, 'wb')\n\n        while True:\n            try:\n                log.info('    - calling \"%s\"' % ' '.join(cmds[cmd]))\n                if subprocess.Popen(cmds[cmd], stderr=DEVNULL,\n                                    stdout=DEVNULL).wait():\n                    raise OSError\n                if not cmd:\n                    break\n                else:\n                    cmd -= 1\n            except OSError:\n                cmd += 1\n                if cmd > 2:\n                    if os.path.exists(os.path.join(os.path.dirname(__file__),\n                                                   'l18n', '__maps.py')):\n                        break\n                    else:\n                        raise RuntimeError('Could not build translation files')\n\n        log.info('translation files built successfully')",
          "hash_value": "b2d7bfd4931433476907f59682f15879",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class PredistBuild(object):\n    \"\"\"\n    Mixin class to build translation files\n    \"\"\"\n    def build_trans(self):\n        log.info('building translation files')\n\n        # we need to use buildout, call the following commands in the specified\n        # order, and reverse if an issue is raised\n        cmds = [[os.path.join('bin', 'build')],\n                [os.path.join('bin', 'buildout'), 'parts=build'],\n                ['python', 'bootstrap.py']]\n        cmd = 0\n\n        try:\n            from subprocess import DEVNULL\n        except ImportError:\n            DEVNULL = open(os.devnull, 'wb')\n\n        while True:\n            try:\n                log.info('    - calling \"%s\"' % ' '.join(cmds[cmd]))\n                if subprocess.Popen(cmds[cmd], stderr=DEVNULL,\n                                    stdout=DEVNULL).wait():\n                    raise OSError\n                if not cmd:\n                    break\n                else:\n                    cmd -= 1\n            except OSError:\n                cmd += 1\n                if cmd > 2:\n                    if os.path.exists(os.path.join(os.path.dirname(__file__),\n                                                   'l18n', '__maps.py')):\n                        break\n                    else:\n                        raise RuntimeError('Could not build translation files')\n\n        log.info('translation files built successfully')",
              "triple_sequences": [
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "'bin', 'build'",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "'bin', 'buildout'",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.dirname(__file__), 'l18n', '__maps.py'",
                  "object_description": "Directory path with file",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for writing (normal writing, binary writing)",
                  "action_id": "basic_write_operations",
                  "object": "os.devnull, 'wb'",
                  "object_description": "System null device",
                  "object_id": "system_null_device",
                  "intention_description": "Access system command execution functionality",
                  "intention_id": "access_system_command_execution"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command with shell access",
                  "action_id": "spawn_process_shell",
                  "object": "cmds[cmd], stderr=DEVNULL, stdout=DEVNULL",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.Popen().wait()",
                  "action_description": "Waits for process to complete execution",
                  "action_id": "wait_process_completion",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Wait for events",
                  "intention_id": "wait_for_events"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "os.path.join(os.path.dirname(__file__), 'l18n', '__maps.py')",
                  "object_description": "Directory path with file",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "apsw-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/apsw-3.49.1.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/apsw-3.49.1.0/apsw-3.49.1.0/setup.py",
          "line_number": "198",
          "type_description": "code-execution",
          "context_snippet": "class build_test_extension(Command):\n    description = \"Compiles APSW test loadable extension\"\n\n    user_options = []\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        name = \"testextension.sqlext\"\n\n        def v(n):\n            return sysconfig.get_config_var(n)\n\n        # unixy platforms have this, and is necessary to match the 32/64 bitness of Python itself\n        if v(\"CC\"):\n            cc = f\"{ v('CC') } { v('CFLAGS') } { v('CCSHARED') } -Isqlite3 -c src/testextension.c\"\n            ld = f\"{ v('LDSHARED') } testextension.o -o { name }\"\n\n            for cmd in cc, ld:\n                print(cmd)\n                subprocess.run(cmd, shell=True, check=True)\n        else:\n            # windows mostly\n            compiler = distutils.ccompiler.new_compiler(verbose=True)\n            compiler.add_include_dir(\"sqlite3\")\n            compiler.add_include_dir(\".\")\n            preargs = [\"/Gd\"] if \"msvc\" in str(compiler.__class__).lower() else [\"-fPIC\"]\n            objs = compiler.compile([\"src/testextension.c\"], extra_preargs=preargs)\n            compiler.link_shared_object(objs, name)\n",
          "hash_value": "455aa53cd49891577094083f3eaea8b7",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class build_test_extension(Command):\n    description = \"Compiles APSW test loadable extension\"\n\n    user_options = []\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        name = \"testextension.sqlext\"\n\n        def v(n):\n            return sysconfig.get_config_var(n)\n\n        # unixy platforms have this, and is necessary to match the 32/64 bitness of Python itself\n        if v(\"CC\"):\n            cc = f\"{ v('CC') } { v('CFLAGS') } { v('CCSHARED') } -Isqlite3 -c src/testextension.c\"\n            ld = f\"{ v('LDSHARED') } testextension.o -o { name }\"\n\n            for cmd in cc, ld:\n                print(cmd)\n                subprocess.run(cmd, shell=True, check=True)\n        else:\n            # windows mostly\n            compiler = distutils.ccompiler.new_compiler(verbose=True)\n            compiler.add_include_dir(\"sqlite3\")\n            compiler.add_include_dir(\".\")\n            preargs = [\"/Gd\"] if \"msvc\" in str(compiler.__class__).lower() else [\"-fPIC\"]\n            objs = compiler.compile([\"src/testextension.c\"], extra_preargs=preargs)\n            compiler.link_shared_object(objs, name)\n",
              "triple_sequences": [
                {
                  "action_api": "sysconfig.get_config_var()",
                  "action_description": "Retrieves operating system information",
                  "action_id": "get_os_info",
                  "object": "CC",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Access configuration value",
                  "intention_id": "access_configuration_value"
                },
                {
                  "action_api": "sysconfig.get_config_var()",
                  "action_description": "Retrieves operating system information",
                  "action_id": "get_os_info",
                  "object": "CFLAGS",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Access configuration value",
                  "intention_id": "access_configuration_value"
                },
                {
                  "action_api": "sysconfig.get_config_var()",
                  "action_description": "Retrieves operating system information",
                  "action_id": "get_os_info",
                  "object": "CCSHARED",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Access configuration value",
                  "intention_id": "access_configuration_value"
                },
                {
                  "action_api": "print()",
                  "action_description": "Prints output to standard output",
                  "action_id": "get_stdout_stream",
                  "object": "cmd",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "cmd",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "distutils.ccompiler.new_compiler()",
                  "action_description": "Instantiates Setup class",
                  "action_id": "init_setup_class",
                  "object": "verbose=True",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Import required module",
                  "intention_id": "import_required_module"
                },
                {
                  "action_api": "compiler.add_include_dir()",
                  "action_description": "Adds field to multipart HTTP request",
                  "action_id": "add_multipart_field",
                  "object": "sqlite3",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "compiler.add_include_dir()",
                  "action_description": "Adds field to multipart HTTP request",
                  "action_id": "add_multipart_field",
                  "object": ".",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "compiler.compile()",
                  "action_description": "Compiles source code string into executable code object",
                  "action_id": "compile_code_object",
                  "object": "[\"src/testextension.c\"]",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "compiler.link_shared_object()",
                  "action_description": "Compiles source code string into executable code object",
                  "action_id": "compile_code_object",
                  "object": "objs, name",
                  "object_description": "Compiled Python code string",
                  "object_id": "compiled_python_code",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "horovod-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/horovod-0.28.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/horovod-0.28.1/horovod-0.28.1/setup.py",
          "line_number": "145",
          "type_description": "code-execution",
          "context_snippet": "class custom_build_ext(build_ext):\n    def build_extensions(self):\n        if os.getenv('HOROVOD_SKIP_COMPILE') == '1':\n            # Skip building extensions using CMake\n            print(\"Horovod is being installed without native libraries\")\n            return\n\n        cmake_bin = get_cmake_bin()\n\n        config = 'Debug' if self.debug or os.environ.get('HOROVOD_DEBUG') == \"1\" else 'RelWithDebInfo'\n\n        ext_name = self.extensions[0].name\n        build_dir = self.get_ext_fullpath(ext_name).replace(self.get_ext_filename(ext_name), '')\n        build_dir = os.path.abspath(build_dir)\n\n        cmake_args = ['-DCMAKE_BUILD_TYPE=' + config,\n                      '-DCMAKE_LIBRARY_OUTPUT_DIRECTORY_{}={}'.format(config.upper(), build_dir),\n                      '-DPYTHON_EXECUTABLE:FILEPATH=' + sys.executable]\n\n        make_args = ['-j8'] if not os.environ.get('MAKEFLAGS') else []\n        if self.verbose:\n            make_args.append('VERBOSE=1')\n\n        cmake_build_args = ['--config', config]\n        if make_args:\n            # -- specifies that these args are going to the native build tool: make\n            cmake_build_args += ['--'] + make_args\n\n        cmake_build_dir = os.path.join(self.build_temp, config)\n        if not os.path.exists(cmake_build_dir):\n            os.makedirs(cmake_build_dir)\n\n        config_and_build_commands = [\n            [cmake_bin, self.extensions[0].cmake_lists_dir] + cmake_args,\n            [cmake_bin, '--build', '.'] + cmake_build_args\n        ]\n\n        if self.verbose:\n            print(f\"Running CMake in {cmake_build_dir}:\")\n            for command in config_and_build_commands:\n                print(\" \".join(command))\n            sys.stdout.flush()\n\n        # Config and build the extension\n        try:\n            for command in config_and_build_commands:\n                subprocess.check_call(command, cwd=cmake_build_dir)\n        except OSError as e:\n            raise RuntimeError('CMake failed: {}'.format(str(e)))\n\n        if sys.argv[1].startswith('develop'):\n            # Copy over metadata.json file from build directory\n            shutil.copyfile(os.path.join(build_dir, _FRAMEWORK_METADATA_FILE),\n                            os.path.join(self.extensions[0].cmake_lists_dir, _FRAMEWORK_METADATA_FILE))\n            # Remove unfound frameworks, otherwise develop mode will fail the install\n            self.extensions = [x for x in self.extensions if os.path.exists(self.get_ext_fullpath(x.name))]",
          "hash_value": "0cf5ae0c3872ed8791271807e74e5d03",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class custom_build_ext(build_ext):\n    def build_extensions(self):\n        if os.getenv('HOROVOD_SKIP_COMPILE') == '1':\n            # Skip building extensions using CMake\n            print(\"Horovod is being installed without native libraries\")\n            return\n\n        cmake_bin = get_cmake_bin()\n\n        config = 'Debug' if self.debug or os.environ.get('HOROVOD_DEBUG') == \"1\" else 'RelWithDebInfo'\n\n        ext_name = self.extensions[0].name\n        build_dir = self.get_ext_fullpath(ext_name).replace(self.get_ext_filename(ext_name), '')\n        build_dir = os.path.abspath(build_dir)\n\n        cmake_args = ['-DCMAKE_BUILD_TYPE=' + config,\n                      '-DCMAKE_LIBRARY_OUTPUT_DIRECTORY_{}={}'.format(config.upper(), build_dir),\n                      '-DPYTHON_EXECUTABLE:FILEPATH=' + sys.executable]\n\n        make_args = ['-j8'] if not os.environ.get('MAKEFLAGS') else []\n        if self.verbose:\n            make_args.append('VERBOSE=1')\n\n        cmake_build_args = ['--config', config]\n        if make_args:\n            # -- specifies that these args are going to the native build tool: make\n            cmake_build_args += ['--'] + make_args\n\n        cmake_build_dir = os.path.join(self.build_temp, config)\n        if not os.path.exists(cmake_build_dir):\n            os.makedirs(cmake_build_dir)\n\n        config_and_build_commands = [\n            [cmake_bin, self.extensions[0].cmake_lists_dir] + cmake_args,\n            [cmake_bin, '--build', '.'] + cmake_build_args\n        ]\n\n        if self.verbose:\n            print(f\"Running CMake in {cmake_build_dir}:\")\n            for command in config_and_build_commands:\n                print(\" \".join(command))\n            sys.stdout.flush()\n\n        # Config and build the extension\n        try:\n            for command in config_and_build_commands:\n                subprocess.check_call(command, cwd=cmake_build_dir)\n        except OSError as e:\n            raise RuntimeError('CMake failed: {}'.format(str(e)))\n\n        if sys.argv[1].startswith('develop'):\n            # Copy over metadata.json file from build directory\n            shutil.copyfile(os.path.join(build_dir, _FRAMEWORK_METADATA_FILE),\n                            os.path.join(self.extensions[0].cmake_lists_dir, _FRAMEWORK_METADATA_FILE))\n            # Remove unfound frameworks, otherwise develop mode will fail the install\n            self.extensions = [x for x in self.extensions if os.path.exists(self.get_ext_fullpath(x.name))]",
              "triple_sequences": [
                {
                  "action_api": "os.getenv()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'HOROVOD_SKIP_COMPILE'",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'HOROVOD_DEBUG'",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "sys.executable",
                  "action_description": "Retrieves Python interpreter version",
                  "action_id": "get_python_version",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get Python executable path",
                  "intention_id": "get_python_executable_path"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'MAKEFLAGS'",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "self.build_temp, config",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "cmake_build_dir",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "os.makedirs()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "cmake_build_dir",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "command, cwd=cmake_build_dir",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "sys.argv",
                  "action_description": "Retrieves command-line arguments passed to script",
                  "action_id": "get_cmd_args",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access command line arguments",
                  "intention_id": "access_command_line_arguments"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "build_dir, _FRAMEWORK_METADATA_FILE",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "self.extensions[0].cmake_lists_dir, _FRAMEWORK_METADATA_FILE",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "shutil.copyfile()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "os.path.join(build_dir, _FRAMEWORK_METADATA_FILE), os.path.join(self.extensions[0].cmake_lists_dir, _FRAMEWORK_METADATA_FILE)",
                  "object_description": "Local file",
                  "object_id": "local_file",
                  "intention_description": "Copy file to destination",
                  "intention_id": "move_file_destination"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "self.get_ext_fullpath(x.name)",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Determine presence of file",
                  "intention_id": "determine_file_presence"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "ncnn-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/ncnn-1.0.20241226.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ncnn-1.0.20241226/ncnn-1.0.20241226/setup.py",
          "line_number": "183",
          "type_description": "cmd-overwrite",
          "context_snippet": "import io\nimport os\nimport sys\nimport time\nimport re\nimport subprocess\n\nfrom setuptools import setup, find_packages, Extension\nfrom setuptools.command.build_ext import build_ext\nfrom setuptools.command.install import install\n\n\ndef find_version():\n    with io.open(\"CMakeLists.txt\", encoding=\"utf8\") as f:\n        version_file = f.read()\n\n    version_major = re.findall(r\"NCNN_VERSION_MAJOR (.+?)\", version_file)\n    version_minor = re.findall(r\"NCNN_VERSION_MINOR (.+?)\", version_file)\n\n    if version_major and version_minor:\n        ncnn_version = time.strftime(\"%Y%m%d\", time.localtime())\n\n        return version_major[0] + \".\" + version_minor[0] + \".\" + ncnn_version\n    raise RuntimeError(\"Unable to find version string.\")\n\n# Parse environment variables\nVulkan_LIBRARY = os.environ.get(\"Vulkan_LIBRARY\", \"\")\nCMAKE_TOOLCHAIN_FILE = os.environ.get(\"CMAKE_TOOLCHAIN_FILE\", \"\")\nPLATFORM = os.environ.get(\"PLATFORM\", \"\")\nARCHS = os.environ.get(\"ARCHS\", \"\")\nDEPLOYMENT_TARGET = os.environ.get(\"DEPLOYMENT_TARGET\", \"\")\nOpenMP_C_FLAGS = os.environ.get(\"OpenMP_C_FLAGS\", \"\")\nOpenMP_CXX_FLAGS = os.environ.get(\"OpenMP_CXX_FLAGS\", \"\")\nOpenMP_C_LIB_NAMES = os.environ.get(\"OpenMP_C_LIB_NAMES\", \"\")\nOpenMP_CXX_LIB_NAMES = os.environ.get(\"OpenMP_CXX_LIB_NAMES\", \"\")\nOpenMP_libomp_LIBRARY = os.environ.get(\"OpenMP_libomp_LIBRARY\", \"\")\nENABLE_BITCODE = os.environ.get(\"ENABLE_BITCODE\", \"\")\nENABLE_ARC = os.environ.get(\"ENABLE_ARC\", \"\")\nENABLE_VISIBILITY = os.environ.get(\"ENABLE_VISIBILITY\", \"\")\n\n# Parse variables from command line with setup.py install\nclass InstallCommand(install):\n    user_options = install.user_options + [\n        ('vulkan=', None, 'Enable the usage of Vulkan.'),\n    ]\n    def initialize_options(self):\n        install.initialize_options(self)\n        self.vulkan = None\n\n    def finalize_options(self):\n        install.finalize_options(self)\n\n    def run(self):\n        install.run(self)\n\n# Convert distutils Windows platform specifiers to CMake -A arguments\nPLAT_TO_CMAKE = {\n    \"win32\": \"Win32\",\n    \"win-amd64\": \"x64\",\n    \"win-arm32\": \"ARM\",\n    \"win-arm64\": \"ARM64\",\n}\n\n# A CMakeExtension needs a sourcedir instead of a file list.\n# The name must be the _single_ output extension from the CMake build.\n# If you need multiple extensions, see scikit-build.\nclass CMakeExtension(Extension):\n    def __init__(self, name, sourcedir=\"\"):\n        Extension.__init__(self, name, sources=[])\n        self.sourcedir = os.path.abspath(sourcedir)\n\n\nclass CMakeBuild(build_ext):\n    def build_extension(self, ext):\n        extdir = os.path.abspath(os.path.dirname(self.get_ext_fullpath(ext.name)))\n        extdir = os.path.join(extdir, \"ncnn\")\n\n        # required for auto-detection of auxiliary \"native\" libs\n        if not extdir.endswith(os.path.sep):\n            extdir += os.path.sep\n\n        cfg = \"Debug\" if self.debug else \"Release\"\n\n        # CMake lets you override the generator - we need to check this.\n        # Can be set with Conda-Build, for example.\n        cmake_generator = os.environ.get(\"CMAKE_GENERATOR\", \"\")\n\n        # Set Python_EXECUTABLE instead if you use PYBIND11_FINDPYTHON\n        # EXAMPLE_VERSION_INFO shows you how to pass a value into the C++ code\n        # from Python.\n        cmake_args = [\n            \"-DCMAKE_LIBRARY_OUTPUT_DIRECTORY={}\".format(extdir),\n            \"-DCMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE={}\".format(extdir),\n            \"-DPYTHON_EXECUTABLE={}\".format(sys.executable),\n            \"-DCMAKE_BUILD_TYPE={}\".format(cfg),  # not used on MSVC, but no harm\n            \"-DNCNN_PYTHON=ON\",\n            \"-DNCNN_VULKAN=ON\",\n            \"-DNCNN_DISABLE_RTTI=OFF\",\n            \"-DNCNN_DISABLE_EXCEPTION=OFF\",\n            \"-DNCNN_BUILD_BENCHMARK=OFF\",\n            \"-DNCNN_BUILD_EXAMPLES=OFF\",\n            \"-DNCNN_BUILD_TOOLS=OFF\",\n        ]\n        if Vulkan_LIBRARY != \"\":\n            cmake_args.append(\"-DVulkan_LIBRARY=\" + Vulkan_LIBRARY)\n        if CMAKE_TOOLCHAIN_FILE != \"\":\n            cmake_args.append(\"-DCMAKE_TOOLCHAIN_FILE=\" + CMAKE_TOOLCHAIN_FILE)\n        if PLATFORM != \"\":\n            cmake_args.append(\"-DPLATFORM=\" + PLATFORM)\n        if ARCHS != \"\":\n            cmake_args.append(\"-DARCHS=\" + ARCHS)\n        if DEPLOYMENT_TARGET != \"\":\n            cmake_args.append(\"-DDEPLOYMENT_TARGET=\" + DEPLOYMENT_TARGET)\n        if OpenMP_C_FLAGS != \"\":\n            cmake_args.append(\"-DOpenMP_C_FLAGS=\" + OpenMP_C_FLAGS)\n        if OpenMP_CXX_FLAGS != \"\":\n            cmake_args.append(\"-DOpenMP_CXX_FLAGS=\" + OpenMP_CXX_FLAGS)\n        if OpenMP_C_LIB_NAMES != \"\":\n            cmake_args.append(\"-DOpenMP_C_LIB_NAMES=\" + OpenMP_C_LIB_NAMES)\n        if OpenMP_CXX_LIB_NAMES != \"\":\n            cmake_args.append(\"-DOpenMP_CXX_LIB_NAMES=\" + OpenMP_CXX_LIB_NAMES)\n        if OpenMP_libomp_LIBRARY != \"\":\n            cmake_args.append(\"-DOpenMP_libomp_LIBRARY=\" + OpenMP_libomp_LIBRARY)\n        if ENABLE_BITCODE != \"\":\n            cmake_args.append(\"-DENABLE_BITCODE=\" + ENABLE_BITCODE)\n        if ENABLE_ARC != \"\":\n            cmake_args.append(\"-DENABLE_ARC=\" + ENABLE_ARC)\n        if ENABLE_VISIBILITY != \"\":\n            cmake_args.append(\"-DENABLE_VISIBILITY=\" + ENABLE_VISIBILITY)\n\n        build_args = []\n\n        if self.compiler.compiler_type == \"msvc\":\n            # Single config generators are handled \"normally\"\n            single_config = any(x in cmake_generator for x in {\"NMake\", \"Ninja\"})\n\n            # CMake allows an arch-in-generator style for backward compatibility\n            contains_arch = any(x in cmake_generator for x in {\"ARM\", \"Win64\"})\n\n            # Specify the arch if using MSVC generator, but only if it doesn't\n            # contain a backward-compatibility arch spec already in the\n            # generator name.\n            if not single_config and not contains_arch:\n                cmake_args += [\"-A\", PLAT_TO_CMAKE[self.plat_name]]\n\n            # Multi-config generators have a different way to specify configs\n            if not single_config:\n                cmake_args += [\n                    \"-DCMAKE_LIBRARY_OUTPUT_DIRECTORY_{}={}\".format(cfg.upper(), extdir)\n                ]\n                build_args += [\"--config\", cfg]\n\n        # Set CMAKE_BUILD_PARALLEL_LEVEL to control the parallel build level\n        # across all generators.\n        if \"CMAKE_BUILD_PARALLEL_LEVEL\" not in os.environ:\n            # self.parallel is a Python 3 only way to set parallel jobs by hand\n            # using -j in the build_ext call, not supported by pip or PyPA-build.\n            if hasattr(self, \"parallel\") and self.parallel:\n                # CMake 3.12+ only.\n                build_args += [\"-j{}\".format(self.parallel)]\n            else:\n                build_args += [\"-j4\"]\n\n        if not os.path.exists(self.build_temp):\n            os.makedirs(self.build_temp)\n\n        subprocess.check_call(\n            [\"cmake\", ext.sourcedir] + cmake_args, cwd=self.build_temp\n        )\n        subprocess.check_call(\n            [\"cmake\", \"--build\", \".\"] + build_args, cwd=self.build_temp\n        )\n\n\nif sys.version_info < (3, 0):\n    sys.exit(\"Sorry, Python < 3.0 is not supported\")\n\nrequirements = [\"numpy\", \"tqdm\", \"requests\", \"portalocker\", \"opencv-python\"]\n\nwith io.open(\"README.md\", encoding=\"utf-8\") as h:\n    long_description = h.read()\n\nsetup(\n    name=\"ncnn\",\n    version=find_version(),\n    author=\"nihui\",\n    author_email=\"nihuini@tencent.com\",\n    maintainer=\"caishanli\",\n    maintainer_email=\"caishanli25@gmail.com\",\n    description=\"ncnn is a high-performance neural network inference framework optimized for the mobile platform\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/Tencent/ncnn\",\n    classifiers=[\n        \"Programming Language :: C++\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.6\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"License :: OSI Approved :: BSD License\",\n        \"Operating System :: OS Independent\",\n    ],\n    license=\"BSD-3\",\n    python_requires=\">=3.5\",\n    packages=find_packages(\"python\"),\n    package_dir={\"\": \"python\"},\n    install_requires=requirements,\n    ext_modules=[CMakeExtension(\"ncnn\")],\n    cmdclass={'install': InstallCommand, \"build_ext\": CMakeBuild},\n)\n",
          "hash_value": "5bed1701638d5b950e389ae846657643",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import io\nimport os\nimport sys\nimport time\nimport re\nimport subprocess\n\nfrom setuptools import setup, find_packages, Extension\nfrom setuptools.command.build_ext import build_ext\nfrom setuptools.command.install import install\n\n\ndef find_version():\n    with io.open(\"CMakeLists.txt\", encoding=\"utf8\") as f:\n        version_file = f.read()\n\n    version_major = re.findall(r\"NCNN_VERSION_MAJOR (.+?)\", version_file)\n    version_minor = re.findall(r\"NCNN_VERSION_MINOR (.+?)\", version_file)\n\n    if version_major and version_minor:\n        ncnn_version = time.strftime(\"%Y%m%d\", time.localtime())\n\n        return version_major[0] + \".\" + version_minor[0] + \".\" + ncnn_version\n    raise RuntimeError(\"Unable to find version string.\")\n\n# Parse environment variables\nVulkan_LIBRARY = os.environ.get(\"Vulkan_LIBRARY\", \"\")\nCMAKE_TOOLCHAIN_FILE = os.environ.get(\"CMAKE_TOOLCHAIN_FILE\", \"\")\nPLATFORM = os.environ.get(\"PLATFORM\", \"\")\nARCHS = os.environ.get(\"ARCHS\", \"\")\nDEPLOYMENT_TARGET = os.environ.get(\"DEPLOYMENT_TARGET\", \"\")\nOpenMP_C_FLAGS = os.environ.get(\"OpenMP_C_FLAGS\", \"\")\nOpenMP_CXX_FLAGS = os.environ.get(\"OpenMP_CXX_FLAGS\", \"\")\nOpenMP_C_LIB_NAMES = os.environ.get(\"OpenMP_C_LIB_NAMES\", \"\")\nOpenMP_CXX_LIB_NAMES = os.environ.get(\"OpenMP_CXX_LIB_NAMES\", \"\")\nOpenMP_libomp_LIBRARY = os.environ.get(\"OpenMP_libomp_LIBRARY\", \"\")\nENABLE_BITCODE = os.environ.get(\"ENABLE_BITCODE\", \"\")\nENABLE_ARC = os.environ.get(\"ENABLE_ARC\", \"\")\nENABLE_VISIBILITY = os.environ.get(\"ENABLE_VISIBILITY\", \"\")\n\n# Parse variables from command line with setup.py install\nclass InstallCommand(install):\n    user_options = install.user_options + [\n        ('vulkan=', None, 'Enable the usage of Vulkan.'),\n    ]\n    def initialize_options(self):\n        install.initialize_options(self)\n        self.vulkan = None\n\n    def finalize_options(self):\n        install.finalize_options(self)\n\n    def run(self):\n        install.run(self)\n\n# Convert distutils Windows platform specifiers to CMake -A arguments\nPLAT_TO_CMAKE = {\n    \"win32\": \"Win32\",\n    \"win-amd64\": \"x64\",\n    \"win-arm32\": \"ARM\",\n    \"win-arm64\": \"ARM64\",\n}\n\n# A CMakeExtension needs a sourcedir instead of a file list.\n# The name must be the _single_ output extension from the CMake build.\n# If you need multiple extensions, see scikit-build.\nclass CMakeExtension(Extension):\n    def __init__(self, name, sourcedir=\"\"):\n        Extension.__init__(self, name, sources=[])\n        self.sourcedir = os.path.abspath(sourcedir)\n\n\nclass CMakeBuild(build_ext):\n    def build_extension(self, ext):\n        extdir = os.path.abspath(os.path.dirname(self.get_ext_fullpath(ext.name)))\n        extdir = os.path.join(extdir, \"ncnn\")\n\n        # required for auto-detection of auxiliary \"native\" libs\n        if not extdir.endswith(os.path.sep):\n            extdir += os.path.sep\n\n        cfg = \"Debug\" if self.debug else \"Release\"\n\n        # CMake lets you override the generator - we need to check this.\n        # Can be set with Conda-Build, for example.\n        cmake_generator = os.environ.get(\"CMAKE_GENERATOR\", \"\")\n\n        # Set Python_EXECUTABLE instead if you use PYBIND11_FINDPYTHON\n        # EXAMPLE_VERSION_INFO shows you how to pass a value into the C++ code\n        # from Python.\n        cmake_args = [\n            \"-DCMAKE_LIBRARY_OUTPUT_DIRECTORY={}\".format(extdir),\n            \"-DCMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE={}\".format(extdir),\n            \"-DPYTHON_EXECUTABLE={}\".format(sys.executable),\n            \"-DCMAKE_BUILD_TYPE={}\".format(cfg),  # not used on MSVC, but no harm\n            \"-DNCNN_PYTHON=ON\",\n            \"-DNCNN_VULKAN=ON\",\n            \"-DNCNN_DISABLE_RTTI=OFF\",\n            \"-DNCNN_DISABLE_EXCEPTION=OFF\",\n            \"-DNCNN_BUILD_BENCHMARK=OFF\",\n            \"-DNCNN_BUILD_EXAMPLES=OFF\",\n            \"-DNCNN_BUILD_TOOLS=OFF\",\n        ]\n        if Vulkan_LIBRARY != \"\":\n            cmake_args.append(\"-DVulkan_LIBRARY=\" + Vulkan_LIBRARY)\n        if CMAKE_TOOLCHAIN_FILE != \"\":\n            cmake_args.append(\"-DCMAKE_TOOLCHAIN_FILE=\" + CMAKE_TOOLCHAIN_FILE)\n        if PLATFORM != \"\":\n            cmake_args.append(\"-DPLATFORM=\" + PLATFORM)\n        if ARCHS != \"\":\n            cmake_args.append(\"-DARCHS=\" + ARCHS)\n        if DEPLOYMENT_TARGET != \"\":\n            cmake_args.append(\"-DDEPLOYMENT_TARGET=\" + DEPLOYMENT_TARGET)\n        if OpenMP_C_FLAGS != \"\":\n            cmake_args.append(\"-DOpenMP_C_FLAGS=\" + OpenMP_C_FLAGS)\n        if OpenMP_CXX_FLAGS != \"\":\n            cmake_args.append(\"-DOpenMP_CXX_FLAGS=\" + OpenMP_CXX_FLAGS)\n        if OpenMP_C_LIB_NAMES != \"\":\n            cmake_args.append(\"-DOpenMP_C_LIB_NAMES=\" + OpenMP_C_LIB_NAMES)\n        if OpenMP_CXX_LIB_NAMES != \"\":\n            cmake_args.append(\"-DOpenMP_CXX_LIB_NAMES=\" + OpenMP_CXX_LIB_NAMES)\n        if OpenMP_libomp_LIBRARY != \"\":\n            cmake_args.append(\"-DOpenMP_libomp_LIBRARY=\" + OpenMP_libomp_LIBRARY)\n        if ENABLE_BITCODE != \"\":\n            cmake_args.append(\"-DENABLE_BITCODE=\" + ENABLE_BITCODE)\n        if ENABLE_ARC != \"\":\n            cmake_args.append(\"-DENABLE_ARC=\" + ENABLE_ARC)\n        if ENABLE_VISIBILITY != \"\":\n            cmake_args.append(\"-DENABLE_VISIBILITY=\" + ENABLE_VISIBILITY)\n\n        build_args = []\n\n        if self.compiler.compiler_type == \"msvc\":\n            # Single config generators are handled \"normally\"\n            single_config = any(x in cmake_generator for x in {\"NMake\", \"Ninja\"})\n\n            # CMake allows an arch-in-generator style for backward compatibility\n            contains_arch = any(x in cmake_generator for x in {\"ARM\", \"Win64\"})\n\n            # Specify the arch if using MSVC generator, but only if it doesn't\n            # contain a backward-compatibility arch spec already in the\n            # generator name.\n            if not single_config and not contains_arch:\n                cmake_args += [\"-A\", PLAT_TO_CMAKE[self.plat_name]]\n\n            # Multi-config generators have a different way to specify configs\n            if not single_config:\n                cmake_args += [\n                    \"-DCMAKE_LIBRARY_OUTPUT_DIRECTORY_{}={}\".format(cfg.upper(), extdir)\n                ]\n                build_args += [\"--config\", cfg]\n\n        # Set CMAKE_BUILD_PARALLEL_LEVEL to control the parallel build level\n        # across all generators.\n        if \"CMAKE_BUILD_PARALLEL_LEVEL\" not in os.environ:\n            # self.parallel is a Python 3 only way to set parallel jobs by hand\n            # using -j in the build_ext call, not supported by pip or PyPA-build.\n            if hasattr(self, \"parallel\") and self.parallel:\n                # CMake 3.12+ only.\n                build_args += [\"-j{}\".format(self.parallel)]\n            else:\n                build_args += [\"-j4\"]\n\n        if not os.path.exists(self.build_temp):\n            os.makedirs(self.build_temp)\n\n        subprocess.check_call(\n            [\"cmake\", ext.sourcedir] + cmake_args, cwd=self.build_temp\n        )\n        subprocess.check_call(\n            [\"cmake\", \"--build\", \".\"] + build_args, cwd=self.build_temp\n        )\n\n\nif sys.version_info < (3, 0):\n    sys.exit(\"Sorry, Python < 3.0 is not supported\")\n\nrequirements = [\"numpy\", \"tqdm\", \"requests\", \"portalocker\", \"opencv-python\"]\n\nwith io.open(\"README.md\", encoding=\"utf-8\") as h:\n    long_description = h.read()\n\nsetup(\n    name=\"ncnn\",\n    version=find_version(),\n    author=\"nihui\",\n    author_email=\"nihuini@tencent.com\",\n    maintainer=\"caishanli\",\n    maintainer_email=\"caishanli25@gmail.com\",\n    description=\"ncnn is a high-performance neural network inference framework optimized for the mobile platform\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/Tencent/ncnn\",\n    classifiers=[\n        \"Programming Language :: C++\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.6\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"License :: OSI Approved :: BSD License\",\n        \"Operating System :: OS Independent\",\n    ],\n    license=\"BSD-3\",\n    python_requires=\">=3.5\",\n    packages=find_packages(\"python\"),\n    package_dir={\"\": \"python\"},\n    install_requires=requirements,\n    ext_modules=[CMakeExtension(\"ncnn\")],\n    cmdclass={'install': InstallCommand, \"build_ext\": CMakeBuild},\n)\n",
              "triple_sequences": [
                {
                  "action_api": "io.open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "\"CMakeLists.txt\", encoding=\"utf8\"",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "re.findall()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "r\"NCNN_VERSION_MAJOR (.+?)\", version_file",
                  "object_description": "Regular expression and file content",
                  "object_id": "regex_file_content",
                  "intention_description": "Extract structured data from file",
                  "intention_id": "extract_structured_file_data"
                },
                {
                  "action_api": "re.findall()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "r\"NCNN_VERSION_MINOR (.+?)\", version_file",
                  "object_description": "Regular expression and file content",
                  "object_id": "regex_file_content",
                  "intention_description": "Extract structured data from file",
                  "intention_id": "extract_structured_file_data"
                },
                {
                  "action_api": "time.strftime()",
                  "action_description": "Returns current time",
                  "action_id": "get_current_time",
                  "object": "\"%Y%m%d\", time.localtime()",
                  "object_description": "Delay duration in seconds",
                  "object_id": "delay_duration",
                  "intention_description": "Get datetime epoch",
                  "intention_id": "get_datetime_epoch"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"Vulkan_LIBRARY\", \"\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"CMAKE_TOOLCHAIN_FILE\", \"\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"PLATFORM\", \"\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"ARCHS\", \"\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"DEPLOYMENT_TARGET\", \"\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"OpenMP_C_FLAGS\", \"\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"OpenMP_CXX_FLAGS\", \"\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"OpenMP_C_LIB_NAMES\", \"\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"OpenMP_CXX_LIB_NAMES\", \"\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"OpenMP_libomp_LIBRARY\", \"\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"ENABLE_BITCODE\", \"\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"ENABLE_ARC\", \"\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"ENABLE_VISIBILITY\", \"\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "sourcedir",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "os.path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.dirname(self.get_ext_fullpath(ext.name))",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "extdir, \"ncnn\"",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.sep",
                  "action_description": "Retrieves operating system path separator",
                  "action_id": "get_os_path_sep",
                  "object": "",
                  "object_description": "Directory path separator",
                  "object_id": "directory_separator",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"CMAKE_GENERATOR\", \"\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "sys.executable",
                  "action_description": "Retrieves Python interpreter version",
                  "action_id": "get_python_version",
                  "object": "",
                  "object_description": "Python command",
                  "object_id": "python_command",
                  "intention_description": "Get Python executable path",
                  "intention_id": "get_python_executable_path"
                },
                {
                  "action_api": "hasattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "self, \"parallel\"",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "self.build_temp",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "os.makedirs()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "self.build_temp",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"cmake\", ext.sourcedir] + cmake_args, cwd=self.build_temp",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"cmake\", \"--build\", \".\"] + build_args, cwd=self.build_temp",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "sys.version_info",
                  "action_description": "Retrieves Python interpreter version",
                  "action_id": "get_python_version",
                  "object": "",
                  "object_description": "Python command",
                  "object_id": "python_command",
                  "intention_description": "Get Python executable path",
                  "intention_id": "get_python_executable_path"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "\"Sorry, Python < 3.0 is not supported\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                },
                {
                  "action_api": "io.open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "\"README.md\", encoding=\"utf-8\"",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "find_packages()",
                  "action_description": "Lists all currently alive threads",
                  "action_id": "list_threads",
                  "object": "\"python\"",
                  "object_description": "Program directory",
                  "object_id": "program_directory",
                  "intention_description": "List files in directory",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "name=\"ncnn\", ...",
                  "object_description": "Python code string",
                  "object_id": "python_code_string",
                  "intention_description": "Trigger main behavioral logic",
                  "intention_id": "trigger_main_behavioral_logic"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pytelegrambotapi-4",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pytelegrambotapi-4.26.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "asyncio_helper.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pytelegrambotapi-4.26.0/pytelegrambotapi-4.26.0/telebot/asyncio_helper.py",
          "line_number": "12",
          "type_description": "shady-links",
          "context_snippet": "import asyncio # for future uses\nimport ssl\nimport aiohttp\nimport certifi\nfrom telebot import types\n\ntry:\n    import ujson as json\nexcept ImportError:\n    import json\nimport os\nAPI_URL = 'https://api.telegram.org/bot{0}/{1}'\n\nfrom datetime import datetime",
          "hash_value": "9939484a77d4e3c310cdf8d72a63f9c2",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import asyncio # for future uses\nimport ssl\nimport aiohttp\nimport certifi\nfrom telebot import types\n\ntry:\n    import ujson as json\nexcept ImportError:\n    import json\nimport os\nAPI_URL = 'https://api.telegram.org/bot{0}/{1}'\n\nfrom datetime import datetime",
              "triple_sequences": [
                {
                  "action_api": "import ujson",
                  "action_description": "Dynamically imports specified module",
                  "action_id": "import_dynamic",
                  "object": "ujson",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "import json",
                  "action_description": "Dynamically imports specified module",
                  "action_id": "import_dynamic",
                  "object": "json",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "h2o_pysparkling_3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/h2o_pysparkling_3.2-3.46.0.6.post1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "compatibility.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/h2o_pysparkling_3.2-3.46.0.6.post1/h2o_pysparkling_3.2-3.46.0.6.post1/h2o/utils/compatibility.py",
          "line_number": "157",
          "type_description": "obfuscation",
          "context_snippet": "def get_builtin(fn_name):\n    import builtins\n    return getattr(builtins, fn_name, None)",
          "hash_value": "963679988aef866f5c97b4458d548a05",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def get_builtin(fn_name):\n    import builtins\n    return getattr(builtins, fn_name, None)",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "builtins, fn_name, None",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "dagster_cloud-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/dagster_cloud-1.10.9.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "io_manager.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/dagster_cloud-1.10.9/dagster_cloud-1.10.9/dagster_cloud/serverless/io_manager.py",
          "line_number": "35",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "import os\nimport requests\nECS_AGENT_IP = \"169.254.170.2\"\n\nclass PickledObjectServerlessIOManager(UPathIOManager):\n    def _refresh_boto_session(self) -> tuple[boto3.Session, datetime.datetime]:\n        # We have to do this whacky way to get credentials to ensure that we get iam role\n        # we assigned to the task. If we used the default boto behavior, it could get overriden\n        # when users set AWS env vars.\n        relative_uri = os.environ[\"AWS_CONTAINER_CREDENTIALS_RELATIVE_URI\"]\n        aws_creds = requests.get(f\"http://{ECS_AGENT_IP}{relative_uri}\").json()\n        session = boto3.Session(\n            aws_access_key_id=aws_creds[\"AccessKeyId\"],\n            aws_secret_access_key=aws_creds[\"SecretAccessKey\"],\n            aws_session_token=aws_creds[\"Token\"],\n        )\n        expiration = parser.parse(aws_creds[\"Expiration\"])\n        return session, expiration  # pyright: ignore[reportReturnType]",
          "hash_value": "74403c34f0a7f9dc109769fbbd6e55c0",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport requests\nECS_AGENT_IP = \"169.254.170.2\"\n\nclass PickledObjectServerlessIOManager(UPathIOManager):\n    def _refresh_boto_session(self) -> tuple[boto3.Session, datetime.datetime]:\n        # We have to do this whacky way to get credentials to ensure that we get iam role\n        # we assigned to the task. If we used the default boto behavior, it could get overriden\n        # when users set AWS env vars.\n        relative_uri = os.environ[\"AWS_CONTAINER_CREDENTIALS_RELATIVE_URI\"]\n        aws_creds = requests.get(f\"http://{ECS_AGENT_IP}{relative_uri}\").json()\n        session = boto3.Session(\n            aws_access_key_id=aws_creds[\"AccessKeyId\"],\n            aws_secret_access_key=aws_creds[\"SecretAccessKey\"],\n            aws_session_token=aws_creds[\"Token\"],\n        )\n        expiration = parser.parse(aws_creds[\"Expiration\"])\n        return session, expiration  # pyright: ignore[reportReturnType]",
              "triple_sequences": [
                {
                  "action_api": "os.environ.__getitem__()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"AWS_CONTAINER_CREDENTIALS_RELATIVE_URI\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP GET request to URL",
                  "action_id": "open_url_get",
                  "object": "f\"http://{ECS_AGENT_IP}{relative_uri}\"",
                  "object_description": "External domain",
                  "object_id": "external_domain",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "requests.Response.json()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "webdrivermanager-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/webdrivermanager-0.10.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "base.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/webdrivermanager-0.10.0/webdrivermanager-0.10.0/src/webdrivermanager/base.py",
          "line_number": "211",
          "type_description": "shady-links",
          "context_snippet": "def _parse_github_page(self, version):\n    if version == \"latest\":\n        release_url = f\"{self.fallback_url}latest\"\n        matcher = r\".*\\/releases\\/download\\/.*{}\".format(self.os_name)\n    else:\n        release_url = f\"{self.fallback_url}tag/{version}\"\n        matcher = r\".*\\/releases\\/download\\/{}/.*{}\".format(version, self.os_name)\n\n    response = requests.get(release_url)\n    if response.status_code != 200:\n        return None\n\n    tree = BeautifulSoup(response.text, \"html.parser\")\n    links = tree.find_all(\"a\", href=re.compile(matcher))\n    if len(links) == 2:\n        matcher = f\"{matcher}.*{self.bitness}\"\n        links = tree.find_all(\"a\", href=re.compile(matcher))\n\n    if links:\n        return f\"https://github.com{links[0]['href']}\"\n\n    return None",
          "hash_value": "a4e509c1666f26ce6cbd662cae32a419",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def _parse_github_page(self, version):\n    if version == \"latest\":\n        release_url = f\"{self.fallback_url}latest\"\n        matcher = r\".*\\/releases\\/download\\/.*{}\".format(self.os_name)\n    else:\n        release_url = f\"{self.fallback_url}tag/{version}\"\n        matcher = r\".*\\/releases\\/download\\/{}/.*{}\".format(version, self.os_name)\n\n    response = requests.get(release_url)\n    if response.status_code != 200:\n        return None\n\n    tree = BeautifulSoup(response.text, \"html.parser\")\n    links = tree.find_all(\"a\", href=re.compile(matcher))\n    if len(links) == 2:\n        matcher = f\"{matcher}.*{self.bitness}\"\n        links = tree.find_all(\"a\", href=re.compile(matcher))\n\n    if links:\n        return f\"https://github.com{links[0]['href']}\"\n\n    return None",
              "triple_sequences": [
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "release_url",
                  "object_description": "External domain",
                  "object_id": "external_domain",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "BeautifulSoup()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "response.text, \"html.parser\"",
                  "object_description": "HTML file content",
                  "object_id": "",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "tree.find_all()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "matcher",
                  "object_description": "Regular expression pattern",
                  "object_id": "regex_pattern",
                  "intention_description": "Browser profile detection preparation",
                  "intention_id": "browser_profile_detection_preparation"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "feapder-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/feapder-1.9.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "create_cookies.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/feapder-1.9.2/feapder-1.9.2/feapder/commands/create/create_cookies.py",
          "line_number": "28",
          "type_description": "clipboard-access",
          "context_snippet": "import pyperclip\n\nclass CreateCookies:\n    def get_data(self):\n        \"\"\"\n        @summary: 从剪切板中读取内容\n        ---------\n        ---------\n        @result:\n        \"\"\"\n        input(\"请复制浏览器cookie (列表或字符串格式), 复制后按任意键读取剪切板内容\\n\")\n\n        text = pyperclip.paste()\n        print(text + \"\\n\")\n\n        return text",
          "hash_value": "405c0dea92b9ffd56907d8e6889d9e0f",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import pyperclip\n\nclass CreateCookies:\n    def get_data(self):\n        \"\"\"\n        @summary: 从剪切板中读取内容\n        ---------\n        ---------\n        @result:\n        \"\"\"\n        input(\"请复制浏览器cookie (列表或字符串格式), 复制后按任意键读取剪切板内容\\n\")\n\n        text = pyperclip.paste()\n        print(text + \"\\n\")\n\n        return text",
              "triple_sequences": [
                {
                  "action_api": "input()",
                  "action_description": "Reads user input from standard input",
                  "action_id": "read_user_input",
                  "object": "请复制浏览器cookie (列表或字符串格式), 复制后按任意键读取剪切板内容\\n",
                  "object_description": "Prompt string",
                  "object_id": "",
                  "intention_description": "Collect user input",
                  "intention_id": "collect_user_input"
                },
                {
                  "action_api": "pyperclip.paste()",
                  "action_description": "Retrieves text from system clipboard",
                  "action_id": "get_clipboard_text",
                  "object": "",
                  "object_description": "Clipboard content data",
                  "object_id": "clipboard_data",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                },
                {
                  "action_api": "print()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "text + \"\\n\"",
                  "object_description": "Clipboard content data",
                  "object_id": "clipboard_data",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "basicsr-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/basicsr-1.4.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/basicsr-1.4.2/basicsr-1.4.2/setup.py",
          "line_number": "31",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport subprocess\n\ndef get_git_hash():\n\n    def _minimal_ext_cmd(cmd):\n        # construct minimal environment\n        env = {}\n        for k in ['SYSTEMROOT', 'PATH', 'HOME']:\n            v = os.environ.get(k)\n            if v is not None:\n                env[k] = v\n        # LANGUAGE is used on win32\n        env['LANGUAGE'] = 'C'\n        env['LANG'] = 'C'\n        env['LC_ALL'] = 'C'\n        out = subprocess.Popen(cmd, stdout=subprocess.PIPE, env=env).communicate()[0]\n        return out\n\n    try:\n        out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])\n        sha = out.strip().decode('ascii')\n    except OSError:\n        sha = 'unknown'\n\n    return sha",
          "hash_value": "5c5f9a0ff3d27d1291d145856fd9122e",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport subprocess\n\ndef get_git_hash():\n\n    def _minimal_ext_cmd(cmd):\n        # construct minimal environment\n        env = {}\n        for k in ['SYSTEMROOT', 'PATH', 'HOME']:\n            v = os.environ.get(k)\n            if v is not None:\n                env[k] = v\n        # LANGUAGE is used on win32\n        env['LANGUAGE'] = 'C'\n        env['LANG'] = 'C'\n        env['LC_ALL'] = 'C'\n        out = subprocess.Popen(cmd, stdout=subprocess.PIPE, env=env).communicate()[0]\n        return out\n\n    try:\n        out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])\n        sha = out.strip().decode('ascii')\n    except OSError:\n        sha = 'unknown'\n\n    return sha",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "k",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "['git', 'rev-parse', 'HEAD']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "subprocess.Popen().communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "bytes.strip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for execution",
                  "intention_id": "prepare_string_execution"
                },
                {
                  "action_api": "bytes.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "ascii",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Prepare string for execution",
                  "intention_id": "prepare_string_execution"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "geemap-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/geemap-0.35.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "coreutils.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/geemap-0.35.3/geemap-0.35.3/geemap/coreutils.py",
          "line_number": "249",
          "type_description": "clipboard-access",
          "context_snippet": "def create_code_cell(code: str = \"\", where: str = \"below\") -> None:\n    \"\"\"Creates a code cell in the IPython Notebook.\n\n    Args:\n        code (str, optional): Code to fill the new code cell with. Defaults to ''.\n        where (str, optional): Where to add the new code cell. It can be one of\n            the following: above, below, at_bottom. Defaults to 'below'.\n    \"\"\"\n\n    import base64\n    import pyperclip\n\n    try:\n        pyperclip.copy(str(code))\n    except Exception as e:\n        pass\n\n    encoded_code = (base64.b64encode(str.encode(code))).decode()\n    display(\n        Javascript(\n            \"\"\"\n        var code = IPython.notebook.insert_cell_{0}('code');\n        code.set_text(atob(\"{1}\"));\n    \"\"\".format(\n                where, encoded_code\n            )\n        )\n    )",
          "hash_value": "79fd4798e2c145babcf10ced4370e322",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def create_code_cell(code: str = \"\", where: str = \"below\") -> None:\n    \"\"\"Creates a code cell in the IPython Notebook.\n\n    Args:\n        code (str, optional): Code to fill the new code cell with. Defaults to ''.\n        where (str, optional): Where to add the new code cell. It can be one of\n            the following: above, below, at_bottom. Defaults to 'below'.\n    \"\"\"\n\n    import base64\n    import pyperclip\n\n    try:\n        pyperclip.copy(str(code))\n    except Exception as e:\n        pass\n\n    encoded_code = (base64.b64encode(str.encode(code))).decode()\n    display(\n        Javascript(\n            \"\"\"\n        var code = IPython.notebook.insert_cell_{0}('code');\n        code.set_text(atob(\"{1}\"));\n    \"\"\".format(\n                where, encoded_code\n            )\n        )\n    )",
              "triple_sequences": [
                {
                  "action_api": "pyperclip.copy()",
                  "action_description": "Copies specified text to system clipboard",
                  "action_id": "copy_to_clipboard",
                  "object": "str(code)",
                  "object_description": "Clipboard content data",
                  "object_id": "clipboard_data",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                },
                {
                  "action_api": "str.encode()",
                  "action_description": "Encodes string to bytes using default encoding",
                  "action_id": "encode_string_to_bytes",
                  "object": "code",
                  "object_description": "Encoded string to bytes",
                  "object_id": "encoded_string_bytes",
                  "intention_description": "Encode string to bytes",
                  "intention_id": "encode_string_to_bytes"
                },
                {
                  "action_api": "base64.b64encode()",
                  "action_description": "Encodes bytes to base64-encoded bytes",
                  "action_id": "encode_bytes_to_base64",
                  "object": "str.encode(code)",
                  "object_description": "Encoded string to bytes",
                  "object_id": "encoded_string_bytes",
                  "intention_description": "Prepare data for base64 encoding",
                  "intention_id": "prepare_data_base64_encoding"
                },
                {
                  "action_api": "bytes.decode()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Decode bytes to string",
                  "intention_id": "decode_bytes_to_string"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "osmium-4",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/osmium-4.0.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/osmium-4.0.2/osmium-4.0.2/contrib/pybind11/setup.py",
          "line_number": "138",
          "type_description": "code-execution",
          "context_snippet": "import contextlib\nimport os\nimport re\nimport shutil\nimport string\nimport subprocess\nimport sys\nfrom collections.abc import Generator\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\n\nDIR = Path(__file__).parent.absolute()\n\nwith remove_output(\"pybind11/include\", \"pybind11/share\"):\n    # Generate the files if they are not present.\n    with TemporaryDirectory() as tmpdir:\n        cmd = [\"cmake\", \"-S\", \".\", \"-B\", tmpdir] + [\n            \"-DCMAKE_INSTALL_PREFIX=pybind11\",\n            \"-DBUILD_TESTING=OFF\",\n            \"-DPYBIND11_NOPYTHON=ON\",\n            \"-Dprefix_for_pc_file=${pcfiledir}/../../\",\n        ]\n        if \"CMAKE_ARGS\" in os.environ:\n            fcommand = [\n                c\n                for c in os.environ[\"CMAKE_ARGS\"].split()\n                if \"DCMAKE_INSTALL_PREFIX\" not in c\n            ]\n            cmd += fcommand\n        subprocess.run(cmd, check=True, cwd=DIR, stdout=sys.stdout, stderr=sys.stderr)\n        subprocess.run(\n            [\"cmake\", \"--install\", tmpdir],\n            check=True,\n            cwd=DIR,\n            stdout=sys.stdout,\n            stderr=sys.stderr,\n        )",
          "hash_value": "837a5a6753aa05e5b79110e244caf018",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import contextlib\nimport os\nimport re\nimport shutil\nimport string\nimport subprocess\nimport sys\nfrom collections.abc import Generator\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\n\nDIR = Path(__file__).parent.absolute()\n\nwith remove_output(\"pybind11/include\", \"pybind11/share\"):\n    # Generate the files if they are not present.\n    with TemporaryDirectory() as tmpdir:\n        cmd = [\"cmake\", \"-S\", \".\", \"-B\", tmpdir] + [\n            \"-DCMAKE_INSTALL_PREFIX=pybind11\",\n            \"-DBUILD_TESTING=OFF\",\n            \"-DPYBIND11_NOPYTHON=ON\",\n            \"-Dprefix_for_pc_file=${pcfiledir}/../../\",\n        ]\n        if \"CMAKE_ARGS\" in os.environ:\n            fcommand = [\n                c\n                for c in os.environ[\"CMAKE_ARGS\"].split()\n                if \"DCMAKE_INSTALL_PREFIX\" not in c\n            ]\n            cmd += fcommand\n        subprocess.run(cmd, check=True, cwd=DIR, stdout=sys.stdout, stderr=sys.stderr)\n        subprocess.run(\n            [\"cmake\", \"--install\", tmpdir],\n            check=True,\n            cwd=DIR,\n            stdout=sys.stdout,\n            stderr=sys.stderr,\n        )",
              "triple_sequences": [
                {
                  "action_api": "os.environ.__contains__()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "\"CMAKE_ARGS\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.__getitem__()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"CMAKE_ARGS\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.environ[\"CMAKE_ARGS\"]",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "cmd, check=True, cwd=DIR, stdout=sys.stdout, stderr=sys.stderr",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "[\"cmake\", \"--install\", tmpdir], check=True, cwd=DIR, stdout=sys.stdout, stderr=sys.stderr",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "gcsa-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/gcsa-2.5.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gcsa-2.5.1/gcsa-2.5.1/setup.py",
          "line_number": "74",
          "type_description": "code-execution",
          "context_snippet": "import subprocess\nimport os\n\nVERSION = '2.5.1'\n\nclass BuildDoc(Command):\n    user_options = []\n\n    def initialize_options(self) -> None:\n        pass\n\n    def finalize_options(self) -> None:\n        pass\n\n    def run(self):\n        output_path = 'docs/html'\n        changed_files = []\n        cmd = [\n            'sphinx-build',\n            'docs/source', output_path,\n            '--builder', 'html',\n            '--define', f'version={VERSION}',\n            '--verbose'\n        ]\n        with subprocess.Popen(\n                cmd,\n                stdout=subprocess.PIPE,\n                bufsize=1,\n                universal_newlines=True\n        ) as p:\n            for line in p.stdout:\n                print(line, end='')\n                if line.startswith('reading sources... ['):\n                    file_name = line.rsplit(maxsplit=1)[1]\n                    if file_name:\n                        changed_files.append(file_name + '.html')\n\n        index_path = os.path.join(os.getcwd(), output_path, 'index.html')\n        print('\\nIndex:')\n        print(f'file://{index_path}')\n\n        if changed_files:\n            print('Update pages:')\n            for cf in changed_files:\n                f_path = os.path.join(os.getcwd(), output_path, cf)\n                print(cf, f'file://{f_path}')",
          "hash_value": "b6ec8639b5c99f49ea80ee8fa30763cf",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import subprocess\nimport os\n\nVERSION = '2.5.1'\n\nclass BuildDoc(Command):\n    user_options = []\n\n    def initialize_options(self) -> None:\n        pass\n\n    def finalize_options(self) -> None:\n        pass\n\n    def run(self):\n        output_path = 'docs/html'\n        changed_files = []\n        cmd = [\n            'sphinx-build',\n            'docs/source', output_path,\n            '--builder', 'html',\n            '--define', f'version={VERSION}',\n            '--verbose'\n        ]\n        with subprocess.Popen(\n                cmd,\n                stdout=subprocess.PIPE,\n                bufsize=1,\n                universal_newlines=True\n        ) as p:\n            for line in p.stdout:\n                print(line, end='')\n                if line.startswith('reading sources... ['):\n                    file_name = line.rsplit(maxsplit=1)[1]\n                    if file_name:\n                        changed_files.append(file_name + '.html')\n\n        index_path = os.path.join(os.getcwd(), output_path, 'index.html')\n        print('\\nIndex:')\n        print(f'file://{index_path}')\n\n        if changed_files:\n            print('Update pages:')\n            for cf in changed_files:\n                f_path = os.path.join(os.getcwd(), output_path, cf)\n                print(cf, f'file://{f_path}')",
              "triple_sequences": [
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "['sphinx-build', 'docs/source', 'docs/html', '--builder', 'html', '--define', 'version=2.5.1', '--verbose']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "p.stdout",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "os.getcwd()",
                  "action_description": "Returns current working directory",
                  "action_id": "get_working_dir",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect working directory",
                  "intention_id": "collect_working_directory"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.getcwd(), output_path, 'index.html'",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.getcwd(), output_path, cf",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "loguru-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/loguru-0.7.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "_colorama.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/loguru-0.7.3/loguru-0.7.3/loguru/_colorama.py",
          "line_number": "10",
          "type_description": "obfuscation",
          "context_snippet": "import builtins\nimport os\nimport sys\n\n\ndef should_colorize(stream):\n    if stream is None:\n        return False\n\n    if getattr(builtins, \"__IPYTHON__\", False) and (stream is sys.stdout or stream is sys.stderr):\n        try:\n            import ipykernel\n            import IPython\n\n            ipython = IPython.get_ipython()\n            is_jupyter_stream = isinstance(stream, ipykernel.iostream.OutStream)\n            is_jupyter_shell = isinstance(ipython, ipykernel.zmqshell.ZMQInteractiveShell)\n        except Exception:\n            pass\n        else:\n            if is_jupyter_stream and is_jupyter_shell:\n                return True\n\n    if stream is sys.__stdout__ or stream is sys.__stderr__:\n        if \"CI\" in os.environ and any(\n            ci in os.environ\n            for ci in [\"TRAVIS\", \"CIRCLECI\", \"APPVEYOR\", \"GITLAB_CI\", \"GITHUB_ACTIONS\"]\n        ):\n            return True\n        if \"PYCHARM_HOSTED\" in os.environ:\n            return True\n        if os.name == \"nt\" and \"TERM\" in os.environ:\n            return True\n\n    try:\n        return stream.isatty()\n    except Exception:\n        return False",
          "hash_value": "37813b0af592e5c43ded42b03b38b876",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import builtins\nimport os\nimport sys\n\n\ndef should_colorize(stream):\n    if stream is None:\n        return False\n\n    if getattr(builtins, \"__IPYTHON__\", False) and (stream is sys.stdout or stream is sys.stderr):\n        try:\n            import ipykernel\n            import IPython\n\n            ipython = IPython.get_ipython()\n            is_jupyter_stream = isinstance(stream, ipykernel.iostream.OutStream)\n            is_jupyter_shell = isinstance(ipython, ipykernel.zmqshell.ZMQInteractiveShell)\n        except Exception:\n            pass\n        else:\n            if is_jupyter_stream and is_jupyter_shell:\n                return True\n\n    if stream is sys.__stdout__ or stream is sys.__stderr__:\n        if \"CI\" in os.environ and any(\n            ci in os.environ\n            for ci in [\"TRAVIS\", \"CIRCLECI\", \"APPVEYOR\", \"GITLAB_CI\", \"GITHUB_ACTIONS\"]\n        ):\n            return True\n        if \"PYCHARM_HOSTED\" in os.environ:\n            return True\n        if os.name == \"nt\" and \"TERM\" in os.environ:\n            return True\n\n    try:\n        return stream.isatty()\n    except Exception:\n        return False",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, \"__IPYTHON__\", False",
                  "object_description": "Builtin module",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "IPython.get_ipython()",
                  "action_description": "Dynamically imports specified module",
                  "action_id": "import_dynamic",
                  "object": "IPython",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "stream, ipykernel.iostream.OutStream",
                  "object_description": "Builtin module",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "ipython, ipykernel.zmqshell.ZMQInteractiveShell",
                  "object_description": "Builtin module",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "os.environ.__contains__()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"CI\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.__contains__()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"TRAVIS\", \"CIRCLECI\", \"APPVEYOR\", \"GITLAB_CI\", \"GITHUB_ACTIONS\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.__contains__()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"PYCHARM_HOSTED\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.__contains__()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"TERM\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "stream.isatty()",
                  "action_description": "Checks if window handle is valid",
                  "action_id": "check_window_handle",
                  "object": "stream",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "web",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/web.py-0.62.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "template.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/web.py-0.62/web.py-0.62/web/template.py",
          "line_number": "786",
          "type_description": "obfuscation",
          "context_snippet": "TEMPLATE_BUILTINS = dict(\n    [\n        (name, getattr(builtins, name))\n        for name in TEMPLATE_BUILTIN_NAMES\n        if name in builtins.__dict__\n    ]\n)\n\n# Data dependencies:\n# - 'TEMPLATE_BUILTIN_NAMES' is defined above as a list of builtin names\n# - 'builtins' is imported at the top: import builtins\n# - This dictionary comprehension is used to construct the TEMPLATE_BUILTINS dict\n# - Used in Template.__init__ and GAE_Render.__init__",
          "hash_value": "2656e4a0d0ff844e9eec6b53bc27b0c8",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "TEMPLATE_BUILTINS = dict(\n    [\n        (name, getattr(builtins, name))\n        for name in TEMPLATE_BUILTIN_NAMES\n        if name in builtins.__dict__\n    ]\n)\n\n# Data dependencies:\n# - 'TEMPLATE_BUILTIN_NAMES' is defined above as a list of builtin names\n# - 'builtins' is imported at the top: import builtins\n# - This dictionary comprehension is used to construct the TEMPLATE_BUILTINS dict\n# - Used in Template.__init__ and GAE_Render.__init__",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "builtins, name",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "adafruit_circuitpython_requests-4",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/adafruit_circuitpython_requests-4.1.10.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "requests_wifi_api_discord.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/adafruit_circuitpython_requests-4.1.10/adafruit_circuitpython_requests-4.1.10/examples/wifi/expanded/requests_wifi_api_discord.py",
          "line_number": "49",
          "type_description": "shady-links",
          "context_snippet": "DISCORD_SOURCE = (\n    \"https://discord.com/api/v10/guilds/\"\n    + \"327254708534116352\"  # Adafruit Discord ID\n    + \"/preview\"\n)\n\n# Data dependencies:\n# - The string \"https://discord.com/api/v10/guilds/\" is used as the base URL for the Discord API endpoint.\n# - The variable DISCORD_SOURCE is constructed using this string, concatenated with a guild ID and the string \"/preview\".\n# - DISCORD_SOURCE is later used as the 'url' parameter in requests.get().\n# - Relevant imports: None directly for this line, but 'adafruit_requests' is used for HTTP requests.\n# - Variable declaration: DISCORD_SOURCE is declared here.\n# - No function context; this is a global assignment.",
          "hash_value": "f61232c4b00007e58057fcf67341f543",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "DISCORD_SOURCE = (\n    \"https://discord.com/api/v10/guilds/\"\n    + \"327254708534116352\"  # Adafruit Discord ID\n    + \"/preview\"\n)\n\n# Data dependencies:\n# - The string \"https://discord.com/api/v10/guilds/\" is used as the base URL for the Discord API endpoint.\n# - The variable DISCORD_SOURCE is constructed using this string, concatenated with a guild ID and the string \"/preview\".\n# - DISCORD_SOURCE is later used as the 'url' parameter in requests.get().\n# - Relevant imports: None directly for this line, but 'adafruit_requests' is used for HTTP requests.\n# - Variable declaration: DISCORD_SOURCE is declared here.\n# - No function context; this is a global assignment.",
              "triple_sequences": [
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "https://discord.com/api/v10/guilds/327254708534116352/preview",
                  "object_description": "Discord API endpoint",
                  "object_id": "discord_api_endpoint",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pulumi_command-4",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pulumi_command-4.6.0a1662390243.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pulumi_command-4.6.0a1662390243/pulumi_command-4.6.0a1662390243/setup.py",
          "line_number": "18",
          "type_description": "code-execution",
          "context_snippet": "import errno\nfrom setuptools import setup, find_packages\nfrom setuptools.command.install import install\nfrom subprocess import check_call\n\nVERSION = \"4.6.0a1662390243\"\nPLUGIN_VERSION = \"4.6.0-alpha.1662390243+5c22c9dd\"\n\nclass InstallPluginCommand(install):\n    def run(self):\n        install.run(self)\n        try:\n            check_call(['pulumi', 'plugin', 'install', 'resource', 'command', PLUGIN_VERSION])\n        except OSError as error:\n            if error.errno == errno.ENOENT:\n                print(f\"\"\"\n                There was an error installing the command resource provider plugin.\n                It looks like `pulumi` is not installed on your system.\n                Please visit https://pulumi.com/ to install the Pulumi CLI.\n                You may try manually installing the plugin by running\n                `pulumi plugin install resource command {PLUGIN_VERSION}`\n                \"\"\")\n            else:\n                raise",
          "hash_value": "042ca33578367697487bd95c1972c3c8",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import errno\nfrom setuptools import setup, find_packages\nfrom setuptools.command.install import install\nfrom subprocess import check_call\n\nVERSION = \"4.6.0a1662390243\"\nPLUGIN_VERSION = \"4.6.0-alpha.1662390243+5c22c9dd\"\n\nclass InstallPluginCommand(install):\n    def run(self):\n        install.run(self)\n        try:\n            check_call(['pulumi', 'plugin', 'install', 'resource', 'command', PLUGIN_VERSION])\n        except OSError as error:\n            if error.errno == errno.ENOENT:\n                print(f\"\"\"\n                There was an error installing the command resource provider plugin.\n                It looks like `pulumi` is not installed on your system.\n                Please visit https://pulumi.com/ to install the Pulumi CLI.\n                You may try manually installing the plugin by running\n                `pulumi plugin install resource command {PLUGIN_VERSION}`\n                \"\"\")\n            else:\n                raise",
              "triple_sequences": [
                {
                  "action_api": "install.run()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "['pulumi', 'plugin', 'install', 'resource', 'command', PLUGIN_VERSION]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "print()",
                  "action_description": "Reads user input from standard input",
                  "action_id": "read_user_input",
                  "object": "Error message about Pulumi CLI not installed",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                },
                {
                  "action_api": "raise",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "OSError",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "z3_solver-4",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/z3_solver-4.14.1.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/z3_solver-4.14.1.0/z3_solver-4.14.1.0/setup.py",
          "line_number": "179",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport sys\nimport shutil\nimport platform\nimport subprocess\nimport multiprocessing\nimport re\nimport glob\n\nbuild_env = dict(os.environ)\nbuild_env['PYTHON'] = sys.executable\nbuild_env['CXXFLAGS'] = build_env.get('CXXFLAGS', '') + \" -std=c++20\"\n\n# ... (other global variables and logic)\n\ndef _configure_z3():\n    global IS_SINGLE_THREADED\n    global ENABLE_LTO\n    # bail out early if we don't need to do this - it forces a rebuild every time otherwise\n    if os.path.exists(BUILD_DIR):\n        return\n    else:\n        os.mkdir(BUILD_DIR)\n    # Config options\n    cmake_options = {\n        # Config Options\n        'Z3_SINGLE_THREADED' : IS_SINGLE_THREADED,      # avoid solving features that use threads\n        'Z3_POLLING_TIMER' : IS_SINGLE_THREADED,         # avoid using timer threads\n        'Z3_BUILD_PYTHON_BINDINGS' : True,\n        # Build Options\n        'CMAKE_BUILD_TYPE' : 'Release',\n        'Z3_BUILD_EXECUTABLE' : True,\n        'Z3_BUILD_LIBZ3_SHARED' : True,\n        'Z3_LINK_TIME_OPTIMIZATION' : ENABLE_LTO,\n        'WARNINGS_AS_ERRORS' : 'SERIOUS_ONLY',\n        # Disable Unwanted Options\n        'Z3_USE_LIB_GMP' : False, # Is default false in python build\n        'Z3_INCLUDE_GIT_HASH' : False, # Can be changed if we bundle the .git as well\n        'Z3_INCLUDE_GIT_DESCRIBE' : False,\n        'Z3_SAVE_CLANG_OPTIMIZATION_RECORDS' : False,\n        'Z3_ENABLE_TRACING_FOR_NON_DEBUG' : False,\n        'Z3_ENABLE_EXAMPLE_TARGETS' : False,\n        'Z3_ENABLE_CFI' : False,\n        'Z3_BUILD_DOCUMENTATION' : False,\n        'Z3_BUILD_TEST_EXECUTABLES' : False,\n        'Z3_BUILD_DOTNET_BINDINGS' : False,\n        'Z3_BUILD_JAVA_BINDINGS' : False\n    }\n    # Convert cmake options to CLI arguments\n    for key, val in cmake_options.items():\n        if type(val) is bool:\n            cmake_options[key] = str(val).upper()\n\n    # Allow command-line arguments to add and override Z3_ options\n    for i in range(len(sys.argv) - 1):\n        key = sys.argv[i]\n        if key.startswith(\"Z3_\"):\n            val = sys.argv[i + 1].upper()\n            if val == \"TRUE\" or val == \"FALSE\":\n                cmake_options[key] = val\n                \n    cmake_args = [ '-D' + key + '=' + value for key,value in cmake_options.items() ]\n    args = [ 'cmake', *cmake_args, SRC_DIR ]\n    if subprocess.call(args, env=build_env, cwd=BUILD_DIR) != 0:\n        raise LibError(\"Unable to configure Z3.\")",
          "hash_value": "51da48031747eb20d64ce8b7db091e82",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport sys\nimport shutil\nimport platform\nimport subprocess\nimport multiprocessing\nimport re\nimport glob\n\nbuild_env = dict(os.environ)\nbuild_env['PYTHON'] = sys.executable\nbuild_env['CXXFLAGS'] = build_env.get('CXXFLAGS', '') + \" -std=c++20\"\n\n# ... (other global variables and logic)\n\ndef _configure_z3():\n    global IS_SINGLE_THREADED\n    global ENABLE_LTO\n    # bail out early if we don't need to do this - it forces a rebuild every time otherwise\n    if os.path.exists(BUILD_DIR):\n        return\n    else:\n        os.mkdir(BUILD_DIR)\n    # Config options\n    cmake_options = {\n        # Config Options\n        'Z3_SINGLE_THREADED' : IS_SINGLE_THREADED,      # avoid solving features that use threads\n        'Z3_POLLING_TIMER' : IS_SINGLE_THREADED,         # avoid using timer threads\n        'Z3_BUILD_PYTHON_BINDINGS' : True,\n        # Build Options\n        'CMAKE_BUILD_TYPE' : 'Release',\n        'Z3_BUILD_EXECUTABLE' : True,\n        'Z3_BUILD_LIBZ3_SHARED' : True,\n        'Z3_LINK_TIME_OPTIMIZATION' : ENABLE_LTO,\n        'WARNINGS_AS_ERRORS' : 'SERIOUS_ONLY',\n        # Disable Unwanted Options\n        'Z3_USE_LIB_GMP' : False, # Is default false in python build\n        'Z3_INCLUDE_GIT_HASH' : False, # Can be changed if we bundle the .git as well\n        'Z3_INCLUDE_GIT_DESCRIBE' : False,\n        'Z3_SAVE_CLANG_OPTIMIZATION_RECORDS' : False,\n        'Z3_ENABLE_TRACING_FOR_NON_DEBUG' : False,\n        'Z3_ENABLE_EXAMPLE_TARGETS' : False,\n        'Z3_ENABLE_CFI' : False,\n        'Z3_BUILD_DOCUMENTATION' : False,\n        'Z3_BUILD_TEST_EXECUTABLES' : False,\n        'Z3_BUILD_DOTNET_BINDINGS' : False,\n        'Z3_BUILD_JAVA_BINDINGS' : False\n    }\n    # Convert cmake options to CLI arguments\n    for key, val in cmake_options.items():\n        if type(val) is bool:\n            cmake_options[key] = str(val).upper()\n\n    # Allow command-line arguments to add and override Z3_ options\n    for i in range(len(sys.argv) - 1):\n        key = sys.argv[i]\n        if key.startswith(\"Z3_\"):\n            val = sys.argv[i + 1].upper()\n            if val == \"TRUE\" or val == \"FALSE\":\n                cmake_options[key] = val\n                \n    cmake_args = [ '-D' + key + '=' + value for key,value in cmake_options.items() ]\n    args = [ 'cmake', *cmake_args, SRC_DIR ]\n    if subprocess.call(args, env=build_env, cwd=BUILD_DIR) != 0:\n        raise LibError(\"Unable to configure Z3.\")",
              "triple_sequences": [
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "BUILD_DIR",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Determine directory presence",
                  "intention_id": "determine_directory_presence"
                },
                {
                  "action_api": "os.mkdir()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "BUILD_DIR",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "sys.argv",
                  "action_description": "Retrieves command-line arguments passed to script",
                  "action_id": "get_cmd_args",
                  "object": "sys.argv",
                  "object_description": "Command-line arguments passed to script",
                  "object_id": "",
                  "intention_description": "Access command line arguments",
                  "intention_id": "access_command_line_arguments"
                },
                {
                  "action_api": "subprocess.call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "args, env=build_env, cwd=BUILD_DIR",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "bcpandas-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/bcpandas-2.7.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "__init__.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/bcpandas-2.7.2/bcpandas-2.7.2/bcpandas/__init__.py",
          "line_number": "11",
          "type_description": "silent-process-execution",
          "context_snippet": "from subprocess import DEVNULL, run\nimport warnings\n\nfrom bcpandas.main import SqlCreds, to_sql\nfrom bcpandas.utils import bcp\n\n__version__ = \"2.7.2\"\n\n# BCP check\ntry:\n    run([\"bcp\", \"-v\"], stdout=DEVNULL, stderr=DEVNULL, stdin=DEVNULL)\nexcept (FileNotFoundError, PermissionError):\n    warnings.warn(\"BCP utility not installed or not found in PATH, bcpandas will not work!\")\n\ndel run, DEVNULL, warnings",
          "hash_value": "1443266a46a22c7fb09cc6f59093683e",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from subprocess import DEVNULL, run\nimport warnings\n\nfrom bcpandas.main import SqlCreds, to_sql\nfrom bcpandas.utils import bcp\n\n__version__ = \"2.7.2\"\n\n# BCP check\ntry:\n    run([\"bcp\", \"-v\"], stdout=DEVNULL, stderr=DEVNULL, stdin=DEVNULL)\nexcept (FileNotFoundError, PermissionError):\n    warnings.warn(\"BCP utility not installed or not found in PATH, bcpandas will not work!\")\n\ndel run, DEVNULL, warnings",
              "triple_sequences": [
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "[\"bcp\", \"-v\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "warnings.warn()",
                  "action_description": "Raises warning message",
                  "action_id": "raise_http_error",
                  "object": "\"BCP utility not installed or not found in PATH, bcpandas will not work!\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                },
                {
                  "action_api": "del run",
                  "action_description": "Deletes function from global namespace",
                  "action_id": "delete_function_global_namespace",
                  "object": "run",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Delete function from global namespace",
                  "intention_id": "delete_function_global_namespace"
                },
                {
                  "action_api": "del DEVNULL",
                  "action_description": "Deletes function from global namespace",
                  "action_id": "delete_function_global_namespace",
                  "object": "DEVNULL",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Delete function from global namespace",
                  "intention_id": "delete_function_global_namespace"
                },
                {
                  "action_api": "del warnings",
                  "action_description": "Deletes function from global namespace",
                  "action_id": "delete_function_global_namespace",
                  "object": "warnings",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Delete function from global namespace",
                  "intention_id": "delete_function_global_namespace"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "zexceptions-5",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/zexceptions-5.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "__init__.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/zexceptions-5.0/zExceptions-5.0/src/zExceptions/__init__.py",
          "line_number": "514",
          "type_description": "obfuscation",
          "context_snippet": "def convertExceptionType(name):\n    import zExceptions\n    etype = None\n    if name in builtins.__dict__:\n        etype = getattr(builtins, name)\n    elif hasattr(zExceptions, name):\n        etype = getattr(zExceptions, name)\n    if (etype is not None and\n            isinstance(etype, type) and\n            issubclass(etype, Exception)):\n        return etype",
          "hash_value": "7cf61138872b6679bcdfc7818828ecb1",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def convertExceptionType(name):\n    import zExceptions\n    etype = None\n    if name in builtins.__dict__:\n        etype = getattr(builtins, name)\n    elif hasattr(zExceptions, name):\n        etype = getattr(zExceptions, name)\n    if (etype is not None and\n            isinstance(etype, type) and\n            issubclass(etype, Exception)):\n        return etype",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, name",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "hasattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "zExceptions, name",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "zExceptions, name",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "etype, type",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "issubclass()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "etype, Exception",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "aliyun-python-sdk-core-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/aliyun-python-sdk-core-2.16.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "ecs_ram_role_signer.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/aliyun-python-sdk-core-2.16.0/aliyun-python-sdk-core-2.16.0/aliyunsdkcore/auth/signers/ecs_ram_role_signer.py",
          "line_number": "58",
          "type_description": "shady-links",
          "context_snippet": "import time\nimport logging\nimport json\n\nfrom aliyunsdkcore.vendored.six.moves.urllib.request import urlopen\nfrom aliyunsdkcore.auth.signers.signer import Signer\nfrom aliyunsdkcore.acs_exception.exceptions import ServerException\n\nlogger = logging.getLogger(__name__)\n\n\nclass EcsRamRoleSigner(Signer):\n    _SESSION_PERIOD = 3600\n    _REFRESH_SCALE = 0.9\n\n    def __init__(self, ecs_ram_role_credential):\n        self._credential = ecs_ram_role_credential\n        self._last_update_time = 0\n\n    def sign(self, region_id, request):\n        self._check_session_credential()\n        session_ak, session_sk, token = self._session_credential\n        if request.get_style() == 'RPC':\n            request.add_query_param(\"SecurityToken\", token)\n        else:\n            request.add_header(\"x-acs-security-token\", token)\n        header = request.get_signed_header(region_id, session_ak, session_sk)\n        url = request.get_url(region_id, session_ak, session_sk)\n        return header, url\n\n    def _check_session_credential(self):\n        now = int(time.time())\n        if now - self._last_update_time > (self._SESSION_PERIOD * self._REFRESH_SCALE):\n            self._refresh_session_ak_and_sk()\n\n    def _refresh_session_ak_and_sk(self):\n        request_url = \"http://100.100.100.200/latest/meta-data/ram/security-credentials/\" + \\\n            self._credential.role_name\n        content = urlopen(request_url).read()\n        response = json.loads(content.decode('utf-8'))\n        if response.get(\"Code\") != \"Success\":\n            message = 'refresh Ecs sts token err, code is ' + \\\n                response.get(\"Code\")\n            raise ServerException(\n                response.get(\"Code\"), message, None)\n\n        session_ak = response.get(\"AccessKeyId\")\n        session_sk = response.get(\"AccessKeySecret\")\n        token = response.get(\"SecurityToken\")\n        self._session_credential = session_ak, session_sk, token\n        self._last_update_time = int(time.time())",
          "hash_value": "d2f3a55c393b850c6b048248d124af6a",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import time\nimport logging\nimport json\n\nfrom aliyunsdkcore.vendored.six.moves.urllib.request import urlopen\nfrom aliyunsdkcore.auth.signers.signer import Signer\nfrom aliyunsdkcore.acs_exception.exceptions import ServerException\n\nlogger = logging.getLogger(__name__)\n\n\nclass EcsRamRoleSigner(Signer):\n    _SESSION_PERIOD = 3600\n    _REFRESH_SCALE = 0.9\n\n    def __init__(self, ecs_ram_role_credential):\n        self._credential = ecs_ram_role_credential\n        self._last_update_time = 0\n\n    def sign(self, region_id, request):\n        self._check_session_credential()\n        session_ak, session_sk, token = self._session_credential\n        if request.get_style() == 'RPC':\n            request.add_query_param(\"SecurityToken\", token)\n        else:\n            request.add_header(\"x-acs-security-token\", token)\n        header = request.get_signed_header(region_id, session_ak, session_sk)\n        url = request.get_url(region_id, session_ak, session_sk)\n        return header, url\n\n    def _check_session_credential(self):\n        now = int(time.time())\n        if now - self._last_update_time > (self._SESSION_PERIOD * self._REFRESH_SCALE):\n            self._refresh_session_ak_and_sk()\n\n    def _refresh_session_ak_and_sk(self):\n        request_url = \"http://100.100.100.200/latest/meta-data/ram/security-credentials/\" + \\\n            self._credential.role_name\n        content = urlopen(request_url).read()\n        response = json.loads(content.decode('utf-8'))\n        if response.get(\"Code\") != \"Success\":\n            message = 'refresh Ecs sts token err, code is ' + \\\n                response.get(\"Code\")\n            raise ServerException(\n                response.get(\"Code\"), message, None)\n\n        session_ak = response.get(\"AccessKeyId\")\n        session_sk = response.get(\"AccessKeySecret\")\n        token = response.get(\"SecurityToken\")\n        self._session_credential = session_ak, session_sk, token\n        self._last_update_time = int(time.time())",
              "triple_sequences": [
                {
                  "action_api": "time.time()",
                  "action_description": "Returns current time",
                  "action_id": "get_current_time",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get datetime epoch",
                  "intention_id": "get_datetime_epoch"
                },
                {
                  "action_api": "urlopen()",
                  "action_description": "Opens URL with GET parameters",
                  "action_id": "open_url_get",
                  "object": "http://100.100.100.200/latest/meta-data/ram/security-credentials/<role_name>",
                  "object_description": "External domain",
                  "object_id": "external_domain",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "read()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "json.loads()",
                  "action_description": "Deserializes JSON string to Python object",
                  "action_id": "deserialize_from_json",
                  "object": "content.decode('utf-8')",
                  "object_description": "JSON string",
                  "object_id": "json_string",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "str.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "content",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Decode bytes to string",
                  "intention_id": "decode_bytes_to_string"
                },
                {
                  "action_api": "response.get()",
                  "action_description": "Retrieves value and data type for registry value",
                  "action_id": "get_registry_value",
                  "object": "\"Code\"",
                  "object_description": "Registry value name",
                  "object_id": "registry_value_name",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "raise ServerException()",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "response.get(\"Code\"), message, None",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                },
                {
                  "action_api": "response.get()",
                  "action_description": "Retrieves value and data type for registry value",
                  "action_id": "get_registry_value",
                  "object": "\"AccessKeyId\"",
                  "object_description": "Registry value name",
                  "object_id": "registry_value_name",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "response.get()",
                  "action_description": "Retrieves value and data type for registry value",
                  "action_id": "get_registry_value",
                  "object": "\"AccessKeySecret\"",
                  "object_description": "Registry value name",
                  "object_id": "registry_value_name",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "response.get()",
                  "action_description": "Retrieves value and data type for registry value",
                  "action_id": "get_registry_value",
                  "object": "\"SecurityToken\"",
                  "object_description": "Registry value name",
                  "object_id": "registry_value_name",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "time.time()",
                  "action_description": "Returns current time",
                  "action_id": "get_current_time",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get datetime epoch",
                  "intention_id": "get_datetime_epoch"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "jpype1-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/jpype1-1.5.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/jpype1-1.5.2/jpype1-1.5.2/setup.py",
          "line_number": "55",
          "type_description": "cmd-overwrite",
          "context_snippet": "from setuptools import Extension\nfrom setuptools import setup\n\n# Add our setupext package to the path, and import it.\nsys.path.append(str(Path(__file__).parent))\nimport setupext\n\nif '--android' in sys.argv:\n    platform = 'android'\n    sys.argv.remove('--android')\nelse:\n    platform = sys.platform\n\n\njpypeLib = Extension(name='_jpype', **setupext.platform.Platform(\n    include_dirs=[Path('native', 'common', 'include'),\n                  Path('native', 'python', 'include'),\n                  Path('native', 'embedded', 'include')],\n    sources=sorted(\n        list(Path('native', 'common').glob('*.cpp')) +\n        list(Path('native', 'python').glob('*.cpp')) +\n        list(Path('native', 'embedded').glob('*.cpp'))\n    ),\n    platform=platform,\n))\njpypeJar = Extension(name=\"org.jpype\",\n                     sources=sorted(map(str, Path(\"native\", \"java\").glob(\"**/*.java\"))),\n                     language=\"java\",\n                     libraries=[\"lib/asm-8.0.1.jar\"]\n                     )\n\n\nsetup(\n    # Non-standard, and extension behaviour of setup() - project information\n    # should be put in pyproject.toml wherever possible. See also:\n    # https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#setuptools-specific-configuration\n    platforms=[\n        'Operating System :: Microsoft :: Windows',\n        'Operating System :: POSIX',\n        'Operating System :: Unix',\n        'Operating System :: MacOS',\n    ],\n    packages=['jpype', 'jpype._pyinstaller'],\n    package_dir={'jpype': 'jpype', },\n    package_data={'jpype': ['*.pyi']},\n    cmdclass={\n        'build_ext': setupext.build_ext.BuildExtCommand,\n        'develop': setupext.develop.Develop,\n        'test_java': setupext.test_java.TestJavaCommand,\n        'sdist': setupext.sdist.BuildSourceDistribution,\n    },\n    zip_safe=False,\n    ext_modules=[jpypeJar, jpypeLib, ],\n)\n",
          "hash_value": "46f4bd60751fdb8e457cade24075b03d",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from setuptools import Extension\nfrom setuptools import setup\n\n# Add our setupext package to the path, and import it.\nsys.path.append(str(Path(__file__).parent))\nimport setupext\n\nif '--android' in sys.argv:\n    platform = 'android'\n    sys.argv.remove('--android')\nelse:\n    platform = sys.platform\n\n\njpypeLib = Extension(name='_jpype', **setupext.platform.Platform(\n    include_dirs=[Path('native', 'common', 'include'),\n                  Path('native', 'python', 'include'),\n                  Path('native', 'embedded', 'include')],\n    sources=sorted(\n        list(Path('native', 'common').glob('*.cpp')) +\n        list(Path('native', 'python').glob('*.cpp')) +\n        list(Path('native', 'embedded').glob('*.cpp'))\n    ),\n    platform=platform,\n))\njpypeJar = Extension(name=\"org.jpype\",\n                     sources=sorted(map(str, Path(\"native\", \"java\").glob(\"**/*.java\"))),\n                     language=\"java\",\n                     libraries=[\"lib/asm-8.0.1.jar\"]\n                     )\n\n\nsetup(\n    # Non-standard, and extension behaviour of setup() - project information\n    # should be put in pyproject.toml wherever possible. See also:\n    # https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#setuptools-specific-configuration\n    platforms=[\n        'Operating System :: Microsoft :: Windows',\n        'Operating System :: POSIX',\n        'Operating System :: Unix',\n        'Operating System :: MacOS',\n    ],\n    packages=['jpype', 'jpype._pyinstaller'],\n    package_dir={'jpype': 'jpype', },\n    package_data={'jpype': ['*.pyi']},\n    cmdclass={\n        'build_ext': setupext.build_ext.BuildExtCommand,\n        'develop': setupext.develop.Develop,\n        'test_java': setupext.test_java.TestJavaCommand,\n        'sdist': setupext.sdist.BuildSourceDistribution,\n    },\n    zip_safe=False,\n    ext_modules=[jpypeJar, jpypeLib, ],\n)\n",
              "triple_sequences": [
                {
                  "action_api": "sys.path.append()",
                  "action_description": "Path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "str(Path(__file__).parent)",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "import setupext",
                  "action_description": "Dynamically imports specified module",
                  "action_id": "import_dynamic",
                  "object": "setupext",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "sys.argv.remove()",
                  "action_description": "Retrieves command-line arguments passed to script",
                  "action_id": "get_cmd_args",
                  "object": "'--android'",
                  "object_description": "Command-line arguments",
                  "object_id": "",
                  "intention_description": "Access command line arguments",
                  "intention_id": "access_command_line_arguments"
                },
                {
                  "action_api": "Path('native', 'common', 'include')",
                  "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
                  "action_id": "path_object_operations",
                  "object": "'native', 'common', 'include'",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "Path('native', 'python', 'include')",
                  "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
                  "action_id": "path_object_operations",
                  "object": "'native', 'python', 'include'",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "Path('native', 'embedded', 'include')",
                  "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
                  "action_id": "path_object_operations",
                  "object": "'native', 'embedded', 'include'",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "Path('native', 'common').glob('*.cpp')",
                  "action_description": "Directory tree generation",
                  "action_id": "path_special_operations",
                  "object": "'native', 'common', '*.cpp'",
                  "object_description": "Directory path with file",
                  "object_id": "directory_path_with_file",
                  "intention_description": "List directory files",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "Path('native', 'python').glob('*.cpp')",
                  "action_description": "Directory tree generation",
                  "action_id": "path_special_operations",
                  "object": "'native', 'python', '*.cpp'",
                  "object_description": "Directory path with file",
                  "object_id": "directory_path_with_file",
                  "intention_description": "List directory files",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "Path('native', 'embedded').glob('*.cpp')",
                  "action_description": "Directory tree generation",
                  "action_id": "path_special_operations",
                  "object": "'native', 'embedded', '*.cpp'",
                  "object_description": "Directory path with file",
                  "object_id": "directory_path_with_file",
                  "intention_description": "List directory files",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "Path('native', 'java').glob('**/*.java')",
                  "action_description": "Directory tree generation",
                  "action_id": "path_special_operations",
                  "object": "'native', 'java', '**/*.java'",
                  "object_description": "Directory path with file",
                  "object_id": "directory_path_with_file",
                  "intention_description": "List directory files",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "ext_modules=[jpypeJar, jpypeLib]",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pycrypto-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pycrypto-2.6.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pycrypto-2.6.1/pycrypto-2.6.1/setup.py",
          "line_number": "242",
          "type_description": "code-execution",
          "context_snippet": "    def __read_autoconf(self, filename):\n        rx_define = re.compile(r\"\"\"^#define (\\S+) (?:(\\d+)|(\".*\"))$\"\"\")\n\n        result = {}\n        f = open(filename, \"r\")\n        try:\n            config_lines = f.read().replace(\"\\r\\n\", \"\\n\").split(\"\\n\")\n            for line in config_lines:\n                m = rx_define.search(line)\n                if not m: continue\n                sym = m.group(1)\n                n = m.group(2)\n                s = m.group(3)\n                if n:\n                    result[sym] = int(n)\n                elif s:\n                    result[sym] = eval(s)     # XXX - hack to unescape C-style string\n                else:\n                    continue\n        finally:\n            f.close()\n        return result",
          "hash_value": "b603815f17d168f366bcd60d981c4a0b",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "    def __read_autoconf(self, filename):\n        rx_define = re.compile(r\"\"\"^#define (\\S+) (?:(\\d+)|(\".*\"))$\"\"\")\n\n        result = {}\n        f = open(filename, \"r\")\n        try:\n            config_lines = f.read().replace(\"\\r\\n\", \"\\n\").split(\"\\n\")\n            for line in config_lines:\n                m = rx_define.search(line)\n                if not m: continue\n                sym = m.group(1)\n                n = m.group(2)\n                s = m.group(3)\n                if n:\n                    result[sym] = int(n)\n                elif s:\n                    result[sym] = eval(s)     # XXX - hack to unescape C-style string\n                else:\n                    continue\n        finally:\n            f.close()\n        return result",
              "triple_sequences": [
                {
                  "action_api": "re.compile()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "^#define (\\S+) (?:(\\d+)|(\".*\"))$",
                  "object_description": "Regular expression pattern",
                  "object_id": "regex_pattern",
                  "intention_description": "Browser profile detection preparation",
                  "intention_id": "browser_profile_detection_preparation"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "filename, \"r\"",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "str.replace()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "\"\\r\\n\", \"\\n\"",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "\"\\n\"",
                  "object_description": "Space delimiter",
                  "object_id": "space_delimiter",
                  "intention_description": "Prepare string processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "re.Pattern.search()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "line",
                  "object_description": "Regular expression and file content",
                  "object_id": "regex_file_content",
                  "intention_description": "Extract structured file data",
                  "intention_id": "extract_structured_file_data"
                },
                {
                  "action_api": "int()",
                  "action_description": "Convert string to integer",
                  "action_id": "convert_char_to_int",
                  "object": "n",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Convert string to integer",
                  "intention_id": "convert_string_to_integer"
                },
                {
                  "action_api": "eval()",
                  "action_description": "Evaluates string as Python expression",
                  "action_id": "eval_python_expr",
                  "object": "s",
                  "object_description": "Character from obfuscated string",
                  "object_id": "character_from_obfuscated_string",
                  "intention_description": "Decode obfuscated data",
                  "intention_id": "decode_obfuscated_data"
                },
                {
                  "action_api": "file.close()",
                  "action_description": "Closes the opened file",
                  "action_id": "close_file",
                  "object": "",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Close file",
                  "intention_id": "close_file"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "zope_configuration-6",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/zope_configuration-6.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "config.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/zope_configuration-6.0/zope_configuration-6.0/src/zope/configuration/config.py",
          "line_number": "185",
          "type_description": "obfuscation",
          "context_snippet": "import builtins\n...\n    def resolve(self, dottedname):\n        \"\"\"\n        Resolve a dotted name to an object.\n        ...\n        if len(names) == 1:\n            # Check for built-in objects\n            marker = object()\n            obj = getattr(builtins, names[0], marker)\n            if obj is not marker:\n                return obj\n        ...\n",
          "hash_value": "0d3d0e1276d0f0b2d69080b3721f9b42",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import builtins\n...\n    def resolve(self, dottedname):\n        \"\"\"\n        Resolve a dotted name to an object.\n        ...\n        if len(names) == 1:\n            # Check for built-in objects\n            marker = object()\n            obj = getattr(builtins, names[0], marker)\n            if obj is not marker:\n                return obj\n        ...\n",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, names[0], marker",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "cherrypy-18",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/cherrypy-18.10.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "reprconf.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cherrypy-18.10.0/cherrypy-18.10.0/cherrypy/lib/reprconf.py",
          "line_number": "325",
          "type_description": "obfuscation",
          "context_snippet": "import builtins\n\nclass _Builder:\n    ...\n    def build_Name(self, o):\n        name = o.id\n        if name == 'None':\n            return None\n        if name == 'True':\n            return True\n        if name == 'False':\n            return False\n\n        # See if the Name is a package or module. If it is, import it.\n        try:\n            return modules(name)\n        except ImportError:\n            pass\n\n        # See if the Name is in builtins.\n        try:\n            return getattr(builtins, name)\n        except AttributeError:\n            pass\n\n        raise TypeError('unrepr could not resolve the name %s' % repr(name))\n    ...",
          "hash_value": "6b50dbc593c489b7df2002b9fd792912",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import builtins\n\nclass _Builder:\n    ...\n    def build_Name(self, o):\n        name = o.id\n        if name == 'None':\n            return None\n        if name == 'True':\n            return True\n        if name == 'False':\n            return False\n\n        # See if the Name is a package or module. If it is, import it.\n        try:\n            return modules(name)\n        except ImportError:\n            pass\n\n        # See if the Name is in builtins.\n        try:\n            return getattr(builtins, name)\n        except AttributeError:\n            pass\n\n        raise TypeError('unrepr could not resolve the name %s' % repr(name))\n    ...",
              "triple_sequences": [
                {
                  "action_api": "modules()",
                  "action_description": "Dynamically imports specified module",
                  "action_id": "import_dynamic",
                  "object": "name",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "builtins, name",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "aeidon-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/aeidon-1.15.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/aeidon-1.15/aeidon-1.15/setup.py",
          "line_number": "86",
          "type_description": "code-execution",
          "context_snippet": "def run_or_exit(cmd):\n    if os.system(cmd) == 0: return\n    log.error(\"command {!r} failed\".format(cmd))\n    raise SystemExit(1)",
          "hash_value": "da83bab73a42d170375bd715435c910a",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def run_or_exit(cmd):\n    if os.system(cmd) == 0: return\n    log.error(\"command {!r} failed\".format(cmd))\n    raise SystemExit(1)",
              "triple_sequences": [
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "cmd",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "log.error()",
                  "action_description": "Logs error message",
                  "action_id": "log_error_message",
                  "object": "\"command {!r} failed\".format(cmd)",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                },
                {
                  "action_api": "SystemExit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "1",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "ipython-9",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/ipython-9.1.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "guarded_eval.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ipython-9.1.0/ipython-9.1.0/IPython/core/guarded_eval.py",
          "line_number": "721",
          "type_description": "obfuscation",
          "context_snippet": "def _eval_node_name(node_id: str, context: EvaluationContext):\n    policy = EVALUATION_POLICIES[context.evaluation]\n    if policy.allow_locals_access and node_id in context.locals:\n        return context.locals[node_id]\n    if policy.allow_globals_access and node_id in context.globals:\n        return context.globals[node_id]\n    if policy.allow_builtins_access and hasattr(builtins, node_id):\n        # note: do not use __builtins__, it is implementation detail of cPython\n        return getattr(builtins, node_id)\n    if not policy.allow_globals_access and not policy.allow_locals_access:\n        raise GuardRejection(\n            f\"Namespace access not allowed in {context.evaluation} mode\"\n        )\n    else:\n        raise NameError(f\"{node_id} not found in locals, globals, nor builtins\")",
          "hash_value": "fd356d510f80374559895c1f558534fc",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def _eval_node_name(node_id: str, context: EvaluationContext):\n    policy = EVALUATION_POLICIES[context.evaluation]\n    if policy.allow_locals_access and node_id in context.locals:\n        return context.locals[node_id]\n    if policy.allow_globals_access and node_id in context.globals:\n        return context.globals[node_id]\n    if policy.allow_builtins_access and hasattr(builtins, node_id):\n        # note: do not use __builtins__, it is implementation detail of cPython\n        return getattr(builtins, node_id)\n    if not policy.allow_globals_access and not policy.allow_locals_access:\n        raise GuardRejection(\n            f\"Namespace access not allowed in {context.evaluation} mode\"\n        )\n    else:\n        raise NameError(f\"{node_id} not found in locals, globals, nor builtins\")",
              "triple_sequences": [
                {
                  "action_api": "hasattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, node_id",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "builtins, node_id",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "raise GuardRejection",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "f\"Namespace access not allowed in {context.evaluation} mode\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                },
                {
                  "action_api": "raise NameError",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "f\"{node_id} not found in locals, globals, nor builtins\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "hqq-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/hqq-0.2.5.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/hqq-0.2.5/hqq-0.2.5/setup.py",
          "line_number": "21",
          "type_description": "code-execution",
          "context_snippet": "import os\n\ndef install_cuda_cmd() -> str:\n    cmd = \"cd hqq/kernels; \"\n    cmd += \"python setup_cuda.py install; \"\n    cmd += \"cd ../..;\"\n    return cmd\n\ndef run_setup_cuda():\n    print(\"Running setup_cuda.py...\")\n    try:\n        os.system(install_cuda_cmd())\n    except Exception as e:\n        print(\"Error while running setup_cuda.py:\", e)",
          "hash_value": "b311d4b6d9c2a29d0a88f95bdd4bd1fe",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\n\ndef install_cuda_cmd() -> str:\n    cmd = \"cd hqq/kernels; \"\n    cmd += \"python setup_cuda.py install; \"\n    cmd += \"cd ../..;\"\n    return cmd\n\ndef run_setup_cuda():\n    print(\"Running setup_cuda.py...\")\n    try:\n        os.system(install_cuda_cmd())\n    except Exception as e:\n        print(\"Error while running setup_cuda.py:\", e)",
              "triple_sequences": [
                {
                  "action_api": "install_cuda_cmd()",
                  "action_description": "Constructs file or directory path",
                  "action_id": "path_string_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Construct Python code string",
                  "intention_id": "construct_python_code"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "cd hqq/kernels; python setup_cuda.py install; cd ../..;",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "flask_cloudflared-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/flask_cloudflared-0.0.14.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "flask_cloudflared.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/flask_cloudflared-0.0.14/flask_cloudflared-0.0.14/flask_cloudflared.py",
          "line_number": "132",
          "type_description": "shady-links",
          "context_snippet": "import atexit\nimport requests\nimport subprocess\nimport tarfile\nimport tempfile\nimport shutil\nimport os\nimport platform\nimport time\nimport re\nfrom random import randint\nfrom threading import Timer\nfrom pathlib import Path\n\n# ... (CLOUDFLARED_CONFIG and helper functions omitted for brevity)\n\ndef _run_cloudflared(port, metrics_port, tunnel_id=None, config_path=None):\n    system, machine = platform.system(), platform.machine()\n    command = _get_command(system, machine)\n    cloudflared_path = str(Path(tempfile.gettempdir()))\n    if system == \"Darwin\":\n        _download_cloudflared(cloudflared_path, \"cloudflared-darwin-amd64.tgz\")\n        _extract_tarball(cloudflared_path, \"cloudflared-darwin-amd64.tgz\")\n    else:\n        _download_cloudflared(cloudflared_path, command)\n\n    executable = str(Path(cloudflared_path, command))\n    os.chmod(executable, 0o777)\n\n    cloudflared_command = [executable, 'tunnel', '--metrics', f'127.0.0.1:{metrics_port}']\n    if config_path:\n        cloudflared_command += ['--config', config_path, 'run']\n    elif tunnel_id:\n        cloudflared_command += ['--url', f'http://127.0.0.1:{port}', 'run', tunnel_id]\n    else:\n        cloudflared_command += ['--url', f'http://127.0.0.1:{port}']\n\n    if system == \"Darwin\" and machine == \"arm64\":\n        cloudflared = subprocess.Popen(['arch', '-x86_64'] + cloudflared_command, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n    else:\n        cloudflared = subprocess.Popen(cloudflared_command, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n\n    atexit.register(cloudflared.terminate)\n    localhost_url = f\"http://127.0.0.1:{metrics_port}/metrics\"\n\n    for _ in range(10):\n        try:\n            metrics = requests.get(localhost_url).text\n            if tunnel_id or config_path:\n                # If tunnel_id or config_path is provided, we check for cloudflared_tunnel_ha_connections, as no tunnel URL is available in the metrics\n                if re.search(\"cloudflared_tunnel_ha_connections\\s\\d\", metrics):\n                    # No tunnel URL is available in the metrics, so we return a generic text\n                    tunnel_url = \"preconfigured tunnel URL\"\n                    break\n            else:\n                # If neither tunnel_id nor config_path is provided, we check for the tunnel URL in the metrics\n                tunnel_url = (re.search(\"(?P<url>https?:\\/\\/[\\^\\s]+.trycloudflare.com)\", metrics).group(\"url\"))\n                break\n        except:\n            time.sleep(3)\n    else:\n        raise Exception(f\"! Can't connect to Cloudflare Edge\")\n\n    return tunnel_url",
          "hash_value": "af28a6bbe878e8756cd95250ab797bbd",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import atexit\nimport requests\nimport subprocess\nimport tarfile\nimport tempfile\nimport shutil\nimport os\nimport platform\nimport time\nimport re\nfrom random import randint\nfrom threading import Timer\nfrom pathlib import Path\n\n# ... (CLOUDFLARED_CONFIG and helper functions omitted for brevity)\n\ndef _run_cloudflared(port, metrics_port, tunnel_id=None, config_path=None):\n    system, machine = platform.system(), platform.machine()\n    command = _get_command(system, machine)\n    cloudflared_path = str(Path(tempfile.gettempdir()))\n    if system == \"Darwin\":\n        _download_cloudflared(cloudflared_path, \"cloudflared-darwin-amd64.tgz\")\n        _extract_tarball(cloudflared_path, \"cloudflared-darwin-amd64.tgz\")\n    else:\n        _download_cloudflared(cloudflared_path, command)\n\n    executable = str(Path(cloudflared_path, command))\n    os.chmod(executable, 0o777)\n\n    cloudflared_command = [executable, 'tunnel', '--metrics', f'127.0.0.1:{metrics_port}']\n    if config_path:\n        cloudflared_command += ['--config', config_path, 'run']\n    elif tunnel_id:\n        cloudflared_command += ['--url', f'http://127.0.0.1:{port}', 'run', tunnel_id]\n    else:\n        cloudflared_command += ['--url', f'http://127.0.0.1:{port}']\n\n    if system == \"Darwin\" and machine == \"arm64\":\n        cloudflared = subprocess.Popen(['arch', '-x86_64'] + cloudflared_command, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n    else:\n        cloudflared = subprocess.Popen(cloudflared_command, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n\n    atexit.register(cloudflared.terminate)\n    localhost_url = f\"http://127.0.0.1:{metrics_port}/metrics\"\n\n    for _ in range(10):\n        try:\n            metrics = requests.get(localhost_url).text\n            if tunnel_id or config_path:\n                # If tunnel_id or config_path is provided, we check for cloudflared_tunnel_ha_connections, as no tunnel URL is available in the metrics\n                if re.search(\"cloudflared_tunnel_ha_connections\\s\\d\", metrics):\n                    # No tunnel URL is available in the metrics, so we return a generic text\n                    tunnel_url = \"preconfigured tunnel URL\"\n                    break\n            else:\n                # If neither tunnel_id nor config_path is provided, we check for the tunnel URL in the metrics\n                tunnel_url = (re.search(\"(?P<url>https?:\\/\\/[\\^\\s]+.trycloudflare.com)\", metrics).group(\"url\"))\n                break\n        except:\n            time.sleep(3)\n    else:\n        raise Exception(f\"! Can't connect to Cloudflare Edge\")\n\n    return tunnel_url",
              "triple_sequences": [
                {
                  "action_api": "platform.system()",
                  "action_description": "Retrieves operating system identifier",
                  "action_id": "get_os_id",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine operating system",
                  "intention_id": "determine_operating_system"
                },
                {
                  "action_api": "platform.machine()",
                  "action_description": "Retrieves machine type",
                  "action_id": "get_machine_type",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Gather system information",
                  "intention_id": "gather_system_information"
                },
                {
                  "action_api": "tempfile.gettempdir()",
                  "action_description": "Creates temporary directory and returns its path",
                  "action_id": "create_temp_dir",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect temporary directory path",
                  "intention_id": "collect_temp_directory_path"
                },
                {
                  "action_api": "Path()",
                  "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
                  "action_id": "path_object_operations",
                  "object": "tempfile.gettempdir()",
                  "object_description": "Temporary directory",
                  "object_id": "temporary_directory",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "os.chmod()",
                  "action_description": "Changes file mode to add execute permission",
                  "action_id": "change_file_mode_execute",
                  "object": "executable",
                  "object_description": "Executable file",
                  "object_id": "executable_file",
                  "intention_description": "Modify file attributes",
                  "intention_id": "modify_file_attributes"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command with shell access",
                  "action_id": "spawn_process_shell",
                  "object": "cloudflared_command",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Create child process",
                  "intention_id": "create_child_process"
                },
                {
                  "action_api": "atexit.register()",
                  "action_description": "Registers function to be called at program exit",
                  "action_id": "register_exit_function",
                  "object": "cloudflared.terminate",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Release system resource",
                  "intention_id": "release_system_resource"
                },
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP GET request to URL",
                  "action_id": "open_url_get",
                  "object": "http://127.0.0.1:{metrics_port}/metrics",
                  "object_description": "Localhost address",
                  "object_id": "localhost_address",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "re.search()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "\"cloudflared_tunnel_ha_connections\\s\\d\", metrics",
                  "object_description": "Regular expression and file content",
                  "object_id": "regex_file_content",
                  "intention_description": "Detect shortcut files",
                  "intention_id": "detect_shortcut_files"
                },
                {
                  "action_api": "re.search()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "\"(?P<url>https?:\\/\\/[\\^\\s]+.trycloudflare.com)\", metrics",
                  "object_description": "Regular expression and file content",
                  "object_id": "regex_file_content",
                  "intention_description": "Extract structured data from file",
                  "intention_id": "extract_structured_file_data"
                },
                {
                  "action_api": "time.sleep()",
                  "action_description": "Suspends execution",
                  "action_id": "suspend_execution",
                  "object": "3",
                  "object_description": "Delay duration in seconds",
                  "object_id": "delay_duration",
                  "intention_description": "Delay next operation",
                  "intention_id": "delay_next_operation"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pandera-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pandera-0.23.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "numpy_engine.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pandera-0.23.1/pandera-0.23.1/pandera/engines/numpy_engine.py",
          "line_number": "127",
          "type_description": "obfuscation",
          "context_snippet": "def _build_number_equivalents(\n    builtin_name: str, pandera_name: str, sizes: List[int]\n) -> Dict[int, List[Union[type, str, np.dtype, dtypes.DataType]]]:\n    \"\"\"Return a dict of equivalent builtin, numpy, pandera dtypes\n    indexed by size in bit_width.\"\"\"\n    builtin_type = getattr(builtins, builtin_name, None)\n    default_np_dtype = np.dtype(builtin_name)\n    default_size = int(default_np_dtype.name.replace(builtin_name, \"\"))\n\n    default_equivalents = [\n        # e.g.: np.int64\n        np.dtype(builtin_name).type,\n        # e.g: pandera.dtypes.Int\n        getattr(dtypes, pandera_name),\n    ]\n    if builtin_type:\n        default_equivalents.append(builtin_type)\n\n    return {\n        bit_width: list(\n            {\n                # e.g.: numpy.int64\n                getattr(np, f\"{builtin_name}{bit_width}\"),\n                # e.g.: pandera.dtypes.Int64\n                getattr(dtypes, f\"{pandera_name}{bit_width}\"),\n                getattr(dtypes, f\"{pandera_name}{bit_width}\")(),\n                # e.g.: pandera.dtypes.Int(64)\n                getattr(dtypes, pandera_name)(),\n            }\n            | set(default_equivalents if bit_width == default_size else [])\n        )\n        for bit_width in sizes\n    }",
          "hash_value": "a3e83eb9c6f0e9c76859b8a13b111496",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def _build_number_equivalents(\n    builtin_name: str, pandera_name: str, sizes: List[int]\n) -> Dict[int, List[Union[type, str, np.dtype, dtypes.DataType]]]:\n    \"\"\"Return a dict of equivalent builtin, numpy, pandera dtypes\n    indexed by size in bit_width.\"\"\"\n    builtin_type = getattr(builtins, builtin_name, None)\n    default_np_dtype = np.dtype(builtin_name)\n    default_size = int(default_np_dtype.name.replace(builtin_name, \"\"))\n\n    default_equivalents = [\n        # e.g.: np.int64\n        np.dtype(builtin_name).type,\n        # e.g: pandera.dtypes.Int\n        getattr(dtypes, pandera_name),\n    ]\n    if builtin_type:\n        default_equivalents.append(builtin_type)\n\n    return {\n        bit_width: list(\n            {\n                # e.g.: numpy.int64\n                getattr(np, f\"{builtin_name}{bit_width}\"),\n                # e.g.: pandera.dtypes.Int64\n                getattr(dtypes, f\"{pandera_name}{bit_width}\"),\n                getattr(dtypes, f\"{pandera_name}{bit_width}\")(),\n                # e.g.: pandera.dtypes.Int(64)\n                getattr(dtypes, pandera_name)(),\n            }\n            | set(default_equivalents if bit_width == default_size else [])\n        )\n        for bit_width in sizes\n    }",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "builtins, builtin_name, None",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "np.dtype()",
                  "action_description": "Creates bytes object from encoded string",
                  "action_id": "create_bytes_encoded",
                  "object": "builtin_name",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "str.replace()",
                  "action_description": "Converts bytes to string using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "default_np_dtype.name.replace(builtin_name, \"\")",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "int()",
                  "action_description": "Converts integer to Unicode character",
                  "action_id": "convert_int_to_char",
                  "object": "default_np_dtype.name.replace(builtin_name, \"\")",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Convert string to integer",
                  "intention_id": "convert_string_to_integer"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "dtypes, pandera_name",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "np.dtype().type",
                  "action_description": "Creates bytes object from encoded string",
                  "action_id": "create_bytes_encoded",
                  "object": "builtin_name",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "np, f\"{builtin_name}{bit_width}\"",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "dtypes, f\"{pandera_name}{bit_width}\"",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "dtypes, f\"{pandera_name}{bit_width}\"",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "dtypes, pandera_name",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "labmaze-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/labmaze-1.0.6.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/labmaze-1.0.6/labmaze-1.0.6/setup.py",
          "line_number": "94",
          "type_description": "code-execution",
          "context_snippet": "class BuildBazelExtension(build_ext.build_ext):\n  \"\"\"A command that runs Bazel to build a C/C++ extension.\"\"\"\n\n  def run(self):\n    for ext in self.extensions:\n      self.bazel_build(ext)\n    build_ext.build_ext.run(self)\n\n  def bazel_build(self, ext):\n    with open('WORKSPACE', 'r') as f:\n      workspace_contents = f.read()\n\n    with open('WORKSPACE', 'w') as f:\n      f.write(WORKSPACE_PYTHON_HEADERS_PATTERN.sub(\n          distutils.sysconfig.get_python_inc().replace(os.path.sep,\n                                                       posixpath.sep),\n          workspace_contents))\n\n    if not os.path.exists(self.build_temp):\n      os.makedirs(self.build_temp)\n\n    bazel_argv = [\n        'bazel',\n        'build',\n        ext.bazel_target,\n        '--symlink_prefix=' + os.path.join(self.build_temp, 'bazel-'),\n        '--compilation_mode=' + ('dbg' if self.debug else 'opt'),\n    ]\n\n    if IS_WINDOWS:\n      for library_dir in self.library_dirs:\n        bazel_argv.append('--linkopt=/LIBPATH:' + library_dir)\n      # TODO(stunya): Figure out why we need this.\n      if sysconfig.get_python_version() == '3.7':\n        bazel_argv.append('--linkopt=/LIBPATH:C:\\\\Python37\\\\Libs')\n\n    self.spawn(bazel_argv)\n\n    shared_lib_suffix = '.dll' if IS_WINDOWS else '.so'\n\n    ext_bazel_bin_path = os.path.join(\n        self.build_temp, 'bazel-bin',\n        ext.relpath, ext.target_name + shared_lib_suffix)\n    ext_dest_path = self.get_ext_fullpath(ext.name)\n    ext_dest_dir = os.path.dirname(ext_dest_path)\n    if not os.path.exists(ext_dest_dir):\n      os.makedirs(ext_dest_dir)\n    shutil.copyfile(ext_bazel_bin_path, ext_dest_path)",
          "hash_value": "a0835c53a9b2f93953f85e0b2967f510",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class BuildBazelExtension(build_ext.build_ext):\n  \"\"\"A command that runs Bazel to build a C/C++ extension.\"\"\"\n\n  def run(self):\n    for ext in self.extensions:\n      self.bazel_build(ext)\n    build_ext.build_ext.run(self)\n\n  def bazel_build(self, ext):\n    with open('WORKSPACE', 'r') as f:\n      workspace_contents = f.read()\n\n    with open('WORKSPACE', 'w') as f:\n      f.write(WORKSPACE_PYTHON_HEADERS_PATTERN.sub(\n          distutils.sysconfig.get_python_inc().replace(os.path.sep,\n                                                       posixpath.sep),\n          workspace_contents))\n\n    if not os.path.exists(self.build_temp):\n      os.makedirs(self.build_temp)\n\n    bazel_argv = [\n        'bazel',\n        'build',\n        ext.bazel_target,\n        '--symlink_prefix=' + os.path.join(self.build_temp, 'bazel-'),\n        '--compilation_mode=' + ('dbg' if self.debug else 'opt'),\n    ]\n\n    if IS_WINDOWS:\n      for library_dir in self.library_dirs:\n        bazel_argv.append('--linkopt=/LIBPATH:' + library_dir)\n      # TODO(stunya): Figure out why we need this.\n      if sysconfig.get_python_version() == '3.7':\n        bazel_argv.append('--linkopt=/LIBPATH:C:\\\\Python37\\\\Libs')\n\n    self.spawn(bazel_argv)\n\n    shared_lib_suffix = '.dll' if IS_WINDOWS else '.so'\n\n    ext_bazel_bin_path = os.path.join(\n        self.build_temp, 'bazel-bin',\n        ext.relpath, ext.target_name + shared_lib_suffix)\n    ext_dest_path = self.get_ext_fullpath(ext.name)\n    ext_dest_dir = os.path.dirname(ext_dest_path)\n    if not os.path.exists(ext_dest_dir):\n      os.makedirs(ext_dest_dir)\n    shutil.copyfile(ext_bazel_bin_path, ext_dest_path)",
              "triple_sequences": [
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "'WORKSPACE'",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for writing (normal writing, binary writing)",
                  "action_id": "basic_write_operations",
                  "object": "'WORKSPACE'",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                },
                {
                  "action_api": "file.write()",
                  "action_description": "File opening operations for writing (normal writing, binary writing)",
                  "action_id": "basic_write_operations",
                  "object": "WORKSPACE_PYTHON_HEADERS_PATTERN.sub(distutils.sysconfig.get_python_inc().replace(os.path.sep, posixpath.sep), workspace_contents)",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "self.build_temp",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "os.makedirs()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "self.build_temp",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "self.build_temp, 'bazel-'",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "self.build_temp, 'bazel-bin', ext.relpath, ext.target_name + shared_lib_suffix",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "self.get_ext_fullpath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "ext.name",
                  "object_description": "Local file or directory name",
                  "object_id": "local_file_or_directory_name",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "ext_dest_path",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "ext_dest_dir",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "os.makedirs()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "ext_dest_dir",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "shutil.copyfile()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "ext_bazel_bin_path, ext_dest_path",
                  "object_description": "Local file",
                  "object_id": "local_file",
                  "intention_description": "Move file to destination",
                  "intention_id": "move_file_destination"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "rpyc-6",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/rpyc-6.0.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "vinegar.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/rpyc-6.0.1/rpyc-6.0.1/rpyc/core/vinegar.py",
          "line_number": "126",
          "type_description": "obfuscation",
          "context_snippet": "def load(val, import_custom_exceptions, instantiate_custom_exceptions, instantiate_oldstyle_exceptions):\n    \"\"\"\n    Loads a dumped exception (the tuple returned by :func:`dump`) info a\n    throwable exception object. If the exception cannot be instantiated for any\n    reason (i.e., the security parameters do not allow it, or the exception\n    class simply doesn't exist on the local machine), a :class:`GenericException`\n    instance will be returned instead, containing all of the original exception's\n    details.\n\n    :param val: the dumped exception\n    :param import_custom_exceptions: whether to allow this function to import custom modules\n                                     (imposes a security risk)\n    :param instantiate_custom_exceptions: whether to allow this function to instantiate \"custom\n                                          exceptions\" (i.e., not one of the built-in exceptions,\n                                          such as ``ValueError``, ``OSError``, etc.)\n    :param instantiate_oldstyle_exceptions: whether to allow this function to instantiate exception\n                                            classes that do not derive from ``BaseException``.\n                                            This is required to support old-style exceptions.\n                                            Not applicable for Python 3 and above.\n\n    :returns: A throwable exception object\n    \"\"\"\n    if val == consts.EXC_STOP_ITERATION:\n        return StopIteration  # optimization\n    if type(val) is str:\n        return val  # deprecated string exceptions\n\n    (modname, clsname), args, attrs, tbtext = val\n\n    if import_custom_exceptions and modname not in sys.modules:\n        try:\n            __import__(modname, None, None, \"*\")\n        except Exception:\n            pass\n\n    if instantiate_custom_exceptions:\n        if modname in sys.modules:\n            cls = getattr(sys.modules[modname], clsname, None)\n        else:\n            cls = None\n    elif modname == exceptions_module.__name__:\n        cls = getattr(exceptions_module, clsname, None)\n    else:\n        cls = None\n\n    if not isinstance(cls, type) or not issubclass(cls, BaseException):\n        cls = None\n\n    if cls is None:\n        fullname = f\"{modname}.{clsname}\"\n        # py2: `type()` expects `str` not `unicode`!\n        fullname = str(fullname)\n        if fullname not in _generic_exceptions_cache:\n            fakemodule = {\"__module__\": f\"{__name__}/{modname}\"}\n            if isinstance(GenericException, ClassType):\n                _generic_exceptions_cache[fullname] = ClassType(fullname, (GenericException,), fakemodule)\n            else:\n                _generic_exceptions_cache[fullname] = type(fullname, (GenericException,), fakemodule)\n        cls = _generic_exceptions_cache[fullname]\n\n    cls = _get_exception_class(cls)\n\n    # support old-style exception classes\n    if ClassType is not type and isinstance(cls, ClassType):\n        exc = InstanceType(cls)\n    else:\n        exc = cls.__new__(cls)\n\n    exc.args = args\n    for name, attrval in attrs:\n        try:\n            setattr(exc, name, attrval)\n        except AttributeError:      # handle immutable attrs (@property)\n            pass\n\n    # When possible and relevant, warn the user about mismatch in major versions between remote and local\n    remote_ver = getattr(exc, \"_remote_version\", \"<version denied>\")\n    if remote_ver != \"<version denied>\" and remote_ver.split('.')[0] != str(version.version[0]):\n        _warn = '\\nWARNING: Remote is on RPyC {} and local is on RPyC {}.\\n\\n'\n        tbtext += _warn.format(remote_ver, version.__version__)\n\n    exc._remote_tb = tbtext\n    return exc\n\n# Data dependencies:\n# - exceptions_module: imported at top of file (either 'exceptions' or 'builtins')\n# - clsname: unpacked from val, which is a tuple argument to load()\n# - cls: local variable, set by getattr(exceptions_module, clsname, None)\n# - The function uses sys, version, _generic_exceptions_cache, ClassType, GenericException, _get_exception_class, InstanceType, etc., all defined or imported in the file.",
          "hash_value": "85d5dc02c332aec97f84d76f693b20cd",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def load(val, import_custom_exceptions, instantiate_custom_exceptions, instantiate_oldstyle_exceptions):\n    \"\"\"\n    Loads a dumped exception (the tuple returned by :func:`dump`) info a\n    throwable exception object. If the exception cannot be instantiated for any\n    reason (i.e., the security parameters do not allow it, or the exception\n    class simply doesn't exist on the local machine), a :class:`GenericException`\n    instance will be returned instead, containing all of the original exception's\n    details.\n\n    :param val: the dumped exception\n    :param import_custom_exceptions: whether to allow this function to import custom modules\n                                     (imposes a security risk)\n    :param instantiate_custom_exceptions: whether to allow this function to instantiate \"custom\n                                          exceptions\" (i.e., not one of the built-in exceptions,\n                                          such as ``ValueError``, ``OSError``, etc.)\n    :param instantiate_oldstyle_exceptions: whether to allow this function to instantiate exception\n                                            classes that do not derive from ``BaseException``.\n                                            This is required to support old-style exceptions.\n                                            Not applicable for Python 3 and above.\n\n    :returns: A throwable exception object\n    \"\"\"\n    if val == consts.EXC_STOP_ITERATION:\n        return StopIteration  # optimization\n    if type(val) is str:\n        return val  # deprecated string exceptions\n\n    (modname, clsname), args, attrs, tbtext = val\n\n    if import_custom_exceptions and modname not in sys.modules:\n        try:\n            __import__(modname, None, None, \"*\")\n        except Exception:\n            pass\n\n    if instantiate_custom_exceptions:\n        if modname in sys.modules:\n            cls = getattr(sys.modules[modname], clsname, None)\n        else:\n            cls = None\n    elif modname == exceptions_module.__name__:\n        cls = getattr(exceptions_module, clsname, None)\n    else:\n        cls = None\n\n    if not isinstance(cls, type) or not issubclass(cls, BaseException):\n        cls = None\n\n    if cls is None:\n        fullname = f\"{modname}.{clsname}\"\n        # py2: `type()` expects `str` not `unicode`!\n        fullname = str(fullname)\n        if fullname not in _generic_exceptions_cache:\n            fakemodule = {\"__module__\": f\"{__name__}/{modname}\"}\n            if isinstance(GenericException, ClassType):\n                _generic_exceptions_cache[fullname] = ClassType(fullname, (GenericException,), fakemodule)\n            else:\n                _generic_exceptions_cache[fullname] = type(fullname, (GenericException,), fakemodule)\n        cls = _generic_exceptions_cache[fullname]\n\n    cls = _get_exception_class(cls)\n\n    # support old-style exception classes\n    if ClassType is not type and isinstance(cls, ClassType):\n        exc = InstanceType(cls)\n    else:\n        exc = cls.__new__(cls)\n\n    exc.args = args\n    for name, attrval in attrs:\n        try:\n            setattr(exc, name, attrval)\n        except AttributeError:      # handle immutable attrs (@property)\n            pass\n\n    # When possible and relevant, warn the user about mismatch in major versions between remote and local\n    remote_ver = getattr(exc, \"_remote_version\", \"<version denied>\")\n    if remote_ver != \"<version denied>\" and remote_ver.split('.')[0] != str(version.version[0]):\n        _warn = '\\nWARNING: Remote is on RPyC {} and local is on RPyC {}.\\n\\n'\n        tbtext += _warn.format(remote_ver, version.__version__)\n\n    exc._remote_tb = tbtext\n    return exc\n\n# Data dependencies:\n# - exceptions_module: imported at top of file (either 'exceptions' or 'builtins')\n# - clsname: unpacked from val, which is a tuple argument to load()\n# - cls: local variable, set by getattr(exceptions_module, clsname, None)\n# - The function uses sys, version, _generic_exceptions_cache, ClassType, GenericException, _get_exception_class, InstanceType, etc., all defined or imported in the file.",
              "triple_sequences": [
                {
                  "action_api": "__import__()",
                  "action_description": "Dynamically imports specified module",
                  "action_id": "import_dynamic",
                  "object": "modname, None, None, \"*\"",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "sys.modules[modname], clsname, None",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "exceptions_module, clsname, None",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "cls, type",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "issubclass()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "cls, BaseException",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "str()",
                  "action_description": "Converts bytes to string using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "fullname",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "GenericException, ClassType",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "type()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "fullname, (GenericException,), fakemodule",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "_get_exception_class()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "cls",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "cls, ClassType",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "InstanceType()",
                  "action_description": "Instantiates class or object",
                  "action_id": "init_setup_class",
                  "object": "cls",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "cls.__new__()",
                  "action_description": "Instantiates class or object",
                  "action_id": "init_setup_class",
                  "object": "cls",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "setattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "exc, name, attrval",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "exc, \"_remote_version\", \"<version denied>\"",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "remote_ver, '.'",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "truss-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/truss-0.60.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "utils.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/truss-0.60.0/truss-0.60.0/truss-chains/truss_chains/remote_chainlet/utils.py",
          "line_number": "214",
          "type_description": "obfuscation",
          "context_snippet": "def _resolve_exception_class(error: definitions.RemoteErrorDetail) -> Type[Exception]:\n    \"\"\"Tries to find the exception class in builtins or imported libs,\n    falls back to `definitions.GenericRemoteError` if not found.\"\"\"\n    exception_cls = None\n    if error.exception_module_name is None:\n        exception_cls = getattr(builtins, error.exception_cls_name, None)\n    else:\n        if mod := sys.modules.get(error.exception_module_name):\n            exception_cls = getattr(mod, error.exception_cls_name, None)\n\n    if exception_cls is None:\n        logging.warning(\n            f\"Could not resolve exception with name `{error.exception_cls_name}` \"\n            f\"and module `{error.exception_module_name}` - fall back to \"\n            f\"`{definitions.GenericRemoteException.__name__}`.\"\n        )\n        exception_cls = definitions.GenericRemoteException\n\n    if issubclass(exception_cls, pydantic.ValidationError):\n        # Cannot re-raise naively.\n        # https://github.com/pydantic/pydantic/issues/6734.\n        exception_cls = definitions.GenericRemoteException\n\n    return exception_cls",
          "hash_value": "2a026395dbb83397eca93433e1f48430",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def _resolve_exception_class(error: definitions.RemoteErrorDetail) -> Type[Exception]:\n    \"\"\"Tries to find the exception class in builtins or imported libs,\n    falls back to `definitions.GenericRemoteError` if not found.\"\"\"\n    exception_cls = None\n    if error.exception_module_name is None:\n        exception_cls = getattr(builtins, error.exception_cls_name, None)\n    else:\n        if mod := sys.modules.get(error.exception_module_name):\n            exception_cls = getattr(mod, error.exception_cls_name, None)\n\n    if exception_cls is None:\n        logging.warning(\n            f\"Could not resolve exception with name `{error.exception_cls_name}` \"\n            f\"and module `{error.exception_module_name}` - fall back to \"\n            f\"`{definitions.GenericRemoteException.__name__}`.\"\n        )\n        exception_cls = definitions.GenericRemoteException\n\n    if issubclass(exception_cls, pydantic.ValidationError):\n        # Cannot re-raise naively.\n        # https://github.com/pydantic/pydantic/issues/6734.\n        exception_cls = definitions.GenericRemoteException\n\n    return exception_cls",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, error.exception_cls_name, None",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Import required module",
                  "intention_id": "import_required_module"
                },
                {
                  "action_api": "sys.modules.get()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "error.exception_module_name",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import required module",
                  "intention_id": "import_required_module"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "mod, error.exception_cls_name, None",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import required module",
                  "intention_id": "import_required_module"
                },
                {
                  "action_api": "logging.warning()",
                  "action_description": "Sends message to Discord channel via webhook",
                  "action_id": "send_discord_webhook",
                  "object": "f\"Could not resolve exception with name `{error.exception_cls_name}` \" f\"and module `{error.exception_module_name}` - fall back to \" f\"`{definitions.GenericRemoteException.__name__}`.\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "issubclass()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "exception_cls, pydantic.ValidationError",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Import required module",
                  "intention_id": "import_required_module"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "memray-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/memray-1.17.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/memray-1.17.0/memray-1.17.0/setup.py",
          "line_number": "49",
          "type_description": "code-execution",
          "context_snippet": "import distutils.log\nimport subprocess\n\nclass BuildMemray(build_ext_orig):\n    def announce_and_run(self, command, **kwargs):\n        self.announce(\n            \"executing command: `{}`\".format(\" \".join(command)),\n            level=distutils.log.INFO,\n        )\n        subprocess.run(command, check=True, **kwargs)",
          "hash_value": "8da082d0048f3ad9a8f1d2f91530f613",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import distutils.log\nimport subprocess\n\nclass BuildMemray(build_ext_orig):\n    def announce_and_run(self, command, **kwargs):\n        self.announce(\n            \"executing command: `{}`\".format(\" \".join(command)),\n            level=distutils.log.INFO,\n        )\n        subprocess.run(command, check=True, **kwargs)",
              "triple_sequences": [
                {
                  "action_api": "self.announce()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "\"executing command: `{}`\".format(\" \".join(command))",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "command",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "cbor-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/cbor-1.0.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cbor-1.0.0/cbor-1.0.0/setup.py",
          "line_number": "59",
          "type_description": "code-execution",
          "context_snippet": "from distutils.command.build_ext import build_ext\nfrom distutils.errors import (CCompilerError, DistutilsExecError,\n    DistutilsPlatformError)\nimport sys\n\nfrom setuptools import setup, Extension\n\n\nbuild_errors = (CCompilerError, DistutilsExecError, DistutilsPlatformError)\nif sys.platform == 'win32' and sys.version_info > (2, 6):\n    # 2.6's distutils.msvc9compiler can raise an IOError when failing to\n    # find the compiler\n    build_errors += (IOError,)\n\n\nclass BuildError(Exception):\n    \"\"\"Raised if compiling extensions failed.\"\"\"\n\n\nclass optional_build_ext(build_ext):\n    \"\"\"build_ext implementation with optional C speedups.\"\"\"\n\n    def run(self):\n        try:\n            build_ext.run(self)\n        except DistutilsPlatformError:\n            raise BuildError()\n\n    def build_extension(self, ext):\n        try:\n            build_ext.build_extension(self, ext)\n        except build_errors as be:\n            raise BuildError(be)\n        except ValueError as ve:\n            # this can happen on Windows 64 bit, see Python issue 7511\n            if \"'path'\" in str(sys.exc_info()[1]): # works with Python 2 and 3\n                raise BuildError(ve)\n            raise\n\n\nVERSION = eval(open('cbor/VERSION.py','rb').read())\n\n\nsetup_options = dict(\n    name='cbor',\n    version=VERSION,\n    description='RFC 7049 - Concise Binary Object Representation',\n    long_description=\"\"\"\nAn implementation of RFC 7049 - Concise Binary Object Representation (CBOR).\n\nCBOR is comparable to JSON, has a superset of JSON's ability, but serializes to a binary format which is smaller and faster to generate and parse.\n\nThe two primary functions are cbor.loads() and cbor.dumps().\n\nThis library includes a C implementation which runs 3-5 times faster than the Python standard library's C-accelerated implementanion of JSON. This is also includes a 100% Python implementation.\n\"\"\",\n    author='Brian Olson',\n    author_email='bolson@bolson.org',\n    url='https://bitbucket.org/bodhisnarkva/cbor',\n    packages=['cbor'],\n    package_dir={'cbor':'cbor'},\n    ext_modules=[\n        Extension(\n            'cbor._cbor',\n            include_dirs=['c/'],\n            sources=['c/cbormodule.c'],\n            headers=['c/cbor.h'],\n        )\n    ],\n    license='Apache',\n    classifiers=[\n\t'Development Status :: 5 - Production/Stable',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: Apache Software License',\n        'Operating System :: OS Independent',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: C',\n        'Topic :: Software Development :: Libraries :: Python Modules',\n    ],\n    cmdclass={'build_ext': optional_build_ext},\n)\n",
          "hash_value": "125a93fdc9b5847d3fa649874721234e",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from distutils.command.build_ext import build_ext\nfrom distutils.errors import (CCompilerError, DistutilsExecError,\n    DistutilsPlatformError)\nimport sys\n\nfrom setuptools import setup, Extension\n\n\nbuild_errors = (CCompilerError, DistutilsExecError, DistutilsPlatformError)\nif sys.platform == 'win32' and sys.version_info > (2, 6):\n    # 2.6's distutils.msvc9compiler can raise an IOError when failing to\n    # find the compiler\n    build_errors += (IOError,)\n\n\nclass BuildError(Exception):\n    \"\"\"Raised if compiling extensions failed.\"\"\"\n\n\nclass optional_build_ext(build_ext):\n    \"\"\"build_ext implementation with optional C speedups.\"\"\"\n\n    def run(self):\n        try:\n            build_ext.run(self)\n        except DistutilsPlatformError:\n            raise BuildError()\n\n    def build_extension(self, ext):\n        try:\n            build_ext.build_extension(self, ext)\n        except build_errors as be:\n            raise BuildError(be)\n        except ValueError as ve:\n            # this can happen on Windows 64 bit, see Python issue 7511\n            if \"'path'\" in str(sys.exc_info()[1]): # works with Python 2 and 3\n                raise BuildError(ve)\n            raise\n\n\nVERSION = eval(open('cbor/VERSION.py','rb').read())\n\n\nsetup_options = dict(\n    name='cbor',\n    version=VERSION,\n    description='RFC 7049 - Concise Binary Object Representation',\n    long_description=\"\"\"\nAn implementation of RFC 7049 - Concise Binary Object Representation (CBOR).\n\nCBOR is comparable to JSON, has a superset of JSON's ability, but serializes to a binary format which is smaller and faster to generate and parse.\n\nThe two primary functions are cbor.loads() and cbor.dumps().\n\nThis library includes a C implementation which runs 3-5 times faster than the Python standard library's C-accelerated implementanion of JSON. This is also includes a 100% Python implementation.\n\"\"\",\n    author='Brian Olson',\n    author_email='bolson@bolson.org',\n    url='https://bitbucket.org/bodhisnarkva/cbor',\n    packages=['cbor'],\n    package_dir={'cbor':'cbor'},\n    ext_modules=[\n        Extension(\n            'cbor._cbor',\n            include_dirs=['c/'],\n            sources=['c/cbormodule.c'],\n            headers=['c/cbor.h'],\n        )\n    ],\n    license='Apache',\n    classifiers=[\n\t'Development Status :: 5 - Production/Stable',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: Apache Software License',\n        'Operating System :: OS Independent',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: C',\n        'Topic :: Software Development :: Libraries :: Python Modules',\n    ],\n    cmdclass={'build_ext': optional_build_ext},\n)\n",
              "triple_sequences": [
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "'cbor/VERSION.py','rb'",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "eval()",
                  "action_description": "Evaluates string as Python expression",
                  "action_id": "eval_python_expr",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Evaluate constructed code",
                  "intention_id": "evaluate_constructed_code"
                },
                {
                  "action_api": "setuptools.setup()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "setup_options",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "correctionlib-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/correctionlib-2.6.4.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/correctionlib-2.6.4/correctionlib-2.6.4/pybind11/setup.py",
          "line_number": "139",
          "type_description": "code-execution",
          "context_snippet": "with remove_output(\"pybind11/include\", \"pybind11/share\"):\n    # Generate the files if they are not present.\n    with TemporaryDirectory() as tmpdir:\n        cmd = [\"cmake\", \"-S\", \".\", \"-B\", tmpdir] + [\n            \"-DCMAKE_INSTALL_PREFIX=pybind11\",\n            \"-DBUILD_TESTING=OFF\",\n            \"-DPYBIND11_NOPYTHON=ON\",\n            \"-Dprefix_for_pc_file=${pcfiledir}/../../\",\n        ]\n        if \"CMAKE_ARGS\" in os.environ:\n            fcommand = [\n                c\n                for c in os.environ[\"CMAKE_ARGS\"].split()\n                if \"DCMAKE_INSTALL_PREFIX\" not in c\n            ]\n            cmd += fcommand\n        subprocess.run(cmd, check=True, cwd=DIR, stdout=sys.stdout, stderr=sys.stderr)\n        subprocess.run(\n            [\"cmake\", \"--install\", tmpdir],\n            check=True,\n            cwd=DIR,\n            stdout=sys.stdout,\n            stderr=sys.stderr,\n        )",
          "hash_value": "b70511a5aec8110591ad3e376676d74e",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "with remove_output(\"pybind11/include\", \"pybind11/share\"):\n    # Generate the files if they are not present.\n    with TemporaryDirectory() as tmpdir:\n        cmd = [\"cmake\", \"-S\", \".\", \"-B\", tmpdir] + [\n            \"-DCMAKE_INSTALL_PREFIX=pybind11\",\n            \"-DBUILD_TESTING=OFF\",\n            \"-DPYBIND11_NOPYTHON=ON\",\n            \"-Dprefix_for_pc_file=${pcfiledir}/../../\",\n        ]\n        if \"CMAKE_ARGS\" in os.environ:\n            fcommand = [\n                c\n                for c in os.environ[\"CMAKE_ARGS\"].split()\n                if \"DCMAKE_INSTALL_PREFIX\" not in c\n            ]\n            cmd += fcommand\n        subprocess.run(cmd, check=True, cwd=DIR, stdout=sys.stdout, stderr=sys.stderr)\n        subprocess.run(\n            [\"cmake\", \"--install\", tmpdir],\n            check=True,\n            cwd=DIR,\n            stdout=sys.stdout,\n            stderr=sys.stderr,\n        )",
              "triple_sequences": [
                {
                  "action_api": "os.environ.__contains__()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "\"CMAKE_ARGS\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.__getitem__()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"CMAKE_ARGS\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.environ[\"CMAKE_ARGS\"]",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "cmd",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "[\"cmake\", \"--install\", tmpdir]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "coveralls-4",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/coveralls-4.0.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "api.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/coveralls-4.0.1/coveralls-4.0.1/coveralls/api.py",
          "line_number": "280",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "def submit_report(self, json_string):\n    endpoint = f'{self._coveralls_host.rstrip(\"/\")}/api/v1/jobs'\n    verify = not bool(os.environ.get('COVERALLS_SKIP_SSL_VERIFY'))\n    response = requests.post(\n        endpoint, files={'json_file': json_string}, verify=verify,\n    )\n\n    if response.status_code == 422:\n        if self.config['service_name'].startswith('github'):\n            print(\n                'Received 422 submitting job via Github Actions. By '\n                'default, coveralls-python uses the \"github\" service '\n                'name, which requires you to set the $GITHUB_TOKEN '\n                'environment variable. If you want to use a '\n                'COVERALLS_REPO_TOKEN instead, please manually override '\n                '$COVERALLS_SERVICE_NAME to \"github-actions\". For more '\n                'info, see https://coveralls-python.readthedocs.io/en'\n                '/latest/usage/configuration.html#github-actions-support',\n            )\n\n    try:\n        response.raise_for_status()\n        data = response.json()\n    except Exception as e:\n        raise CoverallsException(\n            f'Could not submit coverage: {e}',\n        ) from e\n\n    return data",
          "hash_value": "694caa149f0f7c5630aae5ecb5661c8d",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def submit_report(self, json_string):\n    endpoint = f'{self._coveralls_host.rstrip(\"/\")}/api/v1/jobs'\n    verify = not bool(os.environ.get('COVERALLS_SKIP_SSL_VERIFY'))\n    response = requests.post(\n        endpoint, files={'json_file': json_string}, verify=verify,\n    )\n\n    if response.status_code == 422:\n        if self.config['service_name'].startswith('github'):\n            print(\n                'Received 422 submitting job via Github Actions. By '\n                'default, coveralls-python uses the \"github\" service '\n                'name, which requires you to set the $GITHUB_TOKEN '\n                'environment variable. If you want to use a '\n                'COVERALLS_REPO_TOKEN instead, please manually override '\n                '$COVERALLS_SERVICE_NAME to \"github-actions\". For more '\n                'info, see https://coveralls-python.readthedocs.io/en'\n                '/latest/usage/configuration.html#github-actions-support',\n            )\n\n    try:\n        response.raise_for_status()\n        data = response.json()\n    except Exception as e:\n        raise CoverallsException(\n            f'Could not submit coverage: {e}',\n        ) from e\n\n    return data",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "COVERALLS_SKIP_SSL_VERIFY",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "requests.post()",
                  "action_description": "Opens URL with POST data",
                  "action_id": "open_url_post",
                  "object": "endpoint, files={'json_file': json_string}, verify=verify",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Transmit encoded data via HTTP POST",
                  "intention_id": "transmit_data_http_post"
                },
                {
                  "action_api": "response.status_code",
                  "action_description": "Retrieves HTTP response status code",
                  "action_id": "get_http_status",
                  "object": "response",
                  "object_description": "HTTP response remote content",
                  "object_id": "http_response_remote_content",
                  "intention_description": "Extract file upload response",
                  "intention_id": "extract_file_upload_response"
                },
                {
                  "action_api": "response.raise_for_status()",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "response",
                  "object_description": "HTTP response remote content",
                  "object_id": "http_response_remote_content",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                },
                {
                  "action_api": "response.json()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "response",
                  "object_description": "HTTP response remote content",
                  "object_id": "http_response_remote_content",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "autobahn-24",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/autobahn-24.4.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "protocol.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/autobahn-24.4.2/autobahn-24.4.2/autobahn/wamp/protocol.py",
          "line_number": "1140",
          "type_description": "obfuscation",
          "context_snippet": "def success(res):\n    del self._invocations[msg.request]\n\n    encoded_payload = None\n    if msg.enc_algo:\n        if not self._payload_codec:\n            log_msg = \"trying to send encrypted payload, but no keyring active\"\n            self.log.warn(log_msg)\n        else:\n            try:\n                if isinstance(res, types.CallResult):\n                    encoded_payload = self._payload_codec.encode(False, proc, res.results, res.kwresults)\n                else:\n                    encoded_payload = self._payload_codec.encode(False, proc, [res])\n            except Exception as e:\n                self.log.warn(\n                    \"failed to encrypt application payload: {err}\",\n                    err=e,\n                )\n\n    if encoded_payload:\n        if isinstance(res, types.CallResult):\n            reply = message.Yield(msg.request,\n                                  payload=encoded_payload.payload,\n                                  enc_algo=encoded_payload.enc_algo,\n                                  enc_key=encoded_payload.enc_key,\n                                  enc_serializer=encoded_payload.enc_serializer,\n                                  callee=res.callee,\n                                  callee_authid=res.callee_authid,\n                                  callee_authrole=res.callee_authrole,\n                                  forward_for=res.forward_for)\n        else:\n            reply = message.Yield(msg.request,\n                                  payload=encoded_payload.payload,\n                                  enc_algo=encoded_payload.enc_algo,\n                                  enc_key=encoded_payload.enc_key,\n                                  enc_serializer=encoded_payload.enc_serializer)\n    else:\n        if isinstance(res, types.CallResult):\n            reply = message.Yield(msg.request,\n                                  args=res.results,\n                                  kwargs=res.kwresults,\n                                  callee=res.callee,\n                                  callee_authid=res.callee_authid,\n                                  callee_authrole=res.callee_authrole,\n                                  forward_for=res.forward_for)\n        else:\n            reply = message.Yield(msg.request,\n                                  args=[res])\n\n    if self._transport is None:\n        self.log.debug('Skipping result of \"{}\", request {} because transport disconnected.'.format(registration.procedure, msg.request))\n        return\n\n    try:\n        self._transport.send(reply)\n    except SerializationError as e:\n        # the application-level payload returned from the invoked procedure can't be serialized\n        error_reply = message.Error(message.Invocation.MESSAGE_TYPE, msg.request, ApplicationError.INVALID_PAYLOAD,\n                                    args=['success return value (args={}, kwargs={}) from invoked procedure \"{}\" could not be serialized: {}'.format(reply.args,\n                                                                                                                                                         reply.kwargs,\n                                                                                                                                                         registration.procedure,\n                                                                                                                                                         e)])\n        self._transport.send(error_reply)\n    except PayloadExceededError as e:\n        # the application-level payload returned from the invoked procedure, when serialized and framed\n        # for the transport, exceeds the transport message/frame size limit\n        error_reply = message.Error(message.Invocation.MESSAGE_TYPE, msg.request, ApplicationError.PAYLOAD_SIZE_EXCEEDED,\n                                    args=['success return value (args={}, kwargs={}) from invoked procedure \"{}\" exceeds transport size limit: {}'.format(reply.args,\n                                                                                                                                                                  reply.kwargs,\n                                                                                                                                                                  registration.procedure,\n                                                                                                                                                                  e)])\n        self._transport.send(error_reply)",
          "hash_value": "8c1a8bc37423a87c550a6594e9a33177",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def success(res):\n    del self._invocations[msg.request]\n\n    encoded_payload = None\n    if msg.enc_algo:\n        if not self._payload_codec:\n            log_msg = \"trying to send encrypted payload, but no keyring active\"\n            self.log.warn(log_msg)\n        else:\n            try:\n                if isinstance(res, types.CallResult):\n                    encoded_payload = self._payload_codec.encode(False, proc, res.results, res.kwresults)\n                else:\n                    encoded_payload = self._payload_codec.encode(False, proc, [res])\n            except Exception as e:\n                self.log.warn(\n                    \"failed to encrypt application payload: {err}\",\n                    err=e,\n                )\n\n    if encoded_payload:\n        if isinstance(res, types.CallResult):\n            reply = message.Yield(msg.request,\n                                  payload=encoded_payload.payload,\n                                  enc_algo=encoded_payload.enc_algo,\n                                  enc_key=encoded_payload.enc_key,\n                                  enc_serializer=encoded_payload.enc_serializer,\n                                  callee=res.callee,\n                                  callee_authid=res.callee_authid,\n                                  callee_authrole=res.callee_authrole,\n                                  forward_for=res.forward_for)\n        else:\n            reply = message.Yield(msg.request,\n                                  payload=encoded_payload.payload,\n                                  enc_algo=encoded_payload.enc_algo,\n                                  enc_key=encoded_payload.enc_key,\n                                  enc_serializer=encoded_payload.enc_serializer)\n    else:\n        if isinstance(res, types.CallResult):\n            reply = message.Yield(msg.request,\n                                  args=res.results,\n                                  kwargs=res.kwresults,\n                                  callee=res.callee,\n                                  callee_authid=res.callee_authid,\n                                  callee_authrole=res.callee_authrole,\n                                  forward_for=res.forward_for)\n        else:\n            reply = message.Yield(msg.request,\n                                  args=[res])\n\n    if self._transport is None:\n        self.log.debug('Skipping result of \"{}\", request {} because transport disconnected.'.format(registration.procedure, msg.request))\n        return\n\n    try:\n        self._transport.send(reply)\n    except SerializationError as e:\n        # the application-level payload returned from the invoked procedure can't be serialized\n        error_reply = message.Error(message.Invocation.MESSAGE_TYPE, msg.request, ApplicationError.INVALID_PAYLOAD,\n                                    args=['success return value (args={}, kwargs={}) from invoked procedure \"{}\" could not be serialized: {}'.format(reply.args,\n                                                                                                                                                         reply.kwargs,\n                                                                                                                                                         registration.procedure,\n                                                                                                                                                         e)])\n        self._transport.send(error_reply)\n    except PayloadExceededError as e:\n        # the application-level payload returned from the invoked procedure, when serialized and framed\n        # for the transport, exceeds the transport message/frame size limit\n        error_reply = message.Error(message.Invocation.MESSAGE_TYPE, msg.request, ApplicationError.PAYLOAD_SIZE_EXCEEDED,\n                                    args=['success return value (args={}, kwargs={}) from invoked procedure \"{}\" exceeds transport size limit: {}'.format(reply.args,\n                                                                                                                                                                  reply.kwargs,\n                                                                                                                                                                  registration.procedure,\n                                                                                                                                                                  e)])\n        self._transport.send(error_reply)",
              "triple_sequences": [
                {
                  "action_api": "del self._invocations[msg.request]",
                  "action_description": "Deletes specified file from filesystem",
                  "action_id": "delete_file",
                  "object": "self._invocations[msg.request]",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Delete function from global namespace",
                  "intention_id": "delete_function_global_namespace"
                },
                {
                  "action_api": "self._payload_codec.encode()",
                  "action_description": "Encodes bytes to base64-encoded bytes",
                  "action_id": "encode_bytes_to_base64",
                  "object": "False, proc, res.results, res.kwresults / False, proc, [res]",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Prepare data for base64 encoding",
                  "intention_id": "prepare_data_base64_encoding"
                },
                {
                  "action_api": "isinstance(res, types.CallResult)",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "res, types.CallResult",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "message.Yield()",
                  "action_description": "Serializes Python object to JSON string",
                  "action_id": "serialize_to_json",
                  "object": "msg.request, payload=encoded_payload.payload, enc_algo=encoded_payload.enc_algo, enc_key=encoded_payload.enc_key, enc_serializer=encoded_payload.enc_serializer, callee=res.callee, callee_authid=res.callee_authid, callee_authrole=res.callee_authrole, forward_for=res.forward_for",
                  "object_description": "JSON string",
                  "object_id": "json_string",
                  "intention_description": "Serialize data",
                  "intention_id": "serialize_data"
                },
                {
                  "action_api": "self.log.warn()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "\"trying to send encrypted payload, but no keyring active\" / \"failed to encrypt application payload: {err}\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "self.log.debug()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "'Skipping result of \"{}\", request {} because transport disconnected.'.format(registration.procedure, msg.request)",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "self._transport.send()",
                  "action_description": "Sends data over socket connection",
                  "action_id": "send_socket_data",
                  "object": "reply",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Send command output to server",
                  "intention_id": "send_command_output_server"
                },
                {
                  "action_api": "message.Error()",
                  "action_description": "Serializes Python object to JSON string",
                  "action_id": "serialize_to_json",
                  "object": "message.Invocation.MESSAGE_TYPE, msg.request, ApplicationError.INVALID_PAYLOAD, args=[...] / ApplicationError.PAYLOAD_SIZE_EXCEEDED, args=[...]",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Serialize data",
                  "intention_id": "serialize_data"
                },
                {
                  "action_api": "self._transport.send()",
                  "action_description": "Sends data over socket connection",
                  "action_id": "send_socket_data",
                  "object": "error_reply",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Send command output to server",
                  "intention_id": "send_command_output_server"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "ffmpeg_progress_yield-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/ffmpeg_progress_yield-0.12.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ffmpeg_progress_yield-0.12.0/ffmpeg_progress_yield-0.12.0/setup.py",
          "line_number": "11",
          "type_description": "code-execution",
          "context_snippet": "#!/usr/bin/env python\n\nfrom os import path\n\nfrom setuptools import setup\n\nhere = path.abspath(path.dirname(__file__))\n\n# read version string\nwith open(path.join(here, \"ffmpeg_progress_yield\", \"__init__.py\")) as version_file:\n    version = eval(version_file.read().split(\"\\n\")[2].split(\"=\")[1].strip())\n\n# Get the long description from the README file\nwith open(path.join(here, \"README.md\")) as f:\n    long_description = f.read()\n",
          "hash_value": "624dba58990074428f6a74dd73ecae42",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "#!/usr/bin/env python\n\nfrom os import path\n\nfrom setuptools import setup\n\nhere = path.abspath(path.dirname(__file__))\n\n# read version string\nwith open(path.join(here, \"ffmpeg_progress_yield\", \"__init__.py\")) as version_file:\n    version = eval(version_file.read().split(\"\\n\")[2].split(\"=\")[1].strip())\n\n# Get the long description from the README file\nwith open(path.join(here, \"README.md\")) as f:\n    long_description = f.read()\n",
              "triple_sequences": [
                {
                  "action_api": "path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "path.dirname(__file__)",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "here, \"ffmpeg_progress_yield\", \"__init__.py\"",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "path.join(here, \"ffmpeg_progress_yield\", \"__init__.py\")",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "version_file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "eval()",
                  "action_description": "Evaluates string as Python expression",
                  "action_id": "eval_python_expr",
                  "object": "version_file.read().split(\"\\n\")[2].split(\"=\")[1].strip()",
                  "object_description": "Python code string",
                  "object_id": "python_code_string",
                  "intention_description": "Evaluate constructed code",
                  "intention_id": "evaluate_constructed_code"
                },
                {
                  "action_api": "path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "here, \"README.md\"",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "path.join(here, \"README.md\")",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "f.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "multiprocess-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/multiprocess-0.70.17.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/multiprocess-0.70.17/multiprocess-0.70.17/setup.py",
          "line_number": "300",
          "type_description": "code-execution",
          "context_snippet": "try:\n    run_setup(False)\nexcept BaseException:\n    if _is_build_command(sys.argv): #XXX: skip WARNING if is_pypy?\n        import traceback\n        msg = BUILD_WARNING % '\\n'.join(traceback.format_stack())\n        exec('print(msg, file=sys.stderr)')\n        run_setup(False)\n    else:\n        raise",
          "hash_value": "907d4e51b09a3f8c7ae30e3e3d745300",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "try:\n    run_setup(False)\nexcept BaseException:\n    if _is_build_command(sys.argv): #XXX: skip WARNING if is_pypy?\n        import traceback\n        msg = BUILD_WARNING % '\\n'.join(traceback.format_stack())\n        exec('print(msg, file=sys.stderr)')\n        run_setup(False)\n    else:\n        raise",
              "triple_sequences": [
                {
                  "action_api": "run_setup()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "False",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "_is_build_command()",
                  "action_description": "Evaluates string as Python expression",
                  "action_id": "eval_python_expr",
                  "object": "sys.argv",
                  "object_description": "Command-line arguments passed to script",
                  "object_id": "cmd_args",
                  "intention_description": "Access command line arguments",
                  "intention_id": "access_command_line_arguments"
                },
                {
                  "action_api": "traceback.format_stack()",
                  "action_description": "Extracts current call stack as FrameSummary objects",
                  "action_id": "extract_call_stack",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "exec()",
                  "action_description": "Dynamically executes Python code string",
                  "action_id": "exec_python_code",
                  "object": "'print(msg, file=sys.stderr)'",
                  "object_description": "Python code string",
                  "object_id": "python_code_string",
                  "intention_description": "Execute Python code",
                  "intention_id": "execute_python_code"
                },
                {
                  "action_api": "run_setup()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "False",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "gen_wrappers-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/gen_wrappers-0.7.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "creator_cmfy.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gen_wrappers-0.7.1/gen_wrappers-0.7.1/creator/cmfy/creator_cmfy.py",
          "line_number": "49",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "    async def create(self, params: Union[CmfyWorkflow, CmfyWorkflowFcus]) -> ResponseCmfy:\n        cmfy_port = os.environ.get(\"PORT_CMFY\", 8889)\n        url = f\"http://localhost:{cmfy_port}/prompt\"\n        workflow = json.loads(params.workflow_json)\n        loaded_model, is_flux, model_type = await self.get_model_from_workflow(workflow)\n        if model_type == \"checkpoint\" and loaded_model is not None:\n            self._check_loaded_model(loaded_model)\n        logger.debug(f\"CMFY data: {workflow}\")\n        # Send a POST to cmfy_url with the workflow json\n        # The response will be JSON string with the below format\n        response_json = {}\n        try:\n            headers = {'Content-Type': 'application/json'}\n            data = {\"prompt\": workflow}\n            data = json.dumps(data).encode('utf-8')\n            response = requests.post(url, data=data, headers=headers)\n            logger.debug(f\"CMFY response: {response}, {response.text}, {response.json()}\")\n            # If we have a 422 here, print what the unprocessable entity is\n            if response.status_code == 422:\n                logger.warning(f\"Unprocessable entity: {response.text}\")\n            response.raise_for_status()\n            response_json = response.json()\n        except Exception as e:\n            logger.error(f\"Error creating prompt: {e}\")\n            return ResponseCmfy.error(f\"Error creating prompt: {e} ({response_json})\")\n        # {\"prompt_id\": \"f57c69ee-f4ed-4866-b5a4-4072c17c36a8\", \"number\": 2, \"node_errors\": {}}\n        prompt_id = response_json.get(\"prompt_id\", None)\n        logger.debug(f\"Prompt ID: {prompt_id}\")\n        if prompt_id is None:\n            return ResponseCmfy.error(f\"Error creating prompt: {response_json}\")\n        status_count = 0\n        response = await self.get_status(prompt_id)\n        status = response.status\n        while status != JobStatus.FINISHED and status != JobStatus.FAILED and status_count < 10:\n            await asyncio.sleep(1)\n            response = await self.get_status(prompt_id)\n            status = response.status\n            status_count += 1\n        if status == JobStatus.FINISHED:\n            response_data = response.output\n            logger.info(f\"Success, returning response with {len(data)} images\")\n            return ResponseCmfy.success(response_data, prompt_id)\n        return ResponseCmfy.error(\"Error creating prompt\")",
          "hash_value": "e82ac952556c431681bba47db8585d49",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "    async def create(self, params: Union[CmfyWorkflow, CmfyWorkflowFcus]) -> ResponseCmfy:\n        cmfy_port = os.environ.get(\"PORT_CMFY\", 8889)\n        url = f\"http://localhost:{cmfy_port}/prompt\"\n        workflow = json.loads(params.workflow_json)\n        loaded_model, is_flux, model_type = await self.get_model_from_workflow(workflow)\n        if model_type == \"checkpoint\" and loaded_model is not None:\n            self._check_loaded_model(loaded_model)\n        logger.debug(f\"CMFY data: {workflow}\")\n        # Send a POST to cmfy_url with the workflow json\n        # The response will be JSON string with the below format\n        response_json = {}\n        try:\n            headers = {'Content-Type': 'application/json'}\n            data = {\"prompt\": workflow}\n            data = json.dumps(data).encode('utf-8')\n            response = requests.post(url, data=data, headers=headers)\n            logger.debug(f\"CMFY response: {response}, {response.text}, {response.json()}\")\n            # If we have a 422 here, print what the unprocessable entity is\n            if response.status_code == 422:\n                logger.warning(f\"Unprocessable entity: {response.text}\")\n            response.raise_for_status()\n            response_json = response.json()\n        except Exception as e:\n            logger.error(f\"Error creating prompt: {e}\")\n            return ResponseCmfy.error(f\"Error creating prompt: {e} ({response_json})\")\n        # {\"prompt_id\": \"f57c69ee-f4ed-4866-b5a4-4072c17c36a8\", \"number\": 2, \"node_errors\": {}}\n        prompt_id = response_json.get(\"prompt_id\", None)\n        logger.debug(f\"Prompt ID: {prompt_id}\")\n        if prompt_id is None:\n            return ResponseCmfy.error(f\"Error creating prompt: {response_json}\")\n        status_count = 0\n        response = await self.get_status(prompt_id)\n        status = response.status\n        while status != JobStatus.FINISHED and status != JobStatus.FAILED and status_count < 10:\n            await asyncio.sleep(1)\n            response = await self.get_status(prompt_id)\n            status = response.status\n            status_count += 1\n        if status == JobStatus.FINISHED:\n            response_data = response.output\n            logger.info(f\"Success, returning response with {len(data)} images\")\n            return ResponseCmfy.success(response_data, prompt_id)\n        return ResponseCmfy.error(\"Error creating prompt\")",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"PORT_CMFY\", 8889",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "json.loads()",
                  "action_description": "Deserializes JSON string to Python object",
                  "action_id": "deserialize_from_json",
                  "object": "params.workflow_json",
                  "object_description": "JSON string",
                  "object_id": "json_string",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "self.get_model_from_workflow()",
                  "action_description": "Instantiates custom class or function",
                  "action_id": "init_grabber_class",
                  "object": "workflow",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "self._check_loaded_model()",
                  "action_description": "Instantiates custom class or function",
                  "action_id": "init_grabber_class",
                  "object": "loaded_model",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "logger.debug()",
                  "action_description": "Writes log message",
                  "action_id": "basic_write_operations",
                  "object": "f\"CMFY data: {workflow}\"",
                  "object_description": "Log message text",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "json.dumps()",
                  "action_description": "Serializes Python object to JSON string",
                  "action_id": "serialize_to_json",
                  "object": "data",
                  "object_description": "JSON string",
                  "object_id": "json_string",
                  "intention_description": "Serialize data",
                  "intention_id": "serialize_data"
                },
                {
                  "action_api": "str.encode()",
                  "action_description": "Encodes string to bytes using default encoding",
                  "action_id": "encode_string_to_bytes",
                  "object": "'utf-8'",
                  "object_description": "Encoding format",
                  "object_id": "encoding_format",
                  "intention_description": "Encode string to bytes",
                  "intention_id": "encode_string_to_bytes"
                },
                {
                  "action_api": "requests.post()",
                  "action_description": "Opens URL with POST data",
                  "action_id": "open_url_post",
                  "object": "url, data=data, headers=headers",
                  "object_description": "Request object for external domain",
                  "object_id": "request_external_domain",
                  "intention_description": "Send HTTP request",
                  "intention_id": "send_data_server"
                },
                {
                  "action_api": "logger.debug()",
                  "action_description": "Writes log message",
                  "action_id": "basic_write_operations",
                  "object": "f\"CMFY response: {response}, {response.text}, {response.json()}\"",
                  "object_description": "Log message text",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "response.status_code",
                  "action_description": "Retrieves HTTP response status code",
                  "action_id": "get_http_status",
                  "object": "",
                  "object_description": "HTTP status code",
                  "object_id": "status_code",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "logger.warning()",
                  "action_description": "Writes log message",
                  "action_id": "basic_write_operations",
                  "object": "f\"Unprocessable entity: {response.text}\"",
                  "object_description": "Log message text",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "response.raise_for_status()",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "response.json()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "",
                  "object_description": "HTTP response content from remote server",
                  "object_id": "http_response_remote_content",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "logger.error()",
                  "action_description": "Writes log message",
                  "action_id": "basic_write_operations",
                  "object": "f\"Error creating prompt: {e}\"",
                  "object_description": "Log message text",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "ResponseCmfy.error()",
                  "action_description": "Instantiates custom class or function",
                  "action_id": "init_grabber_class",
                  "object": "f\"Error creating prompt: {e} ({response_json})\"",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "response_json.get()",
                  "action_description": "Retrieves value from dictionary",
                  "action_id": "get_env_var",
                  "object": "\"prompt_id\", None",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "logger.debug()",
                  "action_description": "Writes log message",
                  "action_id": "basic_write_operations",
                  "object": "f\"Prompt ID: {prompt_id}\"",
                  "object_description": "Log message text",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "ResponseCmfy.error()",
                  "action_description": "Instantiates custom class or function",
                  "action_id": "init_grabber_class",
                  "object": "f\"Error creating prompt: {response_json}\"",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "self.get_status()",
                  "action_description": "Instantiates custom class or function",
                  "action_id": "init_grabber_class",
                  "object": "prompt_id",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "asyncio.sleep()",
                  "action_description": "Suspends execution",
                  "action_id": "suspend_execution",
                  "object": "1",
                  "object_description": "Delay duration in seconds",
                  "object_id": "delay_duration",
                  "intention_description": "Pause execution",
                  "intention_id": "pause_execution"
                },
                {
                  "action_api": "logger.info()",
                  "action_description": "Writes log message",
                  "action_id": "basic_write_operations",
                  "object": "f\"Success, returning response with {len(data)} images\"",
                  "object_description": "Log message text",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "ResponseCmfy.success()",
                  "action_description": "Instantiates custom class or function",
                  "action_id": "init_grabber_class",
                  "object": "response_data, prompt_id",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "ResponseCmfy.error()",
                  "action_description": "Instantiates custom class or function",
                  "action_id": "init_grabber_class",
                  "object": "\"Error creating prompt\"",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "mecab_python3-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/mecab_python3-1.0.11.dev9.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/mecab_python3-1.0.11.dev9/mecab_python3-1.0.11.dev9/setup.py",
          "line_number": "95",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport subprocess\nimport sys\n\ndef maybe_build_libmecab_and_adjust_flags(ext):\n    if USE_BUNDLED_LIBMECAB:\n        subprocess.check_call([\n            sys.executable,\n            os.path.join(SRCDIR, \"scripts/build-bundled-libmecab.py\"),\n            SRCDIR\n        ])\n        inc_dir  = [os.path.join(SRCDIR, \"build/libmecab/mecab/src\")]\n        lib_dirs = [os.path.join(SRCDIR, \"build/libmecab/mecab/src\")]\n\n        # mecab-config --libs-only-l will produce the list of\n        # libraries needed to link with a hypothetical *shared*\n        # libmecab; we built a *static* libmecab, so what we actually\n        # need is -lmecab + the value of the LIBS substitution\n        # variable from the Makefile.\n        libs = [\"mecab\"]\n        with open(os.path.join(SRCDIR, \"build/libmecab/mecab/Makefile\"),\n                  \"rt\") as fp:\n            for line in fp:\n                if line.startswith(\"LIBS =\"):\n                    for lib in line.partition(\"=\")[2].split():\n                        if lib[:2] == \"-l\":\n                            libs.append(lib[2:])\n                    break\n\n    else:\n        # Ensure use of the \"C\" locale when invoking mecab-config.\n        # (\"C.UTF-8\" would be better if available, but there's no\n        # good way to find out whether it's available.)\n        clocale_env = {}\n        for k, v in os.environ.items():\n            if not (k.startswith(\"LC_\") or k == \"LANG\" or k == \"LANGUAGE\"):\n                clocale_env[k] = v\n        clocale_env[\"LC_ALL\"] = \"C\"\n\n        def mecab_config(arg):\n            output = subprocess.check_output([\"mecab-config\", arg],\n                                             env=clocale_env)\n            if not isinstance(output, str):\n                output = output.decode(\"utf-8\")\n            return output.split()\n\n        inc_dir  = mecab_config(\"--inc-dir\")\n        lib_dirs = mecab_config(\"--libs-only-L\")\n        libs     = mecab_config(\"--libs-only-l\")\n\n    swig_opts = [\"-O\", \"-builtin\", \"-c++\"]\n\n    if sys.version_info.major >= 3:\n        swig_opts.append(\"-py3\")\n\n    swig_opts.extend(\"-I\"+d for d in inc_dir)\n\n    ext.include_dirs = inc_dir\n    ext.library_dirs = lib_dirs\n    ext.libraries    = libs\n    ext.swig_opts    = swig_opts\n    ext.extra_compile_args = [\"-Wno-unused-variable\"]\n\n    sys.stderr.write(\"Extension build configuration adjusted:\\n\"\n                     \" include_dirs = {!r}\\n\"\n                     \" library_dirs = {!r}\\n\"\n                     \" libraries    = {!r}\\n\"\n                     \" swig_opts    = {!r}\\n\"\n                     .format(inc_dir, lib_dirs, libs, swig_opts))",
          "hash_value": "636911285a7128f95890e62cc93481d9",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport subprocess\nimport sys\n\ndef maybe_build_libmecab_and_adjust_flags(ext):\n    if USE_BUNDLED_LIBMECAB:\n        subprocess.check_call([\n            sys.executable,\n            os.path.join(SRCDIR, \"scripts/build-bundled-libmecab.py\"),\n            SRCDIR\n        ])\n        inc_dir  = [os.path.join(SRCDIR, \"build/libmecab/mecab/src\")]\n        lib_dirs = [os.path.join(SRCDIR, \"build/libmecab/mecab/src\")]\n\n        # mecab-config --libs-only-l will produce the list of\n        # libraries needed to link with a hypothetical *shared*\n        # libmecab; we built a *static* libmecab, so what we actually\n        # need is -lmecab + the value of the LIBS substitution\n        # variable from the Makefile.\n        libs = [\"mecab\"]\n        with open(os.path.join(SRCDIR, \"build/libmecab/mecab/Makefile\"),\n                  \"rt\") as fp:\n            for line in fp:\n                if line.startswith(\"LIBS =\"):\n                    for lib in line.partition(\"=\")[2].split():\n                        if lib[:2] == \"-l\":\n                            libs.append(lib[2:])\n                    break\n\n    else:\n        # Ensure use of the \"C\" locale when invoking mecab-config.\n        # (\"C.UTF-8\" would be better if available, but there's no\n        # good way to find out whether it's available.)\n        clocale_env = {}\n        for k, v in os.environ.items():\n            if not (k.startswith(\"LC_\") or k == \"LANG\" or k == \"LANGUAGE\"):\n                clocale_env[k] = v\n        clocale_env[\"LC_ALL\"] = \"C\"\n\n        def mecab_config(arg):\n            output = subprocess.check_output([\"mecab-config\", arg],\n                                             env=clocale_env)\n            if not isinstance(output, str):\n                output = output.decode(\"utf-8\")\n            return output.split()\n\n        inc_dir  = mecab_config(\"--inc-dir\")\n        lib_dirs = mecab_config(\"--libs-only-L\")\n        libs     = mecab_config(\"--libs-only-l\")\n\n    swig_opts = [\"-O\", \"-builtin\", \"-c++\"]\n\n    if sys.version_info.major >= 3:\n        swig_opts.append(\"-py3\")\n\n    swig_opts.extend(\"-I\"+d for d in inc_dir)\n\n    ext.include_dirs = inc_dir\n    ext.library_dirs = lib_dirs\n    ext.libraries    = libs\n    ext.swig_opts    = swig_opts\n    ext.extra_compile_args = [\"-Wno-unused-variable\"]\n\n    sys.stderr.write(\"Extension build configuration adjusted:\\n\"\n                     \" include_dirs = {!r}\\n\"\n                     \" library_dirs = {!r}\\n\"\n                     \" libraries    = {!r}\\n\"\n                     \" swig_opts    = {!r}\\n\"\n                     .format(inc_dir, lib_dirs, libs, swig_opts))",
              "triple_sequences": [
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[sys.executable, os.path.join(SRCDIR, \"scripts/build-bundled-libmecab.py\"), SRCDIR]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "SRCDIR, \"scripts/build-bundled-libmecab.py\"",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "SRCDIR, \"build/libmecab/mecab/src\"",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "os.path.join(SRCDIR, \"build/libmecab/mecab/Makefile\"), \"rt\"",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "os.environ.items()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"mecab-config\", arg], env=clocale_env",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "str.decode()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "\"utf-8\"",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Decode bytes to string",
                  "intention_id": "decode_bytes_to_string"
                },
                {
                  "action_api": "sys.stderr.write()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "\"Extension build configuration adjusted:\\n include_dirs = {!r}\\n library_dirs = {!r}\\n libraries    = {!r}\\n swig_opts    = {!r}\\n\".format(inc_dir, lib_dirs, libs, swig_opts)",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "ipinfo-5",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/ipinfo-5.1.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ipinfo-5.1.1/ipinfo-5.1.1/setup.py",
          "line_number": "10",
          "type_description": "shady-links",
          "context_snippet": "long_description = \"\"\"\nThe official Python library for IPinfo.\n\nIPinfo prides itself on being the most reliable, accurate, and in-depth source of IP address data available anywhere.\nWe process terabytes of data to produce our custom IP geolocation, company, carrier and IP type data sets.\nYou can visit our developer docs at https://ipinfo.io/developers.\n\"\"\"",
          "hash_value": "fea2a6c7a333746d608d5eaa58261f61",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "long_description = \"\"\"\nThe official Python library for IPinfo.\n\nIPinfo prides itself on being the most reliable, accurate, and in-depth source of IP address data available anywhere.\nWe process terabytes of data to produce our custom IP geolocation, company, carrier and IP type data sets.\nYou can visit our developer docs at https://ipinfo.io/developers.\n\"\"\"",
              "triple_sequences": []
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "gradio_client-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/gradio_client-1.8.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "discord_chat.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gradio_client-1.8.0/gradio_client-1.8.0/gradio_client/templates/discord_chat.py",
          "line_number": "143",
          "type_description": "shady-links",
          "context_snippet": "if not DISCORD_TOKEN:\n    welcome_message = \"\"\"\n\n    ## You have not specified a DISCORD_TOKEN, which means you have not created a bot account. Please follow these steps:\n\n    ### 1. Go to https://discord.com/developers/applications and click 'New Application'\n\n    ### 2. Give your bot a name 🤖\n\n    ![](https://gradio-builds.s3.amazonaws.com/demo-files/discordbots/BotName.png)\n\n    ## 3. In Settings > Bot, click the 'Reset Token' button to get a new token. Write it down and keep it safe 🔐\n\n    ![](https://gradio-builds.s3.amazonaws.com/demo-files/discordbots/ResetToken.png)\n\n    ## 4. Optionally make the bot public if you want anyone to be able to add it to their servers\n\n    ## 5. Scroll down and enable 'Message Content Intent' under 'Priviledged Gateway Intents'\n\n    ![](https://gradio-builds.s3.amazonaws.com/demo-files/discordbots/MessageContentIntent.png)\n\n    ## 6. Save your changes!\n\n    ## 7. The token from step 3 is the DISCORD_TOKEN. Rerun the deploy_discord command, e.g client.deploy_discord(discord_bot_token=DISCORD_TOKEN, ...), or add the token as a space secret manually.\n\"\"\"",
          "hash_value": "6caf6a631139b04a49832e5c289ad122",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "if not DISCORD_TOKEN:\n    welcome_message = \"\"\"\n\n    ## You have not specified a DISCORD_TOKEN, which means you have not created a bot account. Please follow these steps:\n\n    ### 1. Go to https://discord.com/developers/applications and click 'New Application'\n\n    ### 2. Give your bot a name 🤖\n\n    ![](https://gradio-builds.s3.amazonaws.com/demo-files/discordbots/BotName.png)\n\n    ## 3. In Settings > Bot, click the 'Reset Token' button to get a new token. Write it down and keep it safe 🔐\n\n    ![](https://gradio-builds.s3.amazonaws.com/demo-files/discordbots/ResetToken.png)\n\n    ## 4. Optionally make the bot public if you want anyone to be able to add it to their servers\n\n    ## 5. Scroll down and enable 'Message Content Intent' under 'Priviledged Gateway Intents'\n\n    ![](https://gradio-builds.s3.amazonaws.com/demo-files/discordbots/MessageContentIntent.png)\n\n    ## 6. Save your changes!\n\n    ## 7. The token from step 3 is the DISCORD_TOKEN. Rerun the deploy_discord command, e.g client.deploy_discord(discord_bot_token=DISCORD_TOKEN, ...), or add the token as a space secret manually.\n\"\"\"",
              "triple_sequences": [
                {
                  "action_api": "",
                  "action_description": "",
                  "action_id": "",
                  "object": "DISCORD_TOKEN",
                  "object_description": "Discord bot token",
                  "object_id": "discord_bot_token",
                  "intention_description": "Determine presence of valid authentication",
                  "intention_id": "determine_valid_authentication_presence"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pyperclip-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyperclip-1.9.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "__main__.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyperclip-1.9.0/pyperclip-1.9.0/src/pyperclip/__main__.py",
          "line_number": "6",
          "type_description": "clipboard-access",
          "context_snippet": "import pyperclip\nimport sys\n\nif len(sys.argv) > 1 and sys.argv[1] in ('-c', '--copy'):\n    if len(sys.argv) > 2:\n        pyperclip.copy(sys.argv[2])\n    else:\n        pyperclip.copy(sys.stdin.read())",
          "hash_value": "c7fc5d348b53c45d34291a1cdca24061",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import pyperclip\nimport sys\n\nif len(sys.argv) > 1 and sys.argv[1] in ('-c', '--copy'):\n    if len(sys.argv) > 2:\n        pyperclip.copy(sys.argv[2])\n    else:\n        pyperclip.copy(sys.stdin.read())",
              "triple_sequences": [
                {
                  "action_api": "len()",
                  "action_description": "Retrieves command-line arguments passed to script",
                  "action_id": "get_cmd_args",
                  "object": "sys.argv",
                  "object_description": "Command-line arguments passed to script",
                  "object_id": "get_cmd_args",
                  "intention_description": "Access command line arguments",
                  "intention_id": "access_command_line_arguments"
                },
                {
                  "action_api": "pyperclip.copy()",
                  "action_description": "Copies specified text to system clipboard",
                  "action_id": "copy_to_clipboard",
                  "object": "sys.argv[2]",
                  "object_description": "Clipboard content data",
                  "object_id": "clipboard_data",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                },
                {
                  "action_api": "pyperclip.copy()",
                  "action_description": "Copies specified text to system clipboard",
                  "action_id": "copy_to_clipboard",
                  "object": "sys.stdin.read()",
                  "object_description": "Clipboard content data",
                  "object_id": "clipboard_data",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "openxlab-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/openxlab-0.1.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "constants.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/openxlab-0.1.2/openxlab-0.1.2/openxlab/model/common/constants.py",
          "line_number": "44",
          "type_description": "shady-links",
          "context_snippet": "import os\n\n\nmodel_openapi_url_prefix_dev = \"https://dev.openxlab.org.cn/api/v1\"\nmodel_openapi_url_prefix_staging = \"https://staging.openxlab.org.cn/api/v1\"\nmodel_openapi_url_prefix_prod = \"https://openapi.openxlab.org.cn/api/v1\"\nmodel_url_prefix_dev = \"http://10.1.100.130:10019\"\nmodel_cache_path = os.path.join(os.path.expanduser(\"~\"), \".cache\", \"model\")\n# temp token\ntoken = (\n    \"eyJ0eXBlIjoiSldUIiwiYWxnIjoiSFM1MTIifQ.\"\n    \"eyJqdGkiOiI1OTcwOTEiLCJyb2wiOiJST0xFX0FETUlOIiwiaXNzIjoiT3Blblh\"\n    \"MYWIiLCJpYXQiOjE2ODE5Njg4NzMsInBob25lIjoiIiwiYWsiOiI2cHFnOXprNm\"\n    \"RteG9rZ2JnbHZvayIsImVtYWlsIjoiZG9uZ3hpYW96aHVhbmdAcGpsYWIub3JnL\"\n    \"mNuIiwiZXhwIjoxNzEzNTA0ODczfQ.eFl8ZH9tDp-pcjY3wz6PeNBarJwhVx90q\"\n    \"Q3h82Qvpf0hrcrdrQSBcI8AmEk2TZFpeViC6HBtXRxxGp2YLK1XkA\"\n)\nendpoint = model_openapi_url_prefix_prod\npaths = {\n    \"file_download_path\": \"/model-center/api/v1/cli/repository/getFileDownloadUrl\",\n    \"meta_file_template_download_path\": \"/model-center/api/v1/cli/repository/getMetafileTemplateUrl\",\n    \"create_repository_path\": \"/model-center/api/v1/cli/repository/createModelRepository\",\n    \"update_repository_path\": \"/model-center/api/v1/cli/repository/updateRepositoryBaseInfo\",\n    \"delete_repository_path\": \"/model-center/api/v1/cli/repository/deleteRepository\",\n    \"query_models_path\": \"/model-center/api/v1/cli/repository/getRepositoryModelList\",\n    \"update_upload_status_path\": \"/model-center/api/v1/cli/repository/updateFileUploadStatus\",\n    \"query_model_repo_info_path\": \"/model-center/api/v1/cli/repository/queryModelRepoInfo\",\n    \"get_upload_signature\": \"/upload-service/api/v1/getUploadSignature\",\n    \"bury_upload\": \"/data-bury/api/v1/bury/collect\",\n}\n# oss_endpoint = 'https://openmmlab-open.oss-cn-shanghai.aliyuncs.com'\noss_endpoint = \"https://oss-cn-shanghai.aliyuncs.com\"\noss_bucket_domain_dev = \"openmmlab-open.oss-cn-shanghai.aliyuncs.com\"\noss_bucket_domain_staging = \"openmmlab-open.oss-cn-shanghai.aliyuncs.com\"\noss_bucket_domain_prod = \"xlab-model-center.oss-cn-shanghai.aliyuncs.com\"\noss_bucket_domain = oss_bucket_domain_prod\noss_endpoint_domain = \"oss-cn-shanghai.aliyuncs.com\"\noss_accelerate_domain = \"oss-accelerate.aliyuncs.com\"\ndefault_metafile_template_name = \"metafile.yaml\"\nriver_pass_url_dev = \"http://106.14.134.80:10006/getFile\"\nriver_pass_url_staging = \"http://riverpass.staging.openxlab.org.cn/getFile\"\nriver_pass_url_prod = \"http://riverpass.openxlab.org.cn/getFile\"\nriver_pass_url = river_pass_url_prod",
          "hash_value": "4927494506f128f186029d7663f5f68b",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\n\n\nmodel_openapi_url_prefix_dev = \"https://dev.openxlab.org.cn/api/v1\"\nmodel_openapi_url_prefix_staging = \"https://staging.openxlab.org.cn/api/v1\"\nmodel_openapi_url_prefix_prod = \"https://openapi.openxlab.org.cn/api/v1\"\nmodel_url_prefix_dev = \"http://10.1.100.130:10019\"\nmodel_cache_path = os.path.join(os.path.expanduser(\"~\"), \".cache\", \"model\")\n# temp token\ntoken = (\n    \"eyJ0eXBlIjoiSldUIiwiYWxnIjoiSFM1MTIifQ.\"\n    \"eyJqdGkiOiI1OTcwOTEiLCJyb2wiOiJST0xFX0FETUlOIiwiaXNzIjoiT3Blblh\"\n    \"MYWIiLCJpYXQiOjE2ODE5Njg4NzMsInBob25lIjoiIiwiYWsiOiI2cHFnOXprNm\"\n    \"RteG9rZ2JnbHZvayIsImVtYWlsIjoiZG9uZ3hpYW96aHVhbmdAcGpsYWIub3JnL\"\n    \"mNuIiwiZXhwIjoxNzEzNTA0ODczfQ.eFl8ZH9tDp-pcjY3wz6PeNBarJwhVx90q\"\n    \"Q3h82Qvpf0hrcrdrQSBcI8AmEk2TZFpeViC6HBtXRxxGp2YLK1XkA\"\n)\nendpoint = model_openapi_url_prefix_prod\npaths = {\n    \"file_download_path\": \"/model-center/api/v1/cli/repository/getFileDownloadUrl\",\n    \"meta_file_template_download_path\": \"/model-center/api/v1/cli/repository/getMetafileTemplateUrl\",\n    \"create_repository_path\": \"/model-center/api/v1/cli/repository/createModelRepository\",\n    \"update_repository_path\": \"/model-center/api/v1/cli/repository/updateRepositoryBaseInfo\",\n    \"delete_repository_path\": \"/model-center/api/v1/cli/repository/deleteRepository\",\n    \"query_models_path\": \"/model-center/api/v1/cli/repository/getRepositoryModelList\",\n    \"update_upload_status_path\": \"/model-center/api/v1/cli/repository/updateFileUploadStatus\",\n    \"query_model_repo_info_path\": \"/model-center/api/v1/cli/repository/queryModelRepoInfo\",\n    \"get_upload_signature\": \"/upload-service/api/v1/getUploadSignature\",\n    \"bury_upload\": \"/data-bury/api/v1/bury/collect\",\n}\n# oss_endpoint = 'https://openmmlab-open.oss-cn-shanghai.aliyuncs.com'\noss_endpoint = \"https://oss-cn-shanghai.aliyuncs.com\"\noss_bucket_domain_dev = \"openmmlab-open.oss-cn-shanghai.aliyuncs.com\"\noss_bucket_domain_staging = \"openmmlab-open.oss-cn-shanghai.aliyuncs.com\"\noss_bucket_domain_prod = \"xlab-model-center.oss-cn-shanghai.aliyuncs.com\"\noss_bucket_domain = oss_bucket_domain_prod\noss_endpoint_domain = \"oss-cn-shanghai.aliyuncs.com\"\noss_accelerate_domain = \"oss-accelerate.aliyuncs.com\"\ndefault_metafile_template_name = \"metafile.yaml\"\nriver_pass_url_dev = \"http://106.14.134.80:10006/getFile\"\nriver_pass_url_staging = \"http://riverpass.staging.openxlab.org.cn/getFile\"\nriver_pass_url_prod = \"http://riverpass.openxlab.org.cn/getFile\"\nriver_pass_url = river_pass_url_prod",
              "triple_sequences": [
                {
                  "action_api": "os.path.expanduser()",
                  "action_description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
                  "action_id": "path_special_operations",
                  "object": "~",
                  "object_description": "Home directory path",
                  "object_id": "home_directory_path",
                  "intention_description": "Access user home directory",
                  "intention_id": "access_user_home_directory"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.expanduser(\"~\"), \".cache\", \"model\"",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "bson-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/bson-0.5.10.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/bson-0.5.10/bson-0.5.10/setup.py",
          "line_number": "26",
          "type_description": "cmd-overwrite",
          "context_snippet": "setup(\n    name=\"bson\",\n    version=\"0.5.10\",\n    packages=[\"bson\"],\n    install_requires=[\"python-dateutil>=2.4.0\", \"six>=1.9.0\"],\n    author=\"Ayun Park\",\n    author_email=\"iamparkayun@gmail.com\",\n    description=\"BSON codec for Python\",\n    long_description=\"\"\"Independent BSON codec for Python that doesn't depend on MongoDB.\"\"\",\n    platforms=\"Any\",\n    license=\"BSD\",\n    keywords=\"BSON codec\",\n    url=\"http://github.com/py-bson/bson\",\n    classifiers=[\n        'Programming Language :: Python :: 2.6',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3.3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n    ],\n    cmdclass={'install': NewInstall}\n)",
          "hash_value": "9a09504dc0ec940082a8024c969f8b0c",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "setup(\n    name=\"bson\",\n    version=\"0.5.10\",\n    packages=[\"bson\"],\n    install_requires=[\"python-dateutil>=2.4.0\", \"six>=1.9.0\"],\n    author=\"Ayun Park\",\n    author_email=\"iamparkayun@gmail.com\",\n    description=\"BSON codec for Python\",\n    long_description=\"\"\"Independent BSON codec for Python that doesn't depend on MongoDB.\"\"\",\n    platforms=\"Any\",\n    license=\"BSD\",\n    keywords=\"BSON codec\",\n    url=\"http://github.com/py-bson/bson\",\n    classifiers=[\n        'Programming Language :: Python :: 2.6',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3.3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n    ],\n    cmdclass={'install': NewInstall}\n)",
              "triple_sequences": [
                {
                  "action_api": "setup()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "{'name': 'bson', 'version': '0.5.10', 'packages': ['bson'], 'install_requires': ['python-dateutil>=2.4.0', 'six>=1.9.0'], 'author': 'Ayun Park', 'author_email': 'iamparkayun@gmail.com', 'description': 'BSON codec for Python', 'long_description': \"\"\"Independent BSON codec for Python that doesn't depend on MongoDB.\"\"\", 'platforms': 'Any', 'license': 'BSD', 'keywords': 'BSON codec', 'url': 'http://github.com/py-bson/bson', 'classifiers': ['Programming Language :: Python :: 2.6', 'Programming Language :: Python :: 2.7', 'Programming Language :: Python :: 3.3', 'Programming Language :: Python :: 3.4', 'Programming Language :: Python :: 3.5', 'Programming Language :: Python :: 3.6'], 'cmdclass': {'install': NewInstall}}",
                  "object_description": "Custom post-install function",
                  "object_id": "custom_post_install_function",
                  "intention_description": "Trigger post-installation logic",
                  "intention_id": "trigger_post_installation_logic"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "cython-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/cython-3.1.0b1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cython-3.1.0b1/cython-3.1.0b1/Demos/libraries/setup.py",
          "line_number": "14",
          "type_description": "code-execution",
          "context_snippet": "from __future__ import absolute_import, print_function\n\nimport os\nimport sys\n\nfrom distutils.core import setup\nfrom distutils.extension import Extension\nfrom Cython.Build import cythonize\n\n\n# For demo purposes, we build our own tiny library.\ntry:\n    print(\"building libmymath.a\")\n    assert os.system(\"gcc -shared -fPIC -c mymath.c -o mymath.o\") == 0\n    assert os.system(\"ar rcs libmymath.a mymath.o\") == 0\nexcept:\n    if not os.path.exists(\"libmymath.a\"):\n        print(\"Error building external library, please create libmymath.a manually.\")\n        sys.exit(1)",
          "hash_value": "d227d5496c3a71ca2d3f9be748030ad9",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from __future__ import absolute_import, print_function\n\nimport os\nimport sys\n\nfrom distutils.core import setup\nfrom distutils.extension import Extension\nfrom Cython.Build import cythonize\n\n\n# For demo purposes, we build our own tiny library.\ntry:\n    print(\"building libmymath.a\")\n    assert os.system(\"gcc -shared -fPIC -c mymath.c -o mymath.o\") == 0\n    assert os.system(\"ar rcs libmymath.a mymath.o\") == 0\nexcept:\n    if not os.path.exists(\"libmymath.a\"):\n        print(\"Error building external library, please create libmymath.a manually.\")\n        sys.exit(1)",
              "triple_sequences": [
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "gcc -shared -fPIC -c mymath.c -o mymath.o",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "ar rcs libmymath.a mymath.o",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "libmymath.a",
                  "object_description": "Local file or directory name",
                  "object_id": "local_file_or_directory_name",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "1",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "sqlitedict-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/sqlitedict-2.1.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/sqlitedict-2.1.0/sqlitedict-2.1.0/setup.py",
          "line_number": "48",
          "type_description": "cmd-overwrite",
          "context_snippet": "setup(\n    name='sqlitedict',\n    version='2.1.0',\n    description='Persistent dict in Python, backed up by sqlite3 and pickle, multithread-safe.',\n    long_description=read('README.rst'),\n\n    py_modules=['sqlitedict'],\n\n    # there is a bug in python2.5, preventing distutils from using any non-ascii characters :(\n    # http://bugs.python.org/issue2562\n    author='Radim Rehurek, Victor R. Escobar, Andrey Usov, Prasanna Swaminathan, Jeff Quast',\n    author_email=\"me@radimrehurek.com\",\n    maintainer='Radim Rehurek',\n    maintainer_email='me@radimrehurek.com',\n\n    url='https://github.com/piskvorky/sqlitedict',\n    download_url='http://pypi.python.org/pypi/sqlitedict',\n\n    keywords='sqlite, persistent dict, multithreaded',\n\n    license='Apache 2.0',\n    platforms='any',\n\n    classifiers=[  # from http://pypi.python.org/pypi?%3Aaction=list_classifiers\n        'Development Status :: 5 - Production/Stable',\n        'Environment :: Console',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: Apache Software License',\n        'Operating System :: OS Independent',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Topic :: Database :: Front-Ends',\n    ],\n    cmdclass={'develop': SetupDevelop},\n)\n\n# Data dependencies:\n# - 'read' is defined as:\ndef read(fname):\n    path = os.path.join(os.path.dirname(__file__), fname)\n    return io.open(path, encoding='utf8').read()\n# - 'SetupDevelop' is defined as:\nclass SetupDevelop(setuptools.command.develop.develop):\n    \"\"\"Docstring is overwritten.\"\"\"\n\n    def run(self):\n        \"\"\"\n        Prepare environment for development.\n\n        - Ensures 'nose' and 'coverage.py' are installed for testing.\n        - Call super()'s run method.\n        \"\"\"\n        subprocess.check_call(('pip', 'install', 'nose', 'coverage'))\n\n        # Call super() (except develop is an old-style class, so we must call\n        # directly). The effect is that the development egg-link is installed.\n        setuptools.command.develop.develop.run(self)\n",
          "hash_value": "37166c96fb07c38be7845cce51231fc1",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "setup(\n    name='sqlitedict',\n    version='2.1.0',\n    description='Persistent dict in Python, backed up by sqlite3 and pickle, multithread-safe.',\n    long_description=read('README.rst'),\n\n    py_modules=['sqlitedict'],\n\n    # there is a bug in python2.5, preventing distutils from using any non-ascii characters :(\n    # http://bugs.python.org/issue2562\n    author='Radim Rehurek, Victor R. Escobar, Andrey Usov, Prasanna Swaminathan, Jeff Quast',\n    author_email=\"me@radimrehurek.com\",\n    maintainer='Radim Rehurek',\n    maintainer_email='me@radimrehurek.com',\n\n    url='https://github.com/piskvorky/sqlitedict',\n    download_url='http://pypi.python.org/pypi/sqlitedict',\n\n    keywords='sqlite, persistent dict, multithreaded',\n\n    license='Apache 2.0',\n    platforms='any',\n\n    classifiers=[  # from http://pypi.python.org/pypi?%3Aaction=list_classifiers\n        'Development Status :: 5 - Production/Stable',\n        'Environment :: Console',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: Apache Software License',\n        'Operating System :: OS Independent',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Topic :: Database :: Front-Ends',\n    ],\n    cmdclass={'develop': SetupDevelop},\n)\n\n# Data dependencies:\n# - 'read' is defined as:\ndef read(fname):\n    path = os.path.join(os.path.dirname(__file__), fname)\n    return io.open(path, encoding='utf8').read()\n# - 'SetupDevelop' is defined as:\nclass SetupDevelop(setuptools.command.develop.develop):\n    \"\"\"Docstring is overwritten.\"\"\"\n\n    def run(self):\n        \"\"\"\n        Prepare environment for development.\n\n        - Ensures 'nose' and 'coverage.py' are installed for testing.\n        - Call super()'s run method.\n        \"\"\"\n        subprocess.check_call(('pip', 'install', 'nose', 'coverage'))\n\n        # Call super() (except develop is an old-style class, so we must call\n        # directly). The effect is that the development egg-link is installed.\n        setuptools.command.develop.develop.run(self)\n",
              "triple_sequences": [
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Get script file path",
                  "intention_id": "get_script_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.dirname(__file__), fname",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "io.open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "path, encoding='utf8'",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "('pip', 'install', 'nose', 'coverage')",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Install multiple Python packages",
                  "intention_id": "install_multiple_python_packages"
                },
                {
                  "action_api": "setuptools.command.develop.develop.run()",
                  "action_description": "Executes setuptools development procedure",
                  "action_id": "exec_setuptools_dev",
                  "object": "self",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Trigger main behavioral logic",
                  "intention_id": "trigger_main_behavioral_logic"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "aggdraw-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/aggdraw-1.3.19.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/aggdraw-1.3.19/aggdraw-1.3.19/setup.py",
          "line_number": "61",
          "type_description": "code-execution",
          "context_snippet": "import subprocess\n\ndef _get_freetype_config():\n    print(\"Trying freetype-config to find freetype library...\")\n    try:\n        # pointer to freetype build directory (tweak as necessary)\n        return subprocess.check_output(\n            ['freetype-config', '--prefix']).strip().replace(\n            b'\"', b'').decode()\n    except (OSError, subprocess.CalledProcessError):\n        return None",
          "hash_value": "eb41c2294b50699bcad7ea02b1fd2a0c",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import subprocess\n\ndef _get_freetype_config():\n    print(\"Trying freetype-config to find freetype library...\")\n    try:\n        # pointer to freetype build directory (tweak as necessary)\n        return subprocess.check_output(\n            ['freetype-config', '--prefix']).strip().replace(\n            b'\"', b'').decode()\n    except (OSError, subprocess.CalledProcessError):\n        return None",
              "triple_sequences": [
                {
                  "action_api": "print()",
                  "action_description": "Writes text to standard output",
                  "action_id": "get_stdout_stream",
                  "object": "\"Trying freetype-config to find freetype library...\"",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "['freetype-config', '--prefix']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "bytes.strip()",
                  "action_description": "Basic read operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "bytes.replace()",
                  "action_description": "Basic read operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "b'\"', b''",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "bytes.decode()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pycurl-7",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pycurl-7.45.6.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pycurl-7.45.6/pycurl-7.45.6/setup.py",
          "line_number": "116",
          "type_description": "code-execution",
          "context_snippet": "import glob, os, re, shlex, sys, subprocess\n\nclass ConfigurationError(exception_base):\n    pass\n\nclass ExtensionConfiguration(object):\n    def detect_features(self):\n        p = subprocess.Popen((self.curl_config(), '--features'),\n            stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        stdout, stderr = p.communicate()\n        if p.wait() != 0:\n            msg = \"Problem running `%s' --features\" % self.curl_config()\n            if stderr:\n                msg += \":\\n\" + stderr.decode()\n            raise ConfigurationError(msg)\n        curl_has_ssl = False\n        for feature in shlex.split(stdout.decode()):\n            if feature == 'SSL':\n                # this means any ssl library, not just openssl.\n                # we set the ssl flag to check for ssl library mismatch\n                # at link time and run time\n                self.define_macros.append(('HAVE_CURL_SSL', 1))\n                curl_has_ssl = True\n        self.curl_has_ssl = curl_has_ssl\n\ndef scan_argv(argv, s, default=None):\n    p = default\n    i = 1\n    while i < len(argv):\n        arg = argv[i]\n        if s.endswith('='):\n            if str.find(arg, s) == 0:\n                # --option=value\n                p = arg[len(s):]\n                if s != '--openssl-lib-name=':\n                    assert p, arg\n                del argv[i]\n            else:\n                i += 1\n        else:\n            if s == arg:\n                # --option\n                # set value to True\n                p = True\n                del argv[i]\n            else:\n                i = i + 1\n    ##print argv\n    return p\n",
          "hash_value": "1d2aeafd9091f363d1acb756559529ad",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import glob, os, re, shlex, sys, subprocess\n\nclass ConfigurationError(exception_base):\n    pass\n\nclass ExtensionConfiguration(object):\n    def detect_features(self):\n        p = subprocess.Popen((self.curl_config(), '--features'),\n            stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        stdout, stderr = p.communicate()\n        if p.wait() != 0:\n            msg = \"Problem running `%s' --features\" % self.curl_config()\n            if stderr:\n                msg += \":\\n\" + stderr.decode()\n            raise ConfigurationError(msg)\n        curl_has_ssl = False\n        for feature in shlex.split(stdout.decode()):\n            if feature == 'SSL':\n                # this means any ssl library, not just openssl.\n                # we set the ssl flag to check for ssl library mismatch\n                # at link time and run time\n                self.define_macros.append(('HAVE_CURL_SSL', 1))\n                curl_has_ssl = True\n        self.curl_has_ssl = curl_has_ssl\n\ndef scan_argv(argv, s, default=None):\n    p = default\n    i = 1\n    while i < len(argv):\n        arg = argv[i]\n        if s.endswith('='):\n            if str.find(arg, s) == 0:\n                # --option=value\n                p = arg[len(s):]\n                if s != '--openssl-lib-name=':\n                    assert p, arg\n                del argv[i]\n            else:\n                i += 1\n        else:\n            if s == arg:\n                # --option\n                # set value to True\n                p = True\n                del argv[i]\n            else:\n                i = i + 1\n    ##print argv\n    return p\n",
              "triple_sequences": [
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "(self.curl_config(), '--features')",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.PIPE",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "stdout",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "subprocess.PIPE",
                  "action_description": "Reads all bytes from process standard error",
                  "action_id": "read_process_stderr",
                  "object": "stderr",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "p.communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "p.wait()",
                  "action_description": "Waits for process to complete execution",
                  "action_id": "wait_process_completion",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Wait for events",
                  "intention_id": "wait_for_events"
                },
                {
                  "action_api": "stderr.decode()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "stderr",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                },
                {
                  "action_api": "stdout.decode()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "stdout",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                },
                {
                  "action_api": "shlex.split()",
                  "action_description": "Splits string into tokens using shell-like syntax",
                  "action_id": "path_string_operations",
                  "object": "stdout.decode()",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "str.find()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "arg, s",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "dython-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/dython-0.7.9.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/dython-0.7.9/dython-0.7.9/setup.py",
          "line_number": "9",
          "type_description": "shady-links",
          "context_snippet": "import pathlib\nfrom setuptools import setup, find_packages\n\nHERE = pathlib.Path(__file__).parent.resolve()\n\nPACKAGE_NAME = \"dython\"\nAUTHOR = \"Shaked Zychlinski\"\nAUTHOR_EMAIL = \"shakedzy@gmail.com\"\nURL = \"http://shakedzy.xyz/dython\"\nDOWNLOAD_URL = \"https://pypi.org/project/dython/\"\n\nLICENSE = \"MIT\"\nVERSION = (HERE / \"VERSION\").read_text(encoding=\"utf8\").strip()\nDESCRIPTION = \"A set of data tools in Python\"\nLONG_DESCRIPTION = (HERE / \"README.md\").read_text(encoding=\"utf8\")\nLONG_DESC_TYPE = \"text/markdown\"\n\nrequirements = (HERE / \"requirements.txt\").read_text(encoding=\"utf8\")\nINSTALL_REQUIRES = [s.strip() for s in requirements.split(\"\\n\")]\n\ndev_requirements = (HERE / \"dev_requirements.txt\").read_text(encoding=\"utf8\")\nEXTRAS_REQUIRE = {\"dev\": [s.strip() for s in dev_requirements.split(\"\\n\")]}\n\nmin_minor = 9\nmax_minor = 12\nCLASSIFIERS = [\n    f\"Programming Language :: Python :: 3.{str(v)}\" for v in range(min_minor, max_minor+1)\n]\nPYTHON_REQUIRES = f\">=3.{min_minor}\"\n\nsetup(\n    name=PACKAGE_NAME,\n    version=VERSION,\n    description=DESCRIPTION,\n    long_description=LONG_DESCRIPTION,\n    long_description_content_type=LONG_DESC_TYPE,\n    author=AUTHOR,\n    license=LICENSE,\n    author_email=AUTHOR_EMAIL,\n    url=URL,\n    download_url=DOWNLOAD_URL,\n    python_requires=PYTHON_REQUIRES,\n    install_requires=INSTALL_REQUIRES,\n    extras_require=EXTRAS_REQUIRE,\n    packages=find_packages(),\n    classifiers=CLASSIFIERS,\n)",
          "hash_value": "cf92302fc243609b8da84fad76266a8c",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import pathlib\nfrom setuptools import setup, find_packages\n\nHERE = pathlib.Path(__file__).parent.resolve()\n\nPACKAGE_NAME = \"dython\"\nAUTHOR = \"Shaked Zychlinski\"\nAUTHOR_EMAIL = \"shakedzy@gmail.com\"\nURL = \"http://shakedzy.xyz/dython\"\nDOWNLOAD_URL = \"https://pypi.org/project/dython/\"\n\nLICENSE = \"MIT\"\nVERSION = (HERE / \"VERSION\").read_text(encoding=\"utf8\").strip()\nDESCRIPTION = \"A set of data tools in Python\"\nLONG_DESCRIPTION = (HERE / \"README.md\").read_text(encoding=\"utf8\")\nLONG_DESC_TYPE = \"text/markdown\"\n\nrequirements = (HERE / \"requirements.txt\").read_text(encoding=\"utf8\")\nINSTALL_REQUIRES = [s.strip() for s in requirements.split(\"\\n\")]\n\ndev_requirements = (HERE / \"dev_requirements.txt\").read_text(encoding=\"utf8\")\nEXTRAS_REQUIRE = {\"dev\": [s.strip() for s in dev_requirements.split(\"\\n\")]}\n\nmin_minor = 9\nmax_minor = 12\nCLASSIFIERS = [\n    f\"Programming Language :: Python :: 3.{str(v)}\" for v in range(min_minor, max_minor+1)\n]\nPYTHON_REQUIRES = f\">=3.{min_minor}\"\n\nsetup(\n    name=PACKAGE_NAME,\n    version=VERSION,\n    description=DESCRIPTION,\n    long_description=LONG_DESCRIPTION,\n    long_description_content_type=LONG_DESC_TYPE,\n    author=AUTHOR,\n    license=LICENSE,\n    author_email=AUTHOR_EMAIL,\n    url=URL,\n    download_url=DOWNLOAD_URL,\n    python_requires=PYTHON_REQUIRES,\n    install_requires=INSTALL_REQUIRES,\n    extras_require=EXTRAS_REQUIRE,\n    packages=find_packages(),\n    classifiers=CLASSIFIERS,\n)",
              "triple_sequences": [
                {
                  "action_api": "pathlib.Path()",
                  "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
                  "action_id": "path_object_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Prepare path for file operations",
                  "intention_id": "prepare_path_file_operations"
                },
                {
                  "action_api": "pathlib.Path.resolve()",
                  "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
                  "action_id": "path_object_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare path for file operations",
                  "intention_id": "prepare_path_file_operations"
                },
                {
                  "action_api": "pathlib.Path.read_text()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "VERSION",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "pathlib.Path.read_text()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "README.md",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "pathlib.Path.read_text()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "requirements.txt",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "requirements (contents of requirements.txt)",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "str.strip()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "requirement line",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "pathlib.Path.read_text()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "dev_requirements.txt",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "dev_requirements (contents of dev_requirements.txt)",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "str.strip()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "dev requirement line",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "PACKAGE_NAME, VERSION, DESCRIPTION, LONG_DESCRIPTION, LONG_DESC_TYPE, AUTHOR, LICENSE, AUTHOR_EMAIL, URL, DOWNLOAD_URL, PYTHON_REQUIRES, INSTALL_REQUIRES, EXTRAS_REQUIRE, find_packages(), CLASSIFIERS",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                },
                {
                  "action_api": "find_packages()",
                  "action_description": "Executes setuptools development procedure",
                  "action_id": "exec_setuptools_dev",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Import required module",
                  "intention_id": "import_required_module"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "haystack_ai-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/haystack_ai-2.12.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "type_serialization.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/haystack_ai-2.12.1/haystack_ai-2.12.1/haystack/utils/type_serialization.py",
          "line_number": "142",
          "type_description": "obfuscation",
          "context_snippet": "import builtins\nimport typing\nfrom haystack.core.errors import DeserializationError\n\ndef deserialize_type(type_str: str) -> Any:  # pylint: disable=too-many-return-statements\n    \"\"\"\n    Deserializes a type given its full import path as a string, including nested generic types.\n\n    This function will dynamically import the module if it's not already imported\n    and then retrieve the type object from it. It also handles nested generic types like\n    `typing.List[typing.Dict[int, str]]`.\n\n    :param type_str:\n        The string representation of the type's full import path.\n    :returns:\n        The deserialized type object.\n    :raises DeserializationError:\n        If the type cannot be deserialized due to missing module or type.\n    \"\"\"\n\n    type_mapping = {\n        list: typing.List,\n        dict: typing.Dict,\n        set: typing.Set,\n        tuple: typing.Tuple,\n        frozenset: typing.FrozenSet,\n    }\n\n    # Handle generics\n    if \"[\" in type_str and type_str.endswith(\"]\"):\n        main_type_str, generics_str = type_str.split(\"[\", 1)\n        generics_str = generics_str[:-1]\n\n        main_type = deserialize_type(main_type_str)\n        generic_args = [deserialize_type(arg) for arg in _parse_generic_args(generics_str)]\n\n        # Reconstruct\n        try:\n            if sys.version_info >= (3, 9) or repr(main_type).startswith(\"typing.\"):\n                return main_type[tuple(generic_args) if len(generic_args) > 1 else generic_args[0]]\n            else:\n                return type_mapping[main_type][tuple(generic_args) if len(generic_args) > 1 else generic_args[0]]\n        except (TypeError, AttributeError) as e:\n            raise DeserializationError(f\"Could not apply arguments {generic_args} to type {main_type}\") from e\n\n    # Handle non-generic types\n    # First, check if there's a module prefix\n    if \".\" in type_str:\n        parts = type_str.split(\".\")\n        module_name = \".\".join(parts[:-1])\n        type_name = parts[-1]\n\n        module = sys.modules.get(module_name)\n        if module is None:\n            try:\n                module = thread_safe_import(module_name)\n            except ImportError as e:\n                raise DeserializationError(f\"Could not import the module: {module_name}\") from e\n\n        # Get the class from the module\n        if hasattr(module, type_name):\n            return getattr(module, type_name)\n\n        raise DeserializationError(f\"Could not locate the type: {type_name} in the module: {module_name}\")\n\n    # No module prefix, check builtins and typing\n    # First check builtins\n    if hasattr(builtins, type_str):\n        return getattr(builtins, type_str)\n\n    # Then check typing\n    if hasattr(typing, type_str):\n        return getattr(typing, type_str)\n\n    # Special case for NoneType\n    if type_str == \"NoneType\":\n        return type(None)\n\n    # Special case for None\n    if type_str == \"None\":\n        return None\n\n    raise DeserializationError(f\"Could not deserialize type: {type_str}\")",
          "hash_value": "f99500deda7ceb92078c0dd3c5fcfc2b",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import builtins\nimport typing\nfrom haystack.core.errors import DeserializationError\n\ndef deserialize_type(type_str: str) -> Any:  # pylint: disable=too-many-return-statements\n    \"\"\"\n    Deserializes a type given its full import path as a string, including nested generic types.\n\n    This function will dynamically import the module if it's not already imported\n    and then retrieve the type object from it. It also handles nested generic types like\n    `typing.List[typing.Dict[int, str]]`.\n\n    :param type_str:\n        The string representation of the type's full import path.\n    :returns:\n        The deserialized type object.\n    :raises DeserializationError:\n        If the type cannot be deserialized due to missing module or type.\n    \"\"\"\n\n    type_mapping = {\n        list: typing.List,\n        dict: typing.Dict,\n        set: typing.Set,\n        tuple: typing.Tuple,\n        frozenset: typing.FrozenSet,\n    }\n\n    # Handle generics\n    if \"[\" in type_str and type_str.endswith(\"]\"):\n        main_type_str, generics_str = type_str.split(\"[\", 1)\n        generics_str = generics_str[:-1]\n\n        main_type = deserialize_type(main_type_str)\n        generic_args = [deserialize_type(arg) for arg in _parse_generic_args(generics_str)]\n\n        # Reconstruct\n        try:\n            if sys.version_info >= (3, 9) or repr(main_type).startswith(\"typing.\"):\n                return main_type[tuple(generic_args) if len(generic_args) > 1 else generic_args[0]]\n            else:\n                return type_mapping[main_type][tuple(generic_args) if len(generic_args) > 1 else generic_args[0]]\n        except (TypeError, AttributeError) as e:\n            raise DeserializationError(f\"Could not apply arguments {generic_args} to type {main_type}\") from e\n\n    # Handle non-generic types\n    # First, check if there's a module prefix\n    if \".\" in type_str:\n        parts = type_str.split(\".\")\n        module_name = \".\".join(parts[:-1])\n        type_name = parts[-1]\n\n        module = sys.modules.get(module_name)\n        if module is None:\n            try:\n                module = thread_safe_import(module_name)\n            except ImportError as e:\n                raise DeserializationError(f\"Could not import the module: {module_name}\") from e\n\n        # Get the class from the module\n        if hasattr(module, type_name):\n            return getattr(module, type_name)\n\n        raise DeserializationError(f\"Could not locate the type: {type_name} in the module: {module_name}\")\n\n    # No module prefix, check builtins and typing\n    # First check builtins\n    if hasattr(builtins, type_str):\n        return getattr(builtins, type_str)\n\n    # Then check typing\n    if hasattr(typing, type_str):\n        return getattr(typing, type_str)\n\n    # Special case for NoneType\n    if type_str == \"NoneType\":\n        return type(None)\n\n    # Special case for None\n    if type_str == \"None\":\n        return None\n\n    raise DeserializationError(f\"Could not deserialize type: {type_str}\")",
              "triple_sequences": [
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "type_str.split(\"[\", 1)",
                  "object_description": "String containing environment data",
                  "object_id": "string_environment_data",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "str.endswith()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "type_str.endswith(\"]\")",
                  "object_description": "String containing environment data",
                  "object_id": "string_environment_data",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "deserialize_type()",
                  "action_description": "Dynamically imports specified module",
                  "action_id": "import_dynamic",
                  "object": "main_type_str",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "_parse_generic_args()",
                  "action_description": "Dynamically imports specified module",
                  "action_id": "import_dynamic",
                  "object": "generics_str",
                  "object_description": "String containing environment data",
                  "object_id": "string_environment_data",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "deserialize_type()",
                  "action_description": "Dynamically imports specified module",
                  "action_id": "import_dynamic",
                  "object": "arg",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "sys.version_info",
                  "action_description": "Retrieves operating system version",
                  "action_id": "get_os_version",
                  "object": "sys.version_info",
                  "object_description": "System info",
                  "object_id": "system_info",
                  "intention_description": "Get operating system version",
                  "intention_id": "get_operating_system_version"
                },
                {
                  "action_api": "repr()",
                  "action_description": "Serializes Python object to JSON string",
                  "action_id": "serialize_to_json",
                  "object": "main_type",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Serialize data",
                  "intention_id": "serialize_data"
                },
                {
                  "action_api": "sys.modules.get()",
                  "action_description": "Dynamically imports specified module",
                  "action_id": "import_dynamic",
                  "object": "module_name",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "thread_safe_import()",
                  "action_description": "Dynamically imports specified module",
                  "action_id": "import_dynamic",
                  "object": "module_name",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "hasattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "module, type_name",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "module, type_name",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "hasattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, type_str",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, type_str",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "hasattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "typing, type_str",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "typing, type_str",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "xmlsec-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/xmlsec-1.3.15.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/xmlsec-1.3.15/xmlsec-1.3.15/setup.py",
          "line_number": "438",
          "type_description": "code-execution",
          "context_snippet": "def prepare_static_build(self, build_platform):\n    ...\n    self.info('Building OpenSSL')\n    openssl_dir = next(self.build_libs_dir.glob('openssl-*'))\n    openssl_config_cmd = [prefix_arg, 'no-shared', '-fPIC', '--libdir=lib']\n    if cross_compiling:\n        openssl_config_cmd.insert(0, './Configure')\n        openssl_config_cmd.append(cross_compiling.triplet)\n    else:\n        openssl_config_cmd.insert(0, './config')\n    subprocess.check_output(openssl_config_cmd, cwd=str(openssl_dir), env=env)\n    subprocess.check_output(['make', '-j{}'.format(multiprocessing.cpu_count() + 1)], cwd=str(openssl_dir), env=env)\n    subprocess.check_output(\n        ['make', '-j{}'.format(multiprocessing.cpu_count() + 1), 'install_sw'], cwd=str(openssl_dir), env=env\n    )\n    ...",
          "hash_value": "a6b688384ec48490c3ef6a918fc227cf",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def prepare_static_build(self, build_platform):\n    ...\n    self.info('Building OpenSSL')\n    openssl_dir = next(self.build_libs_dir.glob('openssl-*'))\n    openssl_config_cmd = [prefix_arg, 'no-shared', '-fPIC', '--libdir=lib']\n    if cross_compiling:\n        openssl_config_cmd.insert(0, './Configure')\n        openssl_config_cmd.append(cross_compiling.triplet)\n    else:\n        openssl_config_cmd.insert(0, './config')\n    subprocess.check_output(openssl_config_cmd, cwd=str(openssl_dir), env=env)\n    subprocess.check_output(['make', '-j{}'.format(multiprocessing.cpu_count() + 1)], cwd=str(openssl_dir), env=env)\n    subprocess.check_output(\n        ['make', '-j{}'.format(multiprocessing.cpu_count() + 1), 'install_sw'], cwd=str(openssl_dir), env=env\n    )\n    ...",
              "triple_sequences": []
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "python-prctl-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/python-prctl-1.8.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/python-prctl-1.8.1/python-prctl-1.8.1/setup.py",
          "line_number": "31",
          "type_description": "code-execution",
          "context_snippet": "import subprocess\nimport sys\n\nexit = False\ntry:\n    subprocess.call(['gcc','-v'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\nexcept:\n    sys.stderr.write(\"You need to install gcc to build this module\\n\")\n    sys.exit(1)",
          "hash_value": "b4402765a17cf5e043cd8d9e21bc822f",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import subprocess\nimport sys\n\nexit = False\ntry:\n    subprocess.call(['gcc','-v'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\nexcept:\n    sys.stderr.write(\"You need to install gcc to build this module\\n\")\n    sys.exit(1)",
              "triple_sequences": [
                {
                  "action_api": "subprocess.call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "['gcc','-v']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "sys.stderr.write()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "You need to install gcc to build this module\n",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "1",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "dscribe-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/dscribe-2.1.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/dscribe-2.1.1/dscribe-2.1.1/setup.py",
          "line_number": "19",
          "type_description": "code-execution",
          "context_snippet": "from distutils.ccompiler import new_compiler\nfrom distutils.sysconfig import customize_compiler\nfrom subprocess import getoutput\n\ndef using_clang():\n    \"\"\"Will we be using a clang compiler?\n    \"\"\"\n    compiler = new_compiler()\n    customize_compiler(compiler)\n    compiler_ver = getoutput(\"{0} -v\".format(compiler.compiler[0]))\n    return \"clang\" in compiler_ver",
          "hash_value": "777228e7bbaa78c179330877dc6f29ca",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from distutils.ccompiler import new_compiler\nfrom distutils.sysconfig import customize_compiler\nfrom subprocess import getoutput\n\ndef using_clang():\n    \"\"\"Will we be using a clang compiler?\n    \"\"\"\n    compiler = new_compiler()\n    customize_compiler(compiler)\n    compiler_ver = getoutput(\"{0} -v\".format(compiler.compiler[0]))\n    return \"clang\" in compiler_ver",
              "triple_sequences": [
                {
                  "action_api": "distutils.ccompiler.new_compiler()",
                  "action_description": "Initializes Git command wrapper",
                  "action_id": "init_git_wrapper",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare executable string",
                  "intention_id": "prepare_executable_string"
                },
                {
                  "action_api": "distutils.sysconfig.customize_compiler()",
                  "action_description": "Initializes Git command wrapper",
                  "action_id": "init_git_wrapper",
                  "object": "compiler",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare executable string",
                  "intention_id": "prepare_executable_string"
                },
                {
                  "action_api": "subprocess.getoutput()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "{0} -v",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "wsaccel-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/wsaccel-0.6.7.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/wsaccel-0.6.7/wsaccel-0.6.7/setup.py",
          "line_number": "18",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport sys\nimport subprocess\n\ndef cythonize(src):\n    sys.stderr.write(\"cythonize: %r\\n\" % (src,))\n    subprocess.check_call(\"cython %s\" % (src,), shell=True)",
          "hash_value": "c593cc2a4a4c66e0ff33ddb76051ef4d",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport sys\nimport subprocess\n\ndef cythonize(src):\n    sys.stderr.write(\"cythonize: %r\\n\" % (src,))\n    subprocess.check_call(\"cython %s\" % (src,), shell=True)",
              "triple_sequences": [
                {
                  "action_api": "sys.stderr.write()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "\"cythonize: %r\\n\" % (src,)",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "\"cython %s\" % (src,)",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "ibm_db-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/ibm_db-3.2.6.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ibm_db-3.2.6/ibm_db-3.2.6/setup.py",
          "line_number": "164",
          "type_description": "code-execution",
          "context_snippet": "if('darwin' in sys.platform):\n    class PostInstall(install):\n        \"\"\" Post installation - run install_name_tool on Darwin \"\"\"\n        def run(self):\n            install.run(self)\n            clipath = os.getenv('IBM_DB_HOME')\n            if not clipath:\n                # no IBM_DB_HOME during install, keep current value\n                return\n\n            for so in glob.glob(get_python_lib()+r'/ibm_db*.so'):\n                os.system(\"install_name_tool -change @loader_path/clidriver/lib/libdb2.dylib {}/lib/libdb2.dylib {}\".format(clipath, so))",
          "hash_value": "c8ea4b39404bbccc6ab8e63f8baedafd",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "if('darwin' in sys.platform):\n    class PostInstall(install):\n        \"\"\" Post installation - run install_name_tool on Darwin \"\"\"\n        def run(self):\n            install.run(self)\n            clipath = os.getenv('IBM_DB_HOME')\n            if not clipath:\n                # no IBM_DB_HOME during install, keep current value\n                return\n\n            for so in glob.glob(get_python_lib()+r'/ibm_db*.so'):\n                os.system(\"install_name_tool -change @loader_path/clidriver/lib/libdb2.dylib {}/lib/libdb2.dylib {}\".format(clipath, so))",
              "triple_sequences": [
                {
                  "action_api": "sys.platform",
                  "action_description": "Retrieves operating system identifier",
                  "action_id": "get_os_id",
                  "object": "sys.platform",
                  "object_description": "Operating system identifier",
                  "object_id": "",
                  "intention_description": "Determine operating system",
                  "intention_id": "determine_operating_system"
                },
                {
                  "action_api": "os.getenv()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "IBM_DB_HOME",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "glob.glob()",
                  "action_description": "List directory contents",
                  "action_id": "list_directory_contents",
                  "object": "get_python_lib()+r'/ibm_db*.so'",
                  "object_description": "Local file or directory name",
                  "object_id": "local_file_or_directory_name",
                  "intention_description": "List files in directory",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "install_name_tool -change @loader_path/clidriver/lib/libdb2.dylib {}/lib/libdb2.dylib {}",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "treelite_runtime-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/treelite_runtime-3.9.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/treelite_runtime-3.9.1/treelite_runtime-3.9.1/setup.py",
          "line_number": "254",
          "type_description": "cmd-overwrite",
          "context_snippet": "if __name__ == '__main__':\n    # Supported commands:\n    # From PyPI:\n    # - pip install treelite_runtime\n    # From source tree `treelite/runtime/python`:\n    # - python setup.py install\n    # - python setup.py bdist_wheel && pip install <wheel-name>\n    logging.basicConfig(level=logging.INFO)\n    setup(name='treelite_runtime',\n          version=open(os.path.join(CURRENT_DIR, 'treelite_runtime/VERSION')).read().strip(),\n          description='Treelite runtime',\n          install_requires=['numpy', 'scipy'],\n          ext_modules=[CMakeExtension('libtreelite_runtime')],\n          cmdclass={\n              'build_ext': BuildExt,\n              'sdist': SDist,\n              'install_lib': InstallLib,\n              'install': Install\n          },\n          author='DMLC',\n          maintainer='Hyunsu Cho',\n          maintainer_email='chohyu01@cs.washington.edu',\n          zip_safe=False,\n          packages=find_packages(),\n          include_package_data=True,\n          license='Apache-2.0',\n          classifiers=['License :: OSI Approved :: Apache Software License',\n                       'Development Status :: 5 - Production/Stable',\n                       'Operating System :: OS Independent',\n                       'Programming Language :: Python',\n                       'Programming Language :: Python :: 3',\n                       'Programming Language :: Python :: 3.7',\n                       'Programming Language :: Python :: 3.8'],\n          python_requires='>=3.7',\n          url='https://github.com/dmlc/treelite')\n\n    clean_up()",
          "hash_value": "fc348808a1ea0b6640ee6c2d596bab3d",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "if __name__ == '__main__':\n    # Supported commands:\n    # From PyPI:\n    # - pip install treelite_runtime\n    # From source tree `treelite/runtime/python`:\n    # - python setup.py install\n    # - python setup.py bdist_wheel && pip install <wheel-name>\n    logging.basicConfig(level=logging.INFO)\n    setup(name='treelite_runtime',\n          version=open(os.path.join(CURRENT_DIR, 'treelite_runtime/VERSION')).read().strip(),\n          description='Treelite runtime',\n          install_requires=['numpy', 'scipy'],\n          ext_modules=[CMakeExtension('libtreelite_runtime')],\n          cmdclass={\n              'build_ext': BuildExt,\n              'sdist': SDist,\n              'install_lib': InstallLib,\n              'install': Install\n          },\n          author='DMLC',\n          maintainer='Hyunsu Cho',\n          maintainer_email='chohyu01@cs.washington.edu',\n          zip_safe=False,\n          packages=find_packages(),\n          include_package_data=True,\n          license='Apache-2.0',\n          classifiers=['License :: OSI Approved :: Apache Software License',\n                       'Development Status :: 5 - Production/Stable',\n                       'Operating System :: OS Independent',\n                       'Programming Language :: Python',\n                       'Programming Language :: Python :: 3',\n                       'Programming Language :: Python :: 3.7',\n                       'Programming Language :: Python :: 3.8'],\n          python_requires='>=3.7',\n          url='https://github.com/dmlc/treelite')\n\n    clean_up()",
              "triple_sequences": [
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "os.path.join(CURRENT_DIR, 'treelite_runtime/VERSION')",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "str.strip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "name='treelite_runtime', version=..., description='Treelite runtime', install_requires=['numpy', 'scipy'], ext_modules=[CMakeExtension('libtreelite_runtime')], cmdclass={...}, author='DMLC', maintainer='Hyunsu Cho', maintainer_email='chohyu01@cs.washington.edu', zip_safe=False, packages=find_packages(), include_package_data=True, license='Apache-2.0', classifiers=[...], python_requires='>=3.7', url='https://github.com/dmlc/treelite'",
                  "object_description": "Python command",
                  "object_id": "python_command",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                },
                {
                  "action_api": "clean_up()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Release system resource",
                  "intention_id": "release_system_resource"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "certbot-4",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/certbot-4.0.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "ops.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/certbot-4.0.0/certbot-4.0.0/certbot/display/ops.py",
          "line_number": "287",
          "type_description": "shady-links",
          "context_snippet": "def _gen_https_names(domains: List[str]) -> str:\n    \"\"\"Returns a string of the https domains.\n\n    Domains are formatted nicely with ``https://`` prepended to each.\n\n    :param list domains: Each domain is a 'str'\n\n    \"\"\"\n    if len(domains) == 1:\n        return \"https://{0}\".format(domains[0])\n    elif len(domains) == 2:\n        return \"https://{dom[0]} and https://{dom[1]}\".format(dom=domains)\n    elif len(domains) > 2:\n        return \"{0}{1}{2}\".format(\n            \", \".join(\"https://%s\" % dom for dom in domains[:-1]),\n            \", and https://\",\n            domains[-1])\n\n    return \"\"",
          "hash_value": "497e6f285af1c9a747427fef9d0fdf56",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def _gen_https_names(domains: List[str]) -> str:\n    \"\"\"Returns a string of the https domains.\n\n    Domains are formatted nicely with ``https://`` prepended to each.\n\n    :param list domains: Each domain is a 'str'\n\n    \"\"\"\n    if len(domains) == 1:\n        return \"https://{0}\".format(domains[0])\n    elif len(domains) == 2:\n        return \"https://{dom[0]} and https://{dom[1]}\".format(dom=domains)\n    elif len(domains) > 2:\n        return \"{0}{1}{2}\".format(\n            \", \".join(\"https://%s\" % dom for dom in domains[:-1]),\n            \", and https://\",\n            domains[-1])\n\n    return \"\"",
              "triple_sequences": [
                {
                  "action_api": "str.format()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "\"https://{0}\".format(domains[0])",
                  "object_description": "Domain name string",
                  "object_id": "domain_name",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "str.format()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "\"https://{dom[0]} and https://{dom[1]}\".format(dom=domains)",
                  "object_description": "Domain name string",
                  "object_id": "domain_name",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "str.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "\", \".join(\"https://%s\" % dom for dom in domains[:-1])",
                  "object_description": "Domain name string",
                  "object_id": "domain_name",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "str.format()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "\"{0}{1}{2}\".format(\", \".join(\"https://%s\" % dom for dom in domains[:-1]), \", and https://\", domains[-1])",
                  "object_description": "Domain name string",
                  "object_id": "domain_name",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "ntgcalls-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/ntgcalls-1.3.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ntgcalls-1.3.3/ntgcalls-1.3.3/deps/pybind11/setup.py",
          "line_number": "138",
          "type_description": "code-execution",
          "context_snippet": "with remove_output(\"pybind11/include\", \"pybind11/share\"):\n    # Generate the files if they are not present.\n    with TemporaryDirectory() as tmpdir:\n        cmd = [\"cmake\", \"-S\", \".\", \"-B\", tmpdir] + [\n            \"-DCMAKE_INSTALL_PREFIX=pybind11\",\n            \"-DBUILD_TESTING=OFF\",\n            \"-DPYBIND11_NOPYTHON=ON\",\n            \"-Dprefix_for_pc_file=${pcfiledir}/../../\",\n        ]\n        if \"CMAKE_ARGS\" in os.environ:\n            fcommand = [\n                c\n                for c in os.environ[\"CMAKE_ARGS\"].split()\n                if \"DCMAKE_INSTALL_PREFIX\" not in c\n            ]\n            cmd += fcommand\n        subprocess.run(cmd, check=True, cwd=DIR, stdout=sys.stdout, stderr=sys.stderr)\n        subprocess.run(\n            [\"cmake\", \"--install\", tmpdir],\n            check=True,\n            cwd=DIR,\n            stdout=sys.stdout,\n            stderr=sys.stderr,\n        )",
          "hash_value": "b70511a5aec8110591ad3e376676d74e",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "with remove_output(\"pybind11/include\", \"pybind11/share\"):\n    # Generate the files if they are not present.\n    with TemporaryDirectory() as tmpdir:\n        cmd = [\"cmake\", \"-S\", \".\", \"-B\", tmpdir] + [\n            \"-DCMAKE_INSTALL_PREFIX=pybind11\",\n            \"-DBUILD_TESTING=OFF\",\n            \"-DPYBIND11_NOPYTHON=ON\",\n            \"-Dprefix_for_pc_file=${pcfiledir}/../../\",\n        ]\n        if \"CMAKE_ARGS\" in os.environ:\n            fcommand = [\n                c\n                for c in os.environ[\"CMAKE_ARGS\"].split()\n                if \"DCMAKE_INSTALL_PREFIX\" not in c\n            ]\n            cmd += fcommand\n        subprocess.run(cmd, check=True, cwd=DIR, stdout=sys.stdout, stderr=sys.stderr)\n        subprocess.run(\n            [\"cmake\", \"--install\", tmpdir],\n            check=True,\n            cwd=DIR,\n            stdout=sys.stdout,\n            stderr=sys.stderr,\n        )",
              "triple_sequences": [
                {
                  "action_api": "os.environ.__contains__()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "\"CMAKE_ARGS\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.__getitem__()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"CMAKE_ARGS\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.environ[\"CMAKE_ARGS\"]",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "cmd",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "[\"cmake\", \"--install\", tmpdir]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "xatlas-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/xatlas-0.0.10.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/xatlas-0.0.10/xatlas-0.0.10/extern/pybind11/setup.py",
          "line_number": "138",
          "type_description": "code-execution",
          "context_snippet": "import contextlib\nimport os\nimport shutil\nimport subprocess\nimport sys\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\n\nDIR = Path(__file__).parent.absolute()\n\nwith contextlib.contextmanager\ndef remove_output(*sources: str):\n    try:\n        yield\n    finally:\n        for src in sources:\n            shutil.rmtree(src)\n\nwith remove_output(\"pybind11/include\", \"pybind11/share\"):\n    # Generate the files if they are not present.\n    with TemporaryDirectory() as tmpdir:\n        cmd = [\"cmake\", \"-S\", \".\", \"-B\", tmpdir] + [\n            \"-DCMAKE_INSTALL_PREFIX=pybind11\",\n            \"-DBUILD_TESTING=OFF\",\n            \"-DPYBIND11_NOPYTHON=ON\",\n            \"-Dprefix_for_pc_file=${pcfiledir}/../../\",\n        ]\n        if \"CMAKE_ARGS\" in os.environ:\n            fcommand = [\n                c\n                for c in os.environ[\"CMAKE_ARGS\"].split()\n                if \"DCMAKE_INSTALL_PREFIX\" not in c\n            ]\n            cmd += fcommand\n        subprocess.run(cmd, check=True, cwd=DIR, stdout=sys.stdout, stderr=sys.stderr)\n        subprocess.run(\n            [\"cmake\", \"--install\", tmpdir],\n            check=True,\n            cwd=DIR,\n            stdout=sys.stdout,\n            stderr=sys.stderr,\n        )",
          "hash_value": "6a9c480244cf23501069b1c82f30c83b",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import contextlib\nimport os\nimport shutil\nimport subprocess\nimport sys\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\n\nDIR = Path(__file__).parent.absolute()\n\nwith contextlib.contextmanager\ndef remove_output(*sources: str):\n    try:\n        yield\n    finally:\n        for src in sources:\n            shutil.rmtree(src)\n\nwith remove_output(\"pybind11/include\", \"pybind11/share\"):\n    # Generate the files if they are not present.\n    with TemporaryDirectory() as tmpdir:\n        cmd = [\"cmake\", \"-S\", \".\", \"-B\", tmpdir] + [\n            \"-DCMAKE_INSTALL_PREFIX=pybind11\",\n            \"-DBUILD_TESTING=OFF\",\n            \"-DPYBIND11_NOPYTHON=ON\",\n            \"-Dprefix_for_pc_file=${pcfiledir}/../../\",\n        ]\n        if \"CMAKE_ARGS\" in os.environ:\n            fcommand = [\n                c\n                for c in os.environ[\"CMAKE_ARGS\"].split()\n                if \"DCMAKE_INSTALL_PREFIX\" not in c\n            ]\n            cmd += fcommand\n        subprocess.run(cmd, check=True, cwd=DIR, stdout=sys.stdout, stderr=sys.stderr)\n        subprocess.run(\n            [\"cmake\", \"--install\", tmpdir],\n            check=True,\n            cwd=DIR,\n            stdout=sys.stdout,\n            stderr=sys.stderr,\n        )",
              "triple_sequences": [
                {
                  "action_api": "shutil.rmtree()",
                  "action_description": "Recursively deletes directory and its contents",
                  "action_id": "delete_directory",
                  "object": "pybind11/include",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Delete directory content",
                  "intention_id": "delete_directory_content"
                },
                {
                  "action_api": "shutil.rmtree()",
                  "action_description": "Recursively deletes directory and its contents",
                  "action_id": "delete_directory",
                  "object": "pybind11/share",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Delete directory content",
                  "intention_id": "delete_directory_content"
                },
                {
                  "action_api": "TemporaryDirectory()",
                  "action_description": "Creates temporary directory and returns its path",
                  "action_id": "create_temp_dir",
                  "object": "",
                  "object_description": "Temporary directory",
                  "object_id": "temporary_directory",
                  "intention_description": "Create temporary directory",
                  "intention_id": "create_temporary_directory"
                },
                {
                  "action_api": "os.environ.__contains__()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "CMAKE_ARGS",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.__getitem__()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "CMAKE_ARGS",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "['cmake', '-S', '.', '-B', tmpdir, '-DCMAKE_INSTALL_PREFIX=pybind11', '-DBUILD_TESTING=OFF', '-DPYBIND11_NOPYTHON=ON', '-Dprefix_for_pc_file=${pcfiledir}/../../'] + fcommand",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "['cmake', '--install', tmpdir]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "torch_tb_profiler-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/torch_tb_profiler-0.4.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/torch_tb_profiler-0.4.3/torch_tb_profiler-0.4.3/setup.py",
          "line_number": "61",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport pathlib\nimport setuptools\nimport subprocess\n\nclass build_fe(setuptools.Command):\n    \"\"\"Build the frontend\"\"\"\n    description = \"run yarn build on frontend directory\"\n\n    user_options = []\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        cwd = pathlib.Path().absolute()\n        root = pathlib.Path(__file__).parent.absolute()\n        os.chdir(root / \"fe\")\n        subprocess.run([\"yarn\", \"build:copy\"], check=True)\n        # restore the working directory\n        os.chdir(cwd)",
          "hash_value": "d45e45acd029bf33ce99e0a8ba0ccbd1",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport pathlib\nimport setuptools\nimport subprocess\n\nclass build_fe(setuptools.Command):\n    \"\"\"Build the frontend\"\"\"\n    description = \"run yarn build on frontend directory\"\n\n    user_options = []\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        cwd = pathlib.Path().absolute()\n        root = pathlib.Path(__file__).parent.absolute()\n        os.chdir(root / \"fe\")\n        subprocess.run([\"yarn\", \"build:copy\"], check=True)\n        # restore the working directory\n        os.chdir(cwd)",
              "triple_sequences": [
                {
                  "action_api": "pathlib.Path().absolute()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "pathlib.Path(__file__).parent.absolute()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "os.chdir()",
                  "action_description": "Changes current working directory",
                  "action_id": "change_working_dir",
                  "object": "root / \"fe\"",
                  "object_description": "Custom directory",
                  "object_id": "custom_directory",
                  "intention_description": "Change working directory",
                  "intention_id": "change_working_directory"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "[\"yarn\", \"build:copy\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.chdir()",
                  "action_description": "Changes current working directory",
                  "action_id": "change_working_dir",
                  "object": "cwd",
                  "object_description": "Custom directory",
                  "object_id": "custom_directory",
                  "intention_description": "Restore previous working directory",
                  "intention_id": "restore_working_directory"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "python_mecab_ko-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/python_mecab_ko-1.3.7.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/python_mecab_ko-1.3.7/python_mecab_ko-1.3.7/setup.py",
          "line_number": "31",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport platform\nimport shutil\nimport site\nimport subprocess\nimport sys\nfrom glob import glob\nfrom pathlib import Path\nfrom typing import Optional\n\nfrom pybind11.setup_helpers import Pybind11Extension, build_ext\nfrom setuptools import setup\n\nis_windows = platform.system() == \"Windows\"\n\nprefix_paths = [\n    Path(sys.prefix),\n    Path(site.getuserbase()),\n    Path.home() / \".local\",\n]\n\n\nclass Executable:\n    def __init__(self, command: str):\n        self._command = command\n\n    def __call__(self, *args) -> str:\n        if self.executable is None:\n            raise RuntimeError(f\"{self._command} not found\")\n\n        return subprocess.check_output([self.executable, *args], encoding=\"utf-8\").strip()\n\n    def exists(self) -> bool:\n        return self.executable is not None\n\n    @property\n    def executable(self) -> Optional[str]:\n        paths = [str(path / \"bin\") for path in prefix_paths]\n        paths.append(os.environ[\"PATH\"])\n        return shutil.which(self._command, path=os.pathsep.join(paths))",
          "hash_value": "8cb7284125c78898622612277c2071f0",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport platform\nimport shutil\nimport site\nimport subprocess\nimport sys\nfrom glob import glob\nfrom pathlib import Path\nfrom typing import Optional\n\nfrom pybind11.setup_helpers import Pybind11Extension, build_ext\nfrom setuptools import setup\n\nis_windows = platform.system() == \"Windows\"\n\nprefix_paths = [\n    Path(sys.prefix),\n    Path(site.getuserbase()),\n    Path.home() / \".local\",\n]\n\n\nclass Executable:\n    def __init__(self, command: str):\n        self._command = command\n\n    def __call__(self, *args) -> str:\n        if self.executable is None:\n            raise RuntimeError(f\"{self._command} not found\")\n\n        return subprocess.check_output([self.executable, *args], encoding=\"utf-8\").strip()\n\n    def exists(self) -> bool:\n        return self.executable is not None\n\n    @property\n    def executable(self) -> Optional[str]:\n        paths = [str(path / \"bin\") for path in prefix_paths]\n        paths.append(os.environ[\"PATH\"])\n        return shutil.which(self._command, path=os.pathsep.join(paths))",
              "triple_sequences": [
                {
                  "action_api": "platform.system()",
                  "action_description": "Retrieves operating system identifier",
                  "action_id": "get_os_id",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine operating system",
                  "intention_id": "determine_operating_system"
                },
                {
                  "action_api": "sys.prefix",
                  "action_description": "Retrieves Python interpreter version",
                  "action_id": "get_python_version",
                  "object": "sys.prefix",
                  "object_description": "Program directory",
                  "object_id": "program_directory",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "site.getuserbase()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "site.getuserbase()",
                  "object_description": "User home directory",
                  "object_id": "user_home_directory",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "Path.home()",
                  "action_description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
                  "action_id": "path_special_operations",
                  "object": "Path.home()",
                  "object_description": "User home directory",
                  "object_id": "user_home_directory",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "os.environ[\"PATH\"]",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "PATH",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "shutil.which()",
                  "action_description": "Retrieves operating system information",
                  "action_id": "get_os_info",
                  "object": "self._command, path=os.pathsep.join(paths)",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Determine file presence",
                  "intention_id": "determine_file_presence"
                },
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[self.executable, *args]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "str.strip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "kr8s-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/kr8s-0.20.6.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "update-kubernetes.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/kr8s-0.20.6/kr8s-0.20.6/ci/update-kubernetes.py",
          "line_number": "24",
          "type_description": "shady-links",
          "context_snippet": "def get_kubernetes_oss_versions():\n    print(\n        \"Loading Kubernetes versions from https://endoflife.date/api/kubernetes.json...\"\n    )\n    with urllib.request.urlopen(\"https://endoflife.date/api/kubernetes.json\") as url:\n        data = json.load(url)\n        data = [\n            {\n                \"cycle\": x[\"cycle\"],\n                \"latest_version\": x[\"latest\"],\n                \"eol\": datetime.strptime(x[\"eol\"], DATE_FORMAT),\n            }\n            for x in data\n            if datetime.strptime(x[\"eol\"], DATE_FORMAT) > datetime.now()\n        ]\n        data.sort(key=lambda x: x[\"eol\"], reverse=True)\n    return data",
          "hash_value": "179cf3c2c300d8627253f27ddcc502eb",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def get_kubernetes_oss_versions():\n    print(\n        \"Loading Kubernetes versions from https://endoflife.date/api/kubernetes.json...\"\n    )\n    with urllib.request.urlopen(\"https://endoflife.date/api/kubernetes.json\") as url:\n        data = json.load(url)\n        data = [\n            {\n                \"cycle\": x[\"cycle\"],\n                \"latest_version\": x[\"latest\"],\n                \"eol\": datetime.strptime(x[\"eol\"], DATE_FORMAT),\n            }\n            for x in data\n            if datetime.strptime(x[\"eol\"], DATE_FORMAT) > datetime.now()\n        ]\n        data.sort(key=lambda x: x[\"eol\"], reverse=True)\n    return data",
              "triple_sequences": [
                {
                  "action_api": "print()",
                  "action_description": "Reads user input from standard input",
                  "action_id": "read_user_input",
                  "object": "\"Loading Kubernetes versions from https://endoflife.date/api/kubernetes.json...\"",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect user input",
                  "intention_id": "collect_user_input"
                },
                {
                  "action_api": "urllib.request.urlopen()",
                  "action_description": "Opens URL with GET parameters",
                  "action_id": "open_url_get",
                  "object": "\"https://endoflife.date/api/kubernetes.json\"",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "json.load()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "url",
                  "object_description": "HTTP response content from remote server",
                  "object_id": "http_response_remote_content",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "datetime.strptime()",
                  "action_description": "Parses string into datetime object",
                  "action_id": "parse_datetime",
                  "object": "x[\"eol\"], DATE_FORMAT",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "datetime.now()",
                  "action_description": "Returns current time",
                  "action_id": "get_current_time",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "list.sort()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "key=lambda x: x[\"eol\"], reverse=True",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "gpiozero-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/gpiozero-2.0.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "pinout.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gpiozero-2.0.1/gpiozero-2.0.1/gpiozerocli/pinout.py",
          "line_number": "74",
          "type_description": "shady-links",
          "context_snippet": "    def main(self, args):\n        warnings.simplefilter('ignore')\n        if args.xyz:\n            webbrowser.open('https://pinout.xyz')\n        else:\n            if args.revision is None:\n                try:\n                    Device.ensure_pin_factory()\n                    board_info = Device.pin_factory.board_info\n                except ImportError:\n                    sys.stderr.write(self.get_gpiozero_help())\n                    return 1\n                except IOError:\n                    sys.stderr.write('Unrecognized board')\n                    return 1\n            else:\n                board_info = PiBoardInfo.from_revision(args.revision)\n            style = Style(color=args.color)\n            sys.stdout.write(f'{board_info:{style} full}')\n            formatter = self.get_formatter()\n            formatter.add_text(\n                \"For further information, please refer to \"\n                \"https://pinout.xyz/\")\n            sys.stdout.write('\\n\\n')\n            sys.stdout.write(formatter.format_help())",
          "hash_value": "b832ee6599177e36a68cf5ac5f808826",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "    def main(self, args):\n        warnings.simplefilter('ignore')\n        if args.xyz:\n            webbrowser.open('https://pinout.xyz')\n        else:\n            if args.revision is None:\n                try:\n                    Device.ensure_pin_factory()\n                    board_info = Device.pin_factory.board_info\n                except ImportError:\n                    sys.stderr.write(self.get_gpiozero_help())\n                    return 1\n                except IOError:\n                    sys.stderr.write('Unrecognized board')\n                    return 1\n            else:\n                board_info = PiBoardInfo.from_revision(args.revision)\n            style = Style(color=args.color)\n            sys.stdout.write(f'{board_info:{style} full}')\n            formatter = self.get_formatter()\n            formatter.add_text(\n                \"For further information, please refer to \"\n                \"https://pinout.xyz/\")\n            sys.stdout.write('\\n\\n')\n            sys.stdout.write(formatter.format_help())",
              "triple_sequences": [
                {
                  "action_api": "warnings.simplefilter()",
                  "action_description": "Disables SSL certificate warnings",
                  "action_id": "disable_ssl_warnings",
                  "object": "'ignore'",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Suppress SSL warning messages",
                  "intention_id": "suppress_ssl_warnings"
                },
                {
                  "action_api": "webbrowser.open()",
                  "action_description": "Opens file with associated application",
                  "action_id": "open_file_app",
                  "object": "'https://pinout.xyz'",
                  "object_description": "External domain",
                  "object_id": "external_domain",
                  "intention_description": "Open URL in default browser",
                  "intention_id": "open_url_browser"
                },
                {
                  "action_api": "Device.ensure_pin_factory()",
                  "action_description": "Instantiates WMI interface for system management",
                  "action_id": "instantiate_wmi",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Initialize shell object",
                  "intention_id": "initialize_shell_object"
                },
                {
                  "action_api": "Device.pin_factory.board_info",
                  "action_description": "Retrieves operating system information",
                  "action_id": "get_os_info",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get system info",
                  "intention_id": "get_system_info"
                },
                {
                  "action_api": "sys.stderr.write()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "self.get_gpiozero_help()",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "sys.stderr.write()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "'Unrecognized board'",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "PiBoardInfo.from_revision()",
                  "action_description": "Retrieves operating system information",
                  "action_id": "get_os_info",
                  "object": "args.revision",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Get system info",
                  "intention_id": "get_system_info"
                },
                {
                  "action_api": "Style()",
                  "action_description": "Creates new thread to execute",
                  "action_id": "create_thread",
                  "object": "color=args.color",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Prepare character for further processing",
                  "intention_id": "prepare_character_processing"
                },
                {
                  "action_api": "sys.stdout.write()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "f'{board_info:{style} full}'",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "self.get_formatter()",
                  "action_description": "Creates new thread to execute",
                  "action_id": "create_thread",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare character for further processing",
                  "intention_id": "prepare_character_processing"
                },
                {
                  "action_api": "formatter.add_text()",
                  "action_description": "Adds field to Discord embed",
                  "action_id": "add_discord_embed_field",
                  "object": "\"For further information, please refer to https://pinout.xyz/\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Prepare character for further processing",
                  "intention_id": "prepare_character_processing"
                },
                {
                  "action_api": "sys.stdout.write()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "'\\n\\n'",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "formatter.format_help()",
                  "action_description": "Creates new thread to execute",
                  "action_id": "create_thread",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare character for further processing",
                  "intention_id": "prepare_character_processing"
                },
                {
                  "action_api": "sys.stdout.write()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "formatter.format_help()",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "approval_utilities-14",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/approval_utilities-14.5.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "clipboard_utilities.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/approval_utilities-14.5.0/approval_utilities-14.5.0/approval_utilities/utilities/clipboard_utilities.py",
          "line_number": "7",
          "type_description": "clipboard-access",
          "context_snippet": "def copy_to_clipboard(text):\n    \"\"\"\n    This acts as a wrapper to defer the importing of pyperclip util actual usage\n    \"\"\"\n    import pyperclip  # type ignore\n\n    pyperclip.copy(text)\n",
          "hash_value": "8ea5b0872e41cf75959e32c6dac1e798",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def copy_to_clipboard(text):\n    \"\"\"\n    This acts as a wrapper to defer the importing of pyperclip util actual usage\n    \"\"\"\n    import pyperclip  # type ignore\n\n    pyperclip.copy(text)\n",
              "triple_sequences": [
                {
                  "action_api": "pyperclip.copy()",
                  "action_description": "Copies specified text to system clipboard",
                  "action_id": "copy_to_clipboard",
                  "object": "text",
                  "object_description": "Clipboard content data",
                  "object_id": "clipboard_data",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "commentjson-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/commentjson-0.9.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "commentjson.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/commentjson-0.9.0/commentjson-0.9.0/commentjson/commentjson.py",
          "line_number": "65",
          "type_description": "shady-links",
          "context_snippet": "def detect_encoding(b):\n    '''\n    Taken from `json` package in CPython 3.7.\n\n    Source can be found at https://bit.ly/2OHqCIK.\n    '''\n\n    bstartswith = b.startswith\n    if bstartswith((codecs.BOM_UTF32_BE, codecs.BOM_UTF32_LE)):\n        return 'utf-32'\n    if bstartswith((codecs.BOM_UTF16_BE, codecs.BOM_UTF16_LE)):\n        return 'utf-16'\n    if bstartswith(codecs.BOM_UTF8):\n        return 'utf-8-sig'\n\n    if len(b) >= 4:\n        if not b[0]:\n            # 00 00 -- -- - utf-32-be\n            # 00 XX -- -- - utf-16-be\n            return 'utf-16-be' if b[1] else 'utf-32-be'\n        if not b[1]:\n            # XX 00 00 00 - utf-32-le\n            # XX 00 00 XX - utf-16-le\n            # XX 00 XX -- - utf-16-le\n            return 'utf-16-le' if b[2] or b[3] else 'utf-32-le'\n    elif len(b) == 2:\n        if not b[0]:\n            # 00 XX - utf-16-be\n            return 'utf-16-be'\n        if not b[1]:\n            # XX 00 - utf-16-le\n            return 'utf-16-le'\n    # default\n    return 'utf-8'",
          "hash_value": "81f8104965b1b8d82468cbc3ca443cac",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def detect_encoding(b):\n    '''\n    Taken from `json` package in CPython 3.7.\n\n    Source can be found at https://bit.ly/2OHqCIK.\n    '''\n\n    bstartswith = b.startswith\n    if bstartswith((codecs.BOM_UTF32_BE, codecs.BOM_UTF32_LE)):\n        return 'utf-32'\n    if bstartswith((codecs.BOM_UTF16_BE, codecs.BOM_UTF16_LE)):\n        return 'utf-16'\n    if bstartswith(codecs.BOM_UTF8):\n        return 'utf-8-sig'\n\n    if len(b) >= 4:\n        if not b[0]:\n            # 00 00 -- -- - utf-32-be\n            # 00 XX -- -- - utf-16-be\n            return 'utf-16-be' if b[1] else 'utf-32-be'\n        if not b[1]:\n            # XX 00 00 00 - utf-32-le\n            # XX 00 00 XX - utf-16-le\n            # XX 00 XX -- - utf-16-le\n            return 'utf-16-le' if b[2] or b[3] else 'utf-32-le'\n    elif len(b) == 2:\n        if not b[0]:\n            # 00 XX - utf-16-be\n            return 'utf-16-be'\n        if not b[1]:\n            # XX 00 - utf-16-le\n            return 'utf-16-le'\n    # default\n    return 'utf-8'",
              "triple_sequences": [
                {
                  "action_api": "b.startswith()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "(codecs.BOM_UTF32_BE, codecs.BOM_UTF32_LE)",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Determine operating system",
                  "intention_id": "get_operating_system_name"
                },
                {
                  "action_api": "b.startswith()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "(codecs.BOM_UTF16_BE, codecs.BOM_UTF16_LE)",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Determine operating system",
                  "intention_id": "get_operating_system_name"
                },
                {
                  "action_api": "b.startswith()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "codecs.BOM_UTF8",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Determine operating system",
                  "intention_id": "get_operating_system_name"
                },
                {
                  "action_api": "len(b)",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "b",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "jsons-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/jsons-1.6.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "_common_impl.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/jsons-1.6.3/jsons-1.6.3/jsons/_common_impl.py",
          "line_number": "78",
          "type_description": "obfuscation",
          "context_snippet": "import builtins\n\ndef get_cls_from_str(cls_str: str, source: object, fork_inst) -> type:\n    cls = getattr(builtins, cls_str, None)\n    if cls:\n        return cls\n    if '[' in cls_str and ']' in cls_str:\n        return _get_generic_cls_from_str(cls_str, source, fork_inst)\n    try:\n        splitted = cls_str.split('.')\n        module_name = '.'.join(splitted[:-1])\n        cls_name = splitted[-1]\n        cls_module = import_module(module_name)\n        cls = getattr(cls_module, cls_name)\n    except (ImportError, AttributeError, ValueError):\n        cls = _lookup_announced_class(cls_str, source, fork_inst)\n    return cls\n\n# Data dependencies:\n# - 'builtins' is imported at the top of the file\n# - 'cls_str' is a parameter to the function\n# - 'getattr' is a built-in function\n# - The function is called by 'get_cls_and_meta', '_get_generic_cls_from_str', and itself recursively\n# - Helper functions used: _get_generic_cls_from_str, _lookup_announced_class",
          "hash_value": "8b98adaccb274993855fb7eb9a0f242d",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import builtins\n\ndef get_cls_from_str(cls_str: str, source: object, fork_inst) -> type:\n    cls = getattr(builtins, cls_str, None)\n    if cls:\n        return cls\n    if '[' in cls_str and ']' in cls_str:\n        return _get_generic_cls_from_str(cls_str, source, fork_inst)\n    try:\n        splitted = cls_str.split('.')\n        module_name = '.'.join(splitted[:-1])\n        cls_name = splitted[-1]\n        cls_module = import_module(module_name)\n        cls = getattr(cls_module, cls_name)\n    except (ImportError, AttributeError, ValueError):\n        cls = _lookup_announced_class(cls_str, source, fork_inst)\n    return cls\n\n# Data dependencies:\n# - 'builtins' is imported at the top of the file\n# - 'cls_str' is a parameter to the function\n# - 'getattr' is a built-in function\n# - The function is called by 'get_cls_and_meta', '_get_generic_cls_from_str', and itself recursively\n# - Helper functions used: _get_generic_cls_from_str, _lookup_announced_class",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, cls_str, None",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "cls_str",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "import_module()",
                  "action_description": "Dynamically imports specified module",
                  "action_id": "import_dynamic",
                  "object": "module_name",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "cls_module, cls_name",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pybcj-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pybcj-1.0.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pybcj-1.0.3/pybcj-1.0.3/setup.py",
          "line_number": "62",
          "type_description": "cmd-overwrite",
          "context_snippet": "from setuptools import Extension, setup\nfrom setuptools.command.build_ext import build_ext\nfrom setuptools.command.egg_info import egg_info\n\nsources = [\"src/ext/Bra.c\", \"src/ext/Bra86.c\", \"src/ext/BraIA64.c\", \"src/ext/_bcjmodule.c\"]\nkwargs = {\n    \"name\": \"bcj._bcj\",\n    \"include_dirs\": [\"src/ext\"],\n    \"library_dirs\": [],\n    \"libraries\": [],\n    \"sources\": sources,\n    \"define_macros\": [],\n}\npackages = [\"bcj\"]\nbinary_extension = Extension(**kwargs)\n\nclass build_ext_compiler_check(build_ext):\n    def build_extensions(self):\n        for extension in self.extensions:\n            if self.compiler.compiler_type.lower() in (\"unix\", \"mingw32\"):\n                if WARNING_AS_ERROR:\n                    extension.extra_compile_args.append(\"-Werror\")\n            elif self.compiler.compiler_type.lower() == \"msvc\":\n                more_options = [\"/GF\", \"/Gy\"]\n                if WARNING_AS_ERROR:\n                    more_options.append(\"/WX\")\n                extension.extra_compile_args.extend(more_options)\n        super().build_extensions()\n\nclass my_egg_info(egg_info):\n    def run(self):\n        try:\n            os.remove(os.path.join(self.egg_info, \"SOURCES.txt\"))\n        except FileNotFoundError:\n            pass\n        super().run()\n\nsetup(\n    package_dir={\"\": \"src\"},\n    ext_modules=[binary_extension],\n    packages=packages,\n    cmdclass={\"build_ext\": build_ext_compiler_check, \"egg_info\": my_egg_info},\n)\n",
          "hash_value": "fce022c3f22fe59a96144215d0e364b6",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from setuptools import Extension, setup\nfrom setuptools.command.build_ext import build_ext\nfrom setuptools.command.egg_info import egg_info\n\nsources = [\"src/ext/Bra.c\", \"src/ext/Bra86.c\", \"src/ext/BraIA64.c\", \"src/ext/_bcjmodule.c\"]\nkwargs = {\n    \"name\": \"bcj._bcj\",\n    \"include_dirs\": [\"src/ext\"],\n    \"library_dirs\": [],\n    \"libraries\": [],\n    \"sources\": sources,\n    \"define_macros\": [],\n}\npackages = [\"bcj\"]\nbinary_extension = Extension(**kwargs)\n\nclass build_ext_compiler_check(build_ext):\n    def build_extensions(self):\n        for extension in self.extensions:\n            if self.compiler.compiler_type.lower() in (\"unix\", \"mingw32\"):\n                if WARNING_AS_ERROR:\n                    extension.extra_compile_args.append(\"-Werror\")\n            elif self.compiler.compiler_type.lower() == \"msvc\":\n                more_options = [\"/GF\", \"/Gy\"]\n                if WARNING_AS_ERROR:\n                    more_options.append(\"/WX\")\n                extension.extra_compile_args.extend(more_options)\n        super().build_extensions()\n\nclass my_egg_info(egg_info):\n    def run(self):\n        try:\n            os.remove(os.path.join(self.egg_info, \"SOURCES.txt\"))\n        except FileNotFoundError:\n            pass\n        super().run()\n\nsetup(\n    package_dir={\"\": \"src\"},\n    ext_modules=[binary_extension],\n    packages=packages,\n    cmdclass={\"build_ext\": build_ext_compiler_check, \"egg_info\": my_egg_info},\n)\n",
              "triple_sequences": [
                {
                  "action_api": "Extension()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "kwargs",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                },
                {
                  "action_api": "build_ext.build_extensions()",
                  "action_description": "Executes setuptools development procedure",
                  "action_id": "exec_setuptools_dev",
                  "object": "self.extensions",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                },
                {
                  "action_api": "egg_info.run()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "self.egg_info",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                },
                {
                  "action_api": "os.remove()",
                  "action_description": "Deletes specified file from filesystem",
                  "action_id": "delete_file",
                  "object": "os.path.join(self.egg_info, \"SOURCES.txt\")",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Delete file",
                  "intention_id": "delete_file"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "package_dir={\"\": \"src\"}, ext_modules=[binary_extension], packages=packages, cmdclass={\"build_ext\": build_ext_compiler_check, \"egg_info\": my_egg_info}",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "twiggy-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/twiggy-0.5.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "validators.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/twiggy-0.5.1/Twiggy-0.5.1/twiggy/lib/validators.py",
          "line_number": "56",
          "type_description": "obfuscation",
          "context_snippet": "from six.moves import builtins\n\ndef _string_to_attribute(value, type_='attribute'):\n    \"\"\"\n    Tests whether a string is an importable attribute and returns the attribute\n\n    :arg value: The string naming the attribute\n    :returns: The attribute\n    :raises ValueError: if the string is not an importable attribute\n    \"\"\"\n    # For exception messages\n    if type_[0] in ('a', 'e', 'i', 'o', 'u'):\n        article = 'an'\n    else:\n        article = 'a'\n\n    if not isinstance(value, string_types):\n        raise ValueError('This value must be a string naming {0} {1}, not {2} of'\n                         ' type {3}'.format(article, type_, value, type(value)))\n    parts = value.split('.')\n\n    # Test for an attribute in builtins named value\n    if len(parts) == 1:\n        try:\n            attribute = getattr(builtins, value)\n        except AttributeError:\n            raise ValueError('Could not find {0} {1} named {2}'.format(article, type_, value))\n\n        return attribute\n\n    # Find a module that we can import\n    module = None\n    for idx in range(len(parts) - 1, 0, -1):\n        try:\n            module = import_module('.'.join(parts[:idx]))\n        except Exception:\n            pass\n        else:\n            remainder = parts[idx:]\n            break\n    else:  # For-else\n        raise ValueError('Could not import a module with {0} {1} named'\n                         ' {2}'.format(article, type_, value))\n\n    # Handle both Staticmethod (ClassName.staticmethod) and module global\n    # attribute (attributename)\n    prev_part = module\n    for next_part in remainder:\n        try:\n            prev_part = getattr(prev_part, next_part)\n        except AttributeError:\n            raise ValueError('Could not find {0} {1} named {2} in module'\n                             ' {3}'.format(article, type_, '.'.join(remainder),\n                                           '.'.join(parts[:idx])))\n    attribute = prev_part\n    return attribute\n\n# Data dependencies:\n# - 'builtins' is imported from 'six.moves'\n# - 'value' is a function argument\n# - 'getattr' is a Python built-in function\n# - 'string_types' is imported from 'six'\n",
          "hash_value": "013070846494515638f810712e603ca7",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from six.moves import builtins\n\ndef _string_to_attribute(value, type_='attribute'):\n    \"\"\"\n    Tests whether a string is an importable attribute and returns the attribute\n\n    :arg value: The string naming the attribute\n    :returns: The attribute\n    :raises ValueError: if the string is not an importable attribute\n    \"\"\"\n    # For exception messages\n    if type_[0] in ('a', 'e', 'i', 'o', 'u'):\n        article = 'an'\n    else:\n        article = 'a'\n\n    if not isinstance(value, string_types):\n        raise ValueError('This value must be a string naming {0} {1}, not {2} of'\n                         ' type {3}'.format(article, type_, value, type(value)))\n    parts = value.split('.')\n\n    # Test for an attribute in builtins named value\n    if len(parts) == 1:\n        try:\n            attribute = getattr(builtins, value)\n        except AttributeError:\n            raise ValueError('Could not find {0} {1} named {2}'.format(article, type_, value))\n\n        return attribute\n\n    # Find a module that we can import\n    module = None\n    for idx in range(len(parts) - 1, 0, -1):\n        try:\n            module = import_module('.'.join(parts[:idx]))\n        except Exception:\n            pass\n        else:\n            remainder = parts[idx:]\n            break\n    else:  # For-else\n        raise ValueError('Could not import a module with {0} {1} named'\n                         ' {2}'.format(article, type_, value))\n\n    # Handle both Staticmethod (ClassName.staticmethod) and module global\n    # attribute (attributename)\n    prev_part = module\n    for next_part in remainder:\n        try:\n            prev_part = getattr(prev_part, next_part)\n        except AttributeError:\n            raise ValueError('Could not find {0} {1} named {2} in module'\n                             ' {3}'.format(article, type_, '.'.join(remainder),\n                                           '.'.join(parts[:idx])))\n    attribute = prev_part\n    return attribute\n\n# Data dependencies:\n# - 'builtins' is imported from 'six.moves'\n# - 'value' is a function argument\n# - 'getattr' is a Python built-in function\n# - 'string_types' is imported from 'six'\n",
              "triple_sequences": [
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "value, string_types",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "value, '.'",
                  "object_description": "String containing environment data",
                  "object_id": "string_environment_data",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "builtins, value",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "import_module()",
                  "action_description": "Dynamically imports specified module",
                  "action_id": "import_dynamic",
                  "object": "'.'.join(parts[:idx])",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "prev_part, next_part",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pyeapi-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyeapi-1.0.4.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyeapi-1.0.4/pyeapi-1.0.4/setup.py",
          "line_number": "83",
          "type_description": "code-execution",
          "context_snippet": "if install() and environ.get('READTHEDOCS'):\n    print('This method is only called by READTHEDOCS.')\n    from subprocess import Popen\n    proc = Popen(['make', 'modules'], cwd='docs/')\n    (_, err) = proc.communicate()\n    return_code = proc.wait()\n\n    if return_code or err:\n        raise ('Failed to make modules.(%s:%s)' % (return_code, err))",
          "hash_value": "9a3b9b4d3f40f3718eba474ff55bfb05",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "if install() and environ.get('READTHEDOCS'):\n    print('This method is only called by READTHEDOCS.')\n    from subprocess import Popen\n    proc = Popen(['make', 'modules'], cwd='docs/')\n    (_, err) = proc.communicate()\n    return_code = proc.wait()\n\n    if return_code or err:\n        raise ('Failed to make modules.(%s:%s)' % (return_code, err))",
              "triple_sequences": [
                {
                  "action_api": "install()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                },
                {
                  "action_api": "environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "READTHEDOCS",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "['make', 'modules'], cwd='docs/'",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "proc.communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "proc.wait()",
                  "action_description": "Waits for process to complete execution",
                  "action_id": "wait_process_completion",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Wait for events",
                  "intention_id": "wait_for_events"
                },
                {
                  "action_api": "raise",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "'Failed to make modules.(%s:%s)' % (return_code, err)",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "igraph-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/igraph-0.11.8.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/igraph-0.11.8/igraph-0.11.8/setup.py",
          "line_number": "142",
          "type_description": "code-execution",
          "context_snippet": "def get_output(args, encoding: str = \"utf-8\") -> Tuple[str, int]:\n    \"\"\"Returns the output of a command returning a single line of output, and\n    the exit code of the command.\n    \"\"\"\n    PIPE = subprocess.PIPE\n    try:\n        p = subprocess.Popen(args, shell=False, stdin=PIPE, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        returncode = p.returncode\n    except OSError:\n        stdout, stderr = None, None\n        returncode = 77\n    if isinstance(stdout, bytes):\n        stdout = str(stdout, encoding=encoding)\n    if isinstance(stderr, bytes):\n        stderr = str(stderr, encoding=encoding)\n    return (stdout or \"\"), returncode",
          "hash_value": "841363ae649cfdf18128f865d733710d",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def get_output(args, encoding: str = \"utf-8\") -> Tuple[str, int]:\n    \"\"\"Returns the output of a command returning a single line of output, and\n    the exit code of the command.\n    \"\"\"\n    PIPE = subprocess.PIPE\n    try:\n        p = subprocess.Popen(args, shell=False, stdin=PIPE, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        returncode = p.returncode\n    except OSError:\n        stdout, stderr = None, None\n        returncode = 77\n    if isinstance(stdout, bytes):\n        stdout = str(stdout, encoding=encoding)\n    if isinstance(stderr, bytes):\n        stderr = str(stderr, encoding=encoding)\n    return (stdout or \"\"), returncode",
              "triple_sequences": [
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "args",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.Popen.communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "subprocess.Popen.communicate()",
                  "action_description": "Reads all bytes from process standard error",
                  "action_id": "read_process_stderr",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "subprocess.Popen.returncode",
                  "action_description": "Checks if process has terminated",
                  "action_id": "check_process_terminated",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate process",
                  "intention_id": "terminate_process"
                },
                {
                  "action_api": "isinstance(stdout, bytes)",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "stdout",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "str(stdout, encoding=encoding)",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "stdout",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                },
                {
                  "action_api": "isinstance(stderr, bytes)",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "stderr",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "str(stderr, encoding=encoding)",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "stderr",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "psutil-7",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/psutil-7.0.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/psutil-7.0.0/psutil-7.0.0/setup.py",
          "line_number": "177",
          "type_description": "code-execution",
          "context_snippet": "import subprocess\nimport sys\nimport os\n\ndef get_long_description():\n    script = os.path.join(HERE, \"scripts\", \"internal\", \"convert_readme.py\")\n    readme = os.path.join(HERE, 'README.rst')\n    p = subprocess.Popen(\n        [sys.executable, script, readme],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        universal_newlines=True,\n    )\n    stdout, stderr = p.communicate()\n    if p.returncode != 0:\n        raise RuntimeError(stderr)\n    return stdout",
          "hash_value": "07a75cff6b55ce98012174d6fd570b04",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import subprocess\nimport sys\nimport os\n\ndef get_long_description():\n    script = os.path.join(HERE, \"scripts\", \"internal\", \"convert_readme.py\")\n    readme = os.path.join(HERE, 'README.rst')\n    p = subprocess.Popen(\n        [sys.executable, script, readme],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        universal_newlines=True,\n    )\n    stdout, stderr = p.communicate()\n    if p.returncode != 0:\n        raise RuntimeError(stderr)\n    return stdout",
              "triple_sequences": [
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "HERE, \"scripts\", \"internal\", \"convert_readme.py\"",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "HERE, 'README.rst'",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "[sys.executable, script, readme]",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Create child process",
                  "intention_id": "create_child_process"
                },
                {
                  "action_api": "p.communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "ptyprocess-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/ptyprocess-0.7.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "ptyprocess.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ptyprocess-0.7.0/ptyprocess-0.7.0/ptyprocess/ptyprocess.py",
          "line_number": "327",
          "type_description": "obfuscation",
          "context_snippet": "        if len(exec_err_data) != 0:\n            try:\n                errclass, errno_s, errmsg = exec_err_data.split(b':', 2)\n                exctype = getattr(builtins, errclass.decode('ascii'), Exception)\n\n                exception = exctype(errmsg.decode('utf-8', 'replace'))\n                if exctype is OSError:\n                    exception.errno = int(errno_s)\n            except:\n                raise Exception('Subprocess failed, got bad error data: %r'\n                                    % exec_err_data)\n            else:\n                raise exception",
          "hash_value": "c1889761b8b9065fe05bf5e424ece07a",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "        if len(exec_err_data) != 0:\n            try:\n                errclass, errno_s, errmsg = exec_err_data.split(b':', 2)\n                exctype = getattr(builtins, errclass.decode('ascii'), Exception)\n\n                exception = exctype(errmsg.decode('utf-8', 'replace'))\n                if exctype is OSError:\n                    exception.errno = int(errno_s)\n            except:\n                raise Exception('Subprocess failed, got bad error data: %r'\n                                    % exec_err_data)\n            else:\n                raise exception",
              "triple_sequences": [
                {
                  "action_api": "bytes.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "exec_err_data.split(b':', 2)",
                  "object_description": "Obfuscated byte string",
                  "object_id": "obfuscated_byte_string",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, errclass.decode('ascii'), Exception",
                  "object_description": "Character from obfuscated byte string",
                  "object_id": "character_from_obfuscated_bytes",
                  "intention_description": "Prepare character for further processing",
                  "intention_id": "prepare_character_processing"
                },
                {
                  "action_api": "bytes.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "errclass.decode('ascii')",
                  "object_description": "Obfuscated byte string",
                  "object_id": "obfuscated_byte_string",
                  "intention_description": "Prepare character for further processing",
                  "intention_id": "prepare_character_processing"
                },
                {
                  "action_api": "bytes.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "errmsg.decode('utf-8', 'replace')",
                  "object_description": "Obfuscated byte string",
                  "object_id": "obfuscated_byte_string",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "int()",
                  "action_description": "Convert string to integer",
                  "action_id": "convert_string_to_integer",
                  "object": "errno_s",
                  "object_description": "Obfuscated byte string",
                  "object_id": "obfuscated_byte_string",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "raise Exception()",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "'Subprocess failed, got bad error data: %r' % exec_err_data",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                },
                {
                  "action_api": "raise exception",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "exception",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "rgwml-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/rgwml-0.0.346.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "m.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/rgwml-0.0.346/rgwml-0.0.346/src/rgwml/m.py",
          "line_number": "637",
          "type_description": "shady-links",
          "context_snippet": "    def send_telegram_message(self, invoking_function_name, message, preset_name):\n\n        # Set the config path to ~/.rgwfuncsrc\n        config_path = os.path.expanduser(\"~/.rgwfuncsrc\")\n\n        def load_config():\n            \"\"\"Load the configuration from the .rgwfuncsrc file.\"\"\"\n            with open(config_path, 'r') as file:\n                return json.load(file)\n\n        def get_telegram_preset(config, preset_name):\n            presets = config.get(\"telegram_bot_presets\", [])\n            for preset in presets:\n                if preset.get(\"name\") == preset_name:\n                    return preset\n            return None\n\n        def get_telegram_bot_details(config, preset_name):\n            preset = get_telegram_preset(config, preset_name)\n            if not preset:\n                raise RuntimeError(f\"Telegram bot preset '{preset_name}' not found in the configuration file\")\n\n            bot_token = preset.get(\"bot_token\")\n            chat_id = preset.get(\"chat_id\")\n\n            if not bot_token or not chat_id:\n                raise RuntimeError(\n                    f\"Telegram bot token or chat ID for '{preset_name}' not found in the configuration file\"\n                )\n\n            return bot_token, chat_id\n\n        config = load_config()\n        bot_token, chat_id = get_telegram_bot_details(config, preset_name)\n        url = f\"https://api.telegram.org/bot{bot_token}/sendMessage\"\n        payload = {\"chat_id\": chat_id, \"text\": message}\n\n        response = requests.post(url, json=payload)\n        response.raise_for_status()\n",
          "hash_value": "f802ef6b34481bd7a0d7e8cdbd4df664",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "    def send_telegram_message(self, invoking_function_name, message, preset_name):\n\n        # Set the config path to ~/.rgwfuncsrc\n        config_path = os.path.expanduser(\"~/.rgwfuncsrc\")\n\n        def load_config():\n            \"\"\"Load the configuration from the .rgwfuncsrc file.\"\"\"\n            with open(config_path, 'r') as file:\n                return json.load(file)\n\n        def get_telegram_preset(config, preset_name):\n            presets = config.get(\"telegram_bot_presets\", [])\n            for preset in presets:\n                if preset.get(\"name\") == preset_name:\n                    return preset\n            return None\n\n        def get_telegram_bot_details(config, preset_name):\n            preset = get_telegram_preset(config, preset_name)\n            if not preset:\n                raise RuntimeError(f\"Telegram bot preset '{preset_name}' not found in the configuration file\")\n\n            bot_token = preset.get(\"bot_token\")\n            chat_id = preset.get(\"chat_id\")\n\n            if not bot_token or not chat_id:\n                raise RuntimeError(\n                    f\"Telegram bot token or chat ID for '{preset_name}' not found in the configuration file\"\n                )\n\n            return bot_token, chat_id\n\n        config = load_config()\n        bot_token, chat_id = get_telegram_bot_details(config, preset_name)\n        url = f\"https://api.telegram.org/bot{bot_token}/sendMessage\"\n        payload = {\"chat_id\": chat_id, \"text\": message}\n\n        response = requests.post(url, json=payload)\n        response.raise_for_status()\n",
              "triple_sequences": [
                {
                  "action_api": "os.path.expanduser()",
                  "action_description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
                  "action_id": "path_special_operations",
                  "object": "~/.rgwfuncsrc",
                  "object_description": "Home directory path",
                  "object_id": "home_directory_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "config_path, 'r'",
                  "object_description": "System configuration file",
                  "object_id": "system_config_file",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "json.load()",
                  "action_description": "Deserializes JSON string to Python object",
                  "action_id": "deserialize_from_json",
                  "object": "file",
                  "object_description": "JSON string",
                  "object_id": "json_string",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "config.get()",
                  "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
                  "action_id": "path_object_operations",
                  "object": "\"telegram_bot_presets\", []",
                  "object_description": "API key or token",
                  "object_id": "api_key",
                  "intention_description": "Access configuration value",
                  "intention_id": "access_configuration_value"
                },
                {
                  "action_api": "preset.get()",
                  "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
                  "action_id": "path_object_operations",
                  "object": "\"name\"",
                  "object_description": "API key or token",
                  "object_id": "api_key",
                  "intention_description": "Access configuration value",
                  "intention_id": "access_configuration_value"
                },
                {
                  "action_api": "preset.get()",
                  "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
                  "action_id": "path_object_operations",
                  "object": "\"bot_token\"",
                  "object_description": "API key or token",
                  "object_id": "api_key",
                  "intention_description": "Access configuration value",
                  "intention_id": "access_configuration_value"
                },
                {
                  "action_api": "preset.get()",
                  "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
                  "action_id": "path_object_operations",
                  "object": "\"chat_id\"",
                  "object_description": "API key or token",
                  "object_id": "api_key",
                  "intention_description": "Access configuration value",
                  "intention_id": "access_configuration_value"
                },
                {
                  "action_api": "requests.post()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "url, json=payload",
                  "object_description": "Telegram API endpoint",
                  "object_id": "telegram_api_endpoint",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "response.raise_for_status()",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Pause execution",
                  "intention_id": "pause_execution"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "drug_named_entity_recognition-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/drug_named_entity_recognition-2.0.7.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "06_optional_check_words_with_ai.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/drug_named_entity_recognition-2.0.7/drug_named_entity_recognition-2.0.7/harvesting_data_from_source/06_optional_check_words_with_ai.py",
          "line_number": "68",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "import os\nimport re\nimport sys\nimport time\nimport traceback\nfrom tqdm import tqdm\nimport requests\n\nMODEL = 'gpt-3.5-turbo'\n\nwith open(\"words_to_check_with_ai.txt\", \"r\", encoding=\"utf-8\") as f:\n    words_to_check_with_ai = f.read().split(\"\\n\")\n\nheaders = {\n    'Content-Type': 'application/json',\n    'Authorization': 'Bearer ' + os.environ[\"OPENAI_API_KEY\"],\n}\n\nbot_responses = [\"\"] * len(words_to_check_with_ai)\n\nfor idx in tqdm(range(len(words_to_check_with_ai))):\n    q = words_to_check_with_ai[idx]\n    print(f\"Asking question: {idx+1}: {q}\")\n\n    starttime = time.time()\n\n    json_data = {\n        'model': MODEL,\n        'messages': [\n            {\"role\": \"user\", \"content\": f\"What is {q}?\\n\"},\n        ],\n    }\n    for attempt in range(3):\n        print(\"attempt calling GPT API:\", attempt)\n        try:\n            response = requests.post('https://api.openai.com/v1/chat/completions', headers=headers, json=json_data)\n            r = response.json()[\"choices\"][0][\"message\"][\"content\"]\n            break\n        except:\n            print(\"Try again\")\n            traceback.print_exc()\n            time.sleep(10)\n    bot_responses[idx] = re.sub(r'\\s+', ' ', r)\n\n    with open(\"ai_responses.txt\", \"w\", encoding=\"utf-8\") as f:\n        for j in range(idx):\n            f.write(words_to_check_with_ai[j] + \"\\t\" + bot_responses[j] + \"\\n\")\n\n    endtime = time.time()\n\n    print(\"\\tReceived response: \", r)",
          "hash_value": "0fd17513477a0276c8e8fe58faed2e50",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport re\nimport sys\nimport time\nimport traceback\nfrom tqdm import tqdm\nimport requests\n\nMODEL = 'gpt-3.5-turbo'\n\nwith open(\"words_to_check_with_ai.txt\", \"r\", encoding=\"utf-8\") as f:\n    words_to_check_with_ai = f.read().split(\"\\n\")\n\nheaders = {\n    'Content-Type': 'application/json',\n    'Authorization': 'Bearer ' + os.environ[\"OPENAI_API_KEY\"],\n}\n\nbot_responses = [\"\"] * len(words_to_check_with_ai)\n\nfor idx in tqdm(range(len(words_to_check_with_ai))):\n    q = words_to_check_with_ai[idx]\n    print(f\"Asking question: {idx+1}: {q}\")\n\n    starttime = time.time()\n\n    json_data = {\n        'model': MODEL,\n        'messages': [\n            {\"role\": \"user\", \"content\": f\"What is {q}?\\n\"},\n        ],\n    }\n    for attempt in range(3):\n        print(\"attempt calling GPT API:\", attempt)\n        try:\n            response = requests.post('https://api.openai.com/v1/chat/completions', headers=headers, json=json_data)\n            r = response.json()[\"choices\"][0][\"message\"][\"content\"]\n            break\n        except:\n            print(\"Try again\")\n            traceback.print_exc()\n            time.sleep(10)\n    bot_responses[idx] = re.sub(r'\\s+', ' ', r)\n\n    with open(\"ai_responses.txt\", \"w\", encoding=\"utf-8\") as f:\n        for j in range(idx):\n            f.write(words_to_check_with_ai[j] + \"\\t\" + bot_responses[j] + \"\\n\")\n\n    endtime = time.time()\n\n    print(\"\\tReceived response: \", r)",
              "triple_sequences": [
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "\"words_to_check_with_ai.txt\", \"r\", encoding=\"utf-8\"",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "f.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "os.environ[\"OPENAI_API_KEY\"]",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"OPENAI_API_KEY\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "requests.post()",
                  "action_description": "Opens URL with POST data",
                  "action_id": "open_url_post",
                  "object": "'https://api.openai.com/v1/chat/completions', headers=headers, json=json_data",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Send data to server",
                  "intention_id": "send_data_server"
                },
                {
                  "action_api": "response.json()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "",
                  "object_description": "JSON string",
                  "object_id": "json_string",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "re.sub()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "r'\\s+', ' ', r",
                  "object_description": "Regular expression and file content",
                  "object_id": "regex_file_content",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for writing (normal writing, binary writing)",
                  "action_id": "basic_write_operations",
                  "object": "\"ai_responses.txt\", \"w\", encoding=\"utf-8\"",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for writing",
                  "intention_id": "open_file_writing"
                },
                {
                  "action_api": "f.write()",
                  "action_description": "File opening operations for writing (normal writing, binary writing)",
                  "action_id": "basic_write_operations",
                  "object": "words_to_check_with_ai[j] + \"\\t\" + bot_responses[j] + \"\\n\"",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                },
                {
                  "action_api": "time.time()",
                  "action_description": "Returns current time",
                  "action_id": "get_current_time",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get datetime epoch",
                  "intention_id": "get_datetime_epoch"
                },
                {
                  "action_api": "traceback.print_exc()",
                  "action_description": "Extracts current call stack as FrameSummary objects",
                  "action_id": "extract_call_stack",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "time.sleep()",
                  "action_description": "Suspends execution",
                  "action_id": "suspend_execution",
                  "object": "10",
                  "object_description": "Delay duration in seconds",
                  "object_id": "delay_duration",
                  "intention_description": "Pause execution",
                  "intention_id": "pause_execution"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "msticpy-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/msticpy-2.16.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "pivot_browser.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/msticpy-2.16.2/msticpy-2.16.2/msticpy/init/pivot_core/pivot_browser.py",
          "line_number": "222",
          "type_description": "clipboard-access",
          "context_snippet": "def _copy_to_clip(self, btn):\n    del btn\n    if _ENABLE_CLIP:\n        pyperclip.copy(self._get_current_func())",
          "hash_value": "c8878714e10fb6bfc4e5aa36cd398bd7",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def _copy_to_clip(self, btn):\n    del btn\n    if _ENABLE_CLIP:\n        pyperclip.copy(self._get_current_func())",
              "triple_sequences": [
                {
                  "action_api": "pyperclip.copy()",
                  "action_description": "Copies specified text to system clipboard",
                  "action_id": "copy_to_clipboard",
                  "object": "self._get_current_func()",
                  "object_description": "Clipboard content data",
                  "object_id": "clipboard_data",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "usaddress-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/usaddress-0.5.13.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/usaddress-0.5.13/usaddress-0.5.13/setup.py",
          "line_number": "21",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport subprocess\nfrom distutils.cmd import Command\n\nclass TrainModel(Command):\n    description = \"Training the model before building the package\"\n    user_options = []\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        PYTHONPATH = os.environ.get(\"PYTHONPATH\", \"\")\n        subprocess.run(\n            [\"parserator\", \"train\", \"training/labeled.xml\", \"usaddress\"],\n            env=dict(os.environ, PYTHONPATH=f\".{os.pathsep}{PYTHONPATH}\"),\n        )",
          "hash_value": "61a9f918576254631166886d40985ece",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport subprocess\nfrom distutils.cmd import Command\n\nclass TrainModel(Command):\n    description = \"Training the model before building the package\"\n    user_options = []\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        PYTHONPATH = os.environ.get(\"PYTHONPATH\", \"\")\n        subprocess.run(\n            [\"parserator\", \"train\", \"training/labeled.xml\", \"usaddress\"],\n            env=dict(os.environ, PYTHONPATH=f\".{os.pathsep}{PYTHONPATH}\"),\n        )",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"PYTHONPATH\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"parserator\", \"train\", \"training/labeled.xml\", \"usaddress\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pygresql-6",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pygresql-6.1.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pygresql-6.1.0/pygresql-6.1.0/setup.py",
          "line_number": "55",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport platform\nimport re\nimport sys\nimport warnings\nfrom distutils.ccompiler import get_default_compiler\nfrom distutils.sysconfig import get_python_inc, get_python_lib\n\ndef pg_config(s):\n    \"\"\"Retrieve information about installed version of PostgreSQL.\"\"\"\n    f = os.popen(f'pg_config --{s}')  # noqa: S605\n    d = f.readline().strip()\n    if f.close() is not None:\n        raise Exception(\"pg_config tool is not available.\")\n    if not d:\n        raise Exception(f\"Could not get {s} information.\")\n    return d",
          "hash_value": "90df4aca4acbeb70641abc89158efc3a",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport platform\nimport re\nimport sys\nimport warnings\nfrom distutils.ccompiler import get_default_compiler\nfrom distutils.sysconfig import get_python_inc, get_python_lib\n\ndef pg_config(s):\n    \"\"\"Retrieve information about installed version of PostgreSQL.\"\"\"\n    f = os.popen(f'pg_config --{s}')  # noqa: S605\n    d = f.readline().strip()\n    if f.close() is not None:\n        raise Exception(\"pg_config tool is not available.\")\n    if not d:\n        raise Exception(f\"Could not get {s} information.\")\n    return d",
              "triple_sequences": [
                {
                  "action_api": "os.popen()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "f'pg_config --{s}'",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "file.readline()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "file.close()",
                  "action_description": "Closes the opened file",
                  "action_id": "close_file",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Close file",
                  "intention_id": "close_file"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "discord_py-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/discord_py-2.5.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "abc.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/discord_py-2.5.2/discord_py-2.5.2/discord/abc.py",
          "line_number": "593",
          "type_description": "shady-links",
          "context_snippet": "@property\n    def jump_url(self) -> str:\n        \"\"\":class:`str`: Returns a URL that allows the client to jump to the channel.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return f'https://discord.com/channels/{self.guild.id}/{self.id}'",
          "hash_value": "ae45e0e408f869eacb2b62b0f8c5333b",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "@property\n    def jump_url(self) -> str:\n        \"\"\":class:`str`: Returns a URL that allows the client to jump to the channel.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return f'https://discord.com/channels/{self.guild.id}/{self.id}'",
              "triple_sequences": [
                {
                  "action_api": "str.format()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "f'https://discord.com/channels/{self.guild.id}/{self.id}'",
                  "object_description": "URL string",
                  "object_id": "url_string",
                  "intention_description": "Prepare URL for HTTP request",
                  "intention_id": "prepare_url_http_request"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "fairscale-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/fairscale-0.4.13.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/fairscale-0.4.13/fairscale-0.4.13/setup.py",
          "line_number": "27",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport re\n\ndef find_version(version_file_path) -> str:\n    with open(version_file_path) as version_file:\n        version_match = re.search(r\"^__version_tuple__ = (.*)\", version_file.read(), re.M)\n        if version_match:\n            ver_tup = eval(version_match.group(1))\n            ver_str = \".\".join([str(x) for x in ver_tup])\n            return ver_str\n        raise RuntimeError(\"Unable to find version tuple.\")",
          "hash_value": "ca57d7251863ff2919c4e707d4df3710",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport re\n\ndef find_version(version_file_path) -> str:\n    with open(version_file_path) as version_file:\n        version_match = re.search(r\"^__version_tuple__ = (.*)\", version_file.read(), re.M)\n        if version_match:\n            ver_tup = eval(version_match.group(1))\n            ver_str = \".\".join([str(x) for x in ver_tup])\n            return ver_str\n        raise RuntimeError(\"Unable to find version tuple.\")",
              "triple_sequences": [
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "version_file_path",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "version_file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "re.search()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "r\"^__version_tuple__ = (.*)\" and version_file.read()",
                  "object_description": "Regular expression and file content",
                  "object_id": "regex_file_content",
                  "intention_description": "Extract structured file data",
                  "intention_id": "extract_structured_file_data"
                },
                {
                  "action_api": "eval()",
                  "action_description": "Evaluates string as Python expression",
                  "action_id": "eval_python_expr",
                  "object": "version_match.group(1)",
                  "object_description": "Compiled Python code string",
                  "object_id": "compiled_python_code",
                  "intention_description": "Evaluate constructed code",
                  "intention_id": "evaluate_constructed_code"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "python_tgpt-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/python_tgpt-0.8.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "imager.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/python_tgpt-0.8.1/python_tgpt-0.8.1/src/pytgpt/imager/imager.py",
          "line_number": "185",
          "type_description": "shady-links",
          "context_snippet": "    async def _generate(self, prompt: str) -> bytes:\n        \"\"\"\n        Create a new image generation based on the given prompt.\n\n        Args:\n            prompt (str): The prompt for generating the image.\n\n        Returns:\n            resp (bytes): The generated image content\n        \"\"\"\n\n        try:\n            resp = await self.session.get(\n                \"https://api.prodia.com/generate\",\n                params={\n                    \"new\": \"true\",\n                    \"prompt\": prompt,\n                    \"model\": \"dreamshaper_6BakedVae.safetensors [114c8abb]\",\n                    \"negative_prompt\": \"(nsfw:1.5),verybadimagenegative_v1.3, ng_deepnegative_v1_75t, (ugly face:0.5),cross-eyed,sketches, (worst quality:2), (low quality:2.1), (normal quality:2), lowres, normal quality, ((monochrome)), ((grayscale)), skin spots, acnes, skin blemishes, bad anatomy, DeepNegative, facing away, tilted head, {Multiple people}, lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worstquality, low quality, normal quality, jpegartifacts, signature, watermark, username, blurry, bad feet, cropped, poorly drawn hands, poorly drawn face, mutation, deformed, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, extra fingers, fewer digits, extra limbs, extra arms,extra legs, malformed limbs, fused fingers, too many fingers, long neck, cross-eyed,mutated hands, polar lowres, bad body, bad proportions, gross proportions, text, error, missing fingers, missing arms, missing legs, extra digit, extra arms, extra leg, extra foot, repeating hair\",\n                    \"steps\": \"50\",\n                    \"cfg\": \"9.5\",\n                    \"seed\": randint(1, 10000),\n                    \"sampler\": \"Euler\",\n                    \"aspect_ratio\": \"square\",\n                },\n                timeout=self.timeout,\n            )\n            data = resp.json()\n            while True:\n                resp = await self.session.get(\n                    f\"https://api.prodia.com/job/{data['job']}\", timeout=self.timeout\n                )\n                json = resp.json()\n                if json[\"status\"] == \"succeeded\":\n                    resp = await self.session.get(\n                        f\"https://images.prodia.xyz/{data['job']}.png?download=1\",\n                        timeout=self.timeout,\n                    )\n                    return resp.content\n\n        except Exception as e:\n            print(e)\n            raise Exception(\"Unable to generate image\") from e",
          "hash_value": "75521e666e74024df1dceaa820957e52",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "    async def _generate(self, prompt: str) -> bytes:\n        \"\"\"\n        Create a new image generation based on the given prompt.\n\n        Args:\n            prompt (str): The prompt for generating the image.\n\n        Returns:\n            resp (bytes): The generated image content\n        \"\"\"\n\n        try:\n            resp = await self.session.get(\n                \"https://api.prodia.com/generate\",\n                params={\n                    \"new\": \"true\",\n                    \"prompt\": prompt,\n                    \"model\": \"dreamshaper_6BakedVae.safetensors [114c8abb]\",\n                    \"negative_prompt\": \"(nsfw:1.5),verybadimagenegative_v1.3, ng_deepnegative_v1_75t, (ugly face:0.5),cross-eyed,sketches, (worst quality:2), (low quality:2.1), (normal quality:2), lowres, normal quality, ((monochrome)), ((grayscale)), skin spots, acnes, skin blemishes, bad anatomy, DeepNegative, facing away, tilted head, {Multiple people}, lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worstquality, low quality, normal quality, jpegartifacts, signature, watermark, username, blurry, bad feet, cropped, poorly drawn hands, poorly drawn face, mutation, deformed, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, extra fingers, fewer digits, extra limbs, extra arms,extra legs, malformed limbs, fused fingers, too many fingers, long neck, cross-eyed,mutated hands, polar lowres, bad body, bad proportions, gross proportions, text, error, missing fingers, missing arms, missing legs, extra digit, extra arms, extra leg, extra foot, repeating hair\",\n                    \"steps\": \"50\",\n                    \"cfg\": \"9.5\",\n                    \"seed\": randint(1, 10000),\n                    \"sampler\": \"Euler\",\n                    \"aspect_ratio\": \"square\",\n                },\n                timeout=self.timeout,\n            )\n            data = resp.json()\n            while True:\n                resp = await self.session.get(\n                    f\"https://api.prodia.com/job/{data['job']}\", timeout=self.timeout\n                )\n                json = resp.json()\n                if json[\"status\"] == \"succeeded\":\n                    resp = await self.session.get(\n                        f\"https://images.prodia.xyz/{data['job']}.png?download=1\",\n                        timeout=self.timeout,\n                    )\n                    return resp.content\n\n        except Exception as e:\n            print(e)\n            raise Exception(\"Unable to generate image\") from e",
              "triple_sequences": [
                {
                  "action_api": "self.session.get()",
                  "action_description": "Sends HTTP GET request to URL",
                  "action_id": "open_url_get",
                  "object": "https://api.prodia.com/generate",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "resp.json()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "self.session.get()",
                  "action_description": "Sends HTTP GET request to URL",
                  "action_id": "open_url_get",
                  "object": "f\"https://api.prodia.com/job/{data['job']}\"",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "resp.json()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "self.session.get()",
                  "action_description": "Sends HTTP GET request to URL",
                  "action_id": "open_url_get",
                  "object": "f\"https://images.prodia.xyz/{data['job']}.png?download=1\"",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "license_expression-30",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/license_expression-30.4.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "utils_dejacode.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/license_expression-30.4.1/license_expression-30.4.1/etc/scripts/utils_dejacode.py",
          "line_number": "51",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "import requests\n\nDEJACODE_API_KEY = os.environ.get(\"DEJACODE_API_KEY\", \"\")\nDEJACODE_API_URL = os.environ.get(\"DEJACODE_API_URL\", \"\")\n\nDEJACODE_API_URL_PACKAGES = f\"{DEJACODE_API_URL}packages/\"\nDEJACODE_API_HEADERS = {\n    \"Authorization\": \"Token {}\".format(DEJACODE_API_KEY),\n    \"Accept\": \"application/json; indent=4\",\n}\n\ndef can_do_api_calls():\n    if not DEJACODE_API_KEY and DEJACODE_API_URL:\n        print(\n            \"DejaCode DEJACODE_API_KEY and DEJACODE_API_URL not configured. Doing nothing\")\n        return False\n    else:\n        return True\n\ndef fetch_dejacode_packages(params):\n    \"\"\"\n    Return a list of package data mappings calling the package API with using\n    `params` or an empty list.\n    \"\"\"\n    if not can_do_api_calls():\n        return []\n\n    response = requests.get(\n        DEJACODE_API_URL_PACKAGES,\n        params=params,\n        headers=DEJACODE_API_HEADERS,\n    )\n\n    return response.json()[\"results\"]",
          "hash_value": "15c5f6856345eae5ab4375652f12184b",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import requests\n\nDEJACODE_API_KEY = os.environ.get(\"DEJACODE_API_KEY\", \"\")\nDEJACODE_API_URL = os.environ.get(\"DEJACODE_API_URL\", \"\")\n\nDEJACODE_API_URL_PACKAGES = f\"{DEJACODE_API_URL}packages/\"\nDEJACODE_API_HEADERS = {\n    \"Authorization\": \"Token {}\".format(DEJACODE_API_KEY),\n    \"Accept\": \"application/json; indent=4\",\n}\n\ndef can_do_api_calls():\n    if not DEJACODE_API_KEY and DEJACODE_API_URL:\n        print(\n            \"DejaCode DEJACODE_API_KEY and DEJACODE_API_URL not configured. Doing nothing\")\n        return False\n    else:\n        return True\n\ndef fetch_dejacode_packages(params):\n    \"\"\"\n    Return a list of package data mappings calling the package API with using\n    `params` or an empty list.\n    \"\"\"\n    if not can_do_api_calls():\n        return []\n\n    response = requests.get(\n        DEJACODE_API_URL_PACKAGES,\n        params=params,\n        headers=DEJACODE_API_HEADERS,\n    )\n\n    return response.json()[\"results\"]",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"DEJACODE_API_KEY\", \"\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"DEJACODE_API_URL\", \"\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP GET request to URL",
                  "action_id": "open_url_get",
                  "object": "DEJACODE_API_URL_PACKAGES, params=params, headers=DEJACODE_API_HEADERS",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "response.json()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "",
                  "object_description": "JSON string",
                  "object_id": "json_string",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "jina-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/jina-3.34.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "helper.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/jina-3.34.0/jina-3.34.0/jina/helper.py",
          "line_number": "1227",
          "type_description": "shady-links",
          "context_snippet": "def get_public_ip(timeout: float = 0.3):\n    \"\"\"\n    Return the public IP address of the gateway for connecting from other machine in the public network.\n\n    :param timeout: the seconds to wait until return None.\n\n    :return: Public IP address.\n\n    .. warn::\n        Set `timeout` to a large number will block the Flow.\n\n    \"\"\"\n    import urllib.request\n\n    def _get_ip(url):\n        try:\n            req = urllib.request.Request(url, headers={'User-Agent': 'Mozilla/5.0'})\n            with urllib.request.urlopen(req, timeout=timeout) as fp:\n                _ip = fp.read().decode().strip()\n                return _ip\n\n        except:\n            pass  # intentionally ignored, public ip is not showed\n\n    ip_server_list = [\n        'https://api.ipify.org',\n        'https://ident.me',\n        'https://checkip.amazonaws.com/',\n    ]\n\n    for idx, ip in enumerate(ip_server_list):\n        r = _get_ip(ip)\n        if r:\n            return r",
          "hash_value": "473086178002ed50b843c0eb6da709cd",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def get_public_ip(timeout: float = 0.3):\n    \"\"\"\n    Return the public IP address of the gateway for connecting from other machine in the public network.\n\n    :param timeout: the seconds to wait until return None.\n\n    :return: Public IP address.\n\n    .. warn::\n        Set `timeout` to a large number will block the Flow.\n\n    \"\"\"\n    import urllib.request\n\n    def _get_ip(url):\n        try:\n            req = urllib.request.Request(url, headers={'User-Agent': 'Mozilla/5.0'})\n            with urllib.request.urlopen(req, timeout=timeout) as fp:\n                _ip = fp.read().decode().strip()\n                return _ip\n\n        except:\n            pass  # intentionally ignored, public ip is not showed\n\n    ip_server_list = [\n        'https://api.ipify.org',\n        'https://ident.me',\n        'https://checkip.amazonaws.com/',\n    ]\n\n    for idx, ip in enumerate(ip_server_list):\n        r = _get_ip(ip)\n        if r:\n            return r",
              "triple_sequences": [
                {
                  "action_api": "urllib.request.Request()",
                  "action_description": "Creates HTTP request object with specified URL, data, and headers",
                  "action_id": "create_http_request",
                  "object": "url, headers={'User-Agent': 'Mozilla/5.0'}",
                  "object_description": "Request object for external domain",
                  "object_id": "request_external_domain",
                  "intention_description": "Prepare URL for HTTP request",
                  "intention_id": "prepare_url_http_request"
                },
                {
                  "action_api": "urllib.request.urlopen()",
                  "action_description": "Opens URL with GET parameters",
                  "action_id": "open_url_get",
                  "object": "req, timeout=timeout",
                  "object_description": "Request object for external domain",
                  "object_id": "request_external_domain",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "fp.read()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Decode downloaded content",
                  "intention_id": "decode_downloaded_content"
                },
                {
                  "action_api": "bytes.decode()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Decode downloaded content",
                  "intention_id": "decode_downloaded_content"
                },
                {
                  "action_api": "str.strip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Extract public IP address",
                  "intention_id": "extract_public_ip_address"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "sagemaker_feature_store_pyspark-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/sagemaker_feature_store_pyspark-1.1.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/sagemaker_feature_store_pyspark-1.1.3/sagemaker_feature_store_pyspark-1.1.3/setup.py",
          "line_number": "61",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport shutil\nimport sys\nimport subprocess\n\nfrom pathlib import Path\n\nSPARK_HOME = os.getenv('SPARK_HOME')\nTEMP_PATH = \"deps\"\nVERSION_PATH = \"VERSION\"\nJARS_TARGET = os.path.join(TEMP_PATH, \"jars\")\nSCALA_SPARK_DIR = Path(\"../scala-spark-sdk\")\nUBER_JAR_NAME_PREFIX = \"sagemaker-feature-store-spark-sdk\"\nUBER_JAR_NAME = f\"{UBER_JAR_NAME_PREFIX}.jar\"\n\nin_spark_sdk = os.path.isfile(SCALA_SPARK_DIR / \"build.sbt\")\n\n...\n\nif in_spark_sdk:\n    shutil.copyfile(os.path.join(\"..\", VERSION_PATH), VERSION_PATH)\n\n    if not os.path.exists(TEMP_PATH):\n        os.mkdir(TEMP_PATH)\n\n    # use sbt to package the scala uber jar\n    p = subprocess.Popen(\"sbt assembly\".split(),\n                         stdout=subprocess.PIPE,\n                         stderr=subprocess.PIPE,\n                         cwd=SCALA_SPARK_DIR)\n    p.communicate()\n",
          "hash_value": "97e1c6cb2ac3562ec68769fd9148d4ca",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport shutil\nimport sys\nimport subprocess\n\nfrom pathlib import Path\n\nSPARK_HOME = os.getenv('SPARK_HOME')\nTEMP_PATH = \"deps\"\nVERSION_PATH = \"VERSION\"\nJARS_TARGET = os.path.join(TEMP_PATH, \"jars\")\nSCALA_SPARK_DIR = Path(\"../scala-spark-sdk\")\nUBER_JAR_NAME_PREFIX = \"sagemaker-feature-store-spark-sdk\"\nUBER_JAR_NAME = f\"{UBER_JAR_NAME_PREFIX}.jar\"\n\nin_spark_sdk = os.path.isfile(SCALA_SPARK_DIR / \"build.sbt\")\n\n...\n\nif in_spark_sdk:\n    shutil.copyfile(os.path.join(\"..\", VERSION_PATH), VERSION_PATH)\n\n    if not os.path.exists(TEMP_PATH):\n        os.mkdir(TEMP_PATH)\n\n    # use sbt to package the scala uber jar\n    p = subprocess.Popen(\"sbt assembly\".split(),\n                         stdout=subprocess.PIPE,\n                         stderr=subprocess.PIPE,\n                         cwd=SCALA_SPARK_DIR)\n    p.communicate()\n",
              "triple_sequences": [
                {
                  "action_api": "os.path.isfile()",
                  "action_description": "Checks if specified path exists and is a file",
                  "action_id": "check_file_is_file",
                  "object": "SCALA_SPARK_DIR / \"build.sbt\"",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Determine file presence",
                  "intention_id": "determine_file_presence"
                },
                {
                  "action_api": "shutil.copyfile()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "os.path.join(\"..\", VERSION_PATH), VERSION_PATH",
                  "object_description": "Local file or directory",
                  "object_id": "local_file_or_directory",
                  "intention_description": "Copy file to temporary directory",
                  "intention_id": "copy_file_temp_directory"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "TEMP_PATH",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Determine directory presence",
                  "intention_id": "determine_directory_presence"
                },
                {
                  "action_api": "os.mkdir()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "TEMP_PATH",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command with shell access",
                  "action_id": "spawn_process_shell",
                  "object": "\"sbt assembly\".split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=SCALA_SPARK_DIR",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "p.communicate()",
                  "action_description": "Waits for process to complete execution",
                  "action_id": "wait_process_completion",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Wait for events",
                  "intention_id": "wait_for_events"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pymupdf-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pymupdf-1.25.5.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pymupdf-1.25.5/pymupdf-1.25.5/setup.py",
          "line_number": "218",
          "type_description": "code-execution",
          "context_snippet": "import subprocess\n\ndef run(command, check=1):\n    log(f'Running: {command}')\n    return subprocess.run( command, shell=1, check=check)\n\n# Helper: log()\ndef log( text):\n    global _log_prefix\n    if not _log_prefix:\n        # This typically sets _log_prefix to `PyMuPDF/setup.py`.\n        p = os.path.abspath( __file__)\n        p, p1 = os.path.split( p)\n        p, p0 = os.path.split( p)\n        _log_prefix = os.path.join( p0, p1)\n    print(f'{_log_prefix}: {text}', file=sys.stdout)\n    sys.stdout.flush()",
          "hash_value": "935025ad6be0bac9790221b56aa7afca",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import subprocess\n\ndef run(command, check=1):\n    log(f'Running: {command}')\n    return subprocess.run( command, shell=1, check=check)\n\n# Helper: log()\ndef log( text):\n    global _log_prefix\n    if not _log_prefix:\n        # This typically sets _log_prefix to `PyMuPDF/setup.py`.\n        p = os.path.abspath( __file__)\n        p, p1 = os.path.split( p)\n        p, p0 = os.path.split( p)\n        _log_prefix = os.path.join( p0, p1)\n    print(f'{_log_prefix}: {text}', file=sys.stdout)\n    sys.stdout.flush()",
              "triple_sequences": [
                {
                  "action_api": "os.path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Get script file path",
                  "intention_id": "get_script_file_path"
                },
                {
                  "action_api": "os.path.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "p",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "os.path.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "p",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "p0, p1",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "print()",
                  "action_description": "Writes data to standard output stream",
                  "action_id": "get_stdout_stream",
                  "object": "f'{_log_prefix}: {text}', file=sys.stdout",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "sys.stdout.flush()",
                  "action_description": "Retrieves standard output stream object",
                  "action_id": "get_stdout_stream",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "command",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "rasterio-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/rasterio-1.4.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/rasterio-1.4.3/rasterio-1.4.3/setup.py",
          "line_number": "86",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport re\nimport sys\nimport logging\nfrom subprocess import check_output\n\nlogging.basicConfig(stream=sys.stderr, level=logging.INFO)\nlog = logging.getLogger()\n\ninclude_dirs = []\nlibrary_dirs = []\nlibraries = []\nextra_link_args = []\ngdal2plus = False\ngdal_output = [None] * 4\ngdalversion = None\ngdal_major_version = 0\ngdal_minor_version = 0\ngdal_patch_version = 0\n\nif \"clean\" not in sys.argv:\n    try:\n        gdal_config = os.environ.get('GDAL_CONFIG', 'gdal-config')\n        for i, flag in enumerate((\"--cflags\", \"--libs\", \"--datadir\", \"--version\")):\n            gdal_output[i] = check_output([gdal_config, flag]).decode(\"utf-8\").strip()\n\n        for item in gdal_output[0].split():\n            if item.startswith(\"-I\"):\n                include_dirs.extend(item[2:].split(\":\"))\n        for item in gdal_output[1].split():\n            if item.startswith(\"-L\"):\n                library_dirs.extend(item[2:].split(\":\"))\n            elif item.startswith(\"-l\"):\n                libraries.append(item[2:])\n            else:\n                # e.g. -framework GDAL\n                extra_link_args.append(item)\n        # datadir, gdal_output[2] handled below\n\n        gdalversion = gdal_output[3]\n        if gdalversion:\n            log.info(\"GDAL API version obtained from gdal-config: %s\",\n                     gdalversion)\n\n    except Exception as e:\n        if os.name == \"nt\":\n            log.info(\"Building on Windows requires extra options to setup.py \"\n                     \"to locate needed GDAL files. More information is available \"\n                     \"in the README.\")\n        else:\n            log.warning(\"Failed to get options via gdal-config: %s\", str(e))",
          "hash_value": "b9f431f00aabde1ea1ff691dcb9a4b74",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport re\nimport sys\nimport logging\nfrom subprocess import check_output\n\nlogging.basicConfig(stream=sys.stderr, level=logging.INFO)\nlog = logging.getLogger()\n\ninclude_dirs = []\nlibrary_dirs = []\nlibraries = []\nextra_link_args = []\ngdal2plus = False\ngdal_output = [None] * 4\ngdalversion = None\ngdal_major_version = 0\ngdal_minor_version = 0\ngdal_patch_version = 0\n\nif \"clean\" not in sys.argv:\n    try:\n        gdal_config = os.environ.get('GDAL_CONFIG', 'gdal-config')\n        for i, flag in enumerate((\"--cflags\", \"--libs\", \"--datadir\", \"--version\")):\n            gdal_output[i] = check_output([gdal_config, flag]).decode(\"utf-8\").strip()\n\n        for item in gdal_output[0].split():\n            if item.startswith(\"-I\"):\n                include_dirs.extend(item[2:].split(\":\"))\n        for item in gdal_output[1].split():\n            if item.startswith(\"-L\"):\n                library_dirs.extend(item[2:].split(\":\"))\n            elif item.startswith(\"-l\"):\n                libraries.append(item[2:])\n            else:\n                # e.g. -framework GDAL\n                extra_link_args.append(item)\n        # datadir, gdal_output[2] handled below\n\n        gdalversion = gdal_output[3]\n        if gdalversion:\n            log.info(\"GDAL API version obtained from gdal-config: %s\",\n                     gdalversion)\n\n    except Exception as e:\n        if os.name == \"nt\":\n            log.info(\"Building on Windows requires extra options to setup.py \"\n                     \"to locate needed GDAL files. More information is available \"\n                     \"in the README.\")\n        else:\n            log.warning(\"Failed to get options via gdal-config: %s\", str(e))",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'GDAL_CONFIG', 'gdal-config'",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[gdal_config, flag]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "bytes.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "\"utf-8\"",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                },
                {
                  "action_api": "str.strip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "log.info()",
                  "action_description": "Sends message to Discord channel via webhook",
                  "action_id": "send_discord_webhook",
                  "object": "\"GDAL API version obtained from gdal-config: %s\", gdalversion",
                  "object_description": "Log level",
                  "object_id": "log_level",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "os.name",
                  "action_description": "Retrieves operating system identifier",
                  "action_id": "get_os_id",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine operating system",
                  "intention_id": "determine_operating_system"
                },
                {
                  "action_api": "log.warning()",
                  "action_description": "Sends message to Discord channel via webhook",
                  "action_id": "send_discord_webhook",
                  "object": "\"Failed to get options via gdal-config: %s\", str(e)",
                  "object_description": "Log level",
                  "object_id": "log_level",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "oic-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/oic-1.7.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "keyio.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/oic-1.7.0/oic-1.7.0/src/oic/utils/keyio.py",
          "line_number": "1161",
          "type_description": "obfuscation",
          "context_snippet": "def build_keyjar(key_conf, kid_template=\"\", keyjar=None, kidd=None):\n    \"\"\"\n    Create a KeyJar from keys.\n\n    Configuration of the type:\n    keys = [\n        {\"type\": \"RSA\", \"key\": \"cp_keys/key.pem\", \"use\": [\"enc\", \"sig\"]},\n        {\"type\": \"EC\", \"crv\": \"P-256\", \"use\": [\"sig\"]},\n        {\"type\": \"EC\", \"crv\": \"P-256\", \"use\": [\"enc\"]}\n    ]\n\n    :param key_conf: The key configuration\n    :param kid_template: A template by which to build the kids\n    :return: a tuple consisting of a JWKS dictionary, a KeyJar instance\n        and a representation of which kids that can be used for what.\n        Note the JWKS contains private key information !!\n    \"\"\"\n    if keyjar is None:\n        keyjar = KeyJar()\n\n    if kidd is None:\n        kidd = {\"sig\": {}, \"enc\": {}}\n\n    kid = 0\n    jwks: Dict[str, List[Dict[str, str]]] = {\"keys\": []}\n\n    for spec in key_conf:\n        typ = spec[\"type\"].upper()\n\n        if typ == \"RSA\":\n            if \"key\" in spec:\n                error_to_catch = getattr(\n                    builtins, \"FileNotFoundError\", getattr(builtins, \"IOError\")\n                )\n                try:\n                    kb = KeyBundle(\n                        source=\"file://%s\" % spec[\"key\"],\n                        fileformat=\"der\",\n                        keytype=typ,\n                        keyusage=spec[\"use\"],\n                    )\n                except error_to_catch:\n                    kb = _new_rsa_key(spec)\n                except Exception:\n                    raise\n            else:\n                kb = rsa_init(spec)\n        elif typ == \"EC\":\n            kb = ec_init(spec)\n\n        for k in kb.keys():\n            if kid_template:\n                k.kid = kid_template % kid\n                kid += 1\n            else:\n                k.add_kid()\n            kidd[k.use][k.kty] = k.kid\n\n        jwks[\"keys\"].extend([k.serialize() for k in kb.keys() if k.kty != \"oct\"])\n\n        keyjar.add_kb(\"\", kb)\n\n    return jwks, keyjar, kidd",
          "hash_value": "dfa7d707e5a6ce378749298cf8cad6ed",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def build_keyjar(key_conf, kid_template=\"\", keyjar=None, kidd=None):\n    \"\"\"\n    Create a KeyJar from keys.\n\n    Configuration of the type:\n    keys = [\n        {\"type\": \"RSA\", \"key\": \"cp_keys/key.pem\", \"use\": [\"enc\", \"sig\"]},\n        {\"type\": \"EC\", \"crv\": \"P-256\", \"use\": [\"sig\"]},\n        {\"type\": \"EC\", \"crv\": \"P-256\", \"use\": [\"enc\"]}\n    ]\n\n    :param key_conf: The key configuration\n    :param kid_template: A template by which to build the kids\n    :return: a tuple consisting of a JWKS dictionary, a KeyJar instance\n        and a representation of which kids that can be used for what.\n        Note the JWKS contains private key information !!\n    \"\"\"\n    if keyjar is None:\n        keyjar = KeyJar()\n\n    if kidd is None:\n        kidd = {\"sig\": {}, \"enc\": {}}\n\n    kid = 0\n    jwks: Dict[str, List[Dict[str, str]]] = {\"keys\": []}\n\n    for spec in key_conf:\n        typ = spec[\"type\"].upper()\n\n        if typ == \"RSA\":\n            if \"key\" in spec:\n                error_to_catch = getattr(\n                    builtins, \"FileNotFoundError\", getattr(builtins, \"IOError\")\n                )\n                try:\n                    kb = KeyBundle(\n                        source=\"file://%s\" % spec[\"key\"],\n                        fileformat=\"der\",\n                        keytype=typ,\n                        keyusage=spec[\"use\"],\n                    )\n                except error_to_catch:\n                    kb = _new_rsa_key(spec)\n                except Exception:\n                    raise\n            else:\n                kb = rsa_init(spec)\n        elif typ == \"EC\":\n            kb = ec_init(spec)\n\n        for k in kb.keys():\n            if kid_template:\n                k.kid = kid_template % kid\n                kid += 1\n            else:\n                k.add_kid()\n            kidd[k.use][k.kty] = k.kid\n\n        jwks[\"keys\"].extend([k.serialize() for k in kb.keys() if k.kty != \"oct\"])\n\n        keyjar.add_kb(\"\", kb)\n\n    return jwks, keyjar, kidd",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Retrieves attribute value from object",
                  "action_id": "access_attribute_value",
                  "object": "builtins, \"FileNotFoundError\", getattr(builtins, \"IOError\")",
                  "object_description": "Attribute value",
                  "object_id": "access_attribute_value",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "KeyBundle()",
                  "action_description": "Instantiates class object",
                  "action_id": "init_encrypter_class",
                  "object": "source=\"file://%s\" % spec[\"key\"], fileformat=\"der\", keytype=typ, keyusage=spec[\"use\"]",
                  "object_description": "Key configuration",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "_new_rsa_key()",
                  "action_description": "Instantiates class object",
                  "action_id": "init_encrypter_class",
                  "object": "spec",
                  "object_description": "Key configuration",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "rsa_init()",
                  "action_description": "Instantiates class object",
                  "action_id": "init_encrypter_class",
                  "object": "spec",
                  "object_description": "Key configuration",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "ec_init()",
                  "action_description": "Instantiates class object",
                  "action_id": "init_encrypter_class",
                  "object": "spec",
                  "object_description": "Key configuration",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "k.add_kid()",
                  "action_description": "Adds field to object",
                  "action_id": "add_discord_embed_field",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "k.serialize()",
                  "action_description": "Serializes Python object to JSON string",
                  "action_id": "serialize_to_json",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Serialize data",
                  "intention_id": "serialize_data"
                },
                {
                  "action_api": "keyjar.add_kb()",
                  "action_description": "Adds field to object",
                  "action_id": "add_discord_embed_field",
                  "object": "\"\", kb",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "billiard-4",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/billiard-4.2.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/billiard-4.2.1/billiard-4.2.1/t/integration/setup.py",
          "line_number": "31",
          "type_description": "cmd-overwrite",
          "context_snippet": "setup(\n    name='billiard-funtests',\n    version='DEV',\n    description='Functional test suite for billiard',\n    author='Ask Solem',\n    author_email='ask@celeryproject.org',\n    url='https://github.com/celery/billiard',\n    platforms=['any'],\n    packages=[],\n    data_files=[],\n    zip_safe=False,\n    cmdclass={'install': no_install},\n    test_suite='pytest',\n    build_requires=[\n        'pytest',\n        'coverage>=3.0',\n    ],\n    classifiers=[\n        'Operating System :: OS Independent',\n        'Programming Language :: Python',\n        'Programming Language :: C'\n        'License :: OSI Approved :: BSD License',\n        'Intended Audience :: Developers',\n    ],\n    long_description='Do not install this package',\n)\n\n# Data dependencies:\n# - 'no_install' is a class defined above:\n#   class no_install(install):\n#       def run(self, *args, **kwargs):\n#           import sys\n#           sys.stderr.write(\"\"\"\n#   ...\n# - 'install' is imported from setuptools.command.install\n# - All other arguments are constants or literals\n# - 'setup' is imported from setuptools",
          "hash_value": "eb05cab1213c9db33e11703d561a3cdf",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "setup(\n    name='billiard-funtests',\n    version='DEV',\n    description='Functional test suite for billiard',\n    author='Ask Solem',\n    author_email='ask@celeryproject.org',\n    url='https://github.com/celery/billiard',\n    platforms=['any'],\n    packages=[],\n    data_files=[],\n    zip_safe=False,\n    cmdclass={'install': no_install},\n    test_suite='pytest',\n    build_requires=[\n        'pytest',\n        'coverage>=3.0',\n    ],\n    classifiers=[\n        'Operating System :: OS Independent',\n        'Programming Language :: Python',\n        'Programming Language :: C'\n        'License :: OSI Approved :: BSD License',\n        'Intended Audience :: Developers',\n    ],\n    long_description='Do not install this package',\n)\n\n# Data dependencies:\n# - 'no_install' is a class defined above:\n#   class no_install(install):\n#       def run(self, *args, **kwargs):\n#           import sys\n#           sys.stderr.write(\"\"\"\n#   ...\n# - 'install' is imported from setuptools.command.install\n# - All other arguments are constants or literals\n# - 'setup' is imported from setuptools",
              "triple_sequences": [
                {
                  "action_api": "setup()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "{'name': 'billiard-funtests', 'version': 'DEV', 'description': 'Functional test suite for billiard', 'author': 'Ask Solem', 'author_email': 'ask@celeryproject.org', 'url': 'https://github.com/celery/billiard', 'platforms': ['any'], 'packages': [], 'data_files': [], 'zip_safe': False, 'cmdclass': {'install': no_install}, 'test_suite': 'pytest', 'build_requires': ['pytest', 'coverage>=3.0'], 'classifiers': ['Operating System :: OS Independent', 'Programming Language :: Python', 'Programming Language :: C', 'License :: OSI Approved :: BSD License', 'Intended Audience :: Developers'], 'long_description': 'Do not install this package'}",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pytest-8",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pytest-8.3.5.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "__init__.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pytest-8.3.5/pytest-8.3.5/src/_pytest/config/__init__.py",
          "line_number": "1957",
          "type_description": "obfuscation",
          "context_snippet": "def _resolve_warning_category(category: str) -> type[Warning]:\n    \"\"\"\n    Copied from warnings._getcategory, but changed so it lets exceptions (specially ImportErrors)\n    propagate so we can get access to their tracebacks (#9218).\n    \"\"\"\n    __tracebackhide__ = True\n    if not category:\n        return Warning\n\n    if \".\" not in category:\n        import builtins as m\n\n        klass = category\n    else:\n        module, _, klass = category.rpartition(\".\")\n        m = __import__(module, None, None, [klass])\n    cat = getattr(m, klass)\n    if not issubclass(cat, Warning):\n        raise UsageError(f\"{cat} is not a Warning subclass\")\n    return cast(Type[Warning], cat)",
          "hash_value": "b9f693385f862876843758df9ec0a278",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def _resolve_warning_category(category: str) -> type[Warning]:\n    \"\"\"\n    Copied from warnings._getcategory, but changed so it lets exceptions (specially ImportErrors)\n    propagate so we can get access to their tracebacks (#9218).\n    \"\"\"\n    __tracebackhide__ = True\n    if not category:\n        return Warning\n\n    if \".\" not in category:\n        import builtins as m\n\n        klass = category\n    else:\n        module, _, klass = category.rpartition(\".\")\n        m = __import__(module, None, None, [klass])\n    cat = getattr(m, klass)\n    if not issubclass(cat, Warning):\n        raise UsageError(f\"{cat} is not a Warning subclass\")\n    return cast(Type[Warning], cat)",
              "triple_sequences": [
                {
                  "action_api": "__import__()",
                  "action_description": "Dynamically imports specified module",
                  "action_id": "import_dynamic",
                  "object": "module",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "m, klass",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "issubclass()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "cat, Warning",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Determine required module presence",
                  "intention_id": "determine_required_module_presence"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "mmcif-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/mmcif-0.91.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/mmcif-0.91.0/mmcif-0.91.0/modules/pybind11/setup.py",
          "line_number": "139",
          "type_description": "code-execution",
          "context_snippet": "with remove_output(\"pybind11/include\", \"pybind11/share\"):\n    # Generate the files if they are not present.\n    with TemporaryDirectory() as tmpdir:\n        cmd = [\"cmake\", \"-S\", \".\", \"-B\", tmpdir] + [\n            \"-DCMAKE_INSTALL_PREFIX=pybind11\",\n            \"-DBUILD_TESTING=OFF\",\n            \"-DPYBIND11_NOPYTHON=ON\",\n            \"-Dprefix_for_pc_file=${pcfiledir}/../../\",\n        ]\n        if \"CMAKE_ARGS\" in os.environ:\n            fcommand = [\n                c\n                for c in os.environ[\"CMAKE_ARGS\"].split()\n                if \"DCMAKE_INSTALL_PREFIX\" not in c\n            ]\n            cmd += fcommand\n        subprocess.run(cmd, check=True, cwd=DIR, stdout=sys.stdout, stderr=sys.stderr)\n        subprocess.run(\n            [\"cmake\", \"--install\", tmpdir],\n            check=True,\n            cwd=DIR,\n            stdout=sys.stdout,\n            stderr=sys.stderr,\n        )",
          "hash_value": "b70511a5aec8110591ad3e376676d74e",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "with remove_output(\"pybind11/include\", \"pybind11/share\"):\n    # Generate the files if they are not present.\n    with TemporaryDirectory() as tmpdir:\n        cmd = [\"cmake\", \"-S\", \".\", \"-B\", tmpdir] + [\n            \"-DCMAKE_INSTALL_PREFIX=pybind11\",\n            \"-DBUILD_TESTING=OFF\",\n            \"-DPYBIND11_NOPYTHON=ON\",\n            \"-Dprefix_for_pc_file=${pcfiledir}/../../\",\n        ]\n        if \"CMAKE_ARGS\" in os.environ:\n            fcommand = [\n                c\n                for c in os.environ[\"CMAKE_ARGS\"].split()\n                if \"DCMAKE_INSTALL_PREFIX\" not in c\n            ]\n            cmd += fcommand\n        subprocess.run(cmd, check=True, cwd=DIR, stdout=sys.stdout, stderr=sys.stderr)\n        subprocess.run(\n            [\"cmake\", \"--install\", tmpdir],\n            check=True,\n            cwd=DIR,\n            stdout=sys.stdout,\n            stderr=sys.stderr,\n        )",
              "triple_sequences": [
                {
                  "action_api": "os.environ.__contains__()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "\"CMAKE_ARGS\" in os.environ",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.__getitem__()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "os.environ[\"CMAKE_ARGS\"]",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.environ[\"CMAKE_ARGS\"].split()",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "cmd, check=True, cwd=DIR, stdout=sys.stdout, stderr=sys.stderr",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"cmake\", \"--install\", tmpdir], check=True, cwd=DIR, stdout=sys.stdout, stderr=sys.stderr",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "jsonconversion-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/jsonconversion-1.1.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "conversion.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/jsonconversion-1.1.1/jsonconversion-1.1.1/source/jsonconversion/conversion.py",
          "line_number": "35",
          "type_description": "obfuscation",
          "context_snippet": "import sys\nfrom pydoc import locate, ErrorDuringImport\nfrom inspect import isclass\n\nfrom jsonconversion import basestring, builtins, PY2_BUILTINS_STR, PY3_BUILTINS_STR\n\n\ndef string2type(string_value):\n    \"\"\"Converts a string into a type or class\n\n    :param string_value: the string to be converted, e.g. \"int\"\n    :return: The type derived from string_value, e.g. int\n    \"\"\"\n    # If the parameter is already a type, return it\n    if isinstance(string_value, type) or isclass(string_value):\n        return string_value\n\n    # Special case, which cannot be handled otherwise\n    if string_value.endswith('NoneType'):\n        return type(None)\n\n    # Get object associated with string\n    # First check whether we are having a built in type (int, str, etc)\n    if hasattr(builtins, string_value):\n        obj = getattr(builtins, string_value)\n        if type(obj) is type:\n            return obj\n\n    if isinstance(string_value, basestring) and '.' in string_value:\n        return get_class_from_qualified_name(string_value)\n\n    # If not, try to locate the module\n    try:\n        obj = locate(string_value)\n    except ErrorDuringImport as e:\n        raise ValueError(\"Unknown type '{0}'\".format(e))\n\n    # Check whether object is a type\n    if type(obj) is type:\n        return locate(string_value)\n\n    # Check whether object is a class\n    if isclass(obj):\n        return obj\n\n    # Raise error if none is the case\n    raise ValueError(\"Unknown type '{0}'\".format(string_value))\n",
          "hash_value": "5ae55ff86a4b40570aa9d7658f569ea4",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import sys\nfrom pydoc import locate, ErrorDuringImport\nfrom inspect import isclass\n\nfrom jsonconversion import basestring, builtins, PY2_BUILTINS_STR, PY3_BUILTINS_STR\n\n\ndef string2type(string_value):\n    \"\"\"Converts a string into a type or class\n\n    :param string_value: the string to be converted, e.g. \"int\"\n    :return: The type derived from string_value, e.g. int\n    \"\"\"\n    # If the parameter is already a type, return it\n    if isinstance(string_value, type) or isclass(string_value):\n        return string_value\n\n    # Special case, which cannot be handled otherwise\n    if string_value.endswith('NoneType'):\n        return type(None)\n\n    # Get object associated with string\n    # First check whether we are having a built in type (int, str, etc)\n    if hasattr(builtins, string_value):\n        obj = getattr(builtins, string_value)\n        if type(obj) is type:\n            return obj\n\n    if isinstance(string_value, basestring) and '.' in string_value:\n        return get_class_from_qualified_name(string_value)\n\n    # If not, try to locate the module\n    try:\n        obj = locate(string_value)\n    except ErrorDuringImport as e:\n        raise ValueError(\"Unknown type '{0}'\".format(e))\n\n    # Check whether object is a type\n    if type(obj) is type:\n        return locate(string_value)\n\n    # Check whether object is a class\n    if isclass(obj):\n        return obj\n\n    # Raise error if none is the case\n    raise ValueError(\"Unknown type '{0}'\".format(string_value))\n",
              "triple_sequences": [
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "string_value, type",
                  "object_description": "Character from obfuscated string",
                  "object_id": "character_from_obfuscated_string",
                  "intention_description": "Convert string to integer",
                  "intention_id": "convert_string_to_integer"
                },
                {
                  "action_api": "isclass()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "string_value",
                  "object_description": "Character from obfuscated string",
                  "object_id": "character_from_obfuscated_string",
                  "intention_description": "Convert string to integer",
                  "intention_id": "convert_string_to_integer"
                },
                {
                  "action_api": "hasattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, string_value",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, string_value",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "string_value, basestring",
                  "object_description": "Character from obfuscated string",
                  "object_id": "character_from_obfuscated_string",
                  "intention_description": "Convert string to integer",
                  "intention_id": "convert_string_to_integer"
                },
                {
                  "action_api": "get_class_from_qualified_name()",
                  "action_description": "Import dynamically specified module",
                  "action_id": "import_dynamic",
                  "object": "string_value",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "locate()",
                  "action_description": "Import dynamically specified module",
                  "action_id": "import_dynamic",
                  "object": "string_value",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "isclass()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "obj",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Convert string to integer",
                  "intention_id": "convert_string_to_integer"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "scylla_driver-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/scylla_driver-3.29.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/scylla_driver-3.29.3/scylla_driver-3.29.3/setup.py",
          "line_number": "92",
          "type_description": "code-execution",
          "context_snippet": "class DocCommand(Command):\n\n    description = \"generate or test documentation\"\n\n    user_options = [(\"test\", \"t\",\n                     \"run doctests instead of generating documentation\")]\n\n    boolean_options = [\"test\"]\n\n    def initialize_options(self):\n        self.test = False\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        if self.test:\n            path = \"docs/_build/doctest\"\n            mode = \"doctest\"\n        else:\n            from cassandra import __version__\n            path = \"docs/_build/%s\" % __version__\n            mode = \"html\"\n\n            try:\n                os.makedirs(path)\n            except:\n                pass\n\n        if has_subprocess:\n            # Prevent run with in-place extensions because cython-generated objects do not carry docstrings\n            # http://docs.cython.org/src/userguide/special_methods.html#docstrings\n            import glob\n            for f in glob.glob(\"cassandra/*.so\"):\n                print(\"Removing '%s' to allow docs to run on pure python modules.\" %(f,))\n                os.unlink(f)\n\n            # Build io extension to make import and docstrings work\n            try:\n                output = subprocess.check_output(\n                    [\"python\", \"setup.py\", \"build_ext\", \"--inplace\", \"--force\", \"--no-murmur3\", \"--no-cython\"],\n                    stderr=subprocess.STDOUT)\n            except subprocess.CalledProcessError as exc:\n                raise RuntimeError(\"Documentation step '%s' failed: %s: %s\" % (\"build_ext\", exc, exc.output))\n            else:\n                print(output)\n\n            try:\n                output = subprocess.check_output(\n                    [\"sphinx-build\", \"-b\", mode, \"docs\", path],\n                    stderr=subprocess.STDOUT)\n            except subprocess.CalledProcessError as exc:\n                raise RuntimeError(\"Documentation step '%s' failed: %s: %s\" % (mode, exc, exc.output))\n            else:\n                print(output)\n\n            print(\"\")\n            print(\"Documentation step '%s' performed, results here:\" % mode)\n            print(\"   file://%s/%s/index.html\" % (os.path.dirname(os.path.realpath(__file__)), path))",
          "hash_value": "12bed8fe0a2aca9807f1fff1b3e70bc9",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class DocCommand(Command):\n\n    description = \"generate or test documentation\"\n\n    user_options = [(\"test\", \"t\",\n                     \"run doctests instead of generating documentation\")]\n\n    boolean_options = [\"test\"]\n\n    def initialize_options(self):\n        self.test = False\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        if self.test:\n            path = \"docs/_build/doctest\"\n            mode = \"doctest\"\n        else:\n            from cassandra import __version__\n            path = \"docs/_build/%s\" % __version__\n            mode = \"html\"\n\n            try:\n                os.makedirs(path)\n            except:\n                pass\n\n        if has_subprocess:\n            # Prevent run with in-place extensions because cython-generated objects do not carry docstrings\n            # http://docs.cython.org/src/userguide/special_methods.html#docstrings\n            import glob\n            for f in glob.glob(\"cassandra/*.so\"):\n                print(\"Removing '%s' to allow docs to run on pure python modules.\" %(f,))\n                os.unlink(f)\n\n            # Build io extension to make import and docstrings work\n            try:\n                output = subprocess.check_output(\n                    [\"python\", \"setup.py\", \"build_ext\", \"--inplace\", \"--force\", \"--no-murmur3\", \"--no-cython\"],\n                    stderr=subprocess.STDOUT)\n            except subprocess.CalledProcessError as exc:\n                raise RuntimeError(\"Documentation step '%s' failed: %s: %s\" % (\"build_ext\", exc, exc.output))\n            else:\n                print(output)\n\n            try:\n                output = subprocess.check_output(\n                    [\"sphinx-build\", \"-b\", mode, \"docs\", path],\n                    stderr=subprocess.STDOUT)\n            except subprocess.CalledProcessError as exc:\n                raise RuntimeError(\"Documentation step '%s' failed: %s: %s\" % (mode, exc, exc.output))\n            else:\n                print(output)\n\n            print(\"\")\n            print(\"Documentation step '%s' performed, results here:\" % mode)\n            print(\"   file://%s/%s/index.html\" % (os.path.dirname(os.path.realpath(__file__)), path))",
              "triple_sequences": [
                {
                  "action_api": "os.makedirs()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "\"docs/_build/%s\" % __version__",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "glob.glob()",
                  "action_description": "List directory contents",
                  "action_id": "list_directory_contents",
                  "object": "\"cassandra/*.so\"",
                  "object_description": "Local file or directory name",
                  "object_id": "local_file_or_directory_name",
                  "intention_description": "List files in directory",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "os.unlink()",
                  "action_description": "Deletes specified file from filesystem",
                  "action_id": "delete_file",
                  "object": "f",
                  "object_description": "Local file",
                  "object_id": "local_file",
                  "intention_description": "Delete file",
                  "intention_id": "delete_file"
                },
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"python\", \"setup.py\", \"build_ext\", \"--inplace\", \"--force\", \"--no-murmur3\", \"--no-cython\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"sphinx-build\", \"-b\", mode, \"docs\", path]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.realpath(__file__)",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.realpath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Get script file path",
                  "intention_id": "get_script_file_path"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "gdal-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/gdal-3.10.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gdal-3.10.3/gdal-3.10.3/setup.py",
          "line_number": "91",
          "type_description": "code-execution",
          "context_snippet": "def fetch_config(option, gdal_config='gdal-config'):\n\n    command = gdal_config + \" --%s\" % option\n\n    import subprocess\n    command, args = command.split()[0], command.split()[1]\n    try:\n        p = subprocess.Popen([command, args], stdout=subprocess.PIPE)\n    except OSError:\n        e = sys.exc_info()[1]\n        raise gdal_config_error(e)\n    r = p.stdout.readline().decode('ascii').strip()\n    p.stdout.close()\n    p.wait()\n\n    return r",
          "hash_value": "27c713a3a608deb140b4671ff62e2ca2",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def fetch_config(option, gdal_config='gdal-config'):\n\n    command = gdal_config + \" --%s\" % option\n\n    import subprocess\n    command, args = command.split()[0], command.split()[1]\n    try:\n        p = subprocess.Popen([command, args], stdout=subprocess.PIPE)\n    except OSError:\n        e = sys.exc_info()[1]\n        raise gdal_config_error(e)\n    r = p.stdout.readline().decode('ascii').strip()\n    p.stdout.close()\n    p.wait()\n\n    return r",
              "triple_sequences": [
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "[command, args]",
                  "object_description": "System command",
                  "object_id": "system_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "p.stdout.readline()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "str.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "'ascii'",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                },
                {
                  "action_api": "str.strip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "p.stdout.close()",
                  "action_description": "Closes the opened file",
                  "action_id": "close_file",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Close file",
                  "intention_id": "close_file"
                },
                {
                  "action_api": "p.wait()",
                  "action_description": "Waits for process to complete execution",
                  "action_id": "wait_process_completion",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Wait for events",
                  "intention_id": "wait_for_events"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "google_re2-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/google_re2-1.1.20240702.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_re2-1.1.20240702/google_re2-1.1.20240702/setup.py",
          "line_number": "71",
          "type_description": "code-execution",
          "context_snippet": "class BuildExt(setuptools.command.build_ext.build_ext):\n\n  def build_extension(self, ext):\n    if 'GITHUB_ACTIONS' not in os.environ:\n      return super().build_extension(ext)\n\n    cmd = ['bazel', 'build']\n    try:\n      cpu = os.environ['BAZEL_CPU']\n      cmd.append(f'--cpu={cpu}')\n      cmd.append(f'--platforms=//python:{cpu}')\n      if cpu == 'x64_x86_windows':\n        # Register the local 32-bit C++ toolchain with highest priority.\n        # (This is likely to break in some release of Bazel after 7.0.0,\n        # but this special case can hopefully be entirely removed then.)\n        cmd.append(f'--extra_toolchains=@local_config_cc//:cc-toolchain-{cpu}')\n    except KeyError:\n      pass\n    try:\n      ver = os.environ['MACOSX_DEPLOYMENT_TARGET']\n      cmd.append(f'--macos_minimum_os={ver}')\n    except KeyError:\n      pass\n    # Register the local Python toolchains with highest priority.\n    cmd.append('--extra_toolchains=//python/toolchains:all')\n    cmd += ['--compilation_mode=opt', '--', ':all']\n    self.spawn(cmd)\n\n    # This ensures that f'_re2.{importlib.machinery.EXTENSION_SUFFIXES[0]}'\n    # is the filename in the destination directory, which is what's needed.\n    shutil.copyfile('../bazel-bin/python/_re2.so',\n                    self.get_ext_fullpath(ext.name))\n\n    cmd = ['bazel', 'clean', '--expunge']\n    self.spawn(cmd)",
          "hash_value": "f6fddd3966d894424109f79c58f4edd1",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class BuildExt(setuptools.command.build_ext.build_ext):\n\n  def build_extension(self, ext):\n    if 'GITHUB_ACTIONS' not in os.environ:\n      return super().build_extension(ext)\n\n    cmd = ['bazel', 'build']\n    try:\n      cpu = os.environ['BAZEL_CPU']\n      cmd.append(f'--cpu={cpu}')\n      cmd.append(f'--platforms=//python:{cpu}')\n      if cpu == 'x64_x86_windows':\n        # Register the local 32-bit C++ toolchain with highest priority.\n        # (This is likely to break in some release of Bazel after 7.0.0,\n        # but this special case can hopefully be entirely removed then.)\n        cmd.append(f'--extra_toolchains=@local_config_cc//:cc-toolchain-{cpu}')\n    except KeyError:\n      pass\n    try:\n      ver = os.environ['MACOSX_DEPLOYMENT_TARGET']\n      cmd.append(f'--macos_minimum_os={ver}')\n    except KeyError:\n      pass\n    # Register the local Python toolchains with highest priority.\n    cmd.append('--extra_toolchains=//python/toolchains:all')\n    cmd += ['--compilation_mode=opt', '--', ':all']\n    self.spawn(cmd)\n\n    # This ensures that f'_re2.{importlib.machinery.EXTENSION_SUFFIXES[0]}'\n    # is the filename in the destination directory, which is what's needed.\n    shutil.copyfile('../bazel-bin/python/_re2.so',\n                    self.get_ext_fullpath(ext.name))\n\n    cmd = ['bazel', 'clean', '--expunge']\n    self.spawn(cmd)",
              "triple_sequences": [
                {
                  "action_api": "os.environ.__contains__()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "'GITHUB_ACTIONS'",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.__getitem__()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'BAZEL_CPU'",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.__getitem__()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'MACOSX_DEPLOYMENT_TARGET'",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "self.spawn()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "cmd",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "shutil.copyfile()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "'../bazel-bin/python/_re2.so', self.get_ext_fullpath(ext.name)",
                  "object_description": "Local file or directory",
                  "object_id": "local_file_or_directory",
                  "intention_description": "Copy file to startup directory",
                  "intention_id": "copy_file_startup_directory"
                },
                {
                  "action_api": "self.spawn()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "cmd",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pygame_ce-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pygame_ce-2.5.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pygame_ce-2.5.3/pygame_ce-2.5.3/setup.py",
          "line_number": "121",
          "type_description": "code-execution",
          "context_snippet": "def spawn(self, cmd, **kwargs):\n    should_use_avx2 = False\n    # try to be thorough in detecting that we are on a platform that potentially supports AVX2\n    machine_name = platform.machine()\n    if ((machine_name.startswith((\"x86\", \"i686\")) or\n        machine_name.lower() == \"amd64\") and\n            os.environ.get(\"MAC_ARCH\") != \"arm64\"):\n        should_use_avx2 = True\n\n    if should_use_avx2:\n        extra_options = compiler_options.get(self.compiler_type)\n        if extra_options is not None:\n            # filenames are closer to the end of command line\n            for argument in reversed(cmd):\n                # Check if argument contains a filename. We must check for all\n                # possible extensions; checking for target extension is faster.\n                if not argument.endswith(self.obj_extension):\n                    continue\n\n                # check for a filename only to avoid building a new string\n                # with variable extension\n                for filename in avx2_filenames:\n                    off_end = -len(self.obj_extension)\n                    off_start = -len(filename) + off_end\n                    if argument.endswith(filename, off_start, off_end):\n                        if self.compiler_type == 'bcpp':\n                            # Borland accepts a source file name at the end,\n                            # insert the options before it\n                            cmd[-1:-1] = extra_options\n                        else:\n                            cmd += extra_options\n\n                # filename is found, no need to search any further\n                break\n\n    distutils.ccompiler.spawn(cmd, dry_run=self.dry_run, **kwargs)",
          "hash_value": "4898a0dc2a5cdc08648b775da22342bc",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def spawn(self, cmd, **kwargs):\n    should_use_avx2 = False\n    # try to be thorough in detecting that we are on a platform that potentially supports AVX2\n    machine_name = platform.machine()\n    if ((machine_name.startswith((\"x86\", \"i686\")) or\n        machine_name.lower() == \"amd64\") and\n            os.environ.get(\"MAC_ARCH\") != \"arm64\"):\n        should_use_avx2 = True\n\n    if should_use_avx2:\n        extra_options = compiler_options.get(self.compiler_type)\n        if extra_options is not None:\n            # filenames are closer to the end of command line\n            for argument in reversed(cmd):\n                # Check if argument contains a filename. We must check for all\n                # possible extensions; checking for target extension is faster.\n                if not argument.endswith(self.obj_extension):\n                    continue\n\n                # check for a filename only to avoid building a new string\n                # with variable extension\n                for filename in avx2_filenames:\n                    off_end = -len(self.obj_extension)\n                    off_start = -len(filename) + off_end\n                    if argument.endswith(filename, off_start, off_end):\n                        if self.compiler_type == 'bcpp':\n                            # Borland accepts a source file name at the end,\n                            # insert the options before it\n                            cmd[-1:-1] = extra_options\n                        else:\n                            cmd += extra_options\n\n                # filename is found, no need to search any further\n                break\n\n    distutils.ccompiler.spawn(cmd, dry_run=self.dry_run, **kwargs)",
              "triple_sequences": [
                {
                  "action_api": "platform.machine()",
                  "action_description": "Retrieves machine type",
                  "action_id": "get_machine_type",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get system info",
                  "intention_id": "get_system_info"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "MAC_ARCH",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "distutils.ccompiler.spawn()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "cmd",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Create child process",
                  "intention_id": "create_child_process"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "mosaicml-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/mosaicml-0.30.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/mosaicml-0.30.0/mosaicml-0.30.0/setup.py",
          "line_number": "241",
          "type_description": "cmd-overwrite",
          "context_snippet": "import os\nimport site\nimport sys\nimport textwrap\n\nimport setuptools\nfrom setuptools import setup\nfrom setuptools.command.develop import develop as develop_orig\n\n# Read the composer version\n# Cannot import from `composer.__version__` since that will not be available when building or installing the package\nwith open(os.path.join(os.path.dirname(__file__), 'composer', '_version.py')) as f:\n    version_globals = {}\n    version_locals = {}\n    exec(f.read(), version_globals, version_locals)\n    composer_version = version_locals['__version__']\n\n_IS_ROOT = os.getuid() == 0\n_IS_USER = '--user' in sys.argv[1:]\n_IS_VIRTUALENV = 'VIRTUAL_ENV' in os.environ\n\n# ... (many lines omitted for brevity, see full code above) ...\n\npackage_name = os.environ.get('COMPOSER_PACKAGE_NAME', 'mosaicml')\n\nif package_name != 'mosaicml':\n    print(f'`Building composer as `{package_name}`)', file=sys.stderr)\n\nsetup(\n    name=package_name,\n    version=composer_version,\n    author='MosaicML',\n    author_email='team@mosaicml.com',\n    description=(\n        'Composer is a PyTorch library that enables you to train ' +\n        'neural networks faster, at lower cost, and to higher accuracy.'\n    ),\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    url='https://github.com/mosaicml/composer',\n    include_package_data=True,\n    package_data={\n        'composer': composer_data_files,\n    },\n    packages=setuptools.find_packages(exclude=['docker*', 'examples*', 'scripts*', 'tests*']),\n    classifiers=[\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n        'Programming Language :: Python :: 3.12',\n    ],\n    install_requires=install_requires,\n    entry_points={\n        'console_scripts': [\n            'composer = composer.cli.launcher:main',\n            'composer_collect_env = composer.utils.collect_env:main',\n            'composer_validate_remote_path = composer.utils.file_helpers:validate_remote_path',\n        ],\n    },\n    extras_require=extra_deps,\n    dependency_links=['https://developer.download.nvidia.com/compute/redist'],\n    python_requires='>=3.10',\n    ext_package='composer',\n    cmdclass={'develop': develop},\n)\n",
          "hash_value": "43f5817a24863363623d8f1276749279",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport site\nimport sys\nimport textwrap\n\nimport setuptools\nfrom setuptools import setup\nfrom setuptools.command.develop import develop as develop_orig\n\n# Read the composer version\n# Cannot import from `composer.__version__` since that will not be available when building or installing the package\nwith open(os.path.join(os.path.dirname(__file__), 'composer', '_version.py')) as f:\n    version_globals = {}\n    version_locals = {}\n    exec(f.read(), version_globals, version_locals)\n    composer_version = version_locals['__version__']\n\n_IS_ROOT = os.getuid() == 0\n_IS_USER = '--user' in sys.argv[1:]\n_IS_VIRTUALENV = 'VIRTUAL_ENV' in os.environ\n\n# ... (many lines omitted for brevity, see full code above) ...\n\npackage_name = os.environ.get('COMPOSER_PACKAGE_NAME', 'mosaicml')\n\nif package_name != 'mosaicml':\n    print(f'`Building composer as `{package_name}`)', file=sys.stderr)\n\nsetup(\n    name=package_name,\n    version=composer_version,\n    author='MosaicML',\n    author_email='team@mosaicml.com',\n    description=(\n        'Composer is a PyTorch library that enables you to train ' +\n        'neural networks faster, at lower cost, and to higher accuracy.'\n    ),\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    url='https://github.com/mosaicml/composer',\n    include_package_data=True,\n    package_data={\n        'composer': composer_data_files,\n    },\n    packages=setuptools.find_packages(exclude=['docker*', 'examples*', 'scripts*', 'tests*']),\n    classifiers=[\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n        'Programming Language :: Python :: 3.12',\n    ],\n    install_requires=install_requires,\n    entry_points={\n        'console_scripts': [\n            'composer = composer.cli.launcher:main',\n            'composer_collect_env = composer.utils.collect_env:main',\n            'composer_validate_remote_path = composer.utils.file_helpers:validate_remote_path',\n        ],\n    },\n    extras_require=extra_deps,\n    dependency_links=['https://developer.download.nvidia.com/compute/redist'],\n    python_requires='>=3.10',\n    ext_package='composer',\n    cmdclass={'develop': develop},\n)\n",
              "triple_sequences": [
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Get script file path",
                  "intention_id": "get_script_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.dirname(__file__), 'composer', '_version.py'",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "os.path.join(os.path.dirname(__file__), 'composer', '_version.py')",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "f.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "exec()",
                  "action_description": "Dynamically executes Python code string",
                  "action_id": "exec_python_code",
                  "object": "f.read(), version_globals, version_locals",
                  "object_description": "Python code string",
                  "object_id": "python_code_string",
                  "intention_description": "Execute Python code",
                  "intention_id": "execute_python_code"
                },
                {
                  "action_api": "os.getuid()",
                  "action_description": "Retrieves current user login name",
                  "action_id": "get_username",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access current username",
                  "intention_id": "access_current_username"
                },
                {
                  "action_api": "sys.argv",
                  "action_description": "Retrieves command-line arguments passed to script",
                  "action_id": "get_cmd_args",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access command line arguments",
                  "intention_id": "access_command_line_arguments"
                },
                {
                  "action_api": "os.environ",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'COMPOSER_PACKAGE_NAME', 'mosaicml'",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "print()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "f'`Building composer as `{package_name}`)', file=sys.stderr",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "setuptools.find_packages()",
                  "action_description": "Retrieves package information",
                  "action_id": "get_platform_info",
                  "object": "exclude=['docker*', 'examples*', 'scripts*', 'tests*']",
                  "object_description": "Program directory",
                  "object_id": "program_directory",
                  "intention_description": "Get system info",
                  "intention_id": "get_system_info"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "name=package_name, version=composer_version, ...",
                  "object_description": "Python command",
                  "object_id": "python_command",
                  "intention_description": "Trigger main behavioral logic",
                  "intention_id": "trigger_main_behavioral_logic"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "dtaidistance-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/dtaidistance-2.3.13.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/dtaidistance-2.3.13/dtaidistance-2.3.13/setup.py",
          "line_number": "312",
          "type_description": "code-execution",
          "context_snippet": "def check_clang(cc_bin, printfn=print):\n    \"\"\"Check if gcc is really an xcrun to clang\"\"\"\n    printfn(\"Checking if {} redirects to clang\".format(cc_bin))\n    args = [[str(cc_bin), \"--version\"]]\n    kwargs = {\"stdout\": sp.PIPE, \"stderr\": sp.PIPE, \"input\": '', \"encoding\": 'ascii'}\n    printfn(\" \".join(args[0]) + \" # with \" + \", \".join(str(k) + \"=\" + str(v) for k, v in kwargs.items()))\n    try:\n        p = sp.run(*args, **kwargs)\n        printfn(p.stderr)\n        defs = p.stdout.splitlines()\n        for curdef in defs:\n            if \"clang\" in curdef:\n                printfn(curdef)\n                printfn(\"... found clang\")\n                return True\n    except Exception:\n        printfn(\"... no clang\")\n        return False\n    return False",
          "hash_value": "de085b9b771f81f74d6e6fb7ae4b3680",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def check_clang(cc_bin, printfn=print):\n    \"\"\"Check if gcc is really an xcrun to clang\"\"\"\n    printfn(\"Checking if {} redirects to clang\".format(cc_bin))\n    args = [[str(cc_bin), \"--version\"]]\n    kwargs = {\"stdout\": sp.PIPE, \"stderr\": sp.PIPE, \"input\": '', \"encoding\": 'ascii'}\n    printfn(\" \".join(args[0]) + \" # with \" + \", \".join(str(k) + \"=\" + str(v) for k, v in kwargs.items()))\n    try:\n        p = sp.run(*args, **kwargs)\n        printfn(p.stderr)\n        defs = p.stdout.splitlines()\n        for curdef in defs:\n            if \"clang\" in curdef:\n                printfn(curdef)\n                printfn(\"... found clang\")\n                return True\n    except Exception:\n        printfn(\"... no clang\")\n        return False\n    return False",
              "triple_sequences": [
                {
                  "action_api": "print()",
                  "action_description": "Reads user input from standard input",
                  "action_id": "read_user_input",
                  "object": "\"Checking if {} redirects to clang\".format(cc_bin)",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect user input",
                  "intention_id": "collect_user_input"
                },
                {
                  "action_api": "str.format()",
                  "action_description": "Encodes string to bytes using default encoding",
                  "action_id": "encode_string_to_bytes",
                  "object": "\"Checking if {} redirects to clang\", cc_bin",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "str()",
                  "action_description": "Encodes string to bytes using default encoding",
                  "action_id": "encode_string_to_bytes",
                  "object": "cc_bin",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "print()",
                  "action_description": "Reads user input from standard input",
                  "action_id": "read_user_input",
                  "object": "\" \".join(args[0]) + \" # with \" + \", \".join(str(k) + \"=\" + str(v) for k, v in kwargs.items())",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect user input",
                  "intention_id": "collect_user_input"
                },
                {
                  "action_api": "str.join()",
                  "action_description": "Joins characters into string",
                  "action_id": "join_characters_into_string",
                  "object": "args[0]",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "str()",
                  "action_description": "Encodes string to bytes using default encoding",
                  "action_id": "encode_string_to_bytes",
                  "object": "k",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "str()",
                  "action_description": "Encodes string to bytes using default encoding",
                  "action_id": "encode_string_to_bytes",
                  "object": "v",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "str.join()",
                  "action_description": "Joins characters into string",
                  "action_id": "join_characters_into_string",
                  "object": "(str(k) + \"=\" + str(v) for k, v in kwargs.items())",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "sp.run()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "args, kwargs",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "print()",
                  "action_description": "Reads user input from standard input",
                  "action_id": "read_user_input",
                  "object": "p.stderr",
                  "object_description": "Command error output",
                  "object_id": "command_output",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "str.splitlines()",
                  "action_description": "Basic string operations (splitting and joining strings)",
                  "action_id": "path_string_operations",
                  "object": "p.stdout",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "print()",
                  "action_description": "Reads user input from standard input",
                  "action_id": "read_user_input",
                  "object": "curdef",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect user input",
                  "intention_id": "collect_user_input"
                },
                {
                  "action_api": "print()",
                  "action_description": "Reads user input from standard input",
                  "action_id": "read_user_input",
                  "object": "\"... found clang\"",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect user input",
                  "intention_id": "collect_user_input"
                },
                {
                  "action_api": "print()",
                  "action_description": "Reads user input from standard input",
                  "action_id": "read_user_input",
                  "object": "\"... no clang\"",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect user input",
                  "intention_id": "collect_user_input"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "aider_chat-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/aider_chat-0.81.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "commands.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/aider_chat-0.81.2/aider_chat-0.81.2/aider/commands.py",
          "line_number": "1280",
          "type_description": "clipboard-access",
          "context_snippet": "def cmd_paste(self, args):\n    \"\"\"Paste image/text from the clipboard into the chat.\\\n    Optionally provide a name for the image.\"\"\"\n    try:\n        # Check for image first\n        image = ImageGrab.grabclipboard()\n        if isinstance(image, Image.Image):\n            if args.strip():\n                filename = args.strip()\n                ext = os.path.splitext(filename)[1].lower()\n                if ext in (\".jpg\", \".jpeg\", \".png\"):\n                    basename = filename\n                else:\n                    basename = f\"{filename}.png\"\n            else:\n                basename = \"clipboard_image.png\"\n\n            temp_dir = tempfile.mkdtemp()\n            temp_file_path = os.path.join(temp_dir, basename)\n            image_format = \"PNG\" if basename.lower().endswith(\".png\") else \"JPEG\"\n            image.save(temp_file_path, image_format)\n\n            abs_file_path = Path(temp_file_path).resolve()\n\n            # Check if a file with the same name already exists in the chat\n            existing_file = next(\n                (f for f in self.coder.abs_fnames if Path(f).name == abs_file_path.name), None\n            )\n            if existing_file:\n                self.coder.abs_fnames.remove(existing_file)\n                self.io.tool_output(f\"Replaced existing image in the chat: {existing_file}\")\n\n            self.coder.abs_fnames.add(str(abs_file_path))\n            self.io.tool_output(f\"Added clipboard image to the chat: {abs_file_path}\")\n            self.coder.check_added_files()\n\n            return\n\n        # If not an image, try to get text\n        text = pyperclip.paste()\n        if text:\n            self.io.tool_output(text)\n            return text\n\n        self.io.tool_error(\"No image or text content found in clipboard.\")\n        return\n\n    except Exception as e:\n        self.io.tool_error(f\"Error processing clipboard content: {e}\")",
          "hash_value": "ec93c6dd224897d7d2d94d363150bc48",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def cmd_paste(self, args):\n    \"\"\"Paste image/text from the clipboard into the chat.\\\n    Optionally provide a name for the image.\"\"\"\n    try:\n        # Check for image first\n        image = ImageGrab.grabclipboard()\n        if isinstance(image, Image.Image):\n            if args.strip():\n                filename = args.strip()\n                ext = os.path.splitext(filename)[1].lower()\n                if ext in (\".jpg\", \".jpeg\", \".png\"):\n                    basename = filename\n                else:\n                    basename = f\"{filename}.png\"\n            else:\n                basename = \"clipboard_image.png\"\n\n            temp_dir = tempfile.mkdtemp()\n            temp_file_path = os.path.join(temp_dir, basename)\n            image_format = \"PNG\" if basename.lower().endswith(\".png\") else \"JPEG\"\n            image.save(temp_file_path, image_format)\n\n            abs_file_path = Path(temp_file_path).resolve()\n\n            # Check if a file with the same name already exists in the chat\n            existing_file = next(\n                (f for f in self.coder.abs_fnames if Path(f).name == abs_file_path.name), None\n            )\n            if existing_file:\n                self.coder.abs_fnames.remove(existing_file)\n                self.io.tool_output(f\"Replaced existing image in the chat: {existing_file}\")\n\n            self.coder.abs_fnames.add(str(abs_file_path))\n            self.io.tool_output(f\"Added clipboard image to the chat: {abs_file_path}\")\n            self.coder.check_added_files()\n\n            return\n\n        # If not an image, try to get text\n        text = pyperclip.paste()\n        if text:\n            self.io.tool_output(text)\n            return text\n\n        self.io.tool_error(\"No image or text content found in clipboard.\")\n        return\n\n    except Exception as e:\n        self.io.tool_error(f\"Error processing clipboard content: {e}\")",
              "triple_sequences": [
                {
                  "action_api": "ImageGrab.grabclipboard()",
                  "action_description": "Retrieves text from system clipboard",
                  "action_id": "get_clipboard_text",
                  "object": "",
                  "object_description": "Clipboard content data",
                  "object_id": "clipboard_data",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                },
                {
                  "action_api": "isinstance(image, Image.Image)",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "image, Image.Image",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Detect image file",
                  "intention_id": "detect_image_file"
                },
                {
                  "action_api": "os.path.splitext()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "filename",
                  "object_description": "Local file or directory name",
                  "object_id": "local_file_or_directory_name",
                  "intention_description": "Prepare path for file operations",
                  "intention_id": "prepare_path_file_operations"
                },
                {
                  "action_api": "tempfile.mkdtemp()",
                  "action_description": "Creates temporary directory and returns its path",
                  "action_id": "create_temp_dir",
                  "object": "",
                  "object_description": "Temporary directory",
                  "object_id": "temporary_directory",
                  "intention_description": "Create temporary directory",
                  "intention_id": "create_temporary_directory"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "temp_dir, basename",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Prepare path for file operations",
                  "intention_id": "prepare_path_file_operations"
                },
                {
                  "action_api": "image.save()",
                  "action_description": "Saves image to file",
                  "action_id": "save_image_file",
                  "object": "temp_file_path, image_format",
                  "object_description": "Image file",
                  "object_id": "image_file",
                  "intention_description": "Save screenshot to file",
                  "intention_id": "save_screenshot_file"
                },
                {
                  "action_api": "Path(temp_file_path).resolve()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "temp_file_path",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Prepare path for file operations",
                  "intention_id": "prepare_path_file_operations"
                },
                {
                  "action_api": "next((f for f in self.coder.abs_fnames if Path(f).name == abs_file_path.name), None)",
                  "action_description": "List directory contents",
                  "action_id": "list_directory_contents",
                  "object": "self.coder.abs_fnames",
                  "object_description": "Local file or directory",
                  "object_id": "local_file_or_directory",
                  "intention_description": "List files in directory",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "self.coder.abs_fnames.remove(existing_file)",
                  "action_description": "Deletes specified file from filesystem",
                  "action_id": "delete_file",
                  "object": "existing_file",
                  "object_description": "Local file",
                  "object_id": "local_file",
                  "intention_description": "Delete file",
                  "intention_id": "delete_file"
                },
                {
                  "action_api": "self.coder.abs_fnames.add(str(abs_file_path))",
                  "action_description": "Adds file to ZIP archive with specified archive name",
                  "action_id": "add_file_zip",
                  "object": "str(abs_file_path)",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Add file to zip archive",
                  "intention_id": "add_file_to_archive"
                },
                {
                  "action_api": "self.coder.check_added_files()",
                  "action_description": "Iterates over all running processes",
                  "action_id": "iterate_processes",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "List processes",
                  "intention_id": "list_processes"
                },
                {
                  "action_api": "pyperclip.paste()",
                  "action_description": "Retrieves text from system clipboard",
                  "action_id": "get_clipboard_text",
                  "object": "",
                  "object_description": "Clipboard content data",
                  "object_id": "clipboard_data",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                },
                {
                  "action_api": "self.io.tool_output(text)",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "text",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Send data to server",
                  "intention_id": "send_data_server"
                },
                {
                  "action_api": "self.io.tool_error(\"No image or text content found in clipboard.\")",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "\"No image or text content found in clipboard.\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "self.io.tool_error(f\"Error processing clipboard content: {e}\")",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "f\"Error processing clipboard content: {e}\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "serial-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/serial-0.0.97.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "__init__.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/serial-0.0.97/serial-0.0.97/serial/utilities/__init__.py",
          "line_number": "179",
          "type_description": "obfuscation",
          "context_snippet": "def calling_function_qualified_name(depth=1):\n    # type: (int) -> Optional[str]\n    \"\"\"\n    >>> def my_function(): return calling_function_qualified_name()\n    >>> print(my_function())\n    \"\"\"\n\n    if not isinstance(depth, int):\n\n        depth_representation = repr(depth)\n\n        raise TypeError(\n            'The parameter `depth` for `serial.utilities.calling_function_qualified_name` must be an `int`, not' +\n            (\n                (':\\n%s' if '\\n' in depth_representation else ' %s.') %\n                depth_representation\n            )\n        )\n    try:\n        stack = inspect.stack()\n    except IndexError:\n        return None\n\n    if len(stack) < (depth + 1):\n        return None\n\n    name_list = []\n    frame_info = stack[depth]  # type: inspect.FrameInfo\n\n    try:\n        frame_function = frame_info.function\n    except AttributeError:\n        frame_function = frame_info[3]\n\n    if frame_function != '<module>':\n\n        try:\n            frame = frame_info.frame\n        except AttributeError:\n            frame = frame_info[0]\n\n        name_list.append(frame_function)\n        arguments, _, _, frame_locals = inspect.getargvalues(frame)\n\n        if arguments:\n\n            argument = arguments[0]\n            argument_value = frame_locals[argument]\n            argument_value_type = type(argument_value)\n\n            if (\n                hasattr(argument_value_type, '__name__') and\n                hasattr(argument_value_type, '__module__') and\n                (\n                    (argument_value_type.__name__ not in dir(builtins)) or\n                    (getattr(builtins, argument_value_type.__name__) is not argument_value_type)\n                )\n            ):\n                name_list.append(qualified_name(argument_value_type))\n\n    if len(name_list) < 2:\n\n        try:\n            file_name = frame_info.filename\n        except AttributeError:\n            file_name = frame_info[1]\n\n        module_name = inspect.getmodulename(file_name)\n\n        if (module_name is not None) and (module_name not in sys.modules):\n\n            path_parts = list(os.path.split(file_name))\n            path_parts.pop()\n\n            while path_parts:\n\n                parent = path_parts.pop()\n                module_name = parent + '.' + module_name\n\n                if module_name in sys.modules:\n                    break\n\n        if module_name is None:\n            raise ValueError('The path \"%s\" is not a python module' % file_name)\n        else:\n            if module_name in sys.modules:\n                qualified_module_name = qualified_name(sys.modules[module_name])\n                name_list.append(qualified_module_name)\n\n    return '.'.join(reversed(name_list))\n\n# Data dependencies:\n# - 'builtins' is imported at the top: import builtins\n# - 'argument_value_type' is set as type(argument_value) in this function\n# - 'qualified_name' is a helper function defined above\n# - 'inspect' is imported at the top\n# - 'os', 'sys' are imported at the top\n",
          "hash_value": "435c316d7c00213c209be573d29c208d",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def calling_function_qualified_name(depth=1):\n    # type: (int) -> Optional[str]\n    \"\"\"\n    >>> def my_function(): return calling_function_qualified_name()\n    >>> print(my_function())\n    \"\"\"\n\n    if not isinstance(depth, int):\n\n        depth_representation = repr(depth)\n\n        raise TypeError(\n            'The parameter `depth` for `serial.utilities.calling_function_qualified_name` must be an `int`, not' +\n            (\n                (':\\n%s' if '\\n' in depth_representation else ' %s.') %\n                depth_representation\n            )\n        )\n    try:\n        stack = inspect.stack()\n    except IndexError:\n        return None\n\n    if len(stack) < (depth + 1):\n        return None\n\n    name_list = []\n    frame_info = stack[depth]  # type: inspect.FrameInfo\n\n    try:\n        frame_function = frame_info.function\n    except AttributeError:\n        frame_function = frame_info[3]\n\n    if frame_function != '<module>':\n\n        try:\n            frame = frame_info.frame\n        except AttributeError:\n            frame = frame_info[0]\n\n        name_list.append(frame_function)\n        arguments, _, _, frame_locals = inspect.getargvalues(frame)\n\n        if arguments:\n\n            argument = arguments[0]\n            argument_value = frame_locals[argument]\n            argument_value_type = type(argument_value)\n\n            if (\n                hasattr(argument_value_type, '__name__') and\n                hasattr(argument_value_type, '__module__') and\n                (\n                    (argument_value_type.__name__ not in dir(builtins)) or\n                    (getattr(builtins, argument_value_type.__name__) is not argument_value_type)\n                )\n            ):\n                name_list.append(qualified_name(argument_value_type))\n\n    if len(name_list) < 2:\n\n        try:\n            file_name = frame_info.filename\n        except AttributeError:\n            file_name = frame_info[1]\n\n        module_name = inspect.getmodulename(file_name)\n\n        if (module_name is not None) and (module_name not in sys.modules):\n\n            path_parts = list(os.path.split(file_name))\n            path_parts.pop()\n\n            while path_parts:\n\n                parent = path_parts.pop()\n                module_name = parent + '.' + module_name\n\n                if module_name in sys.modules:\n                    break\n\n        if module_name is None:\n            raise ValueError('The path \"%s\" is not a python module' % file_name)\n        else:\n            if module_name in sys.modules:\n                qualified_module_name = qualified_name(sys.modules[module_name])\n                name_list.append(qualified_module_name)\n\n    return '.'.join(reversed(name_list))\n\n# Data dependencies:\n# - 'builtins' is imported at the top: import builtins\n# - 'argument_value_type' is set as type(argument_value) in this function\n# - 'qualified_name' is a helper function defined above\n# - 'inspect' is imported at the top\n# - 'os', 'sys' are imported at the top\n",
              "triple_sequences": [
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "depth, int",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine required module presence",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "repr()",
                  "action_description": "Converts object to string representation",
                  "action_id": "prepare_string_processing",
                  "object": "depth",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "inspect.stack()",
                  "action_description": "Extracts current call stack as FrameSummary objects",
                  "action_id": "extract_call_stack",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "len()",
                  "action_description": "Returns length of object",
                  "action_id": "prepare_data_processing",
                  "object": "stack",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "hasattr()",
                  "action_description": "Checks if object has specified attribute",
                  "action_id": "prepare_data_processing",
                  "object": "argument_value_type, '__name__'",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "hasattr()",
                  "action_description": "Checks if object has specified attribute",
                  "action_id": "prepare_data_processing",
                  "object": "argument_value_type, '__module__'",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "dir()",
                  "action_description": "Returns list of attributes for object",
                  "action_id": "prepare_data_processing",
                  "object": "builtins",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Retrieves attribute value from object",
                  "action_id": "prepare_data_processing",
                  "object": "builtins, argument_value_type.__name__",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "os.path.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "file_name",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Prepare path for file operations",
                  "intention_id": "prepare_path_file_operations"
                },
                {
                  "action_api": "inspect.getmodulename()",
                  "action_description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
                  "action_id": "path_special_operations",
                  "object": "file_name",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Prepare path for browser data access",
                  "intention_id": "prepare_path_browser_data"
                },
                {
                  "action_api": "sys.modules",
                  "action_description": "Dynamically imports specified module",
                  "action_id": "import_dynamic",
                  "object": "module_name",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "qualified_name()",
                  "action_description": "Constructs qualified name for object",
                  "action_id": "prepare_string_processing",
                  "object": "argument_value_type or sys.modules[module_name]",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "str.join()",
                  "action_description": "Joins characters into string",
                  "action_id": "join_characters_into_string",
                  "object": "reversed(name_list)",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Join characters into string",
                  "intention_id": "join_characters_into_string"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "praat_parselmouth-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/praat_parselmouth-0.4.5.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "conf.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/praat_parselmouth-0.4.5/praat_parselmouth-0.4.5/docs/conf.py",
          "line_number": "86",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "import git\nimport github\nimport requests\n\nimport io\nimport os\nimport subprocess\nimport sys\nimport tempfile\nimport zipfile\n\non_rtd = os.environ.get('READTHEDOCS') == 'True'\n\nif on_rtd:\n    rtd_version = os.environ.get('READTHEDOCS_VERSION')\n    branch = 'master' if rtd_version == 'latest' else rtd_version\n\n    github_token = os.environ['GITHUB_TOKEN']\n    head_sha = git.Repo(search_parent_directories=True).head.commit.hexsha\n    g = github.Github()\n    runs = g.get_repo('YannickJadoul/Parselmouth').get_workflow(\"wheels.yml\").get_runs(branch=branch)\n    artifacts_url = next(r for r in runs if r.head_sha == head_sha).artifacts_url\n\n    archive_download_url = next(artifact for artifact in requests.get(artifacts_url).json()['artifacts'] if artifact['name'] == 'rtd-wheel')['archive_download_url']\n    artifact_bin = io.BytesIO(requests.get(archive_download_url, headers={'Authorization': f'token {github_token}'}, stream=True).content)\n\n    with zipfile.ZipFile(artifact_bin) as zf, tempfile.TemporaryDirectory() as tmpdir:\n        assert len(zf.namelist()) == 1\n        zf.extractall(tmpdir)\n        subprocess.check_call([sys.executable, '-m', 'pip', 'install', '--force-reinstall', tmpdir + '/' + zf.namelist()[0]])",
          "hash_value": "36a2fb819a1964d0f6a24a5caea30467",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import git\nimport github\nimport requests\n\nimport io\nimport os\nimport subprocess\nimport sys\nimport tempfile\nimport zipfile\n\non_rtd = os.environ.get('READTHEDOCS') == 'True'\n\nif on_rtd:\n    rtd_version = os.environ.get('READTHEDOCS_VERSION')\n    branch = 'master' if rtd_version == 'latest' else rtd_version\n\n    github_token = os.environ['GITHUB_TOKEN']\n    head_sha = git.Repo(search_parent_directories=True).head.commit.hexsha\n    g = github.Github()\n    runs = g.get_repo('YannickJadoul/Parselmouth').get_workflow(\"wheels.yml\").get_runs(branch=branch)\n    artifacts_url = next(r for r in runs if r.head_sha == head_sha).artifacts_url\n\n    archive_download_url = next(artifact for artifact in requests.get(artifacts_url).json()['artifacts'] if artifact['name'] == 'rtd-wheel')['archive_download_url']\n    artifact_bin = io.BytesIO(requests.get(archive_download_url, headers={'Authorization': f'token {github_token}'}, stream=True).content)\n\n    with zipfile.ZipFile(artifact_bin) as zf, tempfile.TemporaryDirectory() as tmpdir:\n        assert len(zf.namelist()) == 1\n        zf.extractall(tmpdir)\n        subprocess.check_call([sys.executable, '-m', 'pip', 'install', '--force-reinstall', tmpdir + '/' + zf.namelist()[0]])",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'READTHEDOCS'",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'READTHEDOCS_VERSION'",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.__getitem__()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'GITHUB_TOKEN'",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "git.Repo()",
                  "action_description": "Initializes Git command wrapper",
                  "action_id": "init_git_wrapper",
                  "object": "search_parent_directories=True",
                  "object_description": "Repository reference",
                  "object_id": "repository_reference",
                  "intention_description": "Import required module",
                  "intention_id": "import_required_module"
                },
                {
                  "action_api": "git.Repo().head.commit.hexsha",
                  "action_description": "Retrieves current HEAD reference of repository",
                  "action_id": "get_git_head",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Extract structured data from file",
                  "intention_id": "extract_structured_file_data"
                },
                {
                  "action_api": "github.Github()",
                  "action_description": "Instantiates GitHub class",
                  "action_id": "import_dynamic",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Import required module",
                  "intention_id": "import_required_module"
                },
                {
                  "action_api": "g.get_repo()",
                  "action_description": "Retrieves object from repository",
                  "action_id": "get_git_object",
                  "object": "'YannickJadoul/Parselmouth'",
                  "object_description": "Repository reference",
                  "object_id": "repository_reference",
                  "intention_description": "Extract structured data from file",
                  "intention_id": "extract_structured_file_data"
                },
                {
                  "action_api": "repo.get_workflow()",
                  "action_description": "Retrieves object from repository",
                  "action_id": "get_git_object",
                  "object": "\"wheels.yml\"",
                  "object_description": "Repository reference",
                  "object_id": "repository_reference",
                  "intention_description": "Extract structured data from file",
                  "intention_id": "extract_structured_file_data"
                },
                {
                  "action_api": "workflow.get_runs()",
                  "action_description": "Retrieves object from repository",
                  "action_id": "get_git_object",
                  "object": "branch=branch",
                  "object_description": "Repository reference",
                  "object_id": "repository_reference",
                  "intention_description": "Extract structured data from file",
                  "intention_id": "extract_structured_file_data"
                },
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP GET request to URL",
                  "action_id": "open_url_get",
                  "object": "artifacts_url",
                  "object_description": "External domain",
                  "object_id": "external_domain",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "requests.get().json()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP GET request to URL",
                  "action_id": "open_url_get",
                  "object": "archive_download_url, headers={'Authorization': f'token {github_token}'}, stream=True",
                  "object_description": "External domain",
                  "object_id": "external_domain",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "io.BytesIO()",
                  "action_description": "Creates in-memory bytes buffer from encoded string",
                  "action_id": "create_memory_bytes",
                  "object": "requests.get(...).content",
                  "object_description": "Image binary stream",
                  "object_id": "image_binary_stream",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "zipfile.ZipFile()",
                  "action_description": "Opens ZIP archive for reading",
                  "action_id": "open_zip_read",
                  "object": "artifact_bin",
                  "object_description": "ZIP archive file",
                  "object_id": "zip_archive",
                  "intention_description": "Open database for reading",
                  "intention_id": "open_database_reading"
                },
                {
                  "action_api": "tempfile.TemporaryDirectory()",
                  "action_description": "Creates temporary directory and returns its path",
                  "action_id": "create_temp_dir",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Create temporary directory",
                  "intention_id": "create_temporary_directory"
                },
                {
                  "action_api": "zipfile.ZipFile().namelist()",
                  "action_description": "Lists all currently alive threads",
                  "action_id": "list_threads",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "List files in directory",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "zipfile.ZipFile().extractall()",
                  "action_description": "Extracts all files from ZIP archive to specified directory",
                  "action_id": "extract_zip_files",
                  "object": "tmpdir",
                  "object_description": "Temporary directory",
                  "object_id": "temporary_directory",
                  "intention_description": "Decompress downloaded archive",
                  "intention_id": "decompress_downloaded_archive"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[sys.executable, '-m', 'pip', 'install', '--force-reinstall', tmpdir + '/' + zf.namelist()[0]]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "apprise-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/apprise-1.9.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "discord.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/apprise-1.9.3/apprise-1.9.3/apprise/plugins/discord.py",
          "line_number": "76",
          "type_description": "shady-links",
          "context_snippet": "class NotifyDiscord(NotifyBase):\n    \"\"\"\n    A wrapper to Discord Notifications\n\n    \"\"\"\n    # The default descriptive name associated with the Notification\n    service_name = 'Discord'\n\n    # The services URL\n    service_url = 'https://discord.com/'\n\n    # The default secure protocol\n    secure_protocol = 'discord'\n\n    # A URL that takes you to the setup/help of the specific protocol\n    setup_url = 'https://github.com/caronc/apprise/wiki/Notify_discord'\n\n    # Discord Webhook\n    notify_url = 'https://discord.com/api/webhooks'\n\n    # Support attachments\n    attachment_support = True\n\n    # Allows the user to specify the NotifyImageSize object\n    image_size = NotifyImageSize.XY_256",
          "hash_value": "89789eed5b3c621edc3ae6597fa23d3a",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class NotifyDiscord(NotifyBase):\n    \"\"\"\n    A wrapper to Discord Notifications\n\n    \"\"\"\n    # The default descriptive name associated with the Notification\n    service_name = 'Discord'\n\n    # The services URL\n    service_url = 'https://discord.com/'\n\n    # The default secure protocol\n    secure_protocol = 'discord'\n\n    # A URL that takes you to the setup/help of the specific protocol\n    setup_url = 'https://github.com/caronc/apprise/wiki/Notify_discord'\n\n    # Discord Webhook\n    notify_url = 'https://discord.com/api/webhooks'\n\n    # Support attachments\n    attachment_support = True\n\n    # Allows the user to specify the NotifyImageSize object\n    image_size = NotifyImageSize.XY_256",
              "triple_sequences": [
                {
                  "action_api": "",
                  "action_description": "",
                  "action_id": "",
                  "object": "'https://discord.com/'",
                  "object_description": "Discord API endpoint",
                  "object_id": "discord_api_endpoint",
                  "intention_description": "Prepare URL for HTTP request",
                  "intention_id": "prepare_url_http_request"
                },
                {
                  "action_api": "",
                  "action_description": "",
                  "action_id": "",
                  "object": "'https://discord.com/api/webhooks'",
                  "object_description": "Discord webhook URL",
                  "object_id": "discord_webhook_url",
                  "intention_description": "Prepare webhook for data transmission",
                  "intention_id": "webhook_transmission_preparation"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "hikari-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/hikari-2.2.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "urls.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/hikari-2.2.1/hikari-2.2.1/hikari/urls.py",
          "line_number": "32",
          "type_description": "shady-links",
          "context_snippet": "import typing\n\nVERSION: typing.Final[int] = 10\n\"\"\"The Gateway and REST version to use.\"\"\"\n\nBASE_URL: typing.Final[str] = \"https://discord.com\"\n\"\"\"The base URL.\"\"\"\n\nREST_API_URL: typing.Final[str] = f\"{BASE_URL}/api/v{VERSION}\"\n\"\"\"The REST API URL.\"\"\"\n\nOAUTH2_API_URL: typing.Final[str] = f\"{REST_API_URL}/oauth2\"\n\"\"\"The OAUTH2 API URL.\"\"\"\n\nCDN_URL: typing.Final[str] = \"https://cdn.discordapp.com\"\n\"\"\"The CDN URL.\"\"\"\n\nMEDIA_PROXY_URL: typing.Final[str] = \"https://media.discordapp.net\"\n\"\"\"The media proxy URL.\"\"\"",
          "hash_value": "11946fc7a8721e82d43befa1041c1b9e",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import typing\n\nVERSION: typing.Final[int] = 10\n\"\"\"The Gateway and REST version to use.\"\"\"\n\nBASE_URL: typing.Final[str] = \"https://discord.com\"\n\"\"\"The base URL.\"\"\"\n\nREST_API_URL: typing.Final[str] = f\"{BASE_URL}/api/v{VERSION}\"\n\"\"\"The REST API URL.\"\"\"\n\nOAUTH2_API_URL: typing.Final[str] = f\"{REST_API_URL}/oauth2\"\n\"\"\"The OAUTH2 API URL.\"\"\"\n\nCDN_URL: typing.Final[str] = \"https://cdn.discordapp.com\"\n\"\"\"The CDN URL.\"\"\"\n\nMEDIA_PROXY_URL: typing.Final[str] = \"https://media.discordapp.net\"\n\"\"\"The media proxy URL.\"\"\"",
              "triple_sequences": [
                {
                  "action_api": "str.format()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "f\"{BASE_URL}/api/v{VERSION}\"",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Prepare URL for HTTP request",
                  "intention_id": "prepare_url_http_request"
                },
                {
                  "action_api": "str.format()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "f\"{REST_API_URL}/oauth2\"",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Prepare URL for HTTP request",
                  "intention_id": "prepare_url_http_request"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "coverage_enable_subprocess-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/coverage_enable_subprocess-1.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/coverage_enable_subprocess-1.0/coverage_enable_subprocess-1.0/setup.py",
          "line_number": "125",
          "type_description": "cmd-overwrite",
          "context_snippet": "def main():\n    \"\"\"the entry point\"\"\"\n    setup(\n        name=str('coverage_enable_subprocess'),\n        version='1.0',\n        url=\"https://github.com/bukzor/python-coverage-enable-subprocess\",\n        license=\"MIT\",\n        author=\"Buck Evan\",\n        author_email=\"buck.2019@gmail.com\",\n        description=\"enable python coverage for subprocesses\",\n        long_description=DOC,\n        zip_safe=False,\n        classifiers=[\n            'Programming Language :: Python :: 2.6',\n            'Programming Language :: Python :: 2.7',\n            'Programming Language :: Python :: 3.3',\n            'Programming Language :: Python :: 3.4',\n            'License :: OSI Approved :: MIT License',\n        ],\n        install_requires=[\n            'coverage',\n        ],\n        cmdclass={\n            'install': Install,\n        },\n        options={\n            'bdist_wheel': {\n                'universal': 1,\n            },\n        },\n    )",
          "hash_value": "0f2d3f6e6b1c7abf49184310727289ff",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def main():\n    \"\"\"the entry point\"\"\"\n    setup(\n        name=str('coverage_enable_subprocess'),\n        version='1.0',\n        url=\"https://github.com/bukzor/python-coverage-enable-subprocess\",\n        license=\"MIT\",\n        author=\"Buck Evan\",\n        author_email=\"buck.2019@gmail.com\",\n        description=\"enable python coverage for subprocesses\",\n        long_description=DOC,\n        zip_safe=False,\n        classifiers=[\n            'Programming Language :: Python :: 2.6',\n            'Programming Language :: Python :: 2.7',\n            'Programming Language :: Python :: 3.3',\n            'Programming Language :: Python :: 3.4',\n            'License :: OSI Approved :: MIT License',\n        ],\n        install_requires=[\n            'coverage',\n        ],\n        cmdclass={\n            'install': Install,\n        },\n        options={\n            'bdist_wheel': {\n                'universal': 1,\n            },\n        },\n    )",
              "triple_sequences": [
                {
                  "action_api": "setup()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "{'name': 'coverage_enable_subprocess', 'version': '1.0', 'url': 'https://github.com/bukzor/python-coverage-enable-subprocess', 'license': 'MIT', 'author': 'Buck Evan', 'author_email': 'buck.2019@gmail.com', 'description': 'enable python coverage for subprocesses', 'long_description': DOC, 'zip_safe': False, 'classifiers': ['Programming Language :: Python :: 2.6', 'Programming Language :: Python :: 2.7', 'Programming Language :: Python :: 3.3', 'Programming Language :: Python :: 3.4', 'License :: OSI Approved :: MIT License'], 'install_requires': ['coverage'], 'cmdclass': {'install': Install}, 'options': {'bdist_wheel': {'universal': 1}}}",
                  "object_description": "Custom post-install function",
                  "object_id": "custom_post_install_function",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pythran-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pythran-0.17.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "expand_builtins.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pythran-0.17.0/pythran-0.17.0/pythran/transformations/expand_builtins.py",
          "line_number": "34",
          "type_description": "obfuscation",
          "context_snippet": "import builtins\nimport gast as ast\n\nclass ExpandBuiltins(Transformation):\n    ...\n    def visit_Name(self, node):\n        s = node.id\n        if s in ('None', 'True', 'False'):\n            self.update = True\n            return ast.Constant(getattr(builtins, s), None)\n        if(isinstance(node.ctx, ast.Load) and\n           s not in self.locals[node] and\n           s not in self.globals and\n           s in MODULES['builtins']):\n            if s == 'getattr':\n                raise PythranSyntaxError(\"You fool! Trying a getattr?\", node)\n            self.update = True\n            return ast.Attribute(\n                ast.Name('builtins', ast.Load(), None, None),\n                s,\n                node.ctx)\n        else:\n            return node",
          "hash_value": "c059e1eff7199b98725c808f70d54682",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import builtins\nimport gast as ast\n\nclass ExpandBuiltins(Transformation):\n    ...\n    def visit_Name(self, node):\n        s = node.id\n        if s in ('None', 'True', 'False'):\n            self.update = True\n            return ast.Constant(getattr(builtins, s), None)\n        if(isinstance(node.ctx, ast.Load) and\n           s not in self.locals[node] and\n           s not in self.globals and\n           s in MODULES['builtins']):\n            if s == 'getattr':\n                raise PythranSyntaxError(\"You fool! Trying a getattr?\", node)\n            self.update = True\n            return ast.Attribute(\n                ast.Name('builtins', ast.Load(), None, None),\n                s,\n                node.ctx)\n        else:\n            return node",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "builtins, s",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "node.ctx, ast.Load",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "ast.Attribute()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "ast.Name('builtins', ast.Load(), None, None), s, node.ctx",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "raise PythranSyntaxError()",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "\"You fool! Trying a getattr?\", node",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pyexcel_io-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyexcel_io-0.6.7.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyexcel_io-0.6.7/pyexcel_io-0.6.7/setup.py",
          "line_number": "129",
          "type_description": "code-execution",
          "context_snippet": "class PublishCommand(Command):\n    \"\"\"Support setup.py upload.\"\"\"\n\n    description = \"Build and publish the package on github and pypi\"\n    user_options = []\n\n    @staticmethod\n    def status(s):\n        \"\"\"Prints things in bold.\"\"\"\n        print(\"\\033[1m{0}\\033[0m\".format(s))\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        try:\n            self.status(\"Removing previous builds...\")\n            rmtree(os.path.join(HERE, \"dist\"))\n            rmtree(os.path.join(HERE, \"build\"))\n            rmtree(os.path.join(HERE, \"pyexcel_io.egg-info\"))\n        except OSError:\n            pass\n\n        self.status(\"Building Source and Wheel (universal) distribution...\")\n        run_status = True\n        if has_gease():\n            run_status = os.system(GS_COMMAND) == 0\n        else:\n            self.status(NO_GS_MESSAGE)\n        if run_status:\n            if os.system(PUBLISH_COMMAND) != 0:\n                self.status(UPLOAD_FAILED_MSG)\n\n        sys.exit()\n\n# Data dependencies:\n# - os: imported at top\n# - GS_COMMAND: defined as (\"gease pyexcel-io v0.6.7 \" + \"Find 0.6.7 in changelog for more details\")\n# - has_gease(): defined below\n# - self.status: defined in this class\n# - NO_GS_MESSAGE: defined as (\"Automatic github release is disabled. \" + \"Please install gease to enable it.\")",
          "hash_value": "3a3f7deb869475ba9f00eb937247fdad",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class PublishCommand(Command):\n    \"\"\"Support setup.py upload.\"\"\"\n\n    description = \"Build and publish the package on github and pypi\"\n    user_options = []\n\n    @staticmethod\n    def status(s):\n        \"\"\"Prints things in bold.\"\"\"\n        print(\"\\033[1m{0}\\033[0m\".format(s))\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        try:\n            self.status(\"Removing previous builds...\")\n            rmtree(os.path.join(HERE, \"dist\"))\n            rmtree(os.path.join(HERE, \"build\"))\n            rmtree(os.path.join(HERE, \"pyexcel_io.egg-info\"))\n        except OSError:\n            pass\n\n        self.status(\"Building Source and Wheel (universal) distribution...\")\n        run_status = True\n        if has_gease():\n            run_status = os.system(GS_COMMAND) == 0\n        else:\n            self.status(NO_GS_MESSAGE)\n        if run_status:\n            if os.system(PUBLISH_COMMAND) != 0:\n                self.status(UPLOAD_FAILED_MSG)\n\n        sys.exit()\n\n# Data dependencies:\n# - os: imported at top\n# - GS_COMMAND: defined as (\"gease pyexcel-io v0.6.7 \" + \"Find 0.6.7 in changelog for more details\")\n# - has_gease(): defined below\n# - self.status: defined in this class\n# - NO_GS_MESSAGE: defined as (\"Automatic github release is disabled. \" + \"Please install gease to enable it.\")",
              "triple_sequences": [
                {
                  "action_api": "rmtree()",
                  "action_description": "Recursively deletes directory and its contents",
                  "action_id": "delete_directory",
                  "object": "os.path.join(HERE, \"dist\")",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Delete directory content",
                  "intention_id": "delete_directory_content"
                },
                {
                  "action_api": "rmtree()",
                  "action_description": "Recursively deletes directory and its contents",
                  "action_id": "delete_directory",
                  "object": "os.path.join(HERE, \"build\")",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Delete directory content",
                  "intention_id": "delete_directory_content"
                },
                {
                  "action_api": "rmtree()",
                  "action_description": "Recursively deletes directory and its contents",
                  "action_id": "delete_directory",
                  "object": "os.path.join(HERE, \"pyexcel_io.egg-info\")",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Delete directory content",
                  "intention_id": "delete_directory_content"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "GS_COMMAND",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "PUBLISH_COMMAND",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "uamqp-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/uamqp-1.6.11.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/uamqp-1.6.11/uamqp-1.6.11/setup.py",
          "line_number": "183",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport subprocess\nimport platform\nimport distutils\nfrom distutils import log as logger\n\ndef get_generator_flags():\n    flags = [\"-G\"]\n    if is_win:\n        flags.append(\"\\\"Visual Studio 17 2022\\\"\")\n        flags.append(\"-A\")\n        flags.append(\"ARM64\" if platform.machine() == \"ARM64\" else \"x64\" if is_x64 else \"Win32\")\n    else:\n        flags.append(\"\\\"Unix Makefiles\\\"\")\n    return \" \".join(flags)\n\ndef get_build_env():\n    build_env = os.environ.copy()\n    return {k.upper(): v for k, v in build_env.items()}\n\nclass build_ext(build_ext_orig):\n    def build_cmake(self, ext):\n        cwd = os.getcwd()\n        self.cmake_build_dir = self.build_temp + \"/cmake\"\n        create_folder_no_exception(self.cmake_build_dir)\n        extdir = self.get_ext_fullpath(ext.name)\n        create_folder_no_exception(extdir)\n        logger.info(\"will build uamqp in %s\", self.cmake_build_dir)\n        os.chdir(cwd + \"/\" + self.cmake_build_dir)\n        generator_flags = get_generator_flags()\n        logger.info(\"Building with generator flags: {}\".format(generator_flags))\n        build_env = get_build_env()\n        # Configure\n        configure_command = [\n            \"cmake\",\n            cwd + \"/src/vendor/azure-uamqp-c/\",\n            generator_flags,\n            \"-Duse_openssl:bool={}\".format(\"ON\" if use_openssl else \"OFF\"),\n            \"-Duse_default_uuid:bool=ON \",\n            \"-Duse_builtin_httpapi:bool=ON \",\n            \"-Dskip_samples:bool=ON\",\n            \"-DCMAKE_POSITION_INDEPENDENT_CODE=TRUE\",\n            \"-DCMAKE_BUILD_TYPE=Release\"\n        ]\n        joined_cmd = \" \".join(configure_command)\n        logger.info(\"calling %s\", joined_cmd)\n        subprocess.check_call(joined_cmd, shell=True, universal_newlines=True, env=build_env)",
          "hash_value": "8979619ed4127c4a17d90ad5d1633f7a",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport subprocess\nimport platform\nimport distutils\nfrom distutils import log as logger\n\ndef get_generator_flags():\n    flags = [\"-G\"]\n    if is_win:\n        flags.append(\"\\\"Visual Studio 17 2022\\\"\")\n        flags.append(\"-A\")\n        flags.append(\"ARM64\" if platform.machine() == \"ARM64\" else \"x64\" if is_x64 else \"Win32\")\n    else:\n        flags.append(\"\\\"Unix Makefiles\\\"\")\n    return \" \".join(flags)\n\ndef get_build_env():\n    build_env = os.environ.copy()\n    return {k.upper(): v for k, v in build_env.items()}\n\nclass build_ext(build_ext_orig):\n    def build_cmake(self, ext):\n        cwd = os.getcwd()\n        self.cmake_build_dir = self.build_temp + \"/cmake\"\n        create_folder_no_exception(self.cmake_build_dir)\n        extdir = self.get_ext_fullpath(ext.name)\n        create_folder_no_exception(extdir)\n        logger.info(\"will build uamqp in %s\", self.cmake_build_dir)\n        os.chdir(cwd + \"/\" + self.cmake_build_dir)\n        generator_flags = get_generator_flags()\n        logger.info(\"Building with generator flags: {}\".format(generator_flags))\n        build_env = get_build_env()\n        # Configure\n        configure_command = [\n            \"cmake\",\n            cwd + \"/src/vendor/azure-uamqp-c/\",\n            generator_flags,\n            \"-Duse_openssl:bool={}\".format(\"ON\" if use_openssl else \"OFF\"),\n            \"-Duse_default_uuid:bool=ON \",\n            \"-Duse_builtin_httpapi:bool=ON \",\n            \"-Dskip_samples:bool=ON\",\n            \"-DCMAKE_POSITION_INDEPENDENT_CODE=TRUE\",\n            \"-DCMAKE_BUILD_TYPE=Release\"\n        ]\n        joined_cmd = \" \".join(configure_command)\n        logger.info(\"calling %s\", joined_cmd)\n        subprocess.check_call(joined_cmd, shell=True, universal_newlines=True, env=build_env)",
              "triple_sequences": [
                {
                  "action_api": "os.environ.copy()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.getcwd()",
                  "action_description": "Returns current working directory",
                  "action_id": "get_working_dir",
                  "object": "",
                  "object_description": "Current working directory",
                  "object_id": "current_working_directory",
                  "intention_description": "Collect working directory",
                  "intention_id": "collect_working_directory"
                },
                {
                  "action_api": "create_folder_no_exception()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "self.cmake_build_dir",
                  "object_description": "Custom directory",
                  "object_id": "custom_directory",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "create_folder_no_exception()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "extdir",
                  "object_description": "Custom directory",
                  "object_id": "custom_directory",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "os.chdir()",
                  "action_description": "Changes current working directory",
                  "action_id": "change_working_dir",
                  "object": "cwd + \"/\" + self.cmake_build_dir",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Change working directory",
                  "intention_id": "change_working_directory"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "joined_cmd",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pycld3-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pycld3-0.22.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pycld3-0.22/pycld3-0.22/setup.py",
          "line_number": "133",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport platform\nimport shutil\nimport subprocess\nfrom distutils.command.build import build\nfrom os import makedirs, path\n\nHERE = path.abspath(path.dirname(__file__))\nPROTOS = [\"sentence.proto\", \"feature_extractor.proto\", \"task_spec.proto\"]\n\nclass BuildProtobuf(build):\n    \"\"\"Compile protocol buffers via `protoc` compiler.\"\"\"\n\n    def run(self):\n\n        # Raise & exit early if `protoc` compiler not available\n        if shutil.which(\"protoc\") is None:\n            raise RuntimeError(\n                \"The Protobuf compiler, `protoc`, which is required for\"\n                \" building this package, could not be found.\\n\"\n                \"See https://github.com/protocolbuffers/protobuf for\"\n                \" information on installing Protobuf.\"\n            )\n\n        # Create protobufs dir if it does not exist\n        protobuf_dir = path.join(HERE, \"src/cld_3/protos/\")\n        if not path.exists(protobuf_dir):\n            print(\"Creating dirs at \\033[1m{}\\033[0;0m\".format(protobuf_dir))\n            makedirs(protobuf_dir)\n\n        # Run command via subprocess, using protoc compiler on .proto\n        # files\n        #\n        # $ cd src && protoc --cpp-_ut cld_3/protos \\\n        # >     sentence.proto feature_extractor.proto task_spec.proto\n        command = [\"protoc\"]\n        command.extend(PROTOS)\n        command.append(\n            \"--cpp_out={}\".format(path.join(HERE, \"src/cld_3/protos/\"))\n        )\n        print(\"Running \\033[1m{}\\033[0;0m\".format(\" \".join(command)))\n        subprocess.run(command, check=True, cwd=path.join(HERE, \"src/\"))\n        build.run(self)",
          "hash_value": "c33669705109b1a12e8c261f050de5d0",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport platform\nimport shutil\nimport subprocess\nfrom distutils.command.build import build\nfrom os import makedirs, path\n\nHERE = path.abspath(path.dirname(__file__))\nPROTOS = [\"sentence.proto\", \"feature_extractor.proto\", \"task_spec.proto\"]\n\nclass BuildProtobuf(build):\n    \"\"\"Compile protocol buffers via `protoc` compiler.\"\"\"\n\n    def run(self):\n\n        # Raise & exit early if `protoc` compiler not available\n        if shutil.which(\"protoc\") is None:\n            raise RuntimeError(\n                \"The Protobuf compiler, `protoc`, which is required for\"\n                \" building this package, could not be found.\\n\"\n                \"See https://github.com/protocolbuffers/protobuf for\"\n                \" information on installing Protobuf.\"\n            )\n\n        # Create protobufs dir if it does not exist\n        protobuf_dir = path.join(HERE, \"src/cld_3/protos/\")\n        if not path.exists(protobuf_dir):\n            print(\"Creating dirs at \\033[1m{}\\033[0;0m\".format(protobuf_dir))\n            makedirs(protobuf_dir)\n\n        # Run command via subprocess, using protoc compiler on .proto\n        # files\n        #\n        # $ cd src && protoc --cpp-_ut cld_3/protos \\\n        # >     sentence.proto feature_extractor.proto task_spec.proto\n        command = [\"protoc\"]\n        command.extend(PROTOS)\n        command.append(\n            \"--cpp_out={}\".format(path.join(HERE, \"src/cld_3/protos/\"))\n        )\n        print(\"Running \\033[1m{}\\033[0;0m\".format(\" \".join(command)))\n        subprocess.run(command, check=True, cwd=path.join(HERE, \"src/\"))\n        build.run(self)",
              "triple_sequences": [
                {
                  "action_api": "shutil.which()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "\"protoc\"",
                  "object_description": "Local file or directory name",
                  "object_id": "local_file_or_directory_name",
                  "intention_description": "Determine_file_presence",
                  "intention_id": "determine_file_presence"
                },
                {
                  "action_api": "path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "HERE, \"src/cld_3/protos/\"",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "protobuf_dir",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Determine_directory_presence",
                  "intention_id": "determine_directory_presence"
                },
                {
                  "action_api": "makedirs()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "protobuf_dir",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "HERE, \"src/cld_3/protos/\"",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "command, check=True, cwd=path.join(HERE, \"src/\")",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "build.run()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "self",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "frida-16",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/frida-16.7.10.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/frida-16.7.10/frida-16.7.10/setup.py",
          "line_number": "120",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport platform\nimport shutil\nimport subprocess\nimport sys\nfrom pathlib import Path\nfrom setuptools.command.build_ext import build_ext\n\nSOURCE_ROOT = Path(__file__).resolve().parent\n\nclass FridaDemandBuiltExt(build_ext):\n    def build_extension(self, ext):\n        make = SOURCE_ROOT / \"make.bat\" if platform.system() == \"Windows\" else \"make\"\n        subprocess.run([make], check=True)\n\n        outputs = [entry for entry in (SOURCE_ROOT / \"build\" / \"frida\" / \"_frida\").glob(\"_frida.*\") if entry.is_file()]\n        assert len(outputs) == 1\n        target = self.get_ext_fullpath(ext.name)\n        Path(target).parent.mkdir(parents=True, exist_ok=True)\n        shutil.copy(outputs[0], target)",
          "hash_value": "f50cae814908e75b41c0208f6f19b32e",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport platform\nimport shutil\nimport subprocess\nimport sys\nfrom pathlib import Path\nfrom setuptools.command.build_ext import build_ext\n\nSOURCE_ROOT = Path(__file__).resolve().parent\n\nclass FridaDemandBuiltExt(build_ext):\n    def build_extension(self, ext):\n        make = SOURCE_ROOT / \"make.bat\" if platform.system() == \"Windows\" else \"make\"\n        subprocess.run([make], check=True)\n\n        outputs = [entry for entry in (SOURCE_ROOT / \"build\" / \"frida\" / \"_frida\").glob(\"_frida.*\") if entry.is_file()]\n        assert len(outputs) == 1\n        target = self.get_ext_fullpath(ext.name)\n        Path(target).parent.mkdir(parents=True, exist_ok=True)\n        shutil.copy(outputs[0], target)",
              "triple_sequences": [
                {
                  "action_api": "platform.system()",
                  "action_description": "Retrieves operating system identifier",
                  "action_id": "get_os_id",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine operating system",
                  "intention_id": "determine_operating_system"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "[make]",
                  "object_description": "Batch file path",
                  "object_id": "batch_file_path",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "Path.glob()",
                  "action_description": "List directory contents",
                  "action_id": "list_directory_contents",
                  "object": "_frida.*",
                  "object_description": "Local file or directory name",
                  "object_id": "local_file_or_directory_name",
                  "intention_description": "List files in directory",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "Path.is_file()",
                  "action_description": "Checks if specified path exists and is a file",
                  "action_id": "check_file_is_file",
                  "object": "entry",
                  "object_description": "Local file",
                  "object_id": "local_file",
                  "intention_description": "Determine_file_presence",
                  "intention_id": "determine_file_presence"
                },
                {
                  "action_api": "self.get_ext_fullpath()",
                  "action_description": "Path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "ext.name",
                  "object_description": "Local file or directory name",
                  "object_id": "local_file_or_directory_name",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "Path.mkdir()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "Path(target).parent",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "shutil.copy()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "outputs[0], target",
                  "object_description": "Local file",
                  "object_id": "local_file",
                  "intention_description": "Move file to destination",
                  "intention_id": "move_file_destination"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pygad-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pygad-3.4.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "parent_selection.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pygad-3.4.0/pygad-3.4.0/pygad/utils/parent_selection.py",
          "line_number": "384",
          "type_description": "obfuscation",
          "context_snippet": "    def nsga2_selection(self,\n                        fitness,\n                        num_parents\n                        ):\n\n        \"\"\"\n        Select the parents using the Non-Dominated Sorting Genetic Algorithm II (NSGA-II). \n        The selection is done using non-dominated sorting and crowding distance.\n        Using non-dominated sorting, the solutions are distributed across pareto fronts. The fronts are given the indices 0, 1, 2, ..., N where N is the number of pareto fronts. The lower the index of the pareto front, the better its solutions.\n        The parents are selected from the lower pareto fronts and moving up until selecting the number of desired parents. \n        A solution from a pareto front X cannot be taken as a parent until all solutions in pareto front Y is selected given that Y < X.\n        For a pareto front X, if only a subset of its solutions is needed, then the corwding distance is used to determine which solutions to be selected from the front. The solution with the higher crowding distance is selected.\n        If the 2 solutions are in the same pareto front and have the same crowding distance, then a solution is randomly selected.\n        Later, the selected parents will mate to produce the offspring.\n    \n        It accepts 2 parameters:\n            -fitness: The fitness values for the current population.\n            -num_parents: The number of parents to be selected.\n            -pareto_fronts: A nested array of all the pareto fronts. Each front has its solutions.\n            -solutions_fronts_indices: A list of the pareto front index of each solution in the current population.\n\n        It returns:\n            -An array of the selected parents.\n            -The indices of the selected solutions.\n        \"\"\"\n\n        if self.gene_type_single == True:\n            parents = numpy.empty((num_parents, self.population.shape[1]), dtype=self.gene_type[0])\n        else:\n            parents = numpy.empty((num_parents, self.population.shape[1]), dtype=object)\n\n        # Verify that the problem is multi-objective optimization as the NSGA-II selection is only applied to multi-objective problems.\n        if type(fitness[0]) in [list, tuple, numpy.ndarray]:\n            pass\n        elif type(fitness[0]) in self.supported_int_float_types:\n            raise ValueError('The NSGA-II parent selection operator is only applied when optimizing multi-objective problems.\\n\\nBut a single-objective optimization problem found as the fitness function returns a single numeric value.\\n\\nTo use multi-objective optimization, consider returning an iterable of any of these data types:\\n1)list\\n2)tuple\\n3)numpy.ndarray')\n\n        # The indices of the selected parents.\n        parents_indices = []\n\n        # If there is only a single objective, each pareto front is expected to have only 1 solution.\n        # TODO Make a test to check for that behaviour.\n        pareto_fronts, solutions_fronts_indices = self.non_dominated_sorting(fitness)\n        self.pareto_fronts = pareto_fronts.copy()\n\n        # The number of remaining parents to be selected.\n        num_remaining_parents = num_parents\n\n        # Index of the current parent.\n        current_parent_idx = 0\n        # A loop variable holding the index of the current pareto front.\n        pareto_front_idx = 0\n        while num_remaining_parents != 0 and pareto_front_idx < len(pareto_fronts):\n            # Return the current pareto front.\n            current_pareto_front = pareto_fronts[pareto_front_idx]\n            # Check if the entire front fits into the parents array.\n            # If so, then insert all the solutions in the current front into the parents array.\n            if num_remaining_parents >= len(current_pareto_front):\n                for sol_idx in range(len(current_pareto_front)):\n                    selected_solution_idx = current_pareto_front[sol_idx, 0]\n                    # Insert the parent into the parents array.\n                    parents[current_parent_idx, :] = self.population[selected_solution_idx, :].copy()\n                    # Insert the index of the selected parent.\n                    parents_indices.append(selected_solution_idx)\n                    # Increase the parent index.\n                    current_parent_idx += 1\n\n                # Decrement the number of remaining parents by the length of the pareto front.\n                num_remaining_parents -= len(current_pareto_front)\n            else:\n                # If only a subset of the front is needed, then use the crowding distance to sort the solutions and select only the number needed.\n    \n                # Calculate the crowding distance of the solutions of the pareto front.\n                obj_crowding_distance_list, crowding_distance_sum, crowding_dist_front_sorted_indices, crowding_dist_pop_sorted_indices = self.crowding_distance(pareto_front=current_pareto_front.copy(),\n                                                                                                                                                                 fitness=fitness)\n\n                for selected_solution_idx in crowding_dist_pop_sorted_indices[0:num_remaining_parents]:\n                    # Insert the parent into the parents array.\n                    parents[current_parent_idx, :] = self.population[selected_solution_idx, :].copy()\n                    # Insert the index of the selected parent.\n                    parents_indices.append(selected_solution_idx)\n                    # Increase the parent index.\n                    current_parent_idx += 1\n    \n                # Decrement the number of remaining parents by the number of selected parents.\n                num_remaining_parents -= num_remaining_parents\n    \n            # Increase the pareto front index to take parents from the next front.\n            pareto_front_idx += 1\n    \n        # Make sure the parents indices is returned as a NumPy array.\n        return parents, numpy.array(parents_indices)",
          "hash_value": "330b412f66dddaf274a4b88ee8c50f31",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "    def nsga2_selection(self,\n                        fitness,\n                        num_parents\n                        ):\n\n        \"\"\"\n        Select the parents using the Non-Dominated Sorting Genetic Algorithm II (NSGA-II). \n        The selection is done using non-dominated sorting and crowding distance.\n        Using non-dominated sorting, the solutions are distributed across pareto fronts. The fronts are given the indices 0, 1, 2, ..., N where N is the number of pareto fronts. The lower the index of the pareto front, the better its solutions.\n        The parents are selected from the lower pareto fronts and moving up until selecting the number of desired parents. \n        A solution from a pareto front X cannot be taken as a parent until all solutions in pareto front Y is selected given that Y < X.\n        For a pareto front X, if only a subset of its solutions is needed, then the corwding distance is used to determine which solutions to be selected from the front. The solution with the higher crowding distance is selected.\n        If the 2 solutions are in the same pareto front and have the same crowding distance, then a solution is randomly selected.\n        Later, the selected parents will mate to produce the offspring.\n    \n        It accepts 2 parameters:\n            -fitness: The fitness values for the current population.\n            -num_parents: The number of parents to be selected.\n            -pareto_fronts: A nested array of all the pareto fronts. Each front has its solutions.\n            -solutions_fronts_indices: A list of the pareto front index of each solution in the current population.\n\n        It returns:\n            -An array of the selected parents.\n            -The indices of the selected solutions.\n        \"\"\"\n\n        if self.gene_type_single == True:\n            parents = numpy.empty((num_parents, self.population.shape[1]), dtype=self.gene_type[0])\n        else:\n            parents = numpy.empty((num_parents, self.population.shape[1]), dtype=object)\n\n        # Verify that the problem is multi-objective optimization as the NSGA-II selection is only applied to multi-objective problems.\n        if type(fitness[0]) in [list, tuple, numpy.ndarray]:\n            pass\n        elif type(fitness[0]) in self.supported_int_float_types:\n            raise ValueError('The NSGA-II parent selection operator is only applied when optimizing multi-objective problems.\\n\\nBut a single-objective optimization problem found as the fitness function returns a single numeric value.\\n\\nTo use multi-objective optimization, consider returning an iterable of any of these data types:\\n1)list\\n2)tuple\\n3)numpy.ndarray')\n\n        # The indices of the selected parents.\n        parents_indices = []\n\n        # If there is only a single objective, each pareto front is expected to have only 1 solution.\n        # TODO Make a test to check for that behaviour.\n        pareto_fronts, solutions_fronts_indices = self.non_dominated_sorting(fitness)\n        self.pareto_fronts = pareto_fronts.copy()\n\n        # The number of remaining parents to be selected.\n        num_remaining_parents = num_parents\n\n        # Index of the current parent.\n        current_parent_idx = 0\n        # A loop variable holding the index of the current pareto front.\n        pareto_front_idx = 0\n        while num_remaining_parents != 0 and pareto_front_idx < len(pareto_fronts):\n            # Return the current pareto front.\n            current_pareto_front = pareto_fronts[pareto_front_idx]\n            # Check if the entire front fits into the parents array.\n            # If so, then insert all the solutions in the current front into the parents array.\n            if num_remaining_parents >= len(current_pareto_front):\n                for sol_idx in range(len(current_pareto_front)):\n                    selected_solution_idx = current_pareto_front[sol_idx, 0]\n                    # Insert the parent into the parents array.\n                    parents[current_parent_idx, :] = self.population[selected_solution_idx, :].copy()\n                    # Insert the index of the selected parent.\n                    parents_indices.append(selected_solution_idx)\n                    # Increase the parent index.\n                    current_parent_idx += 1\n\n                # Decrement the number of remaining parents by the length of the pareto front.\n                num_remaining_parents -= len(current_pareto_front)\n            else:\n                # If only a subset of the front is needed, then use the crowding distance to sort the solutions and select only the number needed.\n    \n                # Calculate the crowding distance of the solutions of the pareto front.\n                obj_crowding_distance_list, crowding_distance_sum, crowding_dist_front_sorted_indices, crowding_dist_pop_sorted_indices = self.crowding_distance(pareto_front=current_pareto_front.copy(),\n                                                                                                                                                                 fitness=fitness)\n\n                for selected_solution_idx in crowding_dist_pop_sorted_indices[0:num_remaining_parents]:\n                    # Insert the parent into the parents array.\n                    parents[current_parent_idx, :] = self.population[selected_solution_idx, :].copy()\n                    # Insert the index of the selected parent.\n                    parents_indices.append(selected_solution_idx)\n                    # Increase the parent index.\n                    current_parent_idx += 1\n    \n                # Decrement the number of remaining parents by the number of selected parents.\n                num_remaining_parents -= num_remaining_parents\n    \n            # Increase the pareto front index to take parents from the next front.\n            pareto_front_idx += 1\n    \n        # Make sure the parents indices is returned as a NumPy array.\n        return parents, numpy.array(parents_indices)",
              "triple_sequences": [
                {
                  "action_api": "numpy.empty()",
                  "action_description": "Creates temporary file that is not deleted on close",
                  "action_id": "create_temp_file",
                  "object": "(num_parents, self.population.shape[1]), dtype=self.gene_type[0]",
                  "object_description": "Temporary file path",
                  "object_id": "temporary_file_path",
                  "intention_description": "Create temporary file",
                  "intention_id": "create_temporary_file"
                },
                {
                  "action_api": "numpy.empty()",
                  "action_description": "Creates temporary file that is not deleted on close",
                  "action_id": "create_temp_file",
                  "object": "(num_parents, self.population.shape[1]), dtype=object",
                  "object_description": "Temporary file path",
                  "object_id": "temporary_file_path",
                  "intention_description": "Create temporary file",
                  "intention_id": "create_temporary_file"
                },
                {
                  "action_api": "type()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "fitness[0]",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine operating system",
                  "intention_id": "determine_operating_system"
                },
                {
                  "action_api": "self.non_dominated_sorting()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "fitness",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "pareto_fronts.copy()",
                  "action_description": "Copies memory from source to destination buffer",
                  "action_id": "copy_memory",
                  "object": "pareto_fronts",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "self.crowding_distance()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "pareto_front=current_pareto_front.copy(), fitness=fitness",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "self.population[selected_solution_idx, :].copy()",
                  "action_description": "Copies memory from source to destination buffer",
                  "action_id": "copy_memory",
                  "object": "self.population[selected_solution_idx, :]",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "numpy.array()",
                  "action_description": "Creates temporary file that is not deleted on close",
                  "action_id": "create_temp_file",
                  "object": "parents_indices",
                  "object_description": "Temporary file path",
                  "object_id": "temporary_file_path",
                  "intention_description": "Create temporary file",
                  "intention_id": "create_temporary_file"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "glob2-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/glob2-0.7.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/glob2-0.7/glob2-0.7/setup.py",
          "line_number": "16",
          "type_description": "code-execution",
          "context_snippet": "import os\nfrom setuptools import setup, find_packages\nimport re\nhere = os.path.dirname(os.path.abspath(__file__))\nversion_re = re.compile(\n    r'__version__ = (\\(.*?\\))')\nfp = open(os.path.join(here, 'glob2', '__init__.py'))\nversion = None\nfor line in fp:\n    match = version_re.search(line)\n    if match:\n        version = eval(match.group(1))\n        break\nelse:\n    raise Exception(\"Cannot find version in __init__.py\")\nfp.close()",
          "hash_value": "979b5787597e7f59aa893c9cb0ce7511",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nfrom setuptools import setup, find_packages\nimport re\nhere = os.path.dirname(os.path.abspath(__file__))\nversion_re = re.compile(\n    r'__version__ = (\\(.*?\\))')\nfp = open(os.path.join(here, 'glob2', '__init__.py'))\nversion = None\nfor line in fp:\n    match = version_re.search(line)\n    if match:\n        version = eval(match.group(1))\n        break\nelse:\n    raise Exception(\"Cannot find version in __init__.py\")\nfp.close()",
              "triple_sequences": [
                {
                  "action_api": "os.path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Get script file path",
                  "intention_id": "get_script_file_path"
                },
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.abspath(__file__)",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "re.compile()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "r'__version__ = (\\(.*?\\))'",
                  "object_description": "Regular expression pattern",
                  "object_id": "regex_pattern",
                  "intention_description": "Browser profile detection preparation",
                  "intention_id": "browser_profile_detection_preparation"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "here, 'glob2', '__init__.py'",
                  "object_description": "Directory path with file",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "os.path.join(here, 'glob2', '__init__.py')",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "re.Pattern.search()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "line",
                  "object_description": "Script file content",
                  "object_id": "script_file_content",
                  "intention_description": "Decode obfuscated code content",
                  "intention_id": "decode_obfuscated_code"
                },
                {
                  "action_api": "match.group()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "1",
                  "object_description": "Regular expression pattern",
                  "object_id": "regex_pattern",
                  "intention_description": "Extract structured data from file",
                  "intention_id": "extract_structured_file_data"
                },
                {
                  "action_api": "eval()",
                  "action_description": "Evaluates string as Python expression",
                  "action_id": "eval_python_expr",
                  "object": "match.group(1)",
                  "object_description": "Script file content",
                  "object_id": "script_file_content",
                  "intention_description": "Evaluate constructed code",
                  "intention_id": "evaluate_constructed_code"
                },
                {
                  "action_api": "fp.close()",
                  "action_description": "Closes the opened file",
                  "action_id": "close_file",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Close file",
                  "intention_id": "close_file"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "singlestoredb-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/singlestoredb-1.12.4.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "graphql.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/singlestoredb-1.12.4/singlestoredb-1.12.4/singlestoredb/fusion/graphql.py",
          "line_number": "173",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "import os\nimport requests\nfrom .result import FusionSQLResult\n\nAPI_URL = 'https://backend.singlestore.com/public'\n\nclass GraphQuery(object):\n    def __init__(\n        self,\n        api_token: str = '',\n        api_url: str = API_URL,\n    ) -> None:\n        self.api_token = api_token\n        self.api_url = api_url\n\n    def run(\n        self,\n        variables: Optional[Dict[str, Any]] = None,\n        *,\n        filter_expr: str = '',\n    ) -> FusionSQLResult:\n        api_token = self.api_token or os.environ.get('SINGLESTOREDB_BACKEND_TOKEN')\n        res = requests.post(\n            self.api_url,\n            headers={\n                'Content-Type': 'application/json',\n                'Authorization': f'Bearer {api_token}',\n            },\n            json={\n                'query': type(self).get_query(),\n                'variables': variables or {},\n            },\n        )\n        if res.status_code != 200:\n            raise ValueError(f'an error occurred: {res.text}')\n        json = res.json()\n        if json['data']:\n            data = json['data'].popitem()[-1]\n            if isinstance(data, Dict):\n                data = [data]\n        else:\n            data = []\n        fres = FusionSQLResult()\n        rows = []\n        fields = type(self).get_fields()\n        for i, obj in enumerate(data):\n            row = []\n            for name, field in fields:\n                found, value = field.get_path(obj)\n                if found:\n                    if i == 0:\n                        fres.add_field(name, field.dtype)\n                    row.append(value)\n            rows.append(tuple(row))\n        fres.set_rows(rows)\n        return fres",
          "hash_value": "f4397f6add80e404858ab6ba6fb7de43",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport requests\nfrom .result import FusionSQLResult\n\nAPI_URL = 'https://backend.singlestore.com/public'\n\nclass GraphQuery(object):\n    def __init__(\n        self,\n        api_token: str = '',\n        api_url: str = API_URL,\n    ) -> None:\n        self.api_token = api_token\n        self.api_url = api_url\n\n    def run(\n        self,\n        variables: Optional[Dict[str, Any]] = None,\n        *,\n        filter_expr: str = '',\n    ) -> FusionSQLResult:\n        api_token = self.api_token or os.environ.get('SINGLESTOREDB_BACKEND_TOKEN')\n        res = requests.post(\n            self.api_url,\n            headers={\n                'Content-Type': 'application/json',\n                'Authorization': f'Bearer {api_token}',\n            },\n            json={\n                'query': type(self).get_query(),\n                'variables': variables or {},\n            },\n        )\n        if res.status_code != 200:\n            raise ValueError(f'an error occurred: {res.text}')\n        json = res.json()\n        if json['data']:\n            data = json['data'].popitem()[-1]\n            if isinstance(data, Dict):\n                data = [data]\n        else:\n            data = []\n        fres = FusionSQLResult()\n        rows = []\n        fields = type(self).get_fields()\n        for i, obj in enumerate(data):\n            row = []\n            for name, field in fields:\n                found, value = field.get_path(obj)\n                if found:\n                    if i == 0:\n                        fres.add_field(name, field.dtype)\n                    row.append(value)\n            rows.append(tuple(row))\n        fres.set_rows(rows)\n        return fres",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "SINGLESTOREDB_BACKEND_TOKEN",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "requests.post()",
                  "action_description": "Opens URL with POST data",
                  "action_id": "open_url_post",
                  "object": "self.api_url, headers={'Content-Type': 'application/json', 'Authorization': f'Bearer {api_token}'}, json={'query': type(self).get_query(), 'variables': variables or {}}",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Transmit encoded data via HTTP POST",
                  "intention_id": "transmit_data_http_post"
                },
                {
                  "action_api": "res.status_code",
                  "action_description": "Retrieves HTTP response status code",
                  "action_id": "get_http_status",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare URL for HTTP request",
                  "intention_id": "prepare_url_http_request"
                },
                {
                  "action_api": "res.json()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "data, Dict",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "FusionSQLResult()",
                  "action_description": "Instantiates FusionSQLResult class",
                  "action_id": "init_grabber_class",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "type(self).get_fields()",
                  "action_description": "Retrieves attribute value",
                  "action_id": "access_attribute_value",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "field.get_path()",
                  "action_description": "Retrieves attribute value",
                  "action_id": "access_attribute_value",
                  "object": "obj",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "fres.add_field()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "name, field.dtype",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "fres.set_rows()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "rows",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "trytond-7",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/trytond-7.4.9.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/trytond-7.4.9/trytond-7.4.9/setup.py",
          "line_number": "41",
          "type_description": "code-execution",
          "context_snippet": "import glob\nimport io\nimport os\nimport re\nimport subprocess\n\nfrom setuptools import Command, find_packages, setup\n\n\ndef read(fname):\n    return io.open(\n        os.path.join(os.path.dirname(__file__), fname),\n        'r', encoding='utf-8').read()\n\n\ndef get_version():\n    init = read(os.path.join('trytond', '__init__.py'))\n    return re.search('__version__ = \"([0-9.]*)\"', init).group(1)\n\n\nclass rnc2rng(Command):\n    description = \"Generate rng files from rnc\"\n    user_options = []\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        os.chdir(os.path.dirname(__file__) or '.')\n        for path in glob.glob('**/*.rnc', recursive=True):\n            root, ext = os.path.splitext(path)\n            cmd = ['rnc2rng', path, root + '.rng']\n            self.announce(' '.join(cmd))\n            subprocess.run(cmd)\n",
          "hash_value": "126d8417f20d5517d4a13dfd167638c1",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import glob\nimport io\nimport os\nimport re\nimport subprocess\n\nfrom setuptools import Command, find_packages, setup\n\n\ndef read(fname):\n    return io.open(\n        os.path.join(os.path.dirname(__file__), fname),\n        'r', encoding='utf-8').read()\n\n\ndef get_version():\n    init = read(os.path.join('trytond', '__init__.py'))\n    return re.search('__version__ = \"([0-9.]*)\"', init).group(1)\n\n\nclass rnc2rng(Command):\n    description = \"Generate rng files from rnc\"\n    user_options = []\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        os.chdir(os.path.dirname(__file__) or '.')\n        for path in glob.glob('**/*.rnc', recursive=True):\n            root, ext = os.path.splitext(path)\n            cmd = ['rnc2rng', path, root + '.rng']\n            self.announce(' '.join(cmd))\n            subprocess.run(cmd)\n",
              "triple_sequences": [
                {
                  "action_api": "io.open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "os.path.join(os.path.dirname(__file__), fname)",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "str.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.dirname(__file__), fname",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "re.search()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "__version__ = \"([0-9.]*)\", init",
                  "object_description": "Regular expression and file content",
                  "object_id": "regex_file_content",
                  "intention_description": "Extract structured data from file",
                  "intention_id": "extract_structured_file_data"
                },
                {
                  "action_api": "os.chdir()",
                  "action_description": "Changes current working directory",
                  "action_id": "change_working_dir",
                  "object": "os.path.dirname(__file__) or '.'",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Change working directory",
                  "intention_id": "change_working_directory"
                },
                {
                  "action_api": "glob.glob()",
                  "action_description": "List directory contents",
                  "action_id": "list_directory_contents",
                  "object": "'**/*.rnc', recursive=True",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "List files in directory",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "os.path.splitext()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "path",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "['rnc2rng', path, root + '.rng']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "ruamel",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/ruamel.ordereddict-0.4.15.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ruamel.ordereddict-0.4.15/ruamel.ordereddict-0.4.15/setup.py",
          "line_number": "130",
          "type_description": "cmd-overwrite",
          "context_snippet": "def main():\n    install_requires = []\n    packages = [full_package_name] + [(full_package_name + '.' + x) for x\n                                     in find_packages(exclude=['tests'])]\n\n    setup(\n        name=full_package_name,\n        version=version_str,\n        description='a version of dict that keeps keys in '\\\n                    'insertion resp. sorted order',\n        install_requires=install_requires,\n        long_description=open('README.rst').read(),\n        url='https://bitbucket.org/ruamel/' + package_name,\n        author='Anthon van der Neut',\n        author_email='a.van.der.neut@ruamel.eu',\n        license=\"MIT license\",\n        package_dir={full_package_name: '.'},\n        namespace_packages=[name_space],\n        packages=packages,\n        ext_modules = [module1],\n        cmdclass={'install_lib': MyInstallLib},\n        classifiers=[\n            'Development Status :: 5 - Production/Stable',\n            'Intended Audience :: System Administrators',\n            'License :: OSI Approved :: MIT License',\n            'Operating System :: POSIX :: Linux',\n            'Programming Language :: Python',\n        ],\n    )\n\n# Data dependencies:\n# - setup: imported from setuptools\n# - full_package_name: defined as name_space + '.' + package_name\n# - version_str: set by _check_convert_version(version_info), which uses get_version()\n# - install_requires: local empty list\n# - open('README.rst').read(): reads README.rst file\n# - package_name: 'ordereddict'\n# - name_space: 'ruamel'\n# - module1: Extension('_ordereddict', ...)\n# - MyInstallLib: class defined above\n# - find_packages: imported from setuptools\n",
          "hash_value": "e1f5cacbaaa9b57d3a944c7e2e7a9ab3",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def main():\n    install_requires = []\n    packages = [full_package_name] + [(full_package_name + '.' + x) for x\n                                     in find_packages(exclude=['tests'])]\n\n    setup(\n        name=full_package_name,\n        version=version_str,\n        description='a version of dict that keeps keys in '\\\n                    'insertion resp. sorted order',\n        install_requires=install_requires,\n        long_description=open('README.rst').read(),\n        url='https://bitbucket.org/ruamel/' + package_name,\n        author='Anthon van der Neut',\n        author_email='a.van.der.neut@ruamel.eu',\n        license=\"MIT license\",\n        package_dir={full_package_name: '.'},\n        namespace_packages=[name_space],\n        packages=packages,\n        ext_modules = [module1],\n        cmdclass={'install_lib': MyInstallLib},\n        classifiers=[\n            'Development Status :: 5 - Production/Stable',\n            'Intended Audience :: System Administrators',\n            'License :: OSI Approved :: MIT License',\n            'Operating System :: POSIX :: Linux',\n            'Programming Language :: Python',\n        ],\n    )\n\n# Data dependencies:\n# - setup: imported from setuptools\n# - full_package_name: defined as name_space + '.' + package_name\n# - version_str: set by _check_convert_version(version_info), which uses get_version()\n# - install_requires: local empty list\n# - open('README.rst').read(): reads README.rst file\n# - package_name: 'ordereddict'\n# - name_space: 'ruamel'\n# - module1: Extension('_ordereddict', ...)\n# - MyInstallLib: class defined above\n# - find_packages: imported from setuptools\n",
              "triple_sequences": [
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "README.rst",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "{name: full_package_name, version: version_str, ...}",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "zstd-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/zstd-1.5.6.7.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/zstd-1.5.6.7/zstd-1.5.6.7/setup.py",
          "line_number": "143",
          "type_description": "code-execution",
          "context_snippet": "import subprocess\nimport sys\n\npkgconf = which(\"pkg-config\")\nif \"--libzstd-bundled\" in sys.argv:\n    # Do you want use external Zstd library?\n    SUP_EXTERNAL=False\n    sys.argv.remove(\"--libzstd-bundled\")\n    pkgconf = False\n    \n#if SUP_EXTERNAL:\nif platform.system() == \"Linux\" and \"build_ext\" in sys.argv or \"build\" in sys.argv or \"bdist_wheel\" in sys.argv:\n    # You should add external library by option: --libraries zstd\n    # And probably include paths by option: --include-dirs /usr/include/zstd\n    # And probably library paths by option: --library-dirs /usr/lib/i386-linux-gnu\n    # We need pkg-config here!\n    if pkgconf is not False:\n        #debug \n        #print(\"pkg-config exists\")\n        cmd = [pkgconf, \"libzstd\", \"--modversion\"]\n        if sys.hexversion >= 0x03000000:\n            VERSION_STR=b''\n        else:\n            VERSION_STR=\"\"\n        if sys.hexversion >= 0x02070000:\n            try:\n                VERSION_STR = subprocess.check_output(cmd).strip()\n            except Exception as e:\n                print(\"Error: %r\" % e) \n                pass",
          "hash_value": "253fdf27526d1fef6e5b76a2c2a38855",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import subprocess\nimport sys\n\npkgconf = which(\"pkg-config\")\nif \"--libzstd-bundled\" in sys.argv:\n    # Do you want use external Zstd library?\n    SUP_EXTERNAL=False\n    sys.argv.remove(\"--libzstd-bundled\")\n    pkgconf = False\n    \n#if SUP_EXTERNAL:\nif platform.system() == \"Linux\" and \"build_ext\" in sys.argv or \"build\" in sys.argv or \"bdist_wheel\" in sys.argv:\n    # You should add external library by option: --libraries zstd\n    # And probably include paths by option: --include-dirs /usr/include/zstd\n    # And probably library paths by option: --library-dirs /usr/lib/i386-linux-gnu\n    # We need pkg-config here!\n    if pkgconf is not False:\n        #debug \n        #print(\"pkg-config exists\")\n        cmd = [pkgconf, \"libzstd\", \"--modversion\"]\n        if sys.hexversion >= 0x03000000:\n            VERSION_STR=b''\n        else:\n            VERSION_STR=\"\"\n        if sys.hexversion >= 0x02070000:\n            try:\n                VERSION_STR = subprocess.check_output(cmd).strip()\n            except Exception as e:\n                print(\"Error: %r\" % e) \n                pass",
              "triple_sequences": [
                {
                  "action_api": "which()",
                  "action_description": "Dynamically imports specified module",
                  "action_id": "import_dynamic",
                  "object": "\"pkg-config\"",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "sys.argv.remove()",
                  "action_description": "Retrieves command-line arguments passed to script",
                  "action_id": "get_cmd_args",
                  "object": "\"--libzstd-bundled\"",
                  "object_description": "Command-line arguments passed to script",
                  "object_id": "command_output",
                  "intention_description": "Access command line arguments",
                  "intention_id": "access_command_line_arguments"
                },
                {
                  "action_api": "platform.system()",
                  "action_description": "Retrieves operating system identifier",
                  "action_id": "get_os_id",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine operating system",
                  "intention_id": "get_operating_system_name"
                },
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[pkgconf, \"libzstd\", \"--modversion\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "str.strip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "wrapt-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/wrapt-1.17.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "decorators.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/wrapt-1.17.2/wrapt-1.17.2/src/wrapt/decorators.py",
          "line_number": "30",
          "type_description": "obfuscation",
          "context_snippet": "else:\n    string_types = str,\n\n    import builtins\n\n    exec_ = getattr(builtins, \"exec\")\n    del builtins",
          "hash_value": "e32ba70876fe3c210676eeef3506c77a",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "else:\n    string_types = str,\n\n    import builtins\n\n    exec_ = getattr(builtins, \"exec\")\n    del builtins",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "builtins, \"exec\"",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Modify builtins and execute code",
                  "intention_id": "modify_builtins_execute_code"
                },
                {
                  "action_api": "del builtins",
                  "action_description": "Deletes function from global namespace",
                  "action_id": "delete_function_global_namespace",
                  "object": "builtins",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Delete function from global namespace",
                  "intention_id": "delete_function_global_namespace"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "conda_forge_metadata-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/conda_forge_metadata-0.11.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "repodata.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/conda_forge_metadata-0.11.0/conda_forge_metadata-0.11.0/conda_forge_metadata/repodata.py",
          "line_number": "45",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "import os\nimport requests\n\n@lru_cache\ndef all_labels(use_remote_cache: bool = False) -> List[str]:\n    if use_remote_cache:\n        r = requests.get(\n            \"https://raw.githubusercontent.com/conda-forge/\"\n            \"by-the-numbers/main/data/labels.json\"\n        )\n        r.raise_for_status()\n        return r.json()\n\n    if token := os.environ.get(\"BINSTAR_TOKEN\"):\n        label_info = requests.get(\n            \"https://api.anaconda.org/channels/conda-forge\",\n            headers={\"Authorization\": f\"token {token}\"},\n        ).json()\n\n        return sorted(label for label in label_info if \"/\" not in label)\n\n    logger.info(\"No token detected. Fetching labels from anaconda.org HTML. Slow...\")\n    r = requests.get(\"https://anaconda.org/conda-forge/repo\")\n    r.raise_for_status()\n    html = r.text\n    soup = bs4.BeautifulSoup(html, \"html.parser\")\n    labels = []\n    len_prefix = len(\"/conda-forge/repo?label=\")\n    for element in soup.select(\"ul#Label > li > a\"):\n        href = element.get(\"href\")\n        if not href:\n            continue\n        label = href[len_prefix:]\n        if label and label not in (\"all\", \"empty\") and \"/\" not in label:\n            labels.append(label)\n    return sorted(labels)\n\n# Data dependencies:\n# - 'requests' is imported at the top\n# - 'os' is imported at the top\n# - 'token' is set from os.environ.get(\"BINSTAR_TOKEN\")\n# - The function is decorated with @lru_cache\n# - 'label_info' is the result of the requests.get(...).json() call\n# - 'logger' is a global variable set by getLogger(__name__)\n# - 'bs4' is imported at the top\n",
          "hash_value": "7ecad33757be4dba87099a4090982805",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport requests\n\n@lru_cache\ndef all_labels(use_remote_cache: bool = False) -> List[str]:\n    if use_remote_cache:\n        r = requests.get(\n            \"https://raw.githubusercontent.com/conda-forge/\"\n            \"by-the-numbers/main/data/labels.json\"\n        )\n        r.raise_for_status()\n        return r.json()\n\n    if token := os.environ.get(\"BINSTAR_TOKEN\"):\n        label_info = requests.get(\n            \"https://api.anaconda.org/channels/conda-forge\",\n            headers={\"Authorization\": f\"token {token}\"},\n        ).json()\n\n        return sorted(label for label in label_info if \"/\" not in label)\n\n    logger.info(\"No token detected. Fetching labels from anaconda.org HTML. Slow...\")\n    r = requests.get(\"https://anaconda.org/conda-forge/repo\")\n    r.raise_for_status()\n    html = r.text\n    soup = bs4.BeautifulSoup(html, \"html.parser\")\n    labels = []\n    len_prefix = len(\"/conda-forge/repo?label=\")\n    for element in soup.select(\"ul#Label > li > a\"):\n        href = element.get(\"href\")\n        if not href:\n            continue\n        label = href[len_prefix:]\n        if label and label not in (\"all\", \"empty\") and \"/\" not in label:\n            labels.append(label)\n    return sorted(labels)\n\n# Data dependencies:\n# - 'requests' is imported at the top\n# - 'os' is imported at the top\n# - 'token' is set from os.environ.get(\"BINSTAR_TOKEN\")\n# - The function is decorated with @lru_cache\n# - 'label_info' is the result of the requests.get(...).json() call\n# - 'logger' is a global variable set by getLogger(__name__)\n# - 'bs4' is imported at the top\n",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "BINSTAR_TOKEN",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP GET request to URL",
                  "action_id": "open_url_get",
                  "object": "https://raw.githubusercontent.com/conda-forge/by-the-numbers/main/data/labels.json",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP GET request to URL",
                  "action_id": "open_url_get",
                  "object": "https://api.anaconda.org/channels/conda-forge",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP GET request to URL",
                  "action_id": "open_url_get",
                  "object": "https://anaconda.org/conda-forge/repo",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "requests.get().raise_for_status()",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                },
                {
                  "action_api": "requests.get().json()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "requests.get().text",
                  "action_description": "Process HTTP response content",
                  "action_id": "process_http_response",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Decode downloaded content",
                  "intention_id": "decode_downloaded_content"
                },
                {
                  "action_api": "bs4.BeautifulSoup()",
                  "action_description": "Deserializes HTML/XML content to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pyodps-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyodps-0.12.3b2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyodps-0.12.3b2/pyodps-0.12.3b2/setup.py",
          "line_number": "65",
          "type_description": "code-execution",
          "context_snippet": "repo_root = os.path.dirname(os.path.abspath(__file__))\n\ntry:\n    execfile\nexcept NameError:\n\n    def execfile(fname, globs, locs=None):\n        locs = locs or globs\n        exec(compile(open(fname).read(), fname, \"exec\"), globs, locs)\n\n\nversion_ns = {}\nexecfile(os.path.join(repo_root, \"odps\", \"_version.py\"), version_ns)",
          "hash_value": "1488f4aeb5a5029910088d2c8bc0cb25",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "repo_root = os.path.dirname(os.path.abspath(__file__))\n\ntry:\n    execfile\nexcept NameError:\n\n    def execfile(fname, globs, locs=None):\n        locs = locs or globs\n        exec(compile(open(fname).read(), fname, \"exec\"), globs, locs)\n\n\nversion_ns = {}\nexecfile(os.path.join(repo_root, \"odps\", \"_version.py\"), version_ns)",
              "triple_sequences": [
                {
                  "action_api": "os.path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.abspath(__file__)",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "repo_root, \"odps\", \"_version.py\"",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "os.path.join(repo_root, \"odps\", \"_version.py\")",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "open(fname)",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "compile()",
                  "action_description": "Compiles source code string into executable code object",
                  "action_id": "compile_code_object",
                  "object": "open(fname).read(), fname, \"exec\"",
                  "object_description": "Script file content",
                  "object_id": "script_file_content",
                  "intention_description": "Construct Python code string",
                  "intention_id": "construct_python_code"
                },
                {
                  "action_api": "exec()",
                  "action_description": "Dynamically executes Python code string",
                  "action_id": "exec_python_code",
                  "object": "compile(open(fname).read(), fname, \"exec\"), globs, locs",
                  "object_description": "Compiled Python code",
                  "object_id": "compiled_python_code",
                  "intention_description": "Execute Python code",
                  "intention_id": "execute_python_code"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "tts-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/tts-0.22.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/tts-0.22.0/TTS-0.22.0/setup.py",
          "line_number": "80",
          "type_description": "cmd-overwrite",
          "context_snippet": "setup(\n    name=\"TTS\",\n    version=version,\n    url=\"https://github.com/coqui-ai/TTS\",\n    author=\"Eren Gölge\",\n    author_email=\"egolge@coqui.ai\",\n    description=\"Deep learning for Text to Speech by Coqui.\",\n    long_description=README,\n    long_description_content_type=\"text/markdown\",\n    license=\"MPL-2.0\",\n    # cython\n    include_dirs=numpy.get_include(),\n    ext_modules=cythonize(exts, language_level=3),\n    # ext_modules=find_cython_extensions(),\n    # package\n    include_package_data=True,\n    packages=find_packages(include=[\"TTS\"], exclude=[\"*.tests\", \"*tests.*\", \"tests.*\", \"*tests\", \"tests\"]),\n    package_data={\n        \"TTS\": [\n            \"VERSION\",\n        ]\n    },\n    project_urls={\n        \"Documentation\": \"https://github.com/coqui-ai/TTS/wiki\",\n        \"Tracker\": \"https://github.com/coqui-ai/TTS/issues\",\n        \"Repository\": \"https://github.com/coqui-ai/TTS\",\n        \"Discussions\": \"https://github.com/coqui-ai/TTS/discussions\",\n    },\n    cmdclass={\n        \"build_py\": build_py,\n        \"develop\": develop,\n        # 'build_ext': build_ext\n    },\n    install_requires=requirements,\n    extras_require={\n        \"all\": requirements_all,\n        \"dev\": requirements_dev,\n        \"notebooks\": requirements_notebooks,\n        \"ja\": requirements_ja,\n    },\n    python_requires=\">=3.9.0, <3.12\",\n    entry_points={\"console_scripts\": [\"tts=TTS.bin.synthesize:main\", \"tts-server = TTS.server.server:main\"]},\n    classifiers=[\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Development Status :: 3 - Alpha\",\n        \"Intended Audience :: Science/Research\",\n        \"Intended Audience :: Developers\",\n        \"Operating System :: POSIX :: Linux\",\n        \"License :: OSI Approved :: Mozilla Public License 2.0 (MPL 2.0)\",\n        \"Topic :: Software Development\",\n        \"Topic :: Software Development :: Libraries :: Python Modules\",\n        \"Topic :: Multimedia :: Sound/Audio :: Speech\",\n        \"Topic :: Multimedia :: Sound/Audio\",\n        \"Topic :: Multimedia\",\n        \"Topic :: Scientific/Engineering :: Artificial Intelligence\",\n    ],\n    zip_safe=False,\n)\n\n# Data dependencies:\n# - version: loaded from 'TTS/VERSION' file\n# - README: loaded from 'README.md'\n# - requirements, requirements_all, requirements_dev, requirements_notebooks, requirements_ja: loaded from requirements files\n# - exts: defined as a list of Extension objects\n# - build_py, develop: custom classes defined above\n# - numpy, cythonize, find_packages, Extension, setup: imported from respective modules",
          "hash_value": "d40ce72b2d42b98baf2cb75413ba4c21",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "setup(\n    name=\"TTS\",\n    version=version,\n    url=\"https://github.com/coqui-ai/TTS\",\n    author=\"Eren Gölge\",\n    author_email=\"egolge@coqui.ai\",\n    description=\"Deep learning for Text to Speech by Coqui.\",\n    long_description=README,\n    long_description_content_type=\"text/markdown\",\n    license=\"MPL-2.0\",\n    # cython\n    include_dirs=numpy.get_include(),\n    ext_modules=cythonize(exts, language_level=3),\n    # ext_modules=find_cython_extensions(),\n    # package\n    include_package_data=True,\n    packages=find_packages(include=[\"TTS\"], exclude=[\"*.tests\", \"*tests.*\", \"tests.*\", \"*tests\", \"tests\"]),\n    package_data={\n        \"TTS\": [\n            \"VERSION\",\n        ]\n    },\n    project_urls={\n        \"Documentation\": \"https://github.com/coqui-ai/TTS/wiki\",\n        \"Tracker\": \"https://github.com/coqui-ai/TTS/issues\",\n        \"Repository\": \"https://github.com/coqui-ai/TTS\",\n        \"Discussions\": \"https://github.com/coqui-ai/TTS/discussions\",\n    },\n    cmdclass={\n        \"build_py\": build_py,\n        \"develop\": develop,\n        # 'build_ext': build_ext\n    },\n    install_requires=requirements,\n    extras_require={\n        \"all\": requirements_all,\n        \"dev\": requirements_dev,\n        \"notebooks\": requirements_notebooks,\n        \"ja\": requirements_ja,\n    },\n    python_requires=\">=3.9.0, <3.12\",\n    entry_points={\"console_scripts\": [\"tts=TTS.bin.synthesize:main\", \"tts-server = TTS.server.server:main\"]},\n    classifiers=[\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Development Status :: 3 - Alpha\",\n        \"Intended Audience :: Science/Research\",\n        \"Intended Audience :: Developers\",\n        \"Operating System :: POSIX :: Linux\",\n        \"License :: OSI Approved :: Mozilla Public License 2.0 (MPL 2.0)\",\n        \"Topic :: Software Development\",\n        \"Topic :: Software Development :: Libraries :: Python Modules\",\n        \"Topic :: Multimedia :: Sound/Audio :: Speech\",\n        \"Topic :: Multimedia :: Sound/Audio\",\n        \"Topic :: Multimedia\",\n        \"Topic :: Scientific/Engineering :: Artificial Intelligence\",\n    ],\n    zip_safe=False,\n)\n\n# Data dependencies:\n# - version: loaded from 'TTS/VERSION' file\n# - README: loaded from 'README.md'\n# - requirements, requirements_all, requirements_dev, requirements_notebooks, requirements_ja: loaded from requirements files\n# - exts: defined as a list of Extension objects\n# - build_py, develop: custom classes defined above\n# - numpy, cythonize, find_packages, Extension, setup: imported from respective modules",
              "triple_sequences": [
                {
                  "action_api": "setup()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "name=\"TTS\", version=version, url=\"https://github.com/coqui-ai/TTS\", author=\"Eren Gölge\", author_email=\"egolge@coqui.ai\", description=\"Deep learning for Text to Speech by Coqui.\", long_description=README, long_description_content_type=\"text/markdown\", license=\"MPL-2.0\", include_dirs=numpy.get_include(), ext_modules=cythonize(exts, language_level=3), include_package_data=True, packages=find_packages(include=[\"TTS\"], exclude=[\"*.tests\", \"*tests.*\", \"tests.*\", \"*tests\", \"tests\"]), package_data={\"TTS\": [\"VERSION\"]}, project_urls={\"Documentation\": \"https://github.com/coqui-ai/TTS/wiki\", \"Tracker\": \"https://github.com/coqui-ai/TTS/issues\", \"Repository\": \"https://github.com/coqui-ai/TTS\", \"Discussions\": \"https://github.com/coqui-ai/TTS/discussions\"}, cmdclass={\"build_py\": build_py, \"develop\": develop}, install_requires=requirements, extras_require={\"all\": requirements_all, \"dev\": requirements_dev, \"notebooks\": requirements_notebooks, \"ja\": requirements_ja}, python_requires=\">=3.9.0, <3.12\", entry_points={\"console_scripts\": [\"tts=TTS.bin.synthesize:main\", \"tts-server = TTS.server.server:main\"]}, classifiers=[...], zip_safe=False",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                },
                {
                  "action_api": "numpy.get_include()",
                  "action_description": "Retrieves operating system information",
                  "action_id": "get_os_info",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "cythonize()",
                  "action_description": "Executes setuptools development procedure",
                  "action_id": "exec_setuptools_dev",
                  "object": "exts, language_level=3",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "find_packages()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "include=[\"TTS\"], exclude=[\"*.tests\", \"*tests.*\", \"tests.*\", \"*tests\", \"tests\"]",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "arpeggio-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/arpeggio-2.0.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/arpeggio-2.0.2/Arpeggio-2.0.2/setup.py",
          "line_number": "30",
          "type_description": "code-execution",
          "context_snippet": "from io import open\nimport os\nimport sys\nfrom setuptools import setup\n\nVERSIONFILE = \"arpeggio/__init__.py\"\nVERSION = None\nfor line in open(VERSIONFILE, \"r\", encoding='utf8').readlines():\n    if line.startswith('__version__'):\n        VERSION = line.split('\"')[1]\n\nif not VERSION:\n    raise RuntimeError('No version defined in arpeggio/__init__.py')\n\nif sys.argv[-1].startswith('publish'):\n    if os.system(\"pip list | grep wheel\"):\n        print(\"wheel not installed.\\nUse `pip install wheel`.\\nExiting.\")\n        sys.exit()\n    if os.system(\"pip list | grep twine\"):\n        print(\"twine not installed.\\nUse `pip install twine`.\\nExiting.\")\n        sys.exit()\n    os.system(\"python setup.py sdist bdist_wheel\")\n    if sys.argv[-1] == 'publishtest':\n        os.system(\"twine upload -r test dist/*\")\n    else:\n        os.system(\"twine upload dist/*\")\n        print(\"You probably want to also tag the version now:\")\n        print(\"  git tag -a {0} -m 'version {0}'\".format(VERSION))\n        print(\"  git push --tags\")\n    sys.exit()\n\nsetup(version=VERSION)\n",
          "hash_value": "431e5e5cae0659f82285464bc7ef0cc9",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from io import open\nimport os\nimport sys\nfrom setuptools import setup\n\nVERSIONFILE = \"arpeggio/__init__.py\"\nVERSION = None\nfor line in open(VERSIONFILE, \"r\", encoding='utf8').readlines():\n    if line.startswith('__version__'):\n        VERSION = line.split('\"')[1]\n\nif not VERSION:\n    raise RuntimeError('No version defined in arpeggio/__init__.py')\n\nif sys.argv[-1].startswith('publish'):\n    if os.system(\"pip list | grep wheel\"):\n        print(\"wheel not installed.\\nUse `pip install wheel`.\\nExiting.\")\n        sys.exit()\n    if os.system(\"pip list | grep twine\"):\n        print(\"twine not installed.\\nUse `pip install twine`.\\nExiting.\")\n        sys.exit()\n    os.system(\"python setup.py sdist bdist_wheel\")\n    if sys.argv[-1] == 'publishtest':\n        os.system(\"twine upload -r test dist/*\")\n    else:\n        os.system(\"twine upload dist/*\")\n        print(\"You probably want to also tag the version now:\")\n        print(\"  git tag -a {0} -m 'version {0}'\".format(VERSION))\n        print(\"  git push --tags\")\n    sys.exit()\n\nsetup(version=VERSION)\n",
              "triple_sequences": [
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "arpeggio/__init__.py",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "str.startswith()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__version__",
                  "object_description": "String containing environment data",
                  "object_id": "string_environment_data",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "\"",
                  "object_description": "String containing environment data",
                  "object_id": "string_environment_data",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "raise RuntimeError()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "No version defined in arpeggio/__init__.py",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                },
                {
                  "action_api": "sys.argv.__getitem__()",
                  "action_description": "Retrieves command-line arguments passed to script",
                  "action_id": "get_cmd_args",
                  "object": "-1",
                  "object_description": "Command-line arguments passed to script",
                  "object_id": "get_cmd_args",
                  "intention_description": "Access command line arguments",
                  "intention_id": "access_command_line_arguments"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "pip list | grep wheel",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "print()",
                  "action_description": "Prints output to standard output",
                  "action_id": "",
                  "object": "wheel not installed.\nUse `pip install wheel`.\nExiting.",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "pip list | grep twine",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "print()",
                  "action_description": "Prints output to standard output",
                  "action_id": "",
                  "object": "twine not installed.\nUse `pip install twine`.\nExiting.",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "python setup.py sdist bdist_wheel",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "twine upload -r test dist/*",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "twine upload dist/*",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "print()",
                  "action_description": "Prints output to standard output",
                  "action_id": "",
                  "object": "You probably want to also tag the version now:",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "print()",
                  "action_description": "Prints output to standard output",
                  "action_id": "",
                  "object": "  git tag -a {0} -m 'version {0}'",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "print()",
                  "action_description": "Prints output to standard output",
                  "action_id": "",
                  "object": "  git push --tags",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "version=VERSION",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "uptime_kuma_api-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/uptime_kuma_api-1.2.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/uptime_kuma_api-1.2.1/uptime_kuma_api-1.2.1/setup.py",
          "line_number": "8",
          "type_description": "code-execution",
          "context_snippet": "from setuptools import setup\nfrom codecs import open\nimport os\nimport sys\n\n# \"setup.py publish\" shortcut.\nif sys.argv[-1] == \"publish\":\n    os.system(\"rm dist/*\")\n    os.system(\"python setup.py sdist\")\n    os.system(\"twine upload dist/*\")\n    sys.exit()",
          "hash_value": "9aa060fd8626ee2c0c9d16e379f32d2e",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from setuptools import setup\nfrom codecs import open\nimport os\nimport sys\n\n# \"setup.py publish\" shortcut.\nif sys.argv[-1] == \"publish\":\n    os.system(\"rm dist/*\")\n    os.system(\"python setup.py sdist\")\n    os.system(\"twine upload dist/*\")\n    sys.exit()",
              "triple_sequences": [
                {
                  "action_api": "sys.argv.__getitem__()",
                  "action_description": "Retrieves command-line arguments passed to script",
                  "action_id": "get_cmd_args",
                  "object": "-1",
                  "object_description": "Command-line arguments passed to script",
                  "object_id": "cmd_args",
                  "intention_description": "Access command line arguments",
                  "intention_id": "access_command_line_arguments"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "rm dist/*",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Delete directory content",
                  "intention_id": "delete_directory_content"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "python setup.py sdist",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "twine upload dist/*",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pdfminer-20191125",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pdfminer-20191125.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pdfminer-20191125/pdfminer-20191125/setup.py",
          "line_number": "38",
          "type_description": "cmd-overwrite",
          "context_snippet": "from setuptools import setup\nfrom setuptools.command.install import install\nfrom pdfminer import __version__\n\nclass install_cmap(install):\n\n    def run(self):\n        import os.path\n        import pdfminer\n        from pdfminer.cmapdb import convert_cmap\n        outdir = os.path.join(os.path.join(self.install_lib, 'pdfminer'), 'cmap')\n        print('installing cmap: %r...' % outdir)\n        os.makedirs(outdir, exist_ok=True)\n        convert_cmap(\n            outdir, 'Adobe-CNS1',\n            {'B5':'cp950', 'UniCNS-UTF8':'utf-8'},\n            ['cmaprsrc/cid2code_Adobe_CNS1.txt'])\n        convert_cmap(\n            outdir, 'Adobe-GB1',\n            {'GBK-EUC':'cp936', 'UniGB-UTF8':'utf-8'},\n            ['cmaprsrc/cid2code_Adobe_GB1.txt'])\n        convert_cmap(\n            outdir, 'Adobe-Japan1',\n            {'RKSJ':'cp932', 'EUC':'euc-jp', 'UniJIS-UTF8':'utf-8'},\n            ['cmaprsrc/cid2code_Adobe_Japan1.txt'])\n        convert_cmap(\n            outdir, 'Adobe-Korea1',\n            {'KSC-EUC':'euc-kr', 'KSC-Johab':'johab', 'KSCms-UHC':'cp949',\n             'UniKS-UTF8':'utf-8'},\n            ['cmaprsrc/cid2code_Adobe_Korea1.txt'])\n        install.run(self)\n        return\n\nwith open('README.md') as fp:\n    long_description = fp.read()\n\nsetup(\n    cmdclass = { 'install': install_cmap },\n    name = 'pdfminer',\n    version = __version__,\n    description = 'PDF parser and analyzer',\n    long_description = long_description,\n    long_description_content_type = 'text/markdown',\n    license = 'MIT',\n    author = 'Yusuke Shinyama',\n    author_email = 'yusuke@shinyama.jp',\n    url = 'http://github.com/euske/pdfminer',\n    packages = [\n        'pdfminer',\n    ],\n    python_requires = '>=3.6',\n    install_requires = [\n        'pycryptodome',\n    ],\n    scripts = [\n        'tools/pdf2txt.py',\n        'tools/dumppdf.py',\n    ],\n    keywords = [\n        'pdf parser',\n        'pdf converter',\n        'layout analysis',\n        'text mining'\n    ],\n    classifiers = [\n        'Development Status :: 4 - Beta',\n        'Environment :: Console',\n        'Intended Audience :: Developers',\n        'Intended Audience :: Science/Research',\n        'License :: OSI Approved :: MIT License',\n        'Topic :: Text Processing',\n    ],\n)\n",
          "hash_value": "0e4c910344ec6d6fcf5ad3e1d9f0b03c",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from setuptools import setup\nfrom setuptools.command.install import install\nfrom pdfminer import __version__\n\nclass install_cmap(install):\n\n    def run(self):\n        import os.path\n        import pdfminer\n        from pdfminer.cmapdb import convert_cmap\n        outdir = os.path.join(os.path.join(self.install_lib, 'pdfminer'), 'cmap')\n        print('installing cmap: %r...' % outdir)\n        os.makedirs(outdir, exist_ok=True)\n        convert_cmap(\n            outdir, 'Adobe-CNS1',\n            {'B5':'cp950', 'UniCNS-UTF8':'utf-8'},\n            ['cmaprsrc/cid2code_Adobe_CNS1.txt'])\n        convert_cmap(\n            outdir, 'Adobe-GB1',\n            {'GBK-EUC':'cp936', 'UniGB-UTF8':'utf-8'},\n            ['cmaprsrc/cid2code_Adobe_GB1.txt'])\n        convert_cmap(\n            outdir, 'Adobe-Japan1',\n            {'RKSJ':'cp932', 'EUC':'euc-jp', 'UniJIS-UTF8':'utf-8'},\n            ['cmaprsrc/cid2code_Adobe_Japan1.txt'])\n        convert_cmap(\n            outdir, 'Adobe-Korea1',\n            {'KSC-EUC':'euc-kr', 'KSC-Johab':'johab', 'KSCms-UHC':'cp949',\n             'UniKS-UTF8':'utf-8'},\n            ['cmaprsrc/cid2code_Adobe_Korea1.txt'])\n        install.run(self)\n        return\n\nwith open('README.md') as fp:\n    long_description = fp.read()\n\nsetup(\n    cmdclass = { 'install': install_cmap },\n    name = 'pdfminer',\n    version = __version__,\n    description = 'PDF parser and analyzer',\n    long_description = long_description,\n    long_description_content_type = 'text/markdown',\n    license = 'MIT',\n    author = 'Yusuke Shinyama',\n    author_email = 'yusuke@shinyama.jp',\n    url = 'http://github.com/euske/pdfminer',\n    packages = [\n        'pdfminer',\n    ],\n    python_requires = '>=3.6',\n    install_requires = [\n        'pycryptodome',\n    ],\n    scripts = [\n        'tools/pdf2txt.py',\n        'tools/dumppdf.py',\n    ],\n    keywords = [\n        'pdf parser',\n        'pdf converter',\n        'layout analysis',\n        'text mining'\n    ],\n    classifiers = [\n        'Development Status :: 4 - Beta',\n        'Environment :: Console',\n        'Intended Audience :: Developers',\n        'Intended Audience :: Science/Research',\n        'License :: OSI Approved :: MIT License',\n        'Topic :: Text Processing',\n    ],\n)\n",
              "triple_sequences": [
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.join(self.install_lib, 'pdfminer')",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.join(os.path.join(self.install_lib, 'pdfminer'), 'cmap')",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.makedirs()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "outdir",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "convert_cmap()",
                  "action_description": "Custom function call (no direct match, best fit: Executes function to process data)",
                  "action_id": "execute_shell_command",
                  "object": "outdir, 'Adobe-CNS1', {'B5':'cp950', 'UniCNS-UTF8':'utf-8'}, ['cmaprsrc/cid2code_Adobe_CNS1.txt']",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "convert_cmap()",
                  "action_description": "Custom function call (no direct match, best fit: Executes function to process data)",
                  "action_id": "execute_shell_command",
                  "object": "outdir, 'Adobe-GB1', {'GBK-EUC':'cp936', 'UniGB-UTF8':'utf-8'}, ['cmaprsrc/cid2code_Adobe_GB1.txt']",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "convert_cmap()",
                  "action_description": "Custom function call (no direct match, best fit: Executes function to process data)",
                  "action_id": "execute_shell_command",
                  "object": "outdir, 'Adobe-Japan1', {'RKSJ':'cp932', 'EUC':'euc-jp', 'UniJIS-UTF8':'utf-8'}, ['cmaprsrc/cid2code_Adobe_Japan1.txt']",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "convert_cmap()",
                  "action_description": "Custom function call (no direct match, best fit: Executes function to process data)",
                  "action_id": "execute_shell_command",
                  "object": "outdir, 'Adobe-Korea1', {'KSC-EUC':'euc-kr', 'KSC-Johab':'johab', 'KSCms-UHC':'cp949', 'UniKS-UTF8':'utf-8'}, ['cmaprsrc/cid2code_Adobe_Korea1.txt']",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "install.run()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "self",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Trigger main behavioral logic",
                  "intention_id": "trigger_main_behavioral_logic"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "'README.md'",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "fp.read()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "cmdclass = { 'install': install_cmap }, name = 'pdfminer', version = __version__, ...",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Trigger main behavioral logic",
                  "intention_id": "trigger_main_behavioral_logic"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "gs_quant-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/gs_quant-1.2.50.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gs_quant-1.2.50/gs_quant-1.2.50/setup.py",
          "line_number": "28",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport shutil\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nimport setuptools\nimport versioneer\n\nif \"sdist\" in sys.argv:\n    reference = os.path.dirname(__file__)\n    doc_dir = os.path.join(reference, \"docs\")\n    p = subprocess.Popen(\"sphinx-build -M help . _build\", cwd=doc_dir, shell=True)\n    p.wait(30)\n    if p.returncode != 0:\n        raise RuntimeError(\"unable to make docs\")\n\n    generated_dir = Path(os.path.join(doc_dir, \"_build\", \"html\", \"functions\"))\n    generated_dir.mkdir(parents=True, exist_ok=True)\n    target_dir = os.path.join(reference, \"gs_quant\", \"docs\")\n    shutil.rmtree(target_dir, ignore_errors=True)\n    shutil.copytree(generated_dir, target_dir)",
          "hash_value": "c916e5edd07d3286f60b700739d458fb",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport shutil\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nimport setuptools\nimport versioneer\n\nif \"sdist\" in sys.argv:\n    reference = os.path.dirname(__file__)\n    doc_dir = os.path.join(reference, \"docs\")\n    p = subprocess.Popen(\"sphinx-build -M help . _build\", cwd=doc_dir, shell=True)\n    p.wait(30)\n    if p.returncode != 0:\n        raise RuntimeError(\"unable to make docs\")\n\n    generated_dir = Path(os.path.join(doc_dir, \"_build\", \"html\", \"functions\"))\n    generated_dir.mkdir(parents=True, exist_ok=True)\n    target_dir = os.path.join(reference, \"gs_quant\", \"docs\")\n    shutil.rmtree(target_dir, ignore_errors=True)\n    shutil.copytree(generated_dir, target_dir)",
              "triple_sequences": [
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "reference, \"docs\"",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command with shell access",
                  "action_id": "spawn_process_shell",
                  "object": "\"sphinx-build -M help . _build\", cwd=doc_dir, shell=True",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "p.wait()",
                  "action_description": "Waits for process to complete execution",
                  "action_id": "wait_process_completion",
                  "object": "30",
                  "object_description": "Timeout duration value",
                  "object_id": "timeout_value",
                  "intention_description": "Pause execution",
                  "intention_id": "pause_execution"
                },
                {
                  "action_api": "Path()",
                  "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
                  "action_id": "path_object_operations",
                  "object": "os.path.join(doc_dir, \"_build\", \"html\", \"functions\")",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "Path.mkdir()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "parents=True, exist_ok=True",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "reference, \"gs_quant\", \"docs\"",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "shutil.rmtree()",
                  "action_description": "Recursively deletes directory and its contents",
                  "action_id": "delete_directory",
                  "object": "target_dir, ignore_errors=True",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Delete directory content",
                  "intention_id": "delete_directory_content"
                },
                {
                  "action_api": "shutil.copytree()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "generated_dir, target_dir",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Copy file to startup directory",
                  "intention_id": "copy_file_startup_directory"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "httpx_ws-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/httpx_ws-0.7.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/httpx_ws-0.7.2/httpx_ws-0.7.2/setup.py",
          "line_number": "8",
          "type_description": "shady-links",
          "context_snippet": "# -*- coding: utf-8 -*-\nfrom setuptools import setup\n\nsetup(\n    name='httpx-ws',\n    version='0.7.2',\n    description='WebSockets support for HTTPX',\n    long_description='# HTTPX WS\\n\\n<p align=\"center\">\\n    <em>WebSockets support for HTTPX</em>\\n</p>\\n\\n[![build](https://github.com/frankie567/httpx-ws/workflows/Build/badge.svg)](https://github.com/frankie567/httpx-ws/actions)\\n[![codecov](https://codecov.io/gh/frankie567/httpx-ws/branch/main/graph/badge.svg?token=fL49kIvrj6)](https://codecov.io/gh/frankie567/httpx-ws)\\n[![All Contributors](https://img.shields.io/badge/all_contributors-2-orange.svg?style=flat-square)](#contributors-)\\n[![PyPI version](https://badge.fury.io/py/httpx-ws.svg)](https://badge.fury.io/py/httpx-ws)\\n[![Downloads](https://pepy.tech/badge/httpx-ws)](https://pepy.tech/project/httpx-ws)\\n\\n---\\n\\n**Documentation**: <a href=\"https://frankie567.github.io/httpx-ws/\" target=\"_blank\">https://frankie567.github.io/httpx-ws/</a>\\n\\n**Source Code**: <a href=\"https://github.com/frankie567/httpx-ws\" target=\"_blank\">https://github.com/frankie567/httpx-ws</a>\\n\\n---\\n\\n## Installation\\n\\n```bash\\npip install httpx-ws\\n```\\n\\n## Features\\n\\n- [x] Sync and async client\\n- [x] Helper methods to send text, binary and JSON data\\n- [x] Helper methods to receive text, binary and JSON data\\n- [x] Automatic ping/pong answers\\n- [x] HTTPX transport to test WebSockets defined in ASGI apps\\n- [x] Automatic keepalive ping\\n- [x] `asyncio` and [Trio](https://trio.readthedocs.io/) support through [AnyIO](https://anyio.readthedocs.io/)\\n\\n## Contributors ✨\\n\\nThanks goes to these wonderful people ([emoji key](https://allcontributors.org/docs/en/emoji-key)):\\n\\n<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->\\n<!-- prettier-ignore-start -->\\n<!-- markdownlint-disable -->\\n<table>\\n  <tbody>\\n    <tr>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"http://francoisvoron.com\"><img src=\"https://avatars.githubusercontent.com/u/1144727?v=4?s=100\" width=\"100px;\" alt=\"François Voron\"/><br /><sub><b>François Voron</b></sub></a><br /><a href=\"#maintenance-frankie567\" title=\"Maintenance\">🚧</a> <a href=\"https://github.com/frankie567/httpx-ws/commits?author=frankie567\" title=\"Code\">💻</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"http://kousikmitra.github.io\"><img src=\"https://avatars.githubusercontent.com/u/15109533?v=4?s=100\" width=\"100px;\" alt=\"Kousik Mitra\"/><br /><sub><b>Kousik Mitra</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/commits?author=kousikmitra\" title=\"Code\">💻</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/davidbrochart\"><img src=\"https://avatars.githubusercontent.com/u/4711805?v=4?s=100\" width=\"100px;\" alt=\"David Brochart\"/><br /><sub><b>David Brochart</b></sub></a><br /><a href=\"#platform-davidbrochart\" title=\"Packaging/porting to new platform\">📦</a> <a href=\"https://github.com/frankie567/httpx-ws/commits?author=davidbrochart\" title=\"Code\">💻</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/ysmu\"><img src=\"https://avatars.githubusercontent.com/u/17018576?v=4?s=100\" width=\"100px;\" alt=\"ysmu\"/><br /><sub><b>ysmu</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3Aysmu\" title=\"Bug reports\">🐛</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://samforeman.me\"><img src=\"https://avatars.githubusercontent.com/u/5234251?v=4?s=100\" width=\"100px;\" alt=\"Sam Foreman\"/><br /><sub><b>Sam Foreman</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3Asaforem2\" title=\"Bug reports\">🐛</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"http://maparent.ca/\"><img src=\"https://avatars.githubusercontent.com/u/202691?v=4?s=100\" width=\"100px;\" alt=\"Marc-Antoine Parent\"/><br /><sub><b>Marc-Antoine Parent</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3Amaparent\" title=\"Bug reports\">🐛</a> <a href=\"https://github.com/frankie567/httpx-ws/commits?author=maparent\" title=\"Code\">💻</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://www.fastapiexpert.com/\"><img src=\"https://avatars.githubusercontent.com/u/7353520?v=4?s=100\" width=\"100px;\" alt=\"Marcelo Trylesinski\"/><br /><sub><b>Marcelo Trylesinski</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3AKludex\" title=\"Bug reports\">🐛</a> <a href=\"#research-Kludex\" title=\"Research\">🔬</a></td>\\n    </tr>\\n    <tr>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://lit.link/MtkN1\"><img src=\"https://avatars.githubusercontent.com/u/51289448?v=4?s=100\" width=\"100px;\" alt=\"MtkN1\"/><br /><sub><b>MtkN1</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3AMtkN1\" title=\"Bug reports\">🐛</a> <a href=\"#research-MtkN1\" title=\"Research\">🔬</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"http://www.tomchristie.com/\"><img src=\"https://avatars.githubusercontent.com/u/647359?v=4?s=100\" width=\"100px;\" alt=\"Tom Christie\"/><br /><sub><b>Tom Christie</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3Atomchristie\" title=\"Bug reports\">🐛</a> <a href=\"#research-tomchristie\" title=\"Research\">🔬</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/dmontagu\"><img src=\"https://avatars.githubusercontent.com/u/35119617?v=4?s=100\" width=\"100px;\" alt=\"David Montague\"/><br /><sub><b>David Montague</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3Admontagu\" title=\"Bug reports\">🐛</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/WSH032\"><img src=\"https://avatars.githubusercontent.com/u/126865849?v=4?s=100\" width=\"100px;\" alt=\"Sean Wang\"/><br /><sub><b>Sean Wang</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/commits?author=WSH032\" title=\"Code\">💻</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/agronholm\"><img src=\"https://avatars.githubusercontent.com/u/130003?v=4?s=100\" width=\"100px;\" alt=\"Alex Grönholm\"/><br /><sub><b>Alex Grönholm</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3Aagronholm\" title=\"Bug reports\">🐛</a> <a href=\"https://github.com/frankie567/httpx-ws/commits?author=agronholm\" title=\"Code\">💻</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/ro-oliveira95\"><img src=\"https://avatars.githubusercontent.com/u/27009864?v=4?s=100\" width=\"100px;\" alt=\"Rodrigo de Oliveira Neto\"/><br /><sub><b>Rodrigo de Oliveira Neto</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3Aro-oliveira95\" title=\"Bug reports\">🐛</a> <a href=\"https://github.com/frankie567/httpx-ws/commits?author=ro-oliveira95\" title=\"Code\">💻</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://tinymind.me/GreyElaina\"><img src=\"https://avatars.githubusercontent.com/u/31543961?v=4?s=100\" width=\"100px;\" alt=\"Elaina\"/><br /><sub><b>Elaina</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/commits?author=GreyElaina\" title=\"Code\">💻</a></td>\\n    </tr>\\n    <tr>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://runsisi.com\"><img src=\"https://avatars.githubusercontent.com/u/2339258?v=4?s=100\" width=\"100px;\" alt=\"runsisi\"/><br /><sub><b>runsisi</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3Arunsisi\" title=\"Bug reports\">🐛</a> <a href=\"#research-runsisi\" title=\"Research\">🔬</a></td>\\n    </tr>\\n  </tbody>\\n</table>\\n\\n<!-- markdownlint-restore -->\\n<!-- prettier-ignore-end -->\\n\\n<!-- ALL-CONTRIBUTORS-LIST:END -->\\n\\nThis project follows the [all-contributors](https://github.com/all-contributors/all-contributors) specification. Contributions of any kind welcome!\\n\\n## Development\\n\\n### Setup environment\\n\\nWe use [Hatch](https://hatch.pypa.io/latest/install/) to manage the development environment and production build. Ensure it\\'s installed on your system.\\n\\n### Run unit tests\\n\\nYou can run all the tests with:\\n\\n```bash\\nhatch run test\\n```\\n\\n### Format the code\\n\\nExecute the following command to apply linting and check typing:\\n\\n```bash\\nhatch run lint\\n```\\n\\n## License\\n\\nThis project is licensed under the terms of the MIT license.\\n',\n    author_email='François Voron <fvoron@gmail.com>',\n    classifiers=[\n        'Development Status :: 4 - Beta',\n        'Framework :: AsyncIO',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: MIT License',\n        'Programming Language :: Python :: 3 :: Only',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n        'Programming Language :: Python :: 3.12',\n        'Programming Language :: Python :: 3.13',\n        'Topic :: Internet :: WWW/HTTP :: Session',\n    ],\n    install_requires=[\n        'anyio>=4',\n        'httpcore>=1.0.4',\n        'httpx>=0.23.1',\n        'wsproto',\n    ],\n    packages=[\n        'httpx_ws',\n        'tests',\n    ],\n)\n",
          "hash_value": "f29d3d914c0dbef900f4ec836e553192",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "# -*- coding: utf-8 -*-\nfrom setuptools import setup\n\nsetup(\n    name='httpx-ws',\n    version='0.7.2',\n    description='WebSockets support for HTTPX',\n    long_description='# HTTPX WS\\n\\n<p align=\"center\">\\n    <em>WebSockets support for HTTPX</em>\\n</p>\\n\\n[![build](https://github.com/frankie567/httpx-ws/workflows/Build/badge.svg)](https://github.com/frankie567/httpx-ws/actions)\\n[![codecov](https://codecov.io/gh/frankie567/httpx-ws/branch/main/graph/badge.svg?token=fL49kIvrj6)](https://codecov.io/gh/frankie567/httpx-ws)\\n[![All Contributors](https://img.shields.io/badge/all_contributors-2-orange.svg?style=flat-square)](#contributors-)\\n[![PyPI version](https://badge.fury.io/py/httpx-ws.svg)](https://badge.fury.io/py/httpx-ws)\\n[![Downloads](https://pepy.tech/badge/httpx-ws)](https://pepy.tech/project/httpx-ws)\\n\\n---\\n\\n**Documentation**: <a href=\"https://frankie567.github.io/httpx-ws/\" target=\"_blank\">https://frankie567.github.io/httpx-ws/</a>\\n\\n**Source Code**: <a href=\"https://github.com/frankie567/httpx-ws\" target=\"_blank\">https://github.com/frankie567/httpx-ws</a>\\n\\n---\\n\\n## Installation\\n\\n```bash\\npip install httpx-ws\\n```\\n\\n## Features\\n\\n- [x] Sync and async client\\n- [x] Helper methods to send text, binary and JSON data\\n- [x] Helper methods to receive text, binary and JSON data\\n- [x] Automatic ping/pong answers\\n- [x] HTTPX transport to test WebSockets defined in ASGI apps\\n- [x] Automatic keepalive ping\\n- [x] `asyncio` and [Trio](https://trio.readthedocs.io/) support through [AnyIO](https://anyio.readthedocs.io/)\\n\\n## Contributors ✨\\n\\nThanks goes to these wonderful people ([emoji key](https://allcontributors.org/docs/en/emoji-key)):\\n\\n<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->\\n<!-- prettier-ignore-start -->\\n<!-- markdownlint-disable -->\\n<table>\\n  <tbody>\\n    <tr>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"http://francoisvoron.com\"><img src=\"https://avatars.githubusercontent.com/u/1144727?v=4?s=100\" width=\"100px;\" alt=\"François Voron\"/><br /><sub><b>François Voron</b></sub></a><br /><a href=\"#maintenance-frankie567\" title=\"Maintenance\">🚧</a> <a href=\"https://github.com/frankie567/httpx-ws/commits?author=frankie567\" title=\"Code\">💻</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"http://kousikmitra.github.io\"><img src=\"https://avatars.githubusercontent.com/u/15109533?v=4?s=100\" width=\"100px;\" alt=\"Kousik Mitra\"/><br /><sub><b>Kousik Mitra</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/commits?author=kousikmitra\" title=\"Code\">💻</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/davidbrochart\"><img src=\"https://avatars.githubusercontent.com/u/4711805?v=4?s=100\" width=\"100px;\" alt=\"David Brochart\"/><br /><sub><b>David Brochart</b></sub></a><br /><a href=\"#platform-davidbrochart\" title=\"Packaging/porting to new platform\">📦</a> <a href=\"https://github.com/frankie567/httpx-ws/commits?author=davidbrochart\" title=\"Code\">💻</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/ysmu\"><img src=\"https://avatars.githubusercontent.com/u/17018576?v=4?s=100\" width=\"100px;\" alt=\"ysmu\"/><br /><sub><b>ysmu</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3Aysmu\" title=\"Bug reports\">🐛</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://samforeman.me\"><img src=\"https://avatars.githubusercontent.com/u/5234251?v=4?s=100\" width=\"100px;\" alt=\"Sam Foreman\"/><br /><sub><b>Sam Foreman</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3Asaforem2\" title=\"Bug reports\">🐛</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"http://maparent.ca/\"><img src=\"https://avatars.githubusercontent.com/u/202691?v=4?s=100\" width=\"100px;\" alt=\"Marc-Antoine Parent\"/><br /><sub><b>Marc-Antoine Parent</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3Amaparent\" title=\"Bug reports\">🐛</a> <a href=\"https://github.com/frankie567/httpx-ws/commits?author=maparent\" title=\"Code\">💻</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://www.fastapiexpert.com/\"><img src=\"https://avatars.githubusercontent.com/u/7353520?v=4?s=100\" width=\"100px;\" alt=\"Marcelo Trylesinski\"/><br /><sub><b>Marcelo Trylesinski</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3AKludex\" title=\"Bug reports\">🐛</a> <a href=\"#research-Kludex\" title=\"Research\">🔬</a></td>\\n    </tr>\\n    <tr>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://lit.link/MtkN1\"><img src=\"https://avatars.githubusercontent.com/u/51289448?v=4?s=100\" width=\"100px;\" alt=\"MtkN1\"/><br /><sub><b>MtkN1</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3AMtkN1\" title=\"Bug reports\">🐛</a> <a href=\"#research-MtkN1\" title=\"Research\">🔬</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"http://www.tomchristie.com/\"><img src=\"https://avatars.githubusercontent.com/u/647359?v=4?s=100\" width=\"100px;\" alt=\"Tom Christie\"/><br /><sub><b>Tom Christie</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3Atomchristie\" title=\"Bug reports\">🐛</a> <a href=\"#research-tomchristie\" title=\"Research\">🔬</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/dmontagu\"><img src=\"https://avatars.githubusercontent.com/u/35119617?v=4?s=100\" width=\"100px;\" alt=\"David Montague\"/><br /><sub><b>David Montague</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3Admontagu\" title=\"Bug reports\">🐛</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/WSH032\"><img src=\"https://avatars.githubusercontent.com/u/126865849?v=4?s=100\" width=\"100px;\" alt=\"Sean Wang\"/><br /><sub><b>Sean Wang</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/commits?author=WSH032\" title=\"Code\">💻</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/agronholm\"><img src=\"https://avatars.githubusercontent.com/u/130003?v=4?s=100\" width=\"100px;\" alt=\"Alex Grönholm\"/><br /><sub><b>Alex Grönholm</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3Aagronholm\" title=\"Bug reports\">🐛</a> <a href=\"https://github.com/frankie567/httpx-ws/commits?author=agronholm\" title=\"Code\">💻</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/ro-oliveira95\"><img src=\"https://avatars.githubusercontent.com/u/27009864?v=4?s=100\" width=\"100px;\" alt=\"Rodrigo de Oliveira Neto\"/><br /><sub><b>Rodrigo de Oliveira Neto</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3Aro-oliveira95\" title=\"Bug reports\">🐛</a> <a href=\"https://github.com/frankie567/httpx-ws/commits?author=ro-oliveira95\" title=\"Code\">💻</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://tinymind.me/GreyElaina\"><img src=\"https://avatars.githubusercontent.com/u/31543961?v=4?s=100\" width=\"100px;\" alt=\"Elaina\"/><br /><sub><b>Elaina</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/commits?author=GreyElaina\" title=\"Code\">💻</a></td>\\n    </tr>\\n    <tr>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://runsisi.com\"><img src=\"https://avatars.githubusercontent.com/u/2339258?v=4?s=100\" width=\"100px;\" alt=\"runsisi\"/><br /><sub><b>runsisi</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3Arunsisi\" title=\"Bug reports\">🐛</a> <a href=\"#research-runsisi\" title=\"Research\">🔬</a></td>\\n    </tr>\\n  </tbody>\\n</table>\\n\\n<!-- markdownlint-restore -->\\n<!-- prettier-ignore-end -->\\n\\n<!-- ALL-CONTRIBUTORS-LIST:END -->\\n\\nThis project follows the [all-contributors](https://github.com/all-contributors/all-contributors) specification. Contributions of any kind welcome!\\n\\n## Development\\n\\n### Setup environment\\n\\nWe use [Hatch](https://hatch.pypa.io/latest/install/) to manage the development environment and production build. Ensure it\\'s installed on your system.\\n\\n### Run unit tests\\n\\nYou can run all the tests with:\\n\\n```bash\\nhatch run test\\n```\\n\\n### Format the code\\n\\nExecute the following command to apply linting and check typing:\\n\\n```bash\\nhatch run lint\\n```\\n\\n## License\\n\\nThis project is licensed under the terms of the MIT license.\\n',\n    author_email='François Voron <fvoron@gmail.com>',\n    classifiers=[\n        'Development Status :: 4 - Beta',\n        'Framework :: AsyncIO',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: MIT License',\n        'Programming Language :: Python :: 3 :: Only',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n        'Programming Language :: Python :: 3.12',\n        'Programming Language :: Python :: 3.13',\n        'Topic :: Internet :: WWW/HTTP :: Session',\n    ],\n    install_requires=[\n        'anyio>=4',\n        'httpcore>=1.0.4',\n        'httpx>=0.23.1',\n        'wsproto',\n    ],\n    packages=[\n        'httpx_ws',\n        'tests',\n    ],\n)\n",
              "triple_sequences": [
                {
                  "action_api": "setuptools.setup()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "name='httpx-ws', version='0.7.2', description='WebSockets support for HTTPX', long_description='# HTTPX WS\\n\\n<p align=\"center\">\\n    <em>WebSockets support for HTTPX</em>\\n</p>\\n\\n[![build](https://github.com/frankie567/httpx-ws/workflows/Build/badge.svg)](https://github.com/frankie567/httpx-ws/actions)\\n[![codecov](https://codecov.io/gh/frankie567/httpx-ws/branch/main/graph/badge.svg?token=fL49kIvrj6)](https://codecov.io/gh/frankie567/httpx-ws)\\n[![All Contributors](https://img.shields.io/badge/all_contributors-2-orange.svg?style=flat-square)](#contributors-)\\n[![PyPI version](https://badge.fury.io/py/httpx-ws.svg)](https://badge.fury.io/py/httpx-ws)\\n[![Downloads](https://pepy.tech/badge/httpx-ws)](https://pepy.tech/project/httpx-ws)\\n\\n---\\n\\n**Documentation**: <a href=\"https://frankie567.github.io/httpx-ws/\" target=\"_blank\">https://frankie567.github.io/httpx-ws/</a>\\n\\n**Source Code**: <a href=\"https://github.com/frankie567/httpx-ws\" target=\"_blank\">https://github.com/frankie567/httpx-ws</a>\\n\\n---\\n\\n## Installation\\n\\n```bash\\npip install httpx-ws\\n```\\n\\n## Features\\n\\n- [x] Sync and async client\\n- [x] Helper methods to send text, binary and JSON data\\n- [x] Helper methods to receive text, binary and JSON data\\n- [x] Automatic ping/pong answers\\n- [x] HTTPX transport to test WebSockets defined in ASGI apps\\n- [x] Automatic keepalive ping\\n- [x] `asyncio` and [Trio](https://trio.readthedocs.io/) support through [AnyIO](https://anyio.readthedocs.io/)\\n\\n## Contributors ✨\\n\\nThanks goes to these wonderful people ([emoji key](https://allcontributors.org/docs/en/emoji-key)):\\n\\n<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->\\n<!-- prettier-ignore-start -->\\n<!-- markdownlint-disable -->\\n<table>\\n  <tbody>\\n    <tr>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"http://francoisvoron.com\"><img src=\"https://avatars.githubusercontent.com/u/1144727?v=4?s=100\" width=\"100px;\" alt=\"François Voron\"/><br /><sub><b>François Voron</b></sub></a><br /><a href=\"#maintenance-frankie567\" title=\"Maintenance\">🚧</a> <a href=\"https://github.com/frankie567/httpx-ws/commits?author=frankie567\" title=\"Code\">💻</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"http://kousikmitra.github.io\"><img src=\"https://avatars.githubusercontent.com/u/15109533?v=4?s=100\" width=\"100px;\" alt=\"Kousik Mitra\"/><br /><sub><b>Kousik Mitra</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/commits?author=kousikmitra\" title=\"Code\">💻</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/davidbrochart\"><img src=\"https://avatars.githubusercontent.com/u/4711805?v=4?s=100\" width=\"100px;\" alt=\"David Brochart\"/><br /><sub><b>David Brochart</b></sub></a><br /><a href=\"#platform-davidbrochart\" title=\"Packaging/porting to new platform\">📦</a> <a href=\"https://github.com/frankie567/httpx-ws/commits?author=davidbrochart\" title=\"Code\">💻</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/ysmu\"><img src=\"https://avatars.githubusercontent.com/u/17018576?v=4?s=100\" width=\"100px;\" alt=\"ysmu\"/><br /><sub><b>ysmu</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3Aysmu\" title=\"Bug reports\">🐛</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://samforeman.me\"><img src=\"https://avatars.githubusercontent.com/u/5234251?v=4?s=100\" width=\"100px;\" alt=\"Sam Foreman\"/><br /><sub><b>Sam Foreman</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3Asaforem2\" title=\"Bug reports\">🐛</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"http://maparent.ca/\"><img src=\"https://avatars.githubusercontent.com/u/202691?v=4?s=100\" width=\"100px;\" alt=\"Marc-Antoine Parent\"/><br /><sub><b>Marc-Antoine Parent</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3Amaparent\" title=\"Bug reports\">🐛</a> <a href=\"https://github.com/frankie567/httpx-ws/commits?author=maparent\" title=\"Code\">💻</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://www.fastapiexpert.com/\"><img src=\"https://avatars.githubusercontent.com/u/7353520?v=4?s=100\" width=\"100px;\" alt=\"Marcelo Trylesinski\"/><br /><sub><b>Marcelo Trylesinski</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3AKludex\" title=\"Bug reports\">🐛</a> <a href=\"#research-Kludex\" title=\"Research\">🔬</a></td>\\n    </tr>\\n    <tr>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://lit.link/MtkN1\"><img src=\"https://avatars.githubusercontent.com/u/51289448?v=4?s=100\" width=\"100px;\" alt=\"MtkN1\"/><br /><sub><b>MtkN1</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3AMtkN1\" title=\"Bug reports\">🐛</a> <a href=\"#research-MtkN1\" title=\"Research\">🔬</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"http://www.tomchristie.com/\"><img src=\"https://avatars.githubusercontent.com/u/647359?v=4?s=100\" width=\"100px;\" alt=\"Tom Christie\"/><br /><sub><b>Tom Christie</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3Atomchristie\" title=\"Bug reports\">🐛</a> <a href=\"#research-tomchristie\" title=\"Research\">🔬</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/dmontagu\"><img src=\"https://avatars.githubusercontent.com/u/35119617?v=4?s=100\" width=\"100px;\" alt=\"David Montague\"/><br /><sub><b>David Montague</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3Admontagu\" title=\"Bug reports\">🐛</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/WSH032\"><img src=\"https://avatars.githubusercontent.com/u/126865849?v=4?s=100\" width=\"100px;\" alt=\"Sean Wang\"/><br /><sub><b>Sean Wang</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/commits?author=WSH032\" title=\"Code\">💻</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/agronholm\"><img src=\"https://avatars.githubusercontent.com/u/130003?v=4?s=100\" width=\"100px;\" alt=\"Alex Grönholm\"/><br /><sub><b>Alex Grönholm</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3Aagronholm\" title=\"Bug reports\">🐛</a> <a href=\"https://github.com/frankie567/httpx-ws/commits?author=agronholm\" title=\"Code\">💻</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/ro-oliveira95\"><img src=\"https://avatars.githubusercontent.com/u/27009864?v=4?s=100\" width=\"100px;\" alt=\"Rodrigo de Oliveira Neto\"/><br /><sub><b>Rodrigo de Oliveira Neto</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3Aro-oliveira95\" title=\"Bug reports\">🐛</a> <a href=\"https://github.com/frankie567/httpx-ws/commits?author=ro-oliveira95\" title=\"Code\">💻</a></td>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://tinymind.me/GreyElaina\"><img src=\"https://avatars.githubusercontent.com/u/31543961?v=4?s=100\" width=\"100px;\" alt=\"Elaina\"/><br /><sub><b>Elaina</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/commits?author=GreyElaina\" title=\"Code\">💻</a></td>\\n    </tr>\\n    <tr>\\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://runsisi.com\"><img src=\"https://avatars.githubusercontent.com/u/2339258?v=4?s=100\" width=\"100px;\" alt=\"runsisi\"/><br /><sub><b>runsisi</b></sub></a><br /><a href=\"https://github.com/frankie567/httpx-ws/issues?q=author%3Arunsisi\" title=\"Bug reports\">🐛</a> <a href=\"#research-runsisi\" title=\"Research\">🔬</a></td>\\n    </tr>\\n  </tbody>\\n</table>\\n\\n<!-- markdownlint-restore -->\\n<!-- prettier-ignore-end -->\\n\\n<!-- ALL-CONTRIBUTORS-LIST:END -->\\n\\nThis project follows the [all-contributors](https://github.com/all-contributors/all-contributors) specification. Contributions of any kind welcome!\\n\\n## Development\\n\\n### Setup environment\\n\\nWe use [Hatch](https://hatch.pypa.io/latest/install/) to manage the development environment and production build. Ensure it\\'s installed on your system.\\n\\n### Run unit tests\\n\\nYou can run all the tests with:\\n\\n```bash\\nhatch run test\\n```\\n\\n### Format the code\\n\\nExecute the following command to apply linting and check typing:\\n\\n```bash\\nhatch run lint\\n```\\n\\n## License\\n\\nThis project is licensed under the terms of the MIT license.\\n', author_email='François Voron <fvoron@gmail.com>', classifiers=[ 'Development Status :: 4 - Beta', 'Framework :: AsyncIO', 'Intended Audience :: Developers', 'License :: OSI Approved :: MIT License', 'Programming Language :: Python :: 3 :: Only', 'Programming Language :: Python :: 3.9', 'Programming Language :: Python :: 3.10', 'Programming Language :: Python :: 3.11', 'Programming Language :: Python :: 3.12', 'Programming Language :: Python :: 3.13', 'Topic :: Internet :: WWW/HTTP :: Session', ], install_requires=[ 'anyio>=4', 'httpcore>=1.0.4', 'httpx>=0.23.1', 'wsproto', ], packages=[ 'httpx_ws', 'tests', ] )",
                  "object_description": "Script file content",
                  "object_id": "script_file_content",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "instructor-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/instructor-1.7.9.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "together.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/instructor-1.7.9/instructor-1.7.9/examples/patching/together.py",
          "line_number": "7",
          "type_description": "shady-links",
          "context_snippet": "import os\nimport openai\nfrom pydantic import BaseModel\nimport instructor\n\nclient = openai.OpenAI(\n    base_url=\"https://api.together.xyz/v1\",\n    api_key=os.environ[\"TOGETHER_API_KEY\"],\n)\n",
          "hash_value": "2f63055ddad2912223464681dbd3ba7b",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport openai\nfrom pydantic import BaseModel\nimport instructor\n\nclient = openai.OpenAI(\n    base_url=\"https://api.together.xyz/v1\",\n    api_key=os.environ[\"TOGETHER_API_KEY\"],\n)\n",
              "triple_sequences": [
                {
                  "action_api": "os.environ[]",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "TOGETHER_API_KEY",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "optbinning-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/optbinning-0.20.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/optbinning-0.20.1/optbinning-0.20.1/setup.py",
          "line_number": "31",
          "type_description": "code-execution",
          "context_snippet": "import os\n\nfrom setuptools import find_packages, setup, Command\n\nclass CleanCommand(Command):\n    user_options = []\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        os.system('rm -vrf ./build ./dist ./*.pyc ./*.tgz ./*.egg-info')",
          "hash_value": "2b4ba83a4f6b445f671135ea22a0bf29",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\n\nfrom setuptools import find_packages, setup, Command\n\nclass CleanCommand(Command):\n    user_options = []\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        os.system('rm -vrf ./build ./dist ./*.pyc ./*.tgz ./*.egg-info')",
              "triple_sequences": [
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "rm -vrf ./build ./dist ./*.pyc ./*.tgz ./*.egg-info",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Delete directory content",
                  "intention_id": "delete_directory_content"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "censys-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/censys-2.2.16.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "hnri.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/censys-2.2.16/censys-2.2.16/censys/cli/commands/hnri.py",
          "line_number": "38",
          "type_description": "shady-links",
          "context_snippet": "import requests\n\nclass CensysHNRI:\n    \"\"\"Searches the Censys API for the user's current IP to scan for risks.\"\"\"\n\n    HIGH_RISK_DEFINITION: List[str] = [\"TELNET\", \"REDIS\", \"POSTGRES\", \"VNC\"]\n    MEDIUM_RISK_DEFINITION: List[str] = [\"SSH\", \"HTTP\", \"HTTPS\"]\n\n    def __init__(self, api_id: Optional[str] = None, api_secret: Optional[str] = None):\n        \"\"\"Inits CensysHNRI.\n\n        Args:\n            api_id (str): Optional; The API ID provided by Censys.\n            api_secret (str): Optional; The API secret provided by Censys.\n        \"\"\"\n        self.index = CensysHosts(api_id, api_secret)\n\n    @staticmethod\n    def get_current_ip() -> str:\n        \"\"\"Uses ipify.org to get the current IP address.\n\n        Returns:\n            str: IP address.\n        \"\"\"\n        response = requests.get(\"https://api.ipify.org?format=json\")\n        current_ip = str(response.json().get(\"ip\"))\n        return current_ip",
          "hash_value": "d08e814fae2aa7d0b9bfcd3bd7ebe1ec",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import requests\n\nclass CensysHNRI:\n    \"\"\"Searches the Censys API for the user's current IP to scan for risks.\"\"\"\n\n    HIGH_RISK_DEFINITION: List[str] = [\"TELNET\", \"REDIS\", \"POSTGRES\", \"VNC\"]\n    MEDIUM_RISK_DEFINITION: List[str] = [\"SSH\", \"HTTP\", \"HTTPS\"]\n\n    def __init__(self, api_id: Optional[str] = None, api_secret: Optional[str] = None):\n        \"\"\"Inits CensysHNRI.\n\n        Args:\n            api_id (str): Optional; The API ID provided by Censys.\n            api_secret (str): Optional; The API secret provided by Censys.\n        \"\"\"\n        self.index = CensysHosts(api_id, api_secret)\n\n    @staticmethod\n    def get_current_ip() -> str:\n        \"\"\"Uses ipify.org to get the current IP address.\n\n        Returns:\n            str: IP address.\n        \"\"\"\n        response = requests.get(\"https://api.ipify.org?format=json\")\n        current_ip = str(response.json().get(\"ip\"))\n        return current_ip",
              "triple_sequences": [
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP GET request to URL",
                  "action_id": "open_url_get",
                  "object": "https://api.ipify.org?format=json",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Collect public IP address",
                  "intention_id": "collect_public_ip"
                },
                {
                  "action_api": "response.json()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "beaker-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/beaker-1.13.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "_compat.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/beaker-1.13.0/Beaker-1.13.0/beaker/_compat.py",
          "line_number": "137",
          "type_description": "obfuscation",
          "context_snippet": "if not PY2:  # pragma: no cover\n    import builtins\n    exec_ = getattr(builtins, \"exec\")\n\n    def reraise(tp, value, tb=None):\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value\nelse:  # pragma: no cover\n    def exec_(code, globs=None, locs=None):\n        \"\"\"Execute code in a namespace.\"\"\"\n        if globs is None:\n            frame = sys._getframe(1)\n            globs = frame.f_globals\n            if locs is None:\n                locs = frame.f_locals\n            del frame\n        elif locs is None:\n            locs = globs\n        exec(\"\"\"exec code in globs, locs\"\"\")\n\n    exec_(\"\"\"def reraise(tp, value, tb=None):\n    raise tp, value, tb\n\"\"\")",
          "hash_value": "cbb8ca7b4986293e5307a8c99a4f24c4",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "if not PY2:  # pragma: no cover\n    import builtins\n    exec_ = getattr(builtins, \"exec\")\n\n    def reraise(tp, value, tb=None):\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value\nelse:  # pragma: no cover\n    def exec_(code, globs=None, locs=None):\n        \"\"\"Execute code in a namespace.\"\"\"\n        if globs is None:\n            frame = sys._getframe(1)\n            globs = frame.f_globals\n            if locs is None:\n                locs = frame.f_locals\n            del frame\n        elif locs is None:\n            locs = globs\n        exec(\"\"\"exec code in globs, locs\"\"\")\n\n    exec_(\"\"\"def reraise(tp, value, tb=None):\n    raise tp, value, tb\n\"\"\")",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Dynamically imports specified module",
                  "action_id": "import_dynamic",
                  "object": "builtins, \"exec\"",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "exec_()",
                  "action_description": "Dynamically executes Python code string",
                  "action_id": "exec_python_code",
                  "object": "\"\"\"def reraise(tp, value, tb=None):\n    raise tp, value, tb\n\"\"\"",
                  "object_description": "Python code string",
                  "object_id": "python_code_string",
                  "intention_description": "Execute Python code",
                  "intention_id": "execute_python_code"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "mypy_baseline-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/mypy_baseline-0.7.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "_suggest.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/mypy_baseline-0.7.2/mypy_baseline-0.7.2/mypy_baseline/commands/_suggest.py",
          "line_number": "216",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "def _post_to_gitlab(self, err_msg: str) -> None:\n    \"\"\"Add a comment to the GitLab MR for which the job runs.\n    \"\"\"\n    import requests\n\n    # get API token\n    is_gitlab = os.environ.get('GITLAB_CI')\n    if not is_gitlab:\n        raise LookupError('Not running on GitLab CI')\n    token = os.environ.get('REVIEWDOG_GITLAB_API_TOKEN')\n    if not token:\n        token = os.environ.get('GITLAB_API_TOKEN')\n    if not token:\n        raise LookupError('GITLAB_API_TOKEN env var is not set')\n\n    already_commented = self._check_gitlab_has_comment(token)\n    if already_commented:\n        return\n\n    # form the message\n    s = 's' if self.args.min_fixed > 1 else ''\n    path = self.config.baseline_path\n    count = self.args.min_fixed\n    msg = f\"\"\"\n        ## mypy-baseline suggest\n\n        Please, resolve at least {count} error{s} from `{path}`. Suggested:\n\n        ```\n        {err_msg}\n        ```\n    \"\"\"\n\n    # send the request\n    resp = requests.post(\n        url=self._gitlab_comment_url,\n        json={'body': dedent(msg)},\n        headers={'PRIVATE-TOKEN': token},\n    )\n    resp.raise_for_status()\n",
          "hash_value": "fa8df4f8ef6b120fb78f29add5d83405",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def _post_to_gitlab(self, err_msg: str) -> None:\n    \"\"\"Add a comment to the GitLab MR for which the job runs.\n    \"\"\"\n    import requests\n\n    # get API token\n    is_gitlab = os.environ.get('GITLAB_CI')\n    if not is_gitlab:\n        raise LookupError('Not running on GitLab CI')\n    token = os.environ.get('REVIEWDOG_GITLAB_API_TOKEN')\n    if not token:\n        token = os.environ.get('GITLAB_API_TOKEN')\n    if not token:\n        raise LookupError('GITLAB_API_TOKEN env var is not set')\n\n    already_commented = self._check_gitlab_has_comment(token)\n    if already_commented:\n        return\n\n    # form the message\n    s = 's' if self.args.min_fixed > 1 else ''\n    path = self.config.baseline_path\n    count = self.args.min_fixed\n    msg = f\"\"\"\n        ## mypy-baseline suggest\n\n        Please, resolve at least {count} error{s} from `{path}`. Suggested:\n\n        ```\n        {err_msg}\n        ```\n    \"\"\"\n\n    # send the request\n    resp = requests.post(\n        url=self._gitlab_comment_url,\n        json={'body': dedent(msg)},\n        headers={'PRIVATE-TOKEN': token},\n    )\n    resp.raise_for_status()\n",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "GITLAB_CI",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "REVIEWDOG_GITLAB_API_TOKEN",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "GITLAB_API_TOKEN",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "self._check_gitlab_has_comment()",
                  "action_description": "Checks if any blacklist name is in hostname",
                  "action_id": "check_blacklist_hostname",
                  "object": "token",
                  "object_description": "API key or token",
                  "object_id": "api_key",
                  "intention_description": "Determine presence of valid authentication",
                  "intention_id": "determine_valid_authentication_presence"
                },
                {
                  "action_api": "requests.post()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "url=self._gitlab_comment_url, json={'body': dedent(msg)}, headers={'PRIVATE-TOKEN': token}",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Transmit data to server",
                  "intention_id": "send_data_server"
                },
                {
                  "action_api": "resp.raise_for_status()",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pygeos-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pygeos-0.14.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pygeos-0.14/pygeos-0.14/setup.py",
          "line_number": "46",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport subprocess\nimport logging\n\nlog = logging.getLogger(__name__)\n\ndef get_geos_config(option):\n    \"\"\"Get configuration option from the `geos-config` development utility\n\n    The PATH environment variable should include the path where geos-config is\n    located, or the GEOS_CONFIG environment variable should point to the\n    executable.\n    \"\"\"\n    cmd = os.environ.get(\"GEOS_CONFIG\", \"geos-config\")\n    try:\n        stdout, stderr = subprocess.Popen(\n            [cmd, option], stdout=subprocess.PIPE, stderr=subprocess.PIPE\n        ).communicate()\n    except OSError:\n        return\n    if stderr and not stdout:\n        log.warning(\"geos-config %s returned '%s'\", option, stderr.decode().strip())\n        return\n    result = stdout.decode().strip()\n    log.debug(\"geos-config %s returned '%s'\", option, result)\n    return result",
          "hash_value": "e9f2980ea249fe7282c5803477bbd914",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport subprocess\nimport logging\n\nlog = logging.getLogger(__name__)\n\ndef get_geos_config(option):\n    \"\"\"Get configuration option from the `geos-config` development utility\n\n    The PATH environment variable should include the path where geos-config is\n    located, or the GEOS_CONFIG environment variable should point to the\n    executable.\n    \"\"\"\n    cmd = os.environ.get(\"GEOS_CONFIG\", \"geos-config\")\n    try:\n        stdout, stderr = subprocess.Popen(\n            [cmd, option], stdout=subprocess.PIPE, stderr=subprocess.PIPE\n        ).communicate()\n    except OSError:\n        return\n    if stderr and not stdout:\n        log.warning(\"geos-config %s returned '%s'\", option, stderr.decode().strip())\n        return\n    result = stdout.decode().strip()\n    log.debug(\"geos-config %s returned '%s'\", option, result)\n    return result",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"GEOS_CONFIG\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "[cmd, option]",
                  "object_description": "System command",
                  "object_id": "system_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.Popen().communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "logging.Logger.warning()",
                  "action_description": "Writes file content",
                  "action_id": "write_file_content",
                  "object": "\"geos-config %s returned '%s'\", option, stderr.decode().strip()",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "bytes.decode()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "stdout",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                },
                {
                  "action_api": "logging.Logger.debug()",
                  "action_description": "Writes file content",
                  "action_id": "write_file_content",
                  "object": "\"geos-config %s returned '%s'\", option, result",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "py_consul-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/py_consul-1.6.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/py_consul-1.6.0/py_consul-1.6.0/setup.py",
          "line_number": "32",
          "type_description": "cmd-overwrite",
          "context_snippet": "import glob\nimport os\nimport re\n\nfrom setuptools import find_packages, setup\nfrom setuptools.command.install import install\n\nwith open(\"consul/__init__.py\", encoding=\"utf-8\") as f:\n    metadata = dict(re.findall('__([a-z]+)__ = \"([^\"]+)\"', f.read()))\n\ndef _read_reqs(relpath: str):\n    fullpath = os.path.join(os.path.dirname(__file__), relpath)\n    with open(fullpath, encoding=\"utf-8\") as f:\n        return [s.strip() for s in f.readlines() if (s.strip() and not s.startswith(\"#\"))]\n\ndescription = \"Python client for Consul (http://www.consul.io/)\"\n\npy_modules = [os.path.splitext(x)[0] for x in glob.glob(\"consul/*.py\")]\n\nclass Install(install):\n    def run(self):\n        install.run(self)\n\nwith open(\"README.md\", encoding=\"utf-8\") as f1, open(\"CHANGELOG.md\", encoding=\"utf-8\") as f2:\n    long_description = f\"{f1.read()}\\n\\n{f2.read()}\"\n\nsetup(\n    name=\"py-consul\",\n    version=metadata[\"version\"],\n    author=\"Criteo\",\n    author_email=\"github@criteo.com\",\n    url=\"https://github.com/criteo-forks/py-consul\",\n    license=\"MIT\",\n    description=description,\n    description_content_type=\"text/markdown\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    py_modules=py_modules,\n    install_requires=_read_reqs(\"requirements.txt\"),\n    extras_require={\n        \"asyncio\": [\"aiohttp\"],\n    },\n    data_files=[(\".\", [\"requirements.txt\", \"tests-requirements.txt\"])],\n    packages=find_packages(exclude=[\"tests*\"]),\n    tests_require=_read_reqs(\"tests-requirements.txt\"),\n    cmdclass={\"install\": Install},\n    classifiers=[\n        \"Development Status :: 3 - Alpha\",\n        \"Intended Audience :: Developers\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.12\",\n        \"Programming Language :: Python :: 3.13\",\n    ],\n)\n",
          "hash_value": "5001c0401328162b71d1b3b2bf571c57",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import glob\nimport os\nimport re\n\nfrom setuptools import find_packages, setup\nfrom setuptools.command.install import install\n\nwith open(\"consul/__init__.py\", encoding=\"utf-8\") as f:\n    metadata = dict(re.findall('__([a-z]+)__ = \"([^\"]+)\"', f.read()))\n\ndef _read_reqs(relpath: str):\n    fullpath = os.path.join(os.path.dirname(__file__), relpath)\n    with open(fullpath, encoding=\"utf-8\") as f:\n        return [s.strip() for s in f.readlines() if (s.strip() and not s.startswith(\"#\"))]\n\ndescription = \"Python client for Consul (http://www.consul.io/)\"\n\npy_modules = [os.path.splitext(x)[0] for x in glob.glob(\"consul/*.py\")]\n\nclass Install(install):\n    def run(self):\n        install.run(self)\n\nwith open(\"README.md\", encoding=\"utf-8\") as f1, open(\"CHANGELOG.md\", encoding=\"utf-8\") as f2:\n    long_description = f\"{f1.read()}\\n\\n{f2.read()}\"\n\nsetup(\n    name=\"py-consul\",\n    version=metadata[\"version\"],\n    author=\"Criteo\",\n    author_email=\"github@criteo.com\",\n    url=\"https://github.com/criteo-forks/py-consul\",\n    license=\"MIT\",\n    description=description,\n    description_content_type=\"text/markdown\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    py_modules=py_modules,\n    install_requires=_read_reqs(\"requirements.txt\"),\n    extras_require={\n        \"asyncio\": [\"aiohttp\"],\n    },\n    data_files=[(\".\", [\"requirements.txt\", \"tests-requirements.txt\"])],\n    packages=find_packages(exclude=[\"tests*\"]),\n    tests_require=_read_reqs(\"tests-requirements.txt\"),\n    cmdclass={\"install\": Install},\n    classifiers=[\n        \"Development Status :: 3 - Alpha\",\n        \"Intended Audience :: Developers\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.12\",\n        \"Programming Language :: Python :: 3.13\",\n    ],\n)\n",
              "triple_sequences": [
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "consul/__init__.py",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "re.findall()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "'__([a-z]+)__ = \"([^\"]+)\"', f.read()",
                  "object_description": "Regex file content",
                  "object_id": "regex_file_content",
                  "intention_description": "Extract structured file data",
                  "intention_id": "extract_structured_file_data"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.dirname(__file__), relpath",
                  "object_description": "Directory path with file",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "fullpath",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "f.readlines()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "os.path.splitext()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "x",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Prepare path for file operations",
                  "intention_id": "prepare_path_file_operations"
                },
                {
                  "action_api": "glob.glob()",
                  "action_description": "List directory contents",
                  "action_id": "list_directory_contents",
                  "object": "consul/*.py",
                  "object_description": "Directory path with file",
                  "object_id": "directory_path_with_file",
                  "intention_description": "List files in directory",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "README.md",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "CHANGELOG.md",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "f1.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "f2.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "find_packages()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "exclude=[\"tests*\"]",
                  "object_description": "Regex pattern",
                  "object_id": "regex_pattern",
                  "intention_description": "Browser profile detection preparation",
                  "intention_id": "browser_profile_detection_preparation"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "name=\"py-consul\", version=metadata[\"version\"], ...",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Trigger main behavioral logic",
                  "intention_id": "trigger_main_behavioral_logic"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "runpod-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/runpod-1.7.9.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "graphql.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/runpod-1.7.9/runpod-1.7.9/runpod/api/graphql.py",
          "line_number": "33",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "import json\nimport os\nfrom typing import Any, Dict\n\nimport requests\n\nfrom runpod import error\nfrom runpod.user_agent import USER_AGENT\n\nHTTP_STATUS_UNAUTHORIZED = 401\n\n\ndef run_graphql_query(query: str) -> Dict[str, Any]:\n    \"\"\"\n    Run a GraphQL query\n    \"\"\"\n    from runpod import api_key  # pylint: disable=import-outside-toplevel, cyclic-import\n\n    api_url_base = os.environ.get(\"RUNPOD_API_BASE_URL\", \"https://api.runpod.io\")\n    url = f\"{api_url_base}/graphql\"\n\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": USER_AGENT,\n        \"Authorization\": f\"Bearer {api_key}\",\n    }\n\n    data = json.dumps({\"query\": query})\n    response = requests.post(url, headers=headers, data=data, timeout=30)\n\n    if response.status_code == HTTP_STATUS_UNAUTHORIZED:\n        raise error.AuthenticationError(\n            \"Unauthorized request, please check your API key.\"\n        )\n\n    if \"errors\" in response.json():\n        raise error.QueryError(response.json()[\"errors\"][0][\"message\"], query)\n\n    return response.json()",
          "hash_value": "ac56a545c554054ee81f8d2381ea2096",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import json\nimport os\nfrom typing import Any, Dict\n\nimport requests\n\nfrom runpod import error\nfrom runpod.user_agent import USER_AGENT\n\nHTTP_STATUS_UNAUTHORIZED = 401\n\n\ndef run_graphql_query(query: str) -> Dict[str, Any]:\n    \"\"\"\n    Run a GraphQL query\n    \"\"\"\n    from runpod import api_key  # pylint: disable=import-outside-toplevel, cyclic-import\n\n    api_url_base = os.environ.get(\"RUNPOD_API_BASE_URL\", \"https://api.runpod.io\")\n    url = f\"{api_url_base}/graphql\"\n\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": USER_AGENT,\n        \"Authorization\": f\"Bearer {api_key}\",\n    }\n\n    data = json.dumps({\"query\": query})\n    response = requests.post(url, headers=headers, data=data, timeout=30)\n\n    if response.status_code == HTTP_STATUS_UNAUTHORIZED:\n        raise error.AuthenticationError(\n            \"Unauthorized request, please check your API key.\"\n        )\n\n    if \"errors\" in response.json():\n        raise error.QueryError(response.json()[\"errors\"][0][\"message\"], query)\n\n    return response.json()",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "RUNPOD_API_BASE_URL",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "json.dumps()",
                  "action_description": "Serializes Python object to JSON string",
                  "action_id": "serialize_to_json",
                  "object": "{\"query\": query}",
                  "object_description": "JSON string",
                  "object_id": "json_string",
                  "intention_description": "Serialize data",
                  "intention_id": "serialize_data"
                },
                {
                  "action_api": "requests.post()",
                  "action_description": "Opens URL with POST data",
                  "action_id": "open_url_post",
                  "object": "url, headers=headers, data=data, timeout=30",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Transmit encoded data via HTTP POST",
                  "intention_id": "transmit_data_http_post"
                },
                {
                  "action_api": "response.status_code",
                  "action_description": "Retrieves HTTP response status code",
                  "action_id": "get_http_status",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "response.json()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "raise error.AuthenticationError()",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "\"Unauthorized request, please check your API key.\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                },
                {
                  "action_api": "raise error.QueryError()",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "response.json()[\"errors\"][0][\"message\"], query",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pyroute2-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyroute2-0.9.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "__init__.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyroute2-0.9.1/pyroute2-0.9.1/pyroute2/plan9/__init__.py",
          "line_number": "419",
          "type_description": "obfuscation",
          "context_snippet": "import builtins\nimport json\n\nclass Plan9Exit(Exception):\n    pass\n\ndef parse(self, data, seq=None, callback=None, skip_alien_seq=False):\n    offset = 0\n    while offset <= len(data) - 5:\n        (length, key, tag) = struct.unpack_from('=IBH', data, offset)\n        if skip_alien_seq and tag != seq:\n            continue\n        if not 0 < length <= len(data):\n            break\n        parser = self.get_parser(key, 0, tag)\n        msg = parser(data, offset, length)\n        if key == Rerror:\n            spec = json.loads(msg['ename'])\n            if spec['class'] in dir(builtins):\n                cls = getattr(builtins, spec['class'])\n            elif spec['class'] == 'Plan9Exit':\n                cls = Plan9Exit\n            else:\n                cls = Exception\n            if not spec.get('argv'):\n                spec['argv'] = [spec['str']]\n            raise cls(*spec['argv'])\n        offset += length\n        if msg is None:\n            continue\n        yield msg",
          "hash_value": "5e5a7b7565c7f4edad3bb8f61872f579",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import builtins\nimport json\n\nclass Plan9Exit(Exception):\n    pass\n\ndef parse(self, data, seq=None, callback=None, skip_alien_seq=False):\n    offset = 0\n    while offset <= len(data) - 5:\n        (length, key, tag) = struct.unpack_from('=IBH', data, offset)\n        if skip_alien_seq and tag != seq:\n            continue\n        if not 0 < length <= len(data):\n            break\n        parser = self.get_parser(key, 0, tag)\n        msg = parser(data, offset, length)\n        if key == Rerror:\n            spec = json.loads(msg['ename'])\n            if spec['class'] in dir(builtins):\n                cls = getattr(builtins, spec['class'])\n            elif spec['class'] == 'Plan9Exit':\n                cls = Plan9Exit\n            else:\n                cls = Exception\n            if not spec.get('argv'):\n                spec['argv'] = [spec['str']]\n            raise cls(*spec['argv'])\n        offset += length\n        if msg is None:\n            continue\n        yield msg",
              "triple_sequences": [
                {
                  "action_api": "struct.unpack_from()",
                  "action_description": "Packs values into bytes using specified format",
                  "action_id": "pack_values",
                  "object": "'=IBH', data, offset",
                  "object_description": "Encoded string to bytes",
                  "object_id": "encoded_string_bytes",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "self.get_parser()",
                  "action_description": "Import module dynamically",
                  "action_id": "import_dynamic",
                  "object": "key, 0, tag",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "parser()",
                  "action_description": "Deserialize Python object from bytes",
                  "action_id": "deserialize_from_bytes",
                  "object": "data, offset, length",
                  "object_description": "Decompressed data",
                  "object_id": "decompressed_data",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "json.loads()",
                  "action_description": "Deserializes JSON string to Python object",
                  "action_id": "deserialize_from_json",
                  "object": "msg['ename']",
                  "object_description": "JSON string",
                  "object_id": "json_string",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "dir()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Access attribute value",
                  "action_id": "set_builtin_attr",
                  "object": "builtins, spec['class']",
                  "object_description": "Attribute value",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "raise cls(*spec['argv'])",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "cls(*spec['argv'])",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "hydra_core-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/hydra_core-1.4.0.dev1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/hydra_core-1.4.0.dev1/hydra_core-1.4.0.dev1/setup.py",
          "line_number": "26",
          "type_description": "cmd-overwrite",
          "context_snippet": "import pathlib\n\nimport pkg_resources\nfrom setuptools import find_namespace_packages, setup\n\nfrom build_helpers.build_helpers import (\n    ANTLRCommand,\n    BuildPyCommand,\n    CleanCommand,\n    Develop,\n    SDistCommand,\n    find_version,\n)\n\nwith pathlib.Path(\"requirements/requirements.txt\").open() as requirements_txt:\n    install_requires = [\n        str(requirement)\n        for requirement in pkg_resources.parse_requirements(requirements_txt)\n    ]\n\n\nwith open(\"README.md\") as fh:\n    LONG_DESC = fh.read()\n    setup(\n        cmdclass={\n            \"antlr\": ANTLRCommand,\n            \"clean\": CleanCommand,\n            \"sdist\": SDistCommand,\n            \"build_py\": BuildPyCommand,\n            \"develop\": Develop,\n        },\n        name=\"hydra-core\",\n        version=find_version(\"hydra\", \"__init__.py\"),\n        author=\"Omry Yadan\",\n        author_email=\"omry@fb.com\",\n        description=\"A framework for elegantly configuring complex applications\",\n        license=\"MIT\",\n        long_description=LONG_DESC,\n        long_description_content_type=\"text/markdown\",\n        url=\"https://github.com/facebookresearch/hydra\",\n        keywords=\"command-line configuration yaml tab-completion\",\n        packages=find_namespace_packages(include=[\"hydra\", \"hydra.*\"]),\n        include_package_data=True,\n        classifiers=[\n            \"License :: OSI Approved :: MIT License\",\n            \"Development Status :: 4 - Beta\",\n            \"Programming Language :: Python :: 3.8\",\n            \"Programming Language :: Python :: 3.9\",\n            \"Programming Language :: Python :: 3.10\",\n            \"Programming Language :: Python :: 3.11\",\n            \"Operating System :: POSIX :: Linux\",\n            \"Operating System :: MacOS\",\n            \"Operating System :: Microsoft :: Windows\",\n        ],\n        install_requires=install_requires,\n        entry_points={\"pytest11\": [\"hydra_pytest = hydra.extra.pytest_plugin\"]},\n        # Install development dependencies with\n        # pip install -r requirements/dev.txt -e .\n    )",
          "hash_value": "3607c178c1dc1ad5a165f629429d6b59",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import pathlib\n\nimport pkg_resources\nfrom setuptools import find_namespace_packages, setup\n\nfrom build_helpers.build_helpers import (\n    ANTLRCommand,\n    BuildPyCommand,\n    CleanCommand,\n    Develop,\n    SDistCommand,\n    find_version,\n)\n\nwith pathlib.Path(\"requirements/requirements.txt\").open() as requirements_txt:\n    install_requires = [\n        str(requirement)\n        for requirement in pkg_resources.parse_requirements(requirements_txt)\n    ]\n\n\nwith open(\"README.md\") as fh:\n    LONG_DESC = fh.read()\n    setup(\n        cmdclass={\n            \"antlr\": ANTLRCommand,\n            \"clean\": CleanCommand,\n            \"sdist\": SDistCommand,\n            \"build_py\": BuildPyCommand,\n            \"develop\": Develop,\n        },\n        name=\"hydra-core\",\n        version=find_version(\"hydra\", \"__init__.py\"),\n        author=\"Omry Yadan\",\n        author_email=\"omry@fb.com\",\n        description=\"A framework for elegantly configuring complex applications\",\n        license=\"MIT\",\n        long_description=LONG_DESC,\n        long_description_content_type=\"text/markdown\",\n        url=\"https://github.com/facebookresearch/hydra\",\n        keywords=\"command-line configuration yaml tab-completion\",\n        packages=find_namespace_packages(include=[\"hydra\", \"hydra.*\"]),\n        include_package_data=True,\n        classifiers=[\n            \"License :: OSI Approved :: MIT License\",\n            \"Development Status :: 4 - Beta\",\n            \"Programming Language :: Python :: 3.8\",\n            \"Programming Language :: Python :: 3.9\",\n            \"Programming Language :: Python :: 3.10\",\n            \"Programming Language :: Python :: 3.11\",\n            \"Operating System :: POSIX :: Linux\",\n            \"Operating System :: MacOS\",\n            \"Operating System :: Microsoft :: Windows\",\n        ],\n        install_requires=install_requires,\n        entry_points={\"pytest11\": [\"hydra_pytest = hydra.extra.pytest_plugin\"]},\n        # Install development dependencies with\n        # pip install -r requirements/dev.txt -e .\n    )",
              "triple_sequences": [
                {
                  "action_api": "pathlib.Path().open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "requirements/requirements.txt",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "pkg_resources.parse_requirements()",
                  "action_description": "Parses string into requirements objects",
                  "action_id": "parse_datetime",
                  "object": "requirements_txt",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "README.md",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "cmdclass={...}, name=\"hydra-core\", version=find_version(\"hydra\", \"__init__.py\"), author=\"Omry Yadan\", author_email=\"omry@fb.com\", description=\"A framework for elegantly configuring complex applications\", license=\"MIT\", long_description=LONG_DESC, long_description_content_type=\"text/markdown\", url=\"https://github.com/facebookresearch/hydra\", keywords=\"command-line configuration yaml tab-completion\", packages=find_namespace_packages(include=[\"hydra\", \"hydra.*\"]), include_package_data=True, classifiers=[...], install_requires=install_requires, entry_points={\"pytest11\": [\"hydra_pytest = hydra.extra.pytest_plugin\"]}",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                },
                {
                  "action_api": "find_namespace_packages()",
                  "action_description": "Finds namespace packages for installation",
                  "action_id": "install_multiple_python_packages",
                  "object": "include=[\"hydra\", \"hydra.*\"]",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Install multiple Python packages",
                  "intention_id": "install_multiple_python_packages"
                },
                {
                  "action_api": "find_version()",
                  "action_description": "Retrieves operating system version",
                  "action_id": "get_os_version",
                  "object": "\"hydra\", \"__init__.py\"",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Get operating system version",
                  "intention_id": "get_operating_system_version"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "streamlit_extras-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/streamlit_extras-0.6.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "__init__.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/streamlit_extras-0.6.0/streamlit_extras-0.6.0/src/streamlit_extras/embed_code/__init__.py",
          "line_number": "54",
          "type_description": "shady-links",
          "context_snippet": "def example_pastebin(pastebin_snippet):\n    pastebin_snippet(\n        \"https://pastebin.com/8QZ7YjYD\",\n        width=700,\n        height=400,\n    )",
          "hash_value": "fa428ae6cbea1b7f9d59218384e1ebef",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def example_pastebin(pastebin_snippet):\n    pastebin_snippet(\n        \"https://pastebin.com/8QZ7YjYD\",\n        width=700,\n        height=400,\n    )",
              "triple_sequences": [
                {
                  "action_api": "pastebin_snippet()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "https://pastebin.com/8QZ7YjYD",
                  "object_description": "Paste service URL",
                  "object_id": "paste_service_url",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pglast-7",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pglast-7.7.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pglast-7.7/pglast-7.7/setup.py",
          "line_number": "35",
          "type_description": "code-execution",
          "context_snippet": "from pathlib import Path\nimport subprocess\nimport sys\n\nLIBPG_QUERY_DIR = here / 'libpg_query'\n\nclass BuildLibPgQueryFirst(build_ext):\n    def run(self):\n        if sys.platform == 'win32':\n            make = ['nmake', '/F', 'Makefile.msvc', 'build']\n        else:\n            make = ['make', '-s', 'build']\n        subprocess.check_call(make, cwd=LIBPG_QUERY_DIR)\n        super().run()",
          "hash_value": "dc02c197ca6ffda1c2d5a74df1d7989b",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from pathlib import Path\nimport subprocess\nimport sys\n\nLIBPG_QUERY_DIR = here / 'libpg_query'\n\nclass BuildLibPgQueryFirst(build_ext):\n    def run(self):\n        if sys.platform == 'win32':\n            make = ['nmake', '/F', 'Makefile.msvc', 'build']\n        else:\n            make = ['make', '-s', 'build']\n        subprocess.check_call(make, cwd=LIBPG_QUERY_DIR)\n        super().run()",
              "triple_sequences": [
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "['make', '-s', 'build']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "kcli-99",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/kcli-99.0.202504101850.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "__init__.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/kcli-99.0.202504101850/kcli-99.0.202504101850/kvirt/providers/ibm/__init__.py",
          "line_number": "29",
          "type_description": "shady-links",
          "context_snippet": "def get_s3_endpoint(region):\n    return f'https://s3.{region}.cloud-object-storage.appdomain.cloud'",
          "hash_value": "8e8147067898a42040f4b0e35654c298",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def get_s3_endpoint(region):\n    return f'https://s3.{region}.cloud-object-storage.appdomain.cloud'",
              "triple_sequences": [
                {
                  "action_api": "get_s3_endpoint()",
                  "action_description": "Constructs file or directory path",
                  "action_id": "path_string_operations",
                  "object": "f'https://s3.{region}.cloud-object-storage.appdomain.cloud'",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Prepare URL for HTTP request",
                  "intention_id": "prepare_url_http_request"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "social_auth_core-4",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/social_auth_core-4.5.6.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "discord.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/social_auth_core-4.5.6/social_auth_core-4.5.6/social_core/backends/discord.py",
          "line_number": "11",
          "type_description": "shady-links",
          "context_snippet": "class DiscordOAuth2(BaseOAuth2):\n    name = \"discord\"\n    HOSTNAME = \"discord.com\"\n    AUTHORIZATION_URL = f\"https://{HOSTNAME}/api/oauth2/authorize\"\n    ACCESS_TOKEN_URL = f\"https://{HOSTNAME}/api/oauth2/token\"\n    ACCESS_TOKEN_METHOD = \"POST\"\n    REVOKE_TOKEN_URL = f\"https://{HOSTNAME}/api/oauth2/token/revoke\"\n    REVOKE_TOKEN_METHOD = \"GET\"\n    DEFAULT_SCOPE = [\"identify\"]\n    SCOPE_SEPARATOR = \"+\"\n    REDIRECT_STATE = False\n    EXTRA_DATA = [(\"expires_in\", \"expires\"), (\"refresh_token\", \"refresh_token\")]",
          "hash_value": "41c4c5df19a4b22ebb5a5622ca22d913",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class DiscordOAuth2(BaseOAuth2):\n    name = \"discord\"\n    HOSTNAME = \"discord.com\"\n    AUTHORIZATION_URL = f\"https://{HOSTNAME}/api/oauth2/authorize\"\n    ACCESS_TOKEN_URL = f\"https://{HOSTNAME}/api/oauth2/token\"\n    ACCESS_TOKEN_METHOD = \"POST\"\n    REVOKE_TOKEN_URL = f\"https://{HOSTNAME}/api/oauth2/token/revoke\"\n    REVOKE_TOKEN_METHOD = \"GET\"\n    DEFAULT_SCOPE = [\"identify\"]\n    SCOPE_SEPARATOR = \"+\"\n    REDIRECT_STATE = False\n    EXTRA_DATA = [(\"expires_in\", \"expires\"), (\"refresh_token\", \"refresh_token\")]",
              "triple_sequences": [
                {
                  "action_api": "f\"https://{HOSTNAME}/api/oauth2/authorize\"",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "https://discord.com/api/oauth2/authorize",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Prepare URL for HTTP request",
                  "intention_id": "prepare_url_http_request"
                },
                {
                  "action_api": "f\"https://{HOSTNAME}/api/oauth2/token\"",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "https://discord.com/api/oauth2/token",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Prepare URL for HTTP request",
                  "intention_id": "prepare_url_http_request"
                },
                {
                  "action_api": "f\"https://{HOSTNAME}/api/oauth2/token/revoke\"",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "https://discord.com/api/oauth2/token/revoke",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Prepare URL for HTTP request",
                  "intention_id": "prepare_url_http_request"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pyxcp-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyxcp-0.22.28.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyxcp-0.22.28/pyxcp-0.22.28/pyxcp/recorder/setup.py",
          "line_number": "15",
          "type_description": "code-execution",
          "context_snippet": "import subprocess  # nosec\nfrom distutils.core import setup\n\nfrom pybind11.setup_helpers import (\n    ParallelCompile,\n    Pybind11Extension,\n    build_ext,\n    naive_recompile,\n)\n\n\n# ParallelCompile(\"NPY_NUM_BUILD_JOBS\").install()\nParallelCompile(\"NPY_NUM_BUILD_JOBS\", needs_recompile=naive_recompile).install()\n\nINCLUDE_DIRS = subprocess.getoutput(\"pybind11-config --include\")  # nosec\n\n# os.environ [\"CFLAGS\"] = ''\n\nPKG_NAME = \"rekorder_test\"\next_NAMES = [\"rekorder\"]\n__version__ = \"0.0.1\"\n\next_modules = [\n    Pybind11Extension(\n        EXT_NAMES[0],\n        include_dirs=[INCLUDE_DIRS],\n        sources=[\"lz4.c\", \"wrap.cpp\"],\n        define_macros=[(\"EXTENSION_NAME\", EXT_NAMES[0])],\n        cxx_std=20,  # Extension will use C++20 generators/coroutines.\n    ),\n]\n\nsetup(\n    name=PKG_NAME,\n    version=\"0.0.1\",\n    author=\"John Doe\",\n    description=\"Example\",\n    ext_modules=ext_modules,\n    cmdclass={\"build_ext\": build_ext},\n    zip_save=False,\n)\n",
          "hash_value": "8d53f39d05cec4ea3c922d3ad3bbc961",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import subprocess  # nosec\nfrom distutils.core import setup\n\nfrom pybind11.setup_helpers import (\n    ParallelCompile,\n    Pybind11Extension,\n    build_ext,\n    naive_recompile,\n)\n\n\n# ParallelCompile(\"NPY_NUM_BUILD_JOBS\").install()\nParallelCompile(\"NPY_NUM_BUILD_JOBS\", needs_recompile=naive_recompile).install()\n\nINCLUDE_DIRS = subprocess.getoutput(\"pybind11-config --include\")  # nosec\n\n# os.environ [\"CFLAGS\"] = ''\n\nPKG_NAME = \"rekorder_test\"\next_NAMES = [\"rekorder\"]\n__version__ = \"0.0.1\"\n\next_modules = [\n    Pybind11Extension(\n        EXT_NAMES[0],\n        include_dirs=[INCLUDE_DIRS],\n        sources=[\"lz4.c\", \"wrap.cpp\"],\n        define_macros=[(\"EXTENSION_NAME\", EXT_NAMES[0])],\n        cxx_std=20,  # Extension will use C++20 generators/coroutines.\n    ),\n]\n\nsetup(\n    name=PKG_NAME,\n    version=\"0.0.1\",\n    author=\"John Doe\",\n    description=\"Example\",\n    ext_modules=ext_modules,\n    cmdclass={\"build_ext\": build_ext},\n    zip_save=False,\n)\n",
              "triple_sequences": [
                {
                  "action_api": "ParallelCompile().install()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "ParallelCompile(\"NPY_NUM_BUILD_JOBS\", needs_recompile=naive_recompile)",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                },
                {
                  "action_api": "subprocess.getoutput()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "pybind11-config --include",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "Pybind11Extension()",
                  "action_description": "Instantiates Browser class",
                  "action_id": "init_browser_class",
                  "object": "EXT_NAMES[0], include_dirs=[INCLUDE_DIRS], sources=[\"lz4.c\", \"wrap.cpp\"], define_macros=[(\"EXTENSION_NAME\", EXT_NAMES[0])], cxx_std=20",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "name=PKG_NAME, version=\"0.0.1\", author=\"John Doe\", description=\"Example\", ext_modules=ext_modules, cmdclass={\"build_ext\": build_ext}, zip_save=False",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "healpy-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/healpy-1.18.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/healpy-1.18.1/healpy-1.18.1/setup.py",
          "line_number": "91",
          "type_description": "code-execution",
          "context_snippet": "    def pkgconfig(self, *packages):\n        env = self.env()\n        PKG_CONFIG = tuple(shlex.split(env[\"PKG_CONFIG\"], posix=(os.sep == \"/\")))\n        kw = {}\n        index_key_flag = (\n            (2, \"--cflags-only-I\", (\"include_dirs\",)),\n            (0, \"--cflags-only-other\", (\"extra_compile_args\", \"extra_link_args\")),\n            (2, \"--libs-only-L\", (\"library_dirs\", \"runtime_library_dirs\")),\n            (2, \"--libs-only-l\", (\"libraries\",)),\n            (0, \"--libs-only-other\", (\"extra_link_args\",)),\n        )\n        for index, flag, keys in index_key_flag:\n            cmd = PKG_CONFIG + (flag,) + tuple(packages)\n            log.debug(\"%s\", \" \".join(cmd))\n            args = [\n                token[index:].decode() for token in check_output(cmd, env=env).split()\n            ]\n            if args:\n                for key in keys:\n                    kw.setdefault(key, []).extend(args)\n        return kw",
          "hash_value": "6f2228e735c054e012dc7e3d10215e13",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "    def pkgconfig(self, *packages):\n        env = self.env()\n        PKG_CONFIG = tuple(shlex.split(env[\"PKG_CONFIG\"], posix=(os.sep == \"/\")))\n        kw = {}\n        index_key_flag = (\n            (2, \"--cflags-only-I\", (\"include_dirs\",)),\n            (0, \"--cflags-only-other\", (\"extra_compile_args\", \"extra_link_args\")),\n            (2, \"--libs-only-L\", (\"library_dirs\", \"runtime_library_dirs\")),\n            (2, \"--libs-only-l\", (\"libraries\",)),\n            (0, \"--libs-only-other\", (\"extra_link_args\",)),\n        )\n        for index, flag, keys in index_key_flag:\n            cmd = PKG_CONFIG + (flag,) + tuple(packages)\n            log.debug(\"%s\", \" \".join(cmd))\n            args = [\n                token[index:].decode() for token in check_output(cmd, env=env).split()\n            ]\n            if args:\n                for key in keys:\n                    kw.setdefault(key, []).extend(args)\n        return kw",
              "triple_sequences": [
                {
                  "action_api": "self.env()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "shlex.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "env[\"PKG_CONFIG\"]",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "os.sep",
                  "action_description": "Retrieves operating system path separator",
                  "action_id": "get_os_path_sep",
                  "object": "",
                  "object_description": "Directory path separator",
                  "object_id": "directory_separator",
                  "intention_description": "Determine operating system",
                  "intention_id": "determine_operating_system"
                },
                {
                  "action_api": "log.debug()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "\"%s\", \" \".join(cmd)",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "cmd, env=env",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "bytes.split()",
                  "action_description": "Basic read operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "bytes.decode()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "token[index:]",
                  "object_description": "Encoded string to bytes",
                  "object_id": "encoded_string_bytes",
                  "intention_description": "Decode bytes to string",
                  "intention_id": "decode_bytes_to_string"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "swarms-7",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/swarms-7.6.7.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "main.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/swarms-7.6.7/swarms-7.6.7/swarms/telemetry/main.py",
          "line_number": "257",
          "type_description": "shady-links",
          "context_snippet": "import requests\nimport platform\nimport socket\nimport psutil\nimport uuid\n\ndef capture_system_data() -> Dict[str, str]:\n    \"\"\"\n    Captures extensive system data including platform information, user ID, IP address, CPU count,\n    memory information, and other system details.\n\n    Returns:\n        Dict[str, str]: A dictionary containing system data.\n    \"\"\"\n    try:\n        system_data = {\n            \"platform\": platform.system(),\n            \"platform_version\": platform.version(),\n            \"platform_release\": platform.release(),\n            \"hostname\": socket.gethostname(),\n            \"ip_address\": socket.gethostbyname(socket.gethostname()),\n            \"cpu_count\": psutil.cpu_count(logical=True),\n            \"memory_total\": f\"{psutil.virtual_memory().total / (1024 ** 3):.2f} GB\",\n            \"memory_available\": f\"{psutil.virtual_memory().available / (1024 ** 3):.2f} GB\",\n            \"user_id\": str(uuid.uuid4()),  # Unique user identifier\n            \"machine_type\": platform.machine(),\n            \"processor\": platform.processor(),\n            \"architecture\": platform.architecture()[0],\n        }\n\n        # Get external IP address\n        try:\n            system_data[\"external_ip\"] = requests.get(\n                \"https://api.ipify.org\"\n            ).text\n        except Exception:\n            system_data[\"external_ip\"] = \"N/A\"\n\n        return system_data\n    except Exception as e:\n        # logger.error(\"Failed to capture system data: {}\", e)\n        print(f\"Failed to capture system data: {e}\")\n        return {}",
          "hash_value": "19d11de1c20c265d882046200edf0d52",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import requests\nimport platform\nimport socket\nimport psutil\nimport uuid\n\ndef capture_system_data() -> Dict[str, str]:\n    \"\"\"\n    Captures extensive system data including platform information, user ID, IP address, CPU count,\n    memory information, and other system details.\n\n    Returns:\n        Dict[str, str]: A dictionary containing system data.\n    \"\"\"\n    try:\n        system_data = {\n            \"platform\": platform.system(),\n            \"platform_version\": platform.version(),\n            \"platform_release\": platform.release(),\n            \"hostname\": socket.gethostname(),\n            \"ip_address\": socket.gethostbyname(socket.gethostname()),\n            \"cpu_count\": psutil.cpu_count(logical=True),\n            \"memory_total\": f\"{psutil.virtual_memory().total / (1024 ** 3):.2f} GB\",\n            \"memory_available\": f\"{psutil.virtual_memory().available / (1024 ** 3):.2f} GB\",\n            \"user_id\": str(uuid.uuid4()),  # Unique user identifier\n            \"machine_type\": platform.machine(),\n            \"processor\": platform.processor(),\n            \"architecture\": platform.architecture()[0],\n        }\n\n        # Get external IP address\n        try:\n            system_data[\"external_ip\"] = requests.get(\n                \"https://api.ipify.org\"\n            ).text\n        except Exception:\n            system_data[\"external_ip\"] = \"N/A\"\n\n        return system_data\n    except Exception as e:\n        # logger.error(\"Failed to capture system data: {}\", e)\n        print(f\"Failed to capture system data: {e}\")\n        return {}",
              "triple_sequences": [
                {
                  "action_api": "platform.system()",
                  "action_description": "Retrieves operating system identifier",
                  "action_id": "get_os_id",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get operating system name",
                  "intention_id": "get_operating_system_name"
                },
                {
                  "action_api": "platform.version()",
                  "action_description": "Retrieves operating system version",
                  "action_id": "get_os_version",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get operating system version",
                  "intention_id": "get_operating_system_version"
                },
                {
                  "action_api": "platform.release()",
                  "action_description": "Retrieves operating system release version",
                  "action_id": "get_os_release",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get operating system name",
                  "intention_id": "get_operating_system_name"
                },
                {
                  "action_api": "socket.gethostname()",
                  "action_description": "Retrieves current host name",
                  "action_id": "get_hostname",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get system hostname",
                  "intention_id": "get_system_hostname"
                },
                {
                  "action_api": "socket.gethostbyname()",
                  "action_description": "Resolves host name to IPv4 address",
                  "action_id": "resolve_hostname",
                  "object": "socket.gethostname()",
                  "object_description": "System hostname",
                  "object_id": "system_hostname",
                  "intention_description": "Extract public IP address",
                  "intention_id": "extract_public_ip_address"
                },
                {
                  "action_api": "psutil.cpu_count()",
                  "action_description": "Retrieves processor name",
                  "action_id": "get_processor_name",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get system info",
                  "intention_id": "get_system_info"
                },
                {
                  "action_api": "psutil.virtual_memory()",
                  "action_description": "Retrieves system virtual memory statistics",
                  "action_id": "get_virtual_memory",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get system info",
                  "intention_id": "get_system_info"
                },
                {
                  "action_api": "uuid.uuid4()",
                  "action_description": "Retrieves hardware address as 48-bit integer",
                  "action_id": "get_hardware_address",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get hardware UUID",
                  "intention_id": "get_hardware_uuid"
                },
                {
                  "action_api": "platform.machine()",
                  "action_description": "Retrieves machine type",
                  "action_id": "get_machine_type",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get system info",
                  "intention_id": "get_system_info"
                },
                {
                  "action_api": "platform.processor()",
                  "action_description": "Retrieves processor name",
                  "action_id": "get_processor_name",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get system info",
                  "intention_id": "get_system_info"
                },
                {
                  "action_api": "platform.architecture()",
                  "action_description": "Retrieves platform information",
                  "action_id": "get_platform_info",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get system info",
                  "intention_id": "get_system_info"
                },
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "https://api.ipify.org",
                  "object_description": "External domain",
                  "object_id": "external_domain",
                  "intention_description": "Extract public IP address",
                  "intention_id": "extract_public_ip_address"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "facexlib-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/facexlib-0.3.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/facexlib-0.3.0/facexlib-0.3.0/setup.py",
          "line_number": "31",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport subprocess\n\ndef get_git_hash():\n\n    def _minimal_ext_cmd(cmd):\n        # construct minimal environment\n        env = {}\n        for k in ['SYSTEMROOT', 'PATH', 'HOME']:\n            v = os.environ.get(k)\n            if v is not None:\n                env[k] = v\n        # LANGUAGE is used on win32\n        env['LANGUAGE'] = 'C'\n        env['LANG'] = 'C'\n        env['LC_ALL'] = 'C'\n        out = subprocess.Popen(cmd, stdout=subprocess.PIPE, env=env).communicate()[0]\n        return out\n\n    try:\n        out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])\n        sha = out.strip().decode('ascii')\n    except OSError:\n        sha = 'unknown'\n\n    return sha",
          "hash_value": "5c5f9a0ff3d27d1291d145856fd9122e",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport subprocess\n\ndef get_git_hash():\n\n    def _minimal_ext_cmd(cmd):\n        # construct minimal environment\n        env = {}\n        for k in ['SYSTEMROOT', 'PATH', 'HOME']:\n            v = os.environ.get(k)\n            if v is not None:\n                env[k] = v\n        # LANGUAGE is used on win32\n        env['LANGUAGE'] = 'C'\n        env['LANG'] = 'C'\n        env['LC_ALL'] = 'C'\n        out = subprocess.Popen(cmd, stdout=subprocess.PIPE, env=env).communicate()[0]\n        return out\n\n    try:\n        out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])\n        sha = out.strip().decode('ascii')\n    except OSError:\n        sha = 'unknown'\n\n    return sha",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "k",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "['git', 'rev-parse', 'HEAD']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "subprocess.Popen.communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "bytes.strip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "bytes.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "'ascii'",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "taskcluster-83",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/taskcluster-83.5.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "helper.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/taskcluster-83.5.1/taskcluster-83.5.1/taskcluster/helper.py",
          "line_number": "179",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "import os\nimport datetime\nfrom datetime import timezone\nimport logging\nimport requests\nfrom taskcluster.utils import stringDate\n\ndef upload_artifact(queue_service, artifact_path, content, content_type, ttl):\n    \"\"\"\n    DEPRECATED. Do not use.\n    \"\"\"\n    task_id = os.environ.get(\"TASK_ID\")\n    run_id = os.environ.get(\"RUN_ID\")\n    proxy = os.environ.get(\"TASKCLUSTER_PROXY_URL\")\n    assert task_id and run_id and proxy, \"Can only run in Taskcluster tasks with proxy\"\n    # Contet can be str or bytes\n    assert isinstance(content, str) or isinstance(content, bytes)\n    assert isinstance(ttl, datetime.timedelta)\n\n    # Create S3 artifact on Taskcluster\n    resp = queue_service.createArtifact(\n        task_id,\n        run_id,\n        artifact_path,\n        {\n            \"storageType\": \"s3\",\n            \"expires\": stringDate(datetime.datetime.now(timezone.utc) + ttl),\n            \"contentType\": content_type,\n        },\n    )\n    assert resp[\"storageType\"] == \"s3\", \"Not an s3 storage\"\n    assert \"putUrl\" in resp, \"Missing putUrl\"\n    assert \"contentType\" in resp, \"Missing contentType\"\n\n    # Push the artifact on storage service\n    headers = {\"Content-Type\": resp[\"contentType\"]}\n    push = requests.put(url=resp[\"putUrl\"], headers=headers, data=content)\n    push.raise_for_status()\n\n    # Build the absolute url\n    return \"/api/queue/v1/task/{task_id}/runs/{run_id}/artifacts/{path}\".format(\n        task_id=task_id,\n        run_id=run_id,\n        path=artifact_path,\n    )",
          "hash_value": "ce9a823e8add67e6fa3b34131698e60d",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport datetime\nfrom datetime import timezone\nimport logging\nimport requests\nfrom taskcluster.utils import stringDate\n\ndef upload_artifact(queue_service, artifact_path, content, content_type, ttl):\n    \"\"\"\n    DEPRECATED. Do not use.\n    \"\"\"\n    task_id = os.environ.get(\"TASK_ID\")\n    run_id = os.environ.get(\"RUN_ID\")\n    proxy = os.environ.get(\"TASKCLUSTER_PROXY_URL\")\n    assert task_id and run_id and proxy, \"Can only run in Taskcluster tasks with proxy\"\n    # Contet can be str or bytes\n    assert isinstance(content, str) or isinstance(content, bytes)\n    assert isinstance(ttl, datetime.timedelta)\n\n    # Create S3 artifact on Taskcluster\n    resp = queue_service.createArtifact(\n        task_id,\n        run_id,\n        artifact_path,\n        {\n            \"storageType\": \"s3\",\n            \"expires\": stringDate(datetime.datetime.now(timezone.utc) + ttl),\n            \"contentType\": content_type,\n        },\n    )\n    assert resp[\"storageType\"] == \"s3\", \"Not an s3 storage\"\n    assert \"putUrl\" in resp, \"Missing putUrl\"\n    assert \"contentType\" in resp, \"Missing contentType\"\n\n    # Push the artifact on storage service\n    headers = {\"Content-Type\": resp[\"contentType\"]}\n    push = requests.put(url=resp[\"putUrl\"], headers=headers, data=content)\n    push.raise_for_status()\n\n    # Build the absolute url\n    return \"/api/queue/v1/task/{task_id}/runs/{run_id}/artifacts/{path}\".format(\n        task_id=task_id,\n        run_id=run_id,\n        path=artifact_path,\n    )",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"TASK_ID\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"RUN_ID\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"TASKCLUSTER_PROXY_URL\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "queue_service.createArtifact()",
                  "action_description": "Creates new ZIP archive for writing",
                  "action_id": "create_zip_archive",
                  "object": "task_id, run_id, artifact_path, {\"storageType\": \"s3\", \"expires\": stringDate(datetime.datetime.now(timezone.utc) + ttl), \"contentType\": content_type}",
                  "object_description": "Structured file data",
                  "object_id": "structured_file_data",
                  "intention_description": "Create zip archive",
                  "intention_id": "create_zip_archive"
                },
                {
                  "action_api": "stringDate()",
                  "action_description": "Parses string into datetime object",
                  "action_id": "parse_datetime",
                  "object": "datetime.datetime.now(timezone.utc) + ttl",
                  "object_description": "Delay duration in seconds",
                  "object_id": "delay_duration",
                  "intention_description": "Get datetime epoch",
                  "intention_id": "get_datetime_epoch"
                },
                {
                  "action_api": "requests.put()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "url=resp[\"putUrl\"], headers=headers, data=content",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Transmit file data to server",
                  "intention_id": "transmit_file_data_server"
                },
                {
                  "action_api": "push.raise_for_status()",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                },
                {
                  "action_api": "str.format()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "\"/api/queue/v1/task/{task_id}/runs/{run_id}/artifacts/{path}\".format(task_id=task_id, run_id=run_id, path=artifact_path)",
                  "object_description": "URL string",
                  "object_id": "url_string",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pysam-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pysam-0.23.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pysam-0.23.0/pysam-0.23.0/setup.py",
          "line_number": "64",
          "type_description": "code-execution",
          "context_snippet": "def run_configure(option):\n    sys.stdout.flush()\n    try:\n        retcode = subprocess.call(\n            \" \".join((\"./configure\", option)),\n            shell=True)\n        if retcode != 0:\n            return False\n        else:\n            return True\n    except OSError as e:\n        return False",
          "hash_value": "a3eca6c8ff3cfb9d023b736e4a6f2ea5",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def run_configure(option):\n    sys.stdout.flush()\n    try:\n        retcode = subprocess.call(\n            \" \".join((\"./configure\", option)),\n            shell=True)\n        if retcode != 0:\n            return False\n        else:\n            return True\n    except OSError as e:\n        return False",
              "triple_sequences": [
                {
                  "action_api": "sys.stdout.flush()",
                  "action_description": "Retrieves standard output stream object",
                  "action_id": "get_stdout_stream",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "subprocess.call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "./configure <option>",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "gevent-24",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/gevent-24.11.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "six.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/gevent/testing/six.py",
          "line_number": "9",
          "type_description": "obfuscation",
          "context_snippet": "import sys\n# pylint:disable=unused-argument,import-error\n\nPY2 = sys.version_info[0] == 2\nPY3 = sys.version_info[0] >= 3\n\nif PY3:\n    import builtins\n    exec_ = getattr(builtins, \"exec\")\n\n    def reraise(tp, value, tb=None):\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value\n\n    xrange = range\n    string_types = (str,)\n    text_type = str",
          "hash_value": "eeec8acc97a7523e6be3880b260980d7",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import sys\n# pylint:disable=unused-argument,import-error\n\nPY2 = sys.version_info[0] == 2\nPY3 = sys.version_info[0] >= 3\n\nif PY3:\n    import builtins\n    exec_ = getattr(builtins, \"exec\")\n\n    def reraise(tp, value, tb=None):\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value\n\n    xrange = range\n    string_types = (str,)\n    text_type = str",
              "triple_sequences": [
                {
                  "action_api": "sys.version_info",
                  "action_description": "Retrieves Python interpreter version",
                  "action_id": "get_python_version",
                  "object": "sys.version_info",
                  "object_description": "Python code string",
                  "object_id": "python_code_string",
                  "intention_description": "Determine operating system",
                  "intention_id": "determine_operating_system"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "builtins, \"exec\"",
                  "object_description": "Builtin module",
                  "object_id": "builtin_module",
                  "intention_description": "Modify builtins and execute code",
                  "intention_id": "modify_builtins_execute_code"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "guppy3-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/guppy3-3.1.5.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "Spec.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/guppy3-3.1.5/guppy3-3.1.5/guppy/heapy/Spec.py",
          "line_number": "1342",
          "type_description": "obfuscation",
          "context_snippet": "class wrap_lambdef:\n    def test(node, f):\n        # and_test ('or' and_test)* | lambdef\n        if len(node) == 2 and node[1][0] == symbol.lambdef:\n            lsource = recover_source(node[1])\n            lnode = mapchildren(node[1], f)\n\n            return (\n                292, (293, (294, (295, (297, (298, (299, (300, (301,\n                                                                (302, (303, (304, (305, (1, 'wrap_source_string')),\n                                                                             (308, (7, '('), (317, (318, (292, lnode)), (12, ','),\n                                                                                              (318, (292, (293, (294, (295, (297, (298, (299, (300,\n                                                                                                                                                   (301, (302, (303, (304, (305, (3, '%r' % lsource\n                                                                                                                                                                                      )))))))))))))))), (8, ')'))))))))))))))\n\n        return mapchildren(node, f)",
          "hash_value": "101bc0c21a3dc909042c48c8eb750d97",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class wrap_lambdef:\n    def test(node, f):\n        # and_test ('or' and_test)* | lambdef\n        if len(node) == 2 and node[1][0] == symbol.lambdef:\n            lsource = recover_source(node[1])\n            lnode = mapchildren(node[1], f)\n\n            return (\n                292, (293, (294, (295, (297, (298, (299, (300, (301,\n                                                                (302, (303, (304, (305, (1, 'wrap_source_string')),\n                                                                             (308, (7, '('), (317, (318, (292, lnode)), (12, ','),\n                                                                                              (318, (292, (293, (294, (295, (297, (298, (299, (300,\n                                                                                                                                                   (301, (302, (303, (304, (305, (3, '%r' % lsource\n                                                                                                                                                                                      )))))))))))))))), (8, ')'))))))))))))))\n\n        return mapchildren(node, f)",
              "triple_sequences": [
                {
                  "action_api": "recover_source()",
                  "action_description": "Retrieves file status",
                  "action_id": "path_object_operations",
                  "object": "node[1]",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access file content",
                  "intention_id": "access_file_content"
                },
                {
                  "action_api": "mapchildren()",
                  "action_description": "Creates new thread to execute",
                  "action_id": "create_thread",
                  "object": "node[1], f",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Run function in child process",
                  "intention_id": "run_function_child_process"
                },
                {
                  "action_api": "mapchildren()",
                  "action_description": "Creates new thread to execute",
                  "action_id": "create_thread",
                  "object": "node, f",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Run function in child process",
                  "intention_id": "run_function_child_process"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "depthai-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/depthai-2.30.0.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/depthai-2.30.0.0/depthai-2.30.0.0/setup.py",
          "line_number": "153",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport io\nimport re\nimport sys\nimport platform\nimport subprocess\nimport find_version\nimport multiprocessing\n\nclass CMakeBuild(build_ext):\n\n    def build_extension(self, ext):\n        ...\n        # Memcheck (guard if it fails)\n        freeMemory = 4000\n        if platform.system() == \"Linux\":\n            try:\n                freeMemory = int(os.popen(\"free -m\").readlines()[1].split()[6])\n            except (KeyboardInterrupt, SystemExit):\n                raise\n            except:\n                freeMemory = 4000\n        ...",
          "hash_value": "81ca0233859eede18e89619c4babf527",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport io\nimport re\nimport sys\nimport platform\nimport subprocess\nimport find_version\nimport multiprocessing\n\nclass CMakeBuild(build_ext):\n\n    def build_extension(self, ext):\n        ...\n        # Memcheck (guard if it fails)\n        freeMemory = 4000\n        if platform.system() == \"Linux\":\n            try:\n                freeMemory = int(os.popen(\"free -m\").readlines()[1].split()[6])\n            except (KeyboardInterrupt, SystemExit):\n                raise\n            except:\n                freeMemory = 4000\n        ...",
              "triple_sequences": [
                {
                  "action_api": "platform.system()",
                  "action_description": "Retrieves operating system identifier",
                  "action_id": "get_os_id",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine operating system",
                  "intention_id": "determine_operating_system"
                },
                {
                  "action_api": "os.popen()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "free -m",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "file.readlines()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "int()",
                  "action_description": "Converts integer to bytes with specified length and byte order",
                  "action_id": "convert_int_to_bytes",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Convert string to integer",
                  "intention_id": "convert_string_to_integer"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "apeye_core-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/apeye_core-1.1.5.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "__init__.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/apeye_core-1.1.5/apeye_core-1.1.5/apeye_core/__init__.py",
          "line_number": "771",
          "type_description": "shady-links",
          "context_snippet": "class Domain(NamedTuple):\n    \"\"\"\n    :class:`typing.NamedTuple` of a URL's subdomain, domain, and suffix.\n    \"\"\"\n\n    subdomain: str\n    domain: str\n    suffix: str\n\n    @property\n    def registered_domain(self):\n        \"\"\"\n        Joins the domain and suffix fields with a dot, if they're both set.\n\n        .. code-block:: python\n\n            >>> URL('https://forums.bbc.co.uk').domain.registered_domain\n            'bbc.co.uk'\n            >>> URL('https://localhost:8080').domain.registered_domain\n            ''\n        \"\"\"\n        if self.domain and self.suffix:\n            return self.domain + '.' + self.suffix\n        return ''\n\n    @property\n    def fqdn(self):\n        \"\"\"\n        Returns a Fully Qualified Domain Name, if there is a proper domain/suffix.\n\n        .. code-block:: python\n\n            >>> URL('https://forums.bbc.co.uk/path/to/file').domain.fqdn\n            'forums.bbc.co.uk'\n            >>> URL('https://localhost:8080').domain.fqdn\n            ''\n        \"\"\"\n        if self.domain and self.suffix:\n            # self is the namedtuple (subdomain domain suffix)\n            return '.'.join(i for i in self if i)\n        return ''\n\n    @property\n    def ipv4(self) -> Optional[ipaddress.IPv4Address]:\n        \"\"\"\n        Returns the ipv4 if that is what the presented domain/url is.\n\n        .. code-block:: python\n\n            >>> URL('https://127.0.0.1/path/to/file').domain.ipv4\n            IPv4Address('127.0.0.1')\n            >>> URL('https://127.0.0.1.1/path/to/file').domain.ipv4\n            >>> URL('https://256.1.1.1').domain.ipv4\n        \"\"\"\n\n        if not (self.suffix or self.subdomain) and _tld.IP_RE.match(self.domain):\n            return cast(ipaddress.IPv4Address, ipaddress.ip_address(self.domain))\n        return None\n\n    def __repr__(self) -> str:\n        \"\"\"\n        Return a string representation of the :class:`~.Domain`.\n        \"\"\"\n\n        # This is necessary to get the custom docstring\n\n        repr_fmt = f\"({', '.join(f'{name}=%r' for name in self._fields)})\"\n        return f\"{self.__class__.__name__}{repr_fmt % self}\"\n",
          "hash_value": "8df25c6dd061348b4218ba2c9fc297f6",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class Domain(NamedTuple):\n    \"\"\"\n    :class:`typing.NamedTuple` of a URL's subdomain, domain, and suffix.\n    \"\"\"\n\n    subdomain: str\n    domain: str\n    suffix: str\n\n    @property\n    def registered_domain(self):\n        \"\"\"\n        Joins the domain and suffix fields with a dot, if they're both set.\n\n        .. code-block:: python\n\n            >>> URL('https://forums.bbc.co.uk').domain.registered_domain\n            'bbc.co.uk'\n            >>> URL('https://localhost:8080').domain.registered_domain\n            ''\n        \"\"\"\n        if self.domain and self.suffix:\n            return self.domain + '.' + self.suffix\n        return ''\n\n    @property\n    def fqdn(self):\n        \"\"\"\n        Returns a Fully Qualified Domain Name, if there is a proper domain/suffix.\n\n        .. code-block:: python\n\n            >>> URL('https://forums.bbc.co.uk/path/to/file').domain.fqdn\n            'forums.bbc.co.uk'\n            >>> URL('https://localhost:8080').domain.fqdn\n            ''\n        \"\"\"\n        if self.domain and self.suffix:\n            # self is the namedtuple (subdomain domain suffix)\n            return '.'.join(i for i in self if i)\n        return ''\n\n    @property\n    def ipv4(self) -> Optional[ipaddress.IPv4Address]:\n        \"\"\"\n        Returns the ipv4 if that is what the presented domain/url is.\n\n        .. code-block:: python\n\n            >>> URL('https://127.0.0.1/path/to/file').domain.ipv4\n            IPv4Address('127.0.0.1')\n            >>> URL('https://127.0.0.1.1/path/to/file').domain.ipv4\n            >>> URL('https://256.1.1.1').domain.ipv4\n        \"\"\"\n\n        if not (self.suffix or self.subdomain) and _tld.IP_RE.match(self.domain):\n            return cast(ipaddress.IPv4Address, ipaddress.ip_address(self.domain))\n        return None\n\n    def __repr__(self) -> str:\n        \"\"\"\n        Return a string representation of the :class:`~.Domain`.\n        \"\"\"\n\n        # This is necessary to get the custom docstring\n\n        repr_fmt = f\"({', '.join(f'{name}=%r' for name in self._fields)})\"\n        return f\"{self.__class__.__name__}{repr_fmt % self}\"\n",
              "triple_sequences": [
                {
                  "action_api": "str.__add__()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "self.domain + '.' + self.suffix",
                  "object_description": "Domain name string",
                  "object_id": "domain_name",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "str.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "'.'.join(i for i in self if i)",
                  "object_description": "Domain name string",
                  "object_id": "domain_name",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "_tld.IP_RE.match()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "self.domain",
                  "object_description": "Domain name string",
                  "object_id": "domain_name",
                  "intention_description": "Detect cryptocurrency address in clipboard",
                  "intention_id": "detect_cryptocurrency_address_clipboard"
                },
                {
                  "action_api": "ipaddress.ip_address()",
                  "action_description": "Resolves host name to IPv4 address",
                  "action_id": "resolve_hostname",
                  "object": "self.domain",
                  "object_description": "Domain name string",
                  "object_id": "domain_name",
                  "intention_description": "Resolve hostname to IP address",
                  "intention_id": "resolve_hostname_ip"
                },
                {
                  "action_api": "str.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "', '.join(f'{name}=%r' for name in self._fields)",
                  "object_description": "Character code array",
                  "object_id": "character_code_array",
                  "intention_description": "Join characters into string",
                  "intention_id": "join_characters_into_string"
                },
                {
                  "action_api": "str.__mod__()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "repr_fmt % self",
                  "object_description": "Character code array",
                  "object_id": "character_code_array",
                  "intention_description": "Join characters into string",
                  "intention_id": "join_characters_into_string"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "html5-parser-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/html5-parser-0.4.12.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/html5-parser-0.4.12/html5-parser-0.4.12/setup.py",
          "line_number": "55",
          "type_description": "code-execution",
          "context_snippet": "class Test(Command):\n\n    description = \"run unit tests after in-place build\"\n    user_options = []\n    user_options = [\n        ('test-name=', None, 'Specify the test to run.'),\n    ]\n    sub_commands = [\n        ('build', None),\n    ]\n\n    def initialize_options(self):\n        self.test_name = ''\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        for cmd_name in self.get_sub_commands():\n            self.run_command(cmd_name)\n        import subprocess\n        build = self.get_finalized_command('build')\n        env = add_python_path(os.environ.copy(), build.build_lib)\n        print('\\nrunning tests...')\n        sys.stdout.flush()\n        cmd = [sys.executable] + TEST_COMMAND\n        if self.test_name:\n            cmd.append(self.test_name)\n        ret = subprocess.Popen(cmd, env=env).wait()\n        if ret != 0:\n            raise SystemExit(ret)",
          "hash_value": "430cc2d29b1a7888b380df53b96bcd63",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class Test(Command):\n\n    description = \"run unit tests after in-place build\"\n    user_options = []\n    user_options = [\n        ('test-name=', None, 'Specify the test to run.'),\n    ]\n    sub_commands = [\n        ('build', None),\n    ]\n\n    def initialize_options(self):\n        self.test_name = ''\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        for cmd_name in self.get_sub_commands():\n            self.run_command(cmd_name)\n        import subprocess\n        build = self.get_finalized_command('build')\n        env = add_python_path(os.environ.copy(), build.build_lib)\n        print('\\nrunning tests...')\n        sys.stdout.flush()\n        cmd = [sys.executable] + TEST_COMMAND\n        if self.test_name:\n            cmd.append(self.test_name)\n        ret = subprocess.Popen(cmd, env=env).wait()\n        if ret != 0:\n            raise SystemExit(ret)",
              "triple_sequences": [
                {
                  "action_api": "self.get_sub_commands()",
                  "action_description": "Iterates over all running processes",
                  "action_id": "iterate_processes",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "List processes",
                  "intention_id": "list_processes"
                },
                {
                  "action_api": "self.run_command()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "cmd_name",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "self.get_finalized_command()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "'build'",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "add_python_path()",
                  "action_description": "Path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.environ.copy(), build.build_lib",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Prepare path for file operations",
                  "intention_id": "prepare_path_file_operations"
                },
                {
                  "action_api": "sys.stdout.flush()",
                  "action_description": "Retrieves standard output stream object",
                  "action_id": "get_stdout_stream",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "cmd, env=env",
                  "object_description": "Background process",
                  "object_id": "background_process",
                  "intention_description": "Create child process",
                  "intention_id": "create_child_process"
                },
                {
                  "action_api": "subprocess.Popen().wait()",
                  "action_description": "Waits for process to complete execution",
                  "action_id": "wait_process_completion",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Wait for events",
                  "intention_id": "wait_for_events"
                },
                {
                  "action_api": "SystemExit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "ret",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pyro4-4",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyro4-4.82.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "util.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyro4-4.82/Pyro4-4.82/src/Pyro4/util.py",
          "line_number": "386",
          "type_description": "obfuscation",
          "context_snippet": "    elif data.get(\"__exception__\", False):\n        if classname in all_exceptions:\n            return SerializerBase.make_exception(all_exceptions[classname], data)\n        # python 2.x: exceptions.ValueError\n        # python 3.x: builtins.ValueError\n        # translate to the appropriate namespace...\n        namespace, short_classname = classname.split('.', 1)\n        if namespace in (\"builtins\", \"exceptions\"):\n            if sys.version_info < (3, 0):\n                exceptiontype = getattr(exceptions, short_classname)\n                if issubclass(exceptiontype, BaseException):\n                    return SerializerBase.make_exception(exceptiontype, data)\n            else:\n                exceptiontype = getattr(builtins, short_classname)\n                if issubclass(exceptiontype, BaseException):\n                    return SerializerBase.make_exception(exceptiontype, data)\n        elif namespace == \"sqlite3\" and short_classname.endswith(\"Error\"):\n            import sqlite3\n            exceptiontype = getattr(sqlite3, short_classname)\n            if issubclass(exceptiontype, BaseException):\n                return SerializerBase.make_exception(exceptiontype, data)",
          "hash_value": "d3751a7cc22a48ca10c0b4ae7b6b204d",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "    elif data.get(\"__exception__\", False):\n        if classname in all_exceptions:\n            return SerializerBase.make_exception(all_exceptions[classname], data)\n        # python 2.x: exceptions.ValueError\n        # python 3.x: builtins.ValueError\n        # translate to the appropriate namespace...\n        namespace, short_classname = classname.split('.', 1)\n        if namespace in (\"builtins\", \"exceptions\"):\n            if sys.version_info < (3, 0):\n                exceptiontype = getattr(exceptions, short_classname)\n                if issubclass(exceptiontype, BaseException):\n                    return SerializerBase.make_exception(exceptiontype, data)\n            else:\n                exceptiontype = getattr(builtins, short_classname)\n                if issubclass(exceptiontype, BaseException):\n                    return SerializerBase.make_exception(exceptiontype, data)\n        elif namespace == \"sqlite3\" and short_classname.endswith(\"Error\"):\n            import sqlite3\n            exceptiontype = getattr(sqlite3, short_classname)\n            if issubclass(exceptiontype, BaseException):\n                return SerializerBase.make_exception(exceptiontype, data)",
              "triple_sequences": [
                {
                  "action_api": "data.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"__exception__\", False",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Access configuration value",
                  "intention_id": "access_configuration_value"
                },
                {
                  "action_api": "classname.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "'.', 1",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "exceptions, short_classname",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "issubclass()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "exceptiontype, BaseException",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "SerializerBase.make_exception()",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "exceptiontype, data",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, short_classname",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "issubclass()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "exceptiontype, BaseException",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "SerializerBase.make_exception()",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "exceptiontype, data",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "import sqlite3",
                  "action_description": "Dynamically imports specified module",
                  "action_id": "import_dynamic",
                  "object": "sqlite3",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "sqlite3, short_classname",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "issubclass()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "exceptiontype, BaseException",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "SerializerBase.make_exception()",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "exceptiontype, data",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "clr_loader-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/clr_loader-0.2.7.post0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/clr_loader-0.2.7.post0/clr_loader-0.2.7.post0/setup.py",
          "line_number": "74",
          "type_description": "code-execution",
          "context_snippet": "class build_dotnet(Command):\n    \"\"\"Build command for dotnet-cli based builds\"\"\"\n\n    description = \"Build DLLs with dotnet-cli\"\n    user_options = [\n        (\"dotnet-config=\", None, \"dotnet build configuration\"),\n        (\n            \"inplace\",\n            \"i\",\n            \"ignore build-lib and put compiled extensions into the source \"\n            + \"directory alongside your pure Python modules\",\n        ),\n    ]\n\n    def initialize_options(self):\n        self.dotnet_config = None\n        self.build_lib = None\n        self.inplace = False\n\n    def finalize_options(self):\n        if self.dotnet_config is None:\n            self.dotnet_config = \"release\"\n\n        build = self.distribution.get_command_obj(\"build\")\n        build.ensure_finalized()\n        if self.inplace:\n            self.build_lib = \".\"\n        else:\n            self.build_lib = build.build_lib\n\n    def run(self):\n        dotnet_modules = self.distribution.dotnet_libs\n\n        for lib in dotnet_modules:\n            output = os.path.join(\n                os.path.abspath(self.build_lib), lib.args.pop(\"output\")\n            )\n            rename = lib.args.pop(\"rename\", {})\n\n            opts = sum(\n                [\n                    [\"--\" + name.replace(\"_\", \"-\"), value]\n                    for name, value in lib.args.items()\n                ],\n                [],\n            )\n\n            opts.extend([\"--configuration\", self.dotnet_config])\n            opts.extend([\"--output\", output])\n\n            self.announce(\"Running dotnet build...\", level=distutils.log.INFO)\n            self.spawn([\"dotnet\", \"build\", lib.path] + opts)\n\n            for k, v in rename.items():\n                source = os.path.join(output, k)\n                dest = os.path.join(output, v)\n\n                if os.path.isfile(source):\n                    try:\n                        os.remove(dest)\n                    except OSError:\n                        pass\n\n                    self.move_file(src=source, dst=dest, level=distutils.log.INFO)\n                else:\n                    self.warn(\n                        \"Can't find file to rename: {}, current dir: {}\".format(\n                            source, os.getcwd()\n                        )\n                    )",
          "hash_value": "b0a3a699f2f02cb76e3cec4dd30286bf",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class build_dotnet(Command):\n    \"\"\"Build command for dotnet-cli based builds\"\"\"\n\n    description = \"Build DLLs with dotnet-cli\"\n    user_options = [\n        (\"dotnet-config=\", None, \"dotnet build configuration\"),\n        (\n            \"inplace\",\n            \"i\",\n            \"ignore build-lib and put compiled extensions into the source \"\n            + \"directory alongside your pure Python modules\",\n        ),\n    ]\n\n    def initialize_options(self):\n        self.dotnet_config = None\n        self.build_lib = None\n        self.inplace = False\n\n    def finalize_options(self):\n        if self.dotnet_config is None:\n            self.dotnet_config = \"release\"\n\n        build = self.distribution.get_command_obj(\"build\")\n        build.ensure_finalized()\n        if self.inplace:\n            self.build_lib = \".\"\n        else:\n            self.build_lib = build.build_lib\n\n    def run(self):\n        dotnet_modules = self.distribution.dotnet_libs\n\n        for lib in dotnet_modules:\n            output = os.path.join(\n                os.path.abspath(self.build_lib), lib.args.pop(\"output\")\n            )\n            rename = lib.args.pop(\"rename\", {})\n\n            opts = sum(\n                [\n                    [\"--\" + name.replace(\"_\", \"-\"), value]\n                    for name, value in lib.args.items()\n                ],\n                [],\n            )\n\n            opts.extend([\"--configuration\", self.dotnet_config])\n            opts.extend([\"--output\", output])\n\n            self.announce(\"Running dotnet build...\", level=distutils.log.INFO)\n            self.spawn([\"dotnet\", \"build\", lib.path] + opts)\n\n            for k, v in rename.items():\n                source = os.path.join(output, k)\n                dest = os.path.join(output, v)\n\n                if os.path.isfile(source):\n                    try:\n                        os.remove(dest)\n                    except OSError:\n                        pass\n\n                    self.move_file(src=source, dst=dest, level=distutils.log.INFO)\n                else:\n                    self.warn(\n                        \"Can't find file to rename: {}, current dir: {}\".format(\n                            source, os.getcwd()\n                        )\n                    )",
              "triple_sequences": [
                {
                  "action_api": "os.path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "self.build_lib",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.abspath(self.build_lib), lib.args.pop(\"output\")",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "lib.args.pop()",
                  "action_description": "Deserialize JSON string to Python object",
                  "action_id": "deserialize_from_json",
                  "object": "\"output\"",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "lib.args.pop()",
                  "action_description": "Deserialize JSON string to Python object",
                  "action_id": "deserialize_from_json",
                  "object": "\"rename\", {}",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "self.announce()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "\"Running dotnet build...\", level=distutils.log.INFO",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "self.spawn()",
                  "action_description": "Spawns new process to execute command with shell access",
                  "action_id": "spawn_process_shell",
                  "object": "[\"dotnet\", \"build\", lib.path] + opts",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "output, k",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "output, v",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.isfile()",
                  "action_description": "Checks if specified path exists and is a file",
                  "action_id": "check_file_is_file",
                  "object": "source",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Determine presence of file",
                  "intention_id": "determine_file_presence"
                },
                {
                  "action_api": "os.remove()",
                  "action_description": "Deletes specified file from filesystem",
                  "action_id": "delete_file",
                  "object": "dest",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Delete file",
                  "intention_id": "delete_file"
                },
                {
                  "action_api": "self.move_file()",
                  "action_description": "Moves file to destination",
                  "action_id": "move_file",
                  "object": "src=source, dst=dest, level=distutils.log.INFO",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Move file to destination",
                  "intention_id": "move_file_destination"
                },
                {
                  "action_api": "self.warn()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "\"Can't find file to rename: {}, current dir: {}\".format(source, os.getcwd())",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "os.getcwd()",
                  "action_description": "Returns current working directory",
                  "action_id": "get_working_dir",
                  "object": "",
                  "object_description": "Current working directory",
                  "object_id": "current_working_directory",
                  "intention_description": "Collect working directory",
                  "intention_id": "collect_working_directory"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "aspidites-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/aspidites-1.16.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/aspidites-1.16.1/Aspidites-1.16.1/setup.py",
          "line_number": "292",
          "type_description": "cmd-overwrite",
          "context_snippet": "setup(\n    name=__title__,\n    version=__version__,\n    author=__author__,\n    author_email=\"rjdbcm@mail.umkc.edu\",\n    description=\"Aspidites is the reference implementation of the Woma Language\",\n    license=__license__,\n    keywords=\"language\",\n    url=\"https://github.com/rjdbcm/Aspidites\",\n    install_requires=[\n        'cython>0.28,<3',\n        'pytest',\n        'pytest-xdist',\n        'pytest-mock',\n        'hypothesis',\n        'future'\n        ],\n    packages=find_packages(),\n    include_dirs=[get_include()],\n    ext_modules=ext_modules,\n    test_suite='Aspidites/tests',\n    distclass=Distribution if sys.platform != 'darwin' else BinaryDistribution,\n    entry_points={'console_scripts': ['aspidites = Aspidites.__main__:main']},\n    package_data={'': [\"*.wom\", \"*.pyx\", \"*.pyi\", \"*.so\", \"*.c\", \"Aspidites/py.typed\"]},  # add any native *.wom files\n    long_description=read('README.md'),\n    cmdclass={'install': InstallWrapper, 'build_ext': BuildExtWrapper},\n    long_description_content_type='text/markdown',\n    classifiers=[\n        \"Operating System :: POSIX :: Linux\",\n        \"Operating System :: MacOS :: MacOS X\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Development Status :: 4 - Beta\",\n        \"Environment :: Console\",\n        \"Programming Language :: Other\",\n        # \"Programming Language :: Python :: 3.6\", EOL in December 2021 and don't want to vendor dataclasses\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        # \"Programming Language :: Python :: Implementation :: PyPy\", looks like a no go\n        \"Programming Language :: Python :: Implementation :: CPython\",\n        \"Topic :: Software Development :: Compilers\",\n        \"Topic :: Utilities\",\n        \"License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)\",\n        \"License :: OSI Approved :: MIT License\",\n        \"License :: OSI Approved :: BSD License\",\n        # \"License :: OSI Approved :: Zope Public License (ZPL)\", ??? Invalid\n        \"License :: OSI Approved :: Apache Software License\",\n    ],\n)\n",
          "hash_value": "602260bac6a757a91001da0c9f998103",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "setup(\n    name=__title__,\n    version=__version__,\n    author=__author__,\n    author_email=\"rjdbcm@mail.umkc.edu\",\n    description=\"Aspidites is the reference implementation of the Woma Language\",\n    license=__license__,\n    keywords=\"language\",\n    url=\"https://github.com/rjdbcm/Aspidites\",\n    install_requires=[\n        'cython>0.28,<3',\n        'pytest',\n        'pytest-xdist',\n        'pytest-mock',\n        'hypothesis',\n        'future'\n        ],\n    packages=find_packages(),\n    include_dirs=[get_include()],\n    ext_modules=ext_modules,\n    test_suite='Aspidites/tests',\n    distclass=Distribution if sys.platform != 'darwin' else BinaryDistribution,\n    entry_points={'console_scripts': ['aspidites = Aspidites.__main__:main']},\n    package_data={'': [\"*.wom\", \"*.pyx\", \"*.pyi\", \"*.so\", \"*.c\", \"Aspidites/py.typed\"]},  # add any native *.wom files\n    long_description=read('README.md'),\n    cmdclass={'install': InstallWrapper, 'build_ext': BuildExtWrapper},\n    long_description_content_type='text/markdown',\n    classifiers=[\n        \"Operating System :: POSIX :: Linux\",\n        \"Operating System :: MacOS :: MacOS X\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Development Status :: 4 - Beta\",\n        \"Environment :: Console\",\n        \"Programming Language :: Other\",\n        # \"Programming Language :: Python :: 3.6\", EOL in December 2021 and don't want to vendor dataclasses\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        # \"Programming Language :: Python :: Implementation :: PyPy\", looks like a no go\n        \"Programming Language :: Python :: Implementation :: CPython\",\n        \"Topic :: Software Development :: Compilers\",\n        \"Topic :: Utilities\",\n        \"License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)\",\n        \"License :: OSI Approved :: MIT License\",\n        \"License :: OSI Approved :: BSD License\",\n        # \"License :: OSI Approved :: Zope Public License (ZPL)\", ??? Invalid\n        \"License :: OSI Approved :: Apache Software License\",\n    ],\n)\n",
              "triple_sequences": [
                {
                  "action_api": "setup()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "name=__title__, version=__version__, author=__author__, author_email=\"rjdbcm@mail.umkc.edu\", description=\"Aspidites is the reference implementation of the Woma Language\", license=__license__, keywords=\"language\", url=\"https://github.com/rjdbcm/Aspidites\", install_requires=[ 'cython>0.28,<3', 'pytest', 'pytest-xdist', 'pytest-mock', 'hypothesis', 'future' ], packages=find_packages(), include_dirs=[get_include()], ext_modules=ext_modules, test_suite='Aspidites/tests', distclass=Distribution if sys.platform != 'darwin' else BinaryDistribution, entry_points={'console_scripts': ['aspidites = Aspidites.__main__:main']}, package_data={'': [\"*.wom\", \"*.pyx\", \"*.pyi\", \"*.so\", \"*.c\", \"Aspidites/py.typed\"]}, long_description=read('README.md'), cmdclass={'install': InstallWrapper, 'build_ext': BuildExtWrapper}, long_description_content_type='text/markdown', classifiers=[ ... ]",
                  "object_description": "Custom post-install function",
                  "object_id": "custom_post_install_function",
                  "intention_description": "Trigger main behavioral logic",
                  "intention_id": "trigger_main_behavioral_logic"
                },
                {
                  "action_api": "find_packages()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Install multiple Python packages",
                  "intention_id": "install_multiple_python_packages"
                },
                {
                  "action_api": "get_include()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                },
                {
                  "action_api": "read('README.md')",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "README.md",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "ai_flow_nightly-2023",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/ai_flow_nightly-2023.12.31.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ai_flow_nightly-2023.12.31/ai_flow_nightly-2023.12.31/setup.py",
          "line_number": "93",
          "type_description": "code-execution",
          "context_snippet": "import subprocess\n\ndef compile_frontend():  # noqa\n    # \"\"\"Run a command to compile and build aiflow frontend.\"\"\"\n    subprocess.check_call('./ai_flow/frontend/compile_frontend.sh')",
          "hash_value": "8f72d60efb191a920dc0eab6279bf133",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import subprocess\n\ndef compile_frontend():  # noqa\n    # \"\"\"Run a command to compile and build aiflow frontend.\"\"\"\n    subprocess.check_call('./ai_flow/frontend/compile_frontend.sh')",
              "triple_sequences": [
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "./ai_flow/frontend/compile_frontend.sh",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pyparsing-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyparsing-3.2.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "httpServerLogParser.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyparsing-3.2.3/pyparsing-3.2.3/examples/httpServerLogParser.py",
          "line_number": "92",
          "type_description": "shady-links",
          "context_snippet": "testdata = \"\"\"\n195.146.134.15 - - [20/Jan/2003:08:55:36 -0800] \"GET /path/to/page.html HTTP/1.0\" 200 4649 \"http://www.somedomain.com/020602/page.html\" \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)\"\n111.111.111.11 - - [16/Feb/2004:04:09:49 -0800] \"GET /ads/redirectads/336x280redirect.htm HTTP/1.1\" 304 - \"http://www.foobarp.org/theme_detail.php?type=vs&cat=0&mid=27512\" \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)\"\n11.111.11.111 - - [16/Feb/2004:10:35:12 -0800] \"GET /ads/redirectads/468x60redirect.htm HTTP/1.1\" 200 541 \"http://11.11.111.11/adframe.php?n=ad1f311a&what=zone:56\" \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1) Opera 7.20  [ru\\\"]\"\n127.0.0.1 - u.surname@domain.com [12/Sep/2006:14:13:53 +0300] \"GET /skins/monobook/external.png HTTP/1.0\" 304 - \"http://wiki.mysite.com/skins/monobook/main.css\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6\"\n\"\"\"\nfor line in testdata.split(\"\\n\"):\n    if not line:\n        continue\n    fields = getLogLineBNF().parseString(line)\n    print(fields.dump())\n    # ~ print repr(fields)\n    # ~ for k in fields.keys():\n    # ~ print \"fields.\" + k + \" =\", fields[k]\n    print()\n",
          "hash_value": "80d18f495af508048c2ee0b08a7ecebd",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "testdata = \"\"\"\n195.146.134.15 - - [20/Jan/2003:08:55:36 -0800] \"GET /path/to/page.html HTTP/1.0\" 200 4649 \"http://www.somedomain.com/020602/page.html\" \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)\"\n111.111.111.11 - - [16/Feb/2004:04:09:49 -0800] \"GET /ads/redirectads/336x280redirect.htm HTTP/1.1\" 304 - \"http://www.foobarp.org/theme_detail.php?type=vs&cat=0&mid=27512\" \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)\"\n11.111.11.111 - - [16/Feb/2004:10:35:12 -0800] \"GET /ads/redirectads/468x60redirect.htm HTTP/1.1\" 200 541 \"http://11.11.111.11/adframe.php?n=ad1f311a&what=zone:56\" \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1) Opera 7.20  [ru\\\"]\"\n127.0.0.1 - u.surname@domain.com [12/Sep/2006:14:13:53 +0300] \"GET /skins/monobook/external.png HTTP/1.0\" 304 - \"http://wiki.mysite.com/skins/monobook/main.css\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6\"\n\"\"\"\nfor line in testdata.split(\"\\n\"):\n    if not line:\n        continue\n    fields = getLogLineBNF().parseString(line)\n    print(fields.dump())\n    # ~ print repr(fields)\n    # ~ for k in fields.keys():\n    # ~ print \"fields.\" + k + \" =\", fields[k]\n    print()\n",
              "triple_sequences": [
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "\\n",
                  "object_description": "Space delimiter",
                  "object_id": "space_delimiter",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "getLogLineBNF().parseString()",
                  "action_description": "Deserialize JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "line",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "fields.dump()",
                  "action_description": "Serialize Python object to JSON string",
                  "action_id": "serialize_to_json",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Serialize data",
                  "intention_id": "serialize_data"
                },
                {
                  "action_api": "print()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "fields.dump()",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "webdavclient3-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/webdavclient3-3.14.6.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/webdavclient3-3.14.6/webdavclient3-3.14.6/setup.py",
          "line_number": "50",
          "type_description": "cmd-overwrite",
          "context_snippet": "setup(\n    name='webdavclient3',\n    version=version,\n    packages=find_packages(exclude=('tests',)),\n    requires=['python (>= 3.3.0)'],\n    install_requires=['requests', 'lxml', 'python-dateutil'],\n    scripts=['wdc'],\n    test_suite='tests',\n    tests_require=['pytest'],\n    cmdclass={'install': Install, 'test': Test},\n    description='WebDAV client, based on original package https://github.com/designerror/webdav-client-python but '\n                'uses requests instead of PyCURL',\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    author='Evgeny Ezhov',\n    author_email='ezhov.evgeny@gmail.com',\n    url='https://github.com/ezhov-evgeny/webdav-client-python-3',\n    license='MIT License',\n    keywords='webdav, client, python, module, library, packet, Yandex.Disk, Dropbox, Google Disk, Box, 4shared',\n    classifiers=[\n        'Environment :: Console',\n        'Environment :: Web Environment',\n        'License :: OSI Approved :: MIT License',\n        'Operating System :: MacOS',\n        'Operating System :: Microsoft',\n        'Operating System :: Unix',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Topic :: Internet',\n        'Topic :: Software Development :: Libraries :: Python Modules',\n    ],\n)\n\n# Data dependencies:\n# - version: declared as version = \"3.14.6\"\n# - find_packages: imported from setuptools\n# - Install, Test: defined as classes above\n# - long_description: loaded from README.md above\n# - All other literals/constants are defined in this block or as string literals.",
          "hash_value": "b736ab23854486d100c288e5be973111",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "setup(\n    name='webdavclient3',\n    version=version,\n    packages=find_packages(exclude=('tests',)),\n    requires=['python (>= 3.3.0)'],\n    install_requires=['requests', 'lxml', 'python-dateutil'],\n    scripts=['wdc'],\n    test_suite='tests',\n    tests_require=['pytest'],\n    cmdclass={'install': Install, 'test': Test},\n    description='WebDAV client, based on original package https://github.com/designerror/webdav-client-python but '\n                'uses requests instead of PyCURL',\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    author='Evgeny Ezhov',\n    author_email='ezhov.evgeny@gmail.com',\n    url='https://github.com/ezhov-evgeny/webdav-client-python-3',\n    license='MIT License',\n    keywords='webdav, client, python, module, library, packet, Yandex.Disk, Dropbox, Google Disk, Box, 4shared',\n    classifiers=[\n        'Environment :: Console',\n        'Environment :: Web Environment',\n        'License :: OSI Approved :: MIT License',\n        'Operating System :: MacOS',\n        'Operating System :: Microsoft',\n        'Operating System :: Unix',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Topic :: Internet',\n        'Topic :: Software Development :: Libraries :: Python Modules',\n    ],\n)\n\n# Data dependencies:\n# - version: declared as version = \"3.14.6\"\n# - find_packages: imported from setuptools\n# - Install, Test: defined as classes above\n# - long_description: loaded from README.md above\n# - All other literals/constants are defined in this block or as string literals.",
              "triple_sequences": [
                {
                  "action_api": "setup()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "name='webdavclient3', version=version, packages=find_packages(exclude=('tests',)), requires=['python (>= 3.3.0)'], install_requires=['requests', 'lxml', 'python-dateutil'], scripts=['wdc'], test_suite='tests', tests_require=['pytest'], cmdclass={'install': Install, 'test': Test}, description='WebDAV client, based on original package https://github.com/designerror/webdav-client-python but uses requests instead of PyCURL', long_description=long_description, long_description_content_type='text/markdown', author='Evgeny Ezhov', author_email='ezhov.evgeny@gmail.com', url='https://github.com/ezhov-evgeny/webdav-client-python-3', license='MIT License', keywords='webdav, client, python, module, library, packet, Yandex.Disk, Dropbox, Google Disk, Box, 4shared', classifiers=[...]",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                },
                {
                  "action_api": "find_packages()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "exclude=('tests',)",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Install multiple Python packages",
                  "intention_id": "install_multiple_python_packages"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pyiqa-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyiqa-0.1.13.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyiqa-0.1.13/pyiqa-0.1.13/setup.py",
          "line_number": "32",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport subprocess\n\ndef get_git_hash():\n\n    def _minimal_ext_cmd(cmd):\n        # construct minimal environment\n        env = {}\n        for k in ['SYSTEMROOT', 'PATH', 'HOME']:\n            v = os.environ.get(k)\n            if v is not None:\n                env[k] = v\n        # LANGUAGE is used on win32\n        env['LANGUAGE'] = 'C'\n        env['LANG'] = 'C'\n        env['LC_ALL'] = 'C'\n        out = subprocess.Popen(cmd, stdout=subprocess.PIPE, env=env).communicate()[0]\n        return out\n\n    try:\n        out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])\n        sha = out.strip().decode('ascii')\n    except OSError:\n        sha = 'unknown'\n\n    return sha",
          "hash_value": "5c5f9a0ff3d27d1291d145856fd9122e",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport subprocess\n\ndef get_git_hash():\n\n    def _minimal_ext_cmd(cmd):\n        # construct minimal environment\n        env = {}\n        for k in ['SYSTEMROOT', 'PATH', 'HOME']:\n            v = os.environ.get(k)\n            if v is not None:\n                env[k] = v\n        # LANGUAGE is used on win32\n        env['LANGUAGE'] = 'C'\n        env['LANG'] = 'C'\n        env['LC_ALL'] = 'C'\n        out = subprocess.Popen(cmd, stdout=subprocess.PIPE, env=env).communicate()[0]\n        return out\n\n    try:\n        out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])\n        sha = out.strip().decode('ascii')\n    except OSError:\n        sha = 'unknown'\n\n    return sha",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "k",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "['git', 'rev-parse', 'HEAD']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "subprocess.Popen().communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "bytes.strip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "bytes.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "ascii",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "elementary_data-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/elementary_data-0.18.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "cli.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/elementary_data-0.18.1/elementary_data-0.18.1/elementary/cli/cli.py",
          "line_number": "70",
          "type_description": "shady-links",
          "context_snippet": "    def invoke(self, ctx: click.Context) -> Any:\n        files_target_path = get_log_path(ctx)\n        set_root_logger_handlers(\"elementary\", files_target_path)\n        click.echo(\n            \"Any feedback and suggestions are welcomed! join our community here - \"\n            \"https://bit.ly/slack-elementary\\n\"\n        )\n        logger.info(f\"Running with edr={package.get_package_version()}\")\n        return super().invoke(ctx)",
          "hash_value": "de4a69802c1ecc99b24915c9aaa016f2",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "    def invoke(self, ctx: click.Context) -> Any:\n        files_target_path = get_log_path(ctx)\n        set_root_logger_handlers(\"elementary\", files_target_path)\n        click.echo(\n            \"Any feedback and suggestions are welcomed! join our community here - \"\n            \"https://bit.ly/slack-elementary\\n\"\n        )\n        logger.info(f\"Running with edr={package.get_package_version()}\")\n        return super().invoke(ctx)",
              "triple_sequences": [
                {
                  "action_api": "get_log_path()",
                  "action_description": "Path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "ctx",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "set_root_logger_handlers()",
                  "action_description": "Set attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "\"elementary\", files_target_path",
                  "object_description": "Log level",
                  "object_id": "log_level",
                  "intention_description": "Modify file attributes",
                  "intention_id": "modify_file_attributes"
                },
                {
                  "action_api": "click.echo()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "\"Any feedback and suggestions are welcomed! join our community here - https://bit.ly/slack-elementary\\n\"",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                },
                {
                  "action_api": "logger.info()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "f\"Running with edr={package.get_package_version()}\"",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                },
                {
                  "action_api": "package.get_package_version()",
                  "action_description": "Retrieves operating system version",
                  "action_id": "get_os_version",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get operating system version",
                  "intention_id": "get_operating_system_version"
                },
                {
                  "action_api": "super().invoke()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "ctx",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "jira-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/jira-3.8.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "make_local_jira_user.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/jira-3.8.0/jira-3.8.0/make_local_jira_user.py",
          "line_number": "45",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "import sys\nimport time\nfrom os import environ\n\nimport requests\n\nfrom jira import JIRA\n\nCI_JIRA_URL = environ[\"CI_JIRA_URL\"]\n\nif __name__ == \"__main__\":\n    if environ.get(\"CI_JIRA_TYPE\", \"Server\").upper() == \"CLOUD\":\n        print(\"Do not need to create a user for Jira Cloud CI, quitting.\")\n        sys.exit()\n\n    start_time = time.time()\n    timeout_mins = 15\n    print(\n        \"waiting for instance of jira to be running, to add a user for CI system:\\n\"\n        f\" timeout = {timeout_mins} mins\"\n    )\n    while True:\n        try:\n            requests.get(CI_JIRA_URL + \"rest/api/2/permissions\")\n            print(\"JIRA IS REACHABLE\")\n            add_user_to_jira()\n            break\n        except (requests.exceptions.Timeout, requests.exceptions.ConnectionError) as ex:\n            print(f\"encountered {ex} while waiting for the JiraServer docker\")\n            time.sleep(20)\n        if start_time + 60 * timeout_mins < time.time():\n            raise TimeoutError(\n                f\"Jira server wasn't reachable within timeout {timeout_mins}\"\n            )",
          "hash_value": "990059feb2019731570707a787c0a0e1",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import sys\nimport time\nfrom os import environ\n\nimport requests\n\nfrom jira import JIRA\n\nCI_JIRA_URL = environ[\"CI_JIRA_URL\"]\n\nif __name__ == \"__main__\":\n    if environ.get(\"CI_JIRA_TYPE\", \"Server\").upper() == \"CLOUD\":\n        print(\"Do not need to create a user for Jira Cloud CI, quitting.\")\n        sys.exit()\n\n    start_time = time.time()\n    timeout_mins = 15\n    print(\n        \"waiting for instance of jira to be running, to add a user for CI system:\\n\"\n        f\" timeout = {timeout_mins} mins\"\n    )\n    while True:\n        try:\n            requests.get(CI_JIRA_URL + \"rest/api/2/permissions\")\n            print(\"JIRA IS REACHABLE\")\n            add_user_to_jira()\n            break\n        except (requests.exceptions.Timeout, requests.exceptions.ConnectionError) as ex:\n            print(f\"encountered {ex} while waiting for the JiraServer docker\")\n            time.sleep(20)\n        if start_time + 60 * timeout_mins < time.time():\n            raise TimeoutError(\n                f\"Jira server wasn't reachable within timeout {timeout_mins}\"\n            )",
              "triple_sequences": [
                {
                  "action_api": "environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "CI_JIRA_TYPE",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                },
                {
                  "action_api": "time.time()",
                  "action_description": "Returns current time",
                  "action_id": "get_current_time",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get datetime epoch",
                  "intention_id": "get_datetime_epoch"
                },
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP GET request to URL",
                  "action_id": "open_url_get",
                  "object": "CI_JIRA_URL + \"rest/api/2/permissions\"",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "add_user_to_jira()",
                  "action_description": "Creates child process",
                  "action_id": "create_child_process",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Create child process",
                  "intention_id": "create_child_process"
                },
                {
                  "action_api": "time.sleep()",
                  "action_description": "Suspends execution",
                  "action_id": "suspend_execution",
                  "object": "20",
                  "object_description": "Delay duration in seconds",
                  "object_id": "delay_duration",
                  "intention_description": "Pause execution",
                  "intention_id": "pause_execution"
                },
                {
                  "action_api": "raise TimeoutError",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "f\"Jira server wasn't reachable within timeout {timeout_mins}\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pykdtree-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pykdtree-1.4.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pykdtree-1.4.1/pykdtree-1.4.1/setup.py",
          "line_number": "173",
          "type_description": "code-execution",
          "context_snippet": "def _compile_link_paths_from_manifest(cmd):\n    \"\"\"Parse include and library paths from OSX package managers.\n\n    Example executions::\n\n        # Homebrew\n        $ brew ls --verbose libomp\n        /opt/homebrew/Cellar/libomp/15.0.7/INSTALL_RECEIPT.json\n        /opt/homebrew/Cellar/libomp/15.0.7/.brew/libomp.rb\n        /opt/homebrew/Cellar/libomp/15.0.7/include/ompt.h\n        /opt/homebrew/Cellar/libomp/15.0.7/include/omp.h\n        /opt/homebrew/Cellar/libomp/15.0.7/include/omp-tools.h\n        /opt/homebrew/Cellar/libomp/15.0.7/lib/libomp.dylib\n        /opt/homebrew/Cellar/libomp/15.0.7/lib/libomp.a\n\n        # MacPorts\n        $ port contents libomp\n        Port libomp contains:\n          /opt/local/include/libomp/omp-tools.h\n          /opt/local/include/libomp/omp.h\n          /opt/local/include/libomp/ompt.h\n          /opt/local/lib/libomp/libgomp.dylib\n          /opt/local/lib/libomp/libiomp5.dylib\n          /opt/local/lib/libomp/libomp.dylib\n          /opt/local/share/doc/libomp/LICENSE.TXT\n          /opt/local/share/doc/libomp/README.txt\n\n    \"\"\"\n    from subprocess import run\n    query = run(cmd, shell=True, check=False, capture_output=True)\n    if query.returncode != 0:\n        return None, None\n    manifest = query.stdout.decode(\"UTF-8\")\n    # find all the unique directories mentioned in the manifest\n    dirs = set(os.path.split(filename)[0] for filename in re.findall(r'^\\s*(/.*?)\\s*$', manifest, re.MULTILINE))\n    # find a unique libdir and incdir\n    inc = tuple(d for d in dirs if re.search(r'/include(\\W|$)', d))\n    lib = tuple(d for d in dirs if re.search(r'/lib(\\W|$)', d))\n    # only return success if there's no ambiguity\n    return (inc + lib) if len(inc) == 1 and len(lib) == 1 else (None, None)",
          "hash_value": "d7ebd695f33978cba3a39ca755206115",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def _compile_link_paths_from_manifest(cmd):\n    \"\"\"Parse include and library paths from OSX package managers.\n\n    Example executions::\n\n        # Homebrew\n        $ brew ls --verbose libomp\n        /opt/homebrew/Cellar/libomp/15.0.7/INSTALL_RECEIPT.json\n        /opt/homebrew/Cellar/libomp/15.0.7/.brew/libomp.rb\n        /opt/homebrew/Cellar/libomp/15.0.7/include/ompt.h\n        /opt/homebrew/Cellar/libomp/15.0.7/include/omp.h\n        /opt/homebrew/Cellar/libomp/15.0.7/include/omp-tools.h\n        /opt/homebrew/Cellar/libomp/15.0.7/lib/libomp.dylib\n        /opt/homebrew/Cellar/libomp/15.0.7/lib/libomp.a\n\n        # MacPorts\n        $ port contents libomp\n        Port libomp contains:\n          /opt/local/include/libomp/omp-tools.h\n          /opt/local/include/libomp/omp.h\n          /opt/local/include/libomp/ompt.h\n          /opt/local/lib/libomp/libgomp.dylib\n          /opt/local/lib/libomp/libiomp5.dylib\n          /opt/local/lib/libomp/libomp.dylib\n          /opt/local/share/doc/libomp/LICENSE.TXT\n          /opt/local/share/doc/libomp/README.txt\n\n    \"\"\"\n    from subprocess import run\n    query = run(cmd, shell=True, check=False, capture_output=True)\n    if query.returncode != 0:\n        return None, None\n    manifest = query.stdout.decode(\"UTF-8\")\n    # find all the unique directories mentioned in the manifest\n    dirs = set(os.path.split(filename)[0] for filename in re.findall(r'^\\s*(/.*?)\\s*$', manifest, re.MULTILINE))\n    # find a unique libdir and incdir\n    inc = tuple(d for d in dirs if re.search(r'/include(\\W|$)', d))\n    lib = tuple(d for d in dirs if re.search(r'/lib(\\W|$)', d))\n    # only return success if there's no ambiguity\n    return (inc + lib) if len(inc) == 1 and len(lib) == 1 else (None, None)",
              "triple_sequences": [
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "cmd",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "CompletedProcess.stdout.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "\"UTF-8\"",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Decode bytes to string",
                  "intention_id": "decode_bytes_to_string"
                },
                {
                  "action_api": "re.findall()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "r'^\u0000a*(/.*?)\u0000a*$', manifest, re.MULTILINE",
                  "object_description": "Regular expression and file content",
                  "object_id": "regex_file_content",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "os.path.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "filename",
                  "object_description": "Local file or directory name",
                  "object_id": "local_file_or_directory_name",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "re.search()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "r'/include(\\W|$)', d",
                  "object_description": "Regular expression pattern",
                  "object_id": "regex_pattern",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "re.search()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "r'/lib(\\W|$)', d",
                  "object_description": "Regular expression pattern",
                  "object_id": "regex_pattern",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "cyvcf2-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/cyvcf2-0.31.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cyvcf2-0.31.1/cyvcf2-0.31.1/setup.py",
          "line_number": "78",
          "type_description": "code-execution",
          "context_snippet": "def build_htslib(htslib_configure_options, static_mode):\n    current_directory = os.getcwd()\n    os.chdir(os.path.join(current_directory, \"htslib\"))\n\n    if os.path.exists(\"config.status\"):\n        print(\"# cyvcf2: config.status exists, skip configure htslib\")\n    else:\n        subprocess.run([\"autoreconf\", \"-i\"], check=True)\n\n        configure_args = [\"./configure\"]\n        if static_mode:\n            configure_args.append(\"CFLAGS=-fPIC\")\n        if htslib_configure_options:\n            configure_args.extend(htslib_configure_options.split())\n\n        subprocess.run(configure_args, check=True)\n    subprocess.run([\"make\"], check=True)\n\n    os.chdir(current_directory)\n\n# Data dependencies:\n# - subprocess: imported at top\n# - os: imported at top\n# - htslib_configure_options, static_mode: function arguments",
          "hash_value": "6c19746049c6733a4aedaf44424ce8da",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def build_htslib(htslib_configure_options, static_mode):\n    current_directory = os.getcwd()\n    os.chdir(os.path.join(current_directory, \"htslib\"))\n\n    if os.path.exists(\"config.status\"):\n        print(\"# cyvcf2: config.status exists, skip configure htslib\")\n    else:\n        subprocess.run([\"autoreconf\", \"-i\"], check=True)\n\n        configure_args = [\"./configure\"]\n        if static_mode:\n            configure_args.append(\"CFLAGS=-fPIC\")\n        if htslib_configure_options:\n            configure_args.extend(htslib_configure_options.split())\n\n        subprocess.run(configure_args, check=True)\n    subprocess.run([\"make\"], check=True)\n\n    os.chdir(current_directory)\n\n# Data dependencies:\n# - subprocess: imported at top\n# - os: imported at top\n# - htslib_configure_options, static_mode: function arguments",
              "triple_sequences": [
                {
                  "action_api": "os.getcwd()",
                  "action_description": "Returns current working directory",
                  "action_id": "get_working_dir",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect working directory",
                  "intention_id": "collect_working_directory"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "current_directory, \"htslib\"",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.chdir()",
                  "action_description": "Changes current working directory",
                  "action_id": "change_working_dir",
                  "object": "os.path.join(current_directory, \"htslib\")",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Change working directory",
                  "intention_id": "change_working_directory"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "\"config.status\"",
                  "object_description": "Local file or directory name",
                  "object_id": "local_file_or_directory_name",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"autoreconf\", \"-i\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "configure_args",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"make\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.chdir()",
                  "action_description": "Changes current working directory",
                  "action_id": "change_working_dir",
                  "object": "current_directory",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Restore previous working directory",
                  "intention_id": "restore_working_directory"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "duplicate_code_report",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/duplicate_code_report.json",
        "dataset_type": "benign"
      },
      "code_files": [],
      "note": "No code snippets found in file"
    },
    {
      "metadata": {
        "package_name": "percy_appium_app-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/percy_appium_app-2.0.7.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "cli_wrapper.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/percy_appium_app-2.0.7/percy_appium_app-2.0.7/percy/lib/cli_wrapper.py",
          "line_number": "21",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "from functools import lru_cache\nimport os\nimport requests\n\nfrom percy.errors import CLIException\nfrom percy.common import log\nfrom percy.environment import Environment\n\n# Maybe get the CLI API address from the environment\nPERCY_CLI_API = os.environ.get('PERCY_CLI_API') or 'http://localhost:5338'\n\nclass CLIWrapper:\n    def __init__(self) -> None:\n        pass\n\n    # Check if Percy is enabled, caching the result so it is only checked once\n    @staticmethod\n    @lru_cache(maxsize=None)\n    def is_percy_enabled():\n        try:\n            response = requests.get(f'{PERCY_CLI_API}/percy/healthcheck', timeout=10)\n            response.raise_for_status()\n            data = response.json()\n\n            if not data['success']: raise CLIException(data['error'])\n            Environment.percy_build_id = data['build']['id']\n            Environment.percy_build_url = data['build']['url']\n            Environment.session_type = data.get('type', None)\n            version = response.headers.get('x-percy-core-version')\n\n            if version.split('.')[0] != '1':\n                log(f'Unsupported Percy CLI version, {version}')\n                return False\n\n            if int(version.split('.')[1]) < 27:\n                log('Please upgrade to latest CLI version for using this SDK. Minimum compatible version is 1.27.0-beta.0')\n                return False\n\n            return True\n        except Exception as e:\n            log('Percy is not running, disabling screenshots')\n            log(e, on_debug=True)\n            return False",
          "hash_value": "75b8d41ba853f48aa160872496be4123",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from functools import lru_cache\nimport os\nimport requests\n\nfrom percy.errors import CLIException\nfrom percy.common import log\nfrom percy.environment import Environment\n\n# Maybe get the CLI API address from the environment\nPERCY_CLI_API = os.environ.get('PERCY_CLI_API') or 'http://localhost:5338'\n\nclass CLIWrapper:\n    def __init__(self) -> None:\n        pass\n\n    # Check if Percy is enabled, caching the result so it is only checked once\n    @staticmethod\n    @lru_cache(maxsize=None)\n    def is_percy_enabled():\n        try:\n            response = requests.get(f'{PERCY_CLI_API}/percy/healthcheck', timeout=10)\n            response.raise_for_status()\n            data = response.json()\n\n            if not data['success']: raise CLIException(data['error'])\n            Environment.percy_build_id = data['build']['id']\n            Environment.percy_build_url = data['build']['url']\n            Environment.session_type = data.get('type', None)\n            version = response.headers.get('x-percy-core-version')\n\n            if version.split('.')[0] != '1':\n                log(f'Unsupported Percy CLI version, {version}')\n                return False\n\n            if int(version.split('.')[1]) < 27:\n                log('Please upgrade to latest CLI version for using this SDK. Minimum compatible version is 1.27.0-beta.0')\n                return False\n\n            return True\n        except Exception as e:\n            log('Percy is not running, disabling screenshots')\n            log(e, on_debug=True)\n            return False",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'PERCY_CLI_API'",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "f'{PERCY_CLI_API}/percy/healthcheck', timeout=10",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "response.raise_for_status()",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                },
                {
                  "action_api": "response.json()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "response.headers.get()",
                  "action_description": "Adds HTTP header to request object",
                  "action_id": "add_http_header",
                  "object": "'x-percy-core-version'",
                  "object_description": "HTTP header",
                  "object_id": "http_header",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "version.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "'.'",
                  "object_description": "Space delimiter",
                  "object_id": "space_delimiter",
                  "intention_description": "Prepare string processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "int()",
                  "action_description": "Converts integer to bytes with specified length and byte order",
                  "action_id": "convert_int_to_bytes",
                  "object": "version.split('.')[1]",
                  "object_description": "Character code array",
                  "object_id": "character_code_array",
                  "intention_description": "Convert string to integer",
                  "intention_id": "convert_string_to_integer"
                },
                {
                  "action_api": "log()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "f'Unsupported Percy CLI version, {version}'",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "log()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "'Please upgrade to latest CLI version for using this SDK. Minimum compatible version is 1.27.0-beta.0'",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "log()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "'Percy is not running, disabling screenshots'",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "log()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "e, on_debug=True",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pip_system_certs-4",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pip_system_certs-4.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pip_system_certs-4.0/pip_system_certs-4.0/setup.py",
          "line_number": "51",
          "type_description": "cmd-overwrite",
          "context_snippet": "import os\nimport sys\nimport distutils.sysconfig\nfrom setuptools import setup\nfrom setuptools.command.install import install\nfrom setuptools.command.develop import develop\nfrom setuptools.command.build_py import build_py\n\n\nwith open(os.path.join(os.path.dirname(__file__), 'README.rst')) as readme:\n    long_description = readme.read()\n\n\ndef check_pth(site_packages):\n    pthfile = os.path.join(site_packages, \"pip_system_certs.pth\")\n    if not os.path.exists(pthfile):\n        sys.stderr.write(\"WARNING: pip_system_certs.pth not installed correctly, will try to correct.\\n\")\n        sys.stderr.write(\"Please report an issue at https://gitlab.com/alelec/pip-system-certs with your\\n\")\n        sys.stderr.write(\"python and pip versions included in the description\\n\")\n        import shutil\n        shutil.copyfile(\"pip_system_certs.pth\", pthfile)\n\n\nclass InstallCheck(install):\n    def run(self):\n        install.run(self)\n        check_pth(self.install_purelib)\n\n\nclass DevelopCheck(develop):\n    def run(self):\n        develop.run(self)\n        check_pth(self.install_dir)\n\n\nclass BuildIncludePth(build_py):\n     \"\"\"Include the .pth file for this project in the generated wheel.\"\"\"\n\n     def run(self):\n         super().run()\n\n         pth_file = \"pip_system_certs.pth\"\n\n         outfile = os.path.join(self.build_lib, pth_file)\n         self.copy_file(pth_file, outfile, preserve_mode=0)\n\n\nsite_packages = distutils.sysconfig.get_python_lib()\n\n\nsetup(\n    name='pip_system_certs',\n    use_git_versioner=\"gitlab:desc:snapshot\",\n    setup_requires=[\"git-versioner\"],\n    description='Live patches pip to use system certs by default',\n    long_description=long_description,\n    author='Andrew Leech',\n    author_email='andrew@alelec.net',\n    license='BSD',\n    url='https://gitlab.com/alelec/pip-system-certs',\n    packages=['pip_system_certs'],\n    install_requires=['wrapt>=1.10.4'],\n    zip_safe=False,\n    cmdclass={\n        \"build_py\": BuildIncludePth,\n        \"install\": InstallCheck,\n        \"develop\": DevelopCheck,\n    },\n    python_requires='>=2.7.9, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*',\n)\n",
          "hash_value": "4a785cd437a979fdd39c92966bbdbf5d",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport sys\nimport distutils.sysconfig\nfrom setuptools import setup\nfrom setuptools.command.install import install\nfrom setuptools.command.develop import develop\nfrom setuptools.command.build_py import build_py\n\n\nwith open(os.path.join(os.path.dirname(__file__), 'README.rst')) as readme:\n    long_description = readme.read()\n\n\ndef check_pth(site_packages):\n    pthfile = os.path.join(site_packages, \"pip_system_certs.pth\")\n    if not os.path.exists(pthfile):\n        sys.stderr.write(\"WARNING: pip_system_certs.pth not installed correctly, will try to correct.\\n\")\n        sys.stderr.write(\"Please report an issue at https://gitlab.com/alelec/pip-system-certs with your\\n\")\n        sys.stderr.write(\"python and pip versions included in the description\\n\")\n        import shutil\n        shutil.copyfile(\"pip_system_certs.pth\", pthfile)\n\n\nclass InstallCheck(install):\n    def run(self):\n        install.run(self)\n        check_pth(self.install_purelib)\n\n\nclass DevelopCheck(develop):\n    def run(self):\n        develop.run(self)\n        check_pth(self.install_dir)\n\n\nclass BuildIncludePth(build_py):\n     \"\"\"Include the .pth file for this project in the generated wheel.\"\"\"\n\n     def run(self):\n         super().run()\n\n         pth_file = \"pip_system_certs.pth\"\n\n         outfile = os.path.join(self.build_lib, pth_file)\n         self.copy_file(pth_file, outfile, preserve_mode=0)\n\n\nsite_packages = distutils.sysconfig.get_python_lib()\n\n\nsetup(\n    name='pip_system_certs',\n    use_git_versioner=\"gitlab:desc:snapshot\",\n    setup_requires=[\"git-versioner\"],\n    description='Live patches pip to use system certs by default',\n    long_description=long_description,\n    author='Andrew Leech',\n    author_email='andrew@alelec.net',\n    license='BSD',\n    url='https://gitlab.com/alelec/pip-system-certs',\n    packages=['pip_system_certs'],\n    install_requires=['wrapt>=1.10.4'],\n    zip_safe=False,\n    cmdclass={\n        \"build_py\": BuildIncludePth,\n        \"install\": InstallCheck,\n        \"develop\": DevelopCheck,\n    },\n    python_requires='>=2.7.9, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*',\n)\n",
              "triple_sequences": [
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "[os.path.dirname(__file__), 'README.rst']",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "os.path.join(os.path.dirname(__file__), 'README.rst')",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "readme.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "[site_packages, 'pip_system_certs.pth']",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "pthfile",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "sys.stderr.write()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "\"WARNING: pip_system_certs.pth not installed correctly, will try to correct.\\n\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "sys.stderr.write()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "\"Please report an issue at https://gitlab.com/alelec/pip-system-certs with your\\n\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "sys.stderr.write()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "\"python and pip versions included in the description\\n\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "shutil.copyfile()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "[\"pip_system_certs.pth\", pthfile]",
                  "object_description": "Local file or directory",
                  "object_id": "local_file_or_directory",
                  "intention_description": "Copy file to startup directory",
                  "intention_id": "copy_file_startup_directory"
                },
                {
                  "action_api": "install.run()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                },
                {
                  "action_api": "check_pth()",
                  "action_description": "Checks if persistence entry exists",
                  "action_id": "check_persistence_entry",
                  "object": "self.install_purelib",
                  "object_description": "Program directory",
                  "object_id": "program_directory",
                  "intention_description": "Setup persistence in startup directory",
                  "intention_id": "setup_startup_persistence"
                },
                {
                  "action_api": "develop.run()",
                  "action_description": "Executes setuptools development procedure",
                  "action_id": "exec_setuptools_dev",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                },
                {
                  "action_api": "check_pth()",
                  "action_description": "Checks if persistence entry exists",
                  "action_id": "check_persistence_entry",
                  "object": "self.install_dir",
                  "object_description": "Program directory",
                  "object_id": "program_directory",
                  "intention_description": "Setup persistence in startup directory",
                  "intention_id": "setup_startup_persistence"
                },
                {
                  "action_api": "super().run()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "[self.build_lib, pth_file]",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "self.copy_file()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "[pth_file, outfile, preserve_mode=0]",
                  "object_description": "Local file or directory",
                  "object_id": "local_file_or_directory",
                  "intention_description": "Copy file to temporary directory",
                  "intention_id": "copy_file_temp_directory"
                },
                {
                  "action_api": "distutils.sysconfig.get_python_lib()",
                  "action_description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
                  "action_id": "path_special_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get Python executable path",
                  "intention_id": "get_python_executable_path"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "{...}",
                  "object_description": "Builtin module",
                  "object_id": "builtin_module",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "plink-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/plink-2.4.6.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/plink-2.4.6/plink-2.4.6/setup.py",
          "line_number": "50",
          "type_description": "code-execution",
          "context_snippet": "import os, re, shutil, subprocess, sys, glob\n\ndef check_call(args):\n    try:\n        subprocess.check_call(args)\n    except subprocess.CalledProcessError:\n        executable = args[0]\n        command = [a for a in args if not a.startswith('-')][-1]\n        raise RuntimeError(command + ' failed for ' + executable)",
          "hash_value": "abd252b9679042f7d2e12581cc21b9ce",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os, re, shutil, subprocess, sys, glob\n\ndef check_call(args):\n    try:\n        subprocess.check_call(args)\n    except subprocess.CalledProcessError:\n        executable = args[0]\n        command = [a for a in args if not a.startswith('-')][-1]\n        raise RuntimeError(command + ' failed for ' + executable)",
              "triple_sequences": [
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "args",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "blaze-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/blaze-0.10.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "python.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/blaze-0.10.1/blaze-0.10.1/blaze/compute/python.py",
          "line_number": "380",
          "type_description": "obfuscation",
          "context_snippet": "from ..compatibility import builtins, apply, unicode, _inttypes\n\n@dispatch(Reduction, Sequence)\ndef compute_up_1d(t, seq, **kwargs):\n    op = getattr(builtins, t.symbol)\n    return op(seq)",
          "hash_value": "e11f1196c6b121c7adda7c12f3d338d5",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from ..compatibility import builtins, apply, unicode, _inttypes\n\n@dispatch(Reduction, Sequence)\ndef compute_up_1d(t, seq, **kwargs):\n    op = getattr(builtins, t.symbol)\n    return op(seq)",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, t.symbol",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "op()",
                  "action_description": "Executes Python code",
                  "action_id": "execute_python_code",
                  "object": "seq",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Evaluate constructed code",
                  "intention_id": "evaluate_constructed_code"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "wtforms-json-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/wtforms-json-0.3.5.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/wtforms-json-0.3.5/WTForms-JSON-0.3.5/setup.py",
          "line_number": "27",
          "type_description": "code-execution",
          "context_snippet": "import subprocess\n\nclass PyTest(Command):\n    user_options = []\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        errno = subprocess.call(['py.test'])\n        raise SystemExit(errno)",
          "hash_value": "2b8f20e73599cb4919c54c7761527cc2",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import subprocess\n\nclass PyTest(Command):\n    user_options = []\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        errno = subprocess.call(['py.test'])\n        raise SystemExit(errno)",
              "triple_sequences": [
                {
                  "action_api": "subprocess.call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "['py.test']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "SystemExit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "errno",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "tbats-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/tbats-1.1.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/tbats-1.1.3/tbats-1.1.3/setup.py",
          "line_number": "48",
          "type_description": "code-execution",
          "context_snippet": "import distutils.log\nimport subprocess\n\nclass RTestCommand(TestCommand):\n    description = 'Run comparison to R forecast package implementation of BATS and TBATS (REQUIRES R)'\n\n    def run_tests(self):\n        \"\"\"Run command.\"\"\"\n        command = ['pytest', 'test_R']\n        # if self.pylint_rcfile:\n        #     command.append('--rcfile=%s' % self.pylint_rcfile)\n        # command.append(os.getcwd())\n        self.announce(\n            'Running command: %s' % str(command),\n            level=distutils.log.INFO)\n        subprocess.check_call(command)",
          "hash_value": "154aab00be32089e3d6e208af3af4bf6",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import distutils.log\nimport subprocess\n\nclass RTestCommand(TestCommand):\n    description = 'Run comparison to R forecast package implementation of BATS and TBATS (REQUIRES R)'\n\n    def run_tests(self):\n        \"\"\"Run command.\"\"\"\n        command = ['pytest', 'test_R']\n        # if self.pylint_rcfile:\n        #     command.append('--rcfile=%s' % self.pylint_rcfile)\n        # command.append(os.getcwd())\n        self.announce(\n            'Running command: %s' % str(command),\n            level=distutils.log.INFO)\n        subprocess.check_call(command)",
              "triple_sequences": [
                {
                  "action_api": "self.announce()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "'Running command: %s' % str(command), level=distutils.log.INFO",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "['pytest', 'test_R']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "simple_parsing-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/simple_parsing-0.1.7.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "utils.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/simple_parsing-0.1.7/simple_parsing-0.1.7/simple_parsing/utils.py",
          "line_number": "71",
          "type_description": "obfuscation",
          "context_snippet": "import builtins\n\nbuiltin_types = [\n    getattr(builtins, d) for d in dir(builtins) if isinstance(getattr(builtins, d), type)\n]",
          "hash_value": "9708504f1675a0714f6f1baedaf64a05",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import builtins\n\nbuiltin_types = [\n    getattr(builtins, d) for d in dir(builtins) if isinstance(getattr(builtins, d), type)\n]",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, d",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "dir()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "getattr(builtins, d), type",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pure_eval-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pure_eval-0.2.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "core.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pure_eval-0.2.3/pure_eval-0.2.3/pure_eval/core.py",
          "line_number": "418",
          "type_description": "obfuscation",
          "context_snippet": "def is_expression_interesting(node: ast.expr, value: Any) -> bool:\n    \"\"\"\n    Determines if an expression is potentially interesting, at least in my opinion.\n    Returns False for the following expressions whose value is generally obvious:\n        - Literals (e.g. 123, 'abc', [1, 2, 3], {'a': (), 'b': ([1, 2], [3])})\n        - Variables or attributes whose name is equal to the value's __name__.\n            For example, a function `def foo(): ...` is not interesting when referred to\n            as `foo` as it usually would, but `bar` can be interesting if `bar is foo`.\n            Similarly the method `self.foo` is not interesting.\n        - Builtins (e.g. `len`) referred to by their usual name.\n\n    This is a low level API, typically you will use `interesting_expressions_grouped`.\n\n    :param node: an AST expression\n    :param value: the value of the node\n    :return: a boolean: True if the expression is interesting, False otherwise\n    \"\"\"\n\n    with suppress(ValueError):\n        ast.literal_eval(node)\n        return False\n\n    # TODO exclude inner modules, e.g. numpy.random.__name__ == 'numpy.random' != 'random'\n    # TODO exclude common module abbreviations, e.g. numpy as np, pandas as pd\n    if has_ast_name(value, node):\n        return False\n\n    if (\n            isinstance(node, ast.Name)\n            and getattr(builtins, node.id, object()) is value\n    ):\n        return False\n\n    return True",
          "hash_value": "a16dd15063ef85153a088014cc0138f9",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def is_expression_interesting(node: ast.expr, value: Any) -> bool:\n    \"\"\"\n    Determines if an expression is potentially interesting, at least in my opinion.\n    Returns False for the following expressions whose value is generally obvious:\n        - Literals (e.g. 123, 'abc', [1, 2, 3], {'a': (), 'b': ([1, 2], [3])})\n        - Variables or attributes whose name is equal to the value's __name__.\n            For example, a function `def foo(): ...` is not interesting when referred to\n            as `foo` as it usually would, but `bar` can be interesting if `bar is foo`.\n            Similarly the method `self.foo` is not interesting.\n        - Builtins (e.g. `len`) referred to by their usual name.\n\n    This is a low level API, typically you will use `interesting_expressions_grouped`.\n\n    :param node: an AST expression\n    :param value: the value of the node\n    :return: a boolean: True if the expression is interesting, False otherwise\n    \"\"\"\n\n    with suppress(ValueError):\n        ast.literal_eval(node)\n        return False\n\n    # TODO exclude inner modules, e.g. numpy.random.__name__ == 'numpy.random' != 'random'\n    # TODO exclude common module abbreviations, e.g. numpy as np, pandas as pd\n    if has_ast_name(value, node):\n        return False\n\n    if (\n            isinstance(node, ast.Name)\n            and getattr(builtins, node.id, object()) is value\n    ):\n        return False\n\n    return True",
              "triple_sequences": [
                {
                  "action_api": "ast.literal_eval()",
                  "action_description": "Compiles source code string into executable code object",
                  "action_id": "compile_code_object",
                  "object": "node",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Decode obfuscated code content",
                  "intention_id": "decode_obfuscated_code"
                },
                {
                  "action_api": "has_ast_name()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "value, node",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "node, ast.Name",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, node.id, object()",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "grpcio_tools-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/grpcio_tools-1.72.0rc1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/grpcio_tools-1.72.0rc1/grpcio_tools-1.72.0rc1/setup.py",
          "line_number": "94",
          "type_description": "code-execution",
          "context_snippet": "import subprocess\nfrom subprocess import PIPE\nimport os\n\ndef check_linker_need_libatomic():\n    \"\"\"Test if linker on system needs libatomic.\"\"\"\n    code_test = (\n        b\"#include <atomic>\\n\"\n        + b\"int main() { return std::atomic<int64_t>{}; }\"\n    )\n    cxx = os.environ.get(\"CXX\", \"c++\")\n    cpp_test = subprocess.Popen(\n        [cxx, \"-x\", \"c++\", \"-std=c++17\", \"-\"],\n        stdin=PIPE,\n        stdout=PIPE,\n        stderr=PIPE,\n    )\n    cpp_test.communicate(input=code_test)\n    if cpp_test.returncode == 0:\n        return False\n    # Double-check to see if -latomic actually can solve the problem.\n    # https://github.com/grpc/grpc/issues/22491\n    cpp_test = subprocess.Popen(\n        [cxx, \"-x\", \"c++\", \"-std=c++17\", \"-\", \"-latomic\"],\n        stdin=PIPE,\n        stdout=PIPE,\n        stderr=PIPE,\n    )\n    cpp_test.communicate(input=code_test)\n    return cpp_test.returncode == 0",
          "hash_value": "e9a7a8680c16fe8ac4e8d3448bd56ccd",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import subprocess\nfrom subprocess import PIPE\nimport os\n\ndef check_linker_need_libatomic():\n    \"\"\"Test if linker on system needs libatomic.\"\"\"\n    code_test = (\n        b\"#include <atomic>\\n\"\n        + b\"int main() { return std::atomic<int64_t>{}; }\"\n    )\n    cxx = os.environ.get(\"CXX\", \"c++\")\n    cpp_test = subprocess.Popen(\n        [cxx, \"-x\", \"c++\", \"-std=c++17\", \"-\"],\n        stdin=PIPE,\n        stdout=PIPE,\n        stderr=PIPE,\n    )\n    cpp_test.communicate(input=code_test)\n    if cpp_test.returncode == 0:\n        return False\n    # Double-check to see if -latomic actually can solve the problem.\n    # https://github.com/grpc/grpc/issues/22491\n    cpp_test = subprocess.Popen(\n        [cxx, \"-x\", \"c++\", \"-std=c++17\", \"-\", \"-latomic\"],\n        stdin=PIPE,\n        stdout=PIPE,\n        stderr=PIPE,\n    )\n    cpp_test.communicate(input=code_test)\n    return cpp_test.returncode == 0",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "CXX",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "[cxx, \"-x\", \"c++\", \"-std=c++17\", \"-\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.Popen.communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "code_test",
                  "object_description": "Script file content",
                  "object_id": "script_file_content",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "[cxx, \"-x\", \"c++\", \"-std=c++17\", \"-\", \"-latomic\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.Popen.communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "code_test",
                  "object_description": "Script file content",
                  "object_id": "script_file_content",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "lmdb-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/lmdb-1.6.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/lmdb-1.6.2/lmdb-1.6.2/setup.py",
          "line_number": "117",
          "type_description": "code-execution",
          "context_snippet": "    # Copy away the lmdb source then patch it\n    if sys.platform.startswith('win'):\n        patchfile = 'lib' + os.sep + 'py-lmdb' + os.sep + 'env-copy-txn.patch'\n        patchset = patch.fromfile(patchfile)\n        rv = patchset.apply(2, root=dest)\n        if not rv:\n            raise Exception('Applying patch failed')\n    else:\n        rv = os.system('patch -N -p3 -d build/lib < lib/py-lmdb/env-copy-txn.patch')\n        if rv:\n            raise Exception('Applying patch failed')",
          "hash_value": "78135af3ecb7638cbea062212296fe03",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "    # Copy away the lmdb source then patch it\n    if sys.platform.startswith('win'):\n        patchfile = 'lib' + os.sep + 'py-lmdb' + os.sep + 'env-copy-txn.patch'\n        patchset = patch.fromfile(patchfile)\n        rv = patchset.apply(2, root=dest)\n        if not rv:\n            raise Exception('Applying patch failed')\n    else:\n        rv = os.system('patch -N -p3 -d build/lib < lib/py-lmdb/env-copy-txn.patch')\n        if rv:\n            raise Exception('Applying patch failed')",
              "triple_sequences": [
                {
                  "action_api": "sys.platform.startswith()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "'win'",
                  "object_description": "String containing environment data",
                  "object_id": "string_environment_data",
                  "intention_description": "Determine operating system",
                  "intention_id": "get_operating_system_name"
                },
                {
                  "action_api": "os.sep",
                  "action_description": "Retrieves operating system path separator",
                  "action_id": "get_os_path_sep",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "patch.fromfile()",
                  "action_description": "Opens file for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "patchfile",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "patchset.apply()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "2, root=dest",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "patch -N -p3 -d build/lib < lib/py-lmdb/env-copy-txn.patch",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "monty-2025",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/monty-2025.3.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "tasks.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/monty-2025.3.3/monty-2025.3.3/tasks.py",
          "line_number": "120",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "import os\nimport json\nimport re\nimport requests\nfrom invoke import task\n\nNEW_VER = datetime.datetime.today().strftime(\"%Y.%-m.%-d\")\n\n@task\ndef release_github(ctx: Context) -> None:\n    with open(\"docs/changelog.md\", encoding=\"utf-8\") as f:\n        contents = f.read()\n    toks = re.split(\"##\", contents)\n    desc = toks[1].strip()\n    payload = {\n        \"tag_name\": f\"v{NEW_VER}\",\n        \"target_commitish\": \"master\",\n        \"name\": f\"v{NEW_VER}\",\n        \"body\": desc,\n        \"draft\": False,\n        \"prerelease\": False,\n    }\n\n    response = requests.post(\n        \"https://api.github.com/repos/materialsvirtuallab/monty/releases\",\n        data=json.dumps(payload),\n        headers={\"Authorization\": \"token \" + os.environ[\"GITHUB_RELEASES_TOKEN\"]},\n    )\n    print(response.text)",
          "hash_value": "992d227b6417f7c0ea02a4bad305e1ae",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport json\nimport re\nimport requests\nfrom invoke import task\n\nNEW_VER = datetime.datetime.today().strftime(\"%Y.%-m.%-d\")\n\n@task\ndef release_github(ctx: Context) -> None:\n    with open(\"docs/changelog.md\", encoding=\"utf-8\") as f:\n        contents = f.read()\n    toks = re.split(\"##\", contents)\n    desc = toks[1].strip()\n    payload = {\n        \"tag_name\": f\"v{NEW_VER}\",\n        \"target_commitish\": \"master\",\n        \"name\": f\"v{NEW_VER}\",\n        \"body\": desc,\n        \"draft\": False,\n        \"prerelease\": False,\n    }\n\n    response = requests.post(\n        \"https://api.github.com/repos/materialsvirtuallab/monty/releases\",\n        data=json.dumps(payload),\n        headers={\"Authorization\": \"token \" + os.environ[\"GITHUB_RELEASES_TOKEN\"]},\n    )\n    print(response.text)",
              "triple_sequences": [
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "docs/changelog.md",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "Script file content",
                  "object_id": "script_file_content",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "re.split()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "\"##\", contents",
                  "object_description": "Regex file content",
                  "object_id": "regex_file_content",
                  "intention_description": "Prepare string processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "str.strip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "json.dumps()",
                  "action_description": "Serializes Python object to JSON string",
                  "action_id": "serialize_to_json",
                  "object": "payload",
                  "object_description": "JSON string",
                  "object_id": "json_string",
                  "intention_description": "Serialize data",
                  "intention_id": "serialize_data"
                },
                {
                  "action_api": "os.environ[]",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "GITHUB_RELEASES_TOKEN",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "requests.post()",
                  "action_description": "Opens URL with POST data",
                  "action_id": "open_url_post",
                  "object": "https://api.github.com/repos/materialsvirtuallab/monty/releases",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Transmit data HTTP POST",
                  "intention_id": "transmit_data_http_post"
                },
                {
                  "action_api": "print()",
                  "action_description": "Reads user input from standard input",
                  "action_id": "read_user_input",
                  "object": "response.text",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pythonnet-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pythonnet-3.0.5.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pythonnet-3.0.5/pythonnet-3.0.5/setup.py",
          "line_number": "74",
          "type_description": "code-execution",
          "context_snippet": "import distutils\nimport os\n\nclass build_dotnet(Command):\n    \"\"\"Build command for dotnet-cli based builds\"\"\"\n\n    description = \"Build DLLs with dotnet-cli\"\n    user_options = [\n        (\"dotnet-config=\", None, \"dotnet build configuration\"),\n        (\n            \"inplace\",\n            \"i\",\n            \"ignore build-lib and put compiled extensions into the source \"\n            + \"directory alongside your pure Python modules\",\n        ),\n    ]\n\n    def initialize_options(self):\n        self.dotnet_config = None\n        self.build_lib = None\n        self.inplace = False\n\n    def finalize_options(self):\n        if self.dotnet_config is None:\n            self.dotnet_config = \"release\"\n\n        build = self.distribution.get_command_obj(\"build\")\n        build.ensure_finalized()\n        if self.inplace:\n            self.build_lib = \".\"\n        else:\n            self.build_lib = build.build_lib\n\n    def run(self):\n        dotnet_modules = self.distribution.dotnet_libs\n\n        for lib in dotnet_modules:\n            output = os.path.join(\n                os.path.abspath(self.build_lib), lib.args.pop(\"output\")\n            )\n            rename = lib.args.pop(\"rename\", {})\n\n            opts = sum(\n                [\n                    [\"--\" + name.replace(\"_\", \"-\"), value]\n                    for name, value in lib.args.items()\n                ],\n                [],\n            )\n\n            opts.extend([\"--configuration\", self.dotnet_config])\n            opts.extend([\"--output\", output])\n\n            self.announce(\"Running dotnet build...\", level=distutils.log.INFO)\n            self.spawn([\"dotnet\", \"build\", lib.path] + opts)\n\n            for k, v in rename.items():\n                source = os.path.join(output, k)\n                dest = os.path.join(output, v)\n\n                if os.path.isfile(source):\n                    try:\n                        os.remove(dest)\n                    except OSError:\n                        pass\n\n                    self.move_file(src=source, dst=dest, level=distutils.log.INFO)\n                else:\n                    self.warn(\n                        \"Can't find file to rename: {}, current dir: {}\".format(\n                            source, os.getcwd()\n                        )\n                    )",
          "hash_value": "2721f46bc46b8d8cbf3639b1d06f5cf6",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import distutils\nimport os\n\nclass build_dotnet(Command):\n    \"\"\"Build command for dotnet-cli based builds\"\"\"\n\n    description = \"Build DLLs with dotnet-cli\"\n    user_options = [\n        (\"dotnet-config=\", None, \"dotnet build configuration\"),\n        (\n            \"inplace\",\n            \"i\",\n            \"ignore build-lib and put compiled extensions into the source \"\n            + \"directory alongside your pure Python modules\",\n        ),\n    ]\n\n    def initialize_options(self):\n        self.dotnet_config = None\n        self.build_lib = None\n        self.inplace = False\n\n    def finalize_options(self):\n        if self.dotnet_config is None:\n            self.dotnet_config = \"release\"\n\n        build = self.distribution.get_command_obj(\"build\")\n        build.ensure_finalized()\n        if self.inplace:\n            self.build_lib = \".\"\n        else:\n            self.build_lib = build.build_lib\n\n    def run(self):\n        dotnet_modules = self.distribution.dotnet_libs\n\n        for lib in dotnet_modules:\n            output = os.path.join(\n                os.path.abspath(self.build_lib), lib.args.pop(\"output\")\n            )\n            rename = lib.args.pop(\"rename\", {})\n\n            opts = sum(\n                [\n                    [\"--\" + name.replace(\"_\", \"-\"), value]\n                    for name, value in lib.args.items()\n                ],\n                [],\n            )\n\n            opts.extend([\"--configuration\", self.dotnet_config])\n            opts.extend([\"--output\", output])\n\n            self.announce(\"Running dotnet build...\", level=distutils.log.INFO)\n            self.spawn([\"dotnet\", \"build\", lib.path] + opts)\n\n            for k, v in rename.items():\n                source = os.path.join(output, k)\n                dest = os.path.join(output, v)\n\n                if os.path.isfile(source):\n                    try:\n                        os.remove(dest)\n                    except OSError:\n                        pass\n\n                    self.move_file(src=source, dst=dest, level=distutils.log.INFO)\n                else:\n                    self.warn(\n                        \"Can't find file to rename: {}, current dir: {}\".format(\n                            source, os.getcwd()\n                        )\n                    )",
              "triple_sequences": [
                {
                  "action_api": "os.path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "self.build_lib",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.abspath(self.build_lib), lib.args.pop(\"output\")",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "lib.args.pop()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "\"output\"",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Prepare file for writing",
                  "intention_id": "prepare_file_writing"
                },
                {
                  "action_api": "lib.args.pop()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "\"rename\", {}",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Prepare file for writing",
                  "intention_id": "prepare_file_writing"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "output, k",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "output, v",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.isfile()",
                  "action_description": "Checks if specified path exists and is a file",
                  "action_id": "check_file_is_file",
                  "object": "source",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Determine presence of file",
                  "intention_id": "determine_file_presence"
                },
                {
                  "action_api": "os.remove()",
                  "action_description": "Deletes specified file from filesystem",
                  "action_id": "delete_file",
                  "object": "dest",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Delete file",
                  "intention_id": "delete_file"
                },
                {
                  "action_api": "self.move_file()",
                  "action_description": "Moves file to destination",
                  "action_id": "move_file",
                  "object": "src=source, dst=dest, level=distutils.log.INFO",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Move file to destination",
                  "intention_id": "move_file_destination"
                },
                {
                  "action_api": "os.getcwd()",
                  "action_description": "Returns current working directory",
                  "action_id": "get_working_dir",
                  "object": "",
                  "object_description": "Current working directory",
                  "object_id": "current_working_directory",
                  "intention_description": "Collect current working directory",
                  "intention_id": "collect_working_directory"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pillow-simd-9",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pillow-simd-9.5.0.post2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pillow-simd-9.5.0.post2/Pillow-SIMD-9.5.0.post2/setup.py",
          "line_number": "182",
          "type_description": "code-execution",
          "context_snippet": "def _find_library_dirs_ldconfig():\n    # Based on ctypes.util from Python 2\n\n    if sys.platform.startswith(\"linux\") or sys.platform.startswith(\"gnu\"):\n        if struct.calcsize(\"l\") == 4:\n            machine = os.uname()[4] + \"-32\"\n        else:\n            machine = os.uname()[4] + \"-64\"\n        mach_map = {\n            \"x86_64-64\": \"libc6,x86-64\",\n            \"ppc64-64\": \"libc6,64bit\",\n            \"sparc64-64\": \"libc6,64bit\",\n            \"s390x-64\": \"libc6,64bit\",\n            \"ia64-64\": \"libc6,IA-64\",\n        }\n        abi_type = mach_map.get(machine, \"libc6\")\n\n        # Assuming GLIBC's ldconfig (with option -p)\n        # Alpine Linux uses musl that can't print cache\n        args = [\"ldconfig\", \"-p\"]\n        expr = rf\".*\\({abi_type}.*\\) => (.*)\"\n        env = dict(os.environ)\n        env[\"LC_ALL\"] = \"C\"\n        env[\"LANG\"] = \"C\"\n\n    elif sys.platform.startswith(\"freebsd\"):\n        args = [\"ldconfig\", \"-r\"]\n        expr = r\".* => (.*)\"\n        env = {}\n\n    try:\n        p = subprocess.Popen(\n            args, stderr=subprocess.DEVNULL, stdout=subprocess.PIPE, env=env\n        )\n    except OSError:  # E.g. command not found\n        return []\n    [data, _] = p.communicate()\n    if isinstance(data, bytes):\n        data = data.decode(\"latin1\")\n\n    dirs = []\n    for dll in re.findall(expr, data):\n        dir = os.path.dirname(dll)\n        if dir not in dirs:\n            dirs.append(dir)\n    return dirs",
          "hash_value": "002afc3a3024c789b66889a40dd25bb5",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def _find_library_dirs_ldconfig():\n    # Based on ctypes.util from Python 2\n\n    if sys.platform.startswith(\"linux\") or sys.platform.startswith(\"gnu\"):\n        if struct.calcsize(\"l\") == 4:\n            machine = os.uname()[4] + \"-32\"\n        else:\n            machine = os.uname()[4] + \"-64\"\n        mach_map = {\n            \"x86_64-64\": \"libc6,x86-64\",\n            \"ppc64-64\": \"libc6,64bit\",\n            \"sparc64-64\": \"libc6,64bit\",\n            \"s390x-64\": \"libc6,64bit\",\n            \"ia64-64\": \"libc6,IA-64\",\n        }\n        abi_type = mach_map.get(machine, \"libc6\")\n\n        # Assuming GLIBC's ldconfig (with option -p)\n        # Alpine Linux uses musl that can't print cache\n        args = [\"ldconfig\", \"-p\"]\n        expr = rf\".*\\({abi_type}.*\\) => (.*)\"\n        env = dict(os.environ)\n        env[\"LC_ALL\"] = \"C\"\n        env[\"LANG\"] = \"C\"\n\n    elif sys.platform.startswith(\"freebsd\"):\n        args = [\"ldconfig\", \"-r\"]\n        expr = r\".* => (.*)\"\n        env = {}\n\n    try:\n        p = subprocess.Popen(\n            args, stderr=subprocess.DEVNULL, stdout=subprocess.PIPE, env=env\n        )\n    except OSError:  # E.g. command not found\n        return []\n    [data, _] = p.communicate()\n    if isinstance(data, bytes):\n        data = data.decode(\"latin1\")\n\n    dirs = []\n    for dll in re.findall(expr, data):\n        dir = os.path.dirname(dll)\n        if dir not in dirs:\n            dirs.append(dir)\n    return dirs",
              "triple_sequences": [
                {
                  "action_api": "sys.platform.startswith()",
                  "action_description": "Retrieves operating system identifier",
                  "action_id": "get_os_id",
                  "object": "\"linux\"",
                  "object_description": "Operating system identifier",
                  "object_id": "",
                  "intention_description": "Determine operating system",
                  "intention_id": "determine_operating_system"
                },
                {
                  "action_api": "struct.calcsize()",
                  "action_description": "Retrieves system virtual memory statistics",
                  "action_id": "get_virtual_memory",
                  "object": "\"l\"",
                  "object_description": "Character code array",
                  "object_id": "character_code_array",
                  "intention_description": "Get system info",
                  "intention_id": "get_system_info"
                },
                {
                  "action_api": "os.uname()",
                  "action_description": "Retrieves operating system information",
                  "action_id": "get_os_info",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get system info",
                  "intention_id": "get_system_info"
                },
                {
                  "action_api": "os.environ",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "sys.platform.startswith()",
                  "action_description": "Retrieves operating system identifier",
                  "action_id": "get_os_id",
                  "object": "\"freebsd\"",
                  "object_description": "Operating system identifier",
                  "object_id": "",
                  "intention_description": "Determine operating system",
                  "intention_id": "determine_operating_system"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "args, stderr=subprocess.DEVNULL, stdout=subprocess.PIPE, env=env",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "p.communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "data, bytes",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "data.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "\"latin1\"",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                },
                {
                  "action_api": "re.findall()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "expr, data",
                  "object_description": "Regular expression and file content",
                  "object_id": "regex_file_content",
                  "intention_description": "Extract structured file data",
                  "intention_id": "extract_structured_file_data"
                },
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "dll",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "flair-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/flair-0.15.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "token.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/flair-0.15.1/flair-0.15.1/flair/embeddings/token.py",
          "line_number": "1579",
          "type_description": "shady-links",
          "context_snippet": "class NILCEmbeddings(WordEmbeddings):\n    def __init__(self, embeddings: str, model: str = \"skip\", size: int = 100) -> None:\n        \"\"\"Initializes portuguese classic word embeddings trained by NILC Lab.\n\n        See: http://www.nilc.icmc.usp.br/embeddings\n        Constructor downloads required files if not there.\n\n        Args:\n            embeddings: one of: 'fasttext', 'glove', 'wang2vec' or 'word2vec'\n            model: one of: 'skip' or 'cbow'. This is not applicable to glove.\n            size: one of: 50, 100, 300, 600 or 1000.\n        \"\"\"\n        self.instance_parameters = self.get_instance_parameters(locals=locals())\n\n        base_path = \"http://143.107.183.175:22980/download.php?file=embeddings/\"\n\n        cache_dir = Path(\"embeddings\") / (\"nilc-\" + embeddings.lower())\n\n        # GLOVE embeddings\n        if embeddings.lower() == \"glove\":\n            cached_path(f\"{base_path}{embeddings}/{embeddings}_s{size}.zip\", cache_dir=cache_dir)\n            embeddings_path = f\"{base_path}{embeddings}/{embeddings}_s{size}.zip\"\n\n        elif embeddings.lower() in [\"fasttext\", \"wang2vec\", \"word2vec\"]:\n            cached_path(f\"{base_path}{embeddings}/{model}_s{size}.zip\", cache_dir=cache_dir)\n            embeddings_path = f\"{base_path}{embeddings}/{model}_s{size}.zip\"\n\n        elif not Path(embeddings).exists():\n            raise ValueError(f'The given embeddings \"{embeddings}\" is not available or is not a valid path.')\n        else:\n            embeddings_path = embeddings\n\n        log.info(\"Reading embeddings from %s\", embeddings_path)\n        super().__init__(\n            embeddings=str(extract_single_zip_file(embeddings_path, cache_dir=cache_dir)), name=\"NILC-\" + embeddings\n        )",
          "hash_value": "dbb4e859363212f81c925738121ae573",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class NILCEmbeddings(WordEmbeddings):\n    def __init__(self, embeddings: str, model: str = \"skip\", size: int = 100) -> None:\n        \"\"\"Initializes portuguese classic word embeddings trained by NILC Lab.\n\n        See: http://www.nilc.icmc.usp.br/embeddings\n        Constructor downloads required files if not there.\n\n        Args:\n            embeddings: one of: 'fasttext', 'glove', 'wang2vec' or 'word2vec'\n            model: one of: 'skip' or 'cbow'. This is not applicable to glove.\n            size: one of: 50, 100, 300, 600 or 1000.\n        \"\"\"\n        self.instance_parameters = self.get_instance_parameters(locals=locals())\n\n        base_path = \"http://143.107.183.175:22980/download.php?file=embeddings/\"\n\n        cache_dir = Path(\"embeddings\") / (\"nilc-\" + embeddings.lower())\n\n        # GLOVE embeddings\n        if embeddings.lower() == \"glove\":\n            cached_path(f\"{base_path}{embeddings}/{embeddings}_s{size}.zip\", cache_dir=cache_dir)\n            embeddings_path = f\"{base_path}{embeddings}/{embeddings}_s{size}.zip\"\n\n        elif embeddings.lower() in [\"fasttext\", \"wang2vec\", \"word2vec\"]:\n            cached_path(f\"{base_path}{embeddings}/{model}_s{size}.zip\", cache_dir=cache_dir)\n            embeddings_path = f\"{base_path}{embeddings}/{model}_s{size}.zip\"\n\n        elif not Path(embeddings).exists():\n            raise ValueError(f'The given embeddings \"{embeddings}\" is not available or is not a valid path.')\n        else:\n            embeddings_path = embeddings\n\n        log.info(\"Reading embeddings from %s\", embeddings_path)\n        super().__init__(\n            embeddings=str(extract_single_zip_file(embeddings_path, cache_dir=cache_dir)), name=\"NILC-\" + embeddings\n        )",
              "triple_sequences": [
                {
                  "action_api": "Path()",
                  "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
                  "action_id": "path_object_operations",
                  "object": "\"embeddings\"",
                  "object_description": "Custom directory",
                  "object_id": "custom_directory",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "embeddings.lower()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "embeddings",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Prepare string processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "cached_path()",
                  "action_description": "Downloads file from URL to local path",
                  "action_id": "download_file_url",
                  "object": "f\"{base_path}{embeddings}/{embeddings}_s{size}.zip\", cache_dir=cache_dir",
                  "object_description": "External domain",
                  "object_id": "external_domain",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "cached_path()",
                  "action_description": "Downloads file from URL to local path",
                  "action_id": "download_file_url",
                  "object": "f\"{base_path}{embeddings}/{model}_s{size}.zip\", cache_dir=cache_dir",
                  "object_description": "External domain",
                  "object_id": "external_domain",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "Path().exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "embeddings",
                  "object_description": "Custom directory",
                  "object_id": "custom_directory",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "log.info()",
                  "action_description": "Process HTTP response content",
                  "action_id": "process_http_response",
                  "object": "\"Reading embeddings from %s\", embeddings_path",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Access file content",
                  "intention_id": "access_file_content"
                },
                {
                  "action_api": "extract_single_zip_file()",
                  "action_description": "Extracts all files from ZIP archive to specified directory",
                  "action_id": "extract_zip_files",
                  "object": "embeddings_path, cache_dir=cache_dir",
                  "object_description": "ZIP archive file",
                  "object_id": "zip_archive",
                  "intention_description": "Decompress downloaded archive",
                  "intention_id": "decompress_downloaded_archive"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pyobjc_core-11",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyobjc_core-11.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyobjc_core-11.0/pyobjc_core-11.0/setup.py",
          "line_number": "763",
          "type_description": "cmd-overwrite",
          "context_snippet": "sources = list(glob.glob(os.path.join(\"Modules\", \"objc\", \"*.m\")))\nsources.sort(key=lambda x: (-os.stat(x).st_mtime, x))\nsetup(\n    ext_modules=[\n        Extension(\n            \"objc._objc\",\n            sources,\n            extra_compile_args=CFLAGS,\n            extra_link_args=OBJC_LDFLAGS,\n            depends=sources,\n        ),\n        Extension(\n            \"objc._machsignals\",\n            [\"Modules/_machsignals.m\"],\n            extra_compile_args=EXT_CFLAGS,\n            extra_link_args=OBJC_LDFLAGS,\n        ),\n    ]\n    + [\n        Extension(\n            \"PyObjCTest.\" + os.path.splitext(os.path.basename(test_source))[0],\n            [test_source],\n            extra_compile_args=EXT_CFLAGS,\n            extra_link_args=OBJC_LDFLAGS,\n        )\n        for test_source in glob.glob(os.path.join(\"Modules\", \"objc\", \"test\", \"*.[mc]\"))\n    ],\n    cmdclass={\n        \"build_ext\": oc_build_ext,\n        \"install_lib\": oc_install_lib,\n        \"build_py\": oc_build_py,\n        \"test\": oc_test,\n        \"egg_info\": oc_egg_info,\n    },\n    package_dir={\"\": \"Lib\", \"PyObjCTest\": \"PyObjCTest\"},\n    options={\"egg_info\": {\"egg_base\": \"Lib\"}},\n    **parse_package_metadata(),\n)",
          "hash_value": "5711b67f7d184d622191e0149cc8470d",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "sources = list(glob.glob(os.path.join(\"Modules\", \"objc\", \"*.m\")))\nsources.sort(key=lambda x: (-os.stat(x).st_mtime, x))\nsetup(\n    ext_modules=[\n        Extension(\n            \"objc._objc\",\n            sources,\n            extra_compile_args=CFLAGS,\n            extra_link_args=OBJC_LDFLAGS,\n            depends=sources,\n        ),\n        Extension(\n            \"objc._machsignals\",\n            [\"Modules/_machsignals.m\"],\n            extra_compile_args=EXT_CFLAGS,\n            extra_link_args=OBJC_LDFLAGS,\n        ),\n    ]\n    + [\n        Extension(\n            \"PyObjCTest.\" + os.path.splitext(os.path.basename(test_source))[0],\n            [test_source],\n            extra_compile_args=EXT_CFLAGS,\n            extra_link_args=OBJC_LDFLAGS,\n        )\n        for test_source in glob.glob(os.path.join(\"Modules\", \"objc\", \"test\", \"*.[mc]\"))\n    ],\n    cmdclass={\n        \"build_ext\": oc_build_ext,\n        \"install_lib\": oc_install_lib,\n        \"build_py\": oc_build_py,\n        \"test\": oc_test,\n        \"egg_info\": oc_egg_info,\n    },\n    package_dir={\"\": \"Lib\", \"PyObjCTest\": \"PyObjCTest\"},\n    options={\"egg_info\": {\"egg_base\": \"Lib\"}},\n    **parse_package_metadata(),\n)",
              "triple_sequences": [
                {
                  "action_api": "glob.glob()",
                  "action_description": "List directory contents",
                  "action_id": "list_directory_contents",
                  "object": "os.path.join(\"Modules\", \"objc\", \"*.m\")",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "List files in directory",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "\"Modules\", \"objc\", \"*.m\"",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.stat()",
                  "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
                  "action_id": "path_object_operations",
                  "object": "x",
                  "object_description": "Local file or directory name",
                  "object_id": "local_file_or_directory_name",
                  "intention_description": "Access file content",
                  "intention_id": "access_file_content"
                },
                {
                  "action_api": "os.stat(x).st_mtime",
                  "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
                  "action_id": "path_object_operations",
                  "object": "x",
                  "object_description": "Local file or directory name",
                  "object_id": "local_file_or_directory_name",
                  "intention_description": "Access file content",
                  "intention_id": "access_file_content"
                },
                {
                  "action_api": "sources.sort()",
                  "action_description": "List directory contents",
                  "action_id": "list_directory_contents",
                  "object": "key=lambda x: (-os.stat(x).st_mtime, x)",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "List files in directory",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "glob.glob()",
                  "action_description": "List directory contents",
                  "action_id": "list_directory_contents",
                  "object": "os.path.join(\"Modules\", \"objc\", \"test\", \"*.[mc]\")",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "List files in directory",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "\"Modules\", \"objc\", \"test\", \"*.[mc]\"",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.splitext()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.basename(test_source)",
                  "object_description": "Local file or directory name",
                  "object_id": "local_file_or_directory_name",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.basename()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "test_source",
                  "object_description": "Local file or directory name",
                  "object_id": "local_file_or_directory_name",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "ext_modules, cmdclass, package_dir, options, **parse_package_metadata()",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                },
                {
                  "action_api": "parse_package_metadata()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "tensorrt_cu12-10",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/tensorrt_cu12-10.9.0.34.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/tensorrt_cu12-10.9.0.34/tensorrt_cu12-10.9.0.34/setup.py",
          "line_number": "111",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport subprocess\n\ndef parent_command_line():\n    \"\"\"Get the command line of the parent PID.\"\"\"\n    pid = os.getppid()\n\n    # try retrieval using psutil\n    try:\n        import psutil\n\n        return \" \".join(psutil.Process(pid).cmdline())\n    except:\n        pass\n    # fall back to shell\n    try:\n        return subprocess.check_output([\"ps\", \"-p\", str(pid), \"-o\", \"command\", \"--no-headers\"]).decode()\n    except:\n        return \"\"",
          "hash_value": "7371096551054e75f02e9031e53e31bc",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport subprocess\n\ndef parent_command_line():\n    \"\"\"Get the command line of the parent PID.\"\"\"\n    pid = os.getppid()\n\n    # try retrieval using psutil\n    try:\n        import psutil\n\n        return \" \".join(psutil.Process(pid).cmdline())\n    except:\n        pass\n    # fall back to shell\n    try:\n        return subprocess.check_output([\"ps\", \"-p\", str(pid), \"-o\", \"command\", \"--no-headers\"]).decode()\n    except:\n        return \"\"",
              "triple_sequences": [
                {
                  "action_api": "os.getppid()",
                  "action_description": "Retrieves process information",
                  "action_id": "get_process_info",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect process name",
                  "intention_id": "collect_process_name"
                },
                {
                  "action_api": "psutil.Process()",
                  "action_description": "Retrieves process information",
                  "action_id": "get_process_info",
                  "object": "pid",
                  "object_description": "Process ID",
                  "object_id": "process_id",
                  "intention_description": "Collect process name",
                  "intention_id": "collect_process_name"
                },
                {
                  "action_api": "psutil.Process().cmdline()",
                  "action_description": "Retrieves command-line arguments passed to script",
                  "action_id": "get_cmd_args",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access command line arguments",
                  "intention_id": "access_command_line_arguments"
                },
                {
                  "action_api": "str.join()",
                  "action_description": "Join characters into string",
                  "action_id": "convert_integers_to_chars",
                  "object": "psutil.Process(pid).cmdline()",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                },
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"ps\", \"-p\", str(pid), \"-o\", \"command\", \"--no-headers\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "bytes.decode()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "restrictedpython-8",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/restrictedpython-8.1a1.dev0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "Guards.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/restrictedpython-8.1a1.dev0/restrictedpython-8.1a1.dev0/src/RestrictedPython/Guards.py",
          "line_number": "109",
          "type_description": "obfuscation",
          "context_snippet": "import builtins\n\nsafe_builtins = {}\n\n_safe_names = [\n    '__build_class__',\n    'None',\n    'False',\n    'True',\n    'abs',\n    'bool',\n    'bytes',\n    'callable',\n    'chr',\n    'complex',\n    'divmod',\n    'float',\n    'hash',\n    'hex',\n    'id',\n    'int',\n    'isinstance',\n    'issubclass',\n    'len',\n    'oct',\n    'ord',\n    'pow',\n    'range',\n    'repr',\n    'round',\n    'slice',\n    'sorted',\n    'str',\n    'tuple',\n    'zip'\n]\n\nfor name in _safe_names:\n    safe_builtins[name] = getattr(builtins, name)\n",
          "hash_value": "d750dc4ddb4723ec44e53ca259cb2282",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import builtins\n\nsafe_builtins = {}\n\n_safe_names = [\n    '__build_class__',\n    'None',\n    'False',\n    'True',\n    'abs',\n    'bool',\n    'bytes',\n    'callable',\n    'chr',\n    'complex',\n    'divmod',\n    'float',\n    'hash',\n    'hex',\n    'id',\n    'int',\n    'isinstance',\n    'issubclass',\n    'len',\n    'oct',\n    'ord',\n    'pow',\n    'range',\n    'repr',\n    'round',\n    'slice',\n    'sorted',\n    'str',\n    'tuple',\n    'zip'\n]\n\nfor name in _safe_names:\n    safe_builtins[name] = getattr(builtins, name)\n",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "builtins, name",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "cosmicfrog-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/cosmicfrog-1.0.6.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cosmicfrog-1.0.6/cosmicfrog-1.0.6/setup.py",
          "line_number": "9",
          "type_description": "code-execution",
          "context_snippet": "import subprocess\nfrom setuptools import setup\n\n\ntry:\n    subprocess.check_output(['pip', 'show', 'psycopg2'])\n    PSYCOPG2_INSTALLED = True\nexcept subprocess.CalledProcessError:\n    PSYCOPG2_INSTALLED = False",
          "hash_value": "c618e556ca85392a00ec654fa7d4a7f6",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import subprocess\nfrom setuptools import setup\n\n\ntry:\n    subprocess.check_output(['pip', 'show', 'psycopg2'])\n    PSYCOPG2_INSTALLED = True\nexcept subprocess.CalledProcessError:\n    PSYCOPG2_INSTALLED = False",
              "triple_sequences": [
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "['pip', 'show', 'psycopg2']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "fiona-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/fiona-1.10.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/fiona-1.10.1/fiona-1.10.1/setup.py",
          "line_number": "25",
          "type_description": "code-execution",
          "context_snippet": "import subprocess\n\ndef check_output(cmd):\n    return subprocess.check_output(cmd).decode('utf')",
          "hash_value": "813e325cdd4a6ba15b1ea93a0cc9e17b",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import subprocess\n\ndef check_output(cmd):\n    return subprocess.check_output(cmd).decode('utf')",
              "triple_sequences": [
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "cmd",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "str.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "'utf'",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "leafmap-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/leafmap-0.43.5.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "plotlymap.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/leafmap-0.43.5/leafmap-0.43.5/leafmap/plotlymap.py",
          "line_number": "159",
          "type_description": "shady-links",
          "context_snippet": "    def add_controls(self, controls: List) -> None:\n        \"\"\"Adds controls to the map.\n\n        Args:\n            controls (list): List of controls to add, e.g., ['drawline', 'drawopenpath', 'drawclosedpath', 'drawcircle', 'drawrect', 'eraseshape'] See https://bit.ly/33Tmqxr\n        \"\"\"\n        if isinstance(controls, str):\n            controls = [controls]\n        elif not isinstance(controls, list):\n            raise ValueError(\n                \"Controls must be a string or a list of strings. See https://bit.ly/33Tmqxr\"\n            )\n\n        self.update_layout(modebar_add=controls)",
          "hash_value": "775f9bf2f4cbc6e78d58b038aad08fa2",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "    def add_controls(self, controls: List) -> None:\n        \"\"\"Adds controls to the map.\n\n        Args:\n            controls (list): List of controls to add, e.g., ['drawline', 'drawopenpath', 'drawclosedpath', 'drawcircle', 'drawrect', 'eraseshape'] See https://bit.ly/33Tmqxr\n        \"\"\"\n        if isinstance(controls, str):\n            controls = [controls]\n        elif not isinstance(controls, list):\n            raise ValueError(\n                \"Controls must be a string or a list of strings. See https://bit.ly/33Tmqxr\"\n            )\n\n        self.update_layout(modebar_add=controls)",
              "triple_sequences": [
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "controls, str",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine required module presence",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "controls, list",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine required module presence",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "self.update_layout()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "modebar_add=controls",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Modify builtins and execute code",
                  "intention_id": "modify_builtins_execute_code"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "blis-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/blis-1.3.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/blis-1.3.0/blis-1.3.0/setup.py",
          "line_number": "177",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport subprocess\nimport platform\n\nclass ExtensionBuilder(build_ext, build_ext_options):\n    ...\n    def check_compiler_flag(self, flag):\n        supports_flag = True\n        DEVNULL = os.open(os.devnull, os.O_RDWR)\n        try:\n            subprocess.check_call(\n                \" \".join(self.compiler.compiler)\n                + \" -march={flag} -E -xc - -o -\".format(flag=flag),\n                stdin=DEVNULL,\n                stdout=DEVNULL,\n                stderr=DEVNULL,\n                shell=True,\n            )\n        except Exception:\n            supports_flag = False\n        os.close(DEVNULL)\n        return supports_flag",
          "hash_value": "9156a54d45094b11c77e6f58d8fceab9",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport subprocess\nimport platform\n\nclass ExtensionBuilder(build_ext, build_ext_options):\n    ...\n    def check_compiler_flag(self, flag):\n        supports_flag = True\n        DEVNULL = os.open(os.devnull, os.O_RDWR)\n        try:\n            subprocess.check_call(\n                \" \".join(self.compiler.compiler)\n                + \" -march={flag} -E -xc - -o -\".format(flag=flag),\n                stdin=DEVNULL,\n                stdout=DEVNULL,\n                stderr=DEVNULL,\n                shell=True,\n            )\n        except Exception:\n            supports_flag = False\n        os.close(DEVNULL)\n        return supports_flag",
              "triple_sequences": [
                {
                  "action_api": "os.open()",
                  "action_description": "Opens null device for writing",
                  "action_id": "open_null_device",
                  "object": "os.devnull, os.O_RDWR",
                  "object_description": "System null device",
                  "object_id": "system_null_device",
                  "intention_description": "Redirect standard output to null device",
                  "intention_id": "redirect_stdout_null"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "\" \".join(self.compiler.compiler) + \" -march={flag} -E -xc - -o -\".format(flag=flag)",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.close()",
                  "action_description": "Closes the opened file",
                  "action_id": "close_file",
                  "object": "DEVNULL",
                  "object_description": "System null device",
                  "object_id": "system_null_device",
                  "intention_description": "Close file",
                  "intention_id": "close_file"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "passlib-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/passlib-1.7.4.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "__init__.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/passlib-1.7.4/passlib-1.7.4/passlib/utils/compat/__init__.py",
          "line_number": "319",
          "type_description": "obfuscation",
          "context_snippet": "if PY3:\n    _lazy_attrs = dict(\n        BytesIO=\"io.BytesIO\",\n        UnicodeIO=\"io.StringIO\",\n        NativeStringIO=\"io.StringIO\",\n        SafeConfigParser=\"configparser.ConfigParser\",\n    )\n\n    print_ = getattr(builtins, \"print\")\n\nelse:\n    _lazy_attrs = dict(\n        BytesIO=\"cStringIO.StringIO\",\n        UnicodeIO=\"StringIO.StringIO\",\n        NativeStringIO=\"cStringIO.StringIO\",\n        SafeConfigParser=\"ConfigParser.SafeConfigParser\",\n    )\n\n    def print_(*args, **kwds):\n        \"\"\"The new-style print function.\"\"\"\n        # extract kwd args\n        fp = kwds.pop(\"file\", sys.stdout)\n        sep = kwds.pop(\"sep\", None)\n        end = kwds.pop(\"end\", None)\n        if kwds:\n            raise TypeError(\"invalid keyword arguments\")\n\n        # short-circuit if no target\n        if fp is None:\n            return\n\n        # use unicode or bytes ?\n        want_unicode = isinstance(sep, unicode) or isinstance(end, unicode) or \\\n                       any(isinstance(arg, unicode) for arg in args)\n\n        # pick default end sequence\n        if end is None:\n            end = u(\"\\n\") if want_unicode else \"\\n\"\n        elif not isinstance(end, unicode_or_bytes_types):\n            raise TypeError(\"end must be None or a string\")\n\n        # pick default separator\n        if sep is None:\n            sep = u(\" \") if want_unicode else \" \"\n        elif not isinstance(sep, unicode_or_bytes_types):\n            raise TypeError(\"sep must be None or a string\")\n\n        # write to buffer\n        first = True\n        write = fp.write\n        for arg in args:\n            if first:\n                first = False\n            else:\n                write(sep)\n            if not isinstance(arg, basestring):\n                arg = str(arg)\n            write(arg)\n        write(end)\n\n# Data dependencies:\n# - PY3: defined as 'PY3 = sys.version_info >= (3,0)'\n# - builtins: imported as 'import builtins' if PY3 else 'import __builtin__ as builtins'\n# - print_: assigned here as 'print_ = getattr(builtins, \"print\")' if PY3, else defined as a function\n# - _lazy_attrs: assigned in both branches\n# - sys: imported at top\n# - u, unicode_or_bytes_types: defined earlier in the file",
          "hash_value": "e7844fdb6d4523a5b4bfdbe0b84a98f7",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "if PY3:\n    _lazy_attrs = dict(\n        BytesIO=\"io.BytesIO\",\n        UnicodeIO=\"io.StringIO\",\n        NativeStringIO=\"io.StringIO\",\n        SafeConfigParser=\"configparser.ConfigParser\",\n    )\n\n    print_ = getattr(builtins, \"print\")\n\nelse:\n    _lazy_attrs = dict(\n        BytesIO=\"cStringIO.StringIO\",\n        UnicodeIO=\"StringIO.StringIO\",\n        NativeStringIO=\"cStringIO.StringIO\",\n        SafeConfigParser=\"ConfigParser.SafeConfigParser\",\n    )\n\n    def print_(*args, **kwds):\n        \"\"\"The new-style print function.\"\"\"\n        # extract kwd args\n        fp = kwds.pop(\"file\", sys.stdout)\n        sep = kwds.pop(\"sep\", None)\n        end = kwds.pop(\"end\", None)\n        if kwds:\n            raise TypeError(\"invalid keyword arguments\")\n\n        # short-circuit if no target\n        if fp is None:\n            return\n\n        # use unicode or bytes ?\n        want_unicode = isinstance(sep, unicode) or isinstance(end, unicode) or \\\n                       any(isinstance(arg, unicode) for arg in args)\n\n        # pick default end sequence\n        if end is None:\n            end = u(\"\\n\") if want_unicode else \"\\n\"\n        elif not isinstance(end, unicode_or_bytes_types):\n            raise TypeError(\"end must be None or a string\")\n\n        # pick default separator\n        if sep is None:\n            sep = u(\" \") if want_unicode else \" \"\n        elif not isinstance(sep, unicode_or_bytes_types):\n            raise TypeError(\"sep must be None or a string\")\n\n        # write to buffer\n        first = True\n        write = fp.write\n        for arg in args:\n            if first:\n                first = False\n            else:\n                write(sep)\n            if not isinstance(arg, basestring):\n                arg = str(arg)\n            write(arg)\n        write(end)\n\n# Data dependencies:\n# - PY3: defined as 'PY3 = sys.version_info >= (3,0)'\n# - builtins: imported as 'import builtins' if PY3 else 'import __builtin__ as builtins'\n# - print_: assigned here as 'print_ = getattr(builtins, \"print\")' if PY3, else defined as a function\n# - _lazy_attrs: assigned in both branches\n# - sys: imported at top\n# - u, unicode_or_bytes_types: defined earlier in the file",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "\"print\"",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "fp.write()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "arg, sep, end",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                },
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "sep, unicode; end, unicode; arg, unicode; end, unicode_or_bytes_types; sep, unicode_or_bytes_types; arg, basestring",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Prepare character for further processing",
                  "intention_id": "prepare_character_processing"
                },
                {
                  "action_api": "str()",
                  "action_description": "Encodes string to bytes using default encoding",
                  "action_id": "encode_string_to_bytes",
                  "object": "arg",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Encode string to bytes",
                  "intention_id": "encode_string_to_bytes"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "conda-4",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/conda-4.3.16.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "five.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/conda-4.3.16/conda-4.3.16/conda/_vendor/auxlib/_vendor/five.py",
          "line_number": "150",
          "type_description": "obfuscation",
          "context_snippet": "if PY3:  # pragma: no cover\n    import builtins\n\n    from itertools import zip_longest\n\n    map = map\n    zip = zip\n    string = str\n    string_t = str\n    long_t = int\n    text_t = str\n    range = range\n    int_types = (int,)\n    module_name_t = str\n\n    open_fqdn = 'builtins.open'\n\n    def items(d):\n        return d.items()\n\n    def keys(d):\n        return d.keys()\n\n    def values(d):\n        return d.values()\n\n    def nextfun(it):\n        return it.__next__\n\n    exec_ = getattr(builtins, 'exec')\n\n    def reraise(tp, value, tb=None):\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value",
          "hash_value": "c61bf7c1dafbdd2442b7a4de6a06a3f1",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "if PY3:  # pragma: no cover\n    import builtins\n\n    from itertools import zip_longest\n\n    map = map\n    zip = zip\n    string = str\n    string_t = str\n    long_t = int\n    text_t = str\n    range = range\n    int_types = (int,)\n    module_name_t = str\n\n    open_fqdn = 'builtins.open'\n\n    def items(d):\n        return d.items()\n\n    def keys(d):\n        return d.keys()\n\n    def values(d):\n        return d.values()\n\n    def nextfun(it):\n        return it.__next__\n\n    exec_ = getattr(builtins, 'exec')\n\n    def reraise(tp, value, tb=None):\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "builtins, 'exec'",
                  "object_description": "Builtin module",
                  "object_id": "builtin_module",
                  "intention_description": "Modify builtins and execute code",
                  "intention_id": "modify_builtins_execute_code"
                },
                {
                  "action_api": "d.items()",
                  "action_description": "Deserializes JSON string to Python object",
                  "action_id": "deserialize_from_json",
                  "object": "d",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "d.keys()",
                  "action_description": "Deserializes JSON string to Python object",
                  "action_id": "deserialize_from_json",
                  "object": "d",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "d.values()",
                  "action_description": "Deserializes JSON string to Python object",
                  "action_id": "deserialize_from_json",
                  "object": "d",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "it.__next__",
                  "action_description": "Runs asynchronous function until completion",
                  "action_id": "run_async_function",
                  "object": "it",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "raise value.with_traceback(tb)",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "value.with_traceback(tb)",
                  "object_description": "Exception type",
                  "object_id": "exception_type",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                },
                {
                  "action_api": "raise value",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "value",
                  "object_description": "Exception type",
                  "object_id": "exception_type",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "recommender_xblock-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/recommender_xblock-3.0.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/recommender_xblock-3.0.0/recommender_xblock-3.0.0/setup.py",
          "line_number": "35",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport subprocess\n\nclass XBlockInstall(_install):\n    \"\"\"Custom XBlock install command.\"\"\"\n\n    def run(self):\n        _install.run(self)\n        self.compile_translations()\n\n    def compile_translations(self):\n        \"\"\"\n        Compiles textual translations files(.po) to binary(.mo) files.\n        \"\"\"\n        self.announce('Compiling translations')\n        try:\n            for dirname, _, files in os.walk(os.path.join('recommender', 'translations')):\n                for fname in files:\n                    if os.path.splitext(fname)[1] == '.po':\n                        po_path = os.path.join(dirname, fname)\n                        mo_path = os.path.splitext(po_path)[0] + '.mo'\n                        self.announce('Compiling translation at %s' % po_path)\n                        subprocess.check_call(['msgfmt', po_path, '-o', mo_path], cwd=self.install_lib)\n        except Exception as ex:\n            self.announce('Translations compilation failed: %s' % getattr(ex, 'message', str(ex)))",
          "hash_value": "12ab2773bd385c051eb387b7bc1f50db",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport subprocess\n\nclass XBlockInstall(_install):\n    \"\"\"Custom XBlock install command.\"\"\"\n\n    def run(self):\n        _install.run(self)\n        self.compile_translations()\n\n    def compile_translations(self):\n        \"\"\"\n        Compiles textual translations files(.po) to binary(.mo) files.\n        \"\"\"\n        self.announce('Compiling translations')\n        try:\n            for dirname, _, files in os.walk(os.path.join('recommender', 'translations')):\n                for fname in files:\n                    if os.path.splitext(fname)[1] == '.po':\n                        po_path = os.path.join(dirname, fname)\n                        mo_path = os.path.splitext(po_path)[0] + '.mo'\n                        self.announce('Compiling translation at %s' % po_path)\n                        subprocess.check_call(['msgfmt', po_path, '-o', mo_path], cwd=self.install_lib)\n        except Exception as ex:\n            self.announce('Translations compilation failed: %s' % getattr(ex, 'message', str(ex)))",
              "triple_sequences": [
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "('recommender', 'translations')",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.walk()",
                  "action_description": "List directory contents",
                  "action_id": "list_directory_contents",
                  "object": "os.path.join('recommender', 'translations')",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "List files in directory",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "os.path.splitext()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "fname",
                  "object_description": "Local file or directory name",
                  "object_id": "local_file_or_directory_name",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "(dirname, fname)",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.splitext()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "po_path",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "['msgfmt', po_path, '-o', mo_path]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "liquidpy-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/liquidpy-0.8.4.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "liquid.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/liquidpy-0.8.4/liquidpy-0.8.4/liquid/liquid.py",
          "line_number": "124",
          "type_description": "obfuscation",
          "context_snippet": "if mode == \"wild\":\n    from .exts.wild import LiquidWildExtension\n    from .filters.wild import wild_filter_manager\n\n    self.env.add_extension(\"jinja2.ext.debug\")\n    self.env.add_extension(LiquidWildExtension)\n\n    bfilters = {\n        key: getattr(builtins, key)\n        for key in dir(builtins)\n        if not key.startswith(\"_\")\n        and callable(getattr(builtins, key))\n        and key\n        not in (\n            \"copyright\",\n            \"credits\",\n            \"input\",\n            \"help\",\n            \"globals\",\n            \"license\",\n            \"locals\",\n            \"memoryview\",\n            \"object\",\n            \"property\",\n            \"staticmethod\",\n            \"super\",\n        )\n        and not any(key_c.isupper() for key_c in key)\n    }\n    self.env.filters.update(bfilters)\n    wild_filter_manager.update_to_env(self.env)\n    self.env.globals.update(\n        {\n            key: val\n            for key, val in __builtins__.items()\n            if not key.startswith(\"_\")\n        }\n    )\n    if filters_as_globals:\n        self.env.globals.update(standard_filter_manager.filters)\n        self.env.globals.update(wild_filter_manager.filters)",
          "hash_value": "ad261e90c68a2cd2bfeab9129e3c49f4",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "if mode == \"wild\":\n    from .exts.wild import LiquidWildExtension\n    from .filters.wild import wild_filter_manager\n\n    self.env.add_extension(\"jinja2.ext.debug\")\n    self.env.add_extension(LiquidWildExtension)\n\n    bfilters = {\n        key: getattr(builtins, key)\n        for key in dir(builtins)\n        if not key.startswith(\"_\")\n        and callable(getattr(builtins, key))\n        and key\n        not in (\n            \"copyright\",\n            \"credits\",\n            \"input\",\n            \"help\",\n            \"globals\",\n            \"license\",\n            \"locals\",\n            \"memoryview\",\n            \"object\",\n            \"property\",\n            \"staticmethod\",\n            \"super\",\n        )\n        and not any(key_c.isupper() for key_c in key)\n    }\n    self.env.filters.update(bfilters)\n    wild_filter_manager.update_to_env(self.env)\n    self.env.globals.update(\n        {\n            key: val\n            for key, val in __builtins__.items()\n            if not key.startswith(\"_\")\n        }\n    )\n    if filters_as_globals:\n        self.env.globals.update(standard_filter_manager.filters)\n        self.env.globals.update(wild_filter_manager.filters)",
              "triple_sequences": [
                {
                  "action_api": "self.env.add_extension()",
                  "action_description": "Enables all Discord intents",
                  "action_id": "enable_discord_intents",
                  "object": "jinja2.ext.debug",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import required module",
                  "intention_id": "import_required_module"
                },
                {
                  "action_api": "self.env.add_extension()",
                  "action_description": "Enables all Discord intents",
                  "action_id": "enable_discord_intents",
                  "object": "LiquidWildExtension",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import required module",
                  "intention_id": "import_required_module"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, key",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "dir()",
                  "action_description": "Lists all currently alive threads",
                  "action_id": "list_threads",
                  "object": "builtins",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "self.env.filters.update()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "bfilters",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Modify builtins and execute code",
                  "intention_id": "modify_builtins_execute_code"
                },
                {
                  "action_api": "wild_filter_manager.update_to_env()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "self.env",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Modify builtins and execute code",
                  "intention_id": "modify_builtins_execute_code"
                },
                {
                  "action_api": "self.env.globals.update()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "{key: val for key, val in __builtins__.items() if not key.startswith(\"_\")}",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Modify builtins and execute code",
                  "intention_id": "modify_builtins_execute_code"
                },
                {
                  "action_api": "self.env.globals.update()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "standard_filter_manager.filters",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Modify builtins and execute code",
                  "intention_id": "modify_builtins_execute_code"
                },
                {
                  "action_api": "self.env.globals.update()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "wild_filter_manager.filters",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Modify builtins and execute code",
                  "intention_id": "modify_builtins_execute_code"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "paste-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/paste-3.10.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "cgitb_hook.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/paste-3.10.1/paste-3.10.1/paste/util/cgitb_hook.py",
          "line_number": "69",
          "type_description": "obfuscation",
          "context_snippet": "def lookup(name, frame, locals):\n    \"\"\"Find the value for a given name in the given environment.\"\"\"\n    if name in locals:\n        return 'local', locals[name]\n    if name in frame.f_globals:\n        return 'global', frame.f_globals[name]\n    if '__builtins__' in frame.f_globals:\n        builtins = frame.f_globals['__builtins__']\n        if isinstance(builtins, dict):\n            if name in builtins:\n                return 'builtin', builtins[name]\n        else:\n            if hasattr(builtins, name):\n                return 'builtin', getattr(builtins, name)\n    return None, __UNDEF__",
          "hash_value": "f4fac2b59320d2e573ff06f75258aa00",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def lookup(name, frame, locals):\n    \"\"\"Find the value for a given name in the given environment.\"\"\"\n    if name in locals:\n        return 'local', locals[name]\n    if name in frame.f_globals:\n        return 'global', frame.f_globals[name]\n    if '__builtins__' in frame.f_globals:\n        builtins = frame.f_globals['__builtins__']\n        if isinstance(builtins, dict):\n            if name in builtins:\n                return 'builtin', builtins[name]\n        else:\n            if hasattr(builtins, name):\n                return 'builtin', getattr(builtins, name)\n    return None, __UNDEF__",
              "triple_sequences": [
                {
                  "action_api": "name in locals",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "name, locals",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "locals[name]",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "locals[name]",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "name in frame.f_globals",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "name, frame.f_globals",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "frame.f_globals[name]",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "frame.f_globals[name]",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "'__builtins__' in frame.f_globals",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "'__builtins__', frame.f_globals",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "isinstance(builtins, dict)",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, dict",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "name in builtins",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "name, builtins",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "builtins[name]",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "builtins[name]",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "hasattr(builtins, name)",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, name",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "getattr(builtins, name)",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "getattr(builtins, name)",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pyfcm-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyfcm-2.0.8.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyfcm-2.0.8/pyfcm-2.0.8/setup.py",
          "line_number": "32",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport sys\nfrom setuptools import setup\n\ndef read(fname):\n    return open(os.path.join(os.path.dirname(__file__), fname)).read()\n\ninstall_requires = [\n    \"requests\",\n    \"urllib3>=1.26.0\",\n    \"google-auth>=2.22.0\",\n    \"aiohttp>=3.8.6\",\n]\ntests_require = [\"pytest\"]\n\n# We can't get the values using `from pyfcm import __meta__`, because this would import\n# the other modules too and raise an exception (dependencies are not installed at this point yet).\nmeta = {}\nexec(read(\"pyfcm/__meta__.py\"), meta)\n\nif sys.argv[-1] == \"publish\":\n    os.system(\"rm dist/*.gz dist/*.whl\")\n    os.system(\"git tag -a %s -m 'v%s'\" % (meta[\"__version__\"], meta[\"__version__\"]))\n    os.system(\"python -m build\")\n    os.system(\"twine upload dist/*\")\n    os.system(\"git push --tags\")\n    sys.exit()",
          "hash_value": "838f83ef21d2170bc75c6c90ed8b3e4d",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport sys\nfrom setuptools import setup\n\ndef read(fname):\n    return open(os.path.join(os.path.dirname(__file__), fname)).read()\n\ninstall_requires = [\n    \"requests\",\n    \"urllib3>=1.26.0\",\n    \"google-auth>=2.22.0\",\n    \"aiohttp>=3.8.6\",\n]\ntests_require = [\"pytest\"]\n\n# We can't get the values using `from pyfcm import __meta__`, because this would import\n# the other modules too and raise an exception (dependencies are not installed at this point yet).\nmeta = {}\nexec(read(\"pyfcm/__meta__.py\"), meta)\n\nif sys.argv[-1] == \"publish\":\n    os.system(\"rm dist/*.gz dist/*.whl\")\n    os.system(\"git tag -a %s -m 'v%s'\" % (meta[\"__version__\"], meta[\"__version__\"]))\n    os.system(\"python -m build\")\n    os.system(\"twine upload dist/*\")\n    os.system(\"git push --tags\")\n    sys.exit()",
              "triple_sequences": [
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "os.path.join(os.path.dirname(__file__), fname)",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.dirname(__file__), fname",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "exec()",
                  "action_description": "Dynamically executes Python code string",
                  "action_id": "exec_python_code",
                  "object": "read(\"pyfcm/__meta__.py\")",
                  "object_description": "Python code string",
                  "object_id": "python_code_string",
                  "intention_description": "Evaluate constructed code",
                  "intention_id": "evaluate_constructed_code"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "rm dist/*.gz dist/*.whl",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Delete file",
                  "intention_id": "delete_file"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "git tag -a %s -m 'v%s'",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "python -m build",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "twine upload dist/*",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "git push --tags",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "browserstack_sdk-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/browserstack_sdk-1.25.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "bstack11lll1l1l1l_opy_.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/browserstack_sdk-1.25.2/browserstack_sdk-1.25.2/bstack_utils/bstack11lll1l1l1l_opy_.py",
          "line_number": "41",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "import requests\nfrom urllib.parse import urljoin, urlencode\nfrom datetime import datetime\nimport os\nimport logging\nimport json\nlogger = logging.getLogger(__name__)\nclass bstack11lll11lll1_opy_:\n    @staticmethod\n    def bstack111l11ll111_opy_(bstack111l11l1lll_opy_):\n        bstack111l11l1ll1_opy_ = os.environ.get(bstack1l11l1l_opy_ (u\"ࠩࡅࡗࡤࡇ࠱࠲࡛ࡢࡎ࡜࡚ࠧᵧ\"), os.environ.get(bstack1l11l1l_opy_ (u\"ࠪࡆࡗࡕࡗࡔࡇࡕࡗ࡙ࡇࡃࡌࡡࡗࡉࡘ࡚ࡈࡖࡄࡢࡎ࡜࡚ࠧᵨ\"), bstack1l11l1l_opy_ (u\"ࠫࠬᵩ\")))\n        headers = {bstack1l11l1l_opy_ (u\"ࠬࡇࡵࡵࡪࡲࡶ࡮ࢀࡡࡵ࡫ࡲࡲࠬᵪ\"): bstack1l11l1l_opy_ (u\"࠭ࡂࡦࡣࡵࡩࡷࠦࡻࡾࠩᵫ\").format(bstack111l11l1ll1_opy_)}\n        response = requests.get(bstack111l11l1lll_opy_, headers=headers)\n        bstack111l11l1l11_opy_ = {}\n        try:\n            bstack111l11l1l11_opy_ = response.json()\n        except Exception as e:\n            logger.debug(bstack1l11l1l_opy_ (u\"ࠢࡇࡣ࡬ࡰࡪࡪࠠࡵࡱࠣࡴࡦࡸࡳࡦࠢࡍࡗࡔࡔࠠࡳࡧࡶࡴࡴࡴࡳࡦ࠼ࠣࡿࢂࠨᵬ\").format(e))\n            pass\n        if bstack111l11l1l11_opy_ is not None:\n            bstack111l11l1l11_opy_[bstack1l11l1l_opy_ (u\"ࠨࡰࡨࡼࡹࡥࡰࡰ࡮࡯ࡣࡹ࡯࡭ࡦࠩᵭ\")] = response.headers.get(bstack1l11l1l_opy_ (u\"ࠩࡱࡩࡽࡺ࡟ࡱࡱ࡯ࡰࡤࡺࡩ࡮ࡧࠪᵮ\"), str(int(datetime.now().timestamp() * 1000)))\n            bstack111l11l1l11_opy_[bstack1l11l1l_opy_ (u\"ࠪࡷࡹࡧࡴࡶࡵࠪᵯ\")] = response.status_code\n        return bstack111l11l1l11_opy_\n\ndef bstack1l11l1l_opy_ (bstack111_opy_):\n    global bstack1111l1_opy_\n    bstack1l1ll1_opy_ = ord (bstack111_opy_ [-1])\n    bstack1l1l_opy_ = bstack111_opy_ [:-1]\n    bstack11l1111_opy_ = bstack1l1ll1_opy_ % len (bstack1l1l_opy_)\n    bstack1l1_opy_ = bstack1l1l_opy_ [:bstack11l1111_opy_] + bstack1l1l_opy_ [bstack11l1111_opy_:]\n    if bstack111ll_opy_:\n        bstack111lll_opy_ = unicode () .join ([unichr (ord (char) - bstack11l11l1_opy_ - (bstack11lllll_opy_ + bstack1l1ll1_opy_) % bstack1l11l11_opy_) for bstack11lllll_opy_, char in enumerate (bstack1l1_opy_)])\n    else:\n        bstack111lll_opy_ = str () .join ([chr (ord (char) - bstack11l11l1_opy_ - (bstack11lllll_opy_ + bstack1l1ll1_opy_) % bstack1l11l11_opy_) for bstack11lllll_opy_, char in enumerate (bstack1l1_opy_)])\n    return eval (bstack111lll_opy_)\n\nbstack111ll_opy_ = sys.version_info [0] == 2\nbstack11l11l1_opy_ = 2048\nbstack1l11l11_opy_ = 7",
          "hash_value": "f38867afa51ab5d5f7b85575d3236b2e",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import requests\nfrom urllib.parse import urljoin, urlencode\nfrom datetime import datetime\nimport os\nimport logging\nimport json\nlogger = logging.getLogger(__name__)\nclass bstack11lll11lll1_opy_:\n    @staticmethod\n    def bstack111l11ll111_opy_(bstack111l11l1lll_opy_):\n        bstack111l11l1ll1_opy_ = os.environ.get(bstack1l11l1l_opy_ (u\"ࠩࡅࡗࡤࡇ࠱࠲࡛ࡢࡎ࡜࡚ࠧᵧ\"), os.environ.get(bstack1l11l1l_opy_ (u\"ࠪࡆࡗࡕࡗࡔࡇࡕࡗ࡙ࡇࡃࡌࡡࡗࡉࡘ࡚ࡈࡖࡄࡢࡎ࡜࡚ࠧᵨ\"), bstack1l11l1l_opy_ (u\"ࠫࠬᵩ\")))\n        headers = {bstack1l11l1l_opy_ (u\"ࠬࡇࡵࡵࡪࡲࡶ࡮ࢀࡡࡵ࡫ࡲࡲࠬᵪ\"): bstack1l11l1l_opy_ (u\"࠭ࡂࡦࡣࡵࡩࡷࠦࡻࡾࠩᵫ\").format(bstack111l11l1ll1_opy_)}\n        response = requests.get(bstack111l11l1lll_opy_, headers=headers)\n        bstack111l11l1l11_opy_ = {}\n        try:\n            bstack111l11l1l11_opy_ = response.json()\n        except Exception as e:\n            logger.debug(bstack1l11l1l_opy_ (u\"ࠢࡇࡣ࡬ࡰࡪࡪࠠࡵࡱࠣࡴࡦࡸࡳࡦࠢࡍࡗࡔࡔࠠࡳࡧࡶࡴࡴࡴࡳࡦ࠼ࠣࡿࢂࠨᵬ\").format(e))\n            pass\n        if bstack111l11l1l11_opy_ is not None:\n            bstack111l11l1l11_opy_[bstack1l11l1l_opy_ (u\"ࠨࡰࡨࡼࡹࡥࡰࡰ࡮࡯ࡣࡹ࡯࡭ࡦࠩᵭ\")] = response.headers.get(bstack1l11l1l_opy_ (u\"ࠩࡱࡩࡽࡺ࡟ࡱࡱ࡯ࡰࡤࡺࡩ࡮ࡧࠪᵮ\"), str(int(datetime.now().timestamp() * 1000)))\n            bstack111l11l1l11_opy_[bstack1l11l1l_opy_ (u\"ࠪࡷࡹࡧࡴࡶࡵࠪᵯ\")] = response.status_code\n        return bstack111l11l1l11_opy_\n\ndef bstack1l11l1l_opy_ (bstack111_opy_):\n    global bstack1111l1_opy_\n    bstack1l1ll1_opy_ = ord (bstack111_opy_ [-1])\n    bstack1l1l_opy_ = bstack111_opy_ [:-1]\n    bstack11l1111_opy_ = bstack1l1ll1_opy_ % len (bstack1l1l_opy_)\n    bstack1l1_opy_ = bstack1l1l_opy_ [:bstack11l1111_opy_] + bstack1l1l_opy_ [bstack11l1111_opy_:]\n    if bstack111ll_opy_:\n        bstack111lll_opy_ = unicode () .join ([unichr (ord (char) - bstack11l11l1_opy_ - (bstack11lllll_opy_ + bstack1l1ll1_opy_) % bstack1l11l11_opy_) for bstack11lllll_opy_, char in enumerate (bstack1l1_opy_)])\n    else:\n        bstack111lll_opy_ = str () .join ([chr (ord (char) - bstack11l11l1_opy_ - (bstack11lllll_opy_ + bstack1l1ll1_opy_) % bstack1l11l11_opy_) for bstack11lllll_opy_, char in enumerate (bstack1l1_opy_)])\n    return eval (bstack111lll_opy_)\n\nbstack111ll_opy_ = sys.version_info [0] == 2\nbstack11l11l1_opy_ = 2048\nbstack1l11l11_opy_ = 7",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "bstack1l11l1l_opy_ (u\"ࠩࡅࡗࡤࡇ࠱࠲࡛ࡢࡎ࡜࡚ࠧᵧ\")",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "bstack1l11l1l_opy_ (u\"ࠪࡆࡗࡕࡗࡔࡇࡕࡗ࡙ࡇࡃࡌࡡࡗࡉࡘ࡚ࡈࡖࡄࡢࡎ࡜࡚ࠧᵨ\")",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "bstack1l11l1l_opy_ (u\"ࠫࠬᵩ\")",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "bstack1l11l1l_opy_()",
                  "action_description": "Decodes obfuscated data",
                  "action_id": "decode_obfuscated_data",
                  "object": "u\"ࠬࡇࡵࡵࡪࡲࡶ࡮ࢀࡡࡵ࡫ࡲࡲࠬᵪ\"",
                  "object_description": "Obfuscated string",
                  "object_id": "obfuscated_string",
                  "intention_description": "Decode obfuscated data",
                  "intention_id": "decode_obfuscated_data"
                },
                {
                  "action_api": "bstack1l11l1l_opy_()",
                  "action_description": "Decodes obfuscated data",
                  "action_id": "decode_obfuscated_data",
                  "object": "u\"࠭ࡂࡦࡣࡵࡩࡷࠦࡻࡾࠩᵫ\"",
                  "object_description": "Obfuscated string",
                  "object_id": "obfuscated_string",
                  "intention_description": "Decode obfuscated data",
                  "intention_id": "decode_obfuscated_data"
                },
                {
                  "action_api": "str.format()",
                  "action_description": "Basic string formatting operation",
                  "action_id": "prepare_string_processing",
                  "object": "bstack111l11l1ll1_opy_",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "bstack111l11l1lll_opy_, headers=headers",
                  "object_description": "External domain",
                  "object_id": "external_domain",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "response.json()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "bstack1l11l1l_opy_()",
                  "action_description": "Decodes obfuscated data",
                  "action_id": "decode_obfuscated_data",
                  "object": "u\"ࠢࡇࡣ࡬ࡰࡪࡪࠠࡵࡱࠣࡴࡦࡸࡳࡦࠢࡍࡗࡔࡔࠠࡳࡧࡶࡴࡴࡴࡳࡦ࠼ࠣࡿࢂࠨᵬ\"",
                  "object_description": "Obfuscated string",
                  "object_id": "obfuscated_string",
                  "intention_description": "Decode obfuscated data",
                  "intention_id": "decode_obfuscated_data"
                },
                {
                  "action_api": "logger.debug()",
                  "action_description": "Writes log message to file or console",
                  "action_id": "write_file_content",
                  "object": "bstack1l11l1l_opy_ (u\"ࠢࡇࡣ࡬ࡰࡪࡪࠠࡵࡱࠣࡴࡦࡸࡳࡦࠢࡍࡗࡔࡔࠠࡳࡧࡶࡴࡴࡴࡳࡦ࠼ࠣࡿࢂࠨᵬ\").format(e)",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "bstack1l11l1l_opy_()",
                  "action_description": "Decodes obfuscated data",
                  "action_id": "decode_obfuscated_data",
                  "object": "u\"ࠨࡰࡨࡼࡹࡥࡰࡰ࡮࡯ࡣࡹ࡯࡭ࡦࠩᵭ\"",
                  "object_description": "Obfuscated string",
                  "object_id": "obfuscated_string",
                  "intention_description": "Decode obfuscated data",
                  "intention_id": "decode_obfuscated_data"
                },
                {
                  "action_api": "response.headers.get()",
                  "action_description": "Retrieves value of HTTP header from response",
                  "action_id": "add_http_header",
                  "object": "bstack1l11l1l_opy_ (u\"ࠩࡱࡩࡽࡺ࡟ࡱࡱ࡯ࡰࡤࡺࡩ࡮ࡧࠪᵮ\"), str(int(datetime.now().timestamp() * 1000))",
                  "object_description": "HTTP header",
                  "object_id": "http_header",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "bstack1l11l1l_opy_()",
                  "action_description": "Decodes obfuscated data",
                  "action_id": "decode_obfuscated_data",
                  "object": "u\"ࠪࡷࡹࡧࡴࡶࡵࠪᵯ\"",
                  "object_description": "Obfuscated string",
                  "object_id": "obfuscated_string",
                  "intention_description": "Decode obfuscated data",
                  "intention_id": "decode_obfuscated_data"
                },
                {
                  "action_api": "response.status_code",
                  "action_description": "Retrieves HTTP response status code",
                  "action_id": "get_http_status",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "ord()",
                  "action_description": "Converts character to integer Unicode code point",
                  "action_id": "convert_char_to_int",
                  "object": "bstack111_opy_ [-1]",
                  "object_description": "Character from obfuscated string",
                  "object_id": "character_from_obfuscated_string",
                  "intention_description": "Prepare character for further processing",
                  "intention_id": "prepare_character_processing"
                },
                {
                  "action_api": "ord()",
                  "action_description": "Converts character to integer Unicode code point",
                  "action_id": "convert_char_to_int",
                  "object": "char",
                  "object_description": "Character from obfuscated string",
                  "object_id": "character_from_obfuscated_string",
                  "intention_description": "Prepare character for further processing",
                  "intention_id": "prepare_character_processing"
                },
                {
                  "action_api": "chr()",
                  "action_description": "Converts integer to Unicode character",
                  "action_id": "convert_int_to_char",
                  "object": "ord (char) - bstack11l11l1_opy_ - (bstack11lllll_opy_ + bstack1l1ll1_opy_) % bstack1l11l11_opy_",
                  "object_description": "Character from obfuscated string",
                  "object_id": "character_from_obfuscated_string",
                  "intention_description": "Prepare character for further processing",
                  "intention_id": "prepare_character_processing"
                },
                {
                  "action_api": "eval()",
                  "action_description": "Evaluates string as Python expression",
                  "action_id": "eval_python_expr",
                  "object": "bstack111lll_opy_",
                  "object_description": "Obfuscated string",
                  "object_id": "obfuscated_string",
                  "intention_description": "Decode obfuscated code content",
                  "intention_id": "decode_obfuscated_code"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "mdanalysis-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/mdanalysis-2.9.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/mdanalysis-2.9.0/mdanalysis-2.9.0/setup.py",
          "line_number": "254",
          "type_description": "code-execution",
          "context_snippet": "from subprocess import getoutput\n\ndef using_clang():\n    \"\"\"Will we be using a clang compiler?\"\"\"\n    compiler = new_compiler()\n    customize_compiler(compiler)\n    compiler_ver = getoutput(\"{0} -v\".format(compiler.compiler[0]))\n    if \"Spack GCC\" in compiler_ver:\n        # when gcc toolchain is built from source with spack\n        # using clang, the 'clang' string may be present in\n        # the compiler metadata, but it is not clang\n        is_clang = False\n    elif \"clang\" in compiler_ver:\n        # by default, Apple will typically alias gcc to\n        # clang, with some mention of 'clang' in the\n        # metadata\n        is_clang = True\n    else:\n        is_clang = False\n    return is_clang",
          "hash_value": "c0198c7a120e141d63f43f1385190504",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from subprocess import getoutput\n\ndef using_clang():\n    \"\"\"Will we be using a clang compiler?\"\"\"\n    compiler = new_compiler()\n    customize_compiler(compiler)\n    compiler_ver = getoutput(\"{0} -v\".format(compiler.compiler[0]))\n    if \"Spack GCC\" in compiler_ver:\n        # when gcc toolchain is built from source with spack\n        # using clang, the 'clang' string may be present in\n        # the compiler metadata, but it is not clang\n        is_clang = False\n    elif \"clang\" in compiler_ver:\n        # by default, Apple will typically alias gcc to\n        # clang, with some mention of 'clang' in the\n        # metadata\n        is_clang = True\n    else:\n        is_clang = False\n    return is_clang",
              "triple_sequences": [
                {
                  "action_api": "getoutput()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "{0} -v",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "mod_wsgi-5",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/mod_wsgi-5.0.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/mod_wsgi-5.0.2/mod_wsgi-5.0.2/setup.py",
          "line_number": "135",
          "type_description": "code-execution",
          "context_snippet": "def get_apxs_config(query):\n    p = subprocess.Popen([APXS, '-q', query],\n            stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    out, err = p.communicate()\n    if isinstance(out, bytes):\n        out = out.decode('UTF-8')\n    return out.strip()\n\n# Data dependencies:\n# - subprocess: imported at top\n# - APXS: set via environment or find_program logic above\n# - query: function argument",
          "hash_value": "4f43ba07a76ff1de2e5a12199218bc53",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def get_apxs_config(query):\n    p = subprocess.Popen([APXS, '-q', query],\n            stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    out, err = p.communicate()\n    if isinstance(out, bytes):\n        out = out.decode('UTF-8')\n    return out.strip()\n\n# Data dependencies:\n# - subprocess: imported at top\n# - APXS: set via environment or find_program logic above\n# - query: function argument",
              "triple_sequences": [
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "[APXS, '-q', query]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "p.communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "out, bytes",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "out.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "'UTF-8'",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                },
                {
                  "action_api": "str.strip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "dbfread-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/dbfread-2.0.7.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/dbfread-2.0.7/dbfread-2.0.7/setup.py",
          "line_number": "16",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport sys\nimport dbfread\n\ntry:\n    from setuptools import setup\nexcept ImportError:\n    from distutils.core import setup\n\nif sys.argv[-1] == \"publish\":\n    os.system(\"python setup.py sdist upload\")\n    sys.exit()\n\nelif sys.argv[-1] == \"test\":\n    os.system(\"./run_tests.py\")\n    sys.exit()",
          "hash_value": "df2801590ba467f7c1d725c38e06af06",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport sys\nimport dbfread\n\ntry:\n    from setuptools import setup\nexcept ImportError:\n    from distutils.core import setup\n\nif sys.argv[-1] == \"publish\":\n    os.system(\"python setup.py sdist upload\")\n    sys.exit()\n\nelif sys.argv[-1] == \"test\":\n    os.system(\"./run_tests.py\")\n    sys.exit()",
              "triple_sequences": [
                {
                  "action_api": "sys.argv.__getitem__()",
                  "action_description": "Retrieves command-line arguments passed to script",
                  "action_id": "get_cmd_args",
                  "object": "-1",
                  "object_description": "Command-line arguments passed to script",
                  "object_id": "get_cmd_args",
                  "intention_description": "Access command line arguments",
                  "intention_id": "access_command_line_arguments"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "python setup.py sdist upload",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "./run_tests.py",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "fpdf-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/fpdf-1.7.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/fpdf-1.7.2/fpdf-1.7.2/setup.py",
          "line_number": "18",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport sys\nimport warnings\nimport subprocess\n\nimport fpdf\npackage_dir = 'fpdf'\n\n# convert the README and format in restructured text (only when registering)\nlong_desc = \"\"\nif os.path.exists(\"README.md\"):\n    try:\n        cmd = ['pandoc', '--from=markdown', '--to=rst', 'README.md']\n        long_desc = subprocess.check_output(cmd).decode(\"utf8\")\n    except Exception as e:\n        warnings.warn(\"Exception when converting the README format: %s\" % e)",
          "hash_value": "4eee34828fe3e53a9d3f38d68206ed53",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport sys\nimport warnings\nimport subprocess\n\nimport fpdf\npackage_dir = 'fpdf'\n\n# convert the README and format in restructured text (only when registering)\nlong_desc = \"\"\nif os.path.exists(\"README.md\"):\n    try:\n        cmd = ['pandoc', '--from=markdown', '--to=rst', 'README.md']\n        long_desc = subprocess.check_output(cmd).decode(\"utf8\")\n    except Exception as e:\n        warnings.warn(\"Exception when converting the README format: %s\" % e)",
              "triple_sequences": [
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "README.md",
                  "object_description": "Local file",
                  "object_id": "local_file",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "['pandoc', '--from=markdown', '--to=rst', 'README.md']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "bytes.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "\"utf8\"",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Decode bytes to string",
                  "intention_id": "decode_bytes_to_string"
                },
                {
                  "action_api": "warnings.warn()",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "\"Exception when converting the README format: %s\" % e",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "manimpango-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/manimpango-1.0.0a2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/manimpango-1.0.0a2/ManimPango-1.0.0a2/setup.py",
          "line_number": "95",
          "type_description": "code-execution",
          "context_snippet": "class PKG_CONFIG:\n    \"\"\"Preform operations with pkg-config.\n    Parameters\n    ==========\n    libname : :class:`str`\n        The library name to query.\n    \"\"\"\n\n    def __init__(self, libname: str) -> None:\n        self.name = libname\n        self.pkg_config = os.environ.get(\"PKG_CONFIG\", \"pkg-config\")\n        self.setup_argparse()\n        self.check_pkgconfig = self.check_pkgconfig()\n\n    def check_pkgconfig(self):\n        \"\"\"Check whether pkg-config works.\n        If it doesn't work raise a warning.\n        \"\"\"\n        try:\n            check_call([self.pkg_config, \"--version\"], stdout=subprocess.DEVNULL)\n            return True\n        except Exception:\n            warnings.warn(\n                f\"{self.pkg_config} doesn't exists or doesn't seem to work\\n\"\n                \"We assume that you give the compiler flags using\\n\"\n                \"corresponding environment variables.\",\n                RuntimeWarning,\n            )\n            return False",
          "hash_value": "5095f0392b49eb22545858d8e853ee16",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class PKG_CONFIG:\n    \"\"\"Preform operations with pkg-config.\n    Parameters\n    ==========\n    libname : :class:`str`\n        The library name to query.\n    \"\"\"\n\n    def __init__(self, libname: str) -> None:\n        self.name = libname\n        self.pkg_config = os.environ.get(\"PKG_CONFIG\", \"pkg-config\")\n        self.setup_argparse()\n        self.check_pkgconfig = self.check_pkgconfig()\n\n    def check_pkgconfig(self):\n        \"\"\"Check whether pkg-config works.\n        If it doesn't work raise a warning.\n        \"\"\"\n        try:\n            check_call([self.pkg_config, \"--version\"], stdout=subprocess.DEVNULL)\n            return True\n        except Exception:\n            warnings.warn(\n                f\"{self.pkg_config} doesn't exists or doesn't seem to work\\n\"\n                \"We assume that you give the compiler flags using\\n\"\n                \"corresponding environment variables.\",\n                RuntimeWarning,\n            )\n            return False",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"PKG_CONFIG\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[self.pkg_config, \"--version\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "warnings.warn()",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "f\"{self.pkg_config} doesn't exists or doesn't seem to work\\nWe assume that you give the compiler flags using\\ncorresponding environment variables.\", RuntimeWarning",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "macholib-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/macholib-1.16.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/macholib-1.16.3/macholib-1.16.3/setup.py",
          "line_number": "68",
          "type_description": "code-execution",
          "context_snippet": "def eval_marker(value):\n    \"\"\"\n    Evaluate an distutils2 environment marker.\n\n    This code is unsafe when used with hostile setup.cfg files,\n    but that's not a problem for our own files.\n    \"\"\"\n    value = value.strip()\n\n    class M:\n        def __init__(self, **kwds):\n            for k, v in kwds.items():\n                setattr(self, k, v)\n\n    variables = {\n        \"python_version\": \"%d.%d\" % (sys.version_info[0], sys.version_info[1]),\n        \"python_full_version\": sys.version.split()[0],\n        \"os\": M(name=os.name),\n        \"sys\": M(platform=sys.platform),\n        \"platform\": M(version=platform.version(), machine=platform.machine()),\n    }\n\n    return bool(eval(value, variables, variables))\n\n    return True",
          "hash_value": "77cb0be6426dca21c37567ddc987f604",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def eval_marker(value):\n    \"\"\"\n    Evaluate an distutils2 environment marker.\n\n    This code is unsafe when used with hostile setup.cfg files,\n    but that's not a problem for our own files.\n    \"\"\"\n    value = value.strip()\n\n    class M:\n        def __init__(self, **kwds):\n            for k, v in kwds.items():\n                setattr(self, k, v)\n\n    variables = {\n        \"python_version\": \"%d.%d\" % (sys.version_info[0], sys.version_info[1]),\n        \"python_full_version\": sys.version.split()[0],\n        \"os\": M(name=os.name),\n        \"sys\": M(platform=sys.platform),\n        \"platform\": M(version=platform.version(), machine=platform.machine()),\n    }\n\n    return bool(eval(value, variables, variables))\n\n    return True",
              "triple_sequences": [
                {
                  "action_api": "str.strip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "value",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "sys.version_info",
                  "action_description": "Retrieves Python interpreter version",
                  "action_id": "get_python_version",
                  "object": "sys.version_info",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get operating system version",
                  "intention_id": "get_operating_system_version"
                },
                {
                  "action_api": "sys.version.split()",
                  "action_description": "Retrieves Python interpreter version",
                  "action_id": "get_python_version",
                  "object": "sys.version.split()[0]",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get operating system version",
                  "intention_id": "get_operating_system_version"
                },
                {
                  "action_api": "os.name",
                  "action_description": "Retrieves operating system identifier",
                  "action_id": "get_os_id",
                  "object": "os.name",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get operating system name",
                  "intention_id": "get_operating_system_name"
                },
                {
                  "action_api": "sys.platform",
                  "action_description": "Retrieves platform information",
                  "action_id": "get_platform_info",
                  "object": "sys.platform",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get operating system name",
                  "intention_id": "get_operating_system_name"
                },
                {
                  "action_api": "platform.version()",
                  "action_description": "Retrieves operating system release version",
                  "action_id": "get_os_release",
                  "object": "platform.version()",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get operating system version",
                  "intention_id": "get_operating_system_version"
                },
                {
                  "action_api": "platform.machine()",
                  "action_description": "Retrieves machine type",
                  "action_id": "get_machine_type",
                  "object": "platform.machine()",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get system info",
                  "intention_id": "get_system_info"
                },
                {
                  "action_api": "eval()",
                  "action_description": "Evaluates string as Python expression",
                  "action_id": "eval_python_expr",
                  "object": "value, variables, variables",
                  "object_description": "Python code string",
                  "object_id": "python_code_string",
                  "intention_description": "Evaluate constructed code",
                  "intention_id": "evaluate_constructed_code"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pyproj-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyproj-3.7.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyproj-3.7.1/pyproj-3.7.1/setup.py",
          "line_number": "43",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nPROJ_VERSION_SEARCH = re.compile(r\".*Rel\\.\\s+(?P<version>\\d+\\.\\d+\\.\\d+).*\")\nVERSION_SEARCH = re.compile(r\".*(?P<version>\\d+\\.\\d+\\.\\d+).*\")\n\ndef _parse_version(version: str) -> tuple[int, int, int]:\n    match = VERSION_SEARCH.search(version)\n    if not match:\n        raise SystemExit(\n            f\"PROJ version unable to be determined from {version}. \"\n            \"Please set the PROJ_VERSION environment variable.\"\n        )\n    return tuple(\n        int(ver) for ver in match.groupdict()[\"version\"].split(\".\", maxsplit=2)\n    )\n\ndef get_proj_version(proj_dir: Path) -> tuple[int, int, int]:\n    \"\"\"\n    Determine PROJ version.\n\n    Prefer PROJ_VERSION environment variable.\n    If PROJ_VERSION is not set, try to determine the version from the PROJ executable.\n    \"\"\"\n    proj_version = os.environ.get(\"PROJ_VERSION\")\n    if proj_version:\n        return _parse_version(proj_version)\n    proj = proj_dir / \"bin\" / \"proj\"\n    proj_ver = subprocess.check_output(str(proj), stderr=subprocess.STDOUT).decode(\n        \"ascii\"\n    )\n    match = PROJ_VERSION_SEARCH.search(proj_ver)\n    if not match:\n        raise SystemExit(\n            \"PROJ version unable to be determined. \"\n            \"Please set the PROJ_VERSION environment variable.\"\n        )\n    return _parse_version(match.groupdict()[\"version\"])",
          "hash_value": "ad1d7fa8512e3446beb8ee554b9b68b6",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nPROJ_VERSION_SEARCH = re.compile(r\".*Rel\\.\\s+(?P<version>\\d+\\.\\d+\\.\\d+).*\")\nVERSION_SEARCH = re.compile(r\".*(?P<version>\\d+\\.\\d+\\.\\d+).*\")\n\ndef _parse_version(version: str) -> tuple[int, int, int]:\n    match = VERSION_SEARCH.search(version)\n    if not match:\n        raise SystemExit(\n            f\"PROJ version unable to be determined from {version}. \"\n            \"Please set the PROJ_VERSION environment variable.\"\n        )\n    return tuple(\n        int(ver) for ver in match.groupdict()[\"version\"].split(\".\", maxsplit=2)\n    )\n\ndef get_proj_version(proj_dir: Path) -> tuple[int, int, int]:\n    \"\"\"\n    Determine PROJ version.\n\n    Prefer PROJ_VERSION environment variable.\n    If PROJ_VERSION is not set, try to determine the version from the PROJ executable.\n    \"\"\"\n    proj_version = os.environ.get(\"PROJ_VERSION\")\n    if proj_version:\n        return _parse_version(proj_version)\n    proj = proj_dir / \"bin\" / \"proj\"\n    proj_ver = subprocess.check_output(str(proj), stderr=subprocess.STDOUT).decode(\n        \"ascii\"\n    )\n    match = PROJ_VERSION_SEARCH.search(proj_ver)\n    if not match:\n        raise SystemExit(\n            \"PROJ version unable to be determined. \"\n            \"Please set the PROJ_VERSION environment variable.\"\n        )\n    return _parse_version(match.groupdict()[\"version\"])",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "PROJ_VERSION",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "str(proj)",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "str.decode()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "\"ascii\"",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                },
                {
                  "action_api": "PROJ_VERSION_SEARCH.search()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "proj_ver",
                  "object_description": "Regex file content",
                  "object_id": "regex_file_content",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "VERSION_SEARCH.search()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "version",
                  "object_description": "Regex file content",
                  "object_id": "regex_file_content",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "match.groupdict()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "\".\"",
                  "object_description": "Space delimiter",
                  "object_id": "space_delimiter",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "int()",
                  "action_description": "Converts integer to Unicode character",
                  "action_id": "convert_int_to_char",
                  "object": "ver",
                  "object_description": "Character from numeric key string",
                  "object_id": "character_from_numeric_key",
                  "intention_description": "Convert string to integer",
                  "intention_id": "convert_string_to_integer"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pydevd-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pydevd-3.3.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "pydevconsole.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pydevd-3.3.0/pydevd-3.3.0/pydevconsole.py",
          "line_number": "451",
          "type_description": "obfuscation",
          "context_snippet": "def get_interpreter():\n    try:\n        interpreterInterface = getattr(__builtin__, \"interpreter\")\n    except AttributeError:\n        interpreterInterface = InterpreterInterface(None, None, threading.current_thread())\n        __builtin__.interpreter = interpreterInterface\n        sys.stderr.write(interpreterInterface.get_greeting_msg())\n        sys.stderr.flush()\n\n    return interpreterInterface",
          "hash_value": "780de2fab062496f7f0a675078b56254",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def get_interpreter():\n    try:\n        interpreterInterface = getattr(__builtin__, \"interpreter\")\n    except AttributeError:\n        interpreterInterface = InterpreterInterface(None, None, threading.current_thread())\n        __builtin__.interpreter = interpreterInterface\n        sys.stderr.write(interpreterInterface.get_greeting_msg())\n        sys.stderr.flush()\n\n    return interpreterInterface",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "__builtin__, \"interpreter\"",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "InterpreterInterface()",
                  "action_description": "Instantiates custom class",
                  "action_id": "init_grabber_class",
                  "object": "None, None, threading.current_thread()",
                  "object_description": "Thread function arguments",
                  "object_id": "thread_arguments",
                  "intention_description": "Create child process",
                  "intention_id": "create_child_process"
                },
                {
                  "action_api": "setattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "__builtin__.interpreter = interpreterInterface",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "interpreterInterface.get_greeting_msg()",
                  "action_description": "Retrieves attribute value from object",
                  "action_id": "check_instance_type",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "sys.stderr.write()",
                  "action_description": "Writes data to file",
                  "action_id": "basic_write_operations",
                  "object": "interpreterInterface.get_greeting_msg()",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "sys.stderr.flush()",
                  "action_description": "Closes the opened file",
                  "action_id": "close_file",
                  "object": "sys.stderr",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Release system resource",
                  "intention_id": "release_system_resource"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "autotrain_advanced-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/autotrain_advanced-0.8.36.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "ngc.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/autotrain_advanced-0.8.36/autotrain_advanced-0.8.36/src/autotrain/backends/ngc.py",
          "line_number": "61",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "import base64\nimport json\nimport os\n\nimport requests\nfrom requests.exceptions import HTTPError\n\nfrom autotrain import logger\nfrom autotrain.backends.base import BaseBackend\n\nNGC_API = os.environ.get(\"NGC_API\", \"https://api.ngc.nvidia.com/v2/org\")\nNGC_AUTH = os.environ.get(\"NGC_AUTH\", \"https://authn.nvidia.com\")\nNGC_ACE = os.environ.get(\"NGC_ACE\")\nNGC_ORG = os.environ.get(\"NGC_ORG\")\nNGC_API_KEY = os.environ.get(\"NGC_CLI_API_KEY\")\nNGC_TEAM = os.environ.get(\"NGC_TEAM\")\n\nclass NGCRunner(BaseBackend):\n    def _user_authentication_ngc(self):\n        logger.info(\"Authenticating NGC user...\")\n        scope = \"group/ngc\"\n\n        querystring = {\"service\": \"ngc\", \"scope\": scope}\n        auth = f\"$oauthtoken:{NGC_API_KEY}\"\n        headers = {\n            \"Authorization\": f\"Basic {base64.b64encode(auth.encode('utf-8')).decode('utf-8')}\",\n            \"Content-Type\": \"application/json\",\n            \"Cache-Control\": \"no-cache\",\n        }\n        try:\n            response = requests.get(NGC_AUTH + \"/token\", headers=headers, params=querystring, timeout=30)\n        except HTTPError as http_err:\n            logger.error(f\"HTTP error occurred: {http_err}\")\n            raise Exception(\"HTTP Error %d: from '%s'\" % (response.status_code, NGC_AUTH))\n        except (requests.Timeout, ConnectionError) as err:\n            logger.error(f\"Failed to request NGC token - {repr(err)}\")\n            raise Exception(\"%s is unreachable, please try again later.\" % NGC_AUTH)\n        return json.loads(response.text.encode(\"utf8\"))[\"token\"]",
          "hash_value": "66dc77ed8c23ec6f915557c012e1c421",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import base64\nimport json\nimport os\n\nimport requests\nfrom requests.exceptions import HTTPError\n\nfrom autotrain import logger\nfrom autotrain.backends.base import BaseBackend\n\nNGC_API = os.environ.get(\"NGC_API\", \"https://api.ngc.nvidia.com/v2/org\")\nNGC_AUTH = os.environ.get(\"NGC_AUTH\", \"https://authn.nvidia.com\")\nNGC_ACE = os.environ.get(\"NGC_ACE\")\nNGC_ORG = os.environ.get(\"NGC_ORG\")\nNGC_API_KEY = os.environ.get(\"NGC_CLI_API_KEY\")\nNGC_TEAM = os.environ.get(\"NGC_TEAM\")\n\nclass NGCRunner(BaseBackend):\n    def _user_authentication_ngc(self):\n        logger.info(\"Authenticating NGC user...\")\n        scope = \"group/ngc\"\n\n        querystring = {\"service\": \"ngc\", \"scope\": scope}\n        auth = f\"$oauthtoken:{NGC_API_KEY}\"\n        headers = {\n            \"Authorization\": f\"Basic {base64.b64encode(auth.encode('utf-8')).decode('utf-8')}\",\n            \"Content-Type\": \"application/json\",\n            \"Cache-Control\": \"no-cache\",\n        }\n        try:\n            response = requests.get(NGC_AUTH + \"/token\", headers=headers, params=querystring, timeout=30)\n        except HTTPError as http_err:\n            logger.error(f\"HTTP error occurred: {http_err}\")\n            raise Exception(\"HTTP Error %d: from '%s'\" % (response.status_code, NGC_AUTH))\n        except (requests.Timeout, ConnectionError) as err:\n            logger.error(f\"Failed to request NGC token - {repr(err)}\")\n            raise Exception(\"%s is unreachable, please try again later.\" % NGC_AUTH)\n        return json.loads(response.text.encode(\"utf8\"))[\"token\"]",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "NGC_API",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "NGC_AUTH",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "NGC_ACE",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "NGC_ORG",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "NGC_CLI_API_KEY",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "NGC_TEAM",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "base64.b64encode()",
                  "action_description": "Encodes bytes to base64-encoded bytes",
                  "action_id": "encode_bytes_to_base64",
                  "object": "auth.encode('utf-8')",
                  "object_description": "Encoded string to bytes",
                  "object_id": "encoded_string_bytes",
                  "intention_description": "Prepare data for base64 encoding",
                  "intention_id": "prepare_data_base64_encoding"
                },
                {
                  "action_api": "str.encode()",
                  "action_description": "Encodes string to bytes using default encoding",
                  "action_id": "encode_string_to_bytes",
                  "object": "auth",
                  "object_description": "Encoded string to bytes",
                  "object_id": "encoded_string_bytes",
                  "intention_description": "Encode string to bytes",
                  "intention_id": "encode_string_to_bytes"
                },
                {
                  "action_api": "str.decode()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Decode bytes to string",
                  "intention_id": "decode_bytes_to_string"
                },
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "NGC_AUTH + \"/token\"",
                  "object_description": "External domain",
                  "object_id": "external_domain",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "json.loads()",
                  "action_description": "Deserializes JSON string to Python object",
                  "action_id": "deserialize_from_json",
                  "object": "response.text.encode(\"utf8\")",
                  "object_description": "JSON string",
                  "object_id": "json_string",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "nvidia-pyindex-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/nvidia-pyindex-1.0.9.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/nvidia-pyindex-1.0.9/nvidia-pyindex-1.0.9/setup.py",
          "line_number": "60",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport shlex\nimport subprocess\nfrom nvidia_pyindex.utils import get_configuration_files\nfrom nvidia_pyindex.utils import get_configuration_files_by_priority\n\ndef _install_nvidia_pypi_index():\n    try:\n        subprocess.call(\n            shlex.split(\"nvidia_pyindex uninstall\"),\n            shell=True,\n            stdout=subprocess.DEVNULL,\n            stderr=subprocess.DEVNULL\n        )\n    except:\n        pass\n\n    debug_mode = bool(os.environ.get(\"DEBUG_MODE\", False))\n\n    config_filedict = get_configuration_files()\n    config_filelist = get_configuration_files_by_priority()\n\n    print(\"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\")\n    print(\"Setting User Pip Configuration ...\")\n    print(\"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\")\n    print(\"\\n######################\\n\")\n\n    pre_existing_configfile = None\n    for config_file in config_filelist:\n        try:\n            if os.path.isfile(config_file):\n                print(\"Editing pip conf file: %s ...\" % config_file)\n                maybe_edit_pip_config_file(\n                    config_file,\n                    config_filedict=config_filedict,\n                    debug_mode=debug_mode\n                )\n                pre_existing_configfile = config_file\n                break\n        except (FileNotFoundError, PermissionError) as e:\n            print(\"Error: {}: {}\".format(e.__class__.__name__, str(e)))\n            pass\n\n    if pre_existing_configfile is None:\n        for config_file in config_filelist:\n            print(\"\\nProcessing pip conf file: %s ...\" % config_file)\n            try:\n                if not os.path.exists(config_file):\n                    print(\"Creating pip conf file: %s ...\" % config_file)\n                    create_pip_config_file(\n                        filepath=config_file,\n                        config_filedict=config_filedict\n                    )\n            except (FileNotFoundError, PermissionError) as e:\n                print(\"Error: {}: {}\".format(e.__class__.__name__, str(e)))\n                pass\n    else:\n        with open(pre_existing_configfile, 'r') as _file:\n            original_content = _file.readlines()\n\n        for config_file in config_filelist:\n            print(\"\\nProcessing pip conf file: %s ...\" % config_file)\n            try:\n\n                try:\n                    with open(config_file, 'r') as _file:\n                        backup_content = _file.readlines()\n                except:\n                    pass\n\n                try:\n                    os.remove(config_file)\n                    os.remove(config_file.old)\n                    with open(\"%s.old\" % config_file, 'w') as _file:\n                        _file.writelines(backup_content)\n                except:\n                    pass\n\n                with open(config_file, 'w') as _file:\n                    _file.writelines(original_content)\n\n            except (FileNotFoundError, PermissionError) as e:\n                print(\"Error: {}: {}\".format(e.__class__.__name__, str(e)))\n                pass\n\n    print(\"\\n######################\\n\")\n\n    time.sleep(2)  # allow readable logs in verbose logs. Please do not delete.",
          "hash_value": "3b78934bb3111ddfe6e4ab00ff341804",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport shlex\nimport subprocess\nfrom nvidia_pyindex.utils import get_configuration_files\nfrom nvidia_pyindex.utils import get_configuration_files_by_priority\n\ndef _install_nvidia_pypi_index():\n    try:\n        subprocess.call(\n            shlex.split(\"nvidia_pyindex uninstall\"),\n            shell=True,\n            stdout=subprocess.DEVNULL,\n            stderr=subprocess.DEVNULL\n        )\n    except:\n        pass\n\n    debug_mode = bool(os.environ.get(\"DEBUG_MODE\", False))\n\n    config_filedict = get_configuration_files()\n    config_filelist = get_configuration_files_by_priority()\n\n    print(\"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\")\n    print(\"Setting User Pip Configuration ...\")\n    print(\"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\")\n    print(\"\\n######################\\n\")\n\n    pre_existing_configfile = None\n    for config_file in config_filelist:\n        try:\n            if os.path.isfile(config_file):\n                print(\"Editing pip conf file: %s ...\" % config_file)\n                maybe_edit_pip_config_file(\n                    config_file,\n                    config_filedict=config_filedict,\n                    debug_mode=debug_mode\n                )\n                pre_existing_configfile = config_file\n                break\n        except (FileNotFoundError, PermissionError) as e:\n            print(\"Error: {}: {}\".format(e.__class__.__name__, str(e)))\n            pass\n\n    if pre_existing_configfile is None:\n        for config_file in config_filelist:\n            print(\"\\nProcessing pip conf file: %s ...\" % config_file)\n            try:\n                if not os.path.exists(config_file):\n                    print(\"Creating pip conf file: %s ...\" % config_file)\n                    create_pip_config_file(\n                        filepath=config_file,\n                        config_filedict=config_filedict\n                    )\n            except (FileNotFoundError, PermissionError) as e:\n                print(\"Error: {}: {}\".format(e.__class__.__name__, str(e)))\n                pass\n    else:\n        with open(pre_existing_configfile, 'r') as _file:\n            original_content = _file.readlines()\n\n        for config_file in config_filelist:\n            print(\"\\nProcessing pip conf file: %s ...\" % config_file)\n            try:\n\n                try:\n                    with open(config_file, 'r') as _file:\n                        backup_content = _file.readlines()\n                except:\n                    pass\n\n                try:\n                    os.remove(config_file)\n                    os.remove(config_file.old)\n                    with open(\"%s.old\" % config_file, 'w') as _file:\n                        _file.writelines(backup_content)\n                except:\n                    pass\n\n                with open(config_file, 'w') as _file:\n                    _file.writelines(original_content)\n\n            except (FileNotFoundError, PermissionError) as e:\n                print(\"Error: {}: {}\".format(e.__class__.__name__, str(e)))\n                pass\n\n    print(\"\\n######################\\n\")\n\n    time.sleep(2)  # allow readable logs in verbose logs. Please do not delete.",
              "triple_sequences": [
                {
                  "action_api": "subprocess.call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "shlex.split(\"nvidia_pyindex uninstall\")",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"DEBUG_MODE\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "get_configuration_files()",
                  "action_description": "Instantiates Setup class",
                  "action_id": "init_setup_class",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access configuration value",
                  "intention_id": "access_configuration_value"
                },
                {
                  "action_api": "get_configuration_files_by_priority()",
                  "action_description": "Instantiates Setup class",
                  "action_id": "init_setup_class",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access configuration value",
                  "intention_id": "access_configuration_value"
                },
                {
                  "action_api": "os.path.isfile()",
                  "action_description": "Checks if specified path exists and is a file",
                  "action_id": "check_file_is_file",
                  "object": "config_file",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "maybe_edit_pip_config_file()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "config_file, config_filedict=config_filedict, debug_mode=debug_mode",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Access configuration value",
                  "intention_id": "access_configuration_value"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "config_file",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "create_pip_config_file()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "filepath=config_file, config_filedict=config_filedict",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Access configuration value",
                  "intention_id": "access_configuration_value"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "pre_existing_configfile, 'r'",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "file.readlines()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "config_file, 'r'",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "file.readlines()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "os.remove()",
                  "action_description": "Deletes specified file from filesystem",
                  "action_id": "delete_file",
                  "object": "config_file",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Delete file",
                  "intention_id": "delete_file"
                },
                {
                  "action_api": "os.remove()",
                  "action_description": "Deletes specified file from filesystem",
                  "action_id": "delete_file",
                  "object": "config_file.old",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Delete file",
                  "intention_id": "delete_file"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for writing (normal writing, binary writing)",
                  "action_id": "basic_write_operations",
                  "object": "\"%s.old\" % config_file, 'w'",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for writing",
                  "intention_id": "open_file_writing"
                },
                {
                  "action_api": "file.writelines()",
                  "action_description": "File opening operations for writing (normal writing, binary writing)",
                  "action_id": "basic_write_operations",
                  "object": "backup_content",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for writing (normal writing, binary writing)",
                  "action_id": "basic_write_operations",
                  "object": "config_file, 'w'",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for writing",
                  "intention_id": "open_file_writing"
                },
                {
                  "action_api": "file.writelines()",
                  "action_description": "File opening operations for writing (normal writing, binary writing)",
                  "action_id": "basic_write_operations",
                  "object": "original_content",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                },
                {
                  "action_api": "time.sleep()",
                  "action_description": "Suspends execution",
                  "action_id": "suspend_execution",
                  "object": "2",
                  "object_description": "Delay duration in seconds",
                  "object_id": "delay_duration",
                  "intention_description": "Delay next operation",
                  "intention_id": "delay_next_operation"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "koalas-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/koalas-1.8.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "namespace.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/koalas-1.8.2/koalas-1.8.2/databricks/koalas/namespace.py",
          "line_number": "815",
          "type_description": "clipboard-access",
          "context_snippet": "def read_clipboard(sep=r\"\\s+\", **kwargs) -> DataFrame:\n    r\"\"\"\n    Read text from clipboard and pass to read_csv. See read_csv for the\n    full argument list\n\n    Parameters\n    ----------\n    sep : str, default '\\s+'\n        A string or regex delimiter. The default of '\\s+' denotes\n        one or more whitespace characters.\n\n    See Also\n    --------\n    DataFrame.to_clipboard : Write text out to clipboard.\n\n    Returns\n    -------\n    parsed : DataFrame\n    \"\"\"\n    return cast(DataFrame, from_pandas(pd.read_clipboard(sep, **kwargs)))",
          "hash_value": "a0c0c9f76f06f950fb65a111abd1846c",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def read_clipboard(sep=r\"\\s+\", **kwargs) -> DataFrame:\n    r\"\"\"\n    Read text from clipboard and pass to read_csv. See read_csv for the\n    full argument list\n\n    Parameters\n    ----------\n    sep : str, default '\\s+'\n        A string or regex delimiter. The default of '\\s+' denotes\n        one or more whitespace characters.\n\n    See Also\n    --------\n    DataFrame.to_clipboard : Write text out to clipboard.\n\n    Returns\n    -------\n    parsed : DataFrame\n    \"\"\"\n    return cast(DataFrame, from_pandas(pd.read_clipboard(sep, **kwargs)))",
              "triple_sequences": [
                {
                  "action_api": "pd.read_clipboard()",
                  "action_description": "Retrieves text from system clipboard",
                  "action_id": "get_clipboard_text",
                  "object": "sep=r\"\\s+\", **kwargs",
                  "object_description": "Clipboard content data",
                  "object_id": "clipboard_data",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pympler-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pympler-1.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pympler-1.1/pympler-1.1/setup.py",
          "line_number": "43",
          "type_description": "code-execution",
          "context_snippet": "import sys\nimport os\nfrom setuptools import Command\nfrom subprocess import run\n\nclass BaseTestCommand(Command):\n    \"\"\"Base class for the pre and the post installation commands. \"\"\"\n    user_options = []\n\n    def initialize_options(self):\n        self.param = None\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        args = [sys.executable,  # this Python binary\n                os.path.join('test', 'runtest.py'),\n                self.param, '-verbose', '3']\n        args.extend(sys.argv[2:])\n        sys.exit(run(args).returncode)",
          "hash_value": "82ffa1e2886e6a03a166de577f2df1ae",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import sys\nimport os\nfrom setuptools import Command\nfrom subprocess import run\n\nclass BaseTestCommand(Command):\n    \"\"\"Base class for the pre and the post installation commands. \"\"\"\n    user_options = []\n\n    def initialize_options(self):\n        self.param = None\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        args = [sys.executable,  # this Python binary\n                os.path.join('test', 'runtest.py'),\n                self.param, '-verbose', '3']\n        args.extend(sys.argv[2:])\n        sys.exit(run(args).returncode)",
              "triple_sequences": [
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "'test', 'runtest.py'",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "run()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "args",
                  "object_description": "User process",
                  "object_id": "user_process",
                  "intention_description": "Create child process",
                  "intention_id": "create_child_process"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "run(args).returncode",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pypdf4-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pypdf4-1.27.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "utils.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pypdf4-1.27.0/PyPDF4-1.27.0/PyPDF4/utils.py",
          "line_number": "43",
          "type_description": "obfuscation",
          "context_snippet": "import sys\n\ntry:\n    import __builtin__ as builtins\nexcept ImportError:  # Py3\n    import builtins\n\n\nxrange_fn = getattr(builtins, \"xrange\", range)\n_basestring = getattr(builtins, \"basestring\", str)\n\nbytes_type = type(bytes()) # Works the same in Python 2.X and 3.X\nstring_type = getattr(builtins, \"unicode\", str)\nint_types = (int, long) if sys.version_info[0] < 3 else (int,)",
          "hash_value": "25d852a084dd125e1dcc380f926478c6",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import sys\n\ntry:\n    import __builtin__ as builtins\nexcept ImportError:  # Py3\n    import builtins\n\n\nxrange_fn = getattr(builtins, \"xrange\", range)\n_basestring = getattr(builtins, \"basestring\", str)\n\nbytes_type = type(bytes()) # Works the same in Python 2.X and 3.X\nstring_type = getattr(builtins, \"unicode\", str)\nint_types = (int, long) if sys.version_info[0] < 3 else (int,)",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, \"xrange\", range",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, \"basestring\", str",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "type()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "bytes()",
                  "object_description": "Encoded string to bytes",
                  "object_id": "encoded_string_bytes",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, \"unicode\", str",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "jc-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/jc-1.25.4.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "tracebackplus.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/jc-1.25.4/jc-1.25.4/jc/tracebackplus.py",
          "line_number": "102",
          "type_description": "obfuscation",
          "context_snippet": "def lookup(name, frame, locals):\n    \"\"\"Find the value for a given name in the given environment.\"\"\"\n    if name in locals:\n        return 'local', locals[name]\n    if name in frame.f_globals:\n        return 'global', frame.f_globals[name]\n    if '__builtins__' in frame.f_globals:\n        builtins = frame.f_globals['__builtins__']\n        if isinstance(builtins, dict):\n            if name in builtins:\n                return 'builtin', builtins[name]\n        else:\n            if hasattr(builtins, name):\n                return 'builtin', getattr(builtins, name)\n    return None, __UNDEF__",
          "hash_value": "f4fac2b59320d2e573ff06f75258aa00",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def lookup(name, frame, locals):\n    \"\"\"Find the value for a given name in the given environment.\"\"\"\n    if name in locals:\n        return 'local', locals[name]\n    if name in frame.f_globals:\n        return 'global', frame.f_globals[name]\n    if '__builtins__' in frame.f_globals:\n        builtins = frame.f_globals['__builtins__']\n        if isinstance(builtins, dict):\n            if name in builtins:\n                return 'builtin', builtins[name]\n        else:\n            if hasattr(builtins, name):\n                return 'builtin', getattr(builtins, name)\n    return None, __UNDEF__",
              "triple_sequences": [
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, dict",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Determine required module presence",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "hasattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, name",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Determine required module presence",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, name",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "safety-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/safety-3.4.0b6.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "utils.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/safety-3.4.0b6/safety-3.4.0b6/safety/tool/utils.py",
          "line_number": "383",
          "type_description": "silent-process-execution",
          "context_snippet": "def __run_scan(self):\n    if not is_os_supported():\n        return\n\n    target = os.getcwd()\n    if Path(os.path.join(target, PROJECT_CONFIG)).is_file():\n        try:\n            subprocess.Popen(\n                [\"safety\", \"scan\"],\n                stdout=subprocess.DEVNULL,\n                stderr=subprocess.DEVNULL,\n                stdin=subprocess.DEVNULL,\n                start_new_session=True,\n            )\n        except Exception:\n            pass",
          "hash_value": "65dcb26d22a88e3cf077427c16e6446c",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def __run_scan(self):\n    if not is_os_supported():\n        return\n\n    target = os.getcwd()\n    if Path(os.path.join(target, PROJECT_CONFIG)).is_file():\n        try:\n            subprocess.Popen(\n                [\"safety\", \"scan\"],\n                stdout=subprocess.DEVNULL,\n                stderr=subprocess.DEVNULL,\n                stdin=subprocess.DEVNULL,\n                start_new_session=True,\n            )\n        except Exception:\n            pass",
              "triple_sequences": [
                {
                  "action_api": "os.getcwd()",
                  "action_description": "Returns current working directory",
                  "action_id": "get_working_dir",
                  "object": "",
                  "object_description": "Current working directory",
                  "object_id": "current_working_directory",
                  "intention_description": "Collect working directory",
                  "intention_id": "collect_working_directory"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "target, PROJECT_CONFIG",
                  "object_description": "Directory path with file",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "Path().is_file()",
                  "action_description": "Checks if specified path exists and is a file",
                  "action_id": "check_file_is_file",
                  "object": "os.path.join(target, PROJECT_CONFIG)",
                  "object_description": "Directory path with file",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Determine file presence",
                  "intention_id": "determine_file_presence"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "[\"safety\", \"scan\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Create child process",
                  "intention_id": "create_child_process"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "cyksuid-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/cyksuid-2.1.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cyksuid-2.1.0/cyksuid-2.1.0/setup.py",
          "line_number": "233",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport subprocess\nimport sys\nfrom typing import Union, List\n\nclass BuildExt(build_ext.build_ext):\n    ...\n    def test_supports_compile_arg(self, comm: Union[str, List[str]]) -> bool:\n        if not hasattr(self.compiler, \"compiler_cxx\"):\n            return False\n        if not isinstance(comm, list):\n            comm = [comm]\n\n        is_supported = False\n\n        try:\n            if not isinstance(self.compiler.compiler_cxx, list):\n                cmd = list(self.compiler.compiler_cxx)\n            else:\n                cmd = self.compiler.compiler_cxx\n        except Exception as e:\n            print(\"Error: could not get compiler_cxx: %s\" % e)\n            cmd = self.compiler.compiler_cxx\n\n        print(\"--- Checking compiler support for option '%s'\" % \" \".join(comm), end=\"\")\n        fname = \"cyksuid_compiler_testing.cpp\"\n        try:\n            with open(fname, \"w\") as ftest:\n                ftest.write(\"int main(int argc, char**argv) {return 0;}\\n\")\n\n            val_good = subprocess.call(cmd + [fname])\n            val = subprocess.call(cmd + comm + [fname])\n            is_supported = val == val_good\n        except Exception:\n            is_supported = False\n        finally:\n            try:\n                os.remove(fname)\n            except Exception:\n                pass\n        print(\" ... %s\" % (\"yes\" if is_supported else \"no\"))\n        return is_supported",
          "hash_value": "20d0e430f6cfdf46ffcdba1b61002171",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport subprocess\nimport sys\nfrom typing import Union, List\n\nclass BuildExt(build_ext.build_ext):\n    ...\n    def test_supports_compile_arg(self, comm: Union[str, List[str]]) -> bool:\n        if not hasattr(self.compiler, \"compiler_cxx\"):\n            return False\n        if not isinstance(comm, list):\n            comm = [comm]\n\n        is_supported = False\n\n        try:\n            if not isinstance(self.compiler.compiler_cxx, list):\n                cmd = list(self.compiler.compiler_cxx)\n            else:\n                cmd = self.compiler.compiler_cxx\n        except Exception as e:\n            print(\"Error: could not get compiler_cxx: %s\" % e)\n            cmd = self.compiler.compiler_cxx\n\n        print(\"--- Checking compiler support for option '%s'\" % \" \".join(comm), end=\"\")\n        fname = \"cyksuid_compiler_testing.cpp\"\n        try:\n            with open(fname, \"w\") as ftest:\n                ftest.write(\"int main(int argc, char**argv) {return 0;}\\n\")\n\n            val_good = subprocess.call(cmd + [fname])\n            val = subprocess.call(cmd + comm + [fname])\n            is_supported = val == val_good\n        except Exception:\n            is_supported = False\n        finally:\n            try:\n                os.remove(fname)\n            except Exception:\n                pass\n        print(\" ... %s\" % (\"yes\" if is_supported else \"no\"))\n        return is_supported",
              "triple_sequences": [
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for writing (normal writing, binary writing)",
                  "action_id": "basic_write_operations",
                  "object": "cyksuid_compiler_testing.cpp",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for writing",
                  "intention_id": "open_file_writing"
                },
                {
                  "action_api": "ftest.write()",
                  "action_description": "File opening operations for writing (normal writing, binary writing)",
                  "action_id": "basic_write_operations",
                  "object": "int main(int argc, char**argv) {return 0;}\n",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                },
                {
                  "action_api": "subprocess.call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "cmd + [fname]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "cmd + comm + [fname]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.remove()",
                  "action_description": "Deletes specified file from filesystem",
                  "action_id": "delete_file",
                  "object": "cyksuid_compiler_testing.cpp",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Delete file",
                  "intention_id": "delete_file"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "better_exceptions-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/better_exceptions-0.3.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/better_exceptions-0.3.3/better_exceptions-0.3.3/setup.py",
          "line_number": "54",
          "type_description": "cmd-overwrite",
          "context_snippet": "setup(\n    name = 'better_exceptions',\n    packages = ['better_exceptions', 'better_exceptions.integrations'],\n    version = version,\n    description = 'Pretty and helpful exceptions, automatically',\n    author = 'Josh Junon',\n    author_email = 'josh@junon.me',\n    url = 'https://github.com/qix-/better-exceptions',\n    download_url = 'https://github.com/qix-/better-exceptions/archive/{}.tar.gz'.format(version),\n    keywords = ['pretty', 'better', 'exceptions', 'exception', 'error', 'local', 'debug', 'debugging', 'locals'],\n    classifiers = [],\n    extras_require = {\n        ':sys_platform==\"win32\"': ['colorama']\n    },\n    # This all comes from pytest-cov repository:\n    # https://github.com/pytest-dev/pytest-cov/blob/cde7c378b6a1971957759f42ac91e2860b41cf89/setup.py\n    cmdclass = {\n        'build': BuildWithPTH,\n        'easy_install': EasyInstallWithPTH,\n        'install_lib': InstallLibWithPTH,\n        'develop': DevelopWithPTH,\n    }\n)\n\n# Data dependencies:\n# - 'version' is set by:\n# with open('better_exceptions/__init__.py', 'r') as file:\n#     version = re.search(r'^__version__\\s*=\\s*[\\'\"]([^\\'\"]*)[\\'\"]',\n#                         file.read(), re.MULTILINE).group(1)\n# - 'BuildWithPTH', 'EasyInstallWithPTH', 'InstallLibWithPTH', 'DevelopWithPTH' are defined as classes above\n# - 'setup' is imported from 'distutils.core'\n# - 're' is imported\n# - 'open' is built-in",
          "hash_value": "37819e8ee4c3049644288455865e46b5",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "setup(\n    name = 'better_exceptions',\n    packages = ['better_exceptions', 'better_exceptions.integrations'],\n    version = version,\n    description = 'Pretty and helpful exceptions, automatically',\n    author = 'Josh Junon',\n    author_email = 'josh@junon.me',\n    url = 'https://github.com/qix-/better-exceptions',\n    download_url = 'https://github.com/qix-/better-exceptions/archive/{}.tar.gz'.format(version),\n    keywords = ['pretty', 'better', 'exceptions', 'exception', 'error', 'local', 'debug', 'debugging', 'locals'],\n    classifiers = [],\n    extras_require = {\n        ':sys_platform==\"win32\"': ['colorama']\n    },\n    # This all comes from pytest-cov repository:\n    # https://github.com/pytest-dev/pytest-cov/blob/cde7c378b6a1971957759f42ac91e2860b41cf89/setup.py\n    cmdclass = {\n        'build': BuildWithPTH,\n        'easy_install': EasyInstallWithPTH,\n        'install_lib': InstallLibWithPTH,\n        'develop': DevelopWithPTH,\n    }\n)\n\n# Data dependencies:\n# - 'version' is set by:\n# with open('better_exceptions/__init__.py', 'r') as file:\n#     version = re.search(r'^__version__\\s*=\\s*[\\'\"]([^\\'\"]*)[\\'\"]',\n#                         file.read(), re.MULTILINE).group(1)\n# - 'BuildWithPTH', 'EasyInstallWithPTH', 'InstallLibWithPTH', 'DevelopWithPTH' are defined as classes above\n# - 'setup' is imported from 'distutils.core'\n# - 're' is imported\n# - 'open' is built-in",
              "triple_sequences": [
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "'better_exceptions/__init__.py', 'r'",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "re.search()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "r'^__version__\\s*=\\s*[\\'\\\"]([^\\'\\\"]*)[\\'\\\"]', file.read(), re.MULTILINE",
                  "object_description": "Regular expression and file content",
                  "object_id": "regex_file_content",
                  "intention_description": "Extract structured data from file",
                  "intention_id": "extract_structured_file_data"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "name = 'better_exceptions', packages = ['better_exceptions', 'better_exceptions.integrations'], version = version, description = 'Pretty and helpful exceptions, automatically', author = 'Josh Junon', author_email = 'josh@junon.me', url = 'https://github.com/qix-/better-exceptions', download_url = 'https://github.com/qix-/better-exceptions/archive/{}.tar.gz'.format(version), keywords = ['pretty', 'better', 'exceptions', 'exception', 'error', 'local', 'debug', 'debugging', 'locals'], classifiers = [], extras_require = { ':sys_platform==\"win32\"': ['colorama'] }, cmdclass = { 'build': BuildWithPTH, 'easy_install': EasyInstallWithPTH, 'install_lib': InstallLibWithPTH, 'develop': DevelopWithPTH }",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "obspy-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/obspy-1.4.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/obspy-1.4.1/obspy-1.4.1/setup.py",
          "line_number": "767",
          "type_description": "cmd-overwrite",
          "context_snippet": "def setupPackage():\n    # setup package\n    setup(\n        name='obspy',\n        version=get_git_version(),\n        description=DOCSTRING[1],\n        long_description=\"\\n\".join(DOCSTRING[3:]),\n        url=\"https://www.obspy.org\",\n        project_urls={\n            \"Bug Tracker\": \"https://github.com/obspy/obspy/issues\",\n            \"Documentation\": \"https://docs.obspy.org/\",\n            \"Source Code\": \"https://github.com/obspy/obspy\",\n        },\n        author='The ObsPy Development Team',\n        author_email='devs@obspy.org',\n        license='GNU Lesser General Public License, Version 3 (LGPLv3)',\n        platforms='OS Independent',\n        classifiers=[\n            'Development Status :: 5 - Production/Stable',\n            'Environment :: Console',\n            'Intended Audience :: Science/Research',\n            'Intended Audience :: Developers',\n            'License :: OSI Approved :: '\n                'GNU Lesser General Public License v3 (LGPLv3)',\n            'Operating System :: OS Independent',\n            'Programming Language :: Python',\n            'Programming Language :: Python :: 3',\n            'Programming Language :: Python :: 3.8',\n            'Programming Language :: Python :: 3.9',\n            'Programming Language :: Python :: 3.10',\n            'Programming Language :: Python :: 3.11',\n            'Programming Language :: Python :: 3.12',\n            'Topic :: Scientific/Engineering',\n            'Topic :: Scientific/Engineering :: Physics'],\n        keywords=KEYWORDS,\n        packages=find_packages(),\n        include_package_data=True,\n        exclude_package_data={\n            'obspy.io.css': ['contrib/*'],\n            # NOTE: If the libmseed test data wasn't used in our tests, we\n            # could just ignore src/* everywhere.\n            'obspy.io.gcf': ['src/*'],\n            'obspy.io.gse2': ['src/*'],\n            'obspy.io.mseed': [\n                # Only keep src/libmseed/test/* except for the C files.\n                'src/*.c',\n                'src/*.def',\n                'src/libmseed/.clang-format',\n                'src/libmseed/ChangeLog',\n                'src/libmseed/Makefile*',\n                'src/libmseed/README.byteorder',\n                'src/libmseed/doc/*',\n                'src/libmseed/example/*',\n                'src/libmseed/test/Makefile',\n                'src/libmseed/*.h',\n                'src/libmseed/*.in',\n                'src/libmseed/*.map',\n                'src/libmseed/*.md',\n            ],\n            'obspy.io.segy': ['src/*'],\n            'obspy.signal': ['src/*'],\n            'obspy.taup': ['src/*'],\n        },\n        namespace_packages=[],\n        zip_safe=False,\n        python_requires=f'>={MIN_PYTHON_VERSION[0]}.{MIN_PYTHON_VERSION[1]}',\n        install_requires=INSTALL_REQUIRES,\n        tests_require=EXTRAS_REQUIRES['tests'],\n        extras_require=EXTRAS_REQUIRES,\n        features=add_features(),\n        entry_points=ENTRY_POINTS,\n        ext_modules=get_extensions(),\n        ext_package='obspy.lib',\n        cmdclass={\n            'build_man': Help2ManBuild,\n            'install_man': Help2ManInstall\n        },\n    )\n\n# Data dependencies for setup() call:\n# - get_git_version: imported from version.py\n# - DOCSTRING: assigned as __doc__.split(\"\\n\")\n# - KEYWORDS: defined as a list above\n# - find_packages: imported from setuptools\n# - INSTALL_REQUIRES, EXTRAS_REQUIRES: defined above\n# - add_features, ENTRY_POINTS, get_extensions: defined above\n# - Help2ManBuild, Help2ManInstall: defined above\n# - MIN_PYTHON_VERSION: defined above",
          "hash_value": "f27ffe3fbb366b46d0c3741ea35f94cd",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def setupPackage():\n    # setup package\n    setup(\n        name='obspy',\n        version=get_git_version(),\n        description=DOCSTRING[1],\n        long_description=\"\\n\".join(DOCSTRING[3:]),\n        url=\"https://www.obspy.org\",\n        project_urls={\n            \"Bug Tracker\": \"https://github.com/obspy/obspy/issues\",\n            \"Documentation\": \"https://docs.obspy.org/\",\n            \"Source Code\": \"https://github.com/obspy/obspy\",\n        },\n        author='The ObsPy Development Team',\n        author_email='devs@obspy.org',\n        license='GNU Lesser General Public License, Version 3 (LGPLv3)',\n        platforms='OS Independent',\n        classifiers=[\n            'Development Status :: 5 - Production/Stable',\n            'Environment :: Console',\n            'Intended Audience :: Science/Research',\n            'Intended Audience :: Developers',\n            'License :: OSI Approved :: '\n                'GNU Lesser General Public License v3 (LGPLv3)',\n            'Operating System :: OS Independent',\n            'Programming Language :: Python',\n            'Programming Language :: Python :: 3',\n            'Programming Language :: Python :: 3.8',\n            'Programming Language :: Python :: 3.9',\n            'Programming Language :: Python :: 3.10',\n            'Programming Language :: Python :: 3.11',\n            'Programming Language :: Python :: 3.12',\n            'Topic :: Scientific/Engineering',\n            'Topic :: Scientific/Engineering :: Physics'],\n        keywords=KEYWORDS,\n        packages=find_packages(),\n        include_package_data=True,\n        exclude_package_data={\n            'obspy.io.css': ['contrib/*'],\n            # NOTE: If the libmseed test data wasn't used in our tests, we\n            # could just ignore src/* everywhere.\n            'obspy.io.gcf': ['src/*'],\n            'obspy.io.gse2': ['src/*'],\n            'obspy.io.mseed': [\n                # Only keep src/libmseed/test/* except for the C files.\n                'src/*.c',\n                'src/*.def',\n                'src/libmseed/.clang-format',\n                'src/libmseed/ChangeLog',\n                'src/libmseed/Makefile*',\n                'src/libmseed/README.byteorder',\n                'src/libmseed/doc/*',\n                'src/libmseed/example/*',\n                'src/libmseed/test/Makefile',\n                'src/libmseed/*.h',\n                'src/libmseed/*.in',\n                'src/libmseed/*.map',\n                'src/libmseed/*.md',\n            ],\n            'obspy.io.segy': ['src/*'],\n            'obspy.signal': ['src/*'],\n            'obspy.taup': ['src/*'],\n        },\n        namespace_packages=[],\n        zip_safe=False,\n        python_requires=f'>={MIN_PYTHON_VERSION[0]}.{MIN_PYTHON_VERSION[1]}',\n        install_requires=INSTALL_REQUIRES,\n        tests_require=EXTRAS_REQUIRES['tests'],\n        extras_require=EXTRAS_REQUIRES,\n        features=add_features(),\n        entry_points=ENTRY_POINTS,\n        ext_modules=get_extensions(),\n        ext_package='obspy.lib',\n        cmdclass={\n            'build_man': Help2ManBuild,\n            'install_man': Help2ManInstall\n        },\n    )\n\n# Data dependencies for setup() call:\n# - get_git_version: imported from version.py\n# - DOCSTRING: assigned as __doc__.split(\"\\n\")\n# - KEYWORDS: defined as a list above\n# - find_packages: imported from setuptools\n# - INSTALL_REQUIRES, EXTRAS_REQUIRES: defined above\n# - add_features, ENTRY_POINTS, get_extensions: defined above\n# - Help2ManBuild, Help2ManInstall: defined above\n# - MIN_PYTHON_VERSION: defined above",
              "triple_sequences": [
                {
                  "action_api": "setup()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "name='obspy', version=get_git_version(), description=DOCSTRING[1], long_description=\"\\n\".join(DOCSTRING[3:]), url=\"https://www.obspy.org\", project_urls={...}, author='The ObsPy Development Team', author_email='devs@obspy.org', license='GNU Lesser General Public License, Version 3 (LGPLv3)', platforms='OS Independent', classifiers=[...], keywords=KEYWORDS, packages=find_packages(), include_package_data=True, exclude_package_data={...}, namespace_packages=[], zip_safe=False, python_requires=f'>={MIN_PYTHON_VERSION[0]}.{MIN_PYTHON_VERSION[1]}', install_requires=INSTALL_REQUIRES, tests_require=EXTRAS_REQUIRES['tests'], extras_require=EXTRAS_REQUIRES, features=add_features(), entry_points=ENTRY_POINTS, ext_modules=get_extensions(), ext_package='obspy.lib', cmdclass={...}",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                },
                {
                  "action_api": "get_git_version()",
                  "action_description": "Retrieves current HEAD reference of repository",
                  "action_id": "get_git_head",
                  "object": "",
                  "object_description": "Repository reference",
                  "object_id": "repository_reference",
                  "intention_description": "Extract executable name",
                  "intention_id": "extract_executable_name"
                },
                {
                  "action_api": "find_packages()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Install multiple Python packages",
                  "intention_id": "install_multiple_python_packages"
                },
                {
                  "action_api": "add_features()",
                  "action_description": "Executes setuptools development procedure",
                  "action_id": "exec_setuptools_dev",
                  "object": "",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                },
                {
                  "action_api": "get_extensions()",
                  "action_description": "Initializes Git command wrapper",
                  "action_id": "init_git_wrapper",
                  "object": "",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "telebot-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/telebot-0.0.5.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "__init__.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/telebot-0.0.5/telebot-0.0.5/telebot_router/__init__.py",
          "line_number": "119",
          "type_description": "shady-links",
          "context_snippet": "    def _bot_cmd(self, method, endpoint, *args, **kwargs):\n        base_api = \"https://api.telegram.org/bot{api_key}/{endpoint}\"\n        endpoint = base_api.format(api_key=self.config['api_key'],\n                                   endpoint=endpoint)\n\n        try:\n            response = method(endpoint,\n                              data=kwargs.get('data', None),\n                              params=kwargs.get('params', {}),\n                              **self.config['requests_kwargs'])\n\n            if response.status_code != 200:\n                raise ValueError('Got unexpected response. ({}) - {}'.\n                                 format(response.status_code, response.text))\n\n            return response.json()\n        except Exception as e:\n            return {\n                'ok': False,\n                'error': str(e),\n            }",
          "hash_value": "25e0fd8963c82c6c657286e3230e0087",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "    def _bot_cmd(self, method, endpoint, *args, **kwargs):\n        base_api = \"https://api.telegram.org/bot{api_key}/{endpoint}\"\n        endpoint = base_api.format(api_key=self.config['api_key'],\n                                   endpoint=endpoint)\n\n        try:\n            response = method(endpoint,\n                              data=kwargs.get('data', None),\n                              params=kwargs.get('params', {}),\n                              **self.config['requests_kwargs'])\n\n            if response.status_code != 200:\n                raise ValueError('Got unexpected response. ({}) - {}'.\n                                 format(response.status_code, response.text))\n\n            return response.json()\n        except Exception as e:\n            return {\n                'ok': False,\n                'error': str(e),\n            }",
              "triple_sequences": [
                {
                  "action_api": "method()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "endpoint, data=kwargs.get('data', None), params=kwargs.get('params', {}), **self.config['requests_kwargs']",
                  "object_description": "Telegram API endpoint",
                  "object_id": "telegram_api_endpoint",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "response.status_code",
                  "action_description": "Retrieves HTTP response status code",
                  "action_id": "get_http_status",
                  "object": "response",
                  "object_description": "HTTP response content from remote server",
                  "object_id": "http_response_remote_content",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "response.text",
                  "action_description": "Process HTTP response content",
                  "action_id": "process_http_response",
                  "object": "response",
                  "object_description": "HTTP response content from remote server",
                  "object_id": "http_response_remote_content",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "response.json()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "response",
                  "object_description": "HTTP response content from remote server",
                  "object_id": "http_response_remote_content",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "str(e)",
                  "action_description": "Converts bytes to string using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "e",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "skypilot-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/skypilot-0.8.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "subprocess_utils.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/skypilot-0.8.1/skypilot-0.8.1/sky/utils/subprocess_utils.py",
          "line_number": "296",
          "type_description": "silent-process-execution",
          "context_snippet": "def kill_process_daemon(process_pid: int) -> None:\n    \"\"\"Start a daemon as a safety net to kill the process.\n\n    Args:\n        process_pid: The PID of the process to kill.\n    \"\"\"\n    # Get initial children list\n    try:\n        process = psutil.Process(process_pid)\n        initial_children = [p.pid for p in process.children(recursive=True)]\n    except psutil.NoSuchProcess:\n        initial_children = []\n\n    parent_pid = os.getpid()\n    daemon_script = os.path.join(\n        os.path.dirname(os.path.abspath(log_lib.__file__)),\n        'subprocess_daemon.py')\n    python_path = subprocess.check_output(constants.SKY_GET_PYTHON_PATH_CMD,\n                                          shell=True,\n                                          stderr=subprocess.DEVNULL,\n                                          encoding='utf-8').strip()\n    daemon_cmd = [\n        python_path,\n        daemon_script,\n        '--parent-pid',\n        str(parent_pid),\n        '--proc-pid',\n        str(process_pid),\n        # We pass the initial children list to avoid the race condition where\n        # the process_pid is terminated before the daemon starts and gets the\n        # children list.\n        '--initial-children',\n        ','.join(map(str, initial_children)),\n    ]\n\n    # We do not need to set `start_new_session=True` here, as the\n    # daemon script will detach itself from the parent process with\n    # fork to avoid being killed by parent process. See the reason we\n    # daemonize the process in `sky/skylet/subprocess_daemon.py`.\n    subprocess.Popen(\n        daemon_cmd,\n        # Suppress output\n        stdout=subprocess.DEVNULL,\n        stderr=subprocess.DEVNULL,\n        # Disable input\n        stdin=subprocess.DEVNULL,\n    )",
          "hash_value": "2d55a3cd00fb5c456c34d0d1dd8d8f5b",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def kill_process_daemon(process_pid: int) -> None:\n    \"\"\"Start a daemon as a safety net to kill the process.\n\n    Args:\n        process_pid: The PID of the process to kill.\n    \"\"\"\n    # Get initial children list\n    try:\n        process = psutil.Process(process_pid)\n        initial_children = [p.pid for p in process.children(recursive=True)]\n    except psutil.NoSuchProcess:\n        initial_children = []\n\n    parent_pid = os.getpid()\n    daemon_script = os.path.join(\n        os.path.dirname(os.path.abspath(log_lib.__file__)),\n        'subprocess_daemon.py')\n    python_path = subprocess.check_output(constants.SKY_GET_PYTHON_PATH_CMD,\n                                          shell=True,\n                                          stderr=subprocess.DEVNULL,\n                                          encoding='utf-8').strip()\n    daemon_cmd = [\n        python_path,\n        daemon_script,\n        '--parent-pid',\n        str(parent_pid),\n        '--proc-pid',\n        str(process_pid),\n        # We pass the initial children list to avoid the race condition where\n        # the process_pid is terminated before the daemon starts and gets the\n        # children list.\n        '--initial-children',\n        ','.join(map(str, initial_children)),\n    ]\n\n    # We do not need to set `start_new_session=True` here, as the\n    # daemon script will detach itself from the parent process with\n    # fork to avoid being killed by parent process. See the reason we\n    # daemonize the process in `sky/skylet/subprocess_daemon.py`.\n    subprocess.Popen(\n        daemon_cmd,\n        # Suppress output\n        stdout=subprocess.DEVNULL,\n        stderr=subprocess.DEVNULL,\n        # Disable input\n        stdin=subprocess.DEVNULL,\n    )",
              "triple_sequences": [
                {
                  "action_api": "psutil.Process()",
                  "action_description": "Retrieves process information",
                  "action_id": "get_process_info",
                  "object": "process_pid",
                  "object_description": "Process ID",
                  "object_id": "process_id",
                  "intention_description": "Collect process name",
                  "intention_id": "collect_process_name"
                },
                {
                  "action_api": "process.children()",
                  "action_description": "Iterates over all running processes",
                  "action_id": "iterate_processes",
                  "object": "recursive=True",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "List processes",
                  "intention_id": "list_processes"
                },
                {
                  "action_api": "os.getpid()",
                  "action_description": "Retrieves process information",
                  "action_id": "get_process_info",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect process name",
                  "intention_id": "collect_process_name"
                },
                {
                  "action_api": "os.path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "log_lib.__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Prepare path for file operations",
                  "intention_id": "prepare_path_file_operations"
                },
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.abspath(log_lib.__file__)",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Prepare path for file operations",
                  "intention_id": "prepare_path_file_operations"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "[os.path.dirname(os.path.abspath(log_lib.__file__)), 'subprocess_daemon.py']",
                  "object_description": "Script file path and image file",
                  "object_id": "script_path_with_image",
                  "intention_description": "Prepare path for file operations",
                  "intention_id": "prepare_path_file_operations"
                },
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "constants.SKY_GET_PYTHON_PATH_CMD",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Get Python executable path",
                  "intention_id": "get_python_executable_path"
                },
                {
                  "action_api": "str.strip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "map()",
                  "action_description": "Convert integers to characters",
                  "action_id": "convert_integers_to_chars",
                  "object": "str, initial_children",
                  "object_description": "Character code array",
                  "object_id": "character_code_array",
                  "intention_description": "Join characters into string",
                  "intention_id": "join_characters_into_string"
                },
                {
                  "action_api": "','.join()",
                  "action_description": "Convert integers to characters",
                  "action_id": "convert_integers_to_chars",
                  "object": "map(str, initial_children)",
                  "object_description": "Character code array",
                  "object_id": "character_code_array",
                  "intention_description": "Join characters into string",
                  "intention_id": "join_characters_into_string"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "daemon_cmd",
                  "object_description": "Background process",
                  "object_id": "background_process",
                  "intention_description": "Create child process",
                  "intention_id": "create_child_process"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pyexcel_xlsx-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyexcel_xlsx-0.6.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyexcel_xlsx-0.6.1/pyexcel_xlsx-0.6.1/setup.py",
          "line_number": "115",
          "type_description": "code-execution",
          "context_snippet": "class PublishCommand(Command):\n    \"\"\"Support setup.py upload.\"\"\"\n\n    description = \"Build and publish the package on github and pypi\"\n    user_options = []\n\n    @staticmethod\n    def status(s):\n        \"\"\"Prints things in bold.\"\"\"\n        print(\"\\033[1m{0}\\033[0m\".format(s))\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        try:\n            self.status(\"Removing previous builds...\")\n            rmtree(os.path.join(HERE, \"dist\"))\n            rmtree(os.path.join(HERE, \"build\"))\n            rmtree(os.path.join(HERE, \"pyexcel_xlsx.egg-info\"))\n        except OSError:\n            pass\n\n        self.status(\"Building Source and Wheel (universal) distribution...\")\n        run_status = True\n        if has_gease():\n            run_status = os.system(GS_COMMAND) == 0\n        else:\n            self.status(NO_GS_MESSAGE)\n        if run_status:\n            if os.system(PUBLISH_COMMAND) != 0:\n                self.status(UPLOAD_FAILED_MSG)\n\n        sys.exit()\n\n# Data dependencies:\n# - os: imported at top\n# - GS_COMMAND: defined as GS_COMMAND = (\"gease pyexcel-xlsx v0.6.1 \" + \"Find 0.6.1 in changelog for more details\")\n# - has_gease(): defined below\n# - self.status: defined in this class\n# - NO_GS_MESSAGE: defined as NO_GS_MESSAGE = (\"Automatic github release is disabled. \" + \"Please install gease to enable it.\")\n# - PUBLISH_COMMAND: defined as PUBLISH_COMMAND = \"{0} setup.py sdist bdist_wheel upload -r pypi\".format(sys.executable)\n# - UPLOAD_FAILED_MSG: defined as UPLOAD_FAILED_MSG = ('Upload failed. please run \"%s\" yourself.' % PUBLISH_COMMAND)\n# - rmtree: imported from shutil\n# - HERE: defined as HERE = os.path.abspath(os.path.dirname(__file__))",
          "hash_value": "ed33711fe65763eff0bad832b85602fd",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class PublishCommand(Command):\n    \"\"\"Support setup.py upload.\"\"\"\n\n    description = \"Build and publish the package on github and pypi\"\n    user_options = []\n\n    @staticmethod\n    def status(s):\n        \"\"\"Prints things in bold.\"\"\"\n        print(\"\\033[1m{0}\\033[0m\".format(s))\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        try:\n            self.status(\"Removing previous builds...\")\n            rmtree(os.path.join(HERE, \"dist\"))\n            rmtree(os.path.join(HERE, \"build\"))\n            rmtree(os.path.join(HERE, \"pyexcel_xlsx.egg-info\"))\n        except OSError:\n            pass\n\n        self.status(\"Building Source and Wheel (universal) distribution...\")\n        run_status = True\n        if has_gease():\n            run_status = os.system(GS_COMMAND) == 0\n        else:\n            self.status(NO_GS_MESSAGE)\n        if run_status:\n            if os.system(PUBLISH_COMMAND) != 0:\n                self.status(UPLOAD_FAILED_MSG)\n\n        sys.exit()\n\n# Data dependencies:\n# - os: imported at top\n# - GS_COMMAND: defined as GS_COMMAND = (\"gease pyexcel-xlsx v0.6.1 \" + \"Find 0.6.1 in changelog for more details\")\n# - has_gease(): defined below\n# - self.status: defined in this class\n# - NO_GS_MESSAGE: defined as NO_GS_MESSAGE = (\"Automatic github release is disabled. \" + \"Please install gease to enable it.\")\n# - PUBLISH_COMMAND: defined as PUBLISH_COMMAND = \"{0} setup.py sdist bdist_wheel upload -r pypi\".format(sys.executable)\n# - UPLOAD_FAILED_MSG: defined as UPLOAD_FAILED_MSG = ('Upload failed. please run \"%s\" yourself.' % PUBLISH_COMMAND)\n# - rmtree: imported from shutil\n# - HERE: defined as HERE = os.path.abspath(os.path.dirname(__file__))",
              "triple_sequences": [
                {
                  "action_api": "self.status()",
                  "action_description": "Prints things in bold.",
                  "action_id": "",
                  "object": "\"Removing previous builds...\"",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Acknowledge keylogger start/stop",
                  "intention_id": "acknowledge_keylogger_status"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "HERE, \"dist\"",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "rmtree()",
                  "action_description": "Recursively deletes directory and its contents",
                  "action_id": "delete_directory",
                  "object": "os.path.join(HERE, \"dist\")",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Delete directory content",
                  "intention_id": "delete_directory_content"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "HERE, \"build\"",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "rmtree()",
                  "action_description": "Recursively deletes directory and its contents",
                  "action_id": "delete_directory",
                  "object": "os.path.join(HERE, \"build\")",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Delete directory content",
                  "intention_id": "delete_directory_content"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "HERE, \"pyexcel_xlsx.egg-info\"",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "rmtree()",
                  "action_description": "Recursively deletes directory and its contents",
                  "action_id": "delete_directory",
                  "object": "os.path.join(HERE, \"pyexcel_xlsx.egg-info\")",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Delete directory content",
                  "intention_id": "delete_directory_content"
                },
                {
                  "action_api": "self.status()",
                  "action_description": "Prints things in bold.",
                  "action_id": "",
                  "object": "\"Building Source and Wheel (universal) distribution...\"",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Acknowledge keylogger start/stop",
                  "intention_id": "acknowledge_keylogger_status"
                },
                {
                  "action_api": "has_gease()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "GS_COMMAND",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "self.status()",
                  "action_description": "Prints things in bold.",
                  "action_id": "",
                  "object": "NO_GS_MESSAGE",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Acknowledge keylogger start/stop",
                  "intention_id": "acknowledge_keylogger_status"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "PUBLISH_COMMAND",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "self.status()",
                  "action_description": "Prints things in bold.",
                  "action_id": "",
                  "object": "UPLOAD_FAILED_MSG",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Acknowledge keylogger start/stop",
                  "intention_id": "acknowledge_keylogger_status"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pyro_ppl-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyro_ppl-1.9.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "bart.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyro_ppl-1.9.1/pyro_ppl-1.9.1/pyro/contrib/examples/bart.py",
          "line_number": "22",
          "type_description": "shady-links",
          "context_snippet": "# https://www.bart.gov/about/reports/ridership\nSOURCE_DIR = \"http://64.111.127.166/origin-destination/\"\nSOURCE_FILES = [\n    \"date-hour-soo-dest-2011.csv.gz\",\n    \"date-hour-soo-dest-2012.csv.gz\",\n    \"date-hour-soo-dest-2013.csv.gz\",\n    \"date-hour-soo-dest-2014.csv.gz\",\n    \"date-hour-soo-dest-2015.csv.gz\",\n    \"date-hour-soo-dest-2016.csv.gz\",\n    \"date-hour-soo-dest-2017.csv.gz\",\n    \"date-hour-soo-dest-2018.csv.gz\",\n    \"date-hour-soo-dest-2019.csv.gz\",\n]\nCACHE_URL = \"https://d2hg8soec8ck9v.cloudfront.net/datasets/bart_full.pkl.bz2\"\n\n\ndef _load_hourly_od(basename):\n    filename = os.path.join(DATA, basename.replace(\".csv.gz\", \".pkl\"))\n    if os.path.exists(filename):\n        return filename\n\n    # Download source files.\n    gz_filename = os.path.join(DATA, basename)\n    if not os.path.exists(gz_filename):\n        url = SOURCE_DIR + basename\n        logging.debug(\"downloading {}\".format(url))\n        urllib.request.urlretrieve(url, gz_filename)\n    csv_filename = gz_filename[:-3]\n    assert csv_filename.endswith(\".csv\")\n    if not os.path.exists(csv_filename):\n        logging.debug(\"unzipping {}\".format(gz_filename))\n        subprocess.check_call([\"gunzip\", \"-k\", gz_filename])\n    assert os.path.exists(csv_filename)\n\n    # Convert to PyTorch.\n    logging.debug(\"converting {}\".format(csv_filename))\n    start_date = datetime.datetime.strptime(\"2000-01-01\", \"%Y-%m-%d\")\n    stations = {}\n    num_rows = sum(1 for _ in open(csv_filename))\n    logging.info(\"Formatting {} rows\".format(num_rows))\n    rows = torch.empty((num_rows, 4), dtype=torch.long)\n    with open(csv_filename) as f:\n        for i, (date, hour, origin, destin, trip_count) in enumerate(csv.reader(f)):\n            date = datetime.datetime.strptime(date, \"%Y-%m-%d\")\n            date += datetime.timedelta(hours=int(hour))\n            rows[i, 0] = int((date - start_date).total_seconds() / 3600)\n            rows[i, 1] = stations.setdefault(origin, len(stations))\n            rows[i, 2] = stations.setdefault(destin, len(stations))\n            rows[i, 3] = int(trip_count)\n            if i % 10000 == 0:\n                sys.stderr.write(\".\")\n                sys.stderr.flush()\n\n    # Save data with metadata.\n    dataset = {\n        \"basename\": basename,\n        \"start_date\": start_date,\n        \"stations\": stations,\n        \"rows\": rows,\n        \"schema\": [\"time_hours\", \"origin\", \"destin\", \"trip_count\"],\n    }\n    dataset[\"rows\"]\n    logging.debug(\"saving {}\".format(filename))\n    torch.save(dataset, filename)\n    return filename",
          "hash_value": "74fa02613e0f87aaae25602880284456",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "# https://www.bart.gov/about/reports/ridership\nSOURCE_DIR = \"http://64.111.127.166/origin-destination/\"\nSOURCE_FILES = [\n    \"date-hour-soo-dest-2011.csv.gz\",\n    \"date-hour-soo-dest-2012.csv.gz\",\n    \"date-hour-soo-dest-2013.csv.gz\",\n    \"date-hour-soo-dest-2014.csv.gz\",\n    \"date-hour-soo-dest-2015.csv.gz\",\n    \"date-hour-soo-dest-2016.csv.gz\",\n    \"date-hour-soo-dest-2017.csv.gz\",\n    \"date-hour-soo-dest-2018.csv.gz\",\n    \"date-hour-soo-dest-2019.csv.gz\",\n]\nCACHE_URL = \"https://d2hg8soec8ck9v.cloudfront.net/datasets/bart_full.pkl.bz2\"\n\n\ndef _load_hourly_od(basename):\n    filename = os.path.join(DATA, basename.replace(\".csv.gz\", \".pkl\"))\n    if os.path.exists(filename):\n        return filename\n\n    # Download source files.\n    gz_filename = os.path.join(DATA, basename)\n    if not os.path.exists(gz_filename):\n        url = SOURCE_DIR + basename\n        logging.debug(\"downloading {}\".format(url))\n        urllib.request.urlretrieve(url, gz_filename)\n    csv_filename = gz_filename[:-3]\n    assert csv_filename.endswith(\".csv\")\n    if not os.path.exists(csv_filename):\n        logging.debug(\"unzipping {}\".format(gz_filename))\n        subprocess.check_call([\"gunzip\", \"-k\", gz_filename])\n    assert os.path.exists(csv_filename)\n\n    # Convert to PyTorch.\n    logging.debug(\"converting {}\".format(csv_filename))\n    start_date = datetime.datetime.strptime(\"2000-01-01\", \"%Y-%m-%d\")\n    stations = {}\n    num_rows = sum(1 for _ in open(csv_filename))\n    logging.info(\"Formatting {} rows\".format(num_rows))\n    rows = torch.empty((num_rows, 4), dtype=torch.long)\n    with open(csv_filename) as f:\n        for i, (date, hour, origin, destin, trip_count) in enumerate(csv.reader(f)):\n            date = datetime.datetime.strptime(date, \"%Y-%m-%d\")\n            date += datetime.timedelta(hours=int(hour))\n            rows[i, 0] = int((date - start_date).total_seconds() / 3600)\n            rows[i, 1] = stations.setdefault(origin, len(stations))\n            rows[i, 2] = stations.setdefault(destin, len(stations))\n            rows[i, 3] = int(trip_count)\n            if i % 10000 == 0:\n                sys.stderr.write(\".\")\n                sys.stderr.flush()\n\n    # Save data with metadata.\n    dataset = {\n        \"basename\": basename,\n        \"start_date\": start_date,\n        \"stations\": stations,\n        \"rows\": rows,\n        \"schema\": [\"time_hours\", \"origin\", \"destin\", \"trip_count\"],\n    }\n    dataset[\"rows\"]\n    logging.debug(\"saving {}\".format(filename))\n    torch.save(dataset, filename)\n    return filename",
              "triple_sequences": [
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "DATA, basename.replace('.csv.gz', '.pkl')",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "filename",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "DATA, basename",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "gz_filename",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "urllib.request.urlretrieve()",
                  "action_description": "Downloads file from URL to local path",
                  "action_id": "download_file_url",
                  "object": "url, gz_filename",
                  "object_description": "External domain",
                  "object_id": "external_domain",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "csv_filename",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"gunzip\", \"-k\", gz_filename]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "csv_filename",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "datetime.datetime.strptime()",
                  "action_description": "Parses string into datetime object",
                  "action_id": "parse_datetime",
                  "object": "\"2000-01-01\", \"%Y-%m-%d\"",
                  "object_description": "String containing environment data",
                  "object_id": "string_environment_data",
                  "intention_description": "Get datetime epoch",
                  "intention_id": "get_datetime_epoch"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "csv_filename",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "csv.reader()",
                  "action_description": "Iterates over response content in chunks",
                  "action_id": "iterate_response_chunks",
                  "object": "f",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "datetime.datetime.strptime()",
                  "action_description": "Parses string into datetime object",
                  "action_id": "parse_datetime",
                  "object": "date, \"%Y-%m-%d\"",
                  "object_description": "String containing environment data",
                  "object_id": "string_environment_data",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "datetime.timedelta()",
                  "action_description": "Parses string into datetime object",
                  "action_id": "parse_datetime",
                  "object": "hours=int(hour)",
                  "object_description": "Delay duration in seconds",
                  "object_id": "delay_duration",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "sys.stderr.write()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "\".\"",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "sys.stderr.flush()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "torch.save()",
                  "action_description": "Saves image to file",
                  "action_id": "save_image_file",
                  "object": "dataset, filename",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pydoop-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pydoop-2.0.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pydoop-2.0.0/pydoop-2.0.0/setup.py",
          "line_number": "229",
          "type_description": "code-execution",
          "context_snippet": "class JavaBuilder(object):\n\n    def __init__(self, build_temp, build_lib):\n        self.build_temp = build_temp\n        self.build_lib = build_lib\n        self.java_libs = [JavaLib()]\n\n    def run(self):\n        for jlib in self.java_libs:\n            self.__build_java_lib(jlib)\n\n    def __build_java_lib(self, jlib):\n        package_path = os.path.join(self.build_lib, \"pydoop\")\n        compile_cmd = \"javac\"\n        if jlib.classpath:\n            classpath = [jlib.classpath]\n            for src in jlib.dependencies:\n                dest = os.path.join(package_path, os.path.basename(src))\n                shutil.copyfile(src, dest)\n                classpath.append(dest)\n            compile_cmd += \" -classpath %s\" % (':'.join(classpath))\n        else:\n            log.warn(\n                \"WARNING: could not set classpath, java code may not compile\"\n            )\n        class_dir = os.path.join(\n            self.build_temp, \"pipes\"\n        )\n        jar_path = os.path.join(package_path, jlib.jar_name)\n        if not os.path.exists(class_dir):\n            os.mkdir(class_dir)\n        compile_cmd += \" -d '%s'\" % class_dir\n        log.info(\"Compiling Java classes\")\n        for f in jlib.java_files:\n            compile_cmd += \" %s\" % f\n        ret = os.system(compile_cmd)\n        if ret:\n            raise DistutilsSetupError(\n                \"Error compiling java component.  Command: %s\" % compile_cmd\n            )\n        log.info(\"Copying properties file\")\n        for p in jlib.properties:\n            prop_file_dest = os.path.join(class_dir, p[0])\n            shutil.copyfile(p[1], prop_file_dest)\n        log.info(\"Making Jar: %s\", jar_path)\n        package_cmd = \"jar -cf %(jar_path)s -C %(class_dir)s ./it\" % {\n            'jar_path': jar_path, 'class_dir': class_dir\n        }\n        log.info(\"Packaging Java classes\")\n        log.info(\"Command: %s\", package_cmd)\n        ret = os.system(package_cmd)\n        if ret:\n            raise DistutilsSetupError(\n                \"Error packaging java component.  Command: %s\" % package_cmd\n            )",
          "hash_value": "9a3805661d08704d5e66150bf0b11885",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class JavaBuilder(object):\n\n    def __init__(self, build_temp, build_lib):\n        self.build_temp = build_temp\n        self.build_lib = build_lib\n        self.java_libs = [JavaLib()]\n\n    def run(self):\n        for jlib in self.java_libs:\n            self.__build_java_lib(jlib)\n\n    def __build_java_lib(self, jlib):\n        package_path = os.path.join(self.build_lib, \"pydoop\")\n        compile_cmd = \"javac\"\n        if jlib.classpath:\n            classpath = [jlib.classpath]\n            for src in jlib.dependencies:\n                dest = os.path.join(package_path, os.path.basename(src))\n                shutil.copyfile(src, dest)\n                classpath.append(dest)\n            compile_cmd += \" -classpath %s\" % (':'.join(classpath))\n        else:\n            log.warn(\n                \"WARNING: could not set classpath, java code may not compile\"\n            )\n        class_dir = os.path.join(\n            self.build_temp, \"pipes\"\n        )\n        jar_path = os.path.join(package_path, jlib.jar_name)\n        if not os.path.exists(class_dir):\n            os.mkdir(class_dir)\n        compile_cmd += \" -d '%s'\" % class_dir\n        log.info(\"Compiling Java classes\")\n        for f in jlib.java_files:\n            compile_cmd += \" %s\" % f\n        ret = os.system(compile_cmd)\n        if ret:\n            raise DistutilsSetupError(\n                \"Error compiling java component.  Command: %s\" % compile_cmd\n            )\n        log.info(\"Copying properties file\")\n        for p in jlib.properties:\n            prop_file_dest = os.path.join(class_dir, p[0])\n            shutil.copyfile(p[1], prop_file_dest)\n        log.info(\"Making Jar: %s\", jar_path)\n        package_cmd = \"jar -cf %(jar_path)s -C %(class_dir)s ./it\" % {\n            'jar_path': jar_path, 'class_dir': class_dir\n        }\n        log.info(\"Packaging Java classes\")\n        log.info(\"Command: %s\", package_cmd)\n        ret = os.system(package_cmd)\n        if ret:\n            raise DistutilsSetupError(\n                \"Error packaging java component.  Command: %s\" % package_cmd\n            )",
              "triple_sequences": [
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "self.build_lib, \"pydoop\"",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.basename()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "src",
                  "object_description": "Local file or directory name",
                  "object_id": "local_file_or_directory_name",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "package_path, os.path.basename(src)",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "shutil.copyfile()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "src, dest",
                  "object_description": "Local file or directory",
                  "object_id": "local_file_or_directory",
                  "intention_description": "Copy file to temporary directory",
                  "intention_id": "copy_file_temp_directory"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "self.build_temp, \"pipes\"",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "package_path, jlib.jar_name",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "class_dir",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "os.mkdir()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "class_dir",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "compile_cmd",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "class_dir, p[0]",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "shutil.copyfile()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "p[1], prop_file_dest",
                  "object_description": "Local file or directory",
                  "object_id": "local_file_or_directory",
                  "intention_description": "Copy file to temporary directory",
                  "intention_id": "copy_file_temp_directory"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "package_cmd",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "future-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/future-1.0.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "__init__.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/future-1.0.0/future-1.0.0/src/future/utils/__init__.py",
          "line_number": "652",
          "type_description": "obfuscation",
          "context_snippet": "if PY3:\n    import builtins\n    exec_ = getattr(builtins, \"exec\")\nelse:\n    def exec_(code, globs=None, locs=None):\n        \"\"\"Execute code in a namespace.\"\"\"\n        if globs is None:\n            frame = sys._getframe(1)\n            globs = frame.f_globals\n            if locs is None:\n                locs = frame.f_locals\n            del frame\n        elif locs is None:\n            locs = globs\n        exec(\"\"\"exec code in globs, locs\"\"\")",
          "hash_value": "d20b22ef373e026217be1065de5554ff",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "if PY3:\n    import builtins\n    exec_ = getattr(builtins, \"exec\")\nelse:\n    def exec_(code, globs=None, locs=None):\n        \"\"\"Execute code in a namespace.\"\"\"\n        if globs is None:\n            frame = sys._getframe(1)\n            globs = frame.f_globals\n            if locs is None:\n                locs = frame.f_locals\n            del frame\n        elif locs is None:\n            locs = globs\n        exec(\"\"\"exec code in globs, locs\"\"\")",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, \"exec\"",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "exec()",
                  "action_description": "Dynamically executes Python code string",
                  "action_id": "exec_python_code",
                  "object": "code",
                  "object_description": "Python code string",
                  "object_id": "python_code_string",
                  "intention_description": "Execute Python code",
                  "intention_id": "execute_python_code"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "strongtyping-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/strongtyping-3.13.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "docstring_typing.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/strongtyping-3.13.1/strongtyping-3.13.1/strongtyping/docstring_typing.py",
          "line_number": "46",
          "type_description": "obfuscation",
          "context_snippet": "import builtins\nimport typing\n\ndef param_attr(attr: str):\n    \"\"\"\n    :return: builtin class or typing instance\n    \"\"\"\n    try:\n        return getattr(typing, attr)\n    except AttributeError:\n        return getattr(builtins, attr)",
          "hash_value": "155eb60c316cd5601af44c255ea03658",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import builtins\nimport typing\n\ndef param_attr(attr: str):\n    \"\"\"\n    :return: builtin class or typing instance\n    \"\"\"\n    try:\n        return getattr(typing, attr)\n    except AttributeError:\n        return getattr(builtins, attr)",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "typing, attr",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "builtins, attr",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pdbpp-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pdbpp-0.10.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pdbpp-0.10.3/pdbpp-0.10.3/setup.py",
          "line_number": "53",
          "type_description": "cmd-overwrite",
          "context_snippet": "setup(\n    name='pdbpp',\n    use_scm_version=True,\n    author='Antonio Cuni',\n    author_email='anto.cuni@gmail.com',\n    py_modules=['pdb', '_pdbpp_path_hack.pdb'],\n    url='http://github.com/antocuni/pdb',\n    license='BSD',\n    platforms=['unix', 'linux', 'osx', 'cygwin', 'win32'],\n    description='pdb++, a drop-in replacement for pdb',\n    long_description=long_description,\n    keywords='pdb debugger tab color completion',\n    classifiers=[\n        'Development Status :: 4 - Beta',\n        'Environment :: Console',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: BSD License',\n        'Operating System :: POSIX',\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.2',\n        'Programming Language :: Python :: 3.3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: Implementation :: CPython',\n        'Programming Language :: Python :: Implementation :: PyPy',\n        'Programming Language :: Python',\n        'Topic :: Utilities',\n        'Topic :: Software Development :: Debuggers',\n    ],\n    install_requires=[\n        \"fancycompleter>=0.8\",\n        \"wmctrl\",\n        \"pygments\",\n    ],\n    extras_require={\n        'funcsigs': [\"funcsigs\"],\n        'testing': [\n            'funcsigs',\n            'pytest',\n        ],\n    },\n    setup_requires=['setuptools_scm'],\n    cmdclass={\n        'install': install_with_pth,\n        'install_pth_hack': install_pth_hack,\n    }\n)",
          "hash_value": "e72e8fd1ec65b6597f0c9a7878b88e2a",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "setup(\n    name='pdbpp',\n    use_scm_version=True,\n    author='Antonio Cuni',\n    author_email='anto.cuni@gmail.com',\n    py_modules=['pdb', '_pdbpp_path_hack.pdb'],\n    url='http://github.com/antocuni/pdb',\n    license='BSD',\n    platforms=['unix', 'linux', 'osx', 'cygwin', 'win32'],\n    description='pdb++, a drop-in replacement for pdb',\n    long_description=long_description,\n    keywords='pdb debugger tab color completion',\n    classifiers=[\n        'Development Status :: 4 - Beta',\n        'Environment :: Console',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: BSD License',\n        'Operating System :: POSIX',\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.2',\n        'Programming Language :: Python :: 3.3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: Implementation :: CPython',\n        'Programming Language :: Python :: Implementation :: PyPy',\n        'Programming Language :: Python',\n        'Topic :: Utilities',\n        'Topic :: Software Development :: Debuggers',\n    ],\n    install_requires=[\n        \"fancycompleter>=0.8\",\n        \"wmctrl\",\n        \"pygments\",\n    ],\n    extras_require={\n        'funcsigs': [\"funcsigs\"],\n        'testing': [\n            'funcsigs',\n            'pytest',\n        ],\n    },\n    setup_requires=['setuptools_scm'],\n    cmdclass={\n        'install': install_with_pth,\n        'install_pth_hack': install_pth_hack,\n    }\n)",
              "triple_sequences": [
                {
                  "action_api": "setup()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "{'name': 'pdbpp', 'use_scm_version': True, 'author': 'Antonio Cuni', 'author_email': 'anto.cuni@gmail.com', 'py_modules': ['pdb', '_pdbpp_path_hack.pdb'], 'url': 'http://github.com/antocuni/pdb', 'license': 'BSD', 'platforms': ['unix', 'linux', 'osx', 'cygwin', 'win32'], 'description': 'pdb++, a drop-in replacement for pdb', 'long_description': long_description, 'keywords': 'pdb debugger tab color completion', 'classifiers': [...], 'install_requires': ['fancycompleter>=0.8', 'wmctrl', 'pygments'], 'extras_require': {'funcsigs': ['funcsigs'], 'testing': ['funcsigs', 'pytest']}, 'setup_requires': ['setuptools_scm'], 'cmdclass': {'install': install_with_pth, 'install_pth_hack': install_pth_hack}}",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "jsonargparse-4",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/jsonargparse-4.38.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "_util.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/jsonargparse-4.38.0/jsonargparse-4.38.0/jsonargparse/_util.py",
          "line_number": "581",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "class Path(PathDeprecations):\n    ...\n    def __init__(\n        self,\n        path: Union[str, os.PathLike, \"Path\"],\n        mode: str = \"fr\",\n        cwd: Optional[Union[str, os.PathLike]] = None,\n        **kwargs,\n    ):\n        ...\n        if not self._skip_check and is_url:\n            if \"r\" in mode:\n                requests = import_requests(\"Path with URL support\")\n                try:\n                    requests.head(abs_path).raise_for_status()\n                except requests.HTTPError as ex:\n                    raise PathError(f\"{abs_path} HEAD not accessible :: {ex}\") from ex\n        ...\n",
          "hash_value": "0f6f59e5aacde3b77a80da825a0b7f5e",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class Path(PathDeprecations):\n    ...\n    def __init__(\n        self,\n        path: Union[str, os.PathLike, \"Path\"],\n        mode: str = \"fr\",\n        cwd: Optional[Union[str, os.PathLike]] = None,\n        **kwargs,\n    ):\n        ...\n        if not self._skip_check and is_url:\n            if \"r\" in mode:\n                requests = import_requests(\"Path with URL support\")\n                try:\n                    requests.head(abs_path).raise_for_status()\n                except requests.HTTPError as ex:\n                    raise PathError(f\"{abs_path} HEAD not accessible :: {ex}\") from ex\n        ...\n",
              "triple_sequences": [
                {
                  "action_api": "import_requests()",
                  "action_description": "Dynamically imports specified module",
                  "action_id": "import_dynamic",
                  "object": "\"Path with URL support\"",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "requests.head()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "abs_path",
                  "object_description": "URL string",
                  "object_id": "url_string",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "requests.HTTPError",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "ex",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "python_telegram_bot-22",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/python_telegram_bot-22.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "_applicationbuilder.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/python_telegram_bot-22.0/python_telegram_bot-22.0/telegram/ext/_applicationbuilder.py",
          "line_number": "176",
          "type_description": "shady-links",
          "context_snippet": "class ApplicationBuilder(Generic[BT, CCT, UD, CD, BD, JQ]):\n    ...\n    def __init__(self: \"InitApplicationBuilder\"):\n        self._token: DVType[str] = DefaultValue(\"\")\n        self._base_url: DVType[BaseUrl] = DefaultValue(\"https://api.telegram.org/bot\")\n        self._base_file_url: DVType[BaseUrl] = DefaultValue(\"https://api.telegram.org/file/bot\")\n        self._connection_pool_size: DVInput[int] = DEFAULT_NONE\n        self._proxy: DVInput[Union[str, httpx.Proxy, httpx.URL]] = DEFAULT_NONE\n        self._socket_options: DVInput[Collection[SocketOpt]] = DEFAULT_NONE\n        self._connect_timeout: ODVInput[float] = DEFAULT_NONE\n        self._read_timeout: ODVInput[float] = DEFAULT_NONE\n        self._write_timeout: ODVInput[float] = DEFAULT_NONE\n        self._media_write_timeout: ODVInput[float] = DEFAULT_NONE\n        self._pool_timeout: ODVInput[float] = DEFAULT_NONE\n        self._request: DVInput[BaseRequest] = DEFAULT_NONE\n        self._get_updates_connection_pool_size: DVInput[int] = DEFAULT_NONE\n        self._get_updates_proxy: DVInput[Union[str, httpx.Proxy, httpx.URL]] = DEFAULT_NONE\n        self._get_updates_socket_options: DVInput[Collection[SocketOpt]] = DEFAULT_NONE\n        self._get_updates_connect_timeout: ODVInput[float] = DEFAULT_NONE\n        self._get_updates_read_timeout: ODVInput[float] = DEFAULT_NONE\n        self._get_updates_write_timeout: ODVInput[float] = DEFAULT_NONE\n        self._get_updates_pool_timeout: ODVInput[float] = DEFAULT_NONE\n        self._get_updates_request: DVInput[BaseRequest] = DEFAULT_NONE\n        self._get_updates_http_version: DVInput[str] = DefaultValue(\"1.1\")\n        self._private_key: ODVInput[bytes] = DEFAULT_NONE\n        self._private_key_password: ODVInput[bytes] = DEFAULT_NONE\n        self._defaults: ODVInput[Defaults] = DEFAULT_NONE\n        self._arbitrary_callback_data: Union[DefaultValue[bool], int] = DEFAULT_FALSE\n        self._local_mode: DVType[bool] = DEFAULT_FALSE\n        self._bot: DVInput[Bot] = DEFAULT_NONE\n        self._update_queue: DVType[Queue[Union[Update, object]]] = DefaultValue(Queue())\n\n        try:\n            self._job_queue: ODVInput[JobQueue] = DefaultValue(JobQueue())\n        except RuntimeError as exc:\n            if \"PTB must be installed via\" not in str(exc):\n                raise\n            self._job_queue = DEFAULT_NONE\n\n        self._persistence: ODVInput[BasePersistence] = DEFAULT_NONE\n        self._context_types: DVType[ContextTypes] = DefaultValue(ContextTypes())\n        self._application_class: DVType[type[Application]] = DefaultValue(Application)\n        self._application_kwargs: dict[str, object] = {}\n        self._update_processor: BaseUpdateProcessor = SimpleUpdateProcessor(\n            max_concurrent_updates=1\n        )\n        self._updater: ODVInput[Updater] = DEFAULT_NONE\n        self._post_init: Optional[Callable[[Application], Coroutine[Any, Any, None]]] = None\n        self._post_shutdown: Optional[Callable[[Application], Coroutine[Any, Any, None]]] = None\n        self._post_stop: Optional[Callable[[Application], Coroutine[Any, Any, None]]] = None\n        self._rate_limiter: ODVInput[BaseRateLimiter] = DEFAULT_NONE\n        self._http_version: DVInput[str] = DefaultValue(\"1.1\")",
          "hash_value": "a374de513d7cf590ecb08953906901fb",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class ApplicationBuilder(Generic[BT, CCT, UD, CD, BD, JQ]):\n    ...\n    def __init__(self: \"InitApplicationBuilder\"):\n        self._token: DVType[str] = DefaultValue(\"\")\n        self._base_url: DVType[BaseUrl] = DefaultValue(\"https://api.telegram.org/bot\")\n        self._base_file_url: DVType[BaseUrl] = DefaultValue(\"https://api.telegram.org/file/bot\")\n        self._connection_pool_size: DVInput[int] = DEFAULT_NONE\n        self._proxy: DVInput[Union[str, httpx.Proxy, httpx.URL]] = DEFAULT_NONE\n        self._socket_options: DVInput[Collection[SocketOpt]] = DEFAULT_NONE\n        self._connect_timeout: ODVInput[float] = DEFAULT_NONE\n        self._read_timeout: ODVInput[float] = DEFAULT_NONE\n        self._write_timeout: ODVInput[float] = DEFAULT_NONE\n        self._media_write_timeout: ODVInput[float] = DEFAULT_NONE\n        self._pool_timeout: ODVInput[float] = DEFAULT_NONE\n        self._request: DVInput[BaseRequest] = DEFAULT_NONE\n        self._get_updates_connection_pool_size: DVInput[int] = DEFAULT_NONE\n        self._get_updates_proxy: DVInput[Union[str, httpx.Proxy, httpx.URL]] = DEFAULT_NONE\n        self._get_updates_socket_options: DVInput[Collection[SocketOpt]] = DEFAULT_NONE\n        self._get_updates_connect_timeout: ODVInput[float] = DEFAULT_NONE\n        self._get_updates_read_timeout: ODVInput[float] = DEFAULT_NONE\n        self._get_updates_write_timeout: ODVInput[float] = DEFAULT_NONE\n        self._get_updates_pool_timeout: ODVInput[float] = DEFAULT_NONE\n        self._get_updates_request: DVInput[BaseRequest] = DEFAULT_NONE\n        self._get_updates_http_version: DVInput[str] = DefaultValue(\"1.1\")\n        self._private_key: ODVInput[bytes] = DEFAULT_NONE\n        self._private_key_password: ODVInput[bytes] = DEFAULT_NONE\n        self._defaults: ODVInput[Defaults] = DEFAULT_NONE\n        self._arbitrary_callback_data: Union[DefaultValue[bool], int] = DEFAULT_FALSE\n        self._local_mode: DVType[bool] = DEFAULT_FALSE\n        self._bot: DVInput[Bot] = DEFAULT_NONE\n        self._update_queue: DVType[Queue[Union[Update, object]]] = DefaultValue(Queue())\n\n        try:\n            self._job_queue: ODVInput[JobQueue] = DefaultValue(JobQueue())\n        except RuntimeError as exc:\n            if \"PTB must be installed via\" not in str(exc):\n                raise\n            self._job_queue = DEFAULT_NONE\n\n        self._persistence: ODVInput[BasePersistence] = DEFAULT_NONE\n        self._context_types: DVType[ContextTypes] = DefaultValue(ContextTypes())\n        self._application_class: DVType[type[Application]] = DefaultValue(Application)\n        self._application_kwargs: dict[str, object] = {}\n        self._update_processor: BaseUpdateProcessor = SimpleUpdateProcessor(\n            max_concurrent_updates=1\n        )\n        self._updater: ODVInput[Updater] = DEFAULT_NONE\n        self._post_init: Optional[Callable[[Application], Coroutine[Any, Any, None]]] = None\n        self._post_shutdown: Optional[Callable[[Application], Coroutine[Any, Any, None]]] = None\n        self._post_stop: Optional[Callable[[Application], Coroutine[Any, Any, None]]] = None\n        self._rate_limiter: ODVInput[BaseRateLimiter] = DEFAULT_NONE\n        self._http_version: DVInput[str] = DefaultValue(\"1.1\")",
              "triple_sequences": [
                {
                  "action_api": "DefaultValue()",
                  "action_description": "Instantiates class",
                  "action_id": "init_telegram_class",
                  "object": "\"\"",
                  "object_description": "Random string",
                  "object_id": "random_string",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "DefaultValue()",
                  "action_description": "Instantiates class",
                  "action_id": "init_telegram_class",
                  "object": "\"https://api.telegram.org/bot\"",
                  "object_description": "Telegram API endpoint",
                  "object_id": "telegram_api_endpoint",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "DefaultValue()",
                  "action_description": "Instantiates class",
                  "action_id": "init_telegram_class",
                  "object": "\"https://api.telegram.org/file/bot\"",
                  "object_description": "Telegram API endpoint",
                  "object_id": "telegram_api_endpoint",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "DefaultValue()",
                  "action_description": "Instantiates class",
                  "action_id": "init_telegram_class",
                  "object": "\"1.1\"",
                  "object_description": "Random string",
                  "object_id": "random_string",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "DefaultValue()",
                  "action_description": "Instantiates class",
                  "action_id": "init_telegram_class",
                  "object": "Queue()",
                  "object_description": "Thread function arguments",
                  "object_id": "thread_arguments",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "JobQueue()",
                  "action_description": "Instantiates class",
                  "action_id": "init_telegram_class",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "ContextTypes()",
                  "action_description": "Instantiates class",
                  "action_id": "init_telegram_class",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "DefaultValue()",
                  "action_description": "Instantiates class",
                  "action_id": "init_telegram_class",
                  "object": "ContextTypes()",
                  "object_description": "Thread function arguments",
                  "object_id": "thread_arguments",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "DefaultValue()",
                  "action_description": "Instantiates class",
                  "action_id": "init_telegram_class",
                  "object": "Application",
                  "object_description": "Thread function arguments",
                  "object_id": "thread_arguments",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "SimpleUpdateProcessor()",
                  "action_description": "Instantiates class",
                  "action_id": "init_telegram_class",
                  "object": "max_concurrent_updates=1",
                  "object_description": "Thread function arguments",
                  "object_id": "thread_arguments",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "databricks_sdk-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/databricks_sdk-0.49.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "credentials_provider.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/databricks_sdk-0.49.0/databricks_sdk-0.49.0/databricks/sdk/credentials_provider.py",
          "line_number": "331",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "@oauth_credentials_strategy(\"github-oidc-azure\", [\"host\", \"azure_client_id\"])\ndef github_oidc_azure(cfg: \"Config\") -> Optional[CredentialsProvider]:\n    if \"ACTIONS_ID_TOKEN_REQUEST_TOKEN\" not in os.environ:\n        # not in GitHub actions\n        return None\n\n    # Client ID is the minimal thing we need, as otherwise we get AADSTS700016: Application with\n    # identifier 'https://token.actions.githubusercontent.com' was not found in the directory '...'.\n    if not cfg.is_azure:\n        return None\n\n    # See https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers\n    headers = {\"Authorization\": f\"Bearer {os.environ['ACTIONS_ID_TOKEN_REQUEST_TOKEN']}\"}\n    endpoint = f\"{os.environ['ACTIONS_ID_TOKEN_REQUEST_URL']}&audience=api://AzureADTokenExchange\"\n    response = requests.get(endpoint, headers=headers)\n    if not response.ok:\n        return None\n\n    # get the ID Token with aud=api://AzureADTokenExchange sub=repo:org/repo:environment:name\n    response_json = response.json()\n    if \"value\" not in response_json:\n        return None\n\n    logger.info(\n        \"Configured AAD token for GitHub Actions OIDC (%s)\",\n        cfg.azure_client_id,\n    )\n    params = {\n        \"client_assertion_type\": \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\",\n        \"resource\": cfg.effective_azure_login_app_id,\n        \"client_assertion\": response_json[\"value\"],\n    }\n    aad_endpoint = cfg.arm_environment.active_directory_endpoint\n    if not cfg.azure_tenant_id:\n        # detect Azure AD Tenant ID if it's not specified directly\n        token_endpoint = cfg.oidc_endpoints.token_endpoint\n        cfg.azure_tenant_id = token_endpoint.replace(aad_endpoint, \"\").split(\"/\")[0]\n    inner = ClientCredentials(\n        client_id=cfg.azure_client_id,\n        client_secret=\"\",  # we have no (rotatable) secrets in OIDC flow\n        token_url=f\"{aad_endpoint}{cfg.azure_tenant_id}/oauth2/token\",\n        endpoint_params=params,\n        use_params=True,\n        disable_async=not cfg.enable_experimental_async_token_refresh,\n    )\n\n    def refreshed_headers() -> Dict[str, str]:\n        token = inner.token()\n        return {\"Authorization\": f\"{token.token_type} {token.access_token}\"}\n\n    def token() -> Token:\n        return inner.token()\n\n    return OAuthCredentialsProvider(refreshed_headers, token)",
          "hash_value": "91eb301fca66f4081092c44f472bbe82",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "@oauth_credentials_strategy(\"github-oidc-azure\", [\"host\", \"azure_client_id\"])\ndef github_oidc_azure(cfg: \"Config\") -> Optional[CredentialsProvider]:\n    if \"ACTIONS_ID_TOKEN_REQUEST_TOKEN\" not in os.environ:\n        # not in GitHub actions\n        return None\n\n    # Client ID is the minimal thing we need, as otherwise we get AADSTS700016: Application with\n    # identifier 'https://token.actions.githubusercontent.com' was not found in the directory '...'.\n    if not cfg.is_azure:\n        return None\n\n    # See https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers\n    headers = {\"Authorization\": f\"Bearer {os.environ['ACTIONS_ID_TOKEN_REQUEST_TOKEN']}\"}\n    endpoint = f\"{os.environ['ACTIONS_ID_TOKEN_REQUEST_URL']}&audience=api://AzureADTokenExchange\"\n    response = requests.get(endpoint, headers=headers)\n    if not response.ok:\n        return None\n\n    # get the ID Token with aud=api://AzureADTokenExchange sub=repo:org/repo:environment:name\n    response_json = response.json()\n    if \"value\" not in response_json:\n        return None\n\n    logger.info(\n        \"Configured AAD token for GitHub Actions OIDC (%s)\",\n        cfg.azure_client_id,\n    )\n    params = {\n        \"client_assertion_type\": \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\",\n        \"resource\": cfg.effective_azure_login_app_id,\n        \"client_assertion\": response_json[\"value\"],\n    }\n    aad_endpoint = cfg.arm_environment.active_directory_endpoint\n    if not cfg.azure_tenant_id:\n        # detect Azure AD Tenant ID if it's not specified directly\n        token_endpoint = cfg.oidc_endpoints.token_endpoint\n        cfg.azure_tenant_id = token_endpoint.replace(aad_endpoint, \"\").split(\"/\")[0]\n    inner = ClientCredentials(\n        client_id=cfg.azure_client_id,\n        client_secret=\"\",  # we have no (rotatable) secrets in OIDC flow\n        token_url=f\"{aad_endpoint}{cfg.azure_tenant_id}/oauth2/token\",\n        endpoint_params=params,\n        use_params=True,\n        disable_async=not cfg.enable_experimental_async_token_refresh,\n    )\n\n    def refreshed_headers() -> Dict[str, str]:\n        token = inner.token()\n        return {\"Authorization\": f\"{token.token_type} {token.access_token}\"}\n\n    def token() -> Token:\n        return inner.token()\n\n    return OAuthCredentialsProvider(refreshed_headers, token)",
              "triple_sequences": [
                {
                  "action_api": "os.environ.__contains__()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "ACTIONS_ID_TOKEN_REQUEST_TOKEN",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "cfg.is_azure",
                  "action_description": "Checks if specified path exists and is a directory",
                  "action_id": "check_directory_exists",
                  "object": "cfg.is_azure",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine operating system",
                  "intention_id": "get_operating_system_name"
                },
                {
                  "action_api": "os.environ.__getitem__()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "ACTIONS_ID_TOKEN_REQUEST_TOKEN",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.__getitem__()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "ACTIONS_ID_TOKEN_REQUEST_URL",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "endpoint",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "response.json()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "response",
                  "object_description": "HTTP response remote content",
                  "object_id": "http_response_remote_content",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "logger.info()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "Configured AAD token for GitHub Actions OIDC (%s)",
                  "object_description": "Log level",
                  "object_id": "log_level",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "token_endpoint.replace()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "token_endpoint.replace(aad_endpoint, \"\")",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "split(\"/\")[0]",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "ClientCredentials()",
                  "action_description": "Instantiates Sender class",
                  "action_id": "init_sender_class",
                  "object": "client_id=cfg.azure_client_id, client_secret=\"\", token_url=f\"{aad_endpoint}{cfg.azure_tenant_id}/oauth2/token\", endpoint_params=params, use_params=True, disable_async=not cfg.enable_experimental_async_token_refresh",
                  "object_description": "Account credentials",
                  "object_id": "account_credentials",
                  "intention_description": "Establish connection",
                  "intention_id": "establish_connection"
                },
                {
                  "action_api": "inner.token()",
                  "action_description": "Retrieves current one-time password",
                  "action_id": "get_totp_password",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "OAuthCredentialsProvider()",
                  "action_description": "Instantiates Sender class",
                  "action_id": "init_sender_class",
                  "object": "refreshed_headers, token",
                  "object_description": "Account credentials",
                  "object_id": "account_credentials",
                  "intention_description": "Establish connection",
                  "intention_id": "establish_connection"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "tensorstore-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/tensorstore-0.1.73.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/tensorstore-0.1.73/tensorstore-0.1.73/setup.py",
          "line_number": "307",
          "type_description": "code-execution",
          "context_snippet": "class BuildExtCommand(setuptools.command.build_ext.build_ext):\n  \"\"\"Overrides default build_ext command to invoke bazel.\"\"\"\n\n  def run(self):\n    if not self.dry_run:\n      ext = self.extensions[0]\n      ext_full_path = self.get_ext_fullpath(ext.name)\n\n      prebuilt_path = os.getenv('TENSORSTORE_PREBUILT_DIR')\n      if not prebuilt_path:\n        # Bazel cache includes PATH; attempt to remove the pip build-env\n        # from the PATH as bazel is already hermetic to improve cache use.\n        action_env = _get_action_env()\n\n        # Ensure python_configure.bzl finds the correct Python verison.\n        os.environ['PYTHON_BIN_PATH'] = sys.executable\n\n        # Ensure it is built against the version of `numpy` in the current\n        # environment (which should be as old as possible for best\n        # compatibility).\n        system_python_libs = [\n            x.strip()\n            for x in os.getenv(SYSTEM_PYTHON_LIBS_ENVVAR, '').split(',')\n            if x.strip()\n        ]\n        if 'numpy' not in system_python_libs:\n          system_python_libs.append('numpy')\n        os.environ[SYSTEM_PYTHON_LIBS_ENVVAR] = ','.join(system_python_libs)\n\n        bazelisk = os.getenv('TENSORSTORE_BAZELISK', 'bazelisk.py')\n        # Controlled via `setup.py build_ext --debug` flag.\n        default_compilation_mode = 'dbg' if self.debug else 'opt'\n        startup_options = shlex.split(\n            os.getenv('TENSORSTORE_BAZEL_STARTUP_OPTIONS', '')\n        )\n        build_options = shlex.split(\n            os.getenv('TENSORSTORE_BAZEL_BUILD_OPTIONS', '')\n        )\n\n        # Build with a specific compilation mode.\n        # When in opt mode also set -O3 optimizations to override bazel -O2.\n        compilation_mode = os.getenv(\n            'TENSORSTORE_BAZEL_COMPILATION_MODE', default_compilation_mode\n        )\n        build_flags = ['build', '-c', compilation_mode]\n        if compilation_mode == 'opt':\n          if 'win32' in sys.platform:\n            # Assumes MSVC compiler.\n            build_flags.append('--copt=/Ox')\n          else:\n            build_flags.append('--copt=-O3')\n\n        build_command = (\n            [sys.executable, '-u', bazelisk]\n            + startup_options\n            + build_flags\n            + [\n                '//python/tensorstore:_tensorstore__shared_objects',\n                '--verbose_failures',\n                # Bazel does not seem to download these files by default when\n                # using remote caching.\n                r'--remote_download_regex=.*/_tensorstore\\.(so|pyd)',\n            ]\n            + action_env\n            + build_options\n        )\n        if 'darwin' in sys.platform:\n          # Note: Bazel does not use the MACOSX_DEPLOYMENT_TARGET environment\n          # variable.\n          build_command += ['--macos_minimum_os=%s' % _macos_deployment_target]\n          # Support cross-compilation on macOS\n          # https://github.com/pypa/cibuildwheel/discussions/997#discussioncomment-2045760\n          darwin_cpus = [\n              x for x in os.getenv('ARCHFLAGS', '').split() if x != '-arch'\n          ]\n          # cibuildwheel sets `ARCHFLAGS` to one of:\n          #     '-arch x86_64'\n          #     '-arch arm64'\n          #     '-arch arm64 -arch x86_64'\n          if darwin_cpus:\n            if len(darwin_cpus) > 1:\n              raise ValueError(\n                  'Fat/universal %r build not supported' % (darwin_cpus,)\n              )\n            darwin_cpu = darwin_cpus[0]\n            build_command += [\n                f'--cpu=darwin_{darwin_cpu}',\n                f'--macos_cpus={darwin_cpu}',\n            ]\n        if sys.platform == 'win32':\n          # Disable newer exception handling from Visual Studio 2019, since it\n          # requires a newer C++ runtime than shipped with Python.\n          #\n          # https://cibuildwheel.readthedocs.io/en/stable/faq/#importerror-dll-load-failed-the-specific-module-could-not-be-found-error-on-windows\n          build_command += ['--copt=/d2FH4-']\n        else:\n          # Build with hidden visibility for more efficient code generation.\n          # Note that this also hides most symbols, but ultimately has no effect\n          # on symbol visibility because a separate linker option is already\n          # used to hide all extraneous symbols anyway.\n          build_command += ['--copt=-fvisibility=hidden']\n\n        self.spawn(build_command)\n        suffix = '.pyd' if os.name == 'nt' else '.so'\n        built_ext_path = os.path.join(\n            'bazel-bin/python/tensorstore/_tensorstore' + suffix\n        )\n      else:\n        # If `TENSORSTORE_PREBUILT_DIR` is set, the extension module is assumed\n        # to have already been built a prior call to `build_ext -b\n        # $TENSORSTORE_PREBUILT_DIR`.\n        #\n        # This is used in conjunction with cibuildwheel to first perform an\n        # in-tree build of the extension module in order to take advantage of\n        # Bazel caching:\n        #\n        # https://github.com/pypa/pip/pull/9091\n        # https://github.com/joerick/cibuildwheel/issues/486\n        built_ext_path = os.path.join(\n            prebuilt_path, 'tensorstore', os.path.basename(ext_full_path)\n        )\n\n      os.makedirs(os.path.dirname(ext_full_path), exist_ok=True)\n      print(\n          'Copying extension %s -> %s'\n          % (\n              built_ext_path,\n              ext_full_path,\n          )\n      )\n      shutil.copyfile(built_ext_path, ext_full_path)\n",
          "hash_value": "42662ce41419bbad7a676bbcb9c13b60",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class BuildExtCommand(setuptools.command.build_ext.build_ext):\n  \"\"\"Overrides default build_ext command to invoke bazel.\"\"\"\n\n  def run(self):\n    if not self.dry_run:\n      ext = self.extensions[0]\n      ext_full_path = self.get_ext_fullpath(ext.name)\n\n      prebuilt_path = os.getenv('TENSORSTORE_PREBUILT_DIR')\n      if not prebuilt_path:\n        # Bazel cache includes PATH; attempt to remove the pip build-env\n        # from the PATH as bazel is already hermetic to improve cache use.\n        action_env = _get_action_env()\n\n        # Ensure python_configure.bzl finds the correct Python verison.\n        os.environ['PYTHON_BIN_PATH'] = sys.executable\n\n        # Ensure it is built against the version of `numpy` in the current\n        # environment (which should be as old as possible for best\n        # compatibility).\n        system_python_libs = [\n            x.strip()\n            for x in os.getenv(SYSTEM_PYTHON_LIBS_ENVVAR, '').split(',')\n            if x.strip()\n        ]\n        if 'numpy' not in system_python_libs:\n          system_python_libs.append('numpy')\n        os.environ[SYSTEM_PYTHON_LIBS_ENVVAR] = ','.join(system_python_libs)\n\n        bazelisk = os.getenv('TENSORSTORE_BAZELISK', 'bazelisk.py')\n        # Controlled via `setup.py build_ext --debug` flag.\n        default_compilation_mode = 'dbg' if self.debug else 'opt'\n        startup_options = shlex.split(\n            os.getenv('TENSORSTORE_BAZEL_STARTUP_OPTIONS', '')\n        )\n        build_options = shlex.split(\n            os.getenv('TENSORSTORE_BAZEL_BUILD_OPTIONS', '')\n        )\n\n        # Build with a specific compilation mode.\n        # When in opt mode also set -O3 optimizations to override bazel -O2.\n        compilation_mode = os.getenv(\n            'TENSORSTORE_BAZEL_COMPILATION_MODE', default_compilation_mode\n        )\n        build_flags = ['build', '-c', compilation_mode]\n        if compilation_mode == 'opt':\n          if 'win32' in sys.platform:\n            # Assumes MSVC compiler.\n            build_flags.append('--copt=/Ox')\n          else:\n            build_flags.append('--copt=-O3')\n\n        build_command = (\n            [sys.executable, '-u', bazelisk]\n            + startup_options\n            + build_flags\n            + [\n                '//python/tensorstore:_tensorstore__shared_objects',\n                '--verbose_failures',\n                # Bazel does not seem to download these files by default when\n                # using remote caching.\n                r'--remote_download_regex=.*/_tensorstore\\.(so|pyd)',\n            ]\n            + action_env\n            + build_options\n        )\n        if 'darwin' in sys.platform:\n          # Note: Bazel does not use the MACOSX_DEPLOYMENT_TARGET environment\n          # variable.\n          build_command += ['--macos_minimum_os=%s' % _macos_deployment_target]\n          # Support cross-compilation on macOS\n          # https://github.com/pypa/cibuildwheel/discussions/997#discussioncomment-2045760\n          darwin_cpus = [\n              x for x in os.getenv('ARCHFLAGS', '').split() if x != '-arch'\n          ]\n          # cibuildwheel sets `ARCHFLAGS` to one of:\n          #     '-arch x86_64'\n          #     '-arch arm64'\n          #     '-arch arm64 -arch x86_64'\n          if darwin_cpus:\n            if len(darwin_cpus) > 1:\n              raise ValueError(\n                  'Fat/universal %r build not supported' % (darwin_cpus,)\n              )\n            darwin_cpu = darwin_cpus[0]\n            build_command += [\n                f'--cpu=darwin_{darwin_cpu}',\n                f'--macos_cpus={darwin_cpu}',\n            ]\n        if sys.platform == 'win32':\n          # Disable newer exception handling from Visual Studio 2019, since it\n          # requires a newer C++ runtime than shipped with Python.\n          #\n          # https://cibuildwheel.readthedocs.io/en/stable/faq/#importerror-dll-load-failed-the-specific-module-could-not-be-found-error-on-windows\n          build_command += ['--copt=/d2FH4-']\n        else:\n          # Build with hidden visibility for more efficient code generation.\n          # Note that this also hides most symbols, but ultimately has no effect\n          # on symbol visibility because a separate linker option is already\n          # used to hide all extraneous symbols anyway.\n          build_command += ['--copt=-fvisibility=hidden']\n\n        self.spawn(build_command)\n        suffix = '.pyd' if os.name == 'nt' else '.so'\n        built_ext_path = os.path.join(\n            'bazel-bin/python/tensorstore/_tensorstore' + suffix\n        )\n      else:\n        # If `TENSORSTORE_PREBUILT_DIR` is set, the extension module is assumed\n        # to have already been built a prior call to `build_ext -b\n        # $TENSORSTORE_PREBUILT_DIR`.\n        #\n        # This is used in conjunction with cibuildwheel to first perform an\n        # in-tree build of the extension module in order to take advantage of\n        # Bazel caching:\n        #\n        # https://github.com/pypa/pip/pull/9091\n        # https://github.com/joerick/cibuildwheel/issues/486\n        built_ext_path = os.path.join(\n            prebuilt_path, 'tensorstore', os.path.basename(ext_full_path)\n        )\n\n      os.makedirs(os.path.dirname(ext_full_path), exist_ok=True)\n      print(\n          'Copying extension %s -> %s'\n          % (\n              built_ext_path,\n              ext_full_path,\n          )\n      )\n      shutil.copyfile(built_ext_path, ext_full_path)\n",
              "triple_sequences": [
                {
                  "action_api": "os.getenv()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'TENSORSTORE_PREBUILT_DIR'",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.getenv()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "SYSTEM_PYTHON_LIBS_ENVVAR",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.getenv()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'TENSORSTORE_BAZELISK', 'bazelisk.py'",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.getenv()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'TENSORSTORE_BAZEL_STARTUP_OPTIONS', ''",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.getenv()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'TENSORSTORE_BAZEL_BUILD_OPTIONS', ''",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.getenv()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'TENSORSTORE_BAZEL_COMPILATION_MODE', default_compilation_mode",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.getenv()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'ARCHFLAGS', ''",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.__setitem__()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "'PYTHON_BIN_PATH', sys.executable",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.__setitem__()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "SYSTEM_PYTHON_LIBS_ENVVAR, ','.join(system_python_libs)",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "shlex.split()",
                  "action_description": "Splits string into list using shell-like syntax",
                  "action_id": "path_string_operations",
                  "object": "os.getenv('TENSORSTORE_BAZEL_STARTUP_OPTIONS', '')",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "shlex.split()",
                  "action_description": "Splits string into list using shell-like syntax",
                  "action_id": "path_string_operations",
                  "object": "os.getenv('TENSORSTORE_BAZEL_BUILD_OPTIONS', '')",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "self.spawn()",
                  "action_description": "Spawns new process to execute command with shell access",
                  "action_id": "spawn_process_shell",
                  "object": "build_command",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "'bazel-bin/python/tensorstore/_tensorstore' + suffix",
                  "object_description": "Directory path with file",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "prebuilt_path, 'tensorstore', os.path.basename(ext_full_path)",
                  "object_description": "Directory path with file",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.makedirs()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "os.path.dirname(ext_full_path), exist_ok=True",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "shutil.copyfile()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "built_ext_path, ext_full_path",
                  "object_description": "Local file or directory",
                  "object_id": "local_file_or_directory",
                  "intention_description": "Move file to destination",
                  "intention_id": "move_file_destination"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "nylas-6",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/nylas-6.8.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/nylas-6.8.0/nylas-6.8.0/setup.py",
          "line_number": "88",
          "type_description": "code-execution",
          "context_snippet": "def main():\n    # A few handy release helpers.\n    # For publishing you should install the extra 'release' dependencies\n    # by running: pip install nylas['release']\n    if len(sys.argv) > 1:\n        if sys.argv[1] == \"publish\":\n            try:\n                subprocess.check_output([\"git\", \"push\", \"--follow-tags\"])\n                subprocess.check_output([\"python\", \"setup.py\", \"sdist\"])\n                subprocess.check_output([\"twine\", \"upload\", \"-r\", \"testpypi\", \"dist/*\"])\n                subprocess.check_output([\"twine\", \"upload\", \"dist/*\"])\n            except FileNotFoundError as e:\n                print(\"Error encountered: {}.\\n\\n\".format(e))\n            sys.exit()\n        elif sys.argv[1] == \"build-docs\":\n            if not os.path.exists(\"docs\"):\n                os.makedirs(\"docs\")\n            try:\n                # Copy the README and other markdowns to the docs folder\n                shutil.copy(\"README.md\", \"docs/index.md\")\n                shutil.copy(\"Contributing.md\", \"docs/contributing.md\")\n                shutil.copy(\"LICENSE\", \"docs/license.md\")\n\n                subprocess.check_output([\"mkdocs\", \"build\"])\n            except FileNotFoundError as e:\n                print(\"Error encountered: {}.\\n\\n\".format(e))\n            sys.exit()\n        elif sys.argv[1] == \"release\":\n            if len(sys.argv) < 3:\n                type_ = \"patch\"\n            else:\n                type_ = sys.argv[2]\n            try:\n                subprocess.check_output(\n                    [\"bumpversion\", \"--current-version\", VERSION, type_]\n                )\n            except FileNotFoundError as e:\n                print(\n                    \"Error encountered: {}.\\n\\n\".format(e),\n                    \"Did you install the extra 'release' dependencies? (pip install nylas['release'])\",\n                )\n            sys.exit()\n\n    setup(\n        name=\"nylas\",\n        version=VERSION,\n        python_requires=\">=3.8\",\n        packages=find_packages(),\n        install_requires=RUN_DEPENDENCIES,\n        dependency_links=[],\n        tests_require=TEST_DEPENDENCIES,\n        extras_require={\n            \"test\": TEST_DEPENDENCIES,\n            \"docs\": DOCS_DEPENDENCIES,\n            \"release\": RELEASE_DEPENDENCIES,\n        },\n        cmdclass={\"test\": PyTest},\n        author=\"Nylas Team\",\n        author_email=\"support@nylas.com\",\n        description=\"Python bindings for the Nylas API platform.\",\n        license=\"MIT\",\n        keywords=\"inbox app appserver email nylas contacts calendar\",\n        url=\"https://github.com/nylas/nylas-python\",\n        long_description_content_type=\"text/markdown\",\n        long_description=README,\n    )",
          "hash_value": "78b94a620945f84354ac88aa13561d90",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def main():\n    # A few handy release helpers.\n    # For publishing you should install the extra 'release' dependencies\n    # by running: pip install nylas['release']\n    if len(sys.argv) > 1:\n        if sys.argv[1] == \"publish\":\n            try:\n                subprocess.check_output([\"git\", \"push\", \"--follow-tags\"])\n                subprocess.check_output([\"python\", \"setup.py\", \"sdist\"])\n                subprocess.check_output([\"twine\", \"upload\", \"-r\", \"testpypi\", \"dist/*\"])\n                subprocess.check_output([\"twine\", \"upload\", \"dist/*\"])\n            except FileNotFoundError as e:\n                print(\"Error encountered: {}.\\n\\n\".format(e))\n            sys.exit()\n        elif sys.argv[1] == \"build-docs\":\n            if not os.path.exists(\"docs\"):\n                os.makedirs(\"docs\")\n            try:\n                # Copy the README and other markdowns to the docs folder\n                shutil.copy(\"README.md\", \"docs/index.md\")\n                shutil.copy(\"Contributing.md\", \"docs/contributing.md\")\n                shutil.copy(\"LICENSE\", \"docs/license.md\")\n\n                subprocess.check_output([\"mkdocs\", \"build\"])\n            except FileNotFoundError as e:\n                print(\"Error encountered: {}.\\n\\n\".format(e))\n            sys.exit()\n        elif sys.argv[1] == \"release\":\n            if len(sys.argv) < 3:\n                type_ = \"patch\"\n            else:\n                type_ = sys.argv[2]\n            try:\n                subprocess.check_output(\n                    [\"bumpversion\", \"--current-version\", VERSION, type_]\n                )\n            except FileNotFoundError as e:\n                print(\n                    \"Error encountered: {}.\\n\\n\".format(e),\n                    \"Did you install the extra 'release' dependencies? (pip install nylas['release'])\",\n                )\n            sys.exit()\n\n    setup(\n        name=\"nylas\",\n        version=VERSION,\n        python_requires=\">=3.8\",\n        packages=find_packages(),\n        install_requires=RUN_DEPENDENCIES,\n        dependency_links=[],\n        tests_require=TEST_DEPENDENCIES,\n        extras_require={\n            \"test\": TEST_DEPENDENCIES,\n            \"docs\": DOCS_DEPENDENCIES,\n            \"release\": RELEASE_DEPENDENCIES,\n        },\n        cmdclass={\"test\": PyTest},\n        author=\"Nylas Team\",\n        author_email=\"support@nylas.com\",\n        description=\"Python bindings for the Nylas API platform.\",\n        license=\"MIT\",\n        keywords=\"inbox app appserver email nylas contacts calendar\",\n        url=\"https://github.com/nylas/nylas-python\",\n        long_description_content_type=\"text/markdown\",\n        long_description=README,\n    )",
              "triple_sequences": [
                {
                  "action_api": "sys.argv",
                  "action_description": "Retrieves command-line arguments passed to script",
                  "action_id": "get_cmd_args",
                  "object": "sys.argv",
                  "object_description": "Command-line arguments passed to script",
                  "object_id": "get_cmd_args",
                  "intention_description": "Access command line arguments",
                  "intention_id": "access_command_line_arguments"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "\"docs\"",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "os.makedirs()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "\"docs\"",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "shutil.copy()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "\"README.md\", \"docs/index.md\"",
                  "object_description": "Local file and temporary file path",
                  "object_id": "local_file_with_temp",
                  "intention_description": "Copy file to temporary directory",
                  "intention_id": "copy_file_temp_directory"
                },
                {
                  "action_api": "shutil.copy()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "\"Contributing.md\", \"docs/contributing.md\"",
                  "object_description": "Local file and temporary file path",
                  "object_id": "local_file_with_temp",
                  "intention_description": "Copy file to temporary directory",
                  "intention_id": "copy_file_temp_directory"
                },
                {
                  "action_api": "shutil.copy()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "\"LICENSE\", \"docs/license.md\"",
                  "object_description": "Local file and temporary file path",
                  "object_id": "local_file_with_temp",
                  "intention_description": "Copy file to temporary directory",
                  "intention_id": "copy_file_temp_directory"
                },
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"git\", \"push\", \"--follow-tags\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"python\", \"setup.py\", \"sdist\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"twine\", \"upload\", \"-r\", \"testpypi\", \"dist/*\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"twine\", \"upload\", \"dist/*\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"mkdocs\", \"build\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"bumpversion\", \"--current-version\", VERSION, type_]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "name=\"nylas\", version=VERSION, ...",
                  "object_description": "Python package setup arguments",
                  "object_id": "",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pymongo-4",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pymongo-4.12.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup_tests.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pymongo-4.12.0/pymongo-4.12.0/.evergreen/scripts/setup_tests.py",
          "line_number": "110",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "def setup_libmongocrypt():\n    target = \"\"\n    if PLATFORM == \"windows\":\n        # PYTHON-2808 Ensure this machine has the CA cert for google KMS.\n        if is_set(\"TEST_FLE_GCP_AUTO\"):\n            run_command('powershell.exe \"Invoke-WebRequest -URI https://oauth2.googleapis.com/\"')\n        target = \"windows-test\"\n\n    elif PLATFORM == \"darwin\":\n        target = \"macos\"\n\n    else:\n        distro = get_distro()\n        if distro.name.startswith(\"Debian\"):\n            target = f\"debian{distro.version_id}\"\n        elif distro.name.startswith(\"Red Hat\"):\n            if distro.version_id.startswith(\"7\"):\n                target = \"rhel-70-64-bit\"\n            elif distro.version_id.startswith(\"8\"):\n                if distro.arch == \"aarch64\":\n                    target = \"rhel-82-arm64\"\n                else:\n                    target = \"rhel-80-64-bit\"\n\n    if not is_set(\"LIBMONGOCRYPT_URL\"):\n        if not target:\n            raise ValueError(\"Cannot find libmongocrypt target for current platform!\")\n        url = f\"https://s3.amazonaws.com/mciuploads/libmongocrypt/{target}/master/latest/libmongocrypt.tar.gz\"\n    else:\n        url = os.environ[\"LIBMONGOCRYPT_URL\"]\n\n    shutil.rmtree(HERE / \"libmongocrypt\", ignore_errors=True)\n\n    LOGGER.info(f\"Fetching {url}...\")\n    with request.urlopen(request.Request(url), timeout=15.0) as response:  # noqa: S310\n        if response.status == 200:\n            fileobj = io.BytesIO(response.read())\n        with tarfile.open(\"libmongocrypt.tar.gz\", fileobj=fileobj) as fid:\n            fid.extractall(Path.cwd() / \"libmongocrypt\")\n    LOGGER.info(f\"Fetching {url}... done.\")\n\n    run_command(\"ls -la libmongocrypt\")\n    run_command(\"ls -la libmongocrypt/nocrypto\")\n\n    if PLATFORM == \"windows\":\n        # libmongocrypt's windows dll is not marked executable.\n        run_command(\"chmod +x libmongocrypt/nocrypto/bin/mongocrypt.dll\")",
          "hash_value": "015c463945dd65deb58740eff9597f63",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def setup_libmongocrypt():\n    target = \"\"\n    if PLATFORM == \"windows\":\n        # PYTHON-2808 Ensure this machine has the CA cert for google KMS.\n        if is_set(\"TEST_FLE_GCP_AUTO\"):\n            run_command('powershell.exe \"Invoke-WebRequest -URI https://oauth2.googleapis.com/\"')\n        target = \"windows-test\"\n\n    elif PLATFORM == \"darwin\":\n        target = \"macos\"\n\n    else:\n        distro = get_distro()\n        if distro.name.startswith(\"Debian\"):\n            target = f\"debian{distro.version_id}\"\n        elif distro.name.startswith(\"Red Hat\"):\n            if distro.version_id.startswith(\"7\"):\n                target = \"rhel-70-64-bit\"\n            elif distro.version_id.startswith(\"8\"):\n                if distro.arch == \"aarch64\":\n                    target = \"rhel-82-arm64\"\n                else:\n                    target = \"rhel-80-64-bit\"\n\n    if not is_set(\"LIBMONGOCRYPT_URL\"):\n        if not target:\n            raise ValueError(\"Cannot find libmongocrypt target for current platform!\")\n        url = f\"https://s3.amazonaws.com/mciuploads/libmongocrypt/{target}/master/latest/libmongocrypt.tar.gz\"\n    else:\n        url = os.environ[\"LIBMONGOCRYPT_URL\"]\n\n    shutil.rmtree(HERE / \"libmongocrypt\", ignore_errors=True)\n\n    LOGGER.info(f\"Fetching {url}...\")\n    with request.urlopen(request.Request(url), timeout=15.0) as response:  # noqa: S310\n        if response.status == 200:\n            fileobj = io.BytesIO(response.read())\n        with tarfile.open(\"libmongocrypt.tar.gz\", fileobj=fileobj) as fid:\n            fid.extractall(Path.cwd() / \"libmongocrypt\")\n    LOGGER.info(f\"Fetching {url}... done.\")\n\n    run_command(\"ls -la libmongocrypt\")\n    run_command(\"ls -la libmongocrypt/nocrypto\")\n\n    if PLATFORM == \"windows\":\n        # libmongocrypt's windows dll is not marked executable.\n        run_command(\"chmod +x libmongocrypt/nocrypto/bin/mongocrypt.dll\")",
              "triple_sequences": [
                {
                  "action_api": "is_set()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "TEST_FLE_GCP_AUTO",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "run_command()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "powershell.exe \"Invoke-WebRequest -URI https://oauth2.googleapis.com/\"",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "get_distro()",
                  "action_description": "Retrieves operating system information",
                  "action_id": "get_os_info",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get operating system name",
                  "intention_id": "get_operating_system_name"
                },
                {
                  "action_api": "is_set()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "LIBMONGOCRYPT_URL",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ[]",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "LIBMONGOCRYPT_URL",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "shutil.rmtree()",
                  "action_description": "Recursively deletes directory and its contents",
                  "action_id": "delete_directory",
                  "object": "HERE / \"libmongocrypt\"",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Delete directory content",
                  "intention_id": "delete_directory_content"
                },
                {
                  "action_api": "LOGGER.info()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "Fetching {url}...",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                },
                {
                  "action_api": "request.Request()",
                  "action_description": "Creates HTTP request object with specified URL, data, and headers",
                  "action_id": "create_http_request",
                  "object": "url",
                  "object_description": "URL string",
                  "object_id": "url_string",
                  "intention_description": "Prepare URL for HTTP request",
                  "intention_id": "prepare_url_http_request"
                },
                {
                  "action_api": "request.urlopen()",
                  "action_description": "Opens URL with GET parameters",
                  "action_id": "open_url_get",
                  "object": "request.Request(url), timeout=15.0",
                  "object_description": "Request object for external domain",
                  "object_id": "request_external_domain",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "response.read()",
                  "action_description": "Receives data from socket connection",
                  "action_id": "receive_socket_data",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Decode downloaded content",
                  "intention_id": "decode_downloaded_content"
                },
                {
                  "action_api": "io.BytesIO()",
                  "action_description": "Creates in-memory bytes buffer from encoded string",
                  "action_id": "create_memory_bytes",
                  "object": "response.read()",
                  "object_description": "Encoded string to bytes",
                  "object_id": "encoded_string_bytes",
                  "intention_description": "Prepare data processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "tarfile.open()",
                  "action_description": "Opens ZIP archive for reading",
                  "action_id": "open_zip_read",
                  "object": "\"libmongocrypt.tar.gz\", fileobj=fileobj",
                  "object_description": "ZIP archive file",
                  "object_id": "zip_archive",
                  "intention_description": "Decompress downloaded archive",
                  "intention_id": "decompress_downloaded_archive"
                },
                {
                  "action_api": "fid.extractall()",
                  "action_description": "Extracts all files from ZIP archive to specified directory",
                  "action_id": "extract_zip_files",
                  "object": "Path.cwd() / \"libmongocrypt\"",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Extract structured file data",
                  "intention_id": "extract_structured_file_data"
                },
                {
                  "action_api": "LOGGER.info()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "Fetching {url}... done.",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                },
                {
                  "action_api": "run_command()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "ls -la libmongocrypt",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "run_command()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "ls -la libmongocrypt/nocrypto",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "run_command()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "chmod +x libmongocrypt/nocrypto/bin/mongocrypt.dll",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Modify file attributes",
                  "intention_id": "modify_file_attributes"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "jq-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/jq-1.8.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/jq-1.8.0/jq-1.8.0/setup.py",
          "line_number": "71",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport shlex\nimport subprocess\nimport sys\nimport sysconfig\n\ndef _dep_build_path(relative_path):\n    return os.path.join(os.path.abspath(os.path.join(os.path.dirname(__file__), \"_deps/build\")), relative_path)\n\njq_lib_tarball_path = os.path.join(os.path.abspath(os.path.join(os.path.dirname(__file__), \"deps\")), \"jq-1.7.1.tar.gz\")\njq_lib_dir = _dep_build_path(\"jq-1.7.1\")\n\nclass jq_with_deps_build_ext(build_ext):\n    def _build_lib(self, tarball_path, lib_dir, commands):\n        self._extract_tarball(\n            tarball_path=tarball_path,\n            lib_dir=lib_dir,\n        )\n\n        macosx_deployment_target = sysconfig.get_config_var(\"MACOSX_DEPLOYMENT_TARGET\")\n        if macosx_deployment_target:\n            os.environ['MACOSX_DEPLOYMENT_TARGET'] = str(macosx_deployment_target)\n\n        def run_command(args):\n            print(\"Executing: %s\" % ' '.join(args))\n\n            if os.name == \"nt\":\n                command = [\"msys2.cmd\", \"-c\", \" \".join(shlex.quote(arg) for arg in args)]\n            else:\n                command = args\n\n            subprocess.check_call(command, cwd=lib_dir)\n\n        for command in commands:\n            run_command(command)",
          "hash_value": "4c46bcdbbe9a2f84e40206a7608845e3",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport shlex\nimport subprocess\nimport sys\nimport sysconfig\n\ndef _dep_build_path(relative_path):\n    return os.path.join(os.path.abspath(os.path.join(os.path.dirname(__file__), \"_deps/build\")), relative_path)\n\njq_lib_tarball_path = os.path.join(os.path.abspath(os.path.join(os.path.dirname(__file__), \"deps\")), \"jq-1.7.1.tar.gz\")\njq_lib_dir = _dep_build_path(\"jq-1.7.1\")\n\nclass jq_with_deps_build_ext(build_ext):\n    def _build_lib(self, tarball_path, lib_dir, commands):\n        self._extract_tarball(\n            tarball_path=tarball_path,\n            lib_dir=lib_dir,\n        )\n\n        macosx_deployment_target = sysconfig.get_config_var(\"MACOSX_DEPLOYMENT_TARGET\")\n        if macosx_deployment_target:\n            os.environ['MACOSX_DEPLOYMENT_TARGET'] = str(macosx_deployment_target)\n\n        def run_command(args):\n            print(\"Executing: %s\" % ' '.join(args))\n\n            if os.name == \"nt\":\n                command = [\"msys2.cmd\", \"-c\", \" \".join(shlex.quote(arg) for arg in args)]\n            else:\n                command = args\n\n            subprocess.check_call(command, cwd=lib_dir)\n\n        for command in commands:\n            run_command(command)",
              "triple_sequences": [
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Get script file path",
                  "intention_id": "get_script_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.dirname(__file__), \"_deps/build\"",
                  "object_description": "Script file path and directory path segment",
                  "object_id": "script_file_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.join(os.path.dirname(__file__), \"_deps/build\")",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.abspath(os.path.join(os.path.dirname(__file__), \"_deps/build\")), relative_path",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Get script file path",
                  "intention_id": "get_script_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.dirname(__file__), \"deps\"",
                  "object_description": "Script file path and directory path segment",
                  "object_id": "script_file_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.join(os.path.dirname(__file__), \"deps\")",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.abspath(os.path.join(os.path.dirname(__file__), \"deps\")), \"jq-1.7.1.tar.gz\"",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "_dep_build_path()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "\"jq-1.7.1\"",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "self._extract_tarball()",
                  "action_description": "Extracts all files from ZIP archive to specified directory",
                  "action_id": "extract_zip_files",
                  "object": "tarball_path=tarball_path, lib_dir=lib_dir",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Decompress downloaded archive",
                  "intention_id": "decompress_downloaded_archive"
                },
                {
                  "action_api": "sysconfig.get_config_var()",
                  "action_description": "Retrieves operating system information",
                  "action_id": "get_os_info",
                  "object": "\"MACOSX_DEPLOYMENT_TARGET\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Access configuration value",
                  "intention_id": "access_configuration_value"
                },
                {
                  "action_api": "os.environ.__setitem__()",
                  "action_description": "Sets value for registry key",
                  "action_id": "set_registry_value",
                  "object": "'MACOSX_DEPLOYMENT_TARGET', str(macosx_deployment_target)",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "shlex.quote()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "arg",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare argument for shortcut",
                  "intention_id": "prepare_shortcut_argument"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "command, cwd=lib_dir",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "psycopg2-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/psycopg2-2.9.10.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/psycopg2-2.9.10/psycopg2-2.9.10/setup.py",
          "line_number": "109",
          "type_description": "code-execution",
          "context_snippet": "import subprocess\n\nclass PostgresConfig:\n    def __init__(self, build_ext):\n        self.build_ext = build_ext\n        self.pg_config_exe = self.build_ext.pg_config\n        if not self.pg_config_exe:\n            self.pg_config_exe = self.autodetect_pg_config_path()\n        if self.pg_config_exe is None:\n            sys.stderr.write(\"\"\"\nError: pg_config executable not found.\n\npg_config is required to build psycopg2 from source.  Please add the directory\ncontaining pg_config to the $PATH or specify the full executable path with the\noption:\n\n    python setup.py build_ext --pg-config /path/to/pg_config build ...\n\nor with the pg_config option in 'setup.cfg'.\n\nIf you prefer to avoid building psycopg2 from source, please install the PyPI\n'psycopg2-binary' package instead.\n\nFor further information please check the 'doc/src/install.rst' file (also at\n<https://www.psycopg.org/docs/install.html>).\n\n\"\"\")\n            sys.exit(1)\n\n    def query(self, attr_name, *, empty_ok=False):\n        \"\"\"Spawn the pg_config executable, querying for the given config\n        name, and return the printed value, sanitized. \"\"\"\n        try:\n            pg_config_process = subprocess.run(\n                [self.pg_config_exe, \"--\" + attr_name],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE)\n        except OSError:\n            raise Warning(\n                f\"Unable to find 'pg_config' file in '{self.pg_config_exe}'\")\n        if pg_config_process.returncode:\n            err = pg_config_process.stderr.decode(errors='backslashreplace')\n            raise Warning(f\"pg_config --{attr_name} failed: {err}\")\n        result = pg_config_process.stdout.decode().strip()\n        if not result and not empty_ok:\n            raise Warning(f\"pg_config --{attr_name} is empty\")\n        return result\n\n    def find_on_path(self, exename, path_directories=None):\n        if not path_directories:\n            path_directories = os.environ['PATH'].split(os.pathsep)\n        for dir_name in path_directories:\n            fullpath = os.path.join(dir_name, exename)\n            if os.path.isfile(fullpath):\n                return fullpath\n        return None\n\n    def autodetect_pg_config_path(self):\n        \"\"\"Find and return the path to the pg_config executable.\"\"\"\n        if PLATFORM_IS_WINDOWS:\n            return self.autodetect_pg_config_path_windows()\n        else:\n            return self.find_on_path('pg_config')\n\n    def autodetect_pg_config_path_windows(self):\n        \"\"\"Attempt several different ways of finding the pg_config\n        executable on Windows, and return its full path, if found.\"\"\"\n\n        # This code only runs if they have not specified a pg_config option\n        # in the config file or via the commandline.\n\n        # First, check for pg_config.exe on the PATH, and use that if found.\n        pg_config_exe = self.find_on_path('pg_config.exe')\n        if pg_config_exe:\n            return pg_config_exe\n\n        # Now, try looking in the Windows Registry to find a PostgreSQL\n        # installation, and infer the path from that.\n        pg_config_exe = self._get_pg_config_from_registry()\n        if pg_config_exe:\n            return pg_config_exe\n\n        return None\n\n    def _get_pg_config_from_registry(self):\n        import winreg\n\n        reg = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)\n        try:\n            pg_inst_list_key = winreg.OpenKey(reg,\n                'SOFTWARE\\\\PostgreSQL\\\\Installations')\n        except OSError:\n            # No PostgreSQL installation, as best as we can tell.\n            return None\n\n        try:\n            # Determine the name of the first subkey, if any:\n            try:\n                first_sub_key_name = winreg.EnumKey(pg_inst_list_key, 0)\n            except OSError:\n                return None\n\n            pg_first_inst_key = winreg.OpenKey(reg,\n                'SOFTWARE\\\\PostgreSQL\\\\Installations\\\\' + first_sub_key_name)\n            try:\n                pg_inst_base_dir = winreg.QueryValueEx(\n                    pg_first_inst_key, 'Base Directory')[0]\n            finally:\n                winreg.CloseKey(pg_first_inst_key)\n\n        finally:\n            winreg.CloseKey(pg_inst_list_key)\n\n        pg_config_path = os.path.join(\n            pg_inst_base_dir, 'bin', 'pg_config.exe')\n        if not os.path.exists(pg_config_path):\n            return None\n\n        return pg_config_path",
          "hash_value": "8080409c475e2af8588b6048db56144f",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import subprocess\n\nclass PostgresConfig:\n    def __init__(self, build_ext):\n        self.build_ext = build_ext\n        self.pg_config_exe = self.build_ext.pg_config\n        if not self.pg_config_exe:\n            self.pg_config_exe = self.autodetect_pg_config_path()\n        if self.pg_config_exe is None:\n            sys.stderr.write(\"\"\"\nError: pg_config executable not found.\n\npg_config is required to build psycopg2 from source.  Please add the directory\ncontaining pg_config to the $PATH or specify the full executable path with the\noption:\n\n    python setup.py build_ext --pg-config /path/to/pg_config build ...\n\nor with the pg_config option in 'setup.cfg'.\n\nIf you prefer to avoid building psycopg2 from source, please install the PyPI\n'psycopg2-binary' package instead.\n\nFor further information please check the 'doc/src/install.rst' file (also at\n<https://www.psycopg.org/docs/install.html>).\n\n\"\"\")\n            sys.exit(1)\n\n    def query(self, attr_name, *, empty_ok=False):\n        \"\"\"Spawn the pg_config executable, querying for the given config\n        name, and return the printed value, sanitized. \"\"\"\n        try:\n            pg_config_process = subprocess.run(\n                [self.pg_config_exe, \"--\" + attr_name],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE)\n        except OSError:\n            raise Warning(\n                f\"Unable to find 'pg_config' file in '{self.pg_config_exe}'\")\n        if pg_config_process.returncode:\n            err = pg_config_process.stderr.decode(errors='backslashreplace')\n            raise Warning(f\"pg_config --{attr_name} failed: {err}\")\n        result = pg_config_process.stdout.decode().strip()\n        if not result and not empty_ok:\n            raise Warning(f\"pg_config --{attr_name} is empty\")\n        return result\n\n    def find_on_path(self, exename, path_directories=None):\n        if not path_directories:\n            path_directories = os.environ['PATH'].split(os.pathsep)\n        for dir_name in path_directories:\n            fullpath = os.path.join(dir_name, exename)\n            if os.path.isfile(fullpath):\n                return fullpath\n        return None\n\n    def autodetect_pg_config_path(self):\n        \"\"\"Find and return the path to the pg_config executable.\"\"\"\n        if PLATFORM_IS_WINDOWS:\n            return self.autodetect_pg_config_path_windows()\n        else:\n            return self.find_on_path('pg_config')\n\n    def autodetect_pg_config_path_windows(self):\n        \"\"\"Attempt several different ways of finding the pg_config\n        executable on Windows, and return its full path, if found.\"\"\"\n\n        # This code only runs if they have not specified a pg_config option\n        # in the config file or via the commandline.\n\n        # First, check for pg_config.exe on the PATH, and use that if found.\n        pg_config_exe = self.find_on_path('pg_config.exe')\n        if pg_config_exe:\n            return pg_config_exe\n\n        # Now, try looking in the Windows Registry to find a PostgreSQL\n        # installation, and infer the path from that.\n        pg_config_exe = self._get_pg_config_from_registry()\n        if pg_config_exe:\n            return pg_config_exe\n\n        return None\n\n    def _get_pg_config_from_registry(self):\n        import winreg\n\n        reg = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)\n        try:\n            pg_inst_list_key = winreg.OpenKey(reg,\n                'SOFTWARE\\\\PostgreSQL\\\\Installations')\n        except OSError:\n            # No PostgreSQL installation, as best as we can tell.\n            return None\n\n        try:\n            # Determine the name of the first subkey, if any:\n            try:\n                first_sub_key_name = winreg.EnumKey(pg_inst_list_key, 0)\n            except OSError:\n                return None\n\n            pg_first_inst_key = winreg.OpenKey(reg,\n                'SOFTWARE\\\\PostgreSQL\\\\Installations\\\\' + first_sub_key_name)\n            try:\n                pg_inst_base_dir = winreg.QueryValueEx(\n                    pg_first_inst_key, 'Base Directory')[0]\n            finally:\n                winreg.CloseKey(pg_first_inst_key)\n\n        finally:\n            winreg.CloseKey(pg_inst_list_key)\n\n        pg_config_path = os.path.join(\n            pg_inst_base_dir, 'bin', 'pg_config.exe')\n        if not os.path.exists(pg_config_path):\n            return None\n\n        return pg_config_path",
              "triple_sequences": [
                {
                  "action_api": "os.environ.__getitem__()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'PATH'",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.pathsep",
                  "action_description": "Retrieves operating system path separator",
                  "action_id": "get_os_path_sep",
                  "object": "",
                  "object_description": "Directory path separator",
                  "object_id": "directory_separator",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.environ['PATH']",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "dir_name, exename",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.isfile()",
                  "action_description": "Checks if specified path exists and is a file",
                  "action_id": "check_file_is_file",
                  "object": "fullpath",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[self.pg_config_exe, '--' + attr_name]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "pg_config_process.stderr.decode()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "pg_config_process.stderr",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                },
                {
                  "action_api": "pg_config_process.stdout.decode()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "pg_config_process.stdout",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                },
                {
                  "action_api": "str.strip()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "pg_config_process.stdout.decode()",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "winreg.ConnectRegistry()",
                  "action_description": "Opens registry key",
                  "action_id": "open_registry_key",
                  "object": "None, winreg.HKEY_LOCAL_MACHINE",
                  "object_description": "Windows registry key",
                  "object_id": "windows_registry_key",
                  "intention_description": "Access Windows registry key",
                  "intention_id": "access_registry_key"
                },
                {
                  "action_api": "winreg.OpenKey()",
                  "action_description": "Opens registry key",
                  "action_id": "open_registry_key",
                  "object": "reg, 'SOFTWARE\\\\PostgreSQL\\\\Installations'",
                  "object_description": "Windows registry key",
                  "object_id": "windows_registry_key",
                  "intention_description": "Access Windows registry key",
                  "intention_id": "access_registry_key"
                },
                {
                  "action_api": "winreg.EnumKey()",
                  "action_description": "Retrieves value and data type for registry value",
                  "action_id": "get_registry_value",
                  "object": "pg_inst_list_key, 0",
                  "object_description": "Registry value",
                  "object_id": "registry_value",
                  "intention_description": "Access registry value",
                  "intention_id": "access_registry_value"
                },
                {
                  "action_api": "winreg.OpenKey()",
                  "action_description": "Opens registry key",
                  "action_id": "open_registry_key",
                  "object": "reg, 'SOFTWARE\\\\PostgreSQL\\\\Installations\\\\' + first_sub_key_name",
                  "object_description": "Windows registry key",
                  "object_id": "windows_registry_key",
                  "intention_description": "Access Windows registry key",
                  "intention_id": "access_registry_key"
                },
                {
                  "action_api": "winreg.QueryValueEx()",
                  "action_description": "Retrieves value and data type for registry value",
                  "action_id": "get_registry_value",
                  "object": "pg_first_inst_key, 'Base Directory'",
                  "object_description": "Registry value",
                  "object_id": "registry_value",
                  "intention_description": "Access registry value",
                  "intention_id": "access_registry_value"
                },
                {
                  "action_api": "winreg.CloseKey()",
                  "action_description": "Closes the opened registry key",
                  "action_id": "close_registry_key",
                  "object": "pg_first_inst_key",
                  "object_description": "Registry key handle",
                  "object_id": "registry_key_handle",
                  "intention_description": "Release system resource",
                  "intention_id": "release_system_resource"
                },
                {
                  "action_api": "winreg.CloseKey()",
                  "action_description": "Closes the opened registry key",
                  "action_id": "close_registry_key",
                  "object": "pg_inst_list_key",
                  "object_description": "Registry key handle",
                  "object_id": "registry_key_handle",
                  "intention_description": "Release system resource",
                  "intention_id": "release_system_resource"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "pg_inst_base_dir, 'bin', 'pg_config.exe'",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "pg_config_path",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "sshtunnel-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/sshtunnel-0.4.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/sshtunnel-0.4.0/sshtunnel-0.4.0/setup.py",
          "line_number": "29",
          "type_description": "code-execution",
          "context_snippet": "import re\nfrom os import path\nfrom codecs import open  # To use a consistent encoding\nfrom setuptools import setup  # Always prefer setuptools over distutils\n\nhere = path.abspath(path.dirname(__file__))\nname = 'sshtunnel'\ndescription = 'Pure python SSH tunnels'\nurl = 'https://github.com/pahaz/sshtunnel'\nppa = 'https://pypi.python.org/packages/source/s/{0}/{0}-'.format(name)\n\n# Get the long description from the README file\nwith open(path.join(here, 'README.rst'), encoding='utf-8') as f:\n    long_description = f.read()\nwith open(path.join(here, 'docs.rst'), encoding='utf-8') as f:\n    documentation = f.read()\nwith open(path.join(here, 'changelog.rst'), encoding='utf-8') as f:\n    changelog = f.read()\n\nwith open(path.join(here, name + '.py'), encoding='utf-8') as f:\n    data = f.read()\n    version = eval(re.search(\"__version__[ ]*=[ ]*([^\\r\\n]+)\", data).group(1))",
          "hash_value": "a96f70bc61055874029a49607b8d0c31",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import re\nfrom os import path\nfrom codecs import open  # To use a consistent encoding\nfrom setuptools import setup  # Always prefer setuptools over distutils\n\nhere = path.abspath(path.dirname(__file__))\nname = 'sshtunnel'\ndescription = 'Pure python SSH tunnels'\nurl = 'https://github.com/pahaz/sshtunnel'\nppa = 'https://pypi.python.org/packages/source/s/{0}/{0}-'.format(name)\n\n# Get the long description from the README file\nwith open(path.join(here, 'README.rst'), encoding='utf-8') as f:\n    long_description = f.read()\nwith open(path.join(here, 'docs.rst'), encoding='utf-8') as f:\n    documentation = f.read()\nwith open(path.join(here, 'changelog.rst'), encoding='utf-8') as f:\n    changelog = f.read()\n\nwith open(path.join(here, name + '.py'), encoding='utf-8') as f:\n    data = f.read()\n    version = eval(re.search(\"__version__[ ]*=[ ]*([^\\r\\n]+)\", data).group(1))",
              "triple_sequences": [
                {
                  "action_api": "os.path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "path.dirname(__file__)",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "here, 'README.rst'",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "codecs.open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "path.join(here, 'README.rst'), encoding='utf-8'",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "here, 'docs.rst'",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "codecs.open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "path.join(here, 'docs.rst'), encoding='utf-8'",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "here, 'changelog.rst'",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "codecs.open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "path.join(here, 'changelog.rst'), encoding='utf-8'",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "here, name + '.py'",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "codecs.open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "path.join(here, name + '.py'), encoding='utf-8'",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "re.search()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "\"__version__[ ]*=[ ]*([^\r\n]+)\", data",
                  "object_description": "Regular expression and file content",
                  "object_id": "regex_file_content",
                  "intention_description": "Extract structured data from file",
                  "intention_id": "extract_structured_file_data"
                },
                {
                  "action_api": "eval()",
                  "action_description": "Evaluates string as Python expression",
                  "action_id": "eval_python_expr",
                  "object": "re.search(\"__version__[ ]*=[ ]*([^\r\n]+)\", data).group(1)",
                  "object_description": "Compiled Python code",
                  "object_id": "compiled_python_code",
                  "intention_description": "Evaluate constructed code",
                  "intention_id": "evaluate_constructed_code"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "lightfm-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/lightfm-1.17.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/lightfm-1.17/lightfm-1.17/setup.py",
          "line_number": "148",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport subprocess\n\nclass Clean(Command):\n    \"\"\"\n    Clean build files.\n    \"\"\"\n\n    user_options = [(\"all\", None, \"(Compatibility with original clean command)\")]\n\n    def initialize_options(self):\n        self.all = False\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        pth = os.path.dirname(os.path.abspath(__file__))\n\n        subprocess.call([\"rm\", \"-rf\", os.path.join(pth, \"build\")])\n        subprocess.call([\"rm\", \"-rf\", os.path.join(pth, \"lightfm.egg-info\")])\n        subprocess.call([\"find\", pth, \"-name\", \"lightfm*.pyc\", \"-type\", \"f\", \"-delete\"])\n        subprocess.call([\"rm\", os.path.join(pth, \"lightfm\", \"_lightfm_fast.so\")])",
          "hash_value": "38a3b365becac0647548db7f40e0d3d8",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport subprocess\n\nclass Clean(Command):\n    \"\"\"\n    Clean build files.\n    \"\"\"\n\n    user_options = [(\"all\", None, \"(Compatibility with original clean command)\")]\n\n    def initialize_options(self):\n        self.all = False\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        pth = os.path.dirname(os.path.abspath(__file__))\n\n        subprocess.call([\"rm\", \"-rf\", os.path.join(pth, \"build\")])\n        subprocess.call([\"rm\", \"-rf\", os.path.join(pth, \"lightfm.egg-info\")])\n        subprocess.call([\"find\", pth, \"-name\", \"lightfm*.pyc\", \"-type\", \"f\", \"-delete\"])\n        subprocess.call([\"rm\", os.path.join(pth, \"lightfm\", \"_lightfm_fast.so\")])",
              "triple_sequences": []
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pymobiledevice3-4",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pymobiledevice3-4.20.25.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "api.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pymobiledevice3-4.20.25/pymobiledevice3-4.20.25/pymobiledevice3/tunneld/api.py",
          "line_number": "40",
          "type_description": "shady-links",
          "context_snippet": "import requests\nfrom pymobiledevice3.exceptions import TunneldConnectionError\nTUNNELD_DEFAULT_ADDRESS = ('127.0.0.1', 49151)\n\ndef _list_tunnels(tunneld_address: tuple[str, int] = TUNNELD_DEFAULT_ADDRESS) -> dict[str, list[dict]]:\n    try:\n        # Get the list of tunnels from the specified address\n        resp = requests.get(f'http://{tunneld_address[0]}:{tunneld_address[1]}')\n        tunnels = resp.json()\n    except requests.exceptions.ConnectionError:\n        raise TunneldConnectionError()\n    return tunnels",
          "hash_value": "262133e6b9b67a0a45f71dcc439f17b3",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import requests\nfrom pymobiledevice3.exceptions import TunneldConnectionError\nTUNNELD_DEFAULT_ADDRESS = ('127.0.0.1', 49151)\n\ndef _list_tunnels(tunneld_address: tuple[str, int] = TUNNELD_DEFAULT_ADDRESS) -> dict[str, list[dict]]:\n    try:\n        # Get the list of tunnels from the specified address\n        resp = requests.get(f'http://{tunneld_address[0]}:{tunneld_address[1]}')\n        tunnels = resp.json()\n    except requests.exceptions.ConnectionError:\n        raise TunneldConnectionError()\n    return tunnels",
              "triple_sequences": [
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP GET request to URL",
                  "action_id": "open_url_get",
                  "object": "f'http://{tunneld_address[0]}:{tunneld_address[1]}'",
                  "object_description": "URL string",
                  "object_id": "url_string",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "resp.json()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "krb5-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/krb5-0.7.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/krb5-0.7.1/krb5-0.7.1/setup.py",
          "line_number": "33",
          "type_description": "code-execution",
          "context_snippet": "import subprocess\n\ndef run_command(*args: str) -> str:\n    stdout = subprocess.check_output(args, shell=True)\n    return stdout.decode(\"utf-8\").strip()",
          "hash_value": "3017b8539f6acaa47a4deee765205d21",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import subprocess\n\ndef run_command(*args: str) -> str:\n    stdout = subprocess.check_output(args, shell=True)\n    return stdout.decode(\"utf-8\").strip()",
              "triple_sequences": [
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "args",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "bytes.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "\"utf-8\"",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                },
                {
                  "action_api": "str.strip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "urlobject-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/urlobject-2.4.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "six.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/urlobject-2.4.3/URLObject-2.4.3/urlobject/six.py",
          "line_number": "313",
          "type_description": "obfuscation",
          "context_snippet": "if PY3:\n    import builtins\n    exec_ = getattr(builtins, \"exec\")\n\n\n    def reraise(tp, value, tb=None):\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value\n\n\n    print_ = getattr(builtins, \"print\")\n    del builtins\n\nelse:\n    def exec_(_code_, _globs_=None, _locs_=None):\n        \"\"\"Execute code in a namespace.\"\"\"\n        if _globs_ is None:\n            frame = sys._getframe(1)\n            _globs_ = frame.f_globals\n            if _locs_ is None:\n                _locs_ = frame.f_locals\n            del frame\n        elif _locs_ is None:\n            _locs_ = _globs_\n        exec(\"\"\"exec _code_ in _globs_, _locs_\"\"\")\n\n\n    exec_(\"\"\"def reraise(tp, value, tb=None):\n    raise tp, value, tb\n\"\"\")\n\n\n    def print_(*args, **kwargs):\n        \"\"\"The new-style print function.\"\"\"\n        fp = kwargs.pop(\"file\", sys.stdout)\n        if fp is None:\n            return\n        def write(data):\n            if not isinstance(data, basestring):\n                data = str(data)\n            fp.write(data)\n        want_unicode = False\n        sep = kwargs.pop(\"sep\", None)\n        if sep is not None:\n            if isinstance(sep, unicode):\n                want_unicode = True\n            elif not isinstance(sep, str):\n                raise TypeError(\"sep must be None or a string\")\n        end = kwargs.pop(\"end\", None)\n        if end is not None:\n            if isinstance(end, unicode):\n                want_unicode = True\n            elif not isinstance(end, str):\n                raise TypeError(\"end must be None or a string\")\n        if kwargs:\n            raise TypeError(\"invalid keyword arguments to print()\")\n        if not want_unicode:\n            for arg in args:\n                if isinstance(arg, unicode):\n                    want_unicode = True\n                    break\n        if want_unicode:\n            newline = unicode(\"\\n\")\n            space = unicode(\" \")\n        else:\n            newline = \"\\n\"\n            space = \" \"\n        if sep is None:\n            sep = space\n        if end is None:\n            end = newline\n        for i, arg in enumerate(args):\n            if i:\n                write(sep)\n            write(arg)\n        write(end)\n",
          "hash_value": "bb8e96a93c66fd4320edfb46e7923920",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "if PY3:\n    import builtins\n    exec_ = getattr(builtins, \"exec\")\n\n\n    def reraise(tp, value, tb=None):\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value\n\n\n    print_ = getattr(builtins, \"print\")\n    del builtins\n\nelse:\n    def exec_(_code_, _globs_=None, _locs_=None):\n        \"\"\"Execute code in a namespace.\"\"\"\n        if _globs_ is None:\n            frame = sys._getframe(1)\n            _globs_ = frame.f_globals\n            if _locs_ is None:\n                _locs_ = frame.f_locals\n            del frame\n        elif _locs_ is None:\n            _locs_ = _globs_\n        exec(\"\"\"exec _code_ in _globs_, _locs_\"\"\")\n\n\n    exec_(\"\"\"def reraise(tp, value, tb=None):\n    raise tp, value, tb\n\"\"\")\n\n\n    def print_(*args, **kwargs):\n        \"\"\"The new-style print function.\"\"\"\n        fp = kwargs.pop(\"file\", sys.stdout)\n        if fp is None:\n            return\n        def write(data):\n            if not isinstance(data, basestring):\n                data = str(data)\n            fp.write(data)\n        want_unicode = False\n        sep = kwargs.pop(\"sep\", None)\n        if sep is not None:\n            if isinstance(sep, unicode):\n                want_unicode = True\n            elif not isinstance(sep, str):\n                raise TypeError(\"sep must be None or a string\")\n        end = kwargs.pop(\"end\", None)\n        if end is not None:\n            if isinstance(end, unicode):\n                want_unicode = True\n            elif not isinstance(end, str):\n                raise TypeError(\"end must be None or a string\")\n        if kwargs:\n            raise TypeError(\"invalid keyword arguments to print()\")\n        if not want_unicode:\n            for arg in args:\n                if isinstance(arg, unicode):\n                    want_unicode = True\n                    break\n        if want_unicode:\n            newline = unicode(\"\\n\")\n            space = unicode(\" \")\n        else:\n            newline = \"\\n\"\n            space = \" \"\n        if sep is None:\n            sep = space\n        if end is None:\n            end = newline\n        for i, arg in enumerate(args):\n            if i:\n                write(sep)\n            write(arg)\n        write(end)\n",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, \"exec\"",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, \"print\"",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "del builtins",
                  "action_description": "Deletes specified file from filesystem",
                  "action_id": "delete_file",
                  "object": "builtins",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Delete function from global namespace",
                  "intention_id": "delete_function_global_namespace"
                },
                {
                  "action_api": "exec_()",
                  "action_description": "Dynamically executes Python code string",
                  "action_id": "exec_python_code",
                  "object": "\"\"\"def reraise(tp, value, tb=None):\n    raise tp, value, tb\n\"\"\"",
                  "object_description": "Python code string",
                  "object_id": "python_code_string",
                  "intention_description": "Evaluate constructed code",
                  "intention_id": "evaluate_constructed_code"
                },
                {
                  "action_api": "fp.write()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "data",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "bagit-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/bagit-1.9b2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/bagit-1.9b2/bagit-1.9b2/setup.py",
          "line_number": "26",
          "type_description": "code-execution",
          "context_snippet": "import glob\nimport os\nimport subprocess\nimport sys\n\ndef get_message_catalogs():\n    message_catalogs = []\n\n    for po_file in glob.glob(\"locale/*/LC_MESSAGES/bagit-python.po\"):\n        mo_file = po_file.replace(\".po\", \".mo\")\n\n        if not os.path.exists(mo_file) or os.path.getmtime(mo_file) < os.path.getmtime(\n            po_file\n        ):\n            try:\n                subprocess.check_call([\"msgfmt\", \"-o\", mo_file, po_file])\n            except (OSError, subprocess.CalledProcessError) as exc:\n                print(\n                    \"Translation catalog %s could not be compiled (is gettext installed?) \"\n                    \" — translations will not be available for this language: %s\"\n                    % (po_file, exc),\n                    file=sys.stderr,\n                )\n                continue\n\n        message_catalogs.append((os.path.dirname(mo_file), (mo_file,)))\n\n    return message_catalogs",
          "hash_value": "e890e14a00b4ec1af57dc39a62866578",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import glob\nimport os\nimport subprocess\nimport sys\n\ndef get_message_catalogs():\n    message_catalogs = []\n\n    for po_file in glob.glob(\"locale/*/LC_MESSAGES/bagit-python.po\"):\n        mo_file = po_file.replace(\".po\", \".mo\")\n\n        if not os.path.exists(mo_file) or os.path.getmtime(mo_file) < os.path.getmtime(\n            po_file\n        ):\n            try:\n                subprocess.check_call([\"msgfmt\", \"-o\", mo_file, po_file])\n            except (OSError, subprocess.CalledProcessError) as exc:\n                print(\n                    \"Translation catalog %s could not be compiled (is gettext installed?) \"\n                    \" — translations will not be available for this language: %s\"\n                    % (po_file, exc),\n                    file=sys.stderr,\n                )\n                continue\n\n        message_catalogs.append((os.path.dirname(mo_file), (mo_file,)))\n\n    return message_catalogs",
              "triple_sequences": [
                {
                  "action_api": "glob.glob()",
                  "action_description": "List directory contents",
                  "action_id": "list_directory_contents",
                  "object": "locale/*/LC_MESSAGES/bagit-python.po",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "List files in directory",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "str.replace()",
                  "action_description": "Path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": ".po, .mo",
                  "object_description": "File extension",
                  "object_id": "file_extension",
                  "intention_description": "Prepare path for file operations",
                  "intention_id": "prepare_path_file_operations"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "mo_file",
                  "object_description": "Local file",
                  "object_id": "local_file",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "os.path.getmtime()",
                  "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
                  "action_id": "path_object_operations",
                  "object": "mo_file, po_file",
                  "object_description": "Local file or directory name",
                  "object_id": "local_file_or_directory_name",
                  "intention_description": "Prepare path for file operations",
                  "intention_id": "prepare_path_file_operations"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"msgfmt\", \"-o\", mo_file, po_file]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "mo_file",
                  "object_description": "Local file",
                  "object_id": "local_file",
                  "intention_description": "Prepare path for file operations",
                  "intention_id": "prepare_path_file_operations"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "parsl-2025",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/parsl-2025.4.7.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "addresses.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/parsl-2025.4.7/parsl-2025.4.7/parsl/addresses.py",
          "line_number": "60",
          "type_description": "shady-links",
          "context_snippet": "import requests\nimport logging\nimport typeguard\n\nlogger = logging.getLogger(__name__)\n\n@typeguard.typechecked\ndef address_by_query(timeout: float = 30) -> str:\n    \"\"\"Finds an address for the local host by querying ipify. This may\n       return an unusable value when the host is behind NAT, or when the\n       internet-facing address is not reachable from workers.\n       Parameters:\n       -----------\n\n       timeout : float\n          Timeout for the request in seconds. Default: 30s\n    \"\"\"\n    logger.debug(\"Finding address by querying remote service\")\n    response = requests.get('https://api.ipify.org', timeout=timeout)\n\n    if response.status_code == 200:\n        addr = response.text\n        logger.debug(\"Address found: {}\".format(addr))\n        return addr\n    else:\n        raise RuntimeError(\"Remote service returned unexpected HTTP status code {}\".format(response.status_code))",
          "hash_value": "b7181ca521cf29f537e5eb07c266347d",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import requests\nimport logging\nimport typeguard\n\nlogger = logging.getLogger(__name__)\n\n@typeguard.typechecked\ndef address_by_query(timeout: float = 30) -> str:\n    \"\"\"Finds an address for the local host by querying ipify. This may\n       return an unusable value when the host is behind NAT, or when the\n       internet-facing address is not reachable from workers.\n       Parameters:\n       -----------\n\n       timeout : float\n          Timeout for the request in seconds. Default: 30s\n    \"\"\"\n    logger.debug(\"Finding address by querying remote service\")\n    response = requests.get('https://api.ipify.org', timeout=timeout)\n\n    if response.status_code == 200:\n        addr = response.text\n        logger.debug(\"Address found: {}\".format(addr))\n        return addr\n    else:\n        raise RuntimeError(\"Remote service returned unexpected HTTP status code {}\".format(response.status_code))",
              "triple_sequences": [
                {
                  "action_api": "logging.getLogger()",
                  "action_description": "Retrieves standard output stream object",
                  "action_id": "get_stdout_stream",
                  "object": "__name__",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "typeguard.typechecked",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                },
                {
                  "action_api": "logger.debug()",
                  "action_description": "Retrieves standard output stream object",
                  "action_id": "get_stdout_stream",
                  "object": "\"Finding address by querying remote service\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP GET request to URL",
                  "action_id": "open_url_get",
                  "object": "'https://api.ipify.org'",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Collect public IP address",
                  "intention_id": "collect_public_ip"
                },
                {
                  "action_api": "response.status_code",
                  "action_description": "Retrieves HTTP response status code",
                  "action_id": "get_http_status",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "response.text",
                  "action_description": "Process HTTP response content",
                  "action_id": "process_http_response",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Extract public IP address",
                  "intention_id": "extract_public_ip_address"
                },
                {
                  "action_api": "logger.debug()",
                  "action_description": "Retrieves standard output stream object",
                  "action_id": "get_stdout_stream",
                  "object": "\"Address found: {}\".format(addr)",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "raise RuntimeError()",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "\"Remote service returned unexpected HTTP status code {}\".format(response.status_code)",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pytest_cov-6",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pytest_cov-6.1.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pytest_cov-6.1.1/pytest_cov-6.1.1/setup.py",
          "line_number": "78",
          "type_description": "cmd-overwrite",
          "context_snippet": "setup(\n    name='pytest-cov',\n    version='6.1.1',\n    license='MIT',\n    description='Pytest plugin for measuring coverage.',\n    long_description='{}\\n{}'.format(read('README.rst'), re.sub(':[a-z]+:`~?(.*?)`', r'``\\1``', read('CHANGELOG.rst'))),\n    author='Marc Schlaich',\n    author_email='marc.schlaich@gmail.com',\n    url='https://github.com/pytest-dev/pytest-cov',\n    packages=find_packages('src'),\n    package_dir={'': 'src'},\n    py_modules=[path.stem for path in Path('src').glob('*.py')],\n    include_package_data=True,\n    zip_safe=False,\n    classifiers=[\n        # complete classifier list: http://pypi.python.org/pypi?%3Aaction=list_classifiers\n        'Development Status :: 5 - Production/Stable',\n        'Framework :: Pytest',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: MIT License',\n        'Operating System :: Microsoft :: Windows',\n        'Operating System :: POSIX',\n        'Operating System :: Unix',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3 :: Only',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n        'Programming Language :: Python :: 3.12',\n        'Programming Language :: Python :: Implementation :: CPython',\n        'Programming Language :: Python :: Implementation :: PyPy',\n        'Topic :: Software Development :: Testing',\n        'Topic :: Utilities',\n    ],\n    project_urls={\n        'Documentation': 'https://pytest-cov.readthedocs.io/',\n        'Changelog': 'https://pytest-cov.readthedocs.io/en/latest/changelog.html',\n        'Issue Tracker': 'https://github.com/pytest-dev/pytest-cov/issues',\n    },\n    keywords=[\n        'cover',\n        'coverage',\n        'pytest',\n        'py.test',\n        'distributed',\n        'parallel',\n    ],\n    python_requires='>=3.9',\n    install_requires=[\n        'pytest>=4.6',\n        'coverage[toml]>=7.5',\n    ],\n    extras_require={\n        'testing': [\n            'fields',\n            'hunter',\n            'process-tests',\n            'pytest-xdist',\n            'virtualenv',\n        ]\n    },\n    entry_points={\n        'pytest11': [\n            'pytest_cov = pytest_cov.plugin',\n        ],\n    },\n    cmdclass={\n        'build': BuildWithPTH,\n        'easy_install': EasyInstallWithPTH,\n        'install_lib': InstallLibWithPTH,\n        'develop': DevelopWithPTH,\n        'genpth': GeneratePTH,\n    },\n)\n\n# Data dependencies:\n# - read: defined as a function above\n# - re: imported at the top\n# - BuildWithPTH, EasyInstallWithPTH, InstallLibWithPTH, DevelopWithPTH, GeneratePTH: defined as classes above\n# - Path: imported at the top\n# - find_packages, setup: imported from setuptools\n",
          "hash_value": "3428f0359496a77c8e69770a80afa338",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "setup(\n    name='pytest-cov',\n    version='6.1.1',\n    license='MIT',\n    description='Pytest plugin for measuring coverage.',\n    long_description='{}\\n{}'.format(read('README.rst'), re.sub(':[a-z]+:`~?(.*?)`', r'``\\1``', read('CHANGELOG.rst'))),\n    author='Marc Schlaich',\n    author_email='marc.schlaich@gmail.com',\n    url='https://github.com/pytest-dev/pytest-cov',\n    packages=find_packages('src'),\n    package_dir={'': 'src'},\n    py_modules=[path.stem for path in Path('src').glob('*.py')],\n    include_package_data=True,\n    zip_safe=False,\n    classifiers=[\n        # complete classifier list: http://pypi.python.org/pypi?%3Aaction=list_classifiers\n        'Development Status :: 5 - Production/Stable',\n        'Framework :: Pytest',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: MIT License',\n        'Operating System :: Microsoft :: Windows',\n        'Operating System :: POSIX',\n        'Operating System :: Unix',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3 :: Only',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n        'Programming Language :: Python :: 3.12',\n        'Programming Language :: Python :: Implementation :: CPython',\n        'Programming Language :: Python :: Implementation :: PyPy',\n        'Topic :: Software Development :: Testing',\n        'Topic :: Utilities',\n    ],\n    project_urls={\n        'Documentation': 'https://pytest-cov.readthedocs.io/',\n        'Changelog': 'https://pytest-cov.readthedocs.io/en/latest/changelog.html',\n        'Issue Tracker': 'https://github.com/pytest-dev/pytest-cov/issues',\n    },\n    keywords=[\n        'cover',\n        'coverage',\n        'pytest',\n        'py.test',\n        'distributed',\n        'parallel',\n    ],\n    python_requires='>=3.9',\n    install_requires=[\n        'pytest>=4.6',\n        'coverage[toml]>=7.5',\n    ],\n    extras_require={\n        'testing': [\n            'fields',\n            'hunter',\n            'process-tests',\n            'pytest-xdist',\n            'virtualenv',\n        ]\n    },\n    entry_points={\n        'pytest11': [\n            'pytest_cov = pytest_cov.plugin',\n        ],\n    },\n    cmdclass={\n        'build': BuildWithPTH,\n        'easy_install': EasyInstallWithPTH,\n        'install_lib': InstallLibWithPTH,\n        'develop': DevelopWithPTH,\n        'genpth': GeneratePTH,\n    },\n)\n\n# Data dependencies:\n# - read: defined as a function above\n# - re: imported at the top\n# - BuildWithPTH, EasyInstallWithPTH, InstallLibWithPTH, DevelopWithPTH, GeneratePTH: defined as classes above\n# - Path: imported at the top\n# - find_packages, setup: imported from setuptools\n",
              "triple_sequences": [
                {
                  "action_api": "read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "README.rst",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "CHANGELOG.rst",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "re.sub()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "':[a-z]+:`~?(.*?)`', r'``\\1``', read('CHANGELOG.rst')",
                  "object_description": "Regular expression and file content",
                  "object_id": "regex_file_content",
                  "intention_description": "Decode obfuscated code content",
                  "intention_id": "decode_obfuscated_code"
                },
                {
                  "action_api": "find_packages()",
                  "action_description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
                  "action_id": "path_special_operations",
                  "object": "src",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "List files in directory",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "Path().glob()",
                  "action_description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
                  "action_id": "path_special_operations",
                  "object": "'src', '*.py'",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "List files in directory",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "{...}",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "simplejpeg-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/simplejpeg-1.8.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/simplejpeg-1.8.2/simplejpeg-1.8.2/setup.py",
          "line_number": "195",
          "type_description": "code-execution",
          "context_snippet": "class cmake_build_ext(build_ext):\n    def build_cmake_dependency(self, path, options, env=None):\n        cur_dir = pt.abspath(os.curdir)\n        build_dir = pt.join(path, BUILD_DIR)\n        if not pt.exists(build_dir):\n            os.makedirs(build_dir)\n        os.chdir(build_dir)\n        config = 'Debug' if self.debug else 'Release'\n        env = dict(os.environ, **(env or {}))\n        subprocess.check_call([\n            CMAKE_PATH,\n            '-G' + make_type(), '-Wno-dev',\n            '-DCMAKE_BUILD_TYPE=' + config,\n            *options,\n            pt.join(path)\n        ], stdout=sys.stdout, stderr=sys.stderr, env=env)\n        if not self.dry_run:\n            subprocess.check_call([\n                CMAKE_PATH, '--build', '.', '--config', config\n            ], stdout=sys.stdout, stderr=sys.stderr, env=env)\n        os.chdir(cur_dir)\n\ndef make_type():\n    if OS in ('linux', 'darwin'):\n        return 'Unix Makefiles'\n    elif OS == 'windows':\n        return 'NMake Makefiles'\n    else:\n        raise RuntimeError('Platform not supported: %s, %s' % (OS, ARCH))\n\n# Variable dependencies:\n# - CMAKE_PATH: set at top, from cmake import or fallback to 'cmake'\n# - make_type(): see above\n# - config: local variable in function\n# - options: function argument\n# - pt: os.path as pt\n# - sys: imported\n# - env: local variable\n# - os: imported",
          "hash_value": "273d8df0086284e95bf720af37cae752",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class cmake_build_ext(build_ext):\n    def build_cmake_dependency(self, path, options, env=None):\n        cur_dir = pt.abspath(os.curdir)\n        build_dir = pt.join(path, BUILD_DIR)\n        if not pt.exists(build_dir):\n            os.makedirs(build_dir)\n        os.chdir(build_dir)\n        config = 'Debug' if self.debug else 'Release'\n        env = dict(os.environ, **(env or {}))\n        subprocess.check_call([\n            CMAKE_PATH,\n            '-G' + make_type(), '-Wno-dev',\n            '-DCMAKE_BUILD_TYPE=' + config,\n            *options,\n            pt.join(path)\n        ], stdout=sys.stdout, stderr=sys.stderr, env=env)\n        if not self.dry_run:\n            subprocess.check_call([\n                CMAKE_PATH, '--build', '.', '--config', config\n            ], stdout=sys.stdout, stderr=sys.stderr, env=env)\n        os.chdir(cur_dir)\n\ndef make_type():\n    if OS in ('linux', 'darwin'):\n        return 'Unix Makefiles'\n    elif OS == 'windows':\n        return 'NMake Makefiles'\n    else:\n        raise RuntimeError('Platform not supported: %s, %s' % (OS, ARCH))\n\n# Variable dependencies:\n# - CMAKE_PATH: set at top, from cmake import or fallback to 'cmake'\n# - make_type(): see above\n# - config: local variable in function\n# - options: function argument\n# - pt: os.path as pt\n# - sys: imported\n# - env: local variable\n# - os: imported",
              "triple_sequences": [
                {
                  "action_api": "pt.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.curdir",
                  "object_description": "Current working directory",
                  "object_id": "current_working_directory",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "pt.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "path, BUILD_DIR",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "pt.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "build_dir",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "os.makedirs()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "build_dir",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "os.chdir()",
                  "action_description": "Changes current working directory",
                  "action_id": "change_working_dir",
                  "object": "build_dir",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Change working directory",
                  "intention_id": "change_working_directory"
                },
                {
                  "action_api": "dict()",
                  "action_description": "Serializes Python object to JSON string",
                  "action_id": "serialize_to_json",
                  "object": "os.environ, **(env or {})",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[CMAKE_PATH, '-G' + make_type(), '-Wno-dev', '-DCMAKE_BUILD_TYPE=' + config, *options, pt.join(path)]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[CMAKE_PATH, '--build', '.', '--config', config]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.chdir()",
                  "action_description": "Changes current working directory",
                  "action_id": "change_working_dir",
                  "object": "cur_dir",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Restore previous working directory",
                  "intention_id": "restore_working_directory"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "codecov-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/codecov-2.1.13.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/codecov-2.1.13/codecov-2.1.13/setup.py",
          "line_number": "38",
          "type_description": "cmd-overwrite",
          "context_snippet": "from setuptools import setup\nfrom setuptools.command.install import install\n\nclass PostInstallCommand(install):\n    def run(self):\n        install.run(self)\n        print(\"\\n**** The codecov package has been deprecated and will be removed by the team in the future. Please update to use the uploader (https://docs.codecov.com/docs/codecov-uploader) to prevent any breakages in workflow. ****\\n\")\n\nclassifiers = [\n    \"Development Status :: 5 - Production/Stable\",\n    \"Environment :: Plugins\",\n    \"Intended Audience :: Developers\",\n    \"Programming Language :: Python\",\n    \"Programming Language :: Python :: 2\",\n    \"Programming Language :: Python :: 2.7\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.4\",\n    \"Programming Language :: Python :: 3.5\",\n    \"Programming Language :: Python :: 3.6\",\n    \"Programming Language :: Python :: 3.7\",\n    \"Programming Language :: Python :: 3.8\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: Implementation :: PyPy\",\n    \"License :: OSI Approved :: Apache Software License\",\n    \"Topic :: Software Development :: Testing\",\n]\n\nfilepath = os.path.abspath(os.path.dirname(__file__))\n\nabout = {}\nwith open(os.path.join(filepath, \"codecov\", \"__version__.py\"), \"r\", \"utf-8\") as f:\n    exec(f.read(), about)\n\nsetup(\n    name=about[\"__title__\"],\n    version=about[\"__version__\"],\n    description=about[\"__description__\"],\n    long_description=None,\n    classifiers=classifiers,\n    keywords=\"coverage codecov code python java scala php\",\n    author=about[\"__author__\"],\n    author_email=about[\"__author_email__\"],\n    url=about[\"__url__\"],\n    license=about[\"__license__\"],\n    packages=[\"codecov\"],\n    include_package_data=True,\n    zip_safe=True,\n    install_requires=[\"requests>=2.7.9\", \"coverage\"],\n    entry_points={\"console_scripts\": [\"codecov=codecov:main\"]},\n    python_requires=\">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*\",\n    cmdclass={\n        'install': PostInstallCommand,\n    },\n)\n",
          "hash_value": "acf6788774733057e68159730c7de5d0",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from setuptools import setup\nfrom setuptools.command.install import install\n\nclass PostInstallCommand(install):\n    def run(self):\n        install.run(self)\n        print(\"\\n**** The codecov package has been deprecated and will be removed by the team in the future. Please update to use the uploader (https://docs.codecov.com/docs/codecov-uploader) to prevent any breakages in workflow. ****\\n\")\n\nclassifiers = [\n    \"Development Status :: 5 - Production/Stable\",\n    \"Environment :: Plugins\",\n    \"Intended Audience :: Developers\",\n    \"Programming Language :: Python\",\n    \"Programming Language :: Python :: 2\",\n    \"Programming Language :: Python :: 2.7\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.4\",\n    \"Programming Language :: Python :: 3.5\",\n    \"Programming Language :: Python :: 3.6\",\n    \"Programming Language :: Python :: 3.7\",\n    \"Programming Language :: Python :: 3.8\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: Implementation :: PyPy\",\n    \"License :: OSI Approved :: Apache Software License\",\n    \"Topic :: Software Development :: Testing\",\n]\n\nfilepath = os.path.abspath(os.path.dirname(__file__))\n\nabout = {}\nwith open(os.path.join(filepath, \"codecov\", \"__version__.py\"), \"r\", \"utf-8\") as f:\n    exec(f.read(), about)\n\nsetup(\n    name=about[\"__title__\"],\n    version=about[\"__version__\"],\n    description=about[\"__description__\"],\n    long_description=None,\n    classifiers=classifiers,\n    keywords=\"coverage codecov code python java scala php\",\n    author=about[\"__author__\"],\n    author_email=about[\"__author_email__\"],\n    url=about[\"__url__\"],\n    license=about[\"__license__\"],\n    packages=[\"codecov\"],\n    include_package_data=True,\n    zip_safe=True,\n    install_requires=[\"requests>=2.7.9\", \"coverage\"],\n    entry_points={\"console_scripts\": [\"codecov=codecov:main\"]},\n    python_requires=\">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*\",\n    cmdclass={\n        'install': PostInstallCommand,\n    },\n)\n",
              "triple_sequences": [
                {
                  "action_api": "os.path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.dirname(__file__)",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "filepath, \"codecov\", \"__version__.py\"",
                  "object_description": "Directory path with file",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "os.path.join(filepath, \"codecov\", \"__version__.py\"), \"r\", \"utf-8\"",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "f.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "exec()",
                  "action_description": "Dynamically executes Python code string",
                  "action_id": "exec_python_code",
                  "object": "f.read(), about",
                  "object_description": "Script file content",
                  "object_id": "script_file_content",
                  "intention_description": "Execute Python code",
                  "intention_id": "execute_python_code"
                },
                {
                  "action_api": "setuptools.setup()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "setup arguments (name, version, description, etc.)",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "lupa-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/lupa-2.4.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/lupa-2.4/lupa-2.4/setup.py",
          "line_number": "65",
          "type_description": "code-execution",
          "context_snippet": "def cmd_output(command):\n    \"\"\"\n    Returns the exit code and output of the program, as a triplet of the form\n    (exit_code, stdout, stderr).\n    \"\"\"\n    env = os.environ.copy()\n    env['LANG'] = ''\n    import subprocess\n    proc = subprocess.Popen(command,\n                            shell=True,\n                            stdout=subprocess.PIPE,\n                            stderr=subprocess.PIPE,\n                            env=env)\n    stdout, stderr = proc.communicate()\n    exit_code = proc.wait()\n    if exit_code != 0:\n        raise PkgConfigError(stderr.decode('ISO8859-1'))\n    return stdout\n\n# Data dependencies:\n# - command: argument to the function\n# - os: imported at top\n# - subprocess: imported at top and again in function\n# - PkgConfigError: defined above\n",
          "hash_value": "43956ccb5255bcd57f5347f166f07cd4",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def cmd_output(command):\n    \"\"\"\n    Returns the exit code and output of the program, as a triplet of the form\n    (exit_code, stdout, stderr).\n    \"\"\"\n    env = os.environ.copy()\n    env['LANG'] = ''\n    import subprocess\n    proc = subprocess.Popen(command,\n                            shell=True,\n                            stdout=subprocess.PIPE,\n                            stderr=subprocess.PIPE,\n                            env=env)\n    stdout, stderr = proc.communicate()\n    exit_code = proc.wait()\n    if exit_code != 0:\n        raise PkgConfigError(stderr.decode('ISO8859-1'))\n    return stdout\n\n# Data dependencies:\n# - command: argument to the function\n# - os: imported at top\n# - subprocess: imported at top and again in function\n# - PkgConfigError: defined above\n",
              "triple_sequences": [
                {
                  "action_api": "os.environ.copy()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command with shell access",
                  "action_id": "spawn_process_shell",
                  "object": "command",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "proc.communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "proc.wait()",
                  "action_description": "Waits for process to complete execution",
                  "action_id": "wait_process_completion",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Wait for events",
                  "intention_id": "wait_for_events"
                },
                {
                  "action_api": "stderr.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "ISO8859-1",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "gitchangelog-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/gitchangelog-3.0.4.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gitchangelog-3.0.4/gitchangelog-3.0.4/setup.py",
          "line_number": "45",
          "type_description": "code-execution",
          "context_snippet": "if \"3.0.4\".startswith(\"%%\"):\n    import os.path\n    import sys\n    WIN32 = sys.platform == 'win32'\n    autogen = os.path.join(\".\", \"autogen.sh\")\n    if not os.path.exists(autogen):\n        sys.stderr.write(\n            \"This source repository was not configured.\\n\"\n            \"Please ensure ``./autogen.sh`` exists and that you are running \"\n            \"``setup.py`` from the project root directory.\\n\")\n        sys.exit(1)\n    if os.path.exists('.autogen.sh.output'):\n        sys.stderr.write(\n            \"It seems that ``./autogen.sh`` couldn't do its job as expected.\\n\"\n            \"Please try to launch ``./autogen.sh`` manualy, and send the \"\n            \"results to the\\nmaintainer of this package.\\n\"\n            \"Package will not be installed !\\n\")\n        sys.exit(1)\n    sys.stderr.write(\"Missing version information: \"\n                     \"running './autogen.sh'...\\n\")\n    import os\n    import subprocess\n    os.system('%s%s > .autogen.sh.output'\n              % (\"bash \" if WIN32 else \"\",\n                 autogen))\n    cmdline = sys.argv[:]\n    if cmdline[0] == \"-c\":\n        ## for some reason, this is needed when launched from pip\n        cmdline[0] = \"setup.py\"\n    errlvl = subprocess.call([\"python\", ] + cmdline)\n    os.unlink(\".autogen.sh.output\")\n    sys.exit(errlvl)",
          "hash_value": "e4875d818dd37ef790472715b501c4ac",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "if \"3.0.4\".startswith(\"%%\"):\n    import os.path\n    import sys\n    WIN32 = sys.platform == 'win32'\n    autogen = os.path.join(\".\", \"autogen.sh\")\n    if not os.path.exists(autogen):\n        sys.stderr.write(\n            \"This source repository was not configured.\\n\"\n            \"Please ensure ``./autogen.sh`` exists and that you are running \"\n            \"``setup.py`` from the project root directory.\\n\")\n        sys.exit(1)\n    if os.path.exists('.autogen.sh.output'):\n        sys.stderr.write(\n            \"It seems that ``./autogen.sh`` couldn't do its job as expected.\\n\"\n            \"Please try to launch ``./autogen.sh`` manualy, and send the \"\n            \"results to the\\nmaintainer of this package.\\n\"\n            \"Package will not be installed !\\n\")\n        sys.exit(1)\n    sys.stderr.write(\"Missing version information: \"\n                     \"running './autogen.sh'...\\n\")\n    import os\n    import subprocess\n    os.system('%s%s > .autogen.sh.output'\n              % (\"bash \" if WIN32 else \"\",\n                 autogen))\n    cmdline = sys.argv[:]\n    if cmdline[0] == \"-c\":\n        ## for some reason, this is needed when launched from pip\n        cmdline[0] = \"setup.py\"\n    errlvl = subprocess.call([\"python\", ] + cmdline)\n    os.unlink(\".autogen.sh.output\")\n    sys.exit(errlvl)",
              "triple_sequences": [
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "[\".\", \"autogen.sh\"]",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "autogen",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "sys.stderr.write()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "\"This source repository was not configured.\\nPlease ensure ``./autogen.sh`` exists and that you are running ``setup.py`` from the project root directory.\\n\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "1",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "'.autogen.sh.output'",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "sys.stderr.write()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "\"It seems that ``./autogen.sh`` couldn't do its job as expected.\\nPlease try to launch ``./autogen.sh`` manualy, and send the results to the\\nmaintainer of this package.\\nPackage will not be installed !\\n\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "1",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                },
                {
                  "action_api": "sys.stderr.write()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "\"Missing version information: running './autogen.sh'...\\n\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "%s%s > .autogen.sh.output",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"python\", ] + cmdline",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.unlink()",
                  "action_description": "Deletes specified file from filesystem",
                  "action_id": "delete_file",
                  "object": "\".autogen.sh.output\"",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Delete file",
                  "intention_id": "delete_file"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "errlvl",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "sfbulk2-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/sfbulk2-0.8.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "sfbulk2.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/sfbulk2-0.8.0/sfbulk2-0.8.0/src/sfbulk2.py",
          "line_number": "324",
          "type_description": "clipboard-access",
          "context_snippet": "import pyperclip\n\ndef copy_to_clipboard(text):\n    pyperclip.copy(text)",
          "hash_value": "c44ff99333fea929383caaafc77fc4cf",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import pyperclip\n\ndef copy_to_clipboard(text):\n    pyperclip.copy(text)",
              "triple_sequences": [
                {
                  "action_api": "pyperclip.copy()",
                  "action_description": "Copies specified text to system clipboard",
                  "action_id": "copy_to_clipboard",
                  "object": "text",
                  "object_description": "Clipboard content data",
                  "object_id": "clipboard_data",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "lap-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/lap-0.5.12.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/lap-0.5.12/lap-0.5.12/setup.py",
          "line_number": "34",
          "type_description": "code-execution",
          "context_snippet": "def compile_cpp(cython_file):\n    \"\"\"Compile a C++ file from Cython's pyx or py.\n    \"\"\"\n    import os\n    import subprocess\n    cpp_file = os.path.splitext(cython_file)[0] + \".cpp\"\n    flags = ['--fast-fail', '--cplus']\n    rc = subprocess.call(['cython'] + flags + ['-o', cpp_file, cython_file])\n    if rc != 0:\n        raise Exception('Cythonizing %s failed' % cython_file)\n    else:\n        return cpp_file",
          "hash_value": "6749b04e58427c8b945ef7827eeb59d2",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def compile_cpp(cython_file):\n    \"\"\"Compile a C++ file from Cython's pyx or py.\n    \"\"\"\n    import os\n    import subprocess\n    cpp_file = os.path.splitext(cython_file)[0] + \".cpp\"\n    flags = ['--fast-fail', '--cplus']\n    rc = subprocess.call(['cython'] + flags + ['-o', cpp_file, cython_file])\n    if rc != 0:\n        raise Exception('Cythonizing %s failed' % cython_file)\n    else:\n        return cpp_file",
              "triple_sequences": [
                {
                  "action_api": "os.path.splitext()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "cython_file",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "subprocess.call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "['cython', '--fast-fail', '--cplus', '-o', cpp_file, cython_file]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "tiledb-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/tiledb-0.33.6.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/tiledb-0.33.6/tiledb-0.33.6/setup.py",
          "line_number": "48",
          "type_description": "code-execution",
          "context_snippet": "import argparse\nimport os\nimport subprocess\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"command\", choices=[\"install\", \"develop\"])\n    parser.add_argument(\"--tiledb\", type=str, required=False)\n    parser.add_argument(\"--debug\", action=\"store_true\")\n    parser.add_argument(\"--enable-deprecations\", action=\"store_true\", required=False)\n    parser.add_argument(\"--enable-serialization\", action=\"store_true\", required=False)\n    parser.add_argument(\"-v\", action=\"store_true\")\n    args = parser.parse_args()\n\n    os.getcwd()\n\n    cmd = [\n        \"pip\",\n        \"install\",\n    ]\n\n    if args.command == \"develop\":\n        cmd.append(\"-e\")\n\n    cmd.append(os.getcwd())\n\n    if args.tiledb:\n        cmd.append(f\"-Cskbuild.cmake.define.TILEDB_PATH={args.tiledb}\")\n\n    if args.debug:\n        cmd.append(f\"-Cskbuild.cmake.build-type=Debug\")\n\n    if args.enable_deprecations:\n        cmd.append(f\"-Cskbuild.cmake.define.TILEDB_REMOVE_DEPRECATIONS=OFF\")\n\n    if args.enable_serialization:\n        cmd.append(f\"-Cskbuild.cmake.define.TILEDB_SERIALIZATION=ON\")\n\n    if args.v:\n        cmd.append(\"-v\")\n\n    print(\n        \"Note: 'setup.py' is deprecated in the Python ecosystem. Limited backward compatibility is currently provided for 'install' and 'develop' commands as passthrough to 'pip'.\"\n    )\n    print(\"    running: \", f\"`{' '.join(cmd)}`\")\n\n    subprocess.run(cmd)\n\n\nif __name__ == \"__main__\":\n    main()",
          "hash_value": "d00a5d110e060d8284231d2d2bb664bf",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import argparse\nimport os\nimport subprocess\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"command\", choices=[\"install\", \"develop\"])\n    parser.add_argument(\"--tiledb\", type=str, required=False)\n    parser.add_argument(\"--debug\", action=\"store_true\")\n    parser.add_argument(\"--enable-deprecations\", action=\"store_true\", required=False)\n    parser.add_argument(\"--enable-serialization\", action=\"store_true\", required=False)\n    parser.add_argument(\"-v\", action=\"store_true\")\n    args = parser.parse_args()\n\n    os.getcwd()\n\n    cmd = [\n        \"pip\",\n        \"install\",\n    ]\n\n    if args.command == \"develop\":\n        cmd.append(\"-e\")\n\n    cmd.append(os.getcwd())\n\n    if args.tiledb:\n        cmd.append(f\"-Cskbuild.cmake.define.TILEDB_PATH={args.tiledb}\")\n\n    if args.debug:\n        cmd.append(f\"-Cskbuild.cmake.build-type=Debug\")\n\n    if args.enable_deprecations:\n        cmd.append(f\"-Cskbuild.cmake.define.TILEDB_REMOVE_DEPRECATIONS=OFF\")\n\n    if args.enable_serialization:\n        cmd.append(f\"-Cskbuild.cmake.define.TILEDB_SERIALIZATION=ON\")\n\n    if args.v:\n        cmd.append(\"-v\")\n\n    print(\n        \"Note: 'setup.py' is deprecated in the Python ecosystem. Limited backward compatibility is currently provided for 'install' and 'develop' commands as passthrough to 'pip'.\"\n    )\n    print(\"    running: \", f\"`{' '.join(cmd)}`\")\n\n    subprocess.run(cmd)\n\n\nif __name__ == \"__main__\":\n    main()",
              "triple_sequences": [
                {
                  "action_api": "argparse.ArgumentParser()",
                  "action_description": "Retrieves command-line arguments passed to script",
                  "action_id": "get_cmd_args",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access command line arguments",
                  "intention_id": "access_command_line_arguments"
                },
                {
                  "action_api": "os.getcwd()",
                  "action_description": "Returns current working directory",
                  "action_id": "get_working_dir",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect working directory",
                  "intention_id": "collect_working_directory"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "cmd (e.g., ['pip', 'install', os.getcwd(), ...])",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "deepeval-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/deepeval-2.7.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "telemetry.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/deepeval-2.7.1/deepeval-2.7.1/deepeval/telemetry.py",
          "line_number": "47",
          "type_description": "shady-links",
          "context_snippet": "import requests\n\ndef get_anonymous_public_ip():\n    try:\n        response = requests.get(\"https://api.ipify.org\", timeout=5)\n        if response.status_code == 200:\n            return response.text\n    except requests.RequestException:\n        pass\n    return None",
          "hash_value": "703c79d118eef19170e47e8009d2dd8e",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import requests\n\ndef get_anonymous_public_ip():\n    try:\n        response = requests.get(\"https://api.ipify.org\", timeout=5)\n        if response.status_code == 200:\n            return response.text\n    except requests.RequestException:\n        pass\n    return None",
              "triple_sequences": [
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP GET request to URL",
                  "action_id": "open_url_get",
                  "object": "https://api.ipify.org",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Collect public IP address",
                  "intention_id": "collect_public_ip"
                },
                {
                  "action_api": "response.status_code",
                  "action_description": "Retrieves HTTP response status code",
                  "action_id": "get_http_status",
                  "object": "response",
                  "object_description": "HTTP response content from remote server",
                  "object_id": "http_response_remote_content",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "response.text",
                  "action_description": "Process HTTP response content",
                  "action_id": "process_http_response",
                  "object": "response",
                  "object_description": "HTTP response content from remote server",
                  "object_id": "http_response_remote_content",
                  "intention_description": "Extract public IP address",
                  "intention_id": "extract_public_ip_address"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "fbprophet-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/fbprophet-0.7.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/fbprophet-0.7.1/fbprophet-0.7.1/setup.py",
          "line_number": "122",
          "type_description": "cmd-overwrite",
          "context_snippet": "setup(\n    name='fbprophet',\n    version='0.7.1',\n    description='Automatic Forecasting Procedure',\n    url='https://facebook.github.io/prophet/',\n    author='Sean J. Taylor <sjtz@pm.me>, Ben Letham <bletham@fb.com>',\n    author_email='sjtz@pm.me',\n    license='MIT',\n    packages=find_packages(),\n    setup_requires=[\n    ],\n    install_requires=install_requires,\n    python_requires='>=3',\n    zip_safe=False,\n    include_package_data=True,\n    cmdclass={\n        'build_py': BuildPyCommand,\n        'develop': DevelopCommand,\n        'test': TestCommand,\n    },\n    test_suite='fbprophet.tests',\n    classifiers=[\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.7',\n    ],\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n)\n\n# Data dependencies:\n# - install_requires: loaded from requirements.txt\n# - long_description: loaded from README.md\n# - BuildPyCommand, DevelopCommand, TestCommand: defined above\n# - find_packages: imported from setuptools\n",
          "hash_value": "eb4fdfce0b8db1f74e773a8938912534",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "setup(\n    name='fbprophet',\n    version='0.7.1',\n    description='Automatic Forecasting Procedure',\n    url='https://facebook.github.io/prophet/',\n    author='Sean J. Taylor <sjtz@pm.me>, Ben Letham <bletham@fb.com>',\n    author_email='sjtz@pm.me',\n    license='MIT',\n    packages=find_packages(),\n    setup_requires=[\n    ],\n    install_requires=install_requires,\n    python_requires='>=3',\n    zip_safe=False,\n    include_package_data=True,\n    cmdclass={\n        'build_py': BuildPyCommand,\n        'develop': DevelopCommand,\n        'test': TestCommand,\n    },\n    test_suite='fbprophet.tests',\n    classifiers=[\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.7',\n    ],\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n)\n\n# Data dependencies:\n# - install_requires: loaded from requirements.txt\n# - long_description: loaded from README.md\n# - BuildPyCommand, DevelopCommand, TestCommand: defined above\n# - find_packages: imported from setuptools\n",
              "triple_sequences": [
                {
                  "action_api": "setup()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "name='fbprophet', version='0.7.1', description='Automatic Forecasting Procedure', url='https://facebook.github.io/prophet/', author='Sean J. Taylor <sjtz@pm.me>, Ben Letham <bletham@fb.com>', author_email='sjtz@pm.me', license='MIT', packages=find_packages(), setup_requires=[], install_requires=install_requires, python_requires='>=3', zip_safe=False, include_package_data=True, cmdclass={'build_py': BuildPyCommand, 'develop': DevelopCommand, 'test': TestCommand}, test_suite='fbprophet.tests', classifiers=['Programming Language :: Python', 'Programming Language :: Python :: 3', 'Programming Language :: Python :: 3.7'], long_description=long_description, long_description_content_type='text/markdown'",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                },
                {
                  "action_api": "find_packages()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Install multiple Python packages",
                  "intention_id": "install_multiple_python_packages"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "mysqlclient-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/mysqlclient-2.2.7.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/mysqlclient-2.2.7/mysqlclient-2.2.7/setup.py",
          "line_number": "23",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport subprocess\nimport sys\n\ndef find_package_name():\n    \"\"\"Get available pkg-config package name\"\"\"\n    # Ubuntu uses mariadb.pc, but CentOS uses libmariadb.pc\n    packages = [\"mysqlclient\", \"mariadb\", \"libmariadb\", \"perconaserverclient\"]\n    for pkg in packages:\n        try:\n            cmd = f\"pkg-config --exists {pkg}\"\n            print(f\"Trying {cmd}\")\n            subprocess.check_call(cmd, shell=True)\n        except subprocess.CalledProcessError as err:\n            print(err)\n        else:\n            return pkg\n    raise Exception(\n        \"Can not find valid pkg-config name.\\n\"\n        \"Specify MYSQLCLIENT_CFLAGS and MYSQLCLIENT_LDFLAGS env vars manually\"\n    )",
          "hash_value": "38f7452e409c04af691bc2b80492bd5d",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport subprocess\nimport sys\n\ndef find_package_name():\n    \"\"\"Get available pkg-config package name\"\"\"\n    # Ubuntu uses mariadb.pc, but CentOS uses libmariadb.pc\n    packages = [\"mysqlclient\", \"mariadb\", \"libmariadb\", \"perconaserverclient\"]\n    for pkg in packages:\n        try:\n            cmd = f\"pkg-config --exists {pkg}\"\n            print(f\"Trying {cmd}\")\n            subprocess.check_call(cmd, shell=True)\n        except subprocess.CalledProcessError as err:\n            print(err)\n        else:\n            return pkg\n    raise Exception(\n        \"Can not find valid pkg-config name.\\n\"\n        \"Specify MYSQLCLIENT_CFLAGS and MYSQLCLIENT_LDFLAGS env vars manually\"\n    )",
              "triple_sequences": [
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "pkg-config --exists mysqlclient",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "pkg-config --exists mariadb",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "pkg-config --exists libmariadb",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "pkg-config --exists perconaserverclient",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "amazon_braket_sdk-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/amazon_braket_sdk-1.91.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "pulse_sequence.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/amazon_braket_sdk-1.91.0/amazon_braket_sdk-1.91.0/src/braket/pulse/pulse_sequence.py",
          "line_number": "364",
          "type_description": "obfuscation",
          "context_snippet": "import builtins\n\ndef _parse_arg_from_calibration_schema(\n    self, argument: dict, waveforms: dict[Waveform], frames: dict[Frame]\n) -> Any:\n    nonprimitive_arg_type = {\n        \"frame\": frames.get,\n        \"waveform\": waveforms.get,\n        \"expr\": FreeParameterExpression,\n    }\n    if argument[\"type\"] in nonprimitive_arg_type:\n        return nonprimitive_arg_type[argument[\"type\"]](argument[\"value\"])\n    return getattr(builtins, argument[\"type\"])(argument[\"value\"])",
          "hash_value": "51d6835307877e73bff65dfc2a3c96f6",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import builtins\n\ndef _parse_arg_from_calibration_schema(\n    self, argument: dict, waveforms: dict[Waveform], frames: dict[Frame]\n) -> Any:\n    nonprimitive_arg_type = {\n        \"frame\": frames.get,\n        \"waveform\": waveforms.get,\n        \"expr\": FreeParameterExpression,\n    }\n    if argument[\"type\"] in nonprimitive_arg_type:\n        return nonprimitive_arg_type[argument[\"type\"]](argument[\"value\"])\n    return getattr(builtins, argument[\"type\"])(argument[\"value\"])",
              "triple_sequences": [
                {
                  "action_api": "frames.get()",
                  "action_description": "Retrieves value and data type for registry value",
                  "action_id": "get_registry_value",
                  "object": "argument[\"value\"]",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "waveforms.get()",
                  "action_description": "Retrieves value and data type for registry value",
                  "action_id": "get_registry_value",
                  "object": "argument[\"value\"]",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "FreeParameterExpression()",
                  "action_description": "Instantiates class",
                  "action_id": "init_grabber_class",
                  "object": "argument[\"value\"]",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, argument[\"type\"]",
                  "object_description": "Builtin module",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "debugpy-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/debugpy-1.8.14.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "pydevconsole.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/debugpy-1.8.14/debugpy-1.8.14/src/debugpy/_vendored/pydevd/pydevconsole.py",
          "line_number": "450",
          "type_description": "obfuscation",
          "context_snippet": "def get_interpreter():\n    try:\n        interpreterInterface = getattr(__builtin__, \"interpreter\")\n    except AttributeError:\n        interpreterInterface = InterpreterInterface(None, None, threading.current_thread())\n        __builtin__.interpreter = interpreterInterface\n        sys.stderr.write(interpreterInterface.get_greeting_msg())\n        sys.stderr.flush()\n\n    return interpreterInterface",
          "hash_value": "780de2fab062496f7f0a675078b56254",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def get_interpreter():\n    try:\n        interpreterInterface = getattr(__builtin__, \"interpreter\")\n    except AttributeError:\n        interpreterInterface = InterpreterInterface(None, None, threading.current_thread())\n        __builtin__.interpreter = interpreterInterface\n        sys.stderr.write(interpreterInterface.get_greeting_msg())\n        sys.stderr.flush()\n\n    return interpreterInterface",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "__builtin__, \"interpreter\"",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "InterpreterInterface()",
                  "action_description": "Instantiates InterpreterInterface class",
                  "action_id": "init_setup_class",
                  "object": "None, None, threading.current_thread()",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Initialize shell object",
                  "intention_id": "initialize_shell_object"
                },
                {
                  "action_api": "setattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "__builtin__.interpreter = interpreterInterface",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "sys.stderr.write()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "interpreterInterface.get_greeting_msg()",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                },
                {
                  "action_api": "sys.stderr.flush()",
                  "action_description": "Writes file content",
                  "action_id": "basic_write_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pynag-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pynag-1.1.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pynag-1.1.2/pynag-1.1.2/setup.py",
          "line_number": "29",
          "type_description": "code-execution",
          "context_snippet": "from subprocess import call, PIPE, Popen\n\nclass BuildMan(Command):\n    \"\"\"Builds the man page using sphinx\"\"\"\n    user_options = []\n\n    def run(self):\n        cmd = \"sphinx-build -b man docs man\"\n        sphinx_proc = Popen(cmd.split(),\n                            stdout=PIPE,\n                            stderr=PIPE)\n        stdout, stderr = sphinx_proc.communicate()\n        return_code = sphinx_proc.wait()\n        if return_code:\n            print(\"Warning: Build of manpage failed \\\"%s\\\":\\n%s\\n%s\" % (\n                      cmd,\n                      stdout,\n                      stderr))",
          "hash_value": "cf5e30cae92ce6dae86f69f892b9deab",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from subprocess import call, PIPE, Popen\n\nclass BuildMan(Command):\n    \"\"\"Builds the man page using sphinx\"\"\"\n    user_options = []\n\n    def run(self):\n        cmd = \"sphinx-build -b man docs man\"\n        sphinx_proc = Popen(cmd.split(),\n                            stdout=PIPE,\n                            stderr=PIPE)\n        stdout, stderr = sphinx_proc.communicate()\n        return_code = sphinx_proc.wait()\n        if return_code:\n            print(\"Warning: Build of manpage failed \\\"%s\\\":\\n%s\\n%s\" % (\n                      cmd,\n                      stdout,\n                      stderr))",
              "triple_sequences": [
                {
                  "action_api": "Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "sphinx-build -b man docs man",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Create child process",
                  "intention_id": "create_child_process"
                },
                {
                  "action_api": "Popen.communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "Popen.communicate()",
                  "action_description": "Reads all bytes from process standard error",
                  "action_id": "read_process_stderr",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "Popen.wait()",
                  "action_description": "Waits for process to complete execution",
                  "action_id": "wait_process_completion",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Wait for events",
                  "intention_id": "wait_for_events"
                },
                {
                  "action_api": "print()",
                  "action_description": "Writes file content",
                  "action_id": "write_file_content",
                  "object": "Warning: Build of manpage failed \"%s\":\n%s\n%s\" % (cmd, stdout, stderr)",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "mutagen-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/mutagen-1.47.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/mutagen-1.47.0/mutagen-1.47.0/setup.py",
          "line_number": "90",
          "type_description": "code-execution",
          "context_snippet": "import subprocess\nimport os\n\nclass distcheck(sdist):\n\n    def _check_manifest(self):\n        assert self.get_archive_files()\n\n        # make sure MANIFEST.in includes all tracked files\n        if subprocess.call([\"git\", \"status\"],\n                           stdout=subprocess.PIPE,\n                           stderr=subprocess.PIPE) == 0:\n            # contains the packaged files after run() is finished\n            included_files = self.filelist.files\n            assert included_files\n\n            process = subprocess.Popen(\n                [\"git\", \"ls-tree\", \"-r\", \"HEAD\", \"--name-only\"],\n                stdout=subprocess.PIPE, universal_newlines=True)\n            out, err = process.communicate()\n            assert process.returncode == 0\n\n            tracked_files = out.splitlines()\n            to_ignore = [\n                \".gitignore\",\n                \".codecov.yml\",\n                \".github/workflows/test.yml\",\n                \".readthedocs.yaml\",\n                \"docs/requirements.txt\",\n            ]\n            for ignore in to_ignore:\n                tracked_files.remove(ignore)\n\n            tracked_files = [\n                f for f in tracked_files if os.path.dirname(f) != \"fuzzing\"]\n\n            diff = set(tracked_files) - set(included_files)\n            assert not diff, (\n                \"Not all tracked files included in tarball, check MANIFEST.in\",\n                diff)\n",
          "hash_value": "6911870188f5117a914dbbed9d49eef5",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import subprocess\nimport os\n\nclass distcheck(sdist):\n\n    def _check_manifest(self):\n        assert self.get_archive_files()\n\n        # make sure MANIFEST.in includes all tracked files\n        if subprocess.call([\"git\", \"status\"],\n                           stdout=subprocess.PIPE,\n                           stderr=subprocess.PIPE) == 0:\n            # contains the packaged files after run() is finished\n            included_files = self.filelist.files\n            assert included_files\n\n            process = subprocess.Popen(\n                [\"git\", \"ls-tree\", \"-r\", \"HEAD\", \"--name-only\"],\n                stdout=subprocess.PIPE, universal_newlines=True)\n            out, err = process.communicate()\n            assert process.returncode == 0\n\n            tracked_files = out.splitlines()\n            to_ignore = [\n                \".gitignore\",\n                \".codecov.yml\",\n                \".github/workflows/test.yml\",\n                \".readthedocs.yaml\",\n                \"docs/requirements.txt\",\n            ]\n            for ignore in to_ignore:\n                tracked_files.remove(ignore)\n\n            tracked_files = [\n                f for f in tracked_files if os.path.dirname(f) != \"fuzzing\"]\n\n            diff = set(tracked_files) - set(included_files)\n            assert not diff, (\n                \"Not all tracked files included in tarball, check MANIFEST.in\",\n                diff)\n",
              "triple_sequences": [
                {
                  "action_api": "subprocess.call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"git\", \"status\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "[\"git\", \"ls-tree\", \"-r\", \"HEAD\", \"--name-only\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "process.communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "f",
                  "object_description": "Local file or directory name",
                  "object_id": "local_file_or_directory_name",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pynput-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pynput-1.8.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pynput-1.8.1/pynput-1.8.1/setup.py",
          "line_number": "53",
          "type_description": "code-execution",
          "context_snippet": "import os\n\n#: The name of the main Python package\nMAIN_PACKAGE_NAME = 'pynput'\n\n# Read globals from ._info without loading it\nINFO = {}\nwith open(os.path.join(\n        os.path.dirname(__file__),\n        'lib',\n        MAIN_PACKAGE_NAME,\n        '_info.py'), 'rb') as f:\n    for line in f.read().decode('utf-8').splitlines():\n        try:\n            name, value = (i.strip() for i in line.split('='))\n            if name.startswith('__') and name.endswith('__'):\n                INFO[name[2:-2]] = eval(value)\n        except ValueError:\n            pass",
          "hash_value": "9afd59b077b56a31c2e49e9de02bf4e5",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\n\n#: The name of the main Python package\nMAIN_PACKAGE_NAME = 'pynput'\n\n# Read globals from ._info without loading it\nINFO = {}\nwith open(os.path.join(\n        os.path.dirname(__file__),\n        'lib',\n        MAIN_PACKAGE_NAME,\n        '_info.py'), 'rb') as f:\n    for line in f.read().decode('utf-8').splitlines():\n        try:\n            name, value = (i.strip() for i in line.split('='))\n            if name.startswith('__') and name.endswith('__'):\n                INFO[name[2:-2]] = eval(value)\n        except ValueError:\n            pass",
              "triple_sequences": [
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.dirname(__file__), 'lib', MAIN_PACKAGE_NAME, '_info.py'",
                  "object_description": "Directory path with file",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "os.path.join(os.path.dirname(__file__), 'lib', MAIN_PACKAGE_NAME, '_info.py'), 'rb'",
                  "object_description": "Directory path with file",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "f.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "bytes.decode()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "'utf-8'",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Decode bytes to string",
                  "intention_id": "decode_bytes_to_string"
                },
                {
                  "action_api": "str.splitlines()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "str.split('=')",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "'='",
                  "object_description": "Space delimiter",
                  "object_id": "space_delimiter",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "str.strip()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "eval()",
                  "action_description": "Evaluates string as Python expression",
                  "action_id": "eval_python_expr",
                  "object": "value",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Evaluate constructed code",
                  "intention_id": "evaluate_constructed_code"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "webassets-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/webassets-2.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "six.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/webassets-2.0/webassets-2.0/examples/appengine/webassets/six.py",
          "line_number": "336",
          "type_description": "obfuscation",
          "context_snippet": "if PY3:\n    import builtins\n    exec_ = getattr(builtins, \"exec\")\n\n\n    def reraise(tp, value, tb=None):\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value\n\n\n    print_ = getattr(builtins, \"print\")\n    del builtins\n\nelse:\n    def exec_(_code_, _globs_=None, _locs_=None):\n        \"\"\"Execute code in a namespace.\"\"\"\n        if _globs_ is None:\n            frame = sys._getframe(1)\n            _globs_ = frame.f_globals\n            if _locs_ is None:\n                _locs_ = frame.f_locals\n            del frame\n        elif _locs_ is None:\n            _locs_ = _globs_\n        exec(\"\"\"exec _code_ in _globs_, _locs_\"\"\")\n\n\n    exec_(\"\"\"def reraise(tp, value, tb=None):\n    raise tp, value, tb\n\"\"\")\n\n\n    def print_(*args, **kwargs):\n        \"\"\"The new-style print function.\"\"\"\n        fp = kwargs.pop(\"file\", sys.stdout)\n        if fp is None:\n            return\n        def write(data):\n            if not isinstance(data, basestring):\n                data = str(data)\n            fp.write(data)\n        want_unicode = False\n        sep = kwargs.pop(\"sep\", None)\n        if sep is not None:\n            if isinstance(sep, unicode):\n                want_unicode = True\n            elif not isinstance(sep, str):\n                raise TypeError(\"sep must be None or a string\")\n        end = kwargs.pop(\"end\", None)\n        if end is not None:\n            if isinstance(end, unicode):\n                want_unicode = True\n            elif not isinstance(end, str):\n                raise TypeError(\"end must be None or a string\")\n        if kwargs:\n            raise TypeError(\"invalid keyword arguments to print()\")\n        if not want_unicode:\n            for arg in args:\n                if isinstance(arg, unicode):\n                    want_unicode = True\n                    break\n        if want_unicode:\n            newline = unicode(\"\\n\")\n            space = unicode(\" \")\n        else:\n            newline = \"\\n\"\n            space = \" \"\n        if sep is None:\n            sep = space\n        if end is None:\n            end = newline\n        for i, arg in enumerate(args):\n            if i:\n                write(sep)\n            write(arg)\n        write(end)\n",
          "hash_value": "bb8e96a93c66fd4320edfb46e7923920",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "if PY3:\n    import builtins\n    exec_ = getattr(builtins, \"exec\")\n\n\n    def reraise(tp, value, tb=None):\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value\n\n\n    print_ = getattr(builtins, \"print\")\n    del builtins\n\nelse:\n    def exec_(_code_, _globs_=None, _locs_=None):\n        \"\"\"Execute code in a namespace.\"\"\"\n        if _globs_ is None:\n            frame = sys._getframe(1)\n            _globs_ = frame.f_globals\n            if _locs_ is None:\n                _locs_ = frame.f_locals\n            del frame\n        elif _locs_ is None:\n            _locs_ = _globs_\n        exec(\"\"\"exec _code_ in _globs_, _locs_\"\"\")\n\n\n    exec_(\"\"\"def reraise(tp, value, tb=None):\n    raise tp, value, tb\n\"\"\")\n\n\n    def print_(*args, **kwargs):\n        \"\"\"The new-style print function.\"\"\"\n        fp = kwargs.pop(\"file\", sys.stdout)\n        if fp is None:\n            return\n        def write(data):\n            if not isinstance(data, basestring):\n                data = str(data)\n            fp.write(data)\n        want_unicode = False\n        sep = kwargs.pop(\"sep\", None)\n        if sep is not None:\n            if isinstance(sep, unicode):\n                want_unicode = True\n            elif not isinstance(sep, str):\n                raise TypeError(\"sep must be None or a string\")\n        end = kwargs.pop(\"end\", None)\n        if end is not None:\n            if isinstance(end, unicode):\n                want_unicode = True\n            elif not isinstance(end, str):\n                raise TypeError(\"end must be None or a string\")\n        if kwargs:\n            raise TypeError(\"invalid keyword arguments to print()\")\n        if not want_unicode:\n            for arg in args:\n                if isinstance(arg, unicode):\n                    want_unicode = True\n                    break\n        if want_unicode:\n            newline = unicode(\"\\n\")\n            space = unicode(\" \")\n        else:\n            newline = \"\\n\"\n            space = \" \"\n        if sep is None:\n            sep = space\n        if end is None:\n            end = newline\n        for i, arg in enumerate(args):\n            if i:\n                write(sep)\n            write(arg)\n        write(end)\n",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, \"exec\"",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, \"print\"",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "del builtins",
                  "action_description": "Deletes specified file from filesystem",
                  "action_id": "delete_file",
                  "object": "builtins",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Delete function from global namespace",
                  "intention_id": "delete_function_global_namespace"
                },
                {
                  "action_api": "exec_()",
                  "action_description": "Dynamically executes Python code string",
                  "action_id": "exec_python_code",
                  "object": "\"\"\"def reraise(tp, value, tb=None):\\n    raise tp, value, tb\\n\"\"\"",
                  "object_description": "Python code string",
                  "object_id": "python_code_string",
                  "intention_description": "Execute Python code",
                  "intention_id": "execute_python_code"
                },
                {
                  "action_api": "str()",
                  "action_description": "Encodes string to bytes using default encoding",
                  "action_id": "encode_string_to_bytes",
                  "object": "data",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Encode string to bytes",
                  "intention_id": "encode_string_to_bytes"
                },
                {
                  "action_api": "fp.write()",
                  "action_description": "Saves image to file",
                  "action_id": "save_image_file",
                  "object": "data",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pybluez-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pybluez-0.23.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pybluez-0.23/PyBluez-0.23/setup.py",
          "line_number": "79",
          "type_description": "code-execution",
          "context_snippet": "elif sys.platform.startswith(\"darwin\"):\n    packages.append('lightblue')\n    package_dir['lightblue'] = 'macos'\n    zip_safe = False\n\n    if sys.version_info >= (3,6):\n        install_requires += ['pyobjc-core>=6', 'pyobjc-framework-Cocoa>=6']\n    else:\n        install_requires += ['pyobjc-core>=3.1,<6', 'pyobjc-framework-Cocoa>=3.1,<6']\n\n    # FIXME: This is inelegant, how can we cover the cases?\n    build_cmds = set(['bdist', 'bdist_egg', 'bdist_wheel'])\n    if build_cmds & set(sys.argv):\n        # Build the framework into macos/\n        import subprocess\n        subprocess.check_call([\n            'xcodebuild', 'install',\n            '-project', 'macos/LightAquaBlue/LightAquaBlue.xcodeproj',\n            '-scheme', 'LightAquaBlue',\n            'DSTROOT=' + os.path.join(os.getcwd(), 'macos'),\n            'INSTALL_PATH=/',\n            'DEPLOYMENT_LOCATION=YES',\n        ])\n        \n        # We can't seem to list a directory as package_data, so we will\n        # recursively add all all files we find\n        package_data['lightblue'] = []\n        for path, _, files in os.walk('macos/LightAquaBlue.framework'):\n            for f in files:\n                include = os.path.join(path, f)[6:]  # trim off macos/\n                package_data['lightblue'].append(include)\n    \n        # This should allow us to use the framework from an egg [untested]\n        eager_resources.append('macos/LightAquaBlue.framework')",
          "hash_value": "c9b93363f7c57d0256a8dcaccd4849b3",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "elif sys.platform.startswith(\"darwin\"):\n    packages.append('lightblue')\n    package_dir['lightblue'] = 'macos'\n    zip_safe = False\n\n    if sys.version_info >= (3,6):\n        install_requires += ['pyobjc-core>=6', 'pyobjc-framework-Cocoa>=6']\n    else:\n        install_requires += ['pyobjc-core>=3.1,<6', 'pyobjc-framework-Cocoa>=3.1,<6']\n\n    # FIXME: This is inelegant, how can we cover the cases?\n    build_cmds = set(['bdist', 'bdist_egg', 'bdist_wheel'])\n    if build_cmds & set(sys.argv):\n        # Build the framework into macos/\n        import subprocess\n        subprocess.check_call([\n            'xcodebuild', 'install',\n            '-project', 'macos/LightAquaBlue/LightAquaBlue.xcodeproj',\n            '-scheme', 'LightAquaBlue',\n            'DSTROOT=' + os.path.join(os.getcwd(), 'macos'),\n            'INSTALL_PATH=/',\n            'DEPLOYMENT_LOCATION=YES',\n        ])\n        \n        # We can't seem to list a directory as package_data, so we will\n        # recursively add all all files we find\n        package_data['lightblue'] = []\n        for path, _, files in os.walk('macos/LightAquaBlue.framework'):\n            for f in files:\n                include = os.path.join(path, f)[6:]  # trim off macos/\n                package_data['lightblue'].append(include)\n    \n        # This should allow us to use the framework from an egg [untested]\n        eager_resources.append('macos/LightAquaBlue.framework')",
              "triple_sequences": [
                {
                  "action_api": "sys.platform.startswith()",
                  "action_description": "Retrieves operating system identifier",
                  "action_id": "get_os_id",
                  "object": "\"darwin\"",
                  "object_description": "Operating system identifier",
                  "object_id": "",
                  "intention_description": "Determine operating system",
                  "intention_id": "determine_operating_system"
                },
                {
                  "action_api": "sys.version_info >= (3,6)",
                  "action_description": "Retrieves Python interpreter version",
                  "action_id": "get_python_version",
                  "object": "sys.version_info",
                  "object_description": "Python interpreter version",
                  "object_id": "",
                  "intention_description": "Determine operating system",
                  "intention_id": "determine_operating_system"
                },
                {
                  "action_api": "set()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "['bdist', 'bdist_egg', 'bdist_wheel']",
                  "object_description": "List of build command strings",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "set(sys.argv)",
                  "action_description": "Retrieves command-line arguments passed to script",
                  "action_id": "get_cmd_args",
                  "object": "sys.argv",
                  "object_description": "Command-line arguments passed to script",
                  "object_id": "",
                  "intention_description": "Access command line arguments",
                  "intention_id": "access_command_line_arguments"
                },
                {
                  "action_api": "build_cmds & set(sys.argv)",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "build_cmds & set(sys.argv)",
                  "object_description": "Intersection of build command set and command-line arguments",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "['xcodebuild', 'install', '-project', 'macos/LightAquaBlue/LightAquaBlue.xcodeproj', '-scheme', 'LightAquaBlue', 'DSTROOT=' + os.path.join(os.getcwd(), 'macos'), 'INSTALL_PATH=/', 'DEPLOYMENT_LOCATION=YES']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.getcwd(), 'macos'",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.getcwd()",
                  "action_description": "Returns current working directory",
                  "action_id": "get_working_dir",
                  "object": "",
                  "object_description": "Current working directory",
                  "object_id": "current_working_directory",
                  "intention_description": "Collect working directory",
                  "intention_id": "collect_working_directory"
                },
                {
                  "action_api": "os.walk()",
                  "action_description": "List directory contents",
                  "action_id": "list_directory_contents",
                  "object": "'macos/LightAquaBlue.framework'",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "List files in directory",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "path, f",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "together-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/together-1.5.5.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "constants.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/together-1.5.5/together-1.5.5/src/together/constants.py",
          "line_number": "12",
          "type_description": "shady-links",
          "context_snippet": "import enum\n\n# Session constants\nTIMEOUT_SECS = 600\nMAX_SESSION_LIFETIME_SECS = 180\nMAX_CONNECTION_RETRIES = 2\nMAX_RETRIES = 5\nINITIAL_RETRY_DELAY = 0.5\nMAX_RETRY_DELAY = 8.0\n\n# API defaults\nBASE_URL = \"https://api.together.xyz/v1\"\n\n# Download defaults\nDOWNLOAD_BLOCK_SIZE = 10 * 1024 * 1024  # 10 MB\nDISABLE_TQDM = False",
          "hash_value": "b355bf4fb01f044e50bf6fb7fbe46245",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import enum\n\n# Session constants\nTIMEOUT_SECS = 600\nMAX_SESSION_LIFETIME_SECS = 180\nMAX_CONNECTION_RETRIES = 2\nMAX_RETRIES = 5\nINITIAL_RETRY_DELAY = 0.5\nMAX_RETRY_DELAY = 8.0\n\n# API defaults\nBASE_URL = \"https://api.together.xyz/v1\"\n\n# Download defaults\nDOWNLOAD_BLOCK_SIZE = 10 * 1024 * 1024  # 10 MB\nDISABLE_TQDM = False",
              "triple_sequences": []
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pgi-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pgi-0.0.11.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "_compat.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pgi-0.0.11.2/pgi-0.0.11.2/pgi/_compat.py",
          "line_number": "25",
          "type_description": "obfuscation",
          "context_snippet": "if PY3:\n    string_types = (str,)\n    text_type = str\n    integer_types = (int,)\n    long_type = int\n\n    import builtins\n    exec_ = getattr(builtins, \"exec\")\n\n    def reraise(tp, value, tb=None):\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value\n\n    iterkeys = lambda d: iter(d.keys())\n    itervalues = lambda d: iter(d.values())\n    iteritems = lambda d: iter(d.items())\n\n    xrange = range\n\n    from io import StringIO\n    StringIO = StringIO\n\n    import builtins\n    builtins = builtins",
          "hash_value": "893ac610b4795dff624bd005845e2a8c",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "if PY3:\n    string_types = (str,)\n    text_type = str\n    integer_types = (int,)\n    long_type = int\n\n    import builtins\n    exec_ = getattr(builtins, \"exec\")\n\n    def reraise(tp, value, tb=None):\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value\n\n    iterkeys = lambda d: iter(d.keys())\n    itervalues = lambda d: iter(d.values())\n    iteritems = lambda d: iter(d.items())\n\n    xrange = range\n\n    from io import StringIO\n    StringIO = StringIO\n\n    import builtins\n    builtins = builtins",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Access attribute value",
                  "action_id": "access_attribute_value",
                  "object": "builtins, \"exec\"",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "celery-5",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/celery-5.5.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "changelog_formatter.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/celery-5.5.1/celery-5.5.1/docs/changelog_formatter.py",
          "line_number": "27",
          "type_description": "clipboard-access",
          "context_snippet": "import pyperclip\n\ndef read_from_clipboard():\n    text = pyperclip.paste()\n    return text.splitlines()",
          "hash_value": "5059472ef24371eef89cc50338303537",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import pyperclip\n\ndef read_from_clipboard():\n    text = pyperclip.paste()\n    return text.splitlines()",
              "triple_sequences": [
                {
                  "action_api": "pyperclip.paste()",
                  "action_description": "Retrieves text from system clipboard",
                  "action_id": "get_clipboard_text",
                  "object": "",
                  "object_description": "Clipboard content data",
                  "object_id": "clipboard_data",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                },
                {
                  "action_api": "str.splitlines()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "netcdf4-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/netcdf4-1.7.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/netcdf4-1.7.2/netcdf4-1.7.2/setup.py",
          "line_number": "180",
          "type_description": "code-execution",
          "context_snippet": "try:\n    if ncconfig is None:\n        if netCDF4_dir is not None:\n            ncconfig = os.path.join(netCDF4_dir, 'bin/nc-config')\n        else:  # otherwise, just hope it's in the users PATH.\n            ncconfig = 'nc-config'\n    HAS_NCCONFIG = subprocess.call([ncconfig, '--libs']) == 0\nexcept OSError:\n    HAS_NCCONFIG = False",
          "hash_value": "e66305e4671089cf747127cee66ac231",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "try:\n    if ncconfig is None:\n        if netCDF4_dir is not None:\n            ncconfig = os.path.join(netCDF4_dir, 'bin/nc-config')\n        else:  # otherwise, just hope it's in the users PATH.\n            ncconfig = 'nc-config'\n    HAS_NCCONFIG = subprocess.call([ncconfig, '--libs']) == 0\nexcept OSError:\n    HAS_NCCONFIG = False",
              "triple_sequences": [
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "netCDF4_dir, 'bin/nc-config'",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "subprocess.call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[ncconfig, '--libs']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "awscrt-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/awscrt-0.26.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/awscrt-0.26.1/awscrt-0.26.1/setup.py",
          "line_number": "53",
          "type_description": "code-execution",
          "context_snippet": "import subprocess\n\ndef get_xcode_major_version():\n    \"\"\"Return major version of xcode present on the system\"\"\"\n    try:\n        output = subprocess.check_output(\n            ['xcodebuild', '-version'], text=True)\n        version_line = output.split('\\n')[0]\n        version = version_line.split(' ')[-1]\n        return int(version.split('.')[0])\n    except BaseException:\n        return 0",
          "hash_value": "e0e3cd9b96b7b7f51f9b0ff372426060",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import subprocess\n\ndef get_xcode_major_version():\n    \"\"\"Return major version of xcode present on the system\"\"\"\n    try:\n        output = subprocess.check_output(\n            ['xcodebuild', '-version'], text=True)\n        version_line = output.split('\\n')[0]\n        version = version_line.split(' ')[-1]\n        return int(version.split('.')[0])\n    except BaseException:\n        return 0",
              "triple_sequences": [
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "['xcodebuild', '-version']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "output.split('\\n')[0]",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "version_line.split(' ')[-1]",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                },
                {
                  "action_api": "int()",
                  "action_description": "Convert integer to bytes with specified length and byte order",
                  "action_id": "convert_int_to_bytes",
                  "object": "version.split('.')[0]",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Convert string to integer",
                  "intention_id": "convert_string_to_integer"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "stcal-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/stcal-1.12.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "astrometric_utils.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/stcal-1.12.0/stcal-1.12.0/src/stcal/tweakreg/astrometric_utils.py",
          "line_number": "207",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "import requests\nfrom astropy.table import Table\n\nSERVICELOCATION = os.environ.get(ASTROMETRIC_CAT_ENVVAR, DEF_CAT_URL)\nTIMEOUT = 30.0  # in seconds\n\ndef get_catalog(\n    right_ascension,\n    declination,\n    epoch=2016.0,\n    search_radius=0.1,\n    catalog=\"GAIADR3\",\n    timeout=TIMEOUT,\n):\n    \"\"\"Extract catalog from VO web service.\n    ...\n    \"\"\"\n    service_type = \"vo/CatalogSearch.aspx\"\n    spec_str = \"RA={}&DEC={}&EPOCH={}&SR={}&FORMAT={}&CAT={}&MINDET=5\"\n    headers = {\"Content-Type\": \"text/csv\"}\n    fmt = \"CSV\"\n\n    spec = spec_str.format(\n        right_ascension,\n        declination,\n        epoch,\n        search_radius,\n        fmt,\n        catalog\n    )\n    service_url = f\"{SERVICELOCATION}/{service_type}?{spec}\"\n    try:\n        rawcat = requests.get(service_url, headers=headers, timeout=timeout)\n    except requests.exceptions.ConnectionError:\n        raise requests.exceptions.ConnectionError(\n            \"Could not connect to the VO API server. Try again later.\"\n        )\n    except requests.exceptions.Timeout:\n        raise requests.exceptions.Timeout(\"The request to the VO API server timed out.\")\n    except requests.exceptions.RequestException:\n        raise requests.exceptions.RequestException(\n            \"There was an unexpected error with the request.\"\n        )\n    r_contents = rawcat.content.decode()  # convert from bytes to a String\n    rstr = r_contents.split(\"\\r\\n\")\n    # remove initial line describing the number of sources returned\n    # CRITICAL to proper interpretation of CSV data\n    del rstr[0]\n\n    return Table.read(rstr, format=\"csv\")",
          "hash_value": "b7b308b19068ec763f47e0891595d3b8",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import requests\nfrom astropy.table import Table\n\nSERVICELOCATION = os.environ.get(ASTROMETRIC_CAT_ENVVAR, DEF_CAT_URL)\nTIMEOUT = 30.0  # in seconds\n\ndef get_catalog(\n    right_ascension,\n    declination,\n    epoch=2016.0,\n    search_radius=0.1,\n    catalog=\"GAIADR3\",\n    timeout=TIMEOUT,\n):\n    \"\"\"Extract catalog from VO web service.\n    ...\n    \"\"\"\n    service_type = \"vo/CatalogSearch.aspx\"\n    spec_str = \"RA={}&DEC={}&EPOCH={}&SR={}&FORMAT={}&CAT={}&MINDET=5\"\n    headers = {\"Content-Type\": \"text/csv\"}\n    fmt = \"CSV\"\n\n    spec = spec_str.format(\n        right_ascension,\n        declination,\n        epoch,\n        search_radius,\n        fmt,\n        catalog\n    )\n    service_url = f\"{SERVICELOCATION}/{service_type}?{spec}\"\n    try:\n        rawcat = requests.get(service_url, headers=headers, timeout=timeout)\n    except requests.exceptions.ConnectionError:\n        raise requests.exceptions.ConnectionError(\n            \"Could not connect to the VO API server. Try again later.\"\n        )\n    except requests.exceptions.Timeout:\n        raise requests.exceptions.Timeout(\"The request to the VO API server timed out.\")\n    except requests.exceptions.RequestException:\n        raise requests.exceptions.RequestException(\n            \"There was an unexpected error with the request.\"\n        )\n    r_contents = rawcat.content.decode()  # convert from bytes to a String\n    rstr = r_contents.split(\"\\r\\n\")\n    # remove initial line describing the number of sources returned\n    # CRITICAL to proper interpretation of CSV data\n    del rstr[0]\n\n    return Table.read(rstr, format=\"csv\")",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "ASTROMETRIC_CAT_ENVVAR",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "service_url, headers=headers, timeout=timeout",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "rawcat.content.decode()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Decode downloaded content",
                  "intention_id": "decode_downloaded_content"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "\"\\r\\n\"",
                  "object_description": "Space delimiter",
                  "object_id": "space_delimiter",
                  "intention_description": "Prepare string processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "del rstr[0]",
                  "action_description": "Deletes specified file from filesystem",
                  "action_id": "delete_file",
                  "object": "rstr[0]",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Delete file content",
                  "intention_id": "delete_file_content"
                },
                {
                  "action_api": "Table.read()",
                  "action_description": "Opens file for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "rstr, format=\"csv\"",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "g4f-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/g4f-0.5.0.4.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "Wuguokai.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/g4f-0.5.0.4/g4f-0.5.0.4/g4f/Provider/deprecated/Wuguokai.py",
          "line_number": "29",
          "type_description": "shady-links",
          "context_snippet": "    @staticmethod\n    def create_completion(\n        model: str,\n        messages: list[dict[str, str]],\n        stream: bool,\n        **kwargs: Any,\n    ) -> CreateResult:\n        headers = {\n            'authority': 'ai-api.wuguokai.xyz',\n            'accept': 'application/json, text/plain, */*',\n            'accept-language': 'id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7',\n            'content-type': 'application/json',\n            'origin': 'https://chat.wuguokai.xyz',\n            'referer': 'https://chat.wuguokai.xyz/',\n            'sec-ch-ua': '\"Not.A/Brand\";v=\"8\", \"Chromium\";v=\"114\", \"Google Chrome\";v=\"114\"',\n            'sec-ch-ua-mobile': '?0',\n            'sec-ch-ua-platform': '\"Windows\"',\n            'sec-fetch-dest': 'empty',\n            'sec-fetch-mode': 'cors',\n            'sec-fetch-site': 'same-site',\n            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36'\n        }\n        data ={\n            \"prompt\": format_prompt(messages),\n            \"options\": {},\n            \"userId\": f\"#/chat/{random.randint(1,99999999)}\",\n            \"usingContext\": True\n        }\n        response = requests.post(\n            \"https://ai-api20.wuguokai.xyz/api/chat-process\",\n            headers=headers,\n            timeout=3,\n            json=data,\n            proxies=kwargs.get('proxy', {}),\n        )\n        _split = response.text.split(\"> 若回答失败请重试或多刷新几次界面后重试\")\n        if response.status_code != 200:\n            raise Exception(f\"Error: {response.status_code} {response.reason}\")\n        if len(_split) > 1:\n            yield _split[1].strip()\n        else:\n            yield _split[0].strip()",
          "hash_value": "77734284265a2331c35c8afd07c33329",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "    @staticmethod\n    def create_completion(\n        model: str,\n        messages: list[dict[str, str]],\n        stream: bool,\n        **kwargs: Any,\n    ) -> CreateResult:\n        headers = {\n            'authority': 'ai-api.wuguokai.xyz',\n            'accept': 'application/json, text/plain, */*',\n            'accept-language': 'id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7',\n            'content-type': 'application/json',\n            'origin': 'https://chat.wuguokai.xyz',\n            'referer': 'https://chat.wuguokai.xyz/',\n            'sec-ch-ua': '\"Not.A/Brand\";v=\"8\", \"Chromium\";v=\"114\", \"Google Chrome\";v=\"114\"',\n            'sec-ch-ua-mobile': '?0',\n            'sec-ch-ua-platform': '\"Windows\"',\n            'sec-fetch-dest': 'empty',\n            'sec-fetch-mode': 'cors',\n            'sec-fetch-site': 'same-site',\n            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36'\n        }\n        data ={\n            \"prompt\": format_prompt(messages),\n            \"options\": {},\n            \"userId\": f\"#/chat/{random.randint(1,99999999)}\",\n            \"usingContext\": True\n        }\n        response = requests.post(\n            \"https://ai-api20.wuguokai.xyz/api/chat-process\",\n            headers=headers,\n            timeout=3,\n            json=data,\n            proxies=kwargs.get('proxy', {}),\n        )\n        _split = response.text.split(\"> 若回答失败请重试或多刷新几次界面后重试\")\n        if response.status_code != 200:\n            raise Exception(f\"Error: {response.status_code} {response.reason}\")\n        if len(_split) > 1:\n            yield _split[1].strip()\n        else:\n            yield _split[0].strip()",
              "triple_sequences": [
                {
                  "action_api": "random.randint()",
                  "action_description": "Generate random integer",
                  "action_id": "generate_random_integer",
                  "object": "1,99999999",
                  "object_description": "Random string",
                  "object_id": "random_string",
                  "intention_description": "Generate random number",
                  "intention_id": "generate_random_number"
                },
                {
                  "action_api": "format_prompt()",
                  "action_description": "Prepare data for further processing",
                  "action_id": "prepare_data_processing",
                  "object": "messages",
                  "object_description": "String containing environment data",
                  "object_id": "string_environment_data",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "requests.post()",
                  "action_description": "Sends HTTP POST request to URL",
                  "action_id": "open_url_post",
                  "object": "https://ai-api20.wuguokai.xyz/api/chat-process",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Transmit encoded data via HTTP POST",
                  "intention_id": "transmit_data_http_post"
                },
                {
                  "action_api": "response.text.split()",
                  "action_description": "Basic string operations (splitting and joining strings)",
                  "action_id": "path_string_operations",
                  "object": "> 若回答失败请重试或多刷新几次界面后重试",
                  "object_description": "String containing environment data",
                  "object_id": "string_environment_data",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "response.status_code",
                  "action_description": "Retrieves HTTP response status code",
                  "action_id": "get_http_status",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "raise Exception()",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "f\"Error: {response.status_code} {response.reason}\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                },
                {
                  "action_api": "str.strip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "_split[1] or _split[0]",
                  "object_description": "String containing environment data",
                  "object_id": "string_environment_data",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "embedchain-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/embedchain-0.1.128.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "add_config.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/embedchain-0.1.128/embedchain-0.1.128/embedchain/config/add_config.py",
          "line_number": "42",
          "type_description": "obfuscation",
          "context_snippet": "import builtins\nimport logging\nfrom collections.abc import Callable\nfrom importlib import import_module\nfrom typing import Optional\n\nfrom embedchain.config.base_config import BaseConfig\nfrom embedchain.helpers.json_serializable import register_deserializable\n\n\n@register_deserializable\nclass ChunkerConfig(BaseConfig):\n    \"\"\"\n    Config for the chunker used in `add` method\n    \"\"\"\n\n    def __init__(\n        self,\n        chunk_size: Optional[int] = 2000,\n        chunk_overlap: Optional[int] = 0,\n        length_function: Optional[Callable[[str], int]] = None,\n        min_chunk_size: Optional[int] = 0,\n    ):\n        self.chunk_size = chunk_size\n        self.chunk_overlap = chunk_overlap\n        self.min_chunk_size = min_chunk_size\n        if self.min_chunk_size >= self.chunk_size:\n            raise ValueError(f\"min_chunk_size {min_chunk_size} should be less than chunk_size {chunk_size}\")\n        if self.min_chunk_size < self.chunk_overlap:\n            logging.warning(\n                f\"min_chunk_size {min_chunk_size} should be greater than chunk_overlap {chunk_overlap}, otherwise it is redundant.\"  # noqa:E501\n            )\n\n        if isinstance(length_function, str):\n            self.length_function = self.load_func(length_function)\n        else:\n            self.length_function = length_function if length_function else len\n\n    @staticmethod\n    def load_func(dotpath: str):\n        if \".\" not in dotpath:\n            return getattr(builtins, dotpath)\n        else:\n            module_, func = dotpath.rsplit(\".\", maxsplit=1)\n            m = import_module(module_)\n            return getattr(m, func)",
          "hash_value": "034d145ab60ee73d9ef94d717895bcab",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import builtins\nimport logging\nfrom collections.abc import Callable\nfrom importlib import import_module\nfrom typing import Optional\n\nfrom embedchain.config.base_config import BaseConfig\nfrom embedchain.helpers.json_serializable import register_deserializable\n\n\n@register_deserializable\nclass ChunkerConfig(BaseConfig):\n    \"\"\"\n    Config for the chunker used in `add` method\n    \"\"\"\n\n    def __init__(\n        self,\n        chunk_size: Optional[int] = 2000,\n        chunk_overlap: Optional[int] = 0,\n        length_function: Optional[Callable[[str], int]] = None,\n        min_chunk_size: Optional[int] = 0,\n    ):\n        self.chunk_size = chunk_size\n        self.chunk_overlap = chunk_overlap\n        self.min_chunk_size = min_chunk_size\n        if self.min_chunk_size >= self.chunk_size:\n            raise ValueError(f\"min_chunk_size {min_chunk_size} should be less than chunk_size {chunk_size}\")\n        if self.min_chunk_size < self.chunk_overlap:\n            logging.warning(\n                f\"min_chunk_size {min_chunk_size} should be greater than chunk_overlap {chunk_overlap}, otherwise it is redundant.\"  # noqa:E501\n            )\n\n        if isinstance(length_function, str):\n            self.length_function = self.load_func(length_function)\n        else:\n            self.length_function = length_function if length_function else len\n\n    @staticmethod\n    def load_func(dotpath: str):\n        if \".\" not in dotpath:\n            return getattr(builtins, dotpath)\n        else:\n            module_, func = dotpath.rsplit(\".\", maxsplit=1)\n            m = import_module(module_)\n            return getattr(m, func)",
              "triple_sequences": [
                {
                  "action_api": "logging.warning()",
                  "action_description": "Logs warning message",
                  "action_id": "set_builtin_attr",
                  "object": "f\"min_chunk_size {min_chunk_size} should be greater than chunk_overlap {chunk_overlap}, otherwise it is redundant.\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "length_function, str",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine required module presence",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "ChunkerConfig.load_func()",
                  "action_description": "Dynamically imports specified module",
                  "action_id": "import_dynamic",
                  "object": "dotpath",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "builtins, dotpath",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "str.rsplit()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "dotpath, maxsplit=1",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "import_module()",
                  "action_description": "Dynamically imports specified module",
                  "action_id": "import_dynamic",
                  "object": "module_",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "m, func",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "bc_detect_secrets-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/bc_detect_secrets-1.5.40.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "ibm_cos_hmac.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/bc_detect_secrets-1.5.40/bc_detect_secrets-1.5.40/detect_secrets/plugins/ibm_cos_hmac.py",
          "line_number": "88",
          "type_description": "shady-links",
          "context_snippet": "def verify_ibm_cos_hmac_credentials(\n    access_key: str,\n    secret_key: str,\n    host: str = 's3.us.cloud-object-storage.appdomain.cloud',\n) -> bool:\n    response = query_ibm_cos_hmac(access_key, secret_key, host)\n    return response.status_code == 200\n\n# Helper function used:\ndef query_ibm_cos_hmac(\n    access_key: str,\n    secret_key: str,\n    host: str = 's3.us.cloud-object-storage.appdomain.cloud',\n) -> requests.Response:\n    # Sample code referenced from link below\n    # https://cloud.ibm.com/docs/services/cloud-object-storage/api-reference?topic=cloud-object-storage-hmac-signature  # noqa: E501\n\n    # request elements\n    http_method = 'GET'\n    # region is a wildcard value that takes the place of the AWS region value\n    # as COS doesn't use the same conventions for regions, this parameter can accept any string\n    region = 'us-standard'\n    endpoint = 'https://{}'.format(host)\n    bucket = ''  # add a '/' before the bucket name to list buckets\n    object_key = ''\n    request_parameters = ''\n\n    # assemble the standardized request\n    time = datetime.now(timezone.utc)\n    timestamp = time.strftime('%Y%m%dT%H%M%SZ')\n    datestamp = time.strftime('%Y%m%d')\n\n    standardized_resource = '/' + bucket + '/' + object_key\n    standardized_querystring = request_parameters\n    standardized_headers = 'host:' + host + '\\n' + 'x-amz-date:' + timestamp + '\\n'\n    signed_headers = 'host;x-amz-date'\n    payload_hash = hashlib.sha256(b'').hexdigest()\n\n    standardized_request = (\n        http_method + '\\n'\n        + standardized_resource + '\\n'\n        + standardized_querystring + '\\n'\n        + standardized_headers + '\\n'\n        + signed_headers + '\\n'\n        + payload_hash\n    ).encode('utf-8')\n\n    # assemble string-to-sign\n    hashing_algorithm = 'AWS4-HMAC-SHA256'\n    credential_scope = datestamp + '/' + region + '/' + 's3' + '/' + 'aws4_request'\n    sts = (\n        hashing_algorithm + '\\n'\n        + timestamp + '\\n'\n        + credential_scope + '\\n'\n        + hashlib.sha256(standardized_request).hexdigest()\n    )\n\n    # generate the signature\n    signature_key = createSignatureKey(secret_key, datestamp, region, 's3')\n    signature = hmac.new(\n        signature_key,\n        (sts).encode('utf-8'),\n        hashlib.sha256,\n    ).hexdigest()\n\n    # assemble all elements into the 'authorization' header\n    v4auth_header = (\n        hashing_algorithm + ' '\n        + 'Credential=' + access_key + '/' + credential_scope + ', '\n        + 'SignedHeaders=' + signed_headers + ', '\n        + 'Signature=' + signature\n    )\n\n    # create and send the request\n    headers = {'x-amz-date': timestamp, 'Authorization': v4auth_header}\n    # the 'requests' package automatically adds the required 'host' header\n    request_url = endpoint + standardized_resource + standardized_querystring\n\n    request = requests.get(request_url, headers=headers)\n\n    return request",
          "hash_value": "eacda064a1840de0db258c3b81e78867",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def verify_ibm_cos_hmac_credentials(\n    access_key: str,\n    secret_key: str,\n    host: str = 's3.us.cloud-object-storage.appdomain.cloud',\n) -> bool:\n    response = query_ibm_cos_hmac(access_key, secret_key, host)\n    return response.status_code == 200\n\n# Helper function used:\ndef query_ibm_cos_hmac(\n    access_key: str,\n    secret_key: str,\n    host: str = 's3.us.cloud-object-storage.appdomain.cloud',\n) -> requests.Response:\n    # Sample code referenced from link below\n    # https://cloud.ibm.com/docs/services/cloud-object-storage/api-reference?topic=cloud-object-storage-hmac-signature  # noqa: E501\n\n    # request elements\n    http_method = 'GET'\n    # region is a wildcard value that takes the place of the AWS region value\n    # as COS doesn't use the same conventions for regions, this parameter can accept any string\n    region = 'us-standard'\n    endpoint = 'https://{}'.format(host)\n    bucket = ''  # add a '/' before the bucket name to list buckets\n    object_key = ''\n    request_parameters = ''\n\n    # assemble the standardized request\n    time = datetime.now(timezone.utc)\n    timestamp = time.strftime('%Y%m%dT%H%M%SZ')\n    datestamp = time.strftime('%Y%m%d')\n\n    standardized_resource = '/' + bucket + '/' + object_key\n    standardized_querystring = request_parameters\n    standardized_headers = 'host:' + host + '\\n' + 'x-amz-date:' + timestamp + '\\n'\n    signed_headers = 'host;x-amz-date'\n    payload_hash = hashlib.sha256(b'').hexdigest()\n\n    standardized_request = (\n        http_method + '\\n'\n        + standardized_resource + '\\n'\n        + standardized_querystring + '\\n'\n        + standardized_headers + '\\n'\n        + signed_headers + '\\n'\n        + payload_hash\n    ).encode('utf-8')\n\n    # assemble string-to-sign\n    hashing_algorithm = 'AWS4-HMAC-SHA256'\n    credential_scope = datestamp + '/' + region + '/' + 's3' + '/' + 'aws4_request'\n    sts = (\n        hashing_algorithm + '\\n'\n        + timestamp + '\\n'\n        + credential_scope + '\\n'\n        + hashlib.sha256(standardized_request).hexdigest()\n    )\n\n    # generate the signature\n    signature_key = createSignatureKey(secret_key, datestamp, region, 's3')\n    signature = hmac.new(\n        signature_key,\n        (sts).encode('utf-8'),\n        hashlib.sha256,\n    ).hexdigest()\n\n    # assemble all elements into the 'authorization' header\n    v4auth_header = (\n        hashing_algorithm + ' '\n        + 'Credential=' + access_key + '/' + credential_scope + ', '\n        + 'SignedHeaders=' + signed_headers + ', '\n        + 'Signature=' + signature\n    )\n\n    # create and send the request\n    headers = {'x-amz-date': timestamp, 'Authorization': v4auth_header}\n    # the 'requests' package automatically adds the required 'host' header\n    request_url = endpoint + standardized_resource + standardized_querystring\n\n    request = requests.get(request_url, headers=headers)\n\n    return request",
              "triple_sequences": [
                {
                  "action_api": "datetime.now()",
                  "action_description": "Returns current time",
                  "action_id": "get_current_time",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "time.strftime('%Y%m%dT%H%M%SZ')",
                  "action_description": "Parses string into datetime object",
                  "action_id": "parse_datetime",
                  "object": "%Y%m%dT%H%M%SZ",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "time.strftime('%Y%m%d')",
                  "action_description": "Parses string into datetime object",
                  "action_id": "parse_datetime",
                  "object": "%Y%m%d",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "hashlib.sha256(b'').hexdigest()",
                  "action_description": "Returns hexadecimal digest of SHA-256 hash",
                  "action_id": "get_sha256_digest",
                  "object": "b''",
                  "object_description": "Encoded string to bytes",
                  "object_id": "encoded_string_bytes",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "str.encode('utf-8')",
                  "action_description": "Encodes string to bytes using default encoding",
                  "action_id": "encode_string_to_bytes",
                  "object": "standardized_request",
                  "object_description": "Encoded string to bytes",
                  "object_id": "encoded_string_bytes",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "hashlib.sha256(standardized_request).hexdigest()",
                  "action_description": "Returns hexadecimal digest of SHA-256 hash",
                  "action_id": "get_sha256_digest",
                  "object": "standardized_request",
                  "object_description": "Encoded string to bytes",
                  "object_id": "encoded_string_bytes",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "createSignatureKey()",
                  "action_description": "Creates symmetric encryption key",
                  "action_id": "init_symmetric_encryption",
                  "object": "secret_key, datestamp, region, 's3'",
                  "object_description": "Hardcoded key",
                  "object_id": "hardcoded_key",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "hmac.new()",
                  "action_description": "Creates new hash object",
                  "action_id": "create_sha256_hash",
                  "object": "signature_key, (sts).encode('utf-8'), hashlib.sha256",
                  "object_description": "Hardcoded key",
                  "object_id": "hardcoded_key",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "hmac.new().hexdigest()",
                  "action_description": "Returns hexadecimal digest of SHA-256 hash",
                  "action_id": "get_sha256_digest",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP GET request to URL",
                  "action_id": "open_url_get",
                  "object": "request_url, headers=headers",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "response.status_code",
                  "action_description": "Retrieves HTTP response status code",
                  "action_id": "get_http_status",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "opendatasets-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/opendatasets-0.1.22.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "kaggle_api.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/opendatasets-0.1.22/opendatasets-0.1.22/opendatasets/utils/kaggle_api.py",
          "line_number": "45",
          "type_description": "shady-links",
          "context_snippet": "import os\nfrom opendatasets.utils.kaggle_direct import get_kaggle_dataset_id, is_kaggle_url\nfrom opendatasets.utils.archive import extract_archive\nimport click\nimport json\n\n\ndef download_kaggle_dataset(dataset_url, data_dir, force=False, dry_run=False):\n    dataset_id = get_kaggle_dataset_id(dataset_url)\n    id = dataset_id.split('/')[1]\n    target_dir = os.path.join(data_dir, id)\n\n    if not force and os.path.exists(target_dir) and len(os.listdir(target_dir)) > 0:\n        print('Skipping, found downloaded files in \"{}\" (use force=True to force download)'.format(\n            target_dir))\n        return\n\n    if not read_kaggle_creds():\n        print(\"Please provide your Kaggle credentials to download this dataset. Learn more: http://bit.ly/kaggle-creds\")\n        os.environ['KAGGLE_USERNAME'] = click.prompt(\"Your Kaggle username\")\n        os.environ['KAGGLE_KEY'] = _get_kaggle_key()\n\n    if not dry_run:\n        from kaggle import api\n        api.authenticate()\n        if dataset_id.split('/')[0] == 'competitions' or dataset_id.split('/')[0] == 'c':\n            api.competition_download_files(\n                id,\n                target_dir,\n                force=force,\n                quiet=False)\n            zip_fname = target_dir + '/' + id + '.zip'\n            extract_archive(zip_fname, target_dir)\n            try:\n                os.remove(zip_fname)\n            except OSError as e:\n                print('Could not delete zip file, got' + str(e))\n        else:\n            api.dataset_download_files(\n                dataset_id,\n                target_dir,\n                force=force,\n                quiet=False,\n                unzip=True)\n\n    else:\n        print(\"This is a dry run, skipping..\")",
          "hash_value": "9986b24d6e8e24168f4e2382ae1cff9f",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nfrom opendatasets.utils.kaggle_direct import get_kaggle_dataset_id, is_kaggle_url\nfrom opendatasets.utils.archive import extract_archive\nimport click\nimport json\n\n\ndef download_kaggle_dataset(dataset_url, data_dir, force=False, dry_run=False):\n    dataset_id = get_kaggle_dataset_id(dataset_url)\n    id = dataset_id.split('/')[1]\n    target_dir = os.path.join(data_dir, id)\n\n    if not force and os.path.exists(target_dir) and len(os.listdir(target_dir)) > 0:\n        print('Skipping, found downloaded files in \"{}\" (use force=True to force download)'.format(\n            target_dir))\n        return\n\n    if not read_kaggle_creds():\n        print(\"Please provide your Kaggle credentials to download this dataset. Learn more: http://bit.ly/kaggle-creds\")\n        os.environ['KAGGLE_USERNAME'] = click.prompt(\"Your Kaggle username\")\n        os.environ['KAGGLE_KEY'] = _get_kaggle_key()\n\n    if not dry_run:\n        from kaggle import api\n        api.authenticate()\n        if dataset_id.split('/')[0] == 'competitions' or dataset_id.split('/')[0] == 'c':\n            api.competition_download_files(\n                id,\n                target_dir,\n                force=force,\n                quiet=False)\n            zip_fname = target_dir + '/' + id + '.zip'\n            extract_archive(zip_fname, target_dir)\n            try:\n                os.remove(zip_fname)\n            except OSError as e:\n                print('Could not delete zip file, got' + str(e))\n        else:\n            api.dataset_download_files(\n                dataset_id,\n                target_dir,\n                force=force,\n                quiet=False,\n                unzip=True)\n\n    else:\n        print(\"This is a dry run, skipping..\")",
              "triple_sequences": [
                {
                  "action_api": "get_kaggle_dataset_id()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "dataset_url",
                  "object_description": "URL string",
                  "object_id": "url_string",
                  "intention_description": "Prepare path for browser data access",
                  "intention_id": "prepare_path_browser_data"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "dataset_id",
                  "object_description": "String containing environment data",
                  "object_id": "string_environment_data",
                  "intention_description": "Prepare path for browser data access",
                  "intention_id": "prepare_path_browser_data"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "data_dir, id",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "target_dir",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "os.listdir()",
                  "action_description": "List directory contents",
                  "action_id": "list_directory_contents",
                  "object": "target_dir",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "List files in directory",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "read_kaggle_creds()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "click.prompt()",
                  "action_description": "Reads user input from standard input",
                  "action_id": "read_user_input",
                  "object": "\"Your Kaggle username\"",
                  "object_description": "Username string",
                  "object_id": "username_string",
                  "intention_description": "Collect user input",
                  "intention_id": "collect_user_input"
                },
                {
                  "action_api": "_get_kaggle_key()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "api.authenticate()",
                  "action_description": "Establishes connection",
                  "action_id": "establish_connection",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Establish connection",
                  "intention_id": "establish_connection"
                },
                {
                  "action_api": "api.competition_download_files()",
                  "action_description": "Downloads file from URL to local path",
                  "action_id": "download_file_url",
                  "object": "id, target_dir, force=force, quiet=False",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "extract_archive()",
                  "action_description": "Extracts all files from ZIP archive to specified directory",
                  "action_id": "extract_zip_files",
                  "object": "zip_fname, target_dir",
                  "object_description": "ZIP archive file",
                  "object_id": "zip_archive",
                  "intention_description": "Decompress downloaded archive",
                  "intention_id": "decompress_downloaded_archive"
                },
                {
                  "action_api": "os.remove()",
                  "action_description": "Deletes specified file from filesystem",
                  "action_id": "delete_file",
                  "object": "zip_fname",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Delete file",
                  "intention_id": "delete_file"
                },
                {
                  "action_api": "api.dataset_download_files()",
                  "action_description": "Downloads file from URL to local path",
                  "action_id": "download_file_url",
                  "object": "dataset_id, target_dir, force=force, quiet=False, unzip=True",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "isal-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/isal-1.7.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/isal-1.7.2/isal-1.7.2/setup.py",
          "line_number": "125",
          "type_description": "code-execution",
          "context_snippet": "import functools\nimport os\nimport platform\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\nfrom pathlib import Path\n\nISA_L_SOURCE = os.path.join(\"src\", \"isal\", \"isa-l\")\nSYSTEM_IS_BSD = (sys.platform.startswith(\"freebsd\") or\n                 sys.platform.startswith(\"netbsd\"))\nSYSTEM_IS_UNIX = (sys.platform.startswith(\"linux\") or\n                  sys.platform.startswith(\"darwin\") or\n                  sys.platform.startswith(\"gnu\") or\n                  SYSTEM_IS_BSD)\nSYSTEM_IS_WINDOWS = sys.platform.startswith(\"win\")\n\n@functools.lru_cache(maxsize=None)\ndef build_isa_l():\n    # Check for cache\n    if BUILD_CACHE:\n        if BUILD_CACHE_FILE.exists():\n            cache_path = Path(BUILD_CACHE_FILE.read_text())\n            if (cache_path / \"isa-l.h\").exists():\n                return str(cache_path)\n\n    # Creating temporary directories\n    build_dir = tempfile.mktemp()\n    shutil.copytree(ISA_L_SOURCE, build_dir)\n\n    # Build environment is a copy of OS environment to allow user to influence\n    # it.\n    build_env = os.environ.copy()\n    if SYSTEM_IS_UNIX:\n        build_env[\"CFLAGS\"] = build_env.get(\"CFLAGS\", \"\") + \" -fPIC\"\n    if hasattr(os, \"sched_getaffinity\"):\n        cpu_count = len(os.sched_getaffinity(0))\n    else:  # sched_getaffinity not available on all platforms\n        cpu_count = os.cpu_count() or 1  # os.cpu_count() can return None\n    run_args = dict(cwd=build_dir, env=build_env)\n    if SYSTEM_IS_UNIX:\n        if platform.machine() == \"aarch64\":\n            cflags_param = \"CFLAGS_aarch64\"\n        else:\n            cflags_param = \"CFLAGS_\"\n        make_cmd = \"make\"\n        if SYSTEM_IS_BSD:\n            make_cmd = \"gmake\"\n        subprocess.run([make_cmd, \"-j\", str(cpu_count), \"-f\", \"Makefile.unx\",\n                        \"isa-l.h\", \"bin/isa-l.a\",\n                        f\"{cflags_param}={build_env.get('CFLAGS', '')}\"],\n                       **run_args)\n    elif SYSTEM_IS_WINDOWS:\n        subprocess.run([\"nmake\", \"/f\", \"Makefile.nmake\"], **run_args)\n    else:\n        raise NotImplementedError(f\"Unsupported platform: {sys.platform}\")\n    shutil.copytree(os.path.join(build_dir, \"include\"),\n                    os.path.join(build_dir, \"isa-l\"))\n    if BUILD_CACHE:\n        BUILD_CACHE_FILE.write_text(build_dir)\n    return build_dir",
          "hash_value": "3fb370138339ead8ef654c35e12cff89",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import functools\nimport os\nimport platform\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\nfrom pathlib import Path\n\nISA_L_SOURCE = os.path.join(\"src\", \"isal\", \"isa-l\")\nSYSTEM_IS_BSD = (sys.platform.startswith(\"freebsd\") or\n                 sys.platform.startswith(\"netbsd\"))\nSYSTEM_IS_UNIX = (sys.platform.startswith(\"linux\") or\n                  sys.platform.startswith(\"darwin\") or\n                  sys.platform.startswith(\"gnu\") or\n                  SYSTEM_IS_BSD)\nSYSTEM_IS_WINDOWS = sys.platform.startswith(\"win\")\n\n@functools.lru_cache(maxsize=None)\ndef build_isa_l():\n    # Check for cache\n    if BUILD_CACHE:\n        if BUILD_CACHE_FILE.exists():\n            cache_path = Path(BUILD_CACHE_FILE.read_text())\n            if (cache_path / \"isa-l.h\").exists():\n                return str(cache_path)\n\n    # Creating temporary directories\n    build_dir = tempfile.mktemp()\n    shutil.copytree(ISA_L_SOURCE, build_dir)\n\n    # Build environment is a copy of OS environment to allow user to influence\n    # it.\n    build_env = os.environ.copy()\n    if SYSTEM_IS_UNIX:\n        build_env[\"CFLAGS\"] = build_env.get(\"CFLAGS\", \"\") + \" -fPIC\"\n    if hasattr(os, \"sched_getaffinity\"):\n        cpu_count = len(os.sched_getaffinity(0))\n    else:  # sched_getaffinity not available on all platforms\n        cpu_count = os.cpu_count() or 1  # os.cpu_count() can return None\n    run_args = dict(cwd=build_dir, env=build_env)\n    if SYSTEM_IS_UNIX:\n        if platform.machine() == \"aarch64\":\n            cflags_param = \"CFLAGS_aarch64\"\n        else:\n            cflags_param = \"CFLAGS_\"\n        make_cmd = \"make\"\n        if SYSTEM_IS_BSD:\n            make_cmd = \"gmake\"\n        subprocess.run([make_cmd, \"-j\", str(cpu_count), \"-f\", \"Makefile.unx\",\n                        \"isa-l.h\", \"bin/isa-l.a\",\n                        f\"{cflags_param}={build_env.get('CFLAGS', '')}\"],\n                       **run_args)\n    elif SYSTEM_IS_WINDOWS:\n        subprocess.run([\"nmake\", \"/f\", \"Makefile.nmake\"], **run_args)\n    else:\n        raise NotImplementedError(f\"Unsupported platform: {sys.platform}\")\n    shutil.copytree(os.path.join(build_dir, \"include\"),\n                    os.path.join(build_dir, \"isa-l\"))\n    if BUILD_CACHE:\n        BUILD_CACHE_FILE.write_text(build_dir)\n    return build_dir",
              "triple_sequences": [
                {
                  "action_api": "Path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "BUILD_CACHE_FILE",
                  "object_description": "Local file",
                  "object_id": "local_file",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "Path.read_text()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "BUILD_CACHE_FILE",
                  "object_description": "Local file",
                  "object_id": "local_file",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "Path()",
                  "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
                  "action_id": "path_object_operations",
                  "object": "Path(BUILD_CACHE_FILE.read_text())",
                  "object_description": "Local file",
                  "object_id": "local_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "Path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "cache_path / \"isa-l.h\"",
                  "object_description": "Directory path with file",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Determine presence of file",
                  "intention_id": "determine_file_presence"
                },
                {
                  "action_api": "tempfile.mktemp()",
                  "action_description": "Creates temporary file that is not deleted on close",
                  "action_id": "create_temp_file",
                  "object": "",
                  "object_description": "Temporary file path",
                  "object_id": "temporary_file_path",
                  "intention_description": "Create temporary file",
                  "intention_id": "create_temporary_file"
                },
                {
                  "action_api": "shutil.copytree()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "ISA_L_SOURCE, build_dir",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Copy file to temporary directory",
                  "intention_id": "copy_file_temp_directory"
                },
                {
                  "action_api": "os.environ.copy()",
                  "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
                  "action_id": "path_object_operations",
                  "object": "os.environ",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.sched_getaffinity()",
                  "action_description": "Retrieves operating system information",
                  "action_id": "get_os_info",
                  "object": "0",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get system info",
                  "intention_id": "get_system_info"
                },
                {
                  "action_api": "os.cpu_count()",
                  "action_description": "Retrieves operating system information",
                  "action_id": "get_os_info",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get system info",
                  "intention_id": "get_system_info"
                },
                {
                  "action_api": "platform.machine()",
                  "action_description": "Retrieves machine type",
                  "action_id": "get_machine_type",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get system info",
                  "intention_id": "get_system_info"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[make_cmd, \"-j\", str(cpu_count), \"-f\", \"Makefile.unx\", \"isa-l.h\", \"bin/isa-l.a\", f\"{cflags_param}={build_env.get('CFLAGS', '')}\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"nmake\", \"/f\", \"Makefile.nmake\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "shutil.copytree()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "os.path.join(build_dir, \"include\"), os.path.join(build_dir, \"isa-l\")",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Copy file to temporary directory",
                  "intention_id": "copy_file_temp_directory"
                },
                {
                  "action_api": "Path.write_text()",
                  "action_description": "File opening operations for writing (normal writing, binary writing)",
                  "action_id": "basic_write_operations",
                  "object": "build_dir",
                  "object_description": "Temporary directory",
                  "object_id": "temporary_directory",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "tiledbsoma-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/tiledbsoma-1.16.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/tiledbsoma-1.16.1/tiledbsoma-1.16.1/setup.py",
          "line_number": "188",
          "type_description": "code-execution",
          "context_snippet": "import shutil\nimport subprocess\nimport sys\n\n# ... (other code and imports)\n\ndef find_or_build_package_data(setuptools_cmd):\n    # check if libtiledbsoma is installed\n    lib_dir = libtiledbsoma_exists()\n\n    # if not then build from source\n    if lib_dir is None:\n        # Note: The GitHub build process uses the contents of `bld` as a key\n        # to cache the native binaries. Using non-default options here will\n        # cause that cache to fall out of sync.\n        #\n        # See `.github/workflows/python-ci-single.yml` for configuration.\n        if os.name == \"nt\":\n            bld_command = [\"pwsh.exe\", \"./bld.ps1\"]\n            if tiledb_dir is not None:\n                bld_command.append(f\"TileDBLocation={tiledb_dir}\")\n            if no_tiledb_dep:\n                bld_command.append(\"RemoveTileDBDeprecated=ON\")\n\n        else:\n            bld_command = [\"./bld\"]\n            if tiledb_dir is not None:\n                bld_command.append(f\"--tiledb={tiledb_dir}\")\n            if no_tiledb_dep:\n                bld_command.append(\"--no-tiledb-deprecated=true\")\n\n        subprocess.run(bld_command, cwd=scripts_dir, check=True)\n\n        lib_dir = libtiledbsoma_exists()\n        assert lib_dir, \"error when building libtiledbsoma from source\"\n\n        # If we are building from source, then we are likely building wheels.\n        # Copy both the tiledbsoma and tiledb shared objects into the\n        # package dir so they can be found by package_data\n        package_data = []\n        src_dir = this_dir / \"src\" / \"tiledbsoma\"\n        for f in lib_dir.glob(\"*tiledbsoma.*\"):\n            if f.suffix != \".a\":  # skip static library\n                print(f\"  copying file {f} to {src_dir}\")\n                shutil.copy(f, src_dir)\n                package_data.append(f.name)\n        assert package_data, f\"tiledbsoma artifacts absent from {lib_dir}\"\n\n        if not tiledb_given:\n            for f in lib_dir.glob(\"*tiledb.*\"):\n                if f.suffix != \".a\":  # skip static library\n                    print(f\"  copying file {f} to {src_dir}\")\n                    shutil.copy(f, src_dir)\n                    package_data.append(f.name)\n                assert package_data, f\"tiledb artifacts absent from {lib_dir}\"\n\n        # Install shared libraries inside the Python module via package_data.\n        print(f\"  adding to package_data: {package_data}\")\n        setuptools_cmd.distribution.package_data[\"tiledbsoma\"] = package_data\n",
          "hash_value": "3544854386149a078694c21f29808228",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import shutil\nimport subprocess\nimport sys\n\n# ... (other code and imports)\n\ndef find_or_build_package_data(setuptools_cmd):\n    # check if libtiledbsoma is installed\n    lib_dir = libtiledbsoma_exists()\n\n    # if not then build from source\n    if lib_dir is None:\n        # Note: The GitHub build process uses the contents of `bld` as a key\n        # to cache the native binaries. Using non-default options here will\n        # cause that cache to fall out of sync.\n        #\n        # See `.github/workflows/python-ci-single.yml` for configuration.\n        if os.name == \"nt\":\n            bld_command = [\"pwsh.exe\", \"./bld.ps1\"]\n            if tiledb_dir is not None:\n                bld_command.append(f\"TileDBLocation={tiledb_dir}\")\n            if no_tiledb_dep:\n                bld_command.append(\"RemoveTileDBDeprecated=ON\")\n\n        else:\n            bld_command = [\"./bld\"]\n            if tiledb_dir is not None:\n                bld_command.append(f\"--tiledb={tiledb_dir}\")\n            if no_tiledb_dep:\n                bld_command.append(\"--no-tiledb-deprecated=true\")\n\n        subprocess.run(bld_command, cwd=scripts_dir, check=True)\n\n        lib_dir = libtiledbsoma_exists()\n        assert lib_dir, \"error when building libtiledbsoma from source\"\n\n        # If we are building from source, then we are likely building wheels.\n        # Copy both the tiledbsoma and tiledb shared objects into the\n        # package dir so they can be found by package_data\n        package_data = []\n        src_dir = this_dir / \"src\" / \"tiledbsoma\"\n        for f in lib_dir.glob(\"*tiledbsoma.*\"):\n            if f.suffix != \".a\":  # skip static library\n                print(f\"  copying file {f} to {src_dir}\")\n                shutil.copy(f, src_dir)\n                package_data.append(f.name)\n        assert package_data, f\"tiledbsoma artifacts absent from {lib_dir}\"\n\n        if not tiledb_given:\n            for f in lib_dir.glob(\"*tiledb.*\"):\n                if f.suffix != \".a\":  # skip static library\n                    print(f\"  copying file {f} to {src_dir}\")\n                    shutil.copy(f, src_dir)\n                    package_data.append(f.name)\n                assert package_data, f\"tiledb artifacts absent from {lib_dir}\"\n\n        # Install shared libraries inside the Python module via package_data.\n        print(f\"  adding to package_data: {package_data}\")\n        setuptools_cmd.distribution.package_data[\"tiledbsoma\"] = package_data\n",
              "triple_sequences": [
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "bld_command",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "shutil.copy()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "f, src_dir",
                  "object_description": "Local file or directory",
                  "object_id": "local_file_or_directory",
                  "intention_description": "Copy file to temporary directory",
                  "intention_id": "copy_file_temp_directory"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "delocate-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/delocate-0.13.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/delocate-0.13.0/delocate-0.13.0/wheel_makers/fakepkg1/setup.py",
          "line_number": "19",
          "type_description": "code-execution",
          "context_snippet": "from os.path import abspath, dirname\nfrom os.path import join as pjoin\nfrom subprocess import check_call\n\nHERE = abspath(dirname(__file__))\nLIBS = pjoin(HERE, \"libs\")\nEXTLIB = pjoin(LIBS, \"libextfunc.dylib\")\n\n# Compile external extension with absolute path in install id\narch_flags = [\"-arch\", \"arm64\", \"-arch\", \"x86_64\"]  # dual arch\ncheck_call(\n    [\"cc\", \"-dynamiclib\", pjoin(LIBS, \"extfunc.c\"), \"-o\", EXTLIB] + arch_flags\n)",
          "hash_value": "df1b47cd080c9652fc66415d0109d1b8",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from os.path import abspath, dirname\nfrom os.path import join as pjoin\nfrom subprocess import check_call\n\nHERE = abspath(dirname(__file__))\nLIBS = pjoin(HERE, \"libs\")\nEXTLIB = pjoin(LIBS, \"libextfunc.dylib\")\n\n# Compile external extension with absolute path in install id\narch_flags = [\"-arch\", \"arm64\", \"-arch\", \"x86_64\"]  # dual arch\ncheck_call(\n    [\"cc\", \"-dynamiclib\", pjoin(LIBS, \"extfunc.c\"), \"-o\", EXTLIB] + arch_flags\n)",
              "triple_sequences": [
                {
                  "action_api": "abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "dirname(__file__)",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Get script file path",
                  "intention_id": "get_script_file_path"
                },
                {
                  "action_api": "pjoin()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "HERE, \"libs\"",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "pjoin()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "LIBS, \"libextfunc.dylib\"",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "pjoin()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "LIBS, \"extfunc.c\"",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"cc\", \"-dynamiclib\", pjoin(LIBS, \"extfunc.c\"), \"-o\", EXTLIB] + arch_flags",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "spyder_kernels-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/spyder_kernels-3.1.0a1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "commbase.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/spyder_kernels-3.1.0a1/spyder_kernels-3.1.0a1/spyder_kernels/comms/commbase.py",
          "line_number": "121",
          "type_description": "obfuscation",
          "context_snippet": "import builtins\n\nclass CommsErrorWrapper():\n    def __init__(self, call_name, call_id):\n        self.call_name = call_name\n        self.call_id = call_id\n        self.etype, self.error, tb = sys.exc_info()\n        self.tb = traceback.extract_tb(tb)\n\n    def to_json(self):\n        \"\"\"Create JSON representation.\"\"\"\n        return {\n            \"call_name\": self.call_name,\n            \"call_id\": self.call_id,\n            \"etype\": self.etype.__name__,\n            \"args\": self.error.args,\n            \"tb\": stacksummary_to_json(self.tb)\n        }\n\n    @classmethod\n    def from_json(cls, json_data):\n        \"\"\"Get a CommsErrorWrapper from a JSON representation.\"\"\"\n        instance = cls.__new__(cls)\n        instance.call_name = json_data[\"call_name\"]\n        instance.call_id = json_data[\"call_id\"]\n        etype = json_data[\"etype\"]\n        instance.etype = getattr(\n            builtins,\n            etype,\n            type(etype, (Exception,), {})\n        )\n        instance.error = instance.etype(*json_data[\"args\"])\n        instance.tb = staksummary_from_json(json_data[\"tb\"])\n        return instance",
          "hash_value": "d37a492939f0b0aa86d138dac2609e2e",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import builtins\n\nclass CommsErrorWrapper():\n    def __init__(self, call_name, call_id):\n        self.call_name = call_name\n        self.call_id = call_id\n        self.etype, self.error, tb = sys.exc_info()\n        self.tb = traceback.extract_tb(tb)\n\n    def to_json(self):\n        \"\"\"Create JSON representation.\"\"\"\n        return {\n            \"call_name\": self.call_name,\n            \"call_id\": self.call_id,\n            \"etype\": self.etype.__name__,\n            \"args\": self.error.args,\n            \"tb\": stacksummary_to_json(self.tb)\n        }\n\n    @classmethod\n    def from_json(cls, json_data):\n        \"\"\"Get a CommsErrorWrapper from a JSON representation.\"\"\"\n        instance = cls.__new__(cls)\n        instance.call_name = json_data[\"call_name\"]\n        instance.call_id = json_data[\"call_id\"]\n        etype = json_data[\"etype\"]\n        instance.etype = getattr(\n            builtins,\n            etype,\n            type(etype, (Exception,), {})\n        )\n        instance.error = instance.etype(*json_data[\"args\"])\n        instance.tb = staksummary_from_json(json_data[\"tb\"])\n        return instance",
              "triple_sequences": [
                {
                  "action_api": "sys.exc_info()",
                  "action_description": "Extracts current call stack as FrameSummary objects",
                  "action_id": "extract_call_stack",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "traceback.extract_tb()",
                  "action_description": "Extracts current call stack as FrameSummary objects",
                  "action_id": "extract_call_stack",
                  "object": "tb",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "stacksummary_to_json()",
                  "action_description": "Serializes Python object to JSON string",
                  "action_id": "serialize_to_json",
                  "object": "self.tb",
                  "object_description": "Character code array",
                  "object_id": "character_code_array",
                  "intention_description": "Serialize data",
                  "intention_id": "serialize_data"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, etype, type(etype, (Exception,), {})",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "instance.etype(*json_data[\"args\"])",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "json_data[\"args\"]",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "staksummary_from_json()",
                  "action_description": "Deserializes JSON string to Python object",
                  "action_id": "deserialize_from_json",
                  "object": "json_data[\"tb\"]",
                  "object_description": "JSON string",
                  "object_id": "json_string",
                  "intention_description": "Deserialize data",
                  "intention_id": "serialize_data"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "ruamel",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/ruamel.ordereddict-0.4.15.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ruamel.ordereddict-0.4.15/ruamel.ordereddict-0.4.15/setup.py",
          "line_number": "130",
          "type_description": "cmd-overwrite",
          "context_snippet": "def main():\n    install_requires = []\n    packages = [full_package_name] + [(full_package_name + '.' + x) for x\n                                     in find_packages(exclude=['tests'])]\n\n    setup(\n        name=full_package_name,\n        version=version_str,\n        description='a version of dict that keeps keys in '\\\n                    'insertion resp. sorted order',\n        install_requires=install_requires,\n        long_description=open('README.rst').read(),\n        url='https://bitbucket.org/ruamel/' + package_name,\n        author='Anthon van der Neut',\n        author_email='a.van.der.neut@ruamel.eu',\n        license=\"MIT license\",\n        package_dir={full_package_name: '.'},\n        namespace_packages=[name_space],\n        packages=packages,\n        ext_modules = [module1],\n        cmdclass={'install_lib': MyInstallLib},\n        classifiers=[\n            'Development Status :: 5 - Production/Stable',\n            'Intended Audience :: System Administrators',\n            'License :: OSI Approved :: MIT License',\n            'Operating System :: POSIX :: Linux',\n            'Programming Language :: Python',\n        ],\n    )\n\n# Data dependencies:\n# - setup: imported from setuptools\n# - full_package_name: defined as name_space + '.' + package_name\n# - version_str: set by _check_convert_version(version_info), which uses get_version()\n# - install_requires: local empty list\n# - open('README.rst').read(): reads README.rst file\n# - package_name: 'ordereddict'\n# - name_space: 'ruamel'\n# - module1: Extension('_ordereddict', ...)\n# - MyInstallLib: class defined above\n# - find_packages: imported from setuptools\n",
          "hash_value": "e1f5cacbaaa9b57d3a944c7e2e7a9ab3",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def main():\n    install_requires = []\n    packages = [full_package_name] + [(full_package_name + '.' + x) for x\n                                     in find_packages(exclude=['tests'])]\n\n    setup(\n        name=full_package_name,\n        version=version_str,\n        description='a version of dict that keeps keys in '\\\n                    'insertion resp. sorted order',\n        install_requires=install_requires,\n        long_description=open('README.rst').read(),\n        url='https://bitbucket.org/ruamel/' + package_name,\n        author='Anthon van der Neut',\n        author_email='a.van.der.neut@ruamel.eu',\n        license=\"MIT license\",\n        package_dir={full_package_name: '.'},\n        namespace_packages=[name_space],\n        packages=packages,\n        ext_modules = [module1],\n        cmdclass={'install_lib': MyInstallLib},\n        classifiers=[\n            'Development Status :: 5 - Production/Stable',\n            'Intended Audience :: System Administrators',\n            'License :: OSI Approved :: MIT License',\n            'Operating System :: POSIX :: Linux',\n            'Programming Language :: Python',\n        ],\n    )\n\n# Data dependencies:\n# - setup: imported from setuptools\n# - full_package_name: defined as name_space + '.' + package_name\n# - version_str: set by _check_convert_version(version_info), which uses get_version()\n# - install_requires: local empty list\n# - open('README.rst').read(): reads README.rst file\n# - package_name: 'ordereddict'\n# - name_space: 'ruamel'\n# - module1: Extension('_ordereddict', ...)\n# - MyInstallLib: class defined above\n# - find_packages: imported from setuptools\n",
              "triple_sequences": [
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "README.rst",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "{name: full_package_name, version: version_str, ...}",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "blake3-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/blake3-1.0.4.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/blake3-1.0.4/blake3-1.0.4/c_impl/setup.py",
          "line_number": "194",
          "type_description": "code-execution",
          "context_snippet": "def compile_windows_msvc_asm():\n    ml64 = windows_ml64_path()\n    object_files = []\n    for filepath in windows_msvc_asm_files:\n        obj_path = path.splitext(filepath)[0] + \".obj\"\n        cmd = [ml64, \"/Fo\", obj_path, \"/c\", filepath]\n        print(\" \".join(cmd))\n        subprocess.run(cmd, check=True)\n        object_files.append(obj_path)\n    return object_files\n\nwindows_msvc_asm_files = [\n    \"vendor/blake3_sse2_x86-64_windows_msvc.asm\",\n    \"vendor/blake3_sse41_x86-64_windows_msvc.asm\",\n    \"vendor/blake3_avx2_x86-64_windows_msvc.asm\",\n    \"vendor/blake3_avx512_x86-64_windows_msvc.asm\",\n]\ndef windows_ml64_path():\n    vswhere_path = (\n        r\"C:\\Program Files (x86)\\Microsoft Visual Studio\\Installer\\vswhere.exe\"\n    )\n    if not path.exists(vswhere_path):\n        raise RuntimeError(vswhere_path + \" doesn't exist.\")\n    vswhere_cmd = [\n        vswhere_path,\n        \"-latest\",\n        \"-requires\",\n        \"Microsoft.VisualStudio.Component.VC.Tools.x86.x64\",\n        \"-products\",\n        \"*\",\n        \"-find\",\n        r\"**\\Hostx64\\x64\\ml64.exe\",\n    ]\n    result = subprocess.run(vswhere_cmd, check=True, stdout=subprocess.PIPE, text=True)\n    vswhere_output = result.stdout.strip()\n    if not result.stdout:\n        raise RuntimeError(\"vswhere.exe didn't output a path\")\n    ml64_path = vswhere_output.splitlines()[-1]\n    if not path.exists(ml64_path):\n        raise RuntimeError(ml64_path + \" doesn't exist\")\n    return ml64_path\n\nimport subprocess\nfrom os import path",
          "hash_value": "c31da9081990a0379967caab7eb2de13",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def compile_windows_msvc_asm():\n    ml64 = windows_ml64_path()\n    object_files = []\n    for filepath in windows_msvc_asm_files:\n        obj_path = path.splitext(filepath)[0] + \".obj\"\n        cmd = [ml64, \"/Fo\", obj_path, \"/c\", filepath]\n        print(\" \".join(cmd))\n        subprocess.run(cmd, check=True)\n        object_files.append(obj_path)\n    return object_files\n\nwindows_msvc_asm_files = [\n    \"vendor/blake3_sse2_x86-64_windows_msvc.asm\",\n    \"vendor/blake3_sse41_x86-64_windows_msvc.asm\",\n    \"vendor/blake3_avx2_x86-64_windows_msvc.asm\",\n    \"vendor/blake3_avx512_x86-64_windows_msvc.asm\",\n]\ndef windows_ml64_path():\n    vswhere_path = (\n        r\"C:\\Program Files (x86)\\Microsoft Visual Studio\\Installer\\vswhere.exe\"\n    )\n    if not path.exists(vswhere_path):\n        raise RuntimeError(vswhere_path + \" doesn't exist.\")\n    vswhere_cmd = [\n        vswhere_path,\n        \"-latest\",\n        \"-requires\",\n        \"Microsoft.VisualStudio.Component.VC.Tools.x86.x64\",\n        \"-products\",\n        \"*\",\n        \"-find\",\n        r\"**\\Hostx64\\x64\\ml64.exe\",\n    ]\n    result = subprocess.run(vswhere_cmd, check=True, stdout=subprocess.PIPE, text=True)\n    vswhere_output = result.stdout.strip()\n    if not result.stdout:\n        raise RuntimeError(\"vswhere.exe didn't output a path\")\n    ml64_path = vswhere_output.splitlines()[-1]\n    if not path.exists(ml64_path):\n        raise RuntimeError(ml64_path + \" doesn't exist\")\n    return ml64_path\n\nimport subprocess\nfrom os import path",
              "triple_sequences": [
                {
                  "action_api": "path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "C:\\Program Files (x86)\\Microsoft Visual Studio\\Installer\\vswhere.exe",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[C:\\Program Files (x86)\\Microsoft Visual Studio\\Installer\\vswhere.exe, -latest, -requires, Microsoft.VisualStudio.Component.VC.Tools.x86.x64, -products, *, -find, **\\Hostx64\\x64\\ml64.exe]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "str.strip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "result.stdout",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "str.splitlines()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "vswhere_output",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "ml64_path",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "path.splitext()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "filepath",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[ml64, /Fo, obj_path, /c, filepath]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pygit2-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pygit2-1.17.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pygit2-1.17.0/pygit2-1.17.0/setup.py",
          "line_number": "49",
          "type_description": "code-execution",
          "context_snippet": "from subprocess import Popen, PIPE\nimport sys\n\nclass sdist_files_from_git(sdist):\n    def get_file_list(self):\n        popen = Popen(\n            ['git', 'ls-files'], stdout=PIPE, stderr=PIPE, universal_newlines=True\n        )\n        stdoutdata, stderrdata = popen.communicate()\n        if popen.returncode != 0:\n            print(stderrdata)\n            sys.exit()\n\n        def exclude(line):\n            for prefix in ['.', 'appveyor.yml', 'docs/', 'misc/']:\n                if line.startswith(prefix):\n                    return True\n            return False\n\n        for line in stdoutdata.splitlines():\n            if not exclude(line):\n                self.filelist.append(line)\n\n        # Ok\n        self.filelist.sort()\n        self.filelist.remove_duplicates()\n        self.write_manifest()",
          "hash_value": "0cee34e93cda86376b929a71b68c83a5",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from subprocess import Popen, PIPE\nimport sys\n\nclass sdist_files_from_git(sdist):\n    def get_file_list(self):\n        popen = Popen(\n            ['git', 'ls-files'], stdout=PIPE, stderr=PIPE, universal_newlines=True\n        )\n        stdoutdata, stderrdata = popen.communicate()\n        if popen.returncode != 0:\n            print(stderrdata)\n            sys.exit()\n\n        def exclude(line):\n            for prefix in ['.', 'appveyor.yml', 'docs/', 'misc/']:\n                if line.startswith(prefix):\n                    return True\n            return False\n\n        for line in stdoutdata.splitlines():\n            if not exclude(line):\n                self.filelist.append(line)\n\n        # Ok\n        self.filelist.sort()\n        self.filelist.remove_duplicates()\n        self.write_manifest()",
              "triple_sequences": [
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "['git', 'ls-files']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Create child process",
                  "intention_id": "create_child_process"
                },
                {
                  "action_api": "popen.communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "print()",
                  "action_description": "Retrieves standard output stream object",
                  "action_id": "get_stdout_stream",
                  "object": "stderrdata",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                },
                {
                  "action_api": "str.splitlines()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "stdoutdata",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "self.filelist.append()",
                  "action_description": "Basic write operations (normal writing, binary writing)",
                  "action_id": "basic_write_operations",
                  "object": "line",
                  "object_description": "Local file or directory name",
                  "object_id": "local_file_or_directory_name",
                  "intention_description": "Prepare file for temporary storage",
                  "intention_id": "prepare_file_temp_storage"
                },
                {
                  "action_api": "self.filelist.sort()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "self.filelist.remove_duplicates()",
                  "action_description": "Basic write operations (normal writing, binary writing)",
                  "action_id": "basic_write_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare file for temporary storage",
                  "intention_id": "prepare_file_temp_storage"
                },
                {
                  "action_api": "self.write_manifest()",
                  "action_description": "Basic write operations (normal writing, binary writing)",
                  "action_id": "basic_write_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pynacl-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pynacl-1.5.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pynacl-1.5.0/PyNaCl-1.5.0/setup.py",
          "line_number": "160",
          "type_description": "code-execution",
          "context_snippet": "import errno\nimport functools\nimport glob\nimport os\nimport os.path\nimport platform\nimport shutil\nimport subprocess\nimport sys\nfrom sysconfig import get_config_vars\n\nclass build_clib(_build_clib):\n    def run(self):\n        if use_system():\n            return\n\n        # use Python's build environment variables\n        build_env = {\n            key: val\n            for key, val in get_config_vars().items()\n            if key in (\"LDFLAGS\", \"CFLAGS\", \"CC\", \"CCSHARED\", \"LDSHARED\")\n            and key not in os.environ\n        }\n        os.environ.update(build_env)\n\n        # Ensure our temporary build directory exists\n        build_temp = os.path.abspath(self.build_temp)\n        try:\n            os.makedirs(build_temp)\n        except OSError as e:\n            if e.errno != errno.EEXIST:\n                raise\n\n        # Ensure all of our executable files have their permission set\n        for filename in [\n            \"src/libsodium/autogen.sh\",\n            \"src/libsodium/compile\",\n            \"src/libsodium/configure\",\n            \"src/libsodium/depcomp\",\n            \"src/libsodium/install-sh\",\n            \"src/libsodium/missing\",\n            \"src/libsodium/msvc-scripts/process.bat\",\n            \"src/libsodium/test/default/wintest.bat\",\n        ]:\n            os.chmod(here(filename), 0o755)\n\n        if not shutil.which(\"make\"):\n            raise Exception(\"ERROR: The 'make' utility is missing from PATH\")\n\n        # Locate our configure script\n        configure = abshere(\"src/libsodium/configure\")\n\n        # Run ./configure\n        configure_flags = [\n            \"--disable-shared\",\n            \"--enable-static\",\n            \"--disable-debug\",\n            \"--disable-dependency-tracking\",\n            \"--with-pic\",\n        ]\n        if platform.system() == \"SunOS\":\n            # On Solaris, libssp doesn't link statically and causes linker\n            # errors during import\n            configure_flags.append(\"--disable-ssp\")\n        if os.environ.get(\"SODIUM_INSTALL_MINIMAL\"):\n            configure_flags.append(\"--enable-minimal\")\n        subprocess.check_call(\n            [configure]\n            + configure_flags\n            + [\"--prefix\", os.path.abspath(self.build_clib)],\n            cwd=build_temp,\n        )",
          "hash_value": "160e6f7b0d8be20d7f2cda25f3e2ed36",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import errno\nimport functools\nimport glob\nimport os\nimport os.path\nimport platform\nimport shutil\nimport subprocess\nimport sys\nfrom sysconfig import get_config_vars\n\nclass build_clib(_build_clib):\n    def run(self):\n        if use_system():\n            return\n\n        # use Python's build environment variables\n        build_env = {\n            key: val\n            for key, val in get_config_vars().items()\n            if key in (\"LDFLAGS\", \"CFLAGS\", \"CC\", \"CCSHARED\", \"LDSHARED\")\n            and key not in os.environ\n        }\n        os.environ.update(build_env)\n\n        # Ensure our temporary build directory exists\n        build_temp = os.path.abspath(self.build_temp)\n        try:\n            os.makedirs(build_temp)\n        except OSError as e:\n            if e.errno != errno.EEXIST:\n                raise\n\n        # Ensure all of our executable files have their permission set\n        for filename in [\n            \"src/libsodium/autogen.sh\",\n            \"src/libsodium/compile\",\n            \"src/libsodium/configure\",\n            \"src/libsodium/depcomp\",\n            \"src/libsodium/install-sh\",\n            \"src/libsodium/missing\",\n            \"src/libsodium/msvc-scripts/process.bat\",\n            \"src/libsodium/test/default/wintest.bat\",\n        ]:\n            os.chmod(here(filename), 0o755)\n\n        if not shutil.which(\"make\"):\n            raise Exception(\"ERROR: The 'make' utility is missing from PATH\")\n\n        # Locate our configure script\n        configure = abshere(\"src/libsodium/configure\")\n\n        # Run ./configure\n        configure_flags = [\n            \"--disable-shared\",\n            \"--enable-static\",\n            \"--disable-debug\",\n            \"--disable-dependency-tracking\",\n            \"--with-pic\",\n        ]\n        if platform.system() == \"SunOS\":\n            # On Solaris, libssp doesn't link statically and causes linker\n            # errors during import\n            configure_flags.append(\"--disable-ssp\")\n        if os.environ.get(\"SODIUM_INSTALL_MINIMAL\"):\n            configure_flags.append(\"--enable-minimal\")\n        subprocess.check_call(\n            [configure]\n            + configure_flags\n            + [\"--prefix\", os.path.abspath(self.build_clib)],\n            cwd=build_temp,\n        )",
              "triple_sequences": [
                {
                  "action_api": "get_config_vars()",
                  "action_description": "Retrieves operating system information",
                  "action_id": "get_os_info",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access configuration value",
                  "intention_id": "access_configuration_value"
                },
                {
                  "action_api": "os.environ.update()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "build_env",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "self.build_temp",
                  "object_description": "Temporary directory",
                  "object_id": "temporary_directory",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "os.makedirs()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "build_temp",
                  "object_description": "Temporary directory",
                  "object_id": "temporary_directory",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "os.chmod()",
                  "action_description": "Changes file mode to add execute permission",
                  "action_id": "change_file_mode_execute",
                  "object": "here(filename), 0o755",
                  "object_description": "File permission",
                  "object_id": "file_permission",
                  "intention_description": "Modify file attributes",
                  "intention_id": "modify_file_attributes"
                },
                {
                  "action_api": "shutil.which()",
                  "action_description": "Retrieves operating system information",
                  "action_id": "get_os_info",
                  "object": "\"make\"",
                  "object_description": "System command",
                  "object_id": "system_command",
                  "intention_description": "Determine required module presence",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "abshere()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "\"src/libsodium/configure\"",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Prepare executable string",
                  "intention_id": "prepare_executable_string"
                },
                {
                  "action_api": "platform.system()",
                  "action_description": "Retrieves operating system information",
                  "action_id": "get_os_info",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine operating system",
                  "intention_id": "get_operating_system_name"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"SODIUM_INSTALL_MINIMAL\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[configure] + configure_flags + [\"--prefix\", os.path.abspath(self.build_clib)]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "astronomer_providers-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/astronomer_providers-1.19.4.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "example_hive.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/astronomer_providers-1.19.4/astronomer_providers-1.19.4/astronomer/providers/apache/hive/example_dags/example_hive.py",
          "line_number": "160",
          "type_description": "shady-links",
          "context_snippet": "def add_inbound_rule_for_security_group(task_instance: Any) -> None:\n    \"\"\"\n    Sets the inbound rule for the aws security group, based on\n    current ip address of the system.\n    \"\"\"\n    import boto3\n    from botocore.exceptions import ClientError\n\n    current_docker_ip = get(\"https://api.ipify.org\").text\n    logging.info(\"Current ip address is: %s\", str(current_docker_ip))\n    client = boto3.client(\"ec2\", **AWS_S3_CREDS)\n\n    # Port HIVE_OPERATOR_INGRESS_PORT needs to be open for Impyla connectivity to Hive.\n    try:\n        client.authorize_security_group_ingress(\n            GroupId=task_instance.xcom_pull(\n                key=\"cluster_response_master_security_group\", task_ids=[\"describe_created_cluster\"]\n            )[0],\n            IpPermissions=[\n                {\n                    \"IpProtocol\": \"tcp\",\n                    \"FromPort\": HIVE_OPERATOR_INGRESS_PORT,\n                    \"ToPort\": HIVE_OPERATOR_INGRESS_PORT,\n                    \"IpRanges\": [{\"CidrIp\": str(current_docker_ip) + \"/32\"}],\n                }\n            ],\n        )\n    except ClientError as error:\n        if error.response.get(\"Error\", {}).get(\"Code\", \"\") == BOTO_DUPLICATE_PERMISSION_ERROR:\n            logging.error(\n                \"Ingress for port %s already authorized. Error Message is: %s\",\n                HIVE_OPERATOR_INGRESS_PORT,\n                error.response[\"Error\"][\"Message\"],\n            )\n        else:\n            raise error\n\n    # Allow SSH traffic on port 22 and copy file to HDFS.\n    try:\n        client.authorize_security_group_ingress(\n            GroupId=task_instance.xcom_pull(\n                key=\"cluster_response_master_security_group\", task_ids=[\"describe_created_cluster\"]\n            )[0],\n            IpPermissions=[\n                {\n                    \"IpProtocol\": \"tcp\",\n                    \"FromPort\": 22,\n                    \"ToPort\": 22,\n                    \"IpRanges\": [{\"CidrIp\": str(current_docker_ip) + \"/32\"}],\n                }\n            ],\n        )\n    except ClientError as error:\n        if error.response.get(\"Error\", {}).get(\"Code\", \"\") == BOTO_DUPLICATE_PERMISSION_ERROR:\n            logging.error(\n                \"Ingress for port 22 already authorized. Error message is: %s\",\n                error.response[\"Error\"][\"Message\"],\n            )\n        else:\n            raise error",
          "hash_value": "233d100eb7063bda6707b57ca80665a3",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def add_inbound_rule_for_security_group(task_instance: Any) -> None:\n    \"\"\"\n    Sets the inbound rule for the aws security group, based on\n    current ip address of the system.\n    \"\"\"\n    import boto3\n    from botocore.exceptions import ClientError\n\n    current_docker_ip = get(\"https://api.ipify.org\").text\n    logging.info(\"Current ip address is: %s\", str(current_docker_ip))\n    client = boto3.client(\"ec2\", **AWS_S3_CREDS)\n\n    # Port HIVE_OPERATOR_INGRESS_PORT needs to be open for Impyla connectivity to Hive.\n    try:\n        client.authorize_security_group_ingress(\n            GroupId=task_instance.xcom_pull(\n                key=\"cluster_response_master_security_group\", task_ids=[\"describe_created_cluster\"]\n            )[0],\n            IpPermissions=[\n                {\n                    \"IpProtocol\": \"tcp\",\n                    \"FromPort\": HIVE_OPERATOR_INGRESS_PORT,\n                    \"ToPort\": HIVE_OPERATOR_INGRESS_PORT,\n                    \"IpRanges\": [{\"CidrIp\": str(current_docker_ip) + \"/32\"}],\n                }\n            ],\n        )\n    except ClientError as error:\n        if error.response.get(\"Error\", {}).get(\"Code\", \"\") == BOTO_DUPLICATE_PERMISSION_ERROR:\n            logging.error(\n                \"Ingress for port %s already authorized. Error Message is: %s\",\n                HIVE_OPERATOR_INGRESS_PORT,\n                error.response[\"Error\"][\"Message\"],\n            )\n        else:\n            raise error\n\n    # Allow SSH traffic on port 22 and copy file to HDFS.\n    try:\n        client.authorize_security_group_ingress(\n            GroupId=task_instance.xcom_pull(\n                key=\"cluster_response_master_security_group\", task_ids=[\"describe_created_cluster\"]\n            )[0],\n            IpPermissions=[\n                {\n                    \"IpProtocol\": \"tcp\",\n                    \"FromPort\": 22,\n                    \"ToPort\": 22,\n                    \"IpRanges\": [{\"CidrIp\": str(current_docker_ip) + \"/32\"}],\n                }\n            ],\n        )\n    except ClientError as error:\n        if error.response.get(\"Error\", {}).get(\"Code\", \"\") == BOTO_DUPLICATE_PERMISSION_ERROR:\n            logging.error(\n                \"Ingress for port 22 already authorized. Error message is: %s\",\n                error.response[\"Error\"][\"Message\"],\n            )\n        else:\n            raise error",
              "triple_sequences": [
                {
                  "action_api": "get()",
                  "action_description": "Opens URL with GET parameters",
                  "action_id": "open_url_get",
                  "object": "https://api.ipify.org",
                  "object_description": "External domain",
                  "object_id": "external_domain",
                  "intention_description": "Collect public IP address",
                  "intention_id": "collect_public_ip"
                },
                {
                  "action_api": "boto3.client()",
                  "action_description": "Creates HTTP connection to specified host",
                  "action_id": "create_http_connection",
                  "object": "\"ec2\", **AWS_S3_CREDS",
                  "object_description": "API key or token",
                  "object_id": "api_key",
                  "intention_description": "Establish connection",
                  "intention_id": "establish_connection"
                },
                {
                  "action_api": "task_instance.xcom_pull()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "key=\"cluster_response_master_security_group\", task_ids=[\"describe_created_cluster\"]",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Access configuration value",
                  "intention_id": "access_configuration_value"
                },
                {
                  "action_api": "client.authorize_security_group_ingress()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "GroupId=..., IpPermissions=[{'IpProtocol': 'tcp', 'FromPort': HIVE_OPERATOR_INGRESS_PORT, 'ToPort': HIVE_OPERATOR_INGRESS_PORT, 'IpRanges': [{'CidrIp': str(current_docker_ip) + '/32'}]}]",
                  "object_description": "System command",
                  "object_id": "system_command",
                  "intention_description": "Establish connection",
                  "intention_id": "establish_connection"
                },
                {
                  "action_api": "client.authorize_security_group_ingress()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "GroupId=..., IpPermissions=[{'IpProtocol': 'tcp', 'FromPort': 22, 'ToPort': 22, 'IpRanges': [{'CidrIp': str(current_docker_ip) + '/32'}]}]",
                  "object_description": "System command",
                  "object_id": "system_command",
                  "intention_description": "Establish connection",
                  "intention_id": "establish_connection"
                },
                {
                  "action_api": "logging.info()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "\"Current ip address is: %s\", str(current_docker_ip)",
                  "object_description": "System command",
                  "object_id": "system_command",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "logging.error()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "\"Ingress for port %s already authorized. Error Message is: %s\", HIVE_OPERATOR_INGRESS_PORT, error.response[\"Error\"][\"Message\"]",
                  "object_description": "System command",
                  "object_id": "system_command",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "logging.error()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "\"Ingress for port 22 already authorized. Error message is: %s\", error.response[\"Error\"][\"Message\"]",
                  "object_description": "System command",
                  "object_id": "system_command",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "erppeek-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/erppeek-1.7.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "erppeek.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/erppeek-1.7.1/ERPpeek-1.7.1/erppeek.py",
          "line_number": "1673",
          "type_description": "obfuscation",
          "context_snippet": "def _interact(global_vars, use_pprint=True, usage=USAGE):\n    import code\n    import pprint\n    if PY2:\n        import __builtin__ as builtins\n\n        def _exec(code, g):\n            exec('exec code in g')\n    else:\n        import builtins\n        _exec = getattr(builtins, 'exec')\n\n    if use_pprint:\n        def displayhook(value, _printer=pprint.pprint, _builtins=builtins):\n            # Pretty-format the output\n            if value is None:\n                return\n            _printer(value)\n            _builtins._ = value\n        sys.displayhook = displayhook\n\n    class Usage(object):\n        def __call__(self):\n            print(usage)\n        __repr__ = lambda s: usage\n    builtins.usage = Usage()\n\n    try:\n        import readline as rl\n        import rlcompleter\n        rl.parse_and_bind('tab: complete')\n        # IOError if file missing, or broken Apple readline\n        rl.read_history_file(HIST_FILE)\n    except Exception:\n        pass\n    else:\n        if rl.get_history_length() < 0:\n            rl.set_history_length(int(os.getenv('HISTSIZE', 500)))\n        # better append instead of replace?\n        atexit.register(rl.write_history_file, HIST_FILE)\n\n    class Console(code.InteractiveConsole):\n        def runcode(self, code):\n            try:\n                _exec(code, global_vars)\n            except SystemExit:\n                raise\n            except:\n                # Print readable 'Fault' errors\n                # Work around http://bugs.python.org/issue12643\n                (exc_type, exc, tb) = sys.exc_info()\n                msg = ''.join(format_exception(exc_type, exc, tb, chain=False))\n                print(msg.strip())\n\n    sys.exc_clear() if hasattr(sys, 'exc_clear') else None  # Python 2.x\n    # Key UP to avoid an empty line\n    Console().interact('\\033[A')",
          "hash_value": "a63c21e1225fd9e4bd2de1fdb58e9dbd",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def _interact(global_vars, use_pprint=True, usage=USAGE):\n    import code\n    import pprint\n    if PY2:\n        import __builtin__ as builtins\n\n        def _exec(code, g):\n            exec('exec code in g')\n    else:\n        import builtins\n        _exec = getattr(builtins, 'exec')\n\n    if use_pprint:\n        def displayhook(value, _printer=pprint.pprint, _builtins=builtins):\n            # Pretty-format the output\n            if value is None:\n                return\n            _printer(value)\n            _builtins._ = value\n        sys.displayhook = displayhook\n\n    class Usage(object):\n        def __call__(self):\n            print(usage)\n        __repr__ = lambda s: usage\n    builtins.usage = Usage()\n\n    try:\n        import readline as rl\n        import rlcompleter\n        rl.parse_and_bind('tab: complete')\n        # IOError if file missing, or broken Apple readline\n        rl.read_history_file(HIST_FILE)\n    except Exception:\n        pass\n    else:\n        if rl.get_history_length() < 0:\n            rl.set_history_length(int(os.getenv('HISTSIZE', 500)))\n        # better append instead of replace?\n        atexit.register(rl.write_history_file, HIST_FILE)\n\n    class Console(code.InteractiveConsole):\n        def runcode(self, code):\n            try:\n                _exec(code, global_vars)\n            except SystemExit:\n                raise\n            except:\n                # Print readable 'Fault' errors\n                # Work around http://bugs.python.org/issue12643\n                (exc_type, exc, tb) = sys.exc_info()\n                msg = ''.join(format_exception(exc_type, exc, tb, chain=False))\n                print(msg.strip())\n\n    sys.exc_clear() if hasattr(sys, 'exc_clear') else None  # Python 2.x\n    # Key UP to avoid an empty line\n    Console().interact('\\033[A')",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, 'exec'",
                  "object_description": "Builtin module",
                  "object_id": "builtin_module",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "pprint.pprint()",
                  "action_description": "Serializes Python object to JSON string",
                  "action_id": "serialize_to_json",
                  "object": "value",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Serialize data",
                  "intention_id": "serialize_data"
                },
                {
                  "action_api": "sys.displayhook = displayhook",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "sys.displayhook, displayhook",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Modify builtins and execute code",
                  "intention_id": "modify_builtins_execute_code"
                },
                {
                  "action_api": "builtins.usage = Usage()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "builtins.usage, Usage()",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Modify builtins and execute code",
                  "intention_id": "modify_builtins_execute_code"
                },
                {
                  "action_api": "rl.parse_and_bind()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "'tab: complete'",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "rl.read_history_file()",
                  "action_description": "Basic read operations for reading file",
                  "action_id": "basic_read_operations",
                  "object": "HIST_FILE",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "rl.get_history_length()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "rl.set_history_length()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "int(os.getenv('HISTSIZE', 500))",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Modify builtins and execute code",
                  "intention_id": "modify_builtins_execute_code"
                },
                {
                  "action_api": "atexit.register()",
                  "action_description": "Registers function to be called at program exit",
                  "action_id": "register_exit_function",
                  "object": "rl.write_history_file, HIST_FILE",
                  "object_description": "Function with arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Register keylogger event handler",
                  "intention_id": "register_keylogger_handler"
                },
                {
                  "action_api": "sys.exc_clear()",
                  "action_description": "Removes all keyboard hooks",
                  "action_id": "remove_keyboard_hooks",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Release keyboard hook",
                  "intention_id": "release_keyboard_hook"
                },
                {
                  "action_api": "Console().interact()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "'\\033[A'",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "setupmeta-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/setupmeta-3.8.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/setupmeta-3.8.0/setupmeta-3.8.0/setup.py",
          "line_number": "39",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport subprocess  # nosec\nimport sys\n\nHERE = os.path.dirname(os.path.abspath(__file__))\nEGG = os.path.join(HERE, \"setupmeta.egg-info\")\n\ndef decode(text):\n    if isinstance(text, bytes):\n        return text.decode(\"utf-8\")\n    return text\n\ndef run_bootstrap(message):\n    sys.stderr.write(\"--- Bootstrapping %s\\n\" % message)\n    p = subprocess.Popen([sys.executable, \"setup.py\", \"egg_info\"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)  # nosec\n    output, error = p.communicate()\n    if p.returncode:\n        print(decode(output))\n        sys.stderr.write(\"%s\\n\" % decode(error))\n        sys.exit(p.returncode)\n    if not os.path.isdir(EGG):\n        sys.exit(\"Could not bootstrap egg-info\")",
          "hash_value": "5e17fa2453fc9cf548e7513b32cbedee",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport subprocess  # nosec\nimport sys\n\nHERE = os.path.dirname(os.path.abspath(__file__))\nEGG = os.path.join(HERE, \"setupmeta.egg-info\")\n\ndef decode(text):\n    if isinstance(text, bytes):\n        return text.decode(\"utf-8\")\n    return text\n\ndef run_bootstrap(message):\n    sys.stderr.write(\"--- Bootstrapping %s\\n\" % message)\n    p = subprocess.Popen([sys.executable, \"setup.py\", \"egg_info\"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)  # nosec\n    output, error = p.communicate()\n    if p.returncode:\n        print(decode(output))\n        sys.stderr.write(\"%s\\n\" % decode(error))\n        sys.exit(p.returncode)\n    if not os.path.isdir(EGG):\n        sys.exit(\"Could not bootstrap egg-info\")",
              "triple_sequences": [
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.abspath(__file__)",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "HERE, \"setupmeta.egg-info\"",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "sys.stderr.write()",
                  "action_description": "Writes data to standard error stream",
                  "action_id": "read_process_stderr",
                  "object": "\"--- Bootstrapping %s\\n\" % message",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "[sys.executable, \"setup.py\", \"egg_info\"]",
                  "object_description": "Python command",
                  "object_id": "python_command",
                  "intention_description": "Create child process",
                  "intention_id": "create_child_process"
                },
                {
                  "action_api": "p.communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "output",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                },
                {
                  "action_api": "decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "error",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                },
                {
                  "action_api": "sys.stderr.write()",
                  "action_description": "Writes data to standard error stream",
                  "action_id": "read_process_stderr",
                  "object": "\"%s\\n\" % decode(error)",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "p.returncode",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                },
                {
                  "action_api": "os.path.isdir()",
                  "action_description": "Checks if specified path exists and is a directory",
                  "action_id": "check_directory_exists",
                  "object": "EGG",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Determine presence of directory",
                  "intention_id": "determine_directory_presence"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "\"Could not bootstrap egg-info\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "latch-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/latch-2.58.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "messages.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/latch-2.58.2/latch-2.58.2/src/latch/functions/messages.py",
          "line_number": "56",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "import os\nfrom typing import Any, Dict\n\nimport requests\n\nNUCLEUS_URL = os.environ.get(\"LATCH_CLI_NUCLEUS_URL\", \"https://nucleus.latch.bio\")\nADD_MESSAGE_ENDPOINT = f\"{NUCLEUS_URL}/sdk/add-task-execution-message\"\n\n\ndef message(typ: str, data: Dict[str, Any]) -> None:\n    \"\"\"Display a message prominently on the Latch console during and after a\n    task execution.\n\n    The Latch platform first processes this message internally, then displays it\n    under your task's execution page.\n\n    Args:\n        typ:\n            A message type that determines how your message is displayed.\n            Currently one of 'info', 'warning', or 'error'.\n        data:\n            The data displayed on the Latch console, formatted as follows:\n            ```{'title': ..., 'body': ...}```.\n\n    Raises:\n        RuntimeError: If an internal error occurs while processing the message.\n\n    Example usage: ::\n\n        @small_task\n        def task():\n\n            ...\n\n            try:\n                ...\n            catch ValueError:\n                title = 'Invalid sample ID column selected'\n                body = 'Your file indicates that sample columns a, b are valid'\n                message(type='error', data={'title': title, 'body': body})\n\n            ...\n    \"\"\"\n    task_project = os.environ.get(\"FLYTE_INTERNAL_TASK_PROJECT\")\n    task_domain = os.environ.get(\"FLYTE_INTERNAL_TASK_DOMAIN\")\n    task_name = os.environ.get(\"FLYTE_INTERNAL_TASK_NAME\")\n    task_version = os.environ.get(\"FLYTE_INTERNAL_TASK_VERSION\")\n    task_attempt_number = os.environ.get(\"FLYTE_ATTEMPT_NUMBER\")\n    execution_token = os.environ.get(\"FLYTE_INTERNAL_EXECUTION_ID\")\n    array_index = os.environ.get(\"FLYTE_K8S_ARRAY_INDEX\")\n\n    if task_project is None:\n        print(f\"Local execution message:\\n[{typ}]: {data}\")\n        return\n\n    response = requests.post(\n        url=ADD_MESSAGE_ENDPOINT,\n        json={\n            \"execution_token\": execution_token,\n            \"task\": {\n                \"project\": task_project,\n                \"domain\": task_domain,\n                \"name\": task_name,\n                \"version\": task_version,\n            },\n            \"task_attempt_number\": task_attempt_number,\n            \"task_array_index\": array_index,\n            \"type\": typ,\n            \"data\": data,\n        },\n    )\n\n    if response.status_code != 200:\n        raise RuntimeError(\"Could not add task execution message to Latch.\")",
          "hash_value": "1f9beade20dae33b5a2d59f5fa3edda6",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nfrom typing import Any, Dict\n\nimport requests\n\nNUCLEUS_URL = os.environ.get(\"LATCH_CLI_NUCLEUS_URL\", \"https://nucleus.latch.bio\")\nADD_MESSAGE_ENDPOINT = f\"{NUCLEUS_URL}/sdk/add-task-execution-message\"\n\n\ndef message(typ: str, data: Dict[str, Any]) -> None:\n    \"\"\"Display a message prominently on the Latch console during and after a\n    task execution.\n\n    The Latch platform first processes this message internally, then displays it\n    under your task's execution page.\n\n    Args:\n        typ:\n            A message type that determines how your message is displayed.\n            Currently one of 'info', 'warning', or 'error'.\n        data:\n            The data displayed on the Latch console, formatted as follows:\n            ```{'title': ..., 'body': ...}```.\n\n    Raises:\n        RuntimeError: If an internal error occurs while processing the message.\n\n    Example usage: ::\n\n        @small_task\n        def task():\n\n            ...\n\n            try:\n                ...\n            catch ValueError:\n                title = 'Invalid sample ID column selected'\n                body = 'Your file indicates that sample columns a, b are valid'\n                message(type='error', data={'title': title, 'body': body})\n\n            ...\n    \"\"\"\n    task_project = os.environ.get(\"FLYTE_INTERNAL_TASK_PROJECT\")\n    task_domain = os.environ.get(\"FLYTE_INTERNAL_TASK_DOMAIN\")\n    task_name = os.environ.get(\"FLYTE_INTERNAL_TASK_NAME\")\n    task_version = os.environ.get(\"FLYTE_INTERNAL_TASK_VERSION\")\n    task_attempt_number = os.environ.get(\"FLYTE_ATTEMPT_NUMBER\")\n    execution_token = os.environ.get(\"FLYTE_INTERNAL_EXECUTION_ID\")\n    array_index = os.environ.get(\"FLYTE_K8S_ARRAY_INDEX\")\n\n    if task_project is None:\n        print(f\"Local execution message:\\n[{typ}]: {data}\")\n        return\n\n    response = requests.post(\n        url=ADD_MESSAGE_ENDPOINT,\n        json={\n            \"execution_token\": execution_token,\n            \"task\": {\n                \"project\": task_project,\n                \"domain\": task_domain,\n                \"name\": task_name,\n                \"version\": task_version,\n            },\n            \"task_attempt_number\": task_attempt_number,\n            \"task_array_index\": array_index,\n            \"type\": typ,\n            \"data\": data,\n        },\n    )\n\n    if response.status_code != 200:\n        raise RuntimeError(\"Could not add task execution message to Latch.\")",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"LATCH_CLI_NUCLEUS_URL\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"FLYTE_INTERNAL_TASK_PROJECT\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"FLYTE_INTERNAL_TASK_DOMAIN\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"FLYTE_INTERNAL_TASK_NAME\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"FLYTE_INTERNAL_TASK_VERSION\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"FLYTE_ATTEMPT_NUMBER\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"FLYTE_INTERNAL_EXECUTION_ID\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"FLYTE_K8S_ARRAY_INDEX\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "print()",
                  "action_description": "Prints output to standard output",
                  "action_id": "get_stdout_stream",
                  "object": "f\"Local execution message:\\n[{typ}]: {data}\"",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "requests.post()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "url=ADD_MESSAGE_ENDPOINT, json={...}",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Transmit data HTTP POST",
                  "intention_id": "transmit_data_http_post"
                },
                {
                  "action_api": "response.status_code",
                  "action_description": "Retrieves HTTP response status code",
                  "action_id": "get_http_status",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "raise RuntimeError()",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "\"Could not add task execution message to Latch.\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "verspec-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/verspec-0.1.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/verspec-0.1.0/verspec-0.1.0/setup.py",
          "line_number": "46",
          "type_description": "code-execution",
          "context_snippet": "class TestCommand(Command):\n    description = \"run unit tests\"\n    user_options = [\n        (\"test-suite=\", \"s\",\n         \"test suite to run (e.g. 'some_file::test_suite')\"),\n    ]\n\n    def initialize_options(self):\n        self.test_suite = None\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        subprocess.check_call(\n            [\"pytest\"] +\n            ([\"-q\"] if self.verbose == 0 else []) +\n            ([self.test_suite] if self.test_suite else [])\n        )",
          "hash_value": "4419bf639a5937a3fdf6b29450e8052d",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class TestCommand(Command):\n    description = \"run unit tests\"\n    user_options = [\n        (\"test-suite=\", \"s\",\n         \"test suite to run (e.g. 'some_file::test_suite')\"),\n    ]\n\n    def initialize_options(self):\n        self.test_suite = None\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        subprocess.check_call(\n            [\"pytest\"] +\n            ([\"-q\"] if self.verbose == 0 else []) +\n            ([self.test_suite] if self.test_suite else [])\n        )",
              "triple_sequences": [
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "['pytest'] + (['-q'] if self.verbose == 0 else []) + ([self.test_suite] if self.test_suite else [])",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "xxtea-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/xxtea-3.3.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/xxtea-3.3.0/xxtea-3.3.0/setup.py",
          "line_number": "7",
          "type_description": "code-execution",
          "context_snippet": "from setuptools import setup, Extension\nimport os\n\nwith open('xxtea.c') as f:\n    for line in f:\n        if line.startswith(\"#define VERSION \"):\n            VERSION = eval(line.rsplit(None, 1)[-1])\n\nextension = Extension('xxtea', ['xxtea.c'])",
          "hash_value": "b6a9304b92197bd4a3902ebff50be99c",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from setuptools import setup, Extension\nimport os\n\nwith open('xxtea.c') as f:\n    for line in f:\n        if line.startswith(\"#define VERSION \"):\n            VERSION = eval(line.rsplit(None, 1)[-1])\n\nextension = Extension('xxtea', ['xxtea.c'])",
              "triple_sequences": [
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "'xxtea.c'",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "file.__iter__()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "str.startswith()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "\"#define VERSION \"",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "str.rsplit()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "None, 1",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "eval()",
                  "action_description": "Evaluates string as Python expression",
                  "action_id": "eval_python_expr",
                  "object": "line.rsplit(None, 1)[-1]",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Evaluate constructed code",
                  "intention_id": "evaluate_constructed_code"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "cylp-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/cylp-0.92.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cylp-0.92.3/cylp-0.92.3/setup.py",
          "line_number": "58",
          "type_description": "code-execution",
          "context_snippet": "        try:\n            location = dirname(\n                check_output(['which', 'cbc']).strip()).decode('utf-8')\n            CoinDir = abspath(join(location, \"..\"))\n        except:\n            #Otherwise, raise an exception\n            raise Exception('''\n            Could not find location of COIN installation.\n            Please ensure that either \n            * COIN_INSTALL_DIR is set to the location of the installation,\n            * PKG_CONFIG_PATH points to the location of the .pc files, or\n            * The cbc executable is in your executable path and is installed\n            at the same location as the libraries. \n            ''')",
          "hash_value": "4a4a8e6d3930c61bdc0fcb19fa03eec3",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "        try:\n            location = dirname(\n                check_output(['which', 'cbc']).strip()).decode('utf-8')\n            CoinDir = abspath(join(location, \"..\"))\n        except:\n            #Otherwise, raise an exception\n            raise Exception('''\n            Could not find location of COIN installation.\n            Please ensure that either \n            * COIN_INSTALL_DIR is set to the location of the installation,\n            * PKG_CONFIG_PATH points to the location of the .pc files, or\n            * The cbc executable is in your executable path and is installed\n            at the same location as the libraries. \n            ''')",
              "triple_sequences": [
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "['which', 'cbc']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "bytes.strip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "bytes.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "'utf-8'",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "location, \"..\"",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "join(location, \"..\")",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "raise Exception()",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "Could not find location of COIN installation. Please ensure that either * COIN_INSTALL_DIR is set to the location of the installation, * PKG_CONFIG_PATH points to the location of the .pc files, or * The cbc executable is in your executable path and is installed at the same location as the libraries.",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pyglove-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyglove-0.4.5.dev202504100810.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "annotation_conversion.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyglove-0.4.5.dev202504100810/pyglove-0.4.5.dev202504100810/pyglove/core/typing/annotation_conversion.py",
          "line_number": "208",
          "type_description": "obfuscation",
          "context_snippet": "def _resolve(type_id: str):\n\n    def _as_forward_ref() -> typing.ForwardRef:\n      return typing.ForwardRef(type_id, False, parent_module)  # pytype: disable=not-callable\n\n    def _resolve_name(name: str, parent_obj: typing.Any):\n      if name == 'None':\n        return None, True\n      if parent_obj is not None and hasattr(parent_obj, name):\n        return getattr(parent_obj, name), False\n      if hasattr(builtins, name):\n        return getattr(builtins, name), True\n      if type_id == '...':\n        return ..., True\n      return utils.MISSING_VALUE, False\n\n    names = type_id.split('.')\n    if len(names) == 1:\n      reference, is_builtin = _resolve_name(names[0], parent_module)\n      if is_builtin:\n        return reference\n      if not is_builtin and (\n          # When reference is not found, we should treat it as a forward\n          # reference.\n          reference == utils.MISSING_VALUE\n          # When module is being reloaded, we should treat all non-builtin\n          # references as forward references.\n          or getattr(parent_module, '__reloading__', False)\n      ):\n        return _as_forward_ref()\n      return reference\n\n    root_obj, _ = _resolve_name(names[0], parent_module)\n    # When root object is not found, we should treat it as a forward reference.\n    if root_obj == utils.MISSING_VALUE:\n      return _as_forward_ref()\n\n    parent_obj = root_obj\n    # When root object is a module, we should treat reference to its children\n    # as non-forward references.\n    if inspect.ismodule(root_obj):\n      for name in names[1:]:\n        parent_obj, _ = _resolve_name(name, parent_obj)\n        if parent_obj == utils.MISSING_VALUE:\n          raise TypeError(f'{type_id!r} does not exist.')\n      return parent_obj\n    # When root object is non-module variable of current module, and when the\n    # module is being reloaded, we should treat reference to its children as\n    # forward references.\n    elif getattr(parent_module, '__reloading__', False):\n      return _as_forward_ref()\n    # When root object is non-module variable of current module, we should treat\n    # unresolved reference to its children as forward references.\n    else:\n      for name in names[1:]:\n        parent_obj, _ = _resolve_name(name, parent_obj)\n        if parent_obj == utils.MISSING_VALUE:\n          return _as_forward_ref()\n      return parent_obj",
          "hash_value": "e347d6dd44147b8fce2345c554a05f17",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def _resolve(type_id: str):\n\n    def _as_forward_ref() -> typing.ForwardRef:\n      return typing.ForwardRef(type_id, False, parent_module)  # pytype: disable=not-callable\n\n    def _resolve_name(name: str, parent_obj: typing.Any):\n      if name == 'None':\n        return None, True\n      if parent_obj is not None and hasattr(parent_obj, name):\n        return getattr(parent_obj, name), False\n      if hasattr(builtins, name):\n        return getattr(builtins, name), True\n      if type_id == '...':\n        return ..., True\n      return utils.MISSING_VALUE, False\n\n    names = type_id.split('.')\n    if len(names) == 1:\n      reference, is_builtin = _resolve_name(names[0], parent_module)\n      if is_builtin:\n        return reference\n      if not is_builtin and (\n          # When reference is not found, we should treat it as a forward\n          # reference.\n          reference == utils.MISSING_VALUE\n          # When module is being reloaded, we should treat all non-builtin\n          # references as forward references.\n          or getattr(parent_module, '__reloading__', False)\n      ):\n        return _as_forward_ref()\n      return reference\n\n    root_obj, _ = _resolve_name(names[0], parent_module)\n    # When root object is not found, we should treat it as a forward reference.\n    if root_obj == utils.MISSING_VALUE:\n      return _as_forward_ref()\n\n    parent_obj = root_obj\n    # When root object is a module, we should treat reference to its children\n    # as non-forward references.\n    if inspect.ismodule(root_obj):\n      for name in names[1:]:\n        parent_obj, _ = _resolve_name(name, parent_obj)\n        if parent_obj == utils.MISSING_VALUE:\n          raise TypeError(f'{type_id!r} does not exist.')\n      return parent_obj\n    # When root object is non-module variable of current module, and when the\n    # module is being reloaded, we should treat reference to its children as\n    # forward references.\n    elif getattr(parent_module, '__reloading__', False):\n      return _as_forward_ref()\n    # When root object is non-module variable of current module, we should treat\n    # unresolved reference to its children as forward references.\n    else:\n      for name in names[1:]:\n        parent_obj, _ = _resolve_name(name, parent_obj)\n        if parent_obj == utils.MISSING_VALUE:\n          return _as_forward_ref()\n      return parent_obj",
              "triple_sequences": [
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "type_id",
                  "object_description": "String containing environment data",
                  "object_id": "string_environment_data",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "hasattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "parent_obj, name",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "parent_obj, name",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "hasattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, name",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, name",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "parent_module, '__reloading__', False",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "typing.ForwardRef()",
                  "action_description": "Dynamically imports specified module",
                  "action_id": "import_dynamic",
                  "object": "type_id, False, parent_module",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "inspect.ismodule()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "root_obj",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "raise TypeError",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "f'{type_id!r} does not exist.'",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "sgp4-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/sgp4-2.24.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/sgp4-2.24/sgp4-2.24/setup.py",
          "line_number": "42",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport sys\nfrom distutils.core import setup, Extension\n\nimport sgp4\ndescription, long_description = sgp4.__doc__.split('\\n', 1)\n\n# It is hard to write C extensions that support both Python 2 and 3, so\n# we opt here to support the acceleration only for Python 3.\n\next_modules = []\nif sys.version_info[0] == 3:\n\n    # This lets CI force us to exit with an error if compilation fails,\n    # instead of falling back silently to the backup Python code.\n    optional = True\n    if os.environ.get('SGP4_FORCE_COMPILE') == 'true':\n        optional = False\n\n    ext_modules.append(Extension(\n        'sgp4.vallado_cpp',\n        optional=optional,\n        sources=[\n            'extension/SGP4.cpp',\n            'extension/wrapper.cpp',\n        ],\n\n        # TODO: can we safely figure out how to use a pair of options\n        # like these, adapted to as many platforms as possible, to use\n        # multiple processors when available?\n        # extra_compile_args=['-fopenmp'],\n        # extra_link_args=['-fopenmp'],\n        extra_compile_args=['-ffloat-store'],\n    ))\n\n# Read the package's \"__version__\" without importing it.\npath = 'sgp4/__init__.py'\nwith open(path, 'rb') as f:\n    text = f.read().decode('utf-8')\ntext = text.replace('-*- coding: utf-8 -*-', '')  # for Python 2.7\nnamespace = {}\neval(compile(text, path, 'exec'), namespace)",
          "hash_value": "df6f12d2d73d27d9c8a14b68ed2cf57a",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport sys\nfrom distutils.core import setup, Extension\n\nimport sgp4\ndescription, long_description = sgp4.__doc__.split('\\n', 1)\n\n# It is hard to write C extensions that support both Python 2 and 3, so\n# we opt here to support the acceleration only for Python 3.\n\next_modules = []\nif sys.version_info[0] == 3:\n\n    # This lets CI force us to exit with an error if compilation fails,\n    # instead of falling back silently to the backup Python code.\n    optional = True\n    if os.environ.get('SGP4_FORCE_COMPILE') == 'true':\n        optional = False\n\n    ext_modules.append(Extension(\n        'sgp4.vallado_cpp',\n        optional=optional,\n        sources=[\n            'extension/SGP4.cpp',\n            'extension/wrapper.cpp',\n        ],\n\n        # TODO: can we safely figure out how to use a pair of options\n        # like these, adapted to as many platforms as possible, to use\n        # multiple processors when available?\n        # extra_compile_args=['-fopenmp'],\n        # extra_link_args=['-fopenmp'],\n        extra_compile_args=['-ffloat-store'],\n    ))\n\n# Read the package's \"__version__\" without importing it.\npath = 'sgp4/__init__.py'\nwith open(path, 'rb') as f:\n    text = f.read().decode('utf-8')\ntext = text.replace('-*- coding: utf-8 -*-', '')  # for Python 2.7\nnamespace = {}\neval(compile(text, path, 'exec'), namespace)",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'SGP4_FORCE_COMPILE'",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "Extension()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "'sgp4.vallado_cpp', optional=optional, sources=['extension/SGP4.cpp', 'extension/wrapper.cpp'], extra_compile_args=['-ffloat-store']",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "'sgp4/__init__.py', 'rb'",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "str.decode()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "'utf-8'",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Decode bytes to string",
                  "intention_id": "decode_bytes_to_string"
                },
                {
                  "action_api": "str.replace()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "'-*- coding: utf-8 -*-', ''",
                  "object_description": "String containing environment data",
                  "object_id": "string_environment_data",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "compile()",
                  "action_description": "Compiles source code string into executable code object",
                  "action_id": "compile_code_object",
                  "object": "text, path, 'exec'",
                  "object_description": "Compiled Python code string",
                  "object_id": "compiled_python_code",
                  "intention_description": "Construct Python code string",
                  "intention_id": "construct_python_code"
                },
                {
                  "action_api": "eval()",
                  "action_description": "Evaluates string as Python expression",
                  "action_id": "eval_python_expr",
                  "object": "compile(text, path, 'exec'), namespace",
                  "object_description": "Compiled Python code string",
                  "object_id": "compiled_python_code",
                  "intention_description": "Evaluate constructed code",
                  "intention_id": "evaluate_constructed_code"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "mongoengine-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/mongoengine-0.29.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/mongoengine-0.29.1/mongoengine-0.29.1/setup.py",
          "line_number": "27",
          "type_description": "code-execution",
          "context_snippet": "import os\n\ndef get_version(version_tuple):\n    \"\"\"Return the version tuple as a string, e.g. for (0, 10, 7),\n    return '0.10.7'.\n    \"\"\"\n    return \".\".join(map(str, version_tuple))\n\n# Dirty hack to get version number from monogengine/__init__.py - we can't\n# import it as it depends on PyMongo and PyMongo isn't installed until this\n# file is read\ninit = os.path.join(os.path.dirname(__file__), \"mongoengine\", \"__init__.py\")\nversion_line = list(filter(lambda line: line.startswith(\"VERSION\"), open(init)))[0]\n\nVERSION = get_version(eval(version_line.split(\"=\")[-1]))",
          "hash_value": "f2fdac964074b2fddf8cd62949727561",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\n\ndef get_version(version_tuple):\n    \"\"\"Return the version tuple as a string, e.g. for (0, 10, 7),\n    return '0.10.7'.\n    \"\"\"\n    return \".\".join(map(str, version_tuple))\n\n# Dirty hack to get version number from monogengine/__init__.py - we can't\n# import it as it depends on PyMongo and PyMongo isn't installed until this\n# file is read\ninit = os.path.join(os.path.dirname(__file__), \"mongoengine\", \"__init__.py\")\nversion_line = list(filter(lambda line: line.startswith(\"VERSION\"), open(init)))[0]\n\nVERSION = get_version(eval(version_line.split(\"=\")[-1]))",
              "triple_sequences": [
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.dirname(__file__), \"mongoengine\", \"__init__.py\"",
                  "object_description": "Directory path with file",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "init",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "filter()",
                  "action_description": "Iterates over all running processes",
                  "action_id": "iterate_processes",
                  "object": "lambda line: line.startswith(\"VERSION\"), open(init)",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "list()",
                  "action_description": "Lists all currently alive threads",
                  "action_id": "list_threads",
                  "object": "filter(lambda line: line.startswith(\"VERSION\"), open(init))",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "version_line.split(\"=\")[-1]",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "eval()",
                  "action_description": "Evaluates string as Python expression",
                  "action_id": "eval_python_expr",
                  "object": "version_line.split(\"=\")[-1]",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Evaluate constructed code",
                  "intention_id": "evaluate_constructed_code"
                },
                {
                  "action_api": "map()",
                  "action_description": "Generate product of sequence",
                  "action_id": "generate_sequence_product",
                  "object": "str, version_tuple",
                  "object_description": "Character code array",
                  "object_id": "character_code_array",
                  "intention_description": "Prepare character for further processing",
                  "intention_id": "prepare_character_processing"
                },
                {
                  "action_api": "str.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "\".\", map(str, version_tuple)",
                  "object_description": "Character code array",
                  "object_id": "character_code_array",
                  "intention_description": "Join characters into string",
                  "intention_id": "join_characters_into_string"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "flaskfarm-4",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/flaskfarm-4.1.37.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "discord.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/flaskfarm-4.1.37/FlaskFarm-4.1.37/flaskfarm/lib/support/base/discord.py",
          "line_number": "228",
          "type_description": "shady-links",
          "context_snippet": "@classmethod\n    def discord_cdn(cls, byteio=None, filepath=None, filename=None, webhook_url=\"https://discord.com/api/webhooks/1050549730964410470/ttge1ggOfIxrCSeTmYbIIsUWyMGAQj-nN6QBgwZTqLcHtUKcqjZ8wFWSWAhHmZne57t7\", content='', retry=True):\n        data = None\n        if webhook_url is None:\n            webhook_url =  webhook_list[random.randint(0,9)] \n\n        try:\n            webhook = DiscordWebhook(url=webhook_url, content=content)\n            if byteio is None and filepath is not None:\n                import io\n                with open(filepath, 'rb') as fh:\n                    byteio = io.BytesIO(fh.read())\n                \n            webhook.add_file(file=byteio.getvalue(), filename=filename)\n            embed = DiscordEmbed()\n            response = webhook.execute()\n            data = None\n            if type(response) == type([]):\n                if len(response) > 0:\n                    data = response[0].json()\n            else:\n                data = response.json()    \n            \n            if data is not None and 'attachments' in data:\n                target = data['attachments'][0]['url']\n                if requests.get(target).status_code == 200:\n                    return target\n            if retry:\n                time.sleep(1)\n                return cls.discord_proxy_image_localfile(filepath, retry=False)\n        except Exception as e: \n            logger.error(f\"Exception:{str(e)}\")\n            logger.error(traceback.format_exc())\n            if retry:\n                time.sleep(1)\n                return cls.discord_proxy_image_localfile(filepath, retry=False)",
          "hash_value": "18244409a89f62905e8bf08930079813",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "@classmethod\n    def discord_cdn(cls, byteio=None, filepath=None, filename=None, webhook_url=\"https://discord.com/api/webhooks/1050549730964410470/ttge1ggOfIxrCSeTmYbIIsUWyMGAQj-nN6QBgwZTqLcHtUKcqjZ8wFWSWAhHmZne57t7\", content='', retry=True):\n        data = None\n        if webhook_url is None:\n            webhook_url =  webhook_list[random.randint(0,9)] \n\n        try:\n            webhook = DiscordWebhook(url=webhook_url, content=content)\n            if byteio is None and filepath is not None:\n                import io\n                with open(filepath, 'rb') as fh:\n                    byteio = io.BytesIO(fh.read())\n                \n            webhook.add_file(file=byteio.getvalue(), filename=filename)\n            embed = DiscordEmbed()\n            response = webhook.execute()\n            data = None\n            if type(response) == type([]):\n                if len(response) > 0:\n                    data = response[0].json()\n            else:\n                data = response.json()    \n            \n            if data is not None and 'attachments' in data:\n                target = data['attachments'][0]['url']\n                if requests.get(target).status_code == 200:\n                    return target\n            if retry:\n                time.sleep(1)\n                return cls.discord_proxy_image_localfile(filepath, retry=False)\n        except Exception as e: \n            logger.error(f\"Exception:{str(e)}\")\n            logger.error(traceback.format_exc())\n            if retry:\n                time.sleep(1)\n                return cls.discord_proxy_image_localfile(filepath, retry=False)",
              "triple_sequences": [
                {
                  "action_api": "DiscordWebhook()",
                  "action_description": "Creates Discord webhook object",
                  "action_id": "create_discord_webhook",
                  "object": "url=webhook_url, content=content",
                  "object_description": "Discord webhook URL",
                  "object_id": "discord_webhook_url",
                  "intention_description": "webhook_transmission_preparation",
                  "intention_id": "webhook_transmission_preparation"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "filepath",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "read_file_content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "io.BytesIO()",
                  "action_description": "Creates in-memory bytes buffer from encoded string",
                  "action_id": "create_memory_bytes",
                  "object": "fh.read()",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "prepare_data_processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "webhook.add_file()",
                  "action_description": "Adds file to ZIP archive with specified archive name",
                  "action_id": "add_file_zip",
                  "object": "file=byteio.getvalue(), filename=filename",
                  "object_description": "Image binary stream",
                  "object_id": "image_binary_stream",
                  "intention_description": "add_file_to_archive",
                  "intention_id": "add_file_to_archive"
                },
                {
                  "action_api": "DiscordEmbed()",
                  "action_description": "Creates Discord embed object",
                  "action_id": "create_discord_embed",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "webhook_transmission_preparation",
                  "intention_id": "webhook_transmission_preparation"
                },
                {
                  "action_api": "webhook.execute()",
                  "action_description": "Sends message to Discord channel via webhook",
                  "action_id": "send_discord_webhook",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "send_data_server",
                  "intention_id": "send_data_server"
                },
                {
                  "action_api": "response.json()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "parse_json_data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "target",
                  "object_description": "Discord CDN URL",
                  "object_id": "discord_cdn_url",
                  "intention_description": "download_remote_content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "time.sleep()",
                  "action_description": "Suspends execution",
                  "action_id": "suspend_execution",
                  "object": "1",
                  "object_description": "Delay duration in seconds",
                  "object_id": "delay_duration",
                  "intention_description": "delay_next_operation",
                  "intention_id": "delay_next_operation"
                },
                {
                  "action_api": "cls.discord_proxy_image_localfile()",
                  "action_description": "Instantiates custom class or function",
                  "action_id": "init_grabber_class",
                  "object": "filepath, retry=False",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "trigger_main_behavioral_logic",
                  "intention_id": "trigger_main_behavioral_logic"
                },
                {
                  "action_api": "logger.error()",
                  "action_description": "Writes log message to error output",
                  "action_id": "read_process_stderr",
                  "object": "f\"Exception:{str(e)}\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "access_command_error_output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "logger.error()",
                  "action_description": "Writes log message to error output",
                  "action_id": "read_process_stderr",
                  "object": "traceback.format_exc()",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "access_command_error_output",
                  "intention_id": "access_command_error_output"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "urllib3_future-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/urllib3_future-2.12.917.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "noxfile.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/urllib3_future-2.12.917/urllib3_future-2.12.917/noxfile.py",
          "line_number": "143",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "from urllib.error import HTTPError, URLError\nfrom urllib.request import Request, urlopen\nfrom http.client import RemoteDisconnected\nfrom socket import timeout as SocketTimeout\nimport time\n\n@contextlib.contextmanager\ndef traefik_boot(\n    session: nox.Session, *args: str\n) -> typing.Generator[None, None, None]:\n    ...\n    traefik_ipv4 = os.environ.get(\"TRAEFIK_HTTPBIN_IPV4\", \"127.0.0.1\")\n    ...\n    try:\n        session.log(\"Attempt to start Traefik with go-httpbin[...]\")\n        ...\n        dc_process.wait()\n    except OSError as e:\n        session.warn(\n            f\"Traefik server cannot be run due to an error with containers: {e}\"\n        )\n    else:\n        session.log(\"Traefik server is starting[...]\")\n\n        i = 0\n\n        while True:\n            if i >= 120:\n                if not dc_v1_legacy:\n                    subprocess.Popen(\n                        [\n                            \"docker\",\n                            \"compose\",\n                            \"-f\",\n                            \"docker-compose.win.yaml\",\n                            \"logs\",\n                            \"--tail=128\",\n                        ]\n                    )\n\n                raise TimeoutError(\n                    \"Error while waiting for the Traefik server (timeout/readiness)\"\n                )\n\n            try:\n                r = urlopen(\n                    Request(\n                        f\"http://{traefik_ipv4}:8888/get\",\n                        headers={\"Host\": \"httpbin.local\"},\n                    ),\n                    timeout=1.0,\n                )\n            except (\n                HTTPError,\n                URLError,\n                RemoteDisconnected,\n                TimeoutError,\n                SocketTimeout,\n                ConnectionError,\n            ) as e:\n                i += 1\n                time.sleep(1)\n                session.log(f\"Waiting for the Traefik server: {e}...\")\n                continue\n\n            if int(r.status) == 200:\n                break\n\n        session.log(\"Traefik server is ready to accept connections[...]\")\n        external_stack_started = True\n\n    yield\n\n    if external_stack_started:\n        if dc_v1_legacy:\n            dc_process = subprocess.Popen([\"docker-compose\", \"stop\"])\n        else:\n            dc_process = subprocess.Popen([\"docker\", \"compose\", \"stop\"])\n\n        dc_process.wait()",
          "hash_value": "19a1de7ae57593e61c853640772e4547",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from urllib.error import HTTPError, URLError\nfrom urllib.request import Request, urlopen\nfrom http.client import RemoteDisconnected\nfrom socket import timeout as SocketTimeout\nimport time\n\n@contextlib.contextmanager\ndef traefik_boot(\n    session: nox.Session, *args: str\n) -> typing.Generator[None, None, None]:\n    ...\n    traefik_ipv4 = os.environ.get(\"TRAEFIK_HTTPBIN_IPV4\", \"127.0.0.1\")\n    ...\n    try:\n        session.log(\"Attempt to start Traefik with go-httpbin[...]\")\n        ...\n        dc_process.wait()\n    except OSError as e:\n        session.warn(\n            f\"Traefik server cannot be run due to an error with containers: {e}\"\n        )\n    else:\n        session.log(\"Traefik server is starting[...]\")\n\n        i = 0\n\n        while True:\n            if i >= 120:\n                if not dc_v1_legacy:\n                    subprocess.Popen(\n                        [\n                            \"docker\",\n                            \"compose\",\n                            \"-f\",\n                            \"docker-compose.win.yaml\",\n                            \"logs\",\n                            \"--tail=128\",\n                        ]\n                    )\n\n                raise TimeoutError(\n                    \"Error while waiting for the Traefik server (timeout/readiness)\"\n                )\n\n            try:\n                r = urlopen(\n                    Request(\n                        f\"http://{traefik_ipv4}:8888/get\",\n                        headers={\"Host\": \"httpbin.local\"},\n                    ),\n                    timeout=1.0,\n                )\n            except (\n                HTTPError,\n                URLError,\n                RemoteDisconnected,\n                TimeoutError,\n                SocketTimeout,\n                ConnectionError,\n            ) as e:\n                i += 1\n                time.sleep(1)\n                session.log(f\"Waiting for the Traefik server: {e}...\")\n                continue\n\n            if int(r.status) == 200:\n                break\n\n        session.log(\"Traefik server is ready to accept connections[...]\")\n        external_stack_started = True\n\n    yield\n\n    if external_stack_started:\n        if dc_v1_legacy:\n            dc_process = subprocess.Popen([\"docker-compose\", \"stop\"])\n        else:\n            dc_process = subprocess.Popen([\"docker\", \"compose\", \"stop\"])\n\n        dc_process.wait()",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"TRAEFIK_HTTPBIN_IPV4\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "session.log()",
                  "action_description": "Writes log message to file or console",
                  "action_id": "write_file_content",
                  "object": "\"Attempt to start Traefik with go-httpbin[...]\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "dc_process.wait()",
                  "action_description": "Waits for process to complete execution",
                  "action_id": "wait_process_completion",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Wait for events",
                  "intention_id": "wait_for_events"
                },
                {
                  "action_api": "session.warn()",
                  "action_description": "Writes log message to file or console",
                  "action_id": "write_file_content",
                  "object": "f\"Traefik server cannot be run due to an error with containers: {e}\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "[\"docker\", \"compose\", \"-f\", \"docker-compose.win.yaml\", \"logs\", \"--tail=128\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "raise TimeoutError",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "\"Error while waiting for the Traefik server (timeout/readiness)\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                },
                {
                  "action_api": "urlopen()",
                  "action_description": "Opens URL with GET parameters",
                  "action_id": "open_url_get",
                  "object": "Request(f\"http://{traefik_ipv4}:8888/get\", headers={\"Host\": \"httpbin.local\"})",
                  "object_description": "Request object for external domain",
                  "object_id": "request_external_domain",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "time.sleep()",
                  "action_description": "Suspends execution",
                  "action_id": "suspend_execution",
                  "object": "1",
                  "object_description": "Delay duration in seconds",
                  "object_id": "delay_duration",
                  "intention_description": "Pause execution",
                  "intention_id": "pause_execution"
                },
                {
                  "action_api": "session.log()",
                  "action_description": "Writes log message to file or console",
                  "action_id": "write_file_content",
                  "object": "f\"Waiting for the Traefik server: {e}...\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "int(r.status)",
                  "action_description": "Retrieves HTTP response status code",
                  "action_id": "get_http_status",
                  "object": "r.status",
                  "object_description": "Status code",
                  "object_id": "status_code",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "session.log()",
                  "action_description": "Writes log message to file or console",
                  "action_id": "write_file_content",
                  "object": "\"Traefik server is ready to accept connections[...]\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "[\"docker-compose\", \"stop\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "[\"docker\", \"compose\", \"stop\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "dc_process.wait()",
                  "action_description": "Waits for process to complete execution",
                  "action_id": "wait_process_completion",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Wait for events",
                  "intention_id": "wait_for_events"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "kqlmagiccustom-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/kqlmagiccustom-0.1.114.post26.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "my_aad_helper.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/kqlmagiccustom-0.1.114.post26/KqlmagicCustom-0.1.114.post26/azure/Kqlmagic/my_aad_helper.py",
          "line_number": "346",
          "type_description": "clipboard-access",
          "context_snippet": "def acquire_token(self):\n    \"\"\"Acquire tokens from AAD.\"\"\"\n    previous_token = self._current_token\n    try:\n        ...\n        elif self._authentication_method is AuthenticationMethod.aad_code_login:\n            logger().debug(f\"_MyAadHelper::acquire_token - aad/code - resource: '{self._resource}', client: '{self._client_id}'\")\n            code: dict = self._current_adal_context.acquire_user_code(self._resource, self._client_id)\n            url = code[OAuth2DeviceCodeResponseParameters.VERIFICATION_URL]\n            device_code = code[OAuth2DeviceCodeResponseParameters.USER_CODE].strip()\n\n            device_code_login_notification = self._options.get(\"device_code_login_notification\")\n            if device_code_login_notification == \"auto\":\n                if self._options.get(\"notebook_app\") in [\"azuredatastudiosaw\"]:\n                    device_code_login_notification = \"terminal\"\n                elif self._options.get(\"notebook_app\") in [\"ipython\"]:\n                    device_code_login_notification = \"popup_interaction\"\n                elif self._options.get(\"notebook_app\") in [\"visualstudiocode\", \"azuredatastudio\"]:\n                    device_code_login_notification = \"popup_interaction\"\n                elif self._options.get(\"notebook_app\") in [\"nteract\"]:\n\n                    if self._options.get(\"kernel_location\") == \"local\":\n                        # ntreact cannot execute authentication script, workaround using temp_file_server webbrowser\n                        if self._options.get(\"temp_files_server_address\") is not None:\n                            import urllib.parse\n                            indirect_url = f'{self._options.get(\"temp_files_server_address\")}/webbrowser?url={urllib.parse.quote(url)}&kernelid={self._options.get(\"kernel_id\")}'\n                            url = indirect_url\n                            device_code_login_notification = \"popup_interaction\"\n                        else:\n                            device_code_login_notification = \"browser\"\n                    else:\n                        device_code_login_notification = \"terminal\"\n                else:\n                    device_code_login_notification = \"button\"\n\n            if (self._options.get(\"kernel_location\") == \"local\"\n                    or device_code_login_notification in [\"browser\"]\n                    or (device_code_login_notification == \"popup_interaction\" and self._options.get(\"popup_interaction\") == \"webbrowser_open_at_kernel\")):\n                # copy code to local clipboard\n                try:\n                    pyperclip = Dependencies.get_module(\"pyperclip\", dont_throw=True)\n                    if pyperclip is not None:\n                        pyperclip.copy(device_code)\n                except: # pylint: disable=bare-except\n                    pass\n            ...\n",
          "hash_value": "d3f44ec853181dbc418615cc23d33efc",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def acquire_token(self):\n    \"\"\"Acquire tokens from AAD.\"\"\"\n    previous_token = self._current_token\n    try:\n        ...\n        elif self._authentication_method is AuthenticationMethod.aad_code_login:\n            logger().debug(f\"_MyAadHelper::acquire_token - aad/code - resource: '{self._resource}', client: '{self._client_id}'\")\n            code: dict = self._current_adal_context.acquire_user_code(self._resource, self._client_id)\n            url = code[OAuth2DeviceCodeResponseParameters.VERIFICATION_URL]\n            device_code = code[OAuth2DeviceCodeResponseParameters.USER_CODE].strip()\n\n            device_code_login_notification = self._options.get(\"device_code_login_notification\")\n            if device_code_login_notification == \"auto\":\n                if self._options.get(\"notebook_app\") in [\"azuredatastudiosaw\"]:\n                    device_code_login_notification = \"terminal\"\n                elif self._options.get(\"notebook_app\") in [\"ipython\"]:\n                    device_code_login_notification = \"popup_interaction\"\n                elif self._options.get(\"notebook_app\") in [\"visualstudiocode\", \"azuredatastudio\"]:\n                    device_code_login_notification = \"popup_interaction\"\n                elif self._options.get(\"notebook_app\") in [\"nteract\"]:\n\n                    if self._options.get(\"kernel_location\") == \"local\":\n                        # ntreact cannot execute authentication script, workaround using temp_file_server webbrowser\n                        if self._options.get(\"temp_files_server_address\") is not None:\n                            import urllib.parse\n                            indirect_url = f'{self._options.get(\"temp_files_server_address\")}/webbrowser?url={urllib.parse.quote(url)}&kernelid={self._options.get(\"kernel_id\")}'\n                            url = indirect_url\n                            device_code_login_notification = \"popup_interaction\"\n                        else:\n                            device_code_login_notification = \"browser\"\n                    else:\n                        device_code_login_notification = \"terminal\"\n                else:\n                    device_code_login_notification = \"button\"\n\n            if (self._options.get(\"kernel_location\") == \"local\"\n                    or device_code_login_notification in [\"browser\"]\n                    or (device_code_login_notification == \"popup_interaction\" and self._options.get(\"popup_interaction\") == \"webbrowser_open_at_kernel\")):\n                # copy code to local clipboard\n                try:\n                    pyperclip = Dependencies.get_module(\"pyperclip\", dont_throw=True)\n                    if pyperclip is not None:\n                        pyperclip.copy(device_code)\n                except: # pylint: disable=bare-except\n                    pass\n            ...\n",
              "triple_sequences": [
                {
                  "action_api": "self._current_adal_context.acquire_user_code()",
                  "action_description": "Creates HTTP request object with specified URL, data, and headers",
                  "action_id": "create_http_request",
                  "object": "self._resource, self._client_id",
                  "object_description": "API key or token",
                  "object_id": "api_key",
                  "intention_description": "Prepare URL for HTTP request",
                  "intention_id": "prepare_url_http_request"
                },
                {
                  "action_api": "str.strip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "code[OAuth2DeviceCodeResponseParameters.USER_CODE]",
                  "object_description": "API key or token",
                  "object_id": "api_key",
                  "intention_description": "Prepare character for further processing",
                  "intention_id": "prepare_character_processing"
                },
                {
                  "action_api": "self._options.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"device_code_login_notification\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Access configuration value",
                  "intention_id": "access_configuration_value"
                },
                {
                  "action_api": "self._options.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"notebook_app\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Access configuration value",
                  "intention_id": "access_configuration_value"
                },
                {
                  "action_api": "self._options.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"kernel_location\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Access configuration value",
                  "intention_id": "access_configuration_value"
                },
                {
                  "action_api": "self._options.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"temp_files_server_address\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Access configuration value",
                  "intention_id": "access_configuration_value"
                },
                {
                  "action_api": "self._options.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"kernel_id\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Access configuration value",
                  "intention_id": "access_configuration_value"
                },
                {
                  "action_api": "urllib.parse.quote()",
                  "action_description": "Percent-encodes bytes for use in URL",
                  "action_id": "percent_encode_url",
                  "object": "url",
                  "object_description": "URL string",
                  "object_id": "url_string",
                  "intention_description": "Prepare URL for HTTP request",
                  "intention_id": "prepare_url_http_request"
                },
                {
                  "action_api": "Dependencies.get_module()",
                  "action_description": "Dynamically imports specified module",
                  "action_id": "import_dynamic",
                  "object": "\"pyperclip\", dont_throw=True",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "pyperclip.copy()",
                  "action_description": "Copies specified text to system clipboard",
                  "action_id": "copy_to_clipboard",
                  "object": "device_code",
                  "object_description": "API key or token",
                  "object_id": "api_key",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "newrelic-10",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/newrelic-10.8.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "object_names.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/newrelic-10.8.1/newrelic-10.8.1/newrelic/common/object_names.py",
          "line_number": "274",
          "type_description": "obfuscation",
          "context_snippet": "import builtins\n\ndef expand_builtin_exception_name(name):\n    # Convert name to module:name format, if it's a builtin Exception.\n    # Otherwise, return it unchanged.\n\n    try:\n        exception = getattr(builtins, name)\n    except AttributeError:\n        pass\n    else:\n        if type(exception) is type and issubclass(exception, BaseException):\n            return callable_name(exception)\n\n    return name\n\ndef callable_name(object, separator=\":\"):  # noqa: A002\n    \"\"\"Returns a string name identifying the supplied object. This will be\n    of the form 'module:object_path'.\n\n    If object were a function, then the name would be 'module:function. If\n    a class, 'module:class'. If a member function, 'module:class.function'.\n\n    By default the separator between the module path and the object path is\n    ':' but can be overridden if necessary. The convention used by the\n    Python Agent is that of using a ':' so it is clearer which part is the\n    module name and which is the name of the object.\n\n    \"\"\"\n\n    # The details are the module name and path. Join them with\n    # the specified separator.\n\n    return separator.join(object_context(object))\n\ndef object_context(target):\n    \"\"\"Returns a tuple identifying the supplied object. This will be of\n    the form (module, object_path).\n\n    \"\"\"\n\n    # Check whether the target is a functools.partial so we\n    # can actually extract the contained function and use it.\n\n    if isinstance(target, functools.partial):\n        target = target.func\n\n    # Check whether we have previously calculated the name\n    # details for the target object and cached it against the\n    # actual target object.\n\n    details = getattr(target, \"_nr_object_path\", None)\n\n    # Disallow cache lookup for methods. In the case where the method\n    # is defined on a parent class, the name of the parent class is incorrectly\n    # returned. Avoid this by recalculating the details each time.\n\n    if details and not inspect.ismethod(target):\n        return details\n\n    # Check whether the object is actually one of our own\n    # wrapper classes. For these we use the convention that the\n    # attribute _nr_last_object refers to the wrapped object\n    # beneath the wrappers, there possibly being more than one\n    # wrapper. We use the wrapped object when deriving the name\n    # details and so bypass that chained calls that would need\n    # to occur through the wrappers to get the attributes of the\n    # original. For good measure, check that this wrapped object\n    # didn't have the name details cached against it already.\n\n    source = getattr(target, \"_nr_last_object\", None)\n\n    if source:\n        details = getattr(source, \"_nr_object_path\", None)\n\n        if details and not inspect.ismethod(source):\n            return details\n\n    else:\n        source = target\n\n    # If it wasn't cached we generate the name details and then\n    # attempt to cache them against the object.\n    details = _object_context(source)\n\n    try:\n        # If the original target is not the same as the source we\n        # derive the name details from, then we are dealing with\n        # a wrapper.\n\n        if target is not source:\n            # Although the original target could be a bound\n            # wrapper still cache it against it anyway, in case\n            # the bound wrapper is actually cached by the program\n            # and used more than the one time.\n\n            target._nr_object_path = details\n\n        # Finally attempt to cache the name details against what\n        # we derived them from. We may not be able to cache it if\n        # it is a type implemented as C code or an object with\n        # slots, which doesn't allow arbitrary addition of extra\n        # attributes. In that case, if we actually have to rely\n        # on the name details being cached against it and it fails,\n        # we have no choice but to recalculate them every time.\n        #\n        # XXX We could consider for the case where it fails\n        # storing it in a dictionary where the key is a weak\n        # function proxy with a callback to remove the entry if\n        # it ever expires. That would be another lookup we would\n        # have to make and we are already doing a lot so would\n        # have to properly benchmarks overhead before making that\n        # choice.\n\n        source._nr_object_path = details\n\n    except Exception:\n        pass\n\n    return details\n\ndef _object_context(object):  # noqa: A002\n    if inspect.ismethod(object):\n        # In Python 3, ismethod() returns True for bound methods. We\n        # need to distinguish between class methods and instance methods.\n        #\n        # First, test for class methods.\n\n        cname = getattr(object.__self__, \"__qualname__\", None)\n\n        # If it's not a class method, it must be an instance method.\n\n        if cname is None:\n            cname = object.__self__.__class__.__qualname__\n\n        path = f\"{cname}.{object.__name__}\"\n\n    else:\n        # For functions, the __qualname__ attribute gives us the name.\n        # This will be a qualified name including the context in which\n        # the function is defined in, such as an outer function in the\n        # case of a nested function.\n\n        path = getattr(object, \"__qualname__\", None)\n\n        # If there is no __qualname__ it should mean it is a type\n        # object of some sort. In this case we use the name from the\n        # __class__. That also can be nested so need to use the\n        # qualified name.\n\n        if path is None and hasattr(object, \"__class__\"):\n            path = object.__class__.__qualname__\n\n    # Now calculate the name of the module object is defined in.\n\n    owner = None\n\n    if inspect.ismethod(object):\n        if object.__self__ is not None:\n            cname = getattr(object.__self__, \"__name__\", None)\n            if cname is None:\n                owner = object.__self__.__class__  # bound method\n            else:\n                owner = object.__self__  # class method\n\n    mname = _module_name(owner or object)\n\n    return (mname, path)\n\ndef _module_name(object):  # noqa: A002\n    mname = None\n\n    # For the module name we first need to deal with the special\n    # case of getset and member descriptors. In this case we\n    # grab the module name from the class the descriptor was\n    # being used in which is held in __objclass__.\n\n    if hasattr(object, \"__objclass__\"):\n        mname = getattr(object.__objclass__, \"__module__\", None)\n\n    # The standard case is that we can just grab the __module__\n    # attribute from the object.\n\n    if mname is None:\n        mname = getattr(object, \"__module__\", None)\n\n    # An exception to that is builtins or any types which are\n    # implemented in C code. For that we need to grab the module\n    # name from the __class__. In doing this though, we need to\n    # ensure we check for case of a bound method. In that case\n    # we need to grab the module from the class of the instance\n    # to which the method is bound.\n\n    if mname is None:\n        self = getattr(object, \"__self__\", None)\n        if self is not None and hasattr(self, \"__class__\"):\n            mname = getattr(self.__class__, \"__module__\", None)\n\n    if mname is None and hasattr(object, \"__class__\"):\n        mname = getattr(object.__class__, \"__module__\", None)\n\n    # Finally, if the module name isn't in sys.modules, we will\n    # format it within '<>' to denote that it is a generated\n    # class of some sort where a fake namespace was used. This\n    # happens for example with namedtuple classes in Python 3.\n\n    if mname and mname not in sys.modules:\n        mname = f\"<{mname}>\"\n\n    # If unable to derive the module name, fallback to unknown.\n\n    if not mname:\n        mname = \"<unknown>\"\n\n    return mname\n",
          "hash_value": "389c56d26ce23f5ab71120b199d7fa22",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import builtins\n\ndef expand_builtin_exception_name(name):\n    # Convert name to module:name format, if it's a builtin Exception.\n    # Otherwise, return it unchanged.\n\n    try:\n        exception = getattr(builtins, name)\n    except AttributeError:\n        pass\n    else:\n        if type(exception) is type and issubclass(exception, BaseException):\n            return callable_name(exception)\n\n    return name\n\ndef callable_name(object, separator=\":\"):  # noqa: A002\n    \"\"\"Returns a string name identifying the supplied object. This will be\n    of the form 'module:object_path'.\n\n    If object were a function, then the name would be 'module:function. If\n    a class, 'module:class'. If a member function, 'module:class.function'.\n\n    By default the separator between the module path and the object path is\n    ':' but can be overridden if necessary. The convention used by the\n    Python Agent is that of using a ':' so it is clearer which part is the\n    module name and which is the name of the object.\n\n    \"\"\"\n\n    # The details are the module name and path. Join them with\n    # the specified separator.\n\n    return separator.join(object_context(object))\n\ndef object_context(target):\n    \"\"\"Returns a tuple identifying the supplied object. This will be of\n    the form (module, object_path).\n\n    \"\"\"\n\n    # Check whether the target is a functools.partial so we\n    # can actually extract the contained function and use it.\n\n    if isinstance(target, functools.partial):\n        target = target.func\n\n    # Check whether we have previously calculated the name\n    # details for the target object and cached it against the\n    # actual target object.\n\n    details = getattr(target, \"_nr_object_path\", None)\n\n    # Disallow cache lookup for methods. In the case where the method\n    # is defined on a parent class, the name of the parent class is incorrectly\n    # returned. Avoid this by recalculating the details each time.\n\n    if details and not inspect.ismethod(target):\n        return details\n\n    # Check whether the object is actually one of our own\n    # wrapper classes. For these we use the convention that the\n    # attribute _nr_last_object refers to the wrapped object\n    # beneath the wrappers, there possibly being more than one\n    # wrapper. We use the wrapped object when deriving the name\n    # details and so bypass that chained calls that would need\n    # to occur through the wrappers to get the attributes of the\n    # original. For good measure, check that this wrapped object\n    # didn't have the name details cached against it already.\n\n    source = getattr(target, \"_nr_last_object\", None)\n\n    if source:\n        details = getattr(source, \"_nr_object_path\", None)\n\n        if details and not inspect.ismethod(source):\n            return details\n\n    else:\n        source = target\n\n    # If it wasn't cached we generate the name details and then\n    # attempt to cache them against the object.\n    details = _object_context(source)\n\n    try:\n        # If the original target is not the same as the source we\n        # derive the name details from, then we are dealing with\n        # a wrapper.\n\n        if target is not source:\n            # Although the original target could be a bound\n            # wrapper still cache it against it anyway, in case\n            # the bound wrapper is actually cached by the program\n            # and used more than the one time.\n\n            target._nr_object_path = details\n\n        # Finally attempt to cache the name details against what\n        # we derived them from. We may not be able to cache it if\n        # it is a type implemented as C code or an object with\n        # slots, which doesn't allow arbitrary addition of extra\n        # attributes. In that case, if we actually have to rely\n        # on the name details being cached against it and it fails,\n        # we have no choice but to recalculate them every time.\n        #\n        # XXX We could consider for the case where it fails\n        # storing it in a dictionary where the key is a weak\n        # function proxy with a callback to remove the entry if\n        # it ever expires. That would be another lookup we would\n        # have to make and we are already doing a lot so would\n        # have to properly benchmarks overhead before making that\n        # choice.\n\n        source._nr_object_path = details\n\n    except Exception:\n        pass\n\n    return details\n\ndef _object_context(object):  # noqa: A002\n    if inspect.ismethod(object):\n        # In Python 3, ismethod() returns True for bound methods. We\n        # need to distinguish between class methods and instance methods.\n        #\n        # First, test for class methods.\n\n        cname = getattr(object.__self__, \"__qualname__\", None)\n\n        # If it's not a class method, it must be an instance method.\n\n        if cname is None:\n            cname = object.__self__.__class__.__qualname__\n\n        path = f\"{cname}.{object.__name__}\"\n\n    else:\n        # For functions, the __qualname__ attribute gives us the name.\n        # This will be a qualified name including the context in which\n        # the function is defined in, such as an outer function in the\n        # case of a nested function.\n\n        path = getattr(object, \"__qualname__\", None)\n\n        # If there is no __qualname__ it should mean it is a type\n        # object of some sort. In this case we use the name from the\n        # __class__. That also can be nested so need to use the\n        # qualified name.\n\n        if path is None and hasattr(object, \"__class__\"):\n            path = object.__class__.__qualname__\n\n    # Now calculate the name of the module object is defined in.\n\n    owner = None\n\n    if inspect.ismethod(object):\n        if object.__self__ is not None:\n            cname = getattr(object.__self__, \"__name__\", None)\n            if cname is None:\n                owner = object.__self__.__class__  # bound method\n            else:\n                owner = object.__self__  # class method\n\n    mname = _module_name(owner or object)\n\n    return (mname, path)\n\ndef _module_name(object):  # noqa: A002\n    mname = None\n\n    # For the module name we first need to deal with the special\n    # case of getset and member descriptors. In this case we\n    # grab the module name from the class the descriptor was\n    # being used in which is held in __objclass__.\n\n    if hasattr(object, \"__objclass__\"):\n        mname = getattr(object.__objclass__, \"__module__\", None)\n\n    # The standard case is that we can just grab the __module__\n    # attribute from the object.\n\n    if mname is None:\n        mname = getattr(object, \"__module__\", None)\n\n    # An exception to that is builtins or any types which are\n    # implemented in C code. For that we need to grab the module\n    # name from the __class__. In doing this though, we need to\n    # ensure we check for case of a bound method. In that case\n    # we need to grab the module from the class of the instance\n    # to which the method is bound.\n\n    if mname is None:\n        self = getattr(object, \"__self__\", None)\n        if self is not None and hasattr(self, \"__class__\"):\n            mname = getattr(self.__class__, \"__module__\", None)\n\n    if mname is None and hasattr(object, \"__class__\"):\n        mname = getattr(object.__class__, \"__module__\", None)\n\n    # Finally, if the module name isn't in sys.modules, we will\n    # format it within '<>' to denote that it is a generated\n    # class of some sort where a fake namespace was used. This\n    # happens for example with namedtuple classes in Python 3.\n\n    if mname and mname not in sys.modules:\n        mname = f\"<{mname}>\"\n\n    # If unable to derive the module name, fallback to unknown.\n\n    if not mname:\n        mname = \"<unknown>\"\n\n    return mname\n",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Retrieves value of attribute from object",
                  "action_id": "access_attribute_value",
                  "object": "builtins, name",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "type()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "exception",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "issubclass()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "exception, BaseException",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "callable_name()",
                  "action_description": "Constructs Python code string",
                  "action_id": "construct_python_code",
                  "object": "exception",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Construct Python code string",
                  "intention_id": "construct_python_code"
                },
                {
                  "action_api": "separator.join()",
                  "action_description": "Joins characters into string",
                  "action_id": "join_characters_into_string",
                  "object": "object_context(object)",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Join characters into string",
                  "intention_id": "join_characters_into_string"
                },
                {
                  "action_api": "object_context()",
                  "action_description": "Constructs Python code string",
                  "action_id": "construct_python_code",
                  "object": "object",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Construct Python code string",
                  "intention_id": "construct_python_code"
                },
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "target, functools.partial",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Retrieves value of attribute from object",
                  "action_id": "access_attribute_value",
                  "object": "target, '_nr_object_path', None",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "inspect.ismethod()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "target",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Retrieves value of attribute from object",
                  "action_id": "access_attribute_value",
                  "object": "target, '_nr_last_object', None",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Retrieves value of attribute from object",
                  "action_id": "access_attribute_value",
                  "object": "source, '_nr_object_path', None",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "inspect.ismethod()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "source",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "_object_context()",
                  "action_description": "Constructs Python code string",
                  "action_id": "construct_python_code",
                  "object": "source",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Construct Python code string",
                  "intention_id": "construct_python_code"
                },
                {
                  "action_api": "setattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "target, '_nr_object_path', details",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "setattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "source, '_nr_object_path', details",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "inspect.ismethod()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "object",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Retrieves value of attribute from object",
                  "action_id": "access_attribute_value",
                  "object": "object.__self__, '__qualname__', None",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Retrieves value of attribute from object",
                  "action_id": "access_attribute_value",
                  "object": "object.__self__, '__class__', None",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Retrieves value of attribute from object",
                  "action_id": "access_attribute_value",
                  "object": "object, '__name__', None",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Retrieves value of attribute from object",
                  "action_id": "access_attribute_value",
                  "object": "object, '__qualname__', None",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "hasattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "object, '__class__'",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Retrieves value of attribute from object",
                  "action_id": "access_attribute_value",
                  "object": "object.__class__, '__qualname__'",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Retrieves value of attribute from object",
                  "action_id": "access_attribute_value",
                  "object": "object, '__self__', None",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Retrieves value of attribute from object",
                  "action_id": "access_attribute_value",
                  "object": "object.__self__, '__name__', None",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Retrieves value of attribute from object",
                  "action_id": "access_attribute_value",
                  "object": "object.__self__, '__class__', None",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "_module_name()",
                  "action_description": "Constructs Python code string",
                  "action_id": "construct_python_code",
                  "object": "owner or object",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Construct Python code string",
                  "intention_id": "construct_python_code"
                },
                {
                  "action_api": "hasattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "object, '__objclass__'",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Retrieves value of attribute from object",
                  "action_id": "access_attribute_value",
                  "object": "object.__objclass__, '__module__', None",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Retrieves value of attribute from object",
                  "action_id": "access_attribute_value",
                  "object": "object, '__module__', None",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Retrieves value of attribute from object",
                  "action_id": "access_attribute_value",
                  "object": "object, '__self__', None",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "hasattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "self, '__class__'",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Retrieves value of attribute from object",
                  "action_id": "access_attribute_value",
                  "object": "self.__class__, '__module__', None",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "hasattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "object, '__class__'",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Retrieves value of attribute from object",
                  "action_id": "access_attribute_value",
                  "object": "object.__class__, '__module__', None",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "cronitor-4",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/cronitor-4.7.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "monitor.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cronitor-4.7.1/cronitor-4.7.1/cronitor/monitor.py",
          "line_number": "200",
          "type_description": "shady-links",
          "context_snippet": "def _ping_api_url(self):\n    return \"https://cronitor.link/p/{}/{}\".format(self.api_key, self.key)",
          "hash_value": "7c4526658e6bbb264248437cfb4c981f",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def _ping_api_url(self):\n    return \"https://cronitor.link/p/{}/{}\".format(self.api_key, self.key)",
              "triple_sequences": [
                {
                  "action_api": "str.format()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "\"https://cronitor.link/p/{}/{}\", self.api_key, self.key",
                  "object_description": "URL string",
                  "object_id": "url_string",
                  "intention_description": "Prepare URL for HTTP request",
                  "intention_id": "prepare_url_http_request"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "epicscorelibs-7",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/epicscorelibs-7.0.7.99.1.2a1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/epicscorelibs-7.0.7.99.1.2a1/epicscorelibs-7.0.7.99.1.2a1/setup.py",
          "line_number": "538",
          "type_description": "cmd-overwrite",
          "context_snippet": "setup(\n    name='epicscorelibs',\n    version=package_version,\n    description=\"The EPICS Core libraries for use by python modules\",\n    long_description=\"\"\"The EPICS (Experimental Physics and Industrial Control System) core libraries\nfor use by python modules.  Either dynamically with ctypes or statically by compiled extension.\n\"\"\",\n    url='https://github.com/mdavidsaver/epicscorelibs',\n    author='Michael Davidsaver',\n    author_email='mdavidsaver@gmail.com',\n    license='EPICS',\n    classifiers = [\n        'Development Status :: 5 - Production/Stable',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'License :: Freely Distributable',\n        'Intended Audience :: Science/Research',\n        'Topic :: Scientific/Engineering',\n        'Topic :: Software Development :: Libraries',\n        'Topic :: System :: Distributed Computing',\n        'Operating System :: POSIX :: Linux',\n        'Operating System :: MacOS',\n        'Operating System :: Microsoft :: Windows',\n    ],\n    keywords='epics scada',\n    project_urls = {\n        'Source': 'https://github.com/mdavidsaver/epicscorelibs',\n        'Tracker': 'https://github.com/mdavidsaver/epicscorelibs/issues',\n        'Upstream': 'https://epics.anl.gov/',\n    },\n    python_requires='>=2.7',\n    install_requires=[\n        'setuptools', # needed at runtime for 'pkg_resources'\n        'setuptools-dso>=2.11a2', # 'setuptools_dso.runtime' used in 'epicscorelibs.path'\n        'numpy', # needed for epicscorelibs.ca.dbr\n    ],\n\n    packages=[\n        'epicscorelibs',\n        'epicscorelibs.lib',\n        'epicscorelibs.path',\n        'epicscorelibs.test',\n        'epicscorelibs.ca',\n    ],\n    package_dir={'':os.path.join('src','python')},\n    package_data={\n        '':['*.pxd'],\n        'dbd':[\n            'modules/database/src/ioc/*/*.dbd',\n            'modules/database/src/std/*/*.dbd',\n            'modules/database/src/ioc/generated/*.dbd',\n            'modules/database/src/std/generated/*.dbd',\n        ],\n    },\n    ext_modules = [ext],\n    x_dsos = modules,\n    x_headers = headers,\n    x_api_h = [\n        ('libCom', 'modules/libcom/src/libComAPI.h'),\n        ('libCa', 'modules/ca/src/client/libCaAPI.h'),\n        ('dbCore', 'modules/database/src/ioc/dbCoreAPI.h'),\n        ('dbRecStd', 'modules/database/src/std/dbRecStdAPI.h'),\n    ],\n    x_expand = [\n        ('modules/libcom/src/libComVersion.h@', 'modules/libcom/src/libComVersion.h',\n         ['configure/CONFIG_LIBCOM_VERSION']),\n        ('modules/database/src/ioc/databaseVersion.h@', 'modules/database/src/ioc/databaseVersion.h',\n         ['configure/CONFIG_DATABASE_VERSION']),\n        ('modules/pvData/src/pv/pvdVersionNum.h@', 'modules/pvData/src/pv/pvdVersionNum.h',\n         ['modules/pvData/configure/CONFIG_PVDATA_VERSION']),\n        ('modules/pvAccess/src/pva/pvaVersionNum.h@', 'modules/pvAccess/src/pva/pv/pvaVersionNum.h',\n         ['modules/pvAccess/configure/CONFIG_PVACCESS_VERSION']),\n        ('modules/pva2pva/pdbApp/pv/qsrvVersionNum.h@', 'modules/pva2pva/pdbApp/pv/qsrvVersionNum.h',\n         ['modules/pva2pva/configure/CONFIG_QSRV_VERSION']),\n    ],\n    x_errtable = [\n        \"modules/libcom/src/osi/devLib.h\",\n        \"modules/libcom/src/osi/epicsTime.h\",\n        #\"modules/libcom/src/as/asLib.h\",\n        \"modules/libcom/src/misc/epicsStdlib.h\",\n        \"modules/libcom/src/pool/epicsThreadPool.h\",\n        \"modules/libcom/src/error/errMdef.h\",\n    ],\n    cmdclass = {\n        'build_generated': GenVersionError,\n        'build_expand': Expand,\n        'build_apih': MakeAPIH,\n        'install_epics_headers':InstallHeaders,\n    },\n    zip_safe = False,\n)\n\n# Data dependencies:\n# - setup: imported from setuptools_dso\n# - ext: defined as Extension(...)\n# - modules: built by build_module(...)\n# - headers: built and processed by proc_headers(...)\n# - package_version: defined as '7.0.7.99.1.2a1'\n# - GenVersionError, Expand, MakeAPIH, InstallHeaders: defined as custom Command subclasses above\n# - os: imported\n# - get_config_var: imported from epicscorelibs.config\n# - cxxdefs, toolchain_macros: built above\n# - package_dir, package_data, x_api_h, x_expand, x_errtable: all defined above\n# - Distribution: imported from setuptools\n# - DSO, build_dso: imported from setuptools_dso\n# - zip_safe: set to False",
          "hash_value": "e6d5196cebdbeb58c7c40d0668af8652",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "setup(\n    name='epicscorelibs',\n    version=package_version,\n    description=\"The EPICS Core libraries for use by python modules\",\n    long_description=\"\"\"The EPICS (Experimental Physics and Industrial Control System) core libraries\nfor use by python modules.  Either dynamically with ctypes or statically by compiled extension.\n\"\"\",\n    url='https://github.com/mdavidsaver/epicscorelibs',\n    author='Michael Davidsaver',\n    author_email='mdavidsaver@gmail.com',\n    license='EPICS',\n    classifiers = [\n        'Development Status :: 5 - Production/Stable',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'License :: Freely Distributable',\n        'Intended Audience :: Science/Research',\n        'Topic :: Scientific/Engineering',\n        'Topic :: Software Development :: Libraries',\n        'Topic :: System :: Distributed Computing',\n        'Operating System :: POSIX :: Linux',\n        'Operating System :: MacOS',\n        'Operating System :: Microsoft :: Windows',\n    ],\n    keywords='epics scada',\n    project_urls = {\n        'Source': 'https://github.com/mdavidsaver/epicscorelibs',\n        'Tracker': 'https://github.com/mdavidsaver/epicscorelibs/issues',\n        'Upstream': 'https://epics.anl.gov/',\n    },\n    python_requires='>=2.7',\n    install_requires=[\n        'setuptools', # needed at runtime for 'pkg_resources'\n        'setuptools-dso>=2.11a2', # 'setuptools_dso.runtime' used in 'epicscorelibs.path'\n        'numpy', # needed for epicscorelibs.ca.dbr\n    ],\n\n    packages=[\n        'epicscorelibs',\n        'epicscorelibs.lib',\n        'epicscorelibs.path',\n        'epicscorelibs.test',\n        'epicscorelibs.ca',\n    ],\n    package_dir={'':os.path.join('src','python')},\n    package_data={\n        '':['*.pxd'],\n        'dbd':[\n            'modules/database/src/ioc/*/*.dbd',\n            'modules/database/src/std/*/*.dbd',\n            'modules/database/src/ioc/generated/*.dbd',\n            'modules/database/src/std/generated/*.dbd',\n        ],\n    },\n    ext_modules = [ext],\n    x_dsos = modules,\n    x_headers = headers,\n    x_api_h = [\n        ('libCom', 'modules/libcom/src/libComAPI.h'),\n        ('libCa', 'modules/ca/src/client/libCaAPI.h'),\n        ('dbCore', 'modules/database/src/ioc/dbCoreAPI.h'),\n        ('dbRecStd', 'modules/database/src/std/dbRecStdAPI.h'),\n    ],\n    x_expand = [\n        ('modules/libcom/src/libComVersion.h@', 'modules/libcom/src/libComVersion.h',\n         ['configure/CONFIG_LIBCOM_VERSION']),\n        ('modules/database/src/ioc/databaseVersion.h@', 'modules/database/src/ioc/databaseVersion.h',\n         ['configure/CONFIG_DATABASE_VERSION']),\n        ('modules/pvData/src/pv/pvdVersionNum.h@', 'modules/pvData/src/pv/pvdVersionNum.h',\n         ['modules/pvData/configure/CONFIG_PVDATA_VERSION']),\n        ('modules/pvAccess/src/pva/pvaVersionNum.h@', 'modules/pvAccess/src/pva/pv/pvaVersionNum.h',\n         ['modules/pvAccess/configure/CONFIG_PVACCESS_VERSION']),\n        ('modules/pva2pva/pdbApp/pv/qsrvVersionNum.h@', 'modules/pva2pva/pdbApp/pv/qsrvVersionNum.h',\n         ['modules/pva2pva/configure/CONFIG_QSRV_VERSION']),\n    ],\n    x_errtable = [\n        \"modules/libcom/src/osi/devLib.h\",\n        \"modules/libcom/src/osi/epicsTime.h\",\n        #\"modules/libcom/src/as/asLib.h\",\n        \"modules/libcom/src/misc/epicsStdlib.h\",\n        \"modules/libcom/src/pool/epicsThreadPool.h\",\n        \"modules/libcom/src/error/errMdef.h\",\n    ],\n    cmdclass = {\n        'build_generated': GenVersionError,\n        'build_expand': Expand,\n        'build_apih': MakeAPIH,\n        'install_epics_headers':InstallHeaders,\n    },\n    zip_safe = False,\n)\n\n# Data dependencies:\n# - setup: imported from setuptools_dso\n# - ext: defined as Extension(...)\n# - modules: built by build_module(...)\n# - headers: built and processed by proc_headers(...)\n# - package_version: defined as '7.0.7.99.1.2a1'\n# - GenVersionError, Expand, MakeAPIH, InstallHeaders: defined as custom Command subclasses above\n# - os: imported\n# - get_config_var: imported from epicscorelibs.config\n# - cxxdefs, toolchain_macros: built above\n# - package_dir, package_data, x_api_h, x_expand, x_errtable: all defined above\n# - Distribution: imported from setuptools\n# - DSO, build_dso: imported from setuptools_dso\n# - zip_safe: set to False",
              "triple_sequences": [
                {
                  "action_api": "setup()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "{...}",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "('src','python')",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "kerberos-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/kerberos-1.3.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/kerberos-1.3.1/kerberos-1.3.1/setup.py",
          "line_number": "83",
          "type_description": "code-execution",
          "context_snippet": "try:\n    from subprocess import getoutput\nexcept ImportError:\n    from commands import getoutput\n\n...\n\nextra_link_args = getoutput(\"krb5-config --libs gssapi\").split()\n\nextra_compile_args = getoutput(\"krb5-config --cflags gssapi\").split()",
          "hash_value": "f606fce02c02fce5146b08b29bb51a05",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "try:\n    from subprocess import getoutput\nexcept ImportError:\n    from commands import getoutput\n\n...\n\nextra_link_args = getoutput(\"krb5-config --libs gssapi\").split()\n\nextra_compile_args = getoutput(\"krb5-config --cflags gssapi\").split()",
              "triple_sequences": [
                {
                  "action_api": "getoutput()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "krb5-config --libs gssapi",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic string operations (splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "getoutput()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "krb5-config --cflags gssapi",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic string operations (splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "flake8_errmsg-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/flake8_errmsg-0.5.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "__init__.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/flake8_errmsg-0.5.1/flake8_errmsg-0.5.1/src/flake8_errmsg/__init__.py",
          "line_number": "26",
          "type_description": "obfuscation",
          "context_snippet": "import builtins\nimport inspect\n\nBUILTIN_EXCEPTION_LIST = {\n    name\n    for name in dir(builtins)\n    if inspect.isclass(_cls := getattr(builtins, name))\n    and issubclass(_cls, BaseException)\n}",
          "hash_value": "b6be8c17275910a4532e9adf1d71aedc",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import builtins\nimport inspect\n\nBUILTIN_EXCEPTION_LIST = {\n    name\n    for name in dir(builtins)\n    if inspect.isclass(_cls := getattr(builtins, name))\n    and issubclass(_cls, BaseException)\n}",
              "triple_sequences": [
                {
                  "action_api": "dir()",
                  "action_description": "Lists all currently alive threads",
                  "action_id": "list_threads",
                  "object": "builtins",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, name",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "inspect.isclass()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "_cls",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "issubclass()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "_cls, BaseException",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "rauth-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/rauth-0.7.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/rauth-0.7.3/rauth-0.7.3/setup.py",
          "line_number": "24",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport sys\n\nfrom setuptools import setup, find_packages\n\nabout = {}\nwith open('rauth/__about__.py') as f:\n    exec(f.read(), about)\n\nif sys.argv[-1] == 'test':\n    status = os.system('make check')\n    status >>= 8\n    sys.exit(status)\n",
          "hash_value": "3705f425a80cbbf446afc5fe5f14519a",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport sys\n\nfrom setuptools import setup, find_packages\n\nabout = {}\nwith open('rauth/__about__.py') as f:\n    exec(f.read(), about)\n\nif sys.argv[-1] == 'test':\n    status = os.system('make check')\n    status >>= 8\n    sys.exit(status)\n",
              "triple_sequences": [
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "rauth/__about__.py",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "f.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "exec()",
                  "action_description": "Dynamically executes Python code string",
                  "action_id": "exec_python_code",
                  "object": "f.read(), about",
                  "object_description": "Python code string",
                  "object_id": "python_code_string",
                  "intention_description": "Execute Python code",
                  "intention_id": "execute_python_code"
                },
                {
                  "action_api": "os.system()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "make check",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "sys.exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "status",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "gfpgan-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/gfpgan-1.3.8.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gfpgan-1.3.8/gfpgan-1.3.8/setup.py",
          "line_number": "31",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport subprocess\n\ndef get_git_hash():\n\n    def _minimal_ext_cmd(cmd):\n        # construct minimal environment\n        env = {}\n        for k in ['SYSTEMROOT', 'PATH', 'HOME']:\n            v = os.environ.get(k)\n            if v is not None:\n                env[k] = v\n        # LANGUAGE is used on win32\n        env['LANGUAGE'] = 'C'\n        env['LANG'] = 'C'\n        env['LC_ALL'] = 'C'\n        out = subprocess.Popen(cmd, stdout=subprocess.PIPE, env=env).communicate()[0]\n        return out\n\n    try:\n        out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])\n        sha = out.strip().decode('ascii')\n    except OSError:\n        sha = 'unknown'\n\n    return sha",
          "hash_value": "5c5f9a0ff3d27d1291d145856fd9122e",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport subprocess\n\ndef get_git_hash():\n\n    def _minimal_ext_cmd(cmd):\n        # construct minimal environment\n        env = {}\n        for k in ['SYSTEMROOT', 'PATH', 'HOME']:\n            v = os.environ.get(k)\n            if v is not None:\n                env[k] = v\n        # LANGUAGE is used on win32\n        env['LANGUAGE'] = 'C'\n        env['LANG'] = 'C'\n        env['LC_ALL'] = 'C'\n        out = subprocess.Popen(cmd, stdout=subprocess.PIPE, env=env).communicate()[0]\n        return out\n\n    try:\n        out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])\n        sha = out.strip().decode('ascii')\n    except OSError:\n        sha = 'unknown'\n\n    return sha",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "k",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "['git', 'rev-parse', 'HEAD']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.Popen.communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "bytes.strip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "bytes.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "'ascii'",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Decode bytes to string",
                  "intention_id": "decode_bytes_to_string"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pykerberos-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pykerberos-1.2.4.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pykerberos-1.2.4/pykerberos-1.2.4/setup.py",
          "line_number": "32",
          "type_description": "code-execution",
          "context_snippet": "import subprocess\n\ndef check_krb5_config(*options, **kwargs):\n    try:\n        cmd = kwargs.get('command_name', 'krb5-config')\n        process = subprocess.Popen((cmd,) + options, stdout=subprocess.PIPE, universal_newlines=True)\n        output, unused_err = process.communicate()\n        retcode = process.poll()\n        if retcode:\n            raise subprocess.CalledProcessError(retcode, cmd, output=output)\n        return output.split()\n    except OSError as e:\n        if e.errno == 2 and cmd != \"krb5-config.mit\":\n            try:\n                return check_krb5_config(*options, command_name=\"krb5-config.mit\")\n            except OSError as e2:\n                if e2.errno == 2:\n                    raise Exception(\"You are missing krb5-config(.mit)\")",
          "hash_value": "ecf41f9835f9343387c8603c928eba61",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import subprocess\n\ndef check_krb5_config(*options, **kwargs):\n    try:\n        cmd = kwargs.get('command_name', 'krb5-config')\n        process = subprocess.Popen((cmd,) + options, stdout=subprocess.PIPE, universal_newlines=True)\n        output, unused_err = process.communicate()\n        retcode = process.poll()\n        if retcode:\n            raise subprocess.CalledProcessError(retcode, cmd, output=output)\n        return output.split()\n    except OSError as e:\n        if e.errno == 2 and cmd != \"krb5-config.mit\":\n            try:\n                return check_krb5_config(*options, command_name=\"krb5-config.mit\")\n            except OSError as e2:\n                if e2.errno == 2:\n                    raise Exception(\"You are missing krb5-config(.mit)\")",
              "triple_sequences": [
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "(cmd,) + options",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "process.communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "process.poll()",
                  "action_description": "Checks if process has terminated",
                  "action_id": "check_process_terminated",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate process",
                  "intention_id": "terminate_process"
                },
                {
                  "action_api": "output.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "output",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Prepare string processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "check_krb5_config()",
                  "action_description": "Dynamically executes Python code string",
                  "action_id": "exec_python_code",
                  "object": "*options, command_name=\"krb5-config.mit\"",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "sqlobject-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/sqlobject-3.13.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/sqlobject-3.13.0/SQLObject-3.13.0/setup.py",
          "line_number": "11",
          "type_description": "code-execution",
          "context_snippet": "from os.path import abspath, dirname, join\nfrom setuptools import setup\nimport sys\n\nversionpath = join(abspath(dirname(__file__)), 'sqlobject', '__version__.py')\nsqlobject_version = {}\n\nif sys.version_info[:2] == (2, 7):\n    execfile(versionpath, sqlobject_version)  # noqa: F821 'execfile' Py3\n\nelif sys.version_info >= (3, 4):\n    exec(open(versionpath, 'r').read(), sqlobject_version)\n\nelse:\n    raise ImportError(\"SQLObject requires Python 2.7 or 3.4+\")",
          "hash_value": "cc029fedb8cb58be92a21a11671d8e45",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from os.path import abspath, dirname, join\nfrom setuptools import setup\nimport sys\n\nversionpath = join(abspath(dirname(__file__)), 'sqlobject', '__version__.py')\nsqlobject_version = {}\n\nif sys.version_info[:2] == (2, 7):\n    execfile(versionpath, sqlobject_version)  # noqa: F821 'execfile' Py3\n\nelif sys.version_info >= (3, 4):\n    exec(open(versionpath, 'r').read(), sqlobject_version)\n\nelse:\n    raise ImportError(\"SQLObject requires Python 2.7 or 3.4+\")",
              "triple_sequences": [
                {
                  "action_api": "abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "dirname(__file__)",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "abspath(dirname(__file__)), 'sqlobject', '__version__.py'",
                  "object_description": "Directory path with file",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "versionpath, 'r'",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "execfile()",
                  "action_description": "Dynamically executes Python code string",
                  "action_id": "exec_python_code",
                  "object": "versionpath, sqlobject_version",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Execute Python code",
                  "intention_id": "execute_python_code"
                },
                {
                  "action_api": "exec()",
                  "action_description": "Dynamically executes Python code string",
                  "action_id": "exec_python_code",
                  "object": "open(versionpath, 'r').read(), sqlobject_version",
                  "object_description": "Script file content",
                  "object_id": "script_file_content",
                  "intention_description": "Execute Python code",
                  "intention_id": "execute_python_code"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "spacy-4",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/spacy-4.0.0.dev3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/spacy-4.0.0.dev3/spacy-4.0.0.dev3/setup.py",
          "line_number": "129",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport subprocess\n\ndef write_git_info_py(filename=\"spacy/git_info.py\"):\n    def _minimal_ext_cmd(cmd):\n        # construct minimal environment\n        env = {}\n        for k in [\"SYSTEMROOT\", \"PATH\", \"HOME\"]:\n            v = os.environ.get(k)\n            if v is not None:\n                env[k] = v\n        # LANGUAGE is used on win32\n        env[\"LANGUAGE\"] = \"C\"\n        env[\"LANG\"] = \"C\"\n        env[\"LC_ALL\"] = \"C\"\n        out = subprocess.check_output(cmd, stderr=subprocess.STDOUT, env=env)\n        return out\n\n    git_version = \"Unknown\"\n    if Path(\".git\").exists():\n        try:\n            out = _minimal_ext_cmd([\"git\", \"rev-parse\", \"--short\", \"HEAD\"])\n            git_version = out.strip().decode(\"ascii\")\n        except Exception:\n            pass\n    elif Path(filename).exists():\n        # must be a source distribution, use existing version file\n        try:\n            a = open(filename, \"r\")\n            lines = a.readlines()\n            git_version = lines[-1].split('\"')[1]\n        except Exception:\n            pass\n        finally:\n            a.close()\n\n    text = \"\"\"# THIS FILE IS GENERATED FROM SPACY SETUP.PY\n#\nGIT_VERSION = \\\"%(git_version)s\\\"\n\"\"\"\n    a = open(filename, \"w\")\n    try:\n        a.write(text % {\"git_version\": git_version})\n    finally:\n        a.close()",
          "hash_value": "d27a0aa19401fddd2958f57e0436980f",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport subprocess\n\ndef write_git_info_py(filename=\"spacy/git_info.py\"):\n    def _minimal_ext_cmd(cmd):\n        # construct minimal environment\n        env = {}\n        for k in [\"SYSTEMROOT\", \"PATH\", \"HOME\"]:\n            v = os.environ.get(k)\n            if v is not None:\n                env[k] = v\n        # LANGUAGE is used on win32\n        env[\"LANGUAGE\"] = \"C\"\n        env[\"LANG\"] = \"C\"\n        env[\"LC_ALL\"] = \"C\"\n        out = subprocess.check_output(cmd, stderr=subprocess.STDOUT, env=env)\n        return out\n\n    git_version = \"Unknown\"\n    if Path(\".git\").exists():\n        try:\n            out = _minimal_ext_cmd([\"git\", \"rev-parse\", \"--short\", \"HEAD\"])\n            git_version = out.strip().decode(\"ascii\")\n        except Exception:\n            pass\n    elif Path(filename).exists():\n        # must be a source distribution, use existing version file\n        try:\n            a = open(filename, \"r\")\n            lines = a.readlines()\n            git_version = lines[-1].split('\"')[1]\n        except Exception:\n            pass\n        finally:\n            a.close()\n\n    text = \"\"\"# THIS FILE IS GENERATED FROM SPACY SETUP.PY\n#\nGIT_VERSION = \\\"%(git_version)s\\\"\n\"\"\"\n    a = open(filename, \"w\")\n    try:\n        a.write(text % {\"git_version\": git_version})\n    finally:\n        a.close()",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "SYSTEMROOT",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "PATH",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "HOME",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"git\", \"rev-parse\", \"--short\", \"HEAD\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "bytes.strip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "bytes.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "ascii",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "Path(\".git\").exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": ".git",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Determine directory presence",
                  "intention_id": "determine_directory_presence"
                },
                {
                  "action_api": "Path(filename).exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "spacy/git_info.py",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Determine file presence",
                  "intention_id": "determine_file_presence"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "spacy/git_info.py",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "file.readlines()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "file.close()",
                  "action_description": "Closes the opened file",
                  "action_id": "close_file",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Close file",
                  "intention_id": "close_file"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for writing (normal writing, binary writing)",
                  "action_id": "basic_write_operations",
                  "object": "spacy/git_info.py",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                },
                {
                  "action_api": "file.write()",
                  "action_description": "File opening operations for writing (normal writing, binary writing)",
                  "action_id": "basic_write_operations",
                  "object": "# THIS FILE IS GENERATED FROM SPACY SETUP.PY\n#\nGIT_VERSION = \"%(git_version)s\"\n",
                  "object_description": "Script file content",
                  "object_id": "script_file_content",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                },
                {
                  "action_api": "file.close()",
                  "action_description": "Closes the opened file",
                  "action_id": "close_file",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Close file",
                  "intention_id": "close_file"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pywinauto-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pywinauto-0.6.9.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "install_7zip.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pywinauto-0.6.9/pywinauto-0.6.9/examples/install_7zip.py",
          "line_number": "15",
          "type_description": "dll-hijacking",
          "context_snippet": "from __future__ import print_function\nimport sys, os\nos.chdir(os.path.join(os.getcwd(), os.path.dirname(sys.argv[0])))\nimport pywinauto\n\napp = pywinauto.Application().Start(r'msiexec.exe /i 7z920-x64.msi')\n\nWizard = app['7-Zip 9.20 (x64 edition) Setup']\nWizard.NextButton.click()\n\nWizard['I &accept the terms in the License Agreement'].wait('enabled').check_by_click()\nWizard.NextButton.click()\n\nWizard['Custom Setup'].wait('enabled')\nWizard.NextButton.click()\n\nWizard.Install.click()\n\nWizard.Finish.wait('enabled', timeout=30)\nWizard.Finish.click()\nWizard.wait_not('visible')",
          "hash_value": "a3e49c6e6c1d43b622846d32a29953d7",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from __future__ import print_function\nimport sys, os\nos.chdir(os.path.join(os.getcwd(), os.path.dirname(sys.argv[0])))\nimport pywinauto\n\napp = pywinauto.Application().Start(r'msiexec.exe /i 7z920-x64.msi')\n\nWizard = app['7-Zip 9.20 (x64 edition) Setup']\nWizard.NextButton.click()\n\nWizard['I &accept the terms in the License Agreement'].wait('enabled').check_by_click()\nWizard.NextButton.click()\n\nWizard['Custom Setup'].wait('enabled')\nWizard.NextButton.click()\n\nWizard.Install.click()\n\nWizard.Finish.wait('enabled', timeout=30)\nWizard.Finish.click()\nWizard.wait_not('visible')",
              "triple_sequences": [
                {
                  "action_api": "os.getcwd()",
                  "action_description": "Returns current working directory",
                  "action_id": "get_working_dir",
                  "object": "",
                  "object_description": "Current working directory",
                  "object_id": "current_working_directory",
                  "intention_description": "Collect working directory",
                  "intention_id": "collect_working_directory"
                },
                {
                  "action_api": "sys.argv[0]",
                  "action_description": "Retrieves command-line arguments passed to script",
                  "action_id": "get_cmd_args",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access command line arguments",
                  "intention_id": "access_command_line_arguments"
                },
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "sys.argv[0]",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.getcwd(), os.path.dirname(sys.argv[0])",
                  "object_description": "Current working directory",
                  "object_id": "current_working_directory",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.chdir()",
                  "action_description": "Changes current working directory",
                  "action_id": "change_working_dir",
                  "object": "os.path.join(os.getcwd(), os.path.dirname(sys.argv[0]))",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Change working directory",
                  "intention_id": "change_working_directory"
                },
                {
                  "action_api": "pywinauto.Application().Start()",
                  "action_description": "Spawns new process to execute command with shell access",
                  "action_id": "spawn_process_shell",
                  "object": "r'msiexec.exe /i 7z920-x64.msi'",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute file",
                  "intention_id": "execute_file"
                },
                {
                  "action_api": "Wizard.NextButton.click()",
                  "action_description": "Changes window position",
                  "action_id": "change_window_position",
                  "object": "NextButton",
                  "object_description": "Window title string",
                  "object_id": "window_title_string",
                  "intention_description": "Prepare argument for shortcut",
                  "intention_id": "prepare_shortcut_argument"
                },
                {
                  "action_api": "Wizard['I &accept the terms in the License Agreement'].wait('enabled').check_by_click()",
                  "action_description": "Checks if window is enabled",
                  "action_id": "check_window_enabled",
                  "object": "I &accept the terms in the License Agreement",
                  "object_description": "Window title string",
                  "object_id": "window_title_string",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "Wizard.NextButton.click()",
                  "action_description": "Changes window position",
                  "action_id": "change_window_position",
                  "object": "NextButton",
                  "object_description": "Window title string",
                  "object_id": "window_title_string",
                  "intention_description": "Prepare argument for shortcut",
                  "intention_id": "prepare_shortcut_argument"
                },
                {
                  "action_api": "Wizard['Custom Setup'].wait('enabled')",
                  "action_description": "Checks if window is enabled",
                  "action_id": "check_window_enabled",
                  "object": "Custom Setup",
                  "object_description": "Window title string",
                  "object_id": "window_title_string",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "Wizard.NextButton.click()",
                  "action_description": "Changes window position",
                  "action_id": "change_window_position",
                  "object": "NextButton",
                  "object_description": "Window title string",
                  "object_id": "window_title_string",
                  "intention_description": "Prepare argument for shortcut",
                  "intention_id": "prepare_shortcut_argument"
                },
                {
                  "action_api": "Wizard.Install.click()",
                  "action_description": "Changes window position",
                  "action_id": "change_window_position",
                  "object": "Install",
                  "object_description": "Window title string",
                  "object_id": "window_title_string",
                  "intention_description": "Prepare argument for shortcut",
                  "intention_id": "prepare_shortcut_argument"
                },
                {
                  "action_api": "Wizard.Finish.wait('enabled', timeout=30)",
                  "action_description": "Checks if window is enabled",
                  "action_id": "check_window_enabled",
                  "object": "Finish",
                  "object_description": "Window title string",
                  "object_id": "window_title_string",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "Wizard.Finish.click()",
                  "action_description": "Changes window position",
                  "action_id": "change_window_position",
                  "object": "Finish",
                  "object_description": "Window title string",
                  "object_id": "window_title_string",
                  "intention_description": "Prepare argument for shortcut",
                  "intention_id": "prepare_shortcut_argument"
                },
                {
                  "action_api": "Wizard.wait_not('visible')",
                  "action_description": "Checks if window is visible",
                  "action_id": "check_window_visible",
                  "object": "Wizard",
                  "object_description": "Window title string",
                  "object_id": "window_title_string",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "h2o_pysparkling_3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/h2o_pysparkling_3.2-3.46.0.6.post1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "compatibility.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/h2o_pysparkling_3.2-3.46.0.6.post1/h2o_pysparkling_3.2-3.46.0.6.post1/h2o/utils/compatibility.py",
          "line_number": "157",
          "type_description": "obfuscation",
          "context_snippet": "def get_builtin(fn_name):\n    import builtins\n    return getattr(builtins, fn_name, None)",
          "hash_value": "963679988aef866f5c97b4458d548a05",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def get_builtin(fn_name):\n    import builtins\n    return getattr(builtins, fn_name, None)",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "builtins, fn_name, None",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "asammdf-8",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/asammdf-8.2.9.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "tabular_base.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/asammdf-8.2.9/asammdf-8.2.9/src/asammdf/gui/widgets/tabular_base.py",
          "line_number": "2067",
          "type_description": "clipboard-access",
          "context_snippet": "    @timeit\n    def copy(self, header=False):\n        \"\"\"\n        Copy the selected cells to clipboard in an Excel-pasteable format\n        \"\"\"\n        # Get the bounds using the top left and bottom right selected cells\n\n        fmt = self.dataView.model().format\n\n        # Copy from data, columns, or index depending on which has focus\n        if header or self.dataView.hasFocus():\n            selection_model = self.dataView.selectionModel()\n            rows = [i for i in range(self.pgdf.df.cached_size[0]) if selection_model.rowIntersectsSelection(i)]\n            cols = [i for i in range(self.pgdf.df.cached_size[1]) if selection_model.columnIntersectsSelection(i)]\n\n            temp_df = self.pgdf.df\n            df = temp_df.iloc[min(rows) : max(rows) + 1, min(cols) : max(cols) + 1]\n\n        elif self.indexHeader.hasFocus():\n            selection_model = self.indexHeader.selectionModel()\n            rows = [i for i in range(self.pgdf.df.cached_size[0]) if selection_model.rowIntersectsSelection(i)]\n            cols = [i for i in range(self.pgdf.df.cached_size[1]) if selection_model.columnIntersectsSelection(i)]\n\n            temp_df = self.pgdf.df.index.to_frame()\n            df = temp_df.iloc[min(rows) : max(rows) + 1, min(cols) : max(cols) + 1]\n\n        elif self.columnHeader.hasFocus():\n            selection_model = self.columnHeader.selectionModel()\n            rows = [i for i in range(self.pgdf.df.cached_size[0]) if selection_model.rowIntersectsSelection(i)]\n            cols = [i for i in range(self.pgdf.df.cached_size[1]) if selection_model.columnIntersectsSelection(i)]\n\n            # Column header should be horizontal so we transpose\n            temp_df = self.pgdf.df.columns.to_frame().transpose()\n            df = temp_df.iloc[min(rows) : max(rows) + 1, min(cols) : max(cols) + 1]\n        else:\n            return\n\n        if fmt in (\"hex\", \"bin\") and len(df):\n            fmt = \"{:X}\" if fmt == \"hex\" else \"{:b}\"\n\n            for name in df.columns:\n                col = df[name]\n                if isinstance(col.values[0], np.integer):\n                    col = pd.Series([fmt.format(val) for val in col], index=df.index)\n                    df[name] = col\n\n        for name in df.columns:\n            col = df[name]\n            if isinstance(col.values[0], bytes | np.bytes_):\n                df[name] = pd.Series(col, dtype=pd.StringDtype())\n\n        if self.dataView.model().float_precision != -1:\n            decimals = self.dataView.model().float_precision\n            for name in df.columns:\n                col = df[name]\n                if isinstance(col.values[0], np.floating):\n                    col = col.round(decimals)\n                    df[name] = col\n            float_format = f\"%.{decimals}f\"\n        else:\n            float_format = \"%.16f\"\n\n        # If I try to use df.to_clipboard without starting new thread, large selections give access denied error\n        if df.shape == (1, 1):\n            # Special case for single-cell copy, excel=False removes the trailing \\n character.\n            df.to_clipboard(\n                index=False,\n                header=False,\n                excel=False,\n                float_format=float_format,\n            )\n        else:\n            df.to_clipboard(\n                index=header,\n                header=header,\n                float_format=float_format,\n            )",
          "hash_value": "64583a444225a9a7b694cce0b75c6a5f",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "    @timeit\n    def copy(self, header=False):\n        \"\"\"\n        Copy the selected cells to clipboard in an Excel-pasteable format\n        \"\"\"\n        # Get the bounds using the top left and bottom right selected cells\n\n        fmt = self.dataView.model().format\n\n        # Copy from data, columns, or index depending on which has focus\n        if header or self.dataView.hasFocus():\n            selection_model = self.dataView.selectionModel()\n            rows = [i for i in range(self.pgdf.df.cached_size[0]) if selection_model.rowIntersectsSelection(i)]\n            cols = [i for i in range(self.pgdf.df.cached_size[1]) if selection_model.columnIntersectsSelection(i)]\n\n            temp_df = self.pgdf.df\n            df = temp_df.iloc[min(rows) : max(rows) + 1, min(cols) : max(cols) + 1]\n\n        elif self.indexHeader.hasFocus():\n            selection_model = self.indexHeader.selectionModel()\n            rows = [i for i in range(self.pgdf.df.cached_size[0]) if selection_model.rowIntersectsSelection(i)]\n            cols = [i for i in range(self.pgdf.df.cached_size[1]) if selection_model.columnIntersectsSelection(i)]\n\n            temp_df = self.pgdf.df.index.to_frame()\n            df = temp_df.iloc[min(rows) : max(rows) + 1, min(cols) : max(cols) + 1]\n\n        elif self.columnHeader.hasFocus():\n            selection_model = self.columnHeader.selectionModel()\n            rows = [i for i in range(self.pgdf.df.cached_size[0]) if selection_model.rowIntersectsSelection(i)]\n            cols = [i for i in range(self.pgdf.df.cached_size[1]) if selection_model.columnIntersectsSelection(i)]\n\n            # Column header should be horizontal so we transpose\n            temp_df = self.pgdf.df.columns.to_frame().transpose()\n            df = temp_df.iloc[min(rows) : max(rows) + 1, min(cols) : max(cols) + 1]\n        else:\n            return\n\n        if fmt in (\"hex\", \"bin\") and len(df):\n            fmt = \"{:X}\" if fmt == \"hex\" else \"{:b}\"\n\n            for name in df.columns:\n                col = df[name]\n                if isinstance(col.values[0], np.integer):\n                    col = pd.Series([fmt.format(val) for val in col], index=df.index)\n                    df[name] = col\n\n        for name in df.columns:\n            col = df[name]\n            if isinstance(col.values[0], bytes | np.bytes_):\n                df[name] = pd.Series(col, dtype=pd.StringDtype())\n\n        if self.dataView.model().float_precision != -1:\n            decimals = self.dataView.model().float_precision\n            for name in df.columns:\n                col = df[name]\n                if isinstance(col.values[0], np.floating):\n                    col = col.round(decimals)\n                    df[name] = col\n            float_format = f\"%.{decimals}f\"\n        else:\n            float_format = \"%.16f\"\n\n        # If I try to use df.to_clipboard without starting new thread, large selections give access denied error\n        if df.shape == (1, 1):\n            # Special case for single-cell copy, excel=False removes the trailing \\n character.\n            df.to_clipboard(\n                index=False,\n                header=False,\n                excel=False,\n                float_format=float_format,\n            )\n        else:\n            df.to_clipboard(\n                index=header,\n                header=header,\n                float_format=float_format,\n            )",
              "triple_sequences": [
                {
                  "action_api": "df.to_clipboard()",
                  "action_description": "Copies specified text to system clipboard",
                  "action_id": "copy_to_clipboard",
                  "object": "Excel-pasteable formatted DataFrame (single cell or selection)",
                  "object_description": "Clipboard content data",
                  "object_id": "clipboard_data",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "detect_secrets-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/detect_secrets-1.5.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "telegram_token.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/detect_secrets-1.5.0/detect_secrets-1.5.0/detect_secrets/plugins/telegram_token.py",
          "line_number": "23",
          "type_description": "shady-links",
          "context_snippet": "import requests\n\nfrom ..constants import VerifiedResult\nfrom detect_secrets.plugins.base import RegexBasedDetector\n\nclass TelegramBotTokenDetector(RegexBasedDetector):\n    \"\"\"Scans for Telegram bot tokens.\"\"\"\n    secret_type = 'Telegram Bot Token'\n\n    denylist = [\n        # refs https://core.telegram.org/bots/api#authorizing-your-bot\n        re.compile(r'\\d{8,10}:[0-9A-Za-z_-]{35}'),\n    ]\n\n    def verify(self, secret: str) -> VerifiedResult:  # pragma: no cover\n        response = requests.get(\n            'https://api.telegram.org/bot{}/getMe'.format(\n                secret,\n            ),\n        )\n        return (\n            VerifiedResult.VERIFIED_TRUE\n            if response.status_code == 200\n            else VerifiedResult.VERIFIED_FALSE\n        )",
          "hash_value": "64f1f94dff7025313146e1bd6e560224",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import requests\n\nfrom ..constants import VerifiedResult\nfrom detect_secrets.plugins.base import RegexBasedDetector\n\nclass TelegramBotTokenDetector(RegexBasedDetector):\n    \"\"\"Scans for Telegram bot tokens.\"\"\"\n    secret_type = 'Telegram Bot Token'\n\n    denylist = [\n        # refs https://core.telegram.org/bots/api#authorizing-your-bot\n        re.compile(r'\\d{8,10}:[0-9A-Za-z_-]{35}'),\n    ]\n\n    def verify(self, secret: str) -> VerifiedResult:  # pragma: no cover\n        response = requests.get(\n            'https://api.telegram.org/bot{}/getMe'.format(\n                secret,\n            ),\n        )\n        return (\n            VerifiedResult.VERIFIED_TRUE\n            if response.status_code == 200\n            else VerifiedResult.VERIFIED_FALSE\n        )",
              "triple_sequences": [
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP GET request to URL",
                  "action_id": "open_url_get",
                  "object": "'https://api.telegram.org/bot{}/getMe'.format(secret)",
                  "object_description": "Telegram API endpoint",
                  "object_id": "telegram_api_endpoint",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "kodexa-7",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/kodexa-7.4.414330611518.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "client.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/kodexa-7.4.414330611518/kodexa-7.4.414330611518/kodexa/platform/client.py",
          "line_number": "6775",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "    @staticmethod\n    def login(url, token):\n        \"\"\"\n        A static method to login to the Kodexa platform.\n\n        Args:\n            url (str): The URL for the Kodexa platform.\n            token (str): The email for the user.\n\n        Returns:\n            KodexaClient: A KodexaClient instance.\n\n        Raises:\n            Exception: If the status code is not 200.\n        \"\"\"\n\n        obj_response = requests.get(\n            f\"{url}/api/account/me\",\n            headers={\"content-type\": \"application/json\",\n                     \"x-access-token\": token,\n                     \"cf-access-token\": os.environ.get(\"CF_TOKEN\", \"\")}\n        )\n        if obj_response.status_code == 200:\n            return KodexaClient(url, obj_response.text)\n\n        raise Exception(f\"Check your URL and password [{obj_response.status_code}]\")",
          "hash_value": "aa7d5a1365310aaec1f5ff19dce5945a",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "    @staticmethod\n    def login(url, token):\n        \"\"\"\n        A static method to login to the Kodexa platform.\n\n        Args:\n            url (str): The URL for the Kodexa platform.\n            token (str): The email for the user.\n\n        Returns:\n            KodexaClient: A KodexaClient instance.\n\n        Raises:\n            Exception: If the status code is not 200.\n        \"\"\"\n\n        obj_response = requests.get(\n            f\"{url}/api/account/me\",\n            headers={\"content-type\": \"application/json\",\n                     \"x-access-token\": token,\n                     \"cf-access-token\": os.environ.get(\"CF_TOKEN\", \"\")}\n        )\n        if obj_response.status_code == 200:\n            return KodexaClient(url, obj_response.text)\n\n        raise Exception(f\"Check your URL and password [{obj_response.status_code}]\")",
              "triple_sequences": [
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP GET request to URL",
                  "action_id": "open_url_get",
                  "object": "f\"{url}/api/account/me\"",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"CF_TOKEN\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "saneyaml-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/saneyaml-0.6.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "utils_dejacode.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/saneyaml-0.6.1/saneyaml-0.6.1/etc/scripts/utils_dejacode.py",
          "line_number": "50",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "import requests\n\nDEJACODE_API_KEY = os.environ.get(\"DEJACODE_API_KEY\", \"\")\nDEJACODE_API_URL = os.environ.get(\"DEJACODE_API_URL\", \"\")\n\nDEJACODE_API_URL_PACKAGES = f\"{DEJACODE_API_URL}packages/\"\nDEJACODE_API_HEADERS = {\n    \"Authorization\": \"Token {}\".format(DEJACODE_API_KEY),\n    \"Accept\": \"application/json; indent=4\",\n}\n\ndef can_do_api_calls():\n    if not DEJACODE_API_KEY and DEJACODE_API_URL:\n        print(\"DejaCode DEJACODE_API_KEY and DEJACODE_API_URL not configured. Doing nothing\")\n        return False\n    else:\n        return True\n\ndef fetch_dejacode_packages(params):\n    \"\"\"\n    Return a list of package data mappings calling the package API with using\n    `params` or an empty list.\n    \"\"\"\n    if not can_do_api_calls():\n        return []\n\n    response = requests.get(\n        DEJACODE_API_URL_PACKAGES,\n        params=params,\n        headers=DEJACODE_API_HEADERS,\n    )\n\n    return response.json()[\"results\"]",
          "hash_value": "15c5f6856345eae5ab4375652f12184b",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import requests\n\nDEJACODE_API_KEY = os.environ.get(\"DEJACODE_API_KEY\", \"\")\nDEJACODE_API_URL = os.environ.get(\"DEJACODE_API_URL\", \"\")\n\nDEJACODE_API_URL_PACKAGES = f\"{DEJACODE_API_URL}packages/\"\nDEJACODE_API_HEADERS = {\n    \"Authorization\": \"Token {}\".format(DEJACODE_API_KEY),\n    \"Accept\": \"application/json; indent=4\",\n}\n\ndef can_do_api_calls():\n    if not DEJACODE_API_KEY and DEJACODE_API_URL:\n        print(\"DejaCode DEJACODE_API_KEY and DEJACODE_API_URL not configured. Doing nothing\")\n        return False\n    else:\n        return True\n\ndef fetch_dejacode_packages(params):\n    \"\"\"\n    Return a list of package data mappings calling the package API with using\n    `params` or an empty list.\n    \"\"\"\n    if not can_do_api_calls():\n        return []\n\n    response = requests.get(\n        DEJACODE_API_URL_PACKAGES,\n        params=params,\n        headers=DEJACODE_API_HEADERS,\n    )\n\n    return response.json()[\"results\"]",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"DEJACODE_API_KEY\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"DEJACODE_API_URL\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "DEJACODE_API_URL_PACKAGES, params=params, headers=DEJACODE_API_HEADERS",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "response.json()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "",
                  "object_description": "JSON string",
                  "object_id": "json_string",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "sqlmesh-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/sqlmesh-0.171.3.dev4.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "controller.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/sqlmesh-0.171.3.dev4/sqlmesh-0.171.3.dev4/sqlmesh/integrations/github/cicd/controller.py",
          "line_number": "517",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "def _get_merge_state_status(self) -> MergeStateStatus:\n    \"\"\"\n    This feature is currently in preview and therefore not available in the python module.\n    So we query GraphQL directly instead.\n    \"\"\"\n    headers = {\n        \"Authorization\": f\"Bearer {self._token}\",\n        \"Accept\": \"application/vnd.github.merge-info-preview+json\",\n    }\n    query = f\"\"\"{{\n        repository(owner: \"{self._event.pull_request_info.owner}\", name: \"{self._event.pull_request_info.repo}\") {{\n            pullRequest(number: {self._event.pull_request_info.pr_number}) {{\n                title\n                state\n                mergeStateStatus\n            }}\n        }}\n    }}\"\"\"\n    request = requests.post(\n        os.environ[\"GITHUB_GRAPHQL_URL\"],\n        json={\"query\": query},\n        headers=headers,\n    )\n    if request.status_code == 200:\n        merge_status = MergeStateStatus(\n            request.json()[\"data\"][\"repository\"][\"pullRequest\"][\"mergeStateStatus\"].lower()\n        )\n        logger.debug(f\"Merge state status: {merge_status.value}\")\n        return merge_status\n    raise CICDBotError(f\"Unable to get merge state status. Error: {request.text}\")",
          "hash_value": "33df3e40ce9d71c6b0e3c1f752cbc73f",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def _get_merge_state_status(self) -> MergeStateStatus:\n    \"\"\"\n    This feature is currently in preview and therefore not available in the python module.\n    So we query GraphQL directly instead.\n    \"\"\"\n    headers = {\n        \"Authorization\": f\"Bearer {self._token}\",\n        \"Accept\": \"application/vnd.github.merge-info-preview+json\",\n    }\n    query = f\"\"\"{{\n        repository(owner: \"{self._event.pull_request_info.owner}\", name: \"{self._event.pull_request_info.repo}\") {{\n            pullRequest(number: {self._event.pull_request_info.pr_number}) {{\n                title\n                state\n                mergeStateStatus\n            }}\n        }}\n    }}\"\"\"\n    request = requests.post(\n        os.environ[\"GITHUB_GRAPHQL_URL\"],\n        json={\"query\": query},\n        headers=headers,\n    )\n    if request.status_code == 200:\n        merge_status = MergeStateStatus(\n            request.json()[\"data\"][\"repository\"][\"pullRequest\"][\"mergeStateStatus\"].lower()\n        )\n        logger.debug(f\"Merge state status: {merge_status.value}\")\n        return merge_status\n    raise CICDBotError(f\"Unable to get merge state status. Error: {request.text}\")",
              "triple_sequences": [
                {
                  "action_api": "requests.post()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "os.environ[\"GITHUB_GRAPHQL_URL\"], json={\"query\": query}, headers=headers",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "request.status_code",
                  "action_description": "Retrieves HTTP response status code",
                  "action_id": "get_http_status",
                  "object": "request",
                  "object_description": "HTTP response content from remote server",
                  "object_id": "http_response_remote_content",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "request.json()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "request",
                  "object_description": "HTTP response content from remote server",
                  "object_id": "http_response_remote_content",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "logger.debug()",
                  "action_description": "Process HTTP response content",
                  "action_id": "process_http_response",
                  "object": "f\"Merge state status: {merge_status.value}\"",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "tcod-18",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/tcod-18.0.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/tcod-18.0.0/tcod-18.0.0/setup.py",
          "line_number": "45",
          "type_description": "code-execution",
          "context_snippet": "import platform\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nSDL_VERSION_NEEDED = (2, 0, 5)\n\ndef check_sdl_version() -> None:\n    \"\"\"Check the local SDL version on Linux distributions.\"\"\"\n    if not sys.platform.startswith(\"linux\"):\n        return\n    needed_version = \"{}.{}.{}\".format(*SDL_VERSION_NEEDED)\n    try:\n        sdl_version_str = subprocess.check_output([\"sdl2-config\", \"--version\"], universal_newlines=True).strip()  # noqa: S603, S607\n    except FileNotFoundError as exc:\n        msg = (\n            f\"libsdl2-dev or equivalent must be installed on your system and must be at least version {needed_version}.\"\n            \"\\nsdl2-config must be on PATH.\"\n        )\n        raise RuntimeError(msg) from exc\n    print(f\"Found SDL {sdl_version_str}.\")\n    sdl_version = tuple(int(s) for s in sdl_version_str.split(\".\"))\n    if sdl_version < SDL_VERSION_NEEDED:\n        msg = f\"SDL version must be at least {needed_version}, (found {sdl_version_str})\"\n        raise RuntimeError(msg)",
          "hash_value": "ff1841bd52d37eb95355643d08488389",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import platform\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nSDL_VERSION_NEEDED = (2, 0, 5)\n\ndef check_sdl_version() -> None:\n    \"\"\"Check the local SDL version on Linux distributions.\"\"\"\n    if not sys.platform.startswith(\"linux\"):\n        return\n    needed_version = \"{}.{}.{}\".format(*SDL_VERSION_NEEDED)\n    try:\n        sdl_version_str = subprocess.check_output([\"sdl2-config\", \"--version\"], universal_newlines=True).strip()  # noqa: S603, S607\n    except FileNotFoundError as exc:\n        msg = (\n            f\"libsdl2-dev or equivalent must be installed on your system and must be at least version {needed_version}.\"\n            \"\\nsdl2-config must be on PATH.\"\n        )\n        raise RuntimeError(msg) from exc\n    print(f\"Found SDL {sdl_version_str}.\")\n    sdl_version = tuple(int(s) for s in sdl_version_str.split(\".\"))\n    if sdl_version < SDL_VERSION_NEEDED:\n        msg = f\"SDL version must be at least {needed_version}, (found {sdl_version_str})\"\n        raise RuntimeError(msg)",
              "triple_sequences": [
                {
                  "action_api": "sys.platform.startswith()",
                  "action_description": "Retrieves operating system identifier",
                  "action_id": "get_os_id",
                  "object": "sys.platform",
                  "object_description": "Operating system identifier",
                  "object_id": "",
                  "intention_description": "Determine operating system",
                  "intention_id": "get_operating_system_name"
                },
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"sdl2-config\", \"--version\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "str.strip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "sdl_version_str",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "sdl_version_str.split(\".\")",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "int()",
                  "action_description": "Converts string to integer",
                  "action_id": "convert_string_to_integer",
                  "object": "s",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare character for further processing",
                  "intention_id": "prepare_character_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "modin-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/modin-0.32.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "io.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/modin-0.32.0/modin-0.32.0/modin/core/io/io.py",
          "line_number": "344",
          "type_description": "clipboard-access",
          "context_snippet": "@classmethod\n@_inherit_docstrings(pandas.read_clipboard, apilink=\"pandas.read_clipboard\")\n@doc(\n    _doc_default_io_method,\n    summary=\"Read text from clipboard into query compiler\",\n    returns=_doc_returns_qc,\n)\ndef read_clipboard(cls, sep=r\"\\s+\", **kwargs):  # pragma: no cover # noqa: PR01\n    ErrorMessage.default_to_pandas(\"`read_clipboard`\")\n    return cls.from_pandas(pandas.read_clipboard(sep=sep, **kwargs))",
          "hash_value": "91bb64165abe072bed9ab1e2dfe473e9",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "@classmethod\n@_inherit_docstrings(pandas.read_clipboard, apilink=\"pandas.read_clipboard\")\n@doc(\n    _doc_default_io_method,\n    summary=\"Read text from clipboard into query compiler\",\n    returns=_doc_returns_qc,\n)\ndef read_clipboard(cls, sep=r\"\\s+\", **kwargs):  # pragma: no cover # noqa: PR01\n    ErrorMessage.default_to_pandas(\"`read_clipboard`\")\n    return cls.from_pandas(pandas.read_clipboard(sep=sep, **kwargs))",
              "triple_sequences": [
                {
                  "action_api": "pandas.read_clipboard()",
                  "action_description": "Retrieves text from system clipboard",
                  "action_id": "get_clipboard_text",
                  "object": "sep=sep, **kwargs",
                  "object_description": "Clipboard content data",
                  "object_id": "clipboard_data",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "gallery_dl-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/gallery_dl-1.29.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "everia.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gallery_dl-1.29.3/gallery_dl-1.29.3/gallery_dl/extractor/everia.py",
          "line_number": "50",
          "type_description": "shady-links",
          "context_snippet": "class EveriaPostExtractor(EveriaExtractor):\n    subcategory = \"post\"\n    directory_fmt = (\"{category}\", \"{title}\")\n    archive_fmt = \"{post_url}_{num}\"\n    pattern = BASE_PATTERN + r\"(/\\d{4}/\\d{2}/\\d{2}/[^/?#]+)\"\n    example = \"https://everia.club/0000/00/00/TITLE\"\n\n    def items(self):\n        url = self.root + self.groups[0]\n        page = self.request(url).text\n        content = text.extr(page, 'itemprop=\"text\">', \"</div>\")\n        urls = re.findall(r'img.*?src=\"([^\"]+)', content)\n\n        data = {\n            \"title\": text.unescape(\n                text.extr(page, 'itemprop=\"headline\">', \"</h1>\")),\n            \"tags\": list(text.extract_iter(page, 'rel=\"tag\">', \"</a>\")),\n            \"post_url\": url,\n            \"post_category\": text.extr(\n                page, \"post-in-category-\", \" \").capitalize(),\n            \"count\": len(urls),\n        }\n\n        yield Message.Directory, data\n        for data[\"num\"], url in enumerate(urls, 1):\n            yield Message.Url, url, text.nameext_from_url(url, data)",
          "hash_value": "1c9485dbf73b3ec540e38faaba6e5431",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class EveriaPostExtractor(EveriaExtractor):\n    subcategory = \"post\"\n    directory_fmt = (\"{category}\", \"{title}\")\n    archive_fmt = \"{post_url}_{num}\"\n    pattern = BASE_PATTERN + r\"(/\\d{4}/\\d{2}/\\d{2}/[^/?#]+)\"\n    example = \"https://everia.club/0000/00/00/TITLE\"\n\n    def items(self):\n        url = self.root + self.groups[0]\n        page = self.request(url).text\n        content = text.extr(page, 'itemprop=\"text\">', \"</div>\")\n        urls = re.findall(r'img.*?src=\"([^\"]+)', content)\n\n        data = {\n            \"title\": text.unescape(\n                text.extr(page, 'itemprop=\"headline\">', \"</h1>\")),\n            \"tags\": list(text.extract_iter(page, 'rel=\"tag\">', \"</a>\")),\n            \"post_url\": url,\n            \"post_category\": text.extr(\n                page, \"post-in-category-\", \" \").capitalize(),\n            \"count\": len(urls),\n        }\n\n        yield Message.Directory, data\n        for data[\"num\"], url in enumerate(urls, 1):\n            yield Message.Url, url, text.nameext_from_url(url, data)",
              "triple_sequences": [
                {
                  "action_api": "self.request()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "self.root + self.groups[0]",
                  "object_description": "External domain",
                  "object_id": "external_domain",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "str.text",
                  "action_description": "Process HTTP response content",
                  "action_id": "process_http_response",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Decode downloaded content",
                  "intention_id": "decode_downloaded_content"
                },
                {
                  "action_api": "text.extr()",
                  "action_description": "Extracts current call stack as FrameSummary objects",
                  "action_id": "extract_call_stack",
                  "object": "page, 'itemprop=\"text\">', \"</div>\"",
                  "object_description": "Script file content",
                  "object_id": "script_file_content",
                  "intention_description": "Extract structured file data",
                  "intention_id": "extract_structured_file_data"
                },
                {
                  "action_api": "re.findall()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "r'img.*?src=\"([^\"]+)'",
                  "object_description": "Regular expression pattern",
                  "object_id": "regex_pattern",
                  "intention_description": "Extract structured file data",
                  "intention_id": "extract_structured_file_data"
                },
                {
                  "action_api": "text.unescape()",
                  "action_description": "Decode obfuscated data",
                  "action_id": "decode_obfuscated_data",
                  "object": "text.extr(page, 'itemprop=\"headline\">', \"</h1>\")",
                  "object_description": "Decoded obfuscated data",
                  "object_id": "decoded_obfuscated_data",
                  "intention_description": "Decode obfuscated data",
                  "intention_id": "decode_obfuscated_data"
                },
                {
                  "action_api": "text.extract_iter()",
                  "action_description": "Extracts current call stack as FrameSummary objects",
                  "action_id": "extract_call_stack",
                  "object": "page, 'rel=\"tag\">', \"</a>\"",
                  "object_description": "Script file content",
                  "object_id": "script_file_content",
                  "intention_description": "Extract structured file data",
                  "intention_id": "extract_structured_file_data"
                },
                {
                  "action_api": "text.extr()",
                  "action_description": "Extracts current call stack as FrameSummary objects",
                  "action_id": "extract_call_stack",
                  "object": "page, \"post-in-category-\", \" \"",
                  "object_description": "Script file content",
                  "object_id": "script_file_content",
                  "intention_description": "Extract structured file data",
                  "intention_id": "extract_structured_file_data"
                },
                {
                  "action_api": "len()",
                  "action_description": "Generate product of sequence",
                  "action_id": "generate_sequence_product",
                  "object": "urls",
                  "object_description": "URL string",
                  "object_id": "url_string",
                  "intention_description": "Generate sequence product",
                  "intention_id": "generate_sequence_product"
                },
                {
                  "action_api": "enumerate()",
                  "action_description": "Generate product of sequence",
                  "action_id": "generate_sequence_product",
                  "object": "urls, 1",
                  "object_description": "URL string",
                  "object_id": "url_string",
                  "intention_description": "Generate sequence product",
                  "intention_id": "generate_sequence_product"
                },
                {
                  "action_api": "text.nameext_from_url()",
                  "action_description": "Path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "url, data",
                  "object_description": "URL string",
                  "object_id": "url_string",
                  "intention_description": "Prepare path for file operations",
                  "intention_id": "prepare_path_file_operations"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pandas_gbq-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pandas_gbq-0.28.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "gbq.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pandas_gbq-0.28.0/pandas_gbq-0.28.0/pandas_gbq/gbq.py",
          "line_number": "516",
          "type_description": "shady-links",
          "context_snippet": "    def _download_results(\n        self,\n        rows_iter,\n        max_results=None,\n        progress_bar_type=None,\n        user_dtypes=None,\n    ):\n        # No results are desired, so don't bother downloading anything.\n        if max_results == 0:\n            return None\n\n        if user_dtypes is None:\n            user_dtypes = {}\n\n        create_bqstorage_client = self.use_bqstorage_api\n        if max_results is not None:\n            create_bqstorage_client = False\n\n        # If we're downloading a large table, BigQuery DataFrames might be a\n        # better fit. Not all code paths will populate rows_iter._table, but\n        # if it's not populated that means we are working with a small result\n        # set.\n        if (table_ref := getattr(rows_iter, \"_table\", None)) is not None:\n            table = self.client.get_table(table_ref)\n            if (\n                isinstance((num_bytes := table.num_bytes), int)\n                and num_bytes > pandas_gbq.constants.BYTES_TO_RECOMMEND_BIGFRAMES\n            ):\n                num_gib = num_bytes / pandas_gbq.constants.BYTES_IN_GIB\n                warnings.warn(\n                    f\"Recommendation: Your results are {num_gib:.1f} GiB. \"\n                    \"Consider using BigQuery DataFrames (https://bit.ly/bigframes-intro)\"\n                    \"to process large results with pandas compatible APIs with transparent SQL \"\n                    \"pushdown to BigQuery engine. This provides an opportunity to save on costs \"\n                    \"and improve performance. \"\n                    \"Please reach out to bigframes-feedback@google.com with any \"\n                    \"questions or concerns. To disable this message, run \"\n                    \"warnings.simplefilter('ignore', category=pandas_gbq.exceptions.LargeResultsWarning)\",\n                    category=pandas_gbq.exceptions.LargeResultsWarning,\n                    # user's code\n                    # -> read_gbq\n                    # -> run_query\n                    # -> download_results\n                    stacklevel=4,\n                )\n\n        try:\n            schema_fields = [field.to_api_repr() for field in rows_iter.schema]\n            conversion_dtypes = _bqschema_to_nullsafe_dtypes(schema_fields)\n            conversion_dtypes.update(user_dtypes)\n            df = rows_iter.to_dataframe(\n                dtypes=conversion_dtypes,\n                progress_bar_type=progress_bar_type,\n                create_bqstorage_client=create_bqstorage_client,\n            )\n        except self.http_error as ex:\n            self.process_http_error(ex)\n\n        df = _finalize_dtypes(df, schema_fields)\n\n        logger.debug(\"Got {} rows.\\n\".format(rows_iter.total_rows))\n        return df",
          "hash_value": "15d352b510897ce494357bf79ade9792",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "    def _download_results(\n        self,\n        rows_iter,\n        max_results=None,\n        progress_bar_type=None,\n        user_dtypes=None,\n    ):\n        # No results are desired, so don't bother downloading anything.\n        if max_results == 0:\n            return None\n\n        if user_dtypes is None:\n            user_dtypes = {}\n\n        create_bqstorage_client = self.use_bqstorage_api\n        if max_results is not None:\n            create_bqstorage_client = False\n\n        # If we're downloading a large table, BigQuery DataFrames might be a\n        # better fit. Not all code paths will populate rows_iter._table, but\n        # if it's not populated that means we are working with a small result\n        # set.\n        if (table_ref := getattr(rows_iter, \"_table\", None)) is not None:\n            table = self.client.get_table(table_ref)\n            if (\n                isinstance((num_bytes := table.num_bytes), int)\n                and num_bytes > pandas_gbq.constants.BYTES_TO_RECOMMEND_BIGFRAMES\n            ):\n                num_gib = num_bytes / pandas_gbq.constants.BYTES_IN_GIB\n                warnings.warn(\n                    f\"Recommendation: Your results are {num_gib:.1f} GiB. \"\n                    \"Consider using BigQuery DataFrames (https://bit.ly/bigframes-intro)\"\n                    \"to process large results with pandas compatible APIs with transparent SQL \"\n                    \"pushdown to BigQuery engine. This provides an opportunity to save on costs \"\n                    \"and improve performance. \"\n                    \"Please reach out to bigframes-feedback@google.com with any \"\n                    \"questions or concerns. To disable this message, run \"\n                    \"warnings.simplefilter('ignore', category=pandas_gbq.exceptions.LargeResultsWarning)\",\n                    category=pandas_gbq.exceptions.LargeResultsWarning,\n                    # user's code\n                    # -> read_gbq\n                    # -> run_query\n                    # -> download_results\n                    stacklevel=4,\n                )\n\n        try:\n            schema_fields = [field.to_api_repr() for field in rows_iter.schema]\n            conversion_dtypes = _bqschema_to_nullsafe_dtypes(schema_fields)\n            conversion_dtypes.update(user_dtypes)\n            df = rows_iter.to_dataframe(\n                dtypes=conversion_dtypes,\n                progress_bar_type=progress_bar_type,\n                create_bqstorage_client=create_bqstorage_client,\n            )\n        except self.http_error as ex:\n            self.process_http_error(ex)\n\n        df = _finalize_dtypes(df, schema_fields)\n\n        logger.debug(\"Got {} rows.\\n\".format(rows_iter.total_rows))\n        return df",
              "triple_sequences": [
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "rows_iter, \"_table\", None",
                  "object_description": "Local file or directory name",
                  "object_id": "local_file_or_directory_name",
                  "intention_description": "Determine_directory_presence",
                  "intention_id": "determine_directory_presence"
                },
                {
                  "action_api": "self.client.get_table()",
                  "action_description": "Retrieves value and data type for registry value",
                  "action_id": "get_registry_value",
                  "object": "table_ref",
                  "object_description": "Registry value name",
                  "object_id": "registry_value_name",
                  "intention_description": "Access_attribute_value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "table.num_bytes, int",
                  "object_description": "Character code array",
                  "object_id": "character_code_array",
                  "intention_description": "Prepare_data_processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "warnings.warn()",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "f\"Recommendation: Your results are {num_gib:.1f} GiB. ...\", category=pandas_gbq.exceptions.LargeResultsWarning, stacklevel=4",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access_attribute_value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "field.to_api_repr()",
                  "action_description": "Retrieves value and data type for registry value",
                  "action_id": "get_registry_value",
                  "object": "field",
                  "object_description": "Registry value",
                  "object_id": "registry_value",
                  "intention_description": "Access_attribute_value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "_bqschema_to_nullsafe_dtypes()",
                  "action_description": "Retrieves value and data type for registry value",
                  "action_id": "get_registry_value",
                  "object": "schema_fields",
                  "object_description": "Registry value",
                  "object_id": "registry_value",
                  "intention_description": "Access_attribute_value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "conversion_dtypes.update()",
                  "action_description": "Sets value for registry key",
                  "action_id": "set_registry_value",
                  "object": "user_dtypes",
                  "object_description": "Registry value",
                  "object_id": "registry_value",
                  "intention_description": "Access_attribute_value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "rows_iter.to_dataframe()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "dtypes=conversion_dtypes, progress_bar_type=progress_bar_type, create_bqstorage_client=create_bqstorage_client",
                  "object_description": "JSON string",
                  "object_id": "json_string",
                  "intention_description": "Parse_json_data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "self.process_http_error()",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "ex",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Access_command_error_output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "_finalize_dtypes()",
                  "action_description": "Sets value for registry key",
                  "action_id": "set_registry_value",
                  "object": "df, schema_fields",
                  "object_description": "Registry value",
                  "object_id": "registry_value",
                  "intention_description": "Prepare_data_processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "logger.debug()",
                  "action_description": "Retrieves value and data type for registry value",
                  "action_id": "get_registry_value",
                  "object": "\"Got {} rows.\\n\".format(rows_iter.total_rows)",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access_attribute_value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "tink-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/tink-1.11.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/tink-1.11.0/tink-1.11.0/setup.py",
          "line_number": "145",
          "type_description": "code-execution",
          "context_snippet": "class BuildBazelExtension(build_ext.build_ext):\n  \"\"\"A command that runs Bazel to build a C/C++ extension.\"\"\"\n\n  def __init__(self, dist: str) -> None:\n    super().__init__(dist)\n    self.bazel_command = _get_bazel_command()\n\n  def run(self) -> None:\n    for ext in self.extensions:\n      self.bazel_build(ext)\n    build_ext.build_ext.run(self)\n\n  def bazel_build(self, ext: str) -> None:\n    if not os.path.exists(self.build_temp):\n      os.makedirs(self.build_temp)\n\n    # Ensure no artifacts from previous builds are reused (i.e. from builds\n    # using a different Python version).\n    self.spawn([self.bazel_command, 'clean', '--expunge'])\n\n    bazel_startup_args = []\n    bazel_build_args = [\n        'build',\n        ext.bazel_target,\n        '--compilation_mode=' + ('dbg' if self.debug else 'opt'),\n    ]\n\n    target_arch = os.getenv('TARGET_ARCH', '')\n    target_os = os.getenv('TARGET_OS', '')\n    if target_arch and target_os:\n      bazel_build_args += [f'--config={target_os}_{target_arch}']\n\n    lib_extension = '.so'\n    if platform.system() == 'Windows':\n      # Required to build protobuf. See\n      # https://github.com/protocolbuffers/protobuf/issues/12947\n      bazel_startup_args += [r'--output_base=C:\\O']\n      # Needed by pybind11_bazel.\n      os.environ['PYTHON_BIN_PATH'] = sys.executable\n      os.environ['PYTHON_LIB_PATH'] = os.path.join(sys.exec_prefix, 'lib')\n      lib_extension = '.pyd'\n\n    if 'TINK_PYTHON_BAZEL_REMOTE_CACHE_GCS_BUCKET_URL' in os.environ:\n      if 'TINK_PYTHON_BAZEL_REMOTE_CACHE_SERVICE_KEY_PATH' not in os.environ:\n        raise ValueError(\n            'TINK_PYTHON_BAZEL_REMOTE_CACHE_SERVICE_KEY_PATH must be set.'\n        )\n      remote_cache_gcs_bucket_url = os.environ[\n          'TINK_PYTHON_BAZEL_REMOTE_CACHE_GCS_BUCKET_URL'\n      ]\n      remote_cache_gcs_service_key_path = os.path.abspath(\n          os.environ['TINK_PYTHON_BAZEL_REMOTE_CACHE_SERVICE_KEY_PATH']\n      )\n      bazel_build_args += [\n          f'--remote_cache={remote_cache_gcs_bucket_url}',\n          f'--google_credentials={remote_cache_gcs_service_key_path}',\n      ]\n\n    # Run build command.\n    self.spawn([self.bazel_command] + bazel_startup_args + bazel_build_args)\n\n    ext_bazel_bin_path = os.path.join(\n        'bazel-bin', ext.relpath, ext.target_name + lib_extension\n    )\n    ext_dest_path = self.get_ext_fullpath(ext.name)\n    ext_dest_dir = os.path.dirname(ext_dest_path)\n    if not os.path.exists(ext_dest_dir):\n      os.makedirs(ext_dest_dir)\n    shutil.copyfile(ext_bazel_bin_path, ext_dest_path)\n\n# Helper function used in __init__\ndef _get_bazel_command() -> str:\n  \"\"\"Finds the bazel command.\"\"\"\n  if shutil.which('bazelisk'):\n    return 'bazelisk'\n  elif shutil.which('bazel'):\n    return 'bazel'\n  raise FileNotFoundError(\n      'Could not find bazel executable. Please install '\n      'bazel to compile the Tink Python package.'\n  )",
          "hash_value": "fc0c9f45dd5bd0b8fc1a4b062c598c0b",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class BuildBazelExtension(build_ext.build_ext):\n  \"\"\"A command that runs Bazel to build a C/C++ extension.\"\"\"\n\n  def __init__(self, dist: str) -> None:\n    super().__init__(dist)\n    self.bazel_command = _get_bazel_command()\n\n  def run(self) -> None:\n    for ext in self.extensions:\n      self.bazel_build(ext)\n    build_ext.build_ext.run(self)\n\n  def bazel_build(self, ext: str) -> None:\n    if not os.path.exists(self.build_temp):\n      os.makedirs(self.build_temp)\n\n    # Ensure no artifacts from previous builds are reused (i.e. from builds\n    # using a different Python version).\n    self.spawn([self.bazel_command, 'clean', '--expunge'])\n\n    bazel_startup_args = []\n    bazel_build_args = [\n        'build',\n        ext.bazel_target,\n        '--compilation_mode=' + ('dbg' if self.debug else 'opt'),\n    ]\n\n    target_arch = os.getenv('TARGET_ARCH', '')\n    target_os = os.getenv('TARGET_OS', '')\n    if target_arch and target_os:\n      bazel_build_args += [f'--config={target_os}_{target_arch}']\n\n    lib_extension = '.so'\n    if platform.system() == 'Windows':\n      # Required to build protobuf. See\n      # https://github.com/protocolbuffers/protobuf/issues/12947\n      bazel_startup_args += [r'--output_base=C:\\O']\n      # Needed by pybind11_bazel.\n      os.environ['PYTHON_BIN_PATH'] = sys.executable\n      os.environ['PYTHON_LIB_PATH'] = os.path.join(sys.exec_prefix, 'lib')\n      lib_extension = '.pyd'\n\n    if 'TINK_PYTHON_BAZEL_REMOTE_CACHE_GCS_BUCKET_URL' in os.environ:\n      if 'TINK_PYTHON_BAZEL_REMOTE_CACHE_SERVICE_KEY_PATH' not in os.environ:\n        raise ValueError(\n            'TINK_PYTHON_BAZEL_REMOTE_CACHE_SERVICE_KEY_PATH must be set.'\n        )\n      remote_cache_gcs_bucket_url = os.environ[\n          'TINK_PYTHON_BAZEL_REMOTE_CACHE_GCS_BUCKET_URL'\n      ]\n      remote_cache_gcs_service_key_path = os.path.abspath(\n          os.environ['TINK_PYTHON_BAZEL_REMOTE_CACHE_SERVICE_KEY_PATH']\n      )\n      bazel_build_args += [\n          f'--remote_cache={remote_cache_gcs_bucket_url}',\n          f'--google_credentials={remote_cache_gcs_service_key_path}',\n      ]\n\n    # Run build command.\n    self.spawn([self.bazel_command] + bazel_startup_args + bazel_build_args)\n\n    ext_bazel_bin_path = os.path.join(\n        'bazel-bin', ext.relpath, ext.target_name + lib_extension\n    )\n    ext_dest_path = self.get_ext_fullpath(ext.name)\n    ext_dest_dir = os.path.dirname(ext_dest_path)\n    if not os.path.exists(ext_dest_dir):\n      os.makedirs(ext_dest_dir)\n    shutil.copyfile(ext_bazel_bin_path, ext_dest_path)\n\n# Helper function used in __init__\ndef _get_bazel_command() -> str:\n  \"\"\"Finds the bazel command.\"\"\"\n  if shutil.which('bazelisk'):\n    return 'bazelisk'\n  elif shutil.which('bazel'):\n    return 'bazel'\n  raise FileNotFoundError(\n      'Could not find bazel executable. Please install '\n      'bazel to compile the Tink Python package.'\n  )",
              "triple_sequences": [
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "self.build_temp",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "os.makedirs()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "self.build_temp",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "self.spawn()",
                  "action_description": "Spawns new process to execute command with shell access",
                  "action_id": "spawn_process_shell",
                  "object": "[self.bazel_command, 'clean', '--expunge']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.getenv()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'TARGET_ARCH', ''",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.getenv()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'TARGET_OS', ''",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "platform.system()",
                  "action_description": "Retrieves operating system identifier",
                  "action_id": "get_os_id",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get operating system name",
                  "intention_id": "get_operating_system_name"
                },
                {
                  "action_api": "os.environ.__setitem__()",
                  "action_description": "Sets value for registry key",
                  "action_id": "set_registry_value",
                  "object": "'PYTHON_BIN_PATH', sys.executable",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.__setitem__()",
                  "action_description": "Sets value for registry key",
                  "action_id": "set_registry_value",
                  "object": "'PYTHON_LIB_PATH', os.path.join(sys.exec_prefix, 'lib')",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.__contains__()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "'TINK_PYTHON_BAZEL_REMOTE_CACHE_GCS_BUCKET_URL'",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Determine presence of valid authentication",
                  "intention_id": "determine_valid_authentication_presence"
                },
                {
                  "action_api": "os.environ.__contains__()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "'TINK_PYTHON_BAZEL_REMOTE_CACHE_SERVICE_KEY_PATH'",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Determine presence of valid authentication",
                  "intention_id": "determine_valid_authentication_presence"
                },
                {
                  "action_api": "os.environ.__getitem__()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'TINK_PYTHON_BAZEL_REMOTE_CACHE_GCS_BUCKET_URL'",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.environ['TINK_PYTHON_BAZEL_REMOTE_CACHE_SERVICE_KEY_PATH']",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Prepare path for file operations",
                  "intention_id": "prepare_path_file_operations"
                },
                {
                  "action_api": "self.spawn()",
                  "action_description": "Spawns new process to execute command with shell access",
                  "action_id": "spawn_process_shell",
                  "object": "[self.bazel_command] + bazel_startup_args + bazel_build_args",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "'bazel-bin', ext.relpath, ext.target_name + lib_extension",
                  "object_description": "Directory path with file",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "self.get_ext_fullpath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "ext.name",
                  "object_description": "Local file or directory name",
                  "object_id": "local_file_or_directory_name",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "ext_dest_path",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "ext_dest_dir",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "os.makedirs()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "ext_dest_dir",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "shutil.copyfile()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "ext_bazel_bin_path, ext_dest_path",
                  "object_description": "Local file",
                  "object_id": "local_file",
                  "intention_description": "Move file to destination",
                  "intention_id": "move_file_destination"
                },
                {
                  "action_api": "shutil.which()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "'bazelisk'",
                  "object_description": "Executable file",
                  "object_id": "executable_file",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "shutil.which()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "'bazel'",
                  "object_description": "Executable file",
                  "object_id": "executable_file",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "dvc-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/dvc-3.59.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "analytics.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/dvc-3.59.1/dvc-3.59.1/dvc/analytics.py",
          "line_number": "83",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "def send(path):\n    \"\"\"\n    Side effect: Removes the report after sending it.\n\n    The report is generated and stored in a temporary file, see:\n    `collect_and_send_report`. Sending happens on another process,\n    thus, the need of removing such file afterwards.\n    \"\"\"\n    import requests\n\n    url = os.environ.get(DVC_ANALYTICS_ENDPOINT, \"https://analytics.dvc.org\")\n    headers = {\"content-type\": \"application/json\"}\n\n    with open(path, encoding=\"utf-8\") as fobj:\n        report = json.load(fobj)\n\n    report.update(_runtime_info())\n\n    logger.debug(\"uploading report to %s\", url)\n    logger.trace(\"Sending %s to %s\", report, url)\n\n    try:\n        requests.post(url, json=report, headers=headers, timeout=5)\n    except requests.exceptions.RequestException as e:\n        logger.trace(\"\", exc_info=True)\n        logger.debug(\"failed to send analytics report %s\", str(e))\n\n    logger.trace(\"removing report %s\", path)\n    os.remove(path)\n\ndef _runtime_info():\n    \"\"\"\n    Gather information from the environment where DVC runs to fill a report.\n    \"\"\"\n    from iterative_telemetry import _generate_ci_id, find_or_create_user_id\n\n    from dvc import __version__\n    from dvc.utils import is_binary\n\n    ci_id = _generate_ci_id()\n    if ci_id:\n        group_id, user_id = ci_id\n    else:\n        group_id, user_id = None, find_or_create_user_id()\n\n    return {\n        \"dvc_version\": __version__,\n        \"is_binary\": is_binary(),\n        \"scm_class\": _scm_in_use(),\n        \"system_info\": _system_info(),\n        \"user_id\": user_id,\n        \"group_id\": group_id,\n    }\n\ndef _scm_in_use():\n    from dvc.exceptions import NotDvcRepoError\n    from dvc.repo import Repo\n    from dvc.scm import NoSCM\n\n    from .scm import SCM, SCMError\n\n    try:\n        scm = SCM(root_dir=Repo.find_root())\n        return type(scm).__name__\n    except SCMError:\n        return NoSCM.__name__\n    except NotDvcRepoError:\n        pass\n\ndef _system_info():\n    import platform\n    import sys\n\n    import distro\n\n    system = platform.system()\n\n    if system == \"Windows\":\n        version = sys.getwindowsversion()  # type: ignore[attr-defined]\n\n        return {\n            \"os\": \"windows\",\n            \"windows_version_build\": version.build,\n            \"windows_version_major\": version.major,\n            \"windows_version_minor\": version.minor,\n            \"windows_version_service_pack\": version.service_pack,\n        }\n\n    if system == \"Darwin\":\n        return {\"os\": \"mac\", \"mac_version\": platform.mac_ver()[0]}\n\n    if system == \"Linux\":\n        return {\n            \"os\": \"linux\",\n            \"linux_distro\": distro.id(),\n            \"linux_distro_like\": distro.like(),\n            \"linux_distro_version\": distro.version(),\n        }\n\n    # We don't collect data for any other system.\n    raise NotImplementedError",
          "hash_value": "fc9c464d2adb0a5c64916a100fc051e3",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def send(path):\n    \"\"\"\n    Side effect: Removes the report after sending it.\n\n    The report is generated and stored in a temporary file, see:\n    `collect_and_send_report`. Sending happens on another process,\n    thus, the need of removing such file afterwards.\n    \"\"\"\n    import requests\n\n    url = os.environ.get(DVC_ANALYTICS_ENDPOINT, \"https://analytics.dvc.org\")\n    headers = {\"content-type\": \"application/json\"}\n\n    with open(path, encoding=\"utf-8\") as fobj:\n        report = json.load(fobj)\n\n    report.update(_runtime_info())\n\n    logger.debug(\"uploading report to %s\", url)\n    logger.trace(\"Sending %s to %s\", report, url)\n\n    try:\n        requests.post(url, json=report, headers=headers, timeout=5)\n    except requests.exceptions.RequestException as e:\n        logger.trace(\"\", exc_info=True)\n        logger.debug(\"failed to send analytics report %s\", str(e))\n\n    logger.trace(\"removing report %s\", path)\n    os.remove(path)\n\ndef _runtime_info():\n    \"\"\"\n    Gather information from the environment where DVC runs to fill a report.\n    \"\"\"\n    from iterative_telemetry import _generate_ci_id, find_or_create_user_id\n\n    from dvc import __version__\n    from dvc.utils import is_binary\n\n    ci_id = _generate_ci_id()\n    if ci_id:\n        group_id, user_id = ci_id\n    else:\n        group_id, user_id = None, find_or_create_user_id()\n\n    return {\n        \"dvc_version\": __version__,\n        \"is_binary\": is_binary(),\n        \"scm_class\": _scm_in_use(),\n        \"system_info\": _system_info(),\n        \"user_id\": user_id,\n        \"group_id\": group_id,\n    }\n\ndef _scm_in_use():\n    from dvc.exceptions import NotDvcRepoError\n    from dvc.repo import Repo\n    from dvc.scm import NoSCM\n\n    from .scm import SCM, SCMError\n\n    try:\n        scm = SCM(root_dir=Repo.find_root())\n        return type(scm).__name__\n    except SCMError:\n        return NoSCM.__name__\n    except NotDvcRepoError:\n        pass\n\ndef _system_info():\n    import platform\n    import sys\n\n    import distro\n\n    system = platform.system()\n\n    if system == \"Windows\":\n        version = sys.getwindowsversion()  # type: ignore[attr-defined]\n\n        return {\n            \"os\": \"windows\",\n            \"windows_version_build\": version.build,\n            \"windows_version_major\": version.major,\n            \"windows_version_minor\": version.minor,\n            \"windows_version_service_pack\": version.service_pack,\n        }\n\n    if system == \"Darwin\":\n        return {\"os\": \"mac\", \"mac_version\": platform.mac_ver()[0]}\n\n    if system == \"Linux\":\n        return {\n            \"os\": \"linux\",\n            \"linux_distro\": distro.id(),\n            \"linux_distro_like\": distro.like(),\n            \"linux_distro_version\": distro.version(),\n        }\n\n    # We don't collect data for any other system.\n    raise NotImplementedError",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "DVC_ANALYTICS_ENDPOINT",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "path",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "json.load()",
                  "action_description": "Deserializes JSON string to Python object",
                  "action_id": "deserialize_from_json",
                  "object": "fobj",
                  "object_description": "JSON string",
                  "object_id": "json_string",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "report.update()",
                  "action_description": "Serializes Python object to JSON string",
                  "action_id": "serialize_to_json",
                  "object": "_runtime_info()",
                  "object_description": "System info",
                  "object_id": "system_info",
                  "intention_description": "Gather system information",
                  "intention_id": "gather_system_information"
                },
                {
                  "action_api": "requests.post()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "url, json=report, headers=headers, timeout=5",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Transmit data via HTTP POST",
                  "intention_id": "transmit_data_http_post"
                },
                {
                  "action_api": "os.remove()",
                  "action_description": "Deletes specified file from filesystem",
                  "action_id": "delete_file",
                  "object": "path",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Delete file",
                  "intention_id": "delete_file"
                },
                {
                  "action_api": "_generate_ci_id()",
                  "action_description": "Instantiates class or function (custom)",
                  "action_id": "init_grabber_class",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Gather system information",
                  "intention_id": "gather_system_information"
                },
                {
                  "action_api": "find_or_create_user_id()",
                  "action_description": "Instantiates class or function (custom)",
                  "action_id": "init_grabber_class",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Gather system information",
                  "intention_id": "gather_system_information"
                },
                {
                  "action_api": "is_binary()",
                  "action_description": "Instantiates class or function (custom)",
                  "action_id": "init_grabber_class",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Gather system information",
                  "intention_id": "gather_system_information"
                },
                {
                  "action_api": "_scm_in_use()",
                  "action_description": "Instantiates class or function (custom)",
                  "action_id": "init_grabber_class",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Gather system information",
                  "intention_id": "gather_system_information"
                },
                {
                  "action_api": "_system_info()",
                  "action_description": "Instantiates class or function (custom)",
                  "action_id": "init_grabber_class",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Gather system information",
                  "intention_id": "gather_system_information"
                },
                {
                  "action_api": "SCM()",
                  "action_description": "Instantiates class or function (custom)",
                  "action_id": "init_grabber_class",
                  "object": "root_dir=Repo.find_root()",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Gather system information",
                  "intention_id": "gather_system_information"
                },
                {
                  "action_api": "type().__name__",
                  "action_description": "Retrieves attribute value",
                  "action_id": "get_os_id",
                  "object": "scm",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Extract structured data from file",
                  "intention_id": "extract_structured_file_data"
                },
                {
                  "action_api": "NoSCM.__name__",
                  "action_description": "Retrieves attribute value",
                  "action_id": "get_os_id",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Extract structured data from file",
                  "intention_id": "extract_structured_file_data"
                },
                {
                  "action_api": "platform.system()",
                  "action_description": "Retrieves operating system identifier",
                  "action_id": "get_os_id",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get operating system name",
                  "intention_id": "get_operating_system_name"
                },
                {
                  "action_api": "sys.getwindowsversion()",
                  "action_description": "Retrieves operating system version",
                  "action_id": "get_os_version",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get operating system version",
                  "intention_id": "get_operating_system_version"
                },
                {
                  "action_api": "platform.mac_ver()",
                  "action_description": "Retrieves operating system version",
                  "action_id": "get_os_version",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get operating system version",
                  "intention_id": "get_operating_system_version"
                },
                {
                  "action_api": "distro.id()",
                  "action_description": "Instantiates class or function (custom)",
                  "action_id": "init_grabber_class",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get operating system name",
                  "intention_id": "get_operating_system_name"
                },
                {
                  "action_api": "distro.like()",
                  "action_description": "Instantiates class or function (custom)",
                  "action_id": "init_grabber_class",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get operating system name",
                  "intention_id": "get_operating_system_name"
                },
                {
                  "action_api": "distro.version()",
                  "action_description": "Instantiates class or function (custom)",
                  "action_id": "init_grabber_class",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get operating system version",
                  "intention_id": "get_operating_system_version"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "fschat-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/fschat-0.2.36.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "api_provider.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/fschat-0.2.36/fschat-0.2.36/fastchat/serve/api_provider.py",
          "line_number": "260",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "def bard_api_stream_iter(model_name, conv, temperature, top_p, api_key=None):\n    del top_p  # not supported\n    del temperature  # not supported\n\n    if api_key is None:\n        api_key = os.environ[\"BARD_API_KEY\"]\n\n    # convert conv to conv_bard\n    conv_bard = []\n    for turn in conv:\n        if turn[\"role\"] == \"user\":\n            conv_bard.append({\"author\": \"0\", \"content\": turn[\"content\"]})\n        elif turn[\"role\"] == \"assistant\":\n            conv_bard.append({\"author\": \"1\", \"content\": turn[\"content\"]})\n        else:\n            raise ValueError(f\"Unsupported role: {turn['role']}\")\n\n    params = {\n        \"model\": model_name,\n        \"prompt\": conv_bard,\n    }\n    logger.info(f\"==== request ====\\n{params}\")\n\n    try:\n        res = requests.post(\n            f\"https://generativelanguage.googleapis.com/v1beta2/models/{model_name}:generateMessage?key={api_key}\",\n            json={\n                \"prompt\": {\n                    \"messages\": conv_bard,\n                },\n            },\n            timeout=30,\n        )\n    except Exception as e:\n        logger.error(f\"==== error ====\\n{e}\")\n        yield {\n            \"text\": f\"**API REQUEST ERROR** Reason: {e}.\",\n            \"error_code\": 1,\n        }\n\n    if res.status_code != 200:\n        logger.error(f\"==== error ==== ({res.status_code}): {res.text}\")\n        yield {\n            \"text\": f\"**API REQUEST ERROR** Reason: status code {res.status_code}.\",\n            \"error_code\": 1,\n        }\n\n    response_json = res.json()\n    if \"candidates\" not in response_json:\n        logger.error(f\"==== error ==== response blocked: {response_json}\")\n        reason = response_json[\"filters\"][0][\"reason\"]\n        yield {\n            \"text\": f\"**API REQUEST ERROR** Reason: {reason}.\",\n            \"error_code\": 1,\n        }\n\n    response = response_json[\"candidates\"][0][\"content\"]\n    pos = 0\n    while pos < len(response):\n        # simulate token streaming\n        pos += random.randint(3, 6)\n        time.sleep(0.002)\n        data = {\n            \"text\": response[:pos],\n            \"error_code\": 0,\n        }\n        yield data",
          "hash_value": "bbfd9c9b33fbfbfcc362f64609191b0d",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def bard_api_stream_iter(model_name, conv, temperature, top_p, api_key=None):\n    del top_p  # not supported\n    del temperature  # not supported\n\n    if api_key is None:\n        api_key = os.environ[\"BARD_API_KEY\"]\n\n    # convert conv to conv_bard\n    conv_bard = []\n    for turn in conv:\n        if turn[\"role\"] == \"user\":\n            conv_bard.append({\"author\": \"0\", \"content\": turn[\"content\"]})\n        elif turn[\"role\"] == \"assistant\":\n            conv_bard.append({\"author\": \"1\", \"content\": turn[\"content\"]})\n        else:\n            raise ValueError(f\"Unsupported role: {turn['role']}\")\n\n    params = {\n        \"model\": model_name,\n        \"prompt\": conv_bard,\n    }\n    logger.info(f\"==== request ====\\n{params}\")\n\n    try:\n        res = requests.post(\n            f\"https://generativelanguage.googleapis.com/v1beta2/models/{model_name}:generateMessage?key={api_key}\",\n            json={\n                \"prompt\": {\n                    \"messages\": conv_bard,\n                },\n            },\n            timeout=30,\n        )\n    except Exception as e:\n        logger.error(f\"==== error ====\\n{e}\")\n        yield {\n            \"text\": f\"**API REQUEST ERROR** Reason: {e}.\",\n            \"error_code\": 1,\n        }\n\n    if res.status_code != 200:\n        logger.error(f\"==== error ==== ({res.status_code}): {res.text}\")\n        yield {\n            \"text\": f\"**API REQUEST ERROR** Reason: status code {res.status_code}.\",\n            \"error_code\": 1,\n        }\n\n    response_json = res.json()\n    if \"candidates\" not in response_json:\n        logger.error(f\"==== error ==== response blocked: {response_json}\")\n        reason = response_json[\"filters\"][0][\"reason\"]\n        yield {\n            \"text\": f\"**API REQUEST ERROR** Reason: {reason}.\",\n            \"error_code\": 1,\n        }\n\n    response = response_json[\"candidates\"][0][\"content\"]\n    pos = 0\n    while pos < len(response):\n        # simulate token streaming\n        pos += random.randint(3, 6)\n        time.sleep(0.002)\n        data = {\n            \"text\": response[:pos],\n            \"error_code\": 0,\n        }\n        yield data",
              "triple_sequences": [
                {
                  "action_api": "os.environ.__getitem__()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"BARD_API_KEY\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "logger.info()",
                  "action_description": "Process HTTP response content",
                  "action_id": "process_http_response",
                  "object": "f\"==== request ====\n{params}\"",
                  "object_description": "String containing environment data",
                  "object_id": "string_environment_data",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "requests.post()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "f\"https://generativelanguage.googleapis.com/v1beta2/models/{model_name}:generateMessage?key={api_key}\"",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "logger.error()",
                  "action_description": "Process HTTP response content",
                  "action_id": "process_http_response",
                  "object": "f\"==== error ====\n{e}\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "logger.error()",
                  "action_description": "Process HTTP response content",
                  "action_id": "process_http_response",
                  "object": "f\"==== error ==== ({res.status_code}): {res.text}\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "res.json()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "",
                  "object_description": "HTTP response content from remote server",
                  "object_id": "http_response_remote_content",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "logger.error()",
                  "action_description": "Process HTTP response content",
                  "action_id": "process_http_response",
                  "object": "f\"==== error ==== response blocked: {response_json}\"",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "random.randint()",
                  "action_description": "Generate random integer",
                  "action_id": "generate_random_integer",
                  "object": "3, 6",
                  "object_description": "Random string",
                  "object_id": "random_string",
                  "intention_description": "Generate random number",
                  "intention_id": "generate_random_number"
                },
                {
                  "action_api": "time.sleep()",
                  "action_description": "Suspends execution",
                  "action_id": "suspend_execution",
                  "object": "0.002",
                  "object_description": "Delay duration in seconds",
                  "object_id": "delay_duration",
                  "intention_description": "Delay next operation",
                  "intention_id": "delay_next_operation"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "cmd2-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/cmd2-2.5.11.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "clipboard.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cmd2-2.5.11/cmd2-2.5.11/cmd2/clipboard.py",
          "line_number": "16",
          "type_description": "clipboard-access",
          "context_snippet": "import typing\n\nimport pyperclip  # type: ignore[import]\n\ndef get_paste_buffer() -> str:\n    \"\"\"Get the contents of the clipboard / paste buffer.\n\n    :return: contents of the clipboard\n    \"\"\"\n    pb_str = typing.cast(str, pyperclip.paste())\n    return pb_str",
          "hash_value": "e4d54a42aa61833eee5d9d1278e511f2",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import typing\n\nimport pyperclip  # type: ignore[import]\n\ndef get_paste_buffer() -> str:\n    \"\"\"Get the contents of the clipboard / paste buffer.\n\n    :return: contents of the clipboard\n    \"\"\"\n    pb_str = typing.cast(str, pyperclip.paste())\n    return pb_str",
              "triple_sequences": [
                {
                  "action_api": "pyperclip.paste()",
                  "action_description": "Retrieves text from system clipboard",
                  "action_id": "get_clipboard_text",
                  "object": "",
                  "object_description": "Clipboard content data",
                  "object_id": "clipboard_data",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                },
                {
                  "action_api": "typing.cast()",
                  "action_description": "Converts bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "pyperclip.paste()",
                  "object_description": "Clipboard content data",
                  "object_id": "clipboard_data",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "aqtinstall-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/aqtinstall-3.2.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "conf.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/aqtinstall-3.2.1/aqtinstall-3.2.1/docs/conf.py",
          "line_number": "301",
          "type_description": "shady-links",
          "context_snippet": "linkcheck_ignore = [r'https://github.com/miurahr/aqtinstall/compare/.+',\n                    'http://mirrors.tuna.tsinghua.edu.cn',\n                    'http://mirrors.geekpie.club/']\n\nlocale_dirs=['locale/']\n",
          "hash_value": "3ba45806b0ad102e0139001b5b58ab04",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "linkcheck_ignore = [r'https://github.com/miurahr/aqtinstall/compare/.+',\n                    'http://mirrors.tuna.tsinghua.edu.cn',\n                    'http://mirrors.geekpie.club/']\n\nlocale_dirs=['locale/']\n",
              "triple_sequences": [
                {
                  "action_api": "",
                  "action_description": "",
                  "action_id": "",
                  "object": "r'https://github.com/miurahr/aqtinstall/compare/.+', 'http://mirrors.tuna.tsinghua.edu.cn', 'http://mirrors.geekpie.club/'",
                  "object_description": "External domain",
                  "object_id": "external_domain",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "",
                  "action_description": "",
                  "action_id": "",
                  "object": "['locale/']",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Prepare directory path",
                  "intention_id": "prepare_directory_path"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "praisonai-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/praisonai-2.1.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/praisonai-2.1.1/praisonai-2.1.1/praisonai/setup.py",
          "line_number": "12",
          "type_description": "cmd-overwrite",
          "context_snippet": "from setuptools import setup\nfrom setuptools.command.install import install\nimport subprocess\nimport sys\n\nclass PostInstallCommand(install):\n    def run(self):\n        install.run(self)\n        # Install Playwright browsers\n        subprocess.check_call([sys.executable, '-m', 'playwright', 'install'])\n\nsetup(\n    cmdclass={\n        'install': PostInstallCommand,\n    }\n)",
          "hash_value": "f6821ca1270b8881d4103fbc657da9aa",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from setuptools import setup\nfrom setuptools.command.install import install\nimport subprocess\nimport sys\n\nclass PostInstallCommand(install):\n    def run(self):\n        install.run(self)\n        # Install Playwright browsers\n        subprocess.check_call([sys.executable, '-m', 'playwright', 'install'])\n\nsetup(\n    cmdclass={\n        'install': PostInstallCommand,\n    }\n)",
              "triple_sequences": [
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[sys.executable, '-m', 'playwright', 'install']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "cmdclass={'install': PostInstallCommand}",
                  "object_description": "Custom post-install function",
                  "object_id": "custom_post_install_function",
                  "intention_description": "Trigger post-installation logic",
                  "intention_id": "trigger_post_installation_logic"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "tornado-6",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/tornado-6.4.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "gen.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/tornado-6.4.2/tornado-6.4.2/tornado/gen.py",
          "line_number": "433",
          "type_description": "obfuscation",
          "context_snippet": "class WaitIterator(object):\n    ...\n    def __anext__(self) -> Future:\n        if self.done():\n            # Lookup by name to silence pyflakes on older versions.\n            raise getattr(builtins, \"StopAsyncIteration\")()\n        return self.next()",
          "hash_value": "983ddd6ac616f60f9f618acbb21b1d54",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class WaitIterator(object):\n    ...\n    def __anext__(self) -> Future:\n        if self.done():\n            # Lookup by name to silence pyflakes on older versions.\n            raise getattr(builtins, \"StopAsyncIteration\")()\n        return self.next()",
              "triple_sequences": [
                {
                  "action_api": "self.done()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine_file_presence",
                  "intention_id": "determine_file_presence"
                },
                {
                  "action_api": "getattr(builtins, \"StopAsyncIteration\")()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, \"StopAsyncIteration\"",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                },
                {
                  "action_api": "self.next()",
                  "action_description": "Reads user input from standard input",
                  "action_id": "read_user_input",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect user input",
                  "intention_id": "collect_user_input"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "autorom",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/autorom.accept-rom-license-0.6.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/autorom.accept-rom-license-0.6.1/AutoROM.accept-rom-license-0.6.1/setup.py",
          "line_number": "18",
          "type_description": "cmd-overwrite",
          "context_snippet": "import pathlib\n\nimport setuptools\nfrom setuptools.command.install import install\n\n\nclass InstallCommand(install):\n    def run(self):\n        super().run()\n\n        from AutoROM import main\n\n        download_dir = pathlib.Path(self.install_lib) / \"AutoROM\" / \"roms\"\n        download_dir.mkdir(exist_ok=True, parents=True)\n        main(True, None, download_dir, False)\n\n\nsetuptools.setup(\n    name=\"AutoROM.accept-rom-license\",\n    cmdclass={\"install\": InstallCommand},\n)\n",
          "hash_value": "6145dad58f1113890d00cd0cf9ce23e3",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import pathlib\n\nimport setuptools\nfrom setuptools.command.install import install\n\n\nclass InstallCommand(install):\n    def run(self):\n        super().run()\n\n        from AutoROM import main\n\n        download_dir = pathlib.Path(self.install_lib) / \"AutoROM\" / \"roms\"\n        download_dir.mkdir(exist_ok=True, parents=True)\n        main(True, None, download_dir, False)\n\n\nsetuptools.setup(\n    name=\"AutoROM.accept-rom-license\",\n    cmdclass={\"install\": InstallCommand},\n)\n",
              "triple_sequences": [
                {
                  "action_api": "pathlib.Path()",
                  "action_description": "Path object and status operations (creating Path objects, retrieving file status)",
                  "action_id": "path_object_operations",
                  "object": "self.install_lib",
                  "object_description": "Program directory",
                  "object_id": "program_directory",
                  "intention_description": "Prepare path for file operations",
                  "intention_id": "prepare_path_file_operations"
                },
                {
                  "action_api": "Path.mkdir()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "download_dir",
                  "object_description": "Custom directory",
                  "object_id": "custom_directory",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "main()",
                  "action_description": "Instantiates Grabber class",
                  "action_id": "init_grabber_class",
                  "object": "True, None, download_dir, False",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Trigger main behavioral logic",
                  "intention_id": "trigger_main_behavioral_logic"
                },
                {
                  "action_api": "setuptools.setup()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "name=\"AutoROM.accept-rom-license\", cmdclass={\"install\": InstallCommand}",
                  "object_description": "Program directory",
                  "object_id": "program_directory",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "flake8_bugbear-24",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/flake8_bugbear-24.12.12.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "bugbear.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/flake8_bugbear-24.12.12/flake8_bugbear-24.12.12/bugbear.py",
          "line_number": "268",
          "type_description": "obfuscation",
          "context_snippet": "def _check_redundant_excepthandlers(names: Sequence[str], node, in_trystar):\n    # See if any of the given exception names could be removed, e.g. from:\n    #    (MyError, MyError)  # duplicate names\n    #    (MyError, BaseException)  # everything derives from the Base\n    #    (Exception, TypeError)  # builtins where one subclasses another\n    #    (IOError, OSError)  # IOError is an alias of OSError since Python3.3\n    # but note that other cases are impractical to handle from the AST.\n    # We expect this is mostly useful for users who do not have the\n    # builtin exception hierarchy memorised, and include a 'shadowed'\n    # subtype without realising that it's redundant.\n    good = sorted(set(names), key=names.index)\n    if \"BaseException\" in good:\n        good = [\"BaseException\"]\n    # Remove redundant exceptions that the automatic system either handles\n    # poorly (usually aliases) or can't be checked (e.g. it's not an\n    # built-in exception).\n    for primary, equivalents in B014_REDUNDANT_EXCEPTIONS.items():\n        if primary in good:\n            good = [g for g in good if g not in equivalents]\n\n    for name, other in itertools.permutations(tuple(good), 2):\n        if _typesafe_issubclass(\n            getattr(builtins, name, type), getattr(builtins, other, ())\n        ):\n            if name in good:\n                good.remove(name)\n    if good != names:\n        desc = good[0] if len(good) == 1 else \"({})\".format(\", \".join(good))\n        as_ = \" as \" + node.name if node.name is not None else \"\"\n        return B014(\n            node.lineno,\n            node.col_offset,\n            vars=(\", \".join(names), as_, desc, in_trystar),\n        )\n    return None",
          "hash_value": "a47df1f696d0f6a3efd2af71ba6b5453",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def _check_redundant_excepthandlers(names: Sequence[str], node, in_trystar):\n    # See if any of the given exception names could be removed, e.g. from:\n    #    (MyError, MyError)  # duplicate names\n    #    (MyError, BaseException)  # everything derives from the Base\n    #    (Exception, TypeError)  # builtins where one subclasses another\n    #    (IOError, OSError)  # IOError is an alias of OSError since Python3.3\n    # but note that other cases are impractical to handle from the AST.\n    # We expect this is mostly useful for users who do not have the\n    # builtin exception hierarchy memorised, and include a 'shadowed'\n    # subtype without realising that it's redundant.\n    good = sorted(set(names), key=names.index)\n    if \"BaseException\" in good:\n        good = [\"BaseException\"]\n    # Remove redundant exceptions that the automatic system either handles\n    # poorly (usually aliases) or can't be checked (e.g. it's not an\n    # built-in exception).\n    for primary, equivalents in B014_REDUNDANT_EXCEPTIONS.items():\n        if primary in good:\n            good = [g for g in good if g not in equivalents]\n\n    for name, other in itertools.permutations(tuple(good), 2):\n        if _typesafe_issubclass(\n            getattr(builtins, name, type), getattr(builtins, other, ())\n        ):\n            if name in good:\n                good.remove(name)\n    if good != names:\n        desc = good[0] if len(good) == 1 else \"({})\".format(\", \".join(good))\n        as_ = \" as \" + node.name if node.name is not None else \"\"\n        return B014(\n            node.lineno,\n            node.col_offset,\n            vars=(\", \".join(names), as_, desc, in_trystar),\n        )\n    return None",
              "triple_sequences": [
                {
                  "action_api": "sorted()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "set(names)",
                  "object_description": "Character code array",
                  "object_id": "character_code_array",
                  "intention_description": "Prepare character processing",
                  "intention_id": "prepare_character_processing"
                },
                {
                  "action_api": "names.index",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "names",
                  "object_description": "Character code array",
                  "object_id": "character_code_array",
                  "intention_description": "Prepare character processing",
                  "intention_id": "prepare_character_processing"
                },
                {
                  "action_api": "itertools.permutations()",
                  "action_description": "Generate product of sequence",
                  "action_id": "generate_sequence_product",
                  "object": "tuple(good), 2",
                  "object_description": "Character code array",
                  "object_id": "character_code_array",
                  "intention_description": "Generate product of sequence",
                  "intention_id": "generate_sequence_product"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Access attribute value",
                  "action_id": "access_attribute_value",
                  "object": "builtins, name, type",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Access attribute value",
                  "action_id": "access_attribute_value",
                  "object": "builtins, other, ()",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "_typesafe_issubclass()",
                  "action_description": "Check instance type",
                  "action_id": "check_instance_type",
                  "object": "getattr(builtins, name, type), getattr(builtins, other, ())",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "good.remove()",
                  "action_description": "Delete file",
                  "action_id": "delete_file",
                  "object": "name",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Delete function from global namespace",
                  "intention_id": "delete_function_global_namespace"
                },
                {
                  "action_api": "B014()",
                  "action_description": "Instantiates custom class",
                  "action_id": "init_evil_class",
                  "object": "node.lineno, node.col_offset, vars=(', '.join(names), as_, desc, in_trystar)",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "wcwidth-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/wcwidth-0.2.13.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/wcwidth-0.2.13/wcwidth-0.2.13/setup.py",
          "line_number": "36",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport codecs\nimport setuptools\n\ndef _get_here(fname):\n    return os.path.join(os.path.dirname(__file__), fname)\n\nclass _SetupUpdate(setuptools.Command):\n    # This is a compatibility, some downstream distributions might\n    # still call \"setup.py update\".\n    #\n    # New entry point is tox, 'tox -eupdate'.\n    description = \"Fetch and update unicode code tables\"\n    user_options = []\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        import sys\n        import subprocess\n        retcode = subprocess.Popen([\n            sys.executable,\n            _get_here(os.path.join('bin', 'update-tables.py'))]).wait()\n        assert retcode == 0, ('non-zero exit code', retcode)\n\ndef main():\n    \"\"\"Setup.py entry point.\"\"\"\n    setuptools.setup(\n        name='wcwidth',\n        # NOTE: manually manage __version__ in wcwidth/__init__.py !\n        version='0.2.13',\n        description=(\n            \"Measures the displayed width of unicode strings in a terminal\"),\n        long_description=codecs.open(\n            _get_here('README.rst'), 'rb', 'utf8').read(),\n        author='Jeff Quast',\n        author_email='contact@jeffquast.com',\n        install_requires=('backports.functools-lru-cache>=1.2.1;'\n                          'python_version < \"3.2\"'),\n        license='MIT',\n        packages=['wcwidth'],\n        url='https://github.com/jquast/wcwidth',\n        package_data={\n            '': ['LICENSE', '*.rst'],\n        },\n        zip_safe=True,\n        classifiers=[\n            'Intended Audience :: Developers',\n            'Natural Language :: English',\n            'Development Status :: 5 - Production/Stable',\n            'Environment :: Console',\n            'License :: OSI Approved :: MIT License',\n            'Operating System :: POSIX',\n            'Programming Language :: Python :: 2.7',\n            'Programming Language :: Python :: 3.5',\n            'Programming Language :: Python :: 3.6',\n            'Programming Language :: Python :: 3.7',\n            'Programming Language :: Python :: 3.8',\n            'Programming Language :: Python :: 3.9',\n            'Programming Language :: Python :: 3.10',\n            'Programming Language :: Python :: 3.11',\n            'Programming Language :: Python :: 3.12',\n            'Topic :: Software Development :: Libraries',\n            'Topic :: Software Development :: Localization',\n            'Topic :: Software Development :: Internationalization',\n            'Topic :: Terminals'\n        ],\n        keywords=[\n            'cjk',\n            'combining',\n            'console',\n            'eastasian',\n            'emoji',\n            'emulator',\n            'terminal',\n            'unicode',\n            'wcswidth',\n            'wcwidth',\n            'xterm',\n        ],\n        cmdclass={'update': _SetupUpdate},\n    )\n\nif __name__ == '__main__':\n    main()",
          "hash_value": "50dc0b8fca2feff9cc40e04179e77abd",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport codecs\nimport setuptools\n\ndef _get_here(fname):\n    return os.path.join(os.path.dirname(__file__), fname)\n\nclass _SetupUpdate(setuptools.Command):\n    # This is a compatibility, some downstream distributions might\n    # still call \"setup.py update\".\n    #\n    # New entry point is tox, 'tox -eupdate'.\n    description = \"Fetch and update unicode code tables\"\n    user_options = []\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        import sys\n        import subprocess\n        retcode = subprocess.Popen([\n            sys.executable,\n            _get_here(os.path.join('bin', 'update-tables.py'))]).wait()\n        assert retcode == 0, ('non-zero exit code', retcode)\n\ndef main():\n    \"\"\"Setup.py entry point.\"\"\"\n    setuptools.setup(\n        name='wcwidth',\n        # NOTE: manually manage __version__ in wcwidth/__init__.py !\n        version='0.2.13',\n        description=(\n            \"Measures the displayed width of unicode strings in a terminal\"),\n        long_description=codecs.open(\n            _get_here('README.rst'), 'rb', 'utf8').read(),\n        author='Jeff Quast',\n        author_email='contact@jeffquast.com',\n        install_requires=('backports.functools-lru-cache>=1.2.1;'\n                          'python_version < \"3.2\"'),\n        license='MIT',\n        packages=['wcwidth'],\n        url='https://github.com/jquast/wcwidth',\n        package_data={\n            '': ['LICENSE', '*.rst'],\n        },\n        zip_safe=True,\n        classifiers=[\n            'Intended Audience :: Developers',\n            'Natural Language :: English',\n            'Development Status :: 5 - Production/Stable',\n            'Environment :: Console',\n            'License :: OSI Approved :: MIT License',\n            'Operating System :: POSIX',\n            'Programming Language :: Python :: 2.7',\n            'Programming Language :: Python :: 3.5',\n            'Programming Language :: Python :: 3.6',\n            'Programming Language :: Python :: 3.7',\n            'Programming Language :: Python :: 3.8',\n            'Programming Language :: Python :: 3.9',\n            'Programming Language :: Python :: 3.10',\n            'Programming Language :: Python :: 3.11',\n            'Programming Language :: Python :: 3.12',\n            'Topic :: Software Development :: Libraries',\n            'Topic :: Software Development :: Localization',\n            'Topic :: Software Development :: Internationalization',\n            'Topic :: Terminals'\n        ],\n        keywords=[\n            'cjk',\n            'combining',\n            'console',\n            'eastasian',\n            'emoji',\n            'emulator',\n            'terminal',\n            'unicode',\n            'wcswidth',\n            'wcwidth',\n            'xterm',\n        ],\n        cmdclass={'update': _SetupUpdate},\n    )\n\nif __name__ == '__main__':\n    main()",
              "triple_sequences": [
                {
                  "action_api": "os.path.dirname()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "__file__",
                  "object_description": "Script file path",
                  "object_id": "script_file_path",
                  "intention_description": "Get script file path",
                  "intention_id": "get_script_file_path"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.dirname(__file__), fname",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "[sys.executable, _get_here(os.path.join('bin', 'update-tables.py'))]",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Create child process",
                  "intention_id": "create_child_process"
                },
                {
                  "action_api": "subprocess.Popen().wait()",
                  "action_description": "Waits for process to complete execution",
                  "action_id": "wait_process_completion",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Wait for events",
                  "intention_id": "wait_for_events"
                },
                {
                  "action_api": "codecs.open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "_get_here('README.rst'), 'rb', 'utf8'",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for reading",
                  "intention_id": "open_file_reading"
                },
                {
                  "action_api": "file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "setuptools.setup()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "name='wcwidth', version='0.2.13', ...",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "p4python-2024",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/p4python-2024.2.2682690.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/p4python-2024.2.2682690/p4python-2024.2.2682690/setup.py",
          "line_number": "160",
          "type_description": "code-execution",
          "context_snippet": "class p4build_ext(build_ext_module):\n    \"\"\"Subclass of build subcommand for passing paths to compiler and linker\"\"\"\n\n    user_options = build_ext_module.user_options + [\n        ('ssl=', None, 'specify ssl library directory'),\n        ('apidir=', None, 'specify root of p4api directory'),\n    ]\n\n    def initialize_options(self, *args, **kwargs):\n        self.apidir = os.getenv(\"apidir\", None)\n        self.ssl = os.getenv(\"ssl\", None)\n        build_ext_module.initialize_options(self, *args, **kwargs)\n\n    def get_config(self, option):\n        config = ConfigParser()\n        config.read(P4_CONFIG_FILE)\n        dir = \"\"\n        if config.has_section(P4_CONFIG_SECTION):\n            if config.has_option(P4_CONFIG_SECTION, option):\n                dir = config.get(P4_CONFIG_SECTION, option)\n        return dir\n\n    def finalize_options(self):\n        global p4_api_dir, p4_ssl_dir\n\n        # options passed to \"build\" are copied into globals for use in \"build_ext\"\n        if p4_api_dir:\n            self.apidir = p4_api_dir\n\n        if p4_ssl_dir:\n            self.ssl = p4_ssl_dir\n\n        # if we didn't get values from the command line, check the config file\n        if not self.apidir:\n            self.apidir = self.get_config(P4_CONFIG_P4APIDIR)\n\n        if not self.ssl:\n            self.ssl = self.get_config(P4_CONFIG_SSLDIR)\n\n        build_ext_module.finalize_options(self)\n\n    def is_super(self):\n        rv = subprocess.check_output(\"id -u\", shell=True)\n        if int(rv) != 0:\n            return False\n        return True",
          "hash_value": "ab3c4c140520bd94a8409435900000f3",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class p4build_ext(build_ext_module):\n    \"\"\"Subclass of build subcommand for passing paths to compiler and linker\"\"\"\n\n    user_options = build_ext_module.user_options + [\n        ('ssl=', None, 'specify ssl library directory'),\n        ('apidir=', None, 'specify root of p4api directory'),\n    ]\n\n    def initialize_options(self, *args, **kwargs):\n        self.apidir = os.getenv(\"apidir\", None)\n        self.ssl = os.getenv(\"ssl\", None)\n        build_ext_module.initialize_options(self, *args, **kwargs)\n\n    def get_config(self, option):\n        config = ConfigParser()\n        config.read(P4_CONFIG_FILE)\n        dir = \"\"\n        if config.has_section(P4_CONFIG_SECTION):\n            if config.has_option(P4_CONFIG_SECTION, option):\n                dir = config.get(P4_CONFIG_SECTION, option)\n        return dir\n\n    def finalize_options(self):\n        global p4_api_dir, p4_ssl_dir\n\n        # options passed to \"build\" are copied into globals for use in \"build_ext\"\n        if p4_api_dir:\n            self.apidir = p4_api_dir\n\n        if p4_ssl_dir:\n            self.ssl = p4_ssl_dir\n\n        # if we didn't get values from the command line, check the config file\n        if not self.apidir:\n            self.apidir = self.get_config(P4_CONFIG_P4APIDIR)\n\n        if not self.ssl:\n            self.ssl = self.get_config(P4_CONFIG_SSLDIR)\n\n        build_ext_module.finalize_options(self)\n\n    def is_super(self):\n        rv = subprocess.check_output(\"id -u\", shell=True)\n        if int(rv) != 0:\n            return False\n        return True",
              "triple_sequences": [
                {
                  "action_api": "os.getenv()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"apidir\", None",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.getenv()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"ssl\", None",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "ConfigParser()",
                  "action_description": "Instantiates configuration parser object",
                  "action_id": "init_setup_class",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Access configuration value",
                  "intention_id": "access_configuration_value"
                },
                {
                  "action_api": "config.read()",
                  "action_description": "Opens file for reading",
                  "action_id": "basic_read_operations",
                  "object": "P4_CONFIG_FILE",
                  "object_description": "System configuration file",
                  "object_id": "system_config_file",
                  "intention_description": "Access file content",
                  "intention_id": "access_file_content"
                },
                {
                  "action_api": "config.has_section()",
                  "action_description": "Checks if specified path exists and is a directory",
                  "action_id": "check_directory_exists",
                  "object": "P4_CONFIG_SECTION",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Determine directory presence",
                  "intention_id": "determine_directory_presence"
                },
                {
                  "action_api": "config.has_option()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "P4_CONFIG_SECTION, option",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Determine file presence",
                  "intention_id": "determine_file_presence"
                },
                {
                  "action_api": "config.get()",
                  "action_description": "Retrieves value and data type for registry value",
                  "action_id": "get_registry_value",
                  "object": "P4_CONFIG_SECTION, option",
                  "object_description": "Registry value",
                  "object_id": "registry_value",
                  "intention_description": "Access configuration value",
                  "intention_id": "access_configuration_value"
                },
                {
                  "action_api": "subprocess.check_output()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "\"id -u\", shell=True",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Determine if user is administrator",
                  "intention_id": "determine_administrator_status"
                },
                {
                  "action_api": "int()",
                  "action_description": "Converts string to integer",
                  "action_id": "convert_char_to_int",
                  "object": "rv",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Convert string to integer",
                  "intention_id": "convert_string_to_integer"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "ruamel",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/ruamel.ordereddict-0.4.15.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ruamel.ordereddict-0.4.15/ruamel.ordereddict-0.4.15/setup.py",
          "line_number": "130",
          "type_description": "cmd-overwrite",
          "context_snippet": "def main():\n    install_requires = []\n    packages = [full_package_name] + [(full_package_name + '.' + x) for x\n                                     in find_packages(exclude=['tests'])]\n\n    setup(\n        name=full_package_name,\n        version=version_str,\n        description='a version of dict that keeps keys in '\\\n                    'insertion resp. sorted order',\n        install_requires=install_requires,\n        long_description=open('README.rst').read(),\n        url='https://bitbucket.org/ruamel/' + package_name,\n        author='Anthon van der Neut',\n        author_email='a.van.der.neut@ruamel.eu',\n        license=\"MIT license\",\n        package_dir={full_package_name: '.'},\n        namespace_packages=[name_space],\n        packages=packages,\n        ext_modules = [module1],\n        cmdclass={'install_lib': MyInstallLib},\n        classifiers=[\n            'Development Status :: 5 - Production/Stable',\n            'Intended Audience :: System Administrators',\n            'License :: OSI Approved :: MIT License',\n            'Operating System :: POSIX :: Linux',\n            'Programming Language :: Python',\n        ],\n    )\n\n# Data dependencies:\n# - setup: imported from setuptools\n# - full_package_name: defined as name_space + '.' + package_name\n# - version_str: set by _check_convert_version(version_info), which uses get_version()\n# - install_requires: local empty list\n# - open('README.rst').read(): reads README.rst file\n# - package_name: 'ordereddict'\n# - name_space: 'ruamel'\n# - module1: Extension('_ordereddict', ...)\n# - MyInstallLib: class defined above\n# - find_packages: imported from setuptools\n",
          "hash_value": "e1f5cacbaaa9b57d3a944c7e2e7a9ab3",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def main():\n    install_requires = []\n    packages = [full_package_name] + [(full_package_name + '.' + x) for x\n                                     in find_packages(exclude=['tests'])]\n\n    setup(\n        name=full_package_name,\n        version=version_str,\n        description='a version of dict that keeps keys in '\\\n                    'insertion resp. sorted order',\n        install_requires=install_requires,\n        long_description=open('README.rst').read(),\n        url='https://bitbucket.org/ruamel/' + package_name,\n        author='Anthon van der Neut',\n        author_email='a.van.der.neut@ruamel.eu',\n        license=\"MIT license\",\n        package_dir={full_package_name: '.'},\n        namespace_packages=[name_space],\n        packages=packages,\n        ext_modules = [module1],\n        cmdclass={'install_lib': MyInstallLib},\n        classifiers=[\n            'Development Status :: 5 - Production/Stable',\n            'Intended Audience :: System Administrators',\n            'License :: OSI Approved :: MIT License',\n            'Operating System :: POSIX :: Linux',\n            'Programming Language :: Python',\n        ],\n    )\n\n# Data dependencies:\n# - setup: imported from setuptools\n# - full_package_name: defined as name_space + '.' + package_name\n# - version_str: set by _check_convert_version(version_info), which uses get_version()\n# - install_requires: local empty list\n# - open('README.rst').read(): reads README.rst file\n# - package_name: 'ordereddict'\n# - name_space: 'ruamel'\n# - module1: Extension('_ordereddict', ...)\n# - MyInstallLib: class defined above\n# - find_packages: imported from setuptools\n",
              "triple_sequences": [
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "README.rst",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "{name: full_package_name, version: version_str, ...}",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "dcicutils-8",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/dcicutils-8.18.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "view_portal_object.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/dcicutils-8.18.3/dcicutils-8.18.3/dcicutils/scripts/view_portal_object.py",
          "line_number": "195",
          "type_description": "clipboard-access",
          "context_snippet": "def main():\n\n    global _output_file\n\n    parser = argparse.ArgumentParser(description=\"View Portal object.\")\n    parser.add_argument(\"uuid\", nargs=\"?\", type=str,\n                        help=f\"The uuid (or path) of the object to fetch and view. \")\n    parser.add_argument(\"--ini\", type=str, required=False, default=None,\n                        help=f\"Name of the application .ini file.\")\n    parser.add_argument(\"--env\", \"-e\", type=str, required=False, default=None,\n                        help=f\"Environment name (key from ~/.smaht-keys.json).\")\n    parser.add_argument(\"--server\", \"-s\", type=str, required=False, default=None,\n                        help=f\"Environment server name (server from key in ~/.smaht-keys.json).\")\n    parser.add_argument(\"--app\", type=str, required=False, default=None,\n                        help=f\"Application name (one of: smaht, cgap, fourfront).\")\n    parser.add_argument(\"--schema\", action=\"store_true\", required=False, default=False,\n                        help=\"View named schema rather than object.\")\n    parser.add_argument(\"--all\", action=\"store_true\", required=False, default=False,\n                        help=\"Include all properties for schema usage.\")\n    parser.add_argument(\"--raw\", action=\"store_true\", required=False, default=False, help=\"Raw output.\")\n    parser.add_argument(\"--inserts\", action=\"store_true\", required=False, default=False,\n                        help=\"Format output for subsequent inserts.\")\n    parser.add_argument(\"--insert-files\", action=\"store_true\", required=False, default=False,\n                        help=\"Output for to insert files.\")\n    parser.add_argument(\"--ignore\", nargs=\"+\", help=\"Ignore these fields for --inserts.\")\n    parser.add_argument(\"--tree\", action=\"store_true\", required=False, default=False, help=\"Tree output for schemas.\")\n    parser.add_argument(\"--database\", action=\"store_true\", required=False, default=False,\n                        help=\"Read from database output.\")\n    parser.add_argument(\"--bool\", action=\"store_true\", required=False,\n                        default=False, help=\"Only return whether found or not.\")\n    parser.add_argument(\"--yaml\", action=\"store_true\", required=False, default=False, help=\"YAML output.\")\n    parser.add_argument(\"--copy\", \"-c\", action=\"store_true\", required=False, default=False,\n                        help=\"Copy object data to clipboard.\")\n    parser.add_argument(\"--output\", required=False, help=\"Output file.\", type=str)\n    parser.add_argument(\"--indent\", required=False, default=False, help=\"Indent output.\", type=int)\n    parser.add_argument(\"--summary\", action=\"store_true\", required=False, default=False,\n                        help=\"Summary output (for schema only).\")\n    parser.add_argument(\"--force\", action=\"store_true\", required=False, default=False, help=\"Debugging output.\")\n    parser.add_argument(\"--terse\", action=\"store_true\", required=False, default=False, help=\"Terse output.\")\n    parser.add_argument(\"--verbose\", action=\"store_true\", required=False, default=False, help=\"Verbose output.\")\n    parser.add_argument(\"--noheader\", action=\"store_true\", required=False, default=False, help=\"Supress header output.\")\n    parser.add_argument(\"--debug\", action=\"store_true\", required=False, default=False, help=\"Debugging output.\")\n    args = parser.parse_args()\n\n    portal = _create_portal(ini=args.ini, env=args.env or os.environ.get(\"SMAHT_ENV\"),\n                            server=args.server, app=args.app,\n                            verbose=args.verbose and not args.noheader, debug=args.debug)\n\n    if not args.uuid:\n        _print(\"UUID or schema or path required.\")\n        _exit(1)\n\n    if args.insert_files:\n        args.inserts = True\n        if args.output:\n            if not os.path.isdir(args.output):\n                _print(f\"Specified output directory for insert files does not exist: {args.output}\")\n                exit(1)\n            args.insert_files = args.output\n            args.output = None\n\n    if args.output:\n        if os.path.exists(args.output):\n            if os.path.isdir(args.output):\n                _print(f\"Specified output file already exists as a directory: {args.output}\")\n                _exit(1)\n            elif os.path.isfile(args.output):\n                _print(f\"Specified output file already exists: {args.output}\")\n                if (not args.force) and not yes_or_no(f\"Do you want to overwrite this file?\"):\n                    _exit(0)\n        _output_file = io.open(args.output, \"w\")\n\n    if args.uuid and ((args.uuid.lower() == \"schemas\") or (args.uuid.lower() == \"schema\")):\n        _print_all_schema_names(portal=portal, terse=args.terse, all=args.all,\n                                tree=args.tree, summary=args.summary, yaml=args.yaml)\n        return\n    elif args.uuid and (args.uuid.lower() == \"info\"):\n        if consortia := portal.get_metadata(\"/consortia?limit=1000\"):\n            _print_output(\"Known Consortia:\")\n            consortia = sorted(consortia.get(\"@graph\", []), key=lambda key: key.get(\"identifier\"))\n            for consortium in consortia:\n                if ((consortium_name := consortium.get(\"identifier\")) and\n                    (consortium_uuid := consortium.get(\"uuid\"))):  # noqa\n                    _print_output(f\"- {consortium_name}: {consortium_uuid}\")\n        if submission_centers := portal.get_metadata(\"/submission-centers?limit=1000\"):\n            _print_output(\"Known Submission Centers:\")\n            submission_centers = sorted(submission_centers.get(\"@graph\", []), key=lambda key: key.get(\"identifier\"))\n            for submission_center in submission_centers:\n                if ((submission_center_name := submission_center.get(\"identifier\")) and\n                    (submission_center_uuid := submission_center.get(\"uuid\"))):  # noqa\n                    _print_output(f\"- {submission_center_name}: {submission_center_uuid}\")\n        try:\n            if file_formats := portal.get_metadata(\"/file-formats?limit=1000\"):\n                _print_output(\"Known File Formats:\")\n                file_formats = sorted(file_formats.get(\"@graph\", []), key=lambda key: key.get(\"identifier\"))\n                for file_format in file_formats:\n                    if ((file_format_name := file_format.get(\"identifier\")) and\n                        (file_format_uuid := file_format.get(\"uuid\"))):  # noqa\n                        _print_output(f\"- {file_format_name}: {file_format_uuid}\")\n        except Exception:\n            _print_output(\"Known File Formats: None\")\n        return\n\n    if _is_maybe_schema_name(args.uuid):\n        args.schema = True\n\n    if args.schema:\n        schema, schema_name = _get_schema(portal, args.uuid)\n        if schema:\n            if args.copy:\n                pyperclip.copy(json.dumps(schema, indent=4))\n            if args.summary:\n                if parent_schema_name := _get_parent_schema_name(schema):\n                    if schema.get(\"isAbstract\") is True:\n                        _print_output(f\"{schema_name} | parent: {parent_schema_name} | abstract\")\n                    else:\n                        _print_output(f\"{schema_name} | parent: {parent_schema_name}\")\n                else:\n                    _print_output(schema_name)\n            _print_schema(schema, terse=args.terse,\n                          all=args.all, summary=args.summary, yaml=args.yaml)\n            return\n\n    data = _get_portal_object(portal=portal, uuid=args.uuid, raw=args.raw, database=args.database,\n                              inserts=args.inserts, insert_files=args.insert_files,\n                              ignore=args.ignore, check=args.bool,\n                              force=args.force, verbose=args.verbose, debug=args.debug)\n    if args.insert_files:\n        return\n\n    if args.bool:\n        if data:\n            _print(f\"{args.uuid}: found\")\n            _exit(0)\n        else:\n            _print(f\"{args.uuid}: not found\")\n            _exit(1)\n    if args.copy:\n        pyperclip.copy(json.dumps(data, indent=4))\n    if args.yaml:\n        _print_output(yaml.dump(data))\n    else:\n        if args.indent > 0:\n            _print_output(_format_json_with_indent(data, indent=args.indent))\n        else:\n            _print_output(json.dumps(data, default=str, indent=4))",
          "hash_value": "bc7476376c90fb673cc2fa98c39359b2",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def main():\n\n    global _output_file\n\n    parser = argparse.ArgumentParser(description=\"View Portal object.\")\n    parser.add_argument(\"uuid\", nargs=\"?\", type=str,\n                        help=f\"The uuid (or path) of the object to fetch and view. \")\n    parser.add_argument(\"--ini\", type=str, required=False, default=None,\n                        help=f\"Name of the application .ini file.\")\n    parser.add_argument(\"--env\", \"-e\", type=str, required=False, default=None,\n                        help=f\"Environment name (key from ~/.smaht-keys.json).\")\n    parser.add_argument(\"--server\", \"-s\", type=str, required=False, default=None,\n                        help=f\"Environment server name (server from key in ~/.smaht-keys.json).\")\n    parser.add_argument(\"--app\", type=str, required=False, default=None,\n                        help=f\"Application name (one of: smaht, cgap, fourfront).\")\n    parser.add_argument(\"--schema\", action=\"store_true\", required=False, default=False,\n                        help=\"View named schema rather than object.\")\n    parser.add_argument(\"--all\", action=\"store_true\", required=False, default=False,\n                        help=\"Include all properties for schema usage.\")\n    parser.add_argument(\"--raw\", action=\"store_true\", required=False, default=False, help=\"Raw output.\")\n    parser.add_argument(\"--inserts\", action=\"store_true\", required=False, default=False,\n                        help=\"Format output for subsequent inserts.\")\n    parser.add_argument(\"--insert-files\", action=\"store_true\", required=False, default=False,\n                        help=\"Output for to insert files.\")\n    parser.add_argument(\"--ignore\", nargs=\"+\", help=\"Ignore these fields for --inserts.\")\n    parser.add_argument(\"--tree\", action=\"store_true\", required=False, default=False, help=\"Tree output for schemas.\")\n    parser.add_argument(\"--database\", action=\"store_true\", required=False, default=False,\n                        help=\"Read from database output.\")\n    parser.add_argument(\"--bool\", action=\"store_true\", required=False,\n                        default=False, help=\"Only return whether found or not.\")\n    parser.add_argument(\"--yaml\", action=\"store_true\", required=False, default=False, help=\"YAML output.\")\n    parser.add_argument(\"--copy\", \"-c\", action=\"store_true\", required=False, default=False,\n                        help=\"Copy object data to clipboard.\")\n    parser.add_argument(\"--output\", required=False, help=\"Output file.\", type=str)\n    parser.add_argument(\"--indent\", required=False, default=False, help=\"Indent output.\", type=int)\n    parser.add_argument(\"--summary\", action=\"store_true\", required=False, default=False,\n                        help=\"Summary output (for schema only).\")\n    parser.add_argument(\"--force\", action=\"store_true\", required=False, default=False, help=\"Debugging output.\")\n    parser.add_argument(\"--terse\", action=\"store_true\", required=False, default=False, help=\"Terse output.\")\n    parser.add_argument(\"--verbose\", action=\"store_true\", required=False, default=False, help=\"Verbose output.\")\n    parser.add_argument(\"--noheader\", action=\"store_true\", required=False, default=False, help=\"Supress header output.\")\n    parser.add_argument(\"--debug\", action=\"store_true\", required=False, default=False, help=\"Debugging output.\")\n    args = parser.parse_args()\n\n    portal = _create_portal(ini=args.ini, env=args.env or os.environ.get(\"SMAHT_ENV\"),\n                            server=args.server, app=args.app,\n                            verbose=args.verbose and not args.noheader, debug=args.debug)\n\n    if not args.uuid:\n        _print(\"UUID or schema or path required.\")\n        _exit(1)\n\n    if args.insert_files:\n        args.inserts = True\n        if args.output:\n            if not os.path.isdir(args.output):\n                _print(f\"Specified output directory for insert files does not exist: {args.output}\")\n                exit(1)\n            args.insert_files = args.output\n            args.output = None\n\n    if args.output:\n        if os.path.exists(args.output):\n            if os.path.isdir(args.output):\n                _print(f\"Specified output file already exists as a directory: {args.output}\")\n                _exit(1)\n            elif os.path.isfile(args.output):\n                _print(f\"Specified output file already exists: {args.output}\")\n                if (not args.force) and not yes_or_no(f\"Do you want to overwrite this file?\"):\n                    _exit(0)\n        _output_file = io.open(args.output, \"w\")\n\n    if args.uuid and ((args.uuid.lower() == \"schemas\") or (args.uuid.lower() == \"schema\")):\n        _print_all_schema_names(portal=portal, terse=args.terse, all=args.all,\n                                tree=args.tree, summary=args.summary, yaml=args.yaml)\n        return\n    elif args.uuid and (args.uuid.lower() == \"info\"):\n        if consortia := portal.get_metadata(\"/consortia?limit=1000\"):\n            _print_output(\"Known Consortia:\")\n            consortia = sorted(consortia.get(\"@graph\", []), key=lambda key: key.get(\"identifier\"))\n            for consortium in consortia:\n                if ((consortium_name := consortium.get(\"identifier\")) and\n                    (consortium_uuid := consortium.get(\"uuid\"))):  # noqa\n                    _print_output(f\"- {consortium_name}: {consortium_uuid}\")\n        if submission_centers := portal.get_metadata(\"/submission-centers?limit=1000\"):\n            _print_output(\"Known Submission Centers:\")\n            submission_centers = sorted(submission_centers.get(\"@graph\", []), key=lambda key: key.get(\"identifier\"))\n            for submission_center in submission_centers:\n                if ((submission_center_name := submission_center.get(\"identifier\")) and\n                    (submission_center_uuid := submission_center.get(\"uuid\"))):  # noqa\n                    _print_output(f\"- {submission_center_name}: {submission_center_uuid}\")\n        try:\n            if file_formats := portal.get_metadata(\"/file-formats?limit=1000\"):\n                _print_output(\"Known File Formats:\")\n                file_formats = sorted(file_formats.get(\"@graph\", []), key=lambda key: key.get(\"identifier\"))\n                for file_format in file_formats:\n                    if ((file_format_name := file_format.get(\"identifier\")) and\n                        (file_format_uuid := file_format.get(\"uuid\"))):  # noqa\n                        _print_output(f\"- {file_format_name}: {file_format_uuid}\")\n        except Exception:\n            _print_output(\"Known File Formats: None\")\n        return\n\n    if _is_maybe_schema_name(args.uuid):\n        args.schema = True\n\n    if args.schema:\n        schema, schema_name = _get_schema(portal, args.uuid)\n        if schema:\n            if args.copy:\n                pyperclip.copy(json.dumps(schema, indent=4))\n            if args.summary:\n                if parent_schema_name := _get_parent_schema_name(schema):\n                    if schema.get(\"isAbstract\") is True:\n                        _print_output(f\"{schema_name} | parent: {parent_schema_name} | abstract\")\n                    else:\n                        _print_output(f\"{schema_name} | parent: {parent_schema_name}\")\n                else:\n                    _print_output(schema_name)\n            _print_schema(schema, terse=args.terse,\n                          all=args.all, summary=args.summary, yaml=args.yaml)\n            return\n\n    data = _get_portal_object(portal=portal, uuid=args.uuid, raw=args.raw, database=args.database,\n                              inserts=args.inserts, insert_files=args.insert_files,\n                              ignore=args.ignore, check=args.bool,\n                              force=args.force, verbose=args.verbose, debug=args.debug)\n    if args.insert_files:\n        return\n\n    if args.bool:\n        if data:\n            _print(f\"{args.uuid}: found\")\n            _exit(0)\n        else:\n            _print(f\"{args.uuid}: not found\")\n            _exit(1)\n    if args.copy:\n        pyperclip.copy(json.dumps(data, indent=4))\n    if args.yaml:\n        _print_output(yaml.dump(data))\n    else:\n        if args.indent > 0:\n            _print_output(_format_json_with_indent(data, indent=args.indent))\n        else:\n            _print_output(json.dumps(data, default=str, indent=4))",
              "triple_sequences": [
                {
                  "action_api": "argparse.ArgumentParser()",
                  "action_description": "Creates HTTP request object with specified URL, data, and headers",
                  "action_id": "create_http_request",
                  "object": "description=\"View Portal object.\"",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Collect user input",
                  "intention_id": "collect_user_input"
                },
                {
                  "action_api": "parser.add_argument()",
                  "action_description": "Creates HTTP request object with specified URL, data, and headers",
                  "action_id": "create_http_request",
                  "object": "\"uuid\", nargs=\"?\", type=str, help=f\"The uuid (or path) of the object to fetch and view. \"",
                  "object_description": "Command output",
                  "object_id": "command_output",
                  "intention_description": "Collect user input",
                  "intention_id": "collect_user_input"
                },
                {
                  "action_api": "parser.parse_args()",
                  "action_description": "Reads user input from standard input",
                  "action_id": "read_user_input",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect user input",
                  "intention_id": "collect_user_input"
                },
                {
                  "action_api": "_create_portal()",
                  "action_description": "Instantiates Setup class",
                  "action_id": "init_setup_class",
                  "object": "ini=args.ini, env=args.env or os.environ.get(\"SMAHT_ENV\"), server=args.server, app=args.app, verbose=args.verbose and not args.noheader, debug=args.debug",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Gather system information",
                  "intention_id": "gather_system_information"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"SMAHT_ENV\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.path.isdir()",
                  "action_description": "Checks if specified path exists and is a directory",
                  "action_id": "check_directory_exists",
                  "object": "args.output",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "args.output",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "os.path.isdir()",
                  "action_description": "Checks if specified path exists and is a directory",
                  "action_id": "check_directory_exists",
                  "object": "args.output",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "os.path.isfile()",
                  "action_description": "Checks if specified path exists and is a file",
                  "action_id": "check_file_is_file",
                  "object": "args.output",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "io.open()",
                  "action_description": "File opening operations for writing (normal writing, binary writing)",
                  "action_id": "basic_write_operations",
                  "object": "args.output, \"w\"",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for writing",
                  "intention_id": "open_file_writing"
                },
                {
                  "action_api": "portal.get_metadata()",
                  "action_description": "Retrieves operating system information",
                  "action_id": "get_os_info",
                  "object": "\"/consortia?limit=1000\"",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Gather system information",
                  "intention_id": "gather_system_information"
                },
                {
                  "action_api": "portal.get_metadata()",
                  "action_description": "Retrieves operating system information",
                  "action_id": "get_os_info",
                  "object": "\"/submission-centers?limit=1000\"",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Gather system information",
                  "intention_id": "gather_system_information"
                },
                {
                  "action_api": "portal.get_metadata()",
                  "action_description": "Retrieves operating system information",
                  "action_id": "get_os_info",
                  "object": "\"/file-formats?limit=1000\"",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Gather system information",
                  "intention_id": "gather_system_information"
                },
                {
                  "action_api": "_get_schema()",
                  "action_description": "Instantiates Setup class",
                  "action_id": "init_setup_class",
                  "object": "portal, args.uuid",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Gather system information",
                  "intention_id": "gather_system_information"
                },
                {
                  "action_api": "pyperclip.copy()",
                  "action_description": "Copies specified text to system clipboard",
                  "action_id": "copy_to_clipboard",
                  "object": "json.dumps(schema, indent=4)",
                  "object_description": "Clipboard content data",
                  "object_id": "clipboard_data",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                },
                {
                  "action_api": "json.dumps()",
                  "action_description": "Serializes Python object to JSON string",
                  "action_id": "serialize_to_json",
                  "object": "schema, indent=4",
                  "object_description": "JSON string",
                  "object_id": "json_string",
                  "intention_description": "Serialize data",
                  "intention_id": "serialize_data"
                },
                {
                  "action_api": "_get_parent_schema_name()",
                  "action_description": "Instantiates Setup class",
                  "action_id": "init_setup_class",
                  "object": "schema",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Gather system information",
                  "intention_id": "gather_system_information"
                },
                {
                  "action_api": "_print_schema()",
                  "action_description": "Instantiates Setup class",
                  "action_id": "init_setup_class",
                  "object": "schema, terse=args.terse, all=args.all, summary=args.summary, yaml=args.yaml",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Gather system information",
                  "intention_id": "gather_system_information"
                },
                {
                  "action_api": "_get_portal_object()",
                  "action_description": "Instantiates Setup class",
                  "action_id": "init_setup_class",
                  "object": "portal=portal, uuid=args.uuid, raw=args.raw, database=args.database, inserts=args.inserts, insert_files=args.insert_files, ignore=args.ignore, check=args.bool, force=args.force, verbose=args.verbose, debug=args.debug",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Gather system information",
                  "intention_id": "gather_system_information"
                },
                {
                  "action_api": "pyperclip.copy()",
                  "action_description": "Copies specified text to system clipboard",
                  "action_id": "copy_to_clipboard",
                  "object": "json.dumps(data, indent=4)",
                  "object_description": "Clipboard content data",
                  "object_id": "clipboard_data",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                },
                {
                  "action_api": "json.dumps()",
                  "action_description": "Serializes Python object to JSON string",
                  "action_id": "serialize_to_json",
                  "object": "data, indent=4",
                  "object_description": "JSON string",
                  "object_id": "json_string",
                  "intention_description": "Serialize data",
                  "intention_id": "serialize_data"
                },
                {
                  "action_api": "yaml.dump()",
                  "action_description": "Serializes Python object to JSON string",
                  "action_id": "serialize_to_json",
                  "object": "data",
                  "object_description": "JSON string",
                  "object_id": "json_string",
                  "intention_description": "Serialize data",
                  "intention_id": "serialize_data"
                },
                {
                  "action_api": "_format_json_with_indent()",
                  "action_description": "Serializes Python object to JSON string",
                  "action_id": "serialize_to_json",
                  "object": "data, indent=args.indent",
                  "object_description": "JSON string",
                  "object_id": "json_string",
                  "intention_description": "Serialize data",
                  "intention_id": "serialize_data"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "unicorn-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/unicorn-2.1.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/unicorn-2.1.3/unicorn-2.1.3/setup.py",
          "line_number": "116",
          "type_description": "code-execution",
          "context_snippet": "def build_libraries():\n    \"\"\"\n    Prepare the unicorn directory for a binary distribution or installation.\n    Builds shared libraries and copies header files.\n\n    Will use a src/ dir if one exists in the current directory, otherwise assumes it's in the repo\n    \"\"\"\n    clean_bins()\n    os.mkdir(HEADERS_DIR)\n    os.mkdir(LIBS_DIR)\n\n    # copy public headers\n    shutil.copytree(os.path.join(UC_DIR, 'include', 'unicorn'), os.path.join(HEADERS_DIR, 'unicorn'))\n\n    # check if a prebuilt library exists and if so, use it instead of building\n    if os.path.exists(os.path.join(ROOT_DIR, 'prebuilt', LIBRARY_FILE)):\n        shutil.copy(os.path.join(ROOT_DIR, 'prebuilt', LIBRARY_FILE), LIBS_DIR)\n        if STATIC_LIBRARY_FILE is not None and os.path.exists(os.path.join(ROOT_DIR, 'prebuilt', STATIC_LIBRARY_FILE)):\n            shutil.copy(os.path.join(ROOT_DIR, 'prebuilt', STATIC_LIBRARY_FILE), LIBS_DIR)\n        return\n\n    # otherwise, build\n    if not os.path.exists(BUILD_DIR):\n        os.mkdir(BUILD_DIR)\n\n    has_msbuild = shutil.which('msbuild') is not None\n    conf = 'Debug' if int(os.getenv('DEBUG', 0)) else 'Release'\n    cmake_args = ['cmake', '-B', BUILD_DIR, \"-DCMAKE_BUILD_TYPE=\" + conf, \"-DUNICORN_BUILD_TESTS=off\"]\n    if os.getenv(\"UNICORN_TRACER\"):\n        cmake_args += [\"-DUNICORN_TRACER=on\"]\n    if conf == 'Debug':\n        cmake_args += [\"-DUNICORN_LOGGING=on\"]\n\n    if has_msbuild and sys.platform == 'win32':\n        generators = os.getenv('GENERATORS') or 'Visual Studio 16 2019'\n        plat = 'Win32' if platform.architecture()[0] == '32bit' else 'x64'\n        cmake_args += ['-G', generators, \"-A\", plat]\n        subprocess.check_call(cmake_args, cwd=UC_DIR)\n        subprocess.check_call(['msbuild', 'unicorn.sln', '-m', '-p:Platform=' + plat, '-p:Configuration=' + conf],\n                              cwd=BUILD_DIR)\n\n        obj_dir = os.path.join(BUILD_DIR, conf)\n        shutil.copy(os.path.join(obj_dir, LIBRARY_FILE), LIBS_DIR)\n        shutil.copy(os.path.join(obj_dir, STATIC_LIBRARY_FILE), LIBS_DIR)\n    else:\n        cmake_args += ['-S', UC_DIR]\n        subprocess.check_call(cmake_args, cwd=UC_DIR)\n        threads = os.getenv(\"THREADS\", \"4\")\n        subprocess.check_call([\"cmake\", \"--build\", \".\", \"-j\" + threads], cwd=BUILD_DIR)\n\n        shutil.copy(os.path.join(BUILD_DIR, LIBRARY_FILE), LIBS_DIR)\n        shutil.copy(os.path.join(BUILD_DIR, STATIC_LIBRARY_FILE), LIBS_DIR)\n",
          "hash_value": "d62a0d584ade3493fd17d99c5ba43e8e",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def build_libraries():\n    \"\"\"\n    Prepare the unicorn directory for a binary distribution or installation.\n    Builds shared libraries and copies header files.\n\n    Will use a src/ dir if one exists in the current directory, otherwise assumes it's in the repo\n    \"\"\"\n    clean_bins()\n    os.mkdir(HEADERS_DIR)\n    os.mkdir(LIBS_DIR)\n\n    # copy public headers\n    shutil.copytree(os.path.join(UC_DIR, 'include', 'unicorn'), os.path.join(HEADERS_DIR, 'unicorn'))\n\n    # check if a prebuilt library exists and if so, use it instead of building\n    if os.path.exists(os.path.join(ROOT_DIR, 'prebuilt', LIBRARY_FILE)):\n        shutil.copy(os.path.join(ROOT_DIR, 'prebuilt', LIBRARY_FILE), LIBS_DIR)\n        if STATIC_LIBRARY_FILE is not None and os.path.exists(os.path.join(ROOT_DIR, 'prebuilt', STATIC_LIBRARY_FILE)):\n            shutil.copy(os.path.join(ROOT_DIR, 'prebuilt', STATIC_LIBRARY_FILE), LIBS_DIR)\n        return\n\n    # otherwise, build\n    if not os.path.exists(BUILD_DIR):\n        os.mkdir(BUILD_DIR)\n\n    has_msbuild = shutil.which('msbuild') is not None\n    conf = 'Debug' if int(os.getenv('DEBUG', 0)) else 'Release'\n    cmake_args = ['cmake', '-B', BUILD_DIR, \"-DCMAKE_BUILD_TYPE=\" + conf, \"-DUNICORN_BUILD_TESTS=off\"]\n    if os.getenv(\"UNICORN_TRACER\"):\n        cmake_args += [\"-DUNICORN_TRACER=on\"]\n    if conf == 'Debug':\n        cmake_args += [\"-DUNICORN_LOGGING=on\"]\n\n    if has_msbuild and sys.platform == 'win32':\n        generators = os.getenv('GENERATORS') or 'Visual Studio 16 2019'\n        plat = 'Win32' if platform.architecture()[0] == '32bit' else 'x64'\n        cmake_args += ['-G', generators, \"-A\", plat]\n        subprocess.check_call(cmake_args, cwd=UC_DIR)\n        subprocess.check_call(['msbuild', 'unicorn.sln', '-m', '-p:Platform=' + plat, '-p:Configuration=' + conf],\n                              cwd=BUILD_DIR)\n\n        obj_dir = os.path.join(BUILD_DIR, conf)\n        shutil.copy(os.path.join(obj_dir, LIBRARY_FILE), LIBS_DIR)\n        shutil.copy(os.path.join(obj_dir, STATIC_LIBRARY_FILE), LIBS_DIR)\n    else:\n        cmake_args += ['-S', UC_DIR]\n        subprocess.check_call(cmake_args, cwd=UC_DIR)\n        threads = os.getenv(\"THREADS\", \"4\")\n        subprocess.check_call([\"cmake\", \"--build\", \".\", \"-j\" + threads], cwd=BUILD_DIR)\n\n        shutil.copy(os.path.join(BUILD_DIR, LIBRARY_FILE), LIBS_DIR)\n        shutil.copy(os.path.join(BUILD_DIR, STATIC_LIBRARY_FILE), LIBS_DIR)\n",
              "triple_sequences": [
                {
                  "action_api": "os.mkdir()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "HEADERS_DIR",
                  "object_description": "Custom directory",
                  "object_id": "custom_directory",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "os.mkdir()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "LIBS_DIR",
                  "object_description": "Custom directory",
                  "object_id": "custom_directory",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "shutil.copytree()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "os.path.join(UC_DIR, 'include', 'unicorn'), os.path.join(HEADERS_DIR, 'unicorn')",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Copy file to temporary directory",
                  "intention_id": "copy_file_temp_directory"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "os.path.join(ROOT_DIR, 'prebuilt', LIBRARY_FILE)",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "shutil.copy()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "os.path.join(ROOT_DIR, 'prebuilt', LIBRARY_FILE), LIBS_DIR",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Copy file to temporary directory",
                  "intention_id": "copy_file_temp_directory"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "os.path.join(ROOT_DIR, 'prebuilt', STATIC_LIBRARY_FILE)",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "shutil.copy()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "os.path.join(ROOT_DIR, 'prebuilt', STATIC_LIBRARY_FILE), LIBS_DIR",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Copy file to temporary directory",
                  "intention_id": "copy_file_temp_directory"
                },
                {
                  "action_api": "os.path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "BUILD_DIR",
                  "object_description": "Custom directory",
                  "object_id": "custom_directory",
                  "intention_description": "Check if file or directory exists",
                  "intention_id": "check_file_existence"
                },
                {
                  "action_api": "os.mkdir()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "BUILD_DIR",
                  "object_description": "Custom directory",
                  "object_id": "custom_directory",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "os.getenv()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'DEBUG', 0",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.getenv()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"UNICORN_TRACER\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.getenv()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'GENERATORS'",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "platform.architecture()",
                  "action_description": "Retrieves machine type",
                  "action_id": "get_machine_type",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get system info",
                  "intention_id": "get_system_info"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "cmake_args, cwd=UC_DIR",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "['msbuild', 'unicorn.sln', '-m', '-p:Platform=' + plat, '-p:Configuration=' + conf], cwd=BUILD_DIR",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "BUILD_DIR, conf",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "shutil.copy()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "os.path.join(obj_dir, LIBRARY_FILE), LIBS_DIR",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Copy file to temporary directory",
                  "intention_id": "copy_file_temp_directory"
                },
                {
                  "action_api": "shutil.copy()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "os.path.join(obj_dir, STATIC_LIBRARY_FILE), LIBS_DIR",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Copy file to temporary directory",
                  "intention_id": "copy_file_temp_directory"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "cmake_args, cwd=UC_DIR",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "os.getenv()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"THREADS\", \"4\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"cmake\", \"--build\", \".\", \"-j\" + threads], cwd=BUILD_DIR",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "shutil.copy()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "os.path.join(BUILD_DIR, LIBRARY_FILE), LIBS_DIR",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Copy file to temporary directory",
                  "intention_id": "copy_file_temp_directory"
                },
                {
                  "action_api": "shutil.copy()",
                  "action_description": "Copies file to destination",
                  "action_id": "copy_file",
                  "object": "os.path.join(BUILD_DIR, STATIC_LIBRARY_FILE), LIBS_DIR",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Copy file to temporary directory",
                  "intention_id": "copy_file_temp_directory"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "snappy_manifolds-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/snappy_manifolds-1.2.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/snappy_manifolds-1.2.1/snappy_manifolds-1.2.1/setup.py",
          "line_number": "11",
          "type_description": "code-execution",
          "context_snippet": "import re, sys, subprocess, os, shutil, glob, sysconfig\n\ndef check_call(args):\n    try:\n        subprocess.check_call(args)\n    except subprocess.CalledProcessError:\n        executable = args[0]\n        command = [a for a in args if not a.startswith('-')][-1]\n        raise RuntimeError(command + ' failed for ' + executable)",
          "hash_value": "f518f58c434fe51465ac01af9cdd8962",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import re, sys, subprocess, os, shutil, glob, sysconfig\n\ndef check_call(args):\n    try:\n        subprocess.check_call(args)\n    except subprocess.CalledProcessError:\n        executable = args[0]\n        command = [a for a in args if not a.startswith('-')][-1]\n        raise RuntimeError(command + ' failed for ' + executable)",
              "triple_sequences": [
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "args",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "deal-4",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/deal-4.24.5.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "_contract.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/deal-4.24.5/deal-4.24.5/deal/linter/_contract.py",
          "line_number": "154",
          "type_description": "obfuscation",
          "context_snippet": "    @cached_property\n    def exceptions(self) -> list[Union[str, type[BaseException]]]:\n        from ._extractors import get_name\n\n        excs = []\n        for expr in self.args:\n            name = get_name(expr)\n            if not name:\n                continue\n            exc = getattr(builtins, name, name)\n            excs.append(exc)\n        return excs",
          "hash_value": "c547e088ef58f810e8fff3b941ce9b1e",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "    @cached_property\n    def exceptions(self) -> list[Union[str, type[BaseException]]]:\n        from ._extractors import get_name\n\n        excs = []\n        for expr in self.args:\n            name = get_name(expr)\n            if not name:\n                continue\n            exc = getattr(builtins, name, name)\n            excs.append(exc)\n        return excs",
              "triple_sequences": [
                {
                  "action_api": "get_name()",
                  "action_description": "Extracts current call stack as FrameSummary objects",
                  "action_id": "extract_call_stack",
                  "object": "expr",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare character for further processing",
                  "intention_id": "prepare_character_processing"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "builtins, name, name",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "excs.append()",
                  "action_description": "Serializes Python object to JSON string",
                  "action_id": "serialize_to_json",
                  "object": "exc",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Prepare character for further processing",
                  "intention_id": "prepare_character_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "geocoder-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/geocoder-1.38.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "ipinfo.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/geocoder-1.38.1/geocoder-1.38.1/geocoder/ipinfo.py",
          "line_number": "75",
          "type_description": "shady-links",
          "context_snippet": "class IpinfoQuery(MultipleResultsQuery):\n    \"\"\"\n    API Reference\n    -------------\n    https://ipinfo.io\n    \"\"\"\n    provider = 'ipinfo'\n    method = 'geocode'\n\n    _URL = 'http://ipinfo.io/json'\n    _RESULT_CLASS = IpinfoResult\n    _KEY_MANDATORY = False\n\n    def _before_initialize(self, location, **kwargs):\n        if location.lower() == 'me' or location == '':\n            self.url = 'http://ipinfo.io/json'\n        else:\n            self.url = 'http://ipinfo.io/{0}/json'.format(self.location)\n",
          "hash_value": "8d4e4fe4a2f941c4d9bfd4a4adee6aa7",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class IpinfoQuery(MultipleResultsQuery):\n    \"\"\"\n    API Reference\n    -------------\n    https://ipinfo.io\n    \"\"\"\n    provider = 'ipinfo'\n    method = 'geocode'\n\n    _URL = 'http://ipinfo.io/json'\n    _RESULT_CLASS = IpinfoResult\n    _KEY_MANDATORY = False\n\n    def _before_initialize(self, location, **kwargs):\n        if location.lower() == 'me' or location == '':\n            self.url = 'http://ipinfo.io/json'\n        else:\n            self.url = 'http://ipinfo.io/{0}/json'.format(self.location)\n",
              "triple_sequences": [
                {
                  "action_api": "str.lower()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "location",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "str.format()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "'http://ipinfo.io/{0}/json'",
                  "object_description": "URL string",
                  "object_id": "url_string",
                  "intention_description": "Prepare URL for HTTP request",
                  "intention_id": "prepare_url_http_request"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "inflate64-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/inflate64-1.0.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/inflate64-1.0.1/inflate64-1.0.1/setup.py",
          "line_number": "64",
          "type_description": "cmd-overwrite",
          "context_snippet": "from setuptools import Extension, setup\nfrom setuptools.command.build_ext import build_ext\nfrom setuptools.command.egg_info import egg_info\n\nsources = [\n    \"src/lib/deflate.c\",\n    \"src/lib/deflate_tree.c\",\n    \"src/lib/inflate.c\",\n    \"src/lib/inflate_tree.c\",\n    \"src/lib/util.c\",\n    \"src/lib/static_tables.c\"\n]\npackages = [\"inflate64\"]\nkwargs = {\"include_dirs\": [\"src/lib\", \"src/ext\"], \"library_dirs\": [], \"libraries\": [], \"sources\": sources, \"define_macros\": []}\n# binary extension\nkwargs[\"name\"] = \"inflate64._inflate64\"\nkwargs[\"sources\"].append(\"src/ext/_inflate64module.c\")\nbinary_extension = Extension(**kwargs)\n_deflate64_extension = Extension(\"inflate64._inflate64\", sources)\n\ndef has_option(option):\n    if option in sys.argv:\n        sys.argv = [s for s in sys.argv if s != option]\n        return True\n    else:\n        return False\n\nWARNING_AS_ERROR = has_option(\"--warning-as-error\")\n\nclass build_ext_compiler_check(build_ext):\n    def build_extensions(self):\n        for extension in self.extensions:\n            if self.compiler.compiler_type.lower() in (\"unix\", \"mingw32\"):\n                if WARNING_AS_ERROR:\n                    extension.extra_compile_args.append(\"-Werror\")\n            elif self.compiler.compiler_type.lower() == \"msvc\":\n                # /GF eliminates duplicate strings\n                # /Gy does function level linking\n                more_options = [\"/GF\", \"/Gy\", \"/wd4996\"]\n                if WARNING_AS_ERROR:\n                    more_options.append(\"/WX\")\n                extension.extra_compile_args.extend(more_options)\n        super().build_extensions()\n\n# Work around pypa/setuptools#436.\nclass my_egg_info(egg_info):\n    def run(self):\n        try:\n            os.remove(os.path.join(self.egg_info, \"SOURCES.txt\"))\n        except FileNotFoundError:\n            pass\n        super().run()\n\nsetup(\n    ext_modules=[binary_extension],\n    package_dir={\"\": \"src\"},\n    packages=packages,\n    cmdclass={\"build_ext\": build_ext_compiler_check, \"egg_info\": my_egg_info},\n)\n",
          "hash_value": "5532b6c425b34f49f327fa0ee663a5d8",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from setuptools import Extension, setup\nfrom setuptools.command.build_ext import build_ext\nfrom setuptools.command.egg_info import egg_info\n\nsources = [\n    \"src/lib/deflate.c\",\n    \"src/lib/deflate_tree.c\",\n    \"src/lib/inflate.c\",\n    \"src/lib/inflate_tree.c\",\n    \"src/lib/util.c\",\n    \"src/lib/static_tables.c\"\n]\npackages = [\"inflate64\"]\nkwargs = {\"include_dirs\": [\"src/lib\", \"src/ext\"], \"library_dirs\": [], \"libraries\": [], \"sources\": sources, \"define_macros\": []}\n# binary extension\nkwargs[\"name\"] = \"inflate64._inflate64\"\nkwargs[\"sources\"].append(\"src/ext/_inflate64module.c\")\nbinary_extension = Extension(**kwargs)\n_deflate64_extension = Extension(\"inflate64._inflate64\", sources)\n\ndef has_option(option):\n    if option in sys.argv:\n        sys.argv = [s for s in sys.argv if s != option]\n        return True\n    else:\n        return False\n\nWARNING_AS_ERROR = has_option(\"--warning-as-error\")\n\nclass build_ext_compiler_check(build_ext):\n    def build_extensions(self):\n        for extension in self.extensions:\n            if self.compiler.compiler_type.lower() in (\"unix\", \"mingw32\"):\n                if WARNING_AS_ERROR:\n                    extension.extra_compile_args.append(\"-Werror\")\n            elif self.compiler.compiler_type.lower() == \"msvc\":\n                # /GF eliminates duplicate strings\n                # /Gy does function level linking\n                more_options = [\"/GF\", \"/Gy\", \"/wd4996\"]\n                if WARNING_AS_ERROR:\n                    more_options.append(\"/WX\")\n                extension.extra_compile_args.extend(more_options)\n        super().build_extensions()\n\n# Work around pypa/setuptools#436.\nclass my_egg_info(egg_info):\n    def run(self):\n        try:\n            os.remove(os.path.join(self.egg_info, \"SOURCES.txt\"))\n        except FileNotFoundError:\n            pass\n        super().run()\n\nsetup(\n    ext_modules=[binary_extension],\n    package_dir={\"\": \"src\"},\n    packages=packages,\n    cmdclass={\"build_ext\": build_ext_compiler_check, \"egg_info\": my_egg_info},\n)\n",
              "triple_sequences": [
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "self.egg_info, \"SOURCES.txt\"",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.remove()",
                  "action_description": "Deletes specified file from filesystem",
                  "action_id": "delete_file",
                  "object": "os.path.join(self.egg_info, \"SOURCES.txt\")",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Delete file",
                  "intention_id": "delete_file"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Executes setuptools installation procedure",
                  "action_id": "exec_setuptools_install",
                  "object": "ext_modules=[binary_extension], package_dir={\"\": \"src\"}, packages=packages, cmdclass={\"build_ext\": build_ext_compiler_check, \"egg_info\": my_egg_info}",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "realesrgan-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/realesrgan-0.3.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/realesrgan-0.3.0/realesrgan-0.3.0/setup.py",
          "line_number": "31",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport subprocess\n\ndef get_git_hash():\n\n    def _minimal_ext_cmd(cmd):\n        # construct minimal environment\n        env = {}\n        for k in ['SYSTEMROOT', 'PATH', 'HOME']:\n            v = os.environ.get(k)\n            if v is not None:\n                env[k] = v\n        # LANGUAGE is used on win32\n        env['LANGUAGE'] = 'C'\n        env['LANG'] = 'C'\n        env['LC_ALL'] = 'C'\n        out = subprocess.Popen(cmd, stdout=subprocess.PIPE, env=env).communicate()[0]\n        return out\n\n    try:\n        out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])\n        sha = out.strip().decode('ascii')\n    except OSError:\n        sha = 'unknown'\n\n    return sha",
          "hash_value": "5c5f9a0ff3d27d1291d145856fd9122e",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport subprocess\n\ndef get_git_hash():\n\n    def _minimal_ext_cmd(cmd):\n        # construct minimal environment\n        env = {}\n        for k in ['SYSTEMROOT', 'PATH', 'HOME']:\n            v = os.environ.get(k)\n            if v is not None:\n                env[k] = v\n        # LANGUAGE is used on win32\n        env['LANGUAGE'] = 'C'\n        env['LANG'] = 'C'\n        env['LC_ALL'] = 'C'\n        out = subprocess.Popen(cmd, stdout=subprocess.PIPE, env=env).communicate()[0]\n        return out\n\n    try:\n        out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])\n        sha = out.strip().decode('ascii')\n    except OSError:\n        sha = 'unknown'\n\n    return sha",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "k",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "['git', 'rev-parse', 'HEAD']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "subprocess.Popen().communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "bytes.strip()",
                  "action_description": "Decodes bytes using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "bytes.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "ascii",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "intake-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/intake-2.0.8.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "user_parameters.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/intake-2.0.8/intake-2.0.8/intake/readers/user_parameters.py",
          "line_number": "89",
          "type_description": "obfuscation",
          "context_snippet": "class SimpleUserParameter(BaseUserParameter):\n    \"\"\"This class is enough for simple type coercion.\"\"\"\n\n    def __init__(self, dtype: type = object, **kw):\n        self.dtype = dtype.__name__\n        if self.dtype not in dir(builtins) or not isinstance(dtype, type):\n            raise ValueError(\"Only supports classes from the builtins module\")\n        super().__init__(**kw)\n\n    @property\n    def _dtype(self):\n        return getattr(builtins, self.dtype)\n\n    def coerce(self, value):\n        if not isinstance(value, self._dtype):\n            return self._dtype(value)  # works for dtype like str, int, list\n        return value\n\n    def _validate(self, value):\n        return isinstance(value, self._dtype)",
          "hash_value": "95f1ebe0cbec2ca5f42d3f352b8d1ce1",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class SimpleUserParameter(BaseUserParameter):\n    \"\"\"This class is enough for simple type coercion.\"\"\"\n\n    def __init__(self, dtype: type = object, **kw):\n        self.dtype = dtype.__name__\n        if self.dtype not in dir(builtins) or not isinstance(dtype, type):\n            raise ValueError(\"Only supports classes from the builtins module\")\n        super().__init__(**kw)\n\n    @property\n    def _dtype(self):\n        return getattr(builtins, self.dtype)\n\n    def coerce(self, value):\n        if not isinstance(value, self._dtype):\n            return self._dtype(value)  # works for dtype like str, int, list\n        return value\n\n    def _validate(self, value):\n        return isinstance(value, self._dtype)",
              "triple_sequences": [
                {
                  "action_api": "dir()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Determine required module presence",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "dtype, type",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Determine required module presence",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, self.dtype",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "value, self._dtype",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine required module presence",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "self._dtype(value)",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "value",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Prepare character processing",
                  "intention_id": "prepare_character_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "cronex-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/cronex-0.1.3.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cronex-0.1.3.1/cronex-0.1.3.1/setup.py",
          "line_number": "10",
          "type_description": "code-execution",
          "context_snippet": "import subprocess\n\n# If pandoc is available, convert the markdown README to REstructured Text.\ntry:\n    pandoc = subprocess.Popen([\"pandoc\", \"-t\", \"rst\", \"README.md\"],\n                              stdout=subprocess.PIPE,\n                              stderr=subprocess.PIPE)\n    long_description, _ = pandoc.communicate()\n    long_description = long_description.decode(\"utf-8\")\nexcept OSError:\n    long_description = None",
          "hash_value": "ea6784334bf9a460f56528d2fc347443",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import subprocess\n\n# If pandoc is available, convert the markdown README to REstructured Text.\ntry:\n    pandoc = subprocess.Popen([\"pandoc\", \"-t\", \"rst\", \"README.md\"],\n                              stdout=subprocess.PIPE,\n                              stderr=subprocess.PIPE)\n    long_description, _ = pandoc.communicate()\n    long_description = long_description.decode(\"utf-8\")\nexcept OSError:\n    long_description = None",
              "triple_sequences": [
                {
                  "action_api": "subprocess.Popen()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "[\"pandoc\", \"-t\", \"rst\", \"README.md\"]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.Popen.communicate()",
                  "action_description": "Reads all bytes from process standard output",
                  "action_id": "read_process_stdout",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                },
                {
                  "action_api": "bytes.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "\"utf-8\"",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Decode command output",
                  "intention_id": "decode_command_output"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pygame-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pygame-2.6.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pygame-2.6.1/pygame-2.6.1/setup.py",
          "line_number": "126",
          "type_description": "code-execution",
          "context_snippet": "if os.environ.get('PYGAME_DETECT_AVX2', '') != '':\n    import distutils.ccompiler\n\n    avx2_filenames = ['simd_blitters_avx2']\n\n    compiler_options = {\n        'unix': ('-mavx2',),\n        'msvc': ('/arch:AVX2',)\n    }\n\n    def spawn(self, cmd, **kwargs):\n        should_use_avx2 = False\n        # try to be thorough in detecting that we are on a platform that potentially supports AVX2\n        machine_name = platform.machine()\n        if ((machine_name.startswith((\"x86\", \"i686\")) or\n            machine_name.lower() == \"amd64\") and\n                os.environ.get(\"MAC_ARCH\") != \"arm64\"):\n            should_use_avx2 = True\n\n        if should_use_avx2:\n            extra_options = compiler_options.get(self.compiler_type)\n            if extra_options is not None:\n                # filenames are closer to the end of command line\n                for argument in reversed(cmd):\n                    # Check if argument contains a filename. We must check for all\n                    # possible extensions; checking for target extension is faster.\n                    if not argument.endswith(self.obj_extension):\n                        continue\n\n                    # check for a filename only to avoid building a new string\n                    # with variable extension\n                    for filename in avx2_filenames:\n                        off_end = -len(self.obj_extension)\n                        off_start = -len(filename) + off_end\n                        if argument.endswith(filename, off_start, off_end):\n                            if self.compiler_type == 'bcpp':\n                                # Borland accepts a source file name at the end,\n                                # insert the options before it\n                                cmd[-1:-1] = extra_options\n                            else:\n                                cmd += extra_options\n\n                    # filename is found, no need to search any further\n                    break\n\n        distutils.ccompiler.spawn(cmd, dry_run=self.dry_run, **kwargs)\n\n    distutils.ccompiler.CCompiler.__spawn = distutils.ccompiler.CCompiler.spawn\n    distutils.ccompiler.CCompiler.spawn = spawn",
          "hash_value": "d7bdf7c3d4f16b4137ed03bc0447ef40",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "if os.environ.get('PYGAME_DETECT_AVX2', '') != '':\n    import distutils.ccompiler\n\n    avx2_filenames = ['simd_blitters_avx2']\n\n    compiler_options = {\n        'unix': ('-mavx2',),\n        'msvc': ('/arch:AVX2',)\n    }\n\n    def spawn(self, cmd, **kwargs):\n        should_use_avx2 = False\n        # try to be thorough in detecting that we are on a platform that potentially supports AVX2\n        machine_name = platform.machine()\n        if ((machine_name.startswith((\"x86\", \"i686\")) or\n            machine_name.lower() == \"amd64\") and\n                os.environ.get(\"MAC_ARCH\") != \"arm64\"):\n            should_use_avx2 = True\n\n        if should_use_avx2:\n            extra_options = compiler_options.get(self.compiler_type)\n            if extra_options is not None:\n                # filenames are closer to the end of command line\n                for argument in reversed(cmd):\n                    # Check if argument contains a filename. We must check for all\n                    # possible extensions; checking for target extension is faster.\n                    if not argument.endswith(self.obj_extension):\n                        continue\n\n                    # check for a filename only to avoid building a new string\n                    # with variable extension\n                    for filename in avx2_filenames:\n                        off_end = -len(self.obj_extension)\n                        off_start = -len(filename) + off_end\n                        if argument.endswith(filename, off_start, off_end):\n                            if self.compiler_type == 'bcpp':\n                                # Borland accepts a source file name at the end,\n                                # insert the options before it\n                                cmd[-1:-1] = extra_options\n                            else:\n                                cmd += extra_options\n\n                    # filename is found, no need to search any further\n                    break\n\n        distutils.ccompiler.spawn(cmd, dry_run=self.dry_run, **kwargs)\n\n    distutils.ccompiler.CCompiler.__spawn = distutils.ccompiler.CCompiler.spawn\n    distutils.ccompiler.CCompiler.spawn = spawn",
              "triple_sequences": [
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'PYGAME_DETECT_AVX2'",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "import distutils.ccompiler",
                  "action_description": "Dynamically imports specified module",
                  "action_id": "import_dynamic",
                  "object": "distutils.ccompiler",
                  "object_description": "Module name string",
                  "object_id": "module_name_string",
                  "intention_description": "Import module dynamically",
                  "intention_id": "import_module_dynamically"
                },
                {
                  "action_api": "platform.machine()",
                  "action_description": "Retrieves machine type",
                  "action_id": "get_machine_type",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get hardware UUID",
                  "intention_id": "get_hardware_uuid"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'MAC_ARCH'",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "distutils.ccompiler.spawn()",
                  "action_description": "Spawns new process to execute command without shell access",
                  "action_id": "spawn_process_no_shell",
                  "object": "cmd",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "distutils.ccompiler.CCompiler.__spawn = distutils.ccompiler.CCompiler.spawn",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "distutils.ccompiler.CCompiler.__spawn",
                  "object_description": "Attribute value",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "distutils.ccompiler.CCompiler.spawn = spawn",
                  "action_description": "Sets attribute on builtins object",
                  "action_id": "set_builtin_attr",
                  "object": "distutils.ccompiler.CCompiler.spawn",
                  "object_description": "Attribute value",
                  "object_id": "",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pyvex-9",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyvex-9.2.149.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyvex-9.2.149/pyvex-9.2.149/setup.py",
          "line_number": "55",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport shutil\nimport subprocess\nimport sys\nimport multiprocessing\nfrom setuptools.errors import LibError\n\nVEX_PATH = os.path.abspath(os.path.join(PROJECT_DIR, \"vex\"))\n\ndef _build_vex():\n    if len(os.listdir(VEX_PATH)) == 0:\n        raise LibError(\n            \"vex submodule not cloned correctly, aborting.\\nThis may be fixed with `git submodule update --init`\"\n        )\n\n    e = os.environ.copy()\n    e[\"MULTIARCH\"] = \"1\"\n    e[\"DEBUG\"] = \"1\"\n\n    if sys.platform == \"win32\":\n        cmd = [\"nmake\", \"/f\", \"Makefile-msvc\", \"all\"]\n    elif shutil.which(\"gmake\") is not None:\n        cmd = [\"gmake\", \"-f\", \"Makefile-gcc\", \"-j\", str(multiprocessing.cpu_count()), \"all\"]\n    else:\n        cmd = [\"make\", \"-f\", \"Makefile-gcc\", \"-j\", str(multiprocessing.cpu_count()), \"all\"]\n\n    try:\n        subprocess.run(cmd, cwd=VEX_PATH, env=e, check=True)\n    except FileNotFoundError as err:\n        raise LibError(\"Couldn't find \" + cmd[0] + \" in PATH\") from err\n    except subprocess.CalledProcessError as err:\n        raise LibError(\"Error while building libvex: \" + str(err)) from err",
          "hash_value": "3726fde2b7f0096d6929a4d0aa71bbae",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport shutil\nimport subprocess\nimport sys\nimport multiprocessing\nfrom setuptools.errors import LibError\n\nVEX_PATH = os.path.abspath(os.path.join(PROJECT_DIR, \"vex\"))\n\ndef _build_vex():\n    if len(os.listdir(VEX_PATH)) == 0:\n        raise LibError(\n            \"vex submodule not cloned correctly, aborting.\\nThis may be fixed with `git submodule update --init`\"\n        )\n\n    e = os.environ.copy()\n    e[\"MULTIARCH\"] = \"1\"\n    e[\"DEBUG\"] = \"1\"\n\n    if sys.platform == \"win32\":\n        cmd = [\"nmake\", \"/f\", \"Makefile-msvc\", \"all\"]\n    elif shutil.which(\"gmake\") is not None:\n        cmd = [\"gmake\", \"-f\", \"Makefile-gcc\", \"-j\", str(multiprocessing.cpu_count()), \"all\"]\n    else:\n        cmd = [\"make\", \"-f\", \"Makefile-gcc\", \"-j\", str(multiprocessing.cpu_count()), \"all\"]\n\n    try:\n        subprocess.run(cmd, cwd=VEX_PATH, env=e, check=True)\n    except FileNotFoundError as err:\n        raise LibError(\"Couldn't find \" + cmd[0] + \" in PATH\") from err\n    except subprocess.CalledProcessError as err:\n        raise LibError(\"Error while building libvex: \" + str(err)) from err",
              "triple_sequences": [
                {
                  "action_api": "os.path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.path.join(PROJECT_DIR, \"vex\")",
                  "object_description": "Path segment",
                  "object_id": "path_segment",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "os.listdir()",
                  "action_description": "List directory contents",
                  "action_id": "list_directory_contents",
                  "object": "VEX_PATH",
                  "object_description": "Directory path",
                  "object_id": "directory_path",
                  "intention_description": "List files in directory",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "os.environ.copy()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "shutil.which()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "\"gmake\"",
                  "object_description": "Local file or directory name",
                  "object_id": "local_file_or_directory_name",
                  "intention_description": "Determine presence of required module",
                  "intention_id": "determine_required_module_presence"
                },
                {
                  "action_api": "multiprocessing.cpu_count()",
                  "action_description": "Retrieves operating system information",
                  "action_id": "get_os_info",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get system info",
                  "intention_id": "get_system_info"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "cmd",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "unav-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/unav-0.1.40.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "d2net.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/unav-0.1.40/unav-0.1.40/unav/third_party/local_feature/SuperPoint_SuperGlue/extractors/d2net.py",
          "line_number": "27",
          "type_description": "shady-links",
          "context_snippet": "import sys\nfrom pathlib import Path\nimport subprocess\nimport logging\nimport torch\n\nfrom unav.third_party.local_feature.SuperPoint_SuperGlue.utils.base_model import BaseModel\n\nd2net_path = Path(__file__).parent / '../../third_party/d2net'\nsys.path.append(str(d2net_path))\nfrom lib.model_test import D2Net as _D2Net\nfrom lib.pyramid import process_multiscale\n\n\nclass D2Net(BaseModel):\n    default_conf = {\n        'model_name': 'd2_tf.pth',\n        'use_relu': True,\n        'multiscale': False,\n    }\n    required_inputs = ['image']\n\n    def _init(self, conf):\n        model_file = d2net_path / 'models' / conf['model_name']\n        if not model_file.exists():\n            model_file.parent.mkdir(exist_ok=True)\n            cmd = ['wget', 'https://dsmn.ml/files/d2-net/'+conf['model_name'],\n                   '-O', str(model_file)]\n            ret = subprocess.call(cmd)\n            if ret != 0:\n                logging.warning(\n                    f'Cannot download the D2-Net model with `{cmd}`.')\n                exit(ret)\n\n        self.net = _D2Net(\n            model_file=model_file,\n            use_relu=conf['use_relu'],\n            use_cuda=False)",
          "hash_value": "5015d2745bbc2f6d3e93196fd5e96c16",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import sys\nfrom pathlib import Path\nimport subprocess\nimport logging\nimport torch\n\nfrom unav.third_party.local_feature.SuperPoint_SuperGlue.utils.base_model import BaseModel\n\nd2net_path = Path(__file__).parent / '../../third_party/d2net'\nsys.path.append(str(d2net_path))\nfrom lib.model_test import D2Net as _D2Net\nfrom lib.pyramid import process_multiscale\n\n\nclass D2Net(BaseModel):\n    default_conf = {\n        'model_name': 'd2_tf.pth',\n        'use_relu': True,\n        'multiscale': False,\n    }\n    required_inputs = ['image']\n\n    def _init(self, conf):\n        model_file = d2net_path / 'models' / conf['model_name']\n        if not model_file.exists():\n            model_file.parent.mkdir(exist_ok=True)\n            cmd = ['wget', 'https://dsmn.ml/files/d2-net/'+conf['model_name'],\n                   '-O', str(model_file)]\n            ret = subprocess.call(cmd)\n            if ret != 0:\n                logging.warning(\n                    f'Cannot download the D2-Net model with `{cmd}`.')\n                exit(ret)\n\n        self.net = _D2Net(\n            model_file=model_file,\n            use_relu=conf['use_relu'],\n            use_cuda=False)",
              "triple_sequences": [
                {
                  "action_api": "Path.exists()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "model_file",
                  "object_description": "Local file",
                  "object_id": "local_file",
                  "intention_description": "Determine_file_presence",
                  "intention_id": "determine_file_presence"
                },
                {
                  "action_api": "Path.mkdir()",
                  "action_description": "Creates directory, ignoring if it already exists",
                  "action_id": "create_directory",
                  "object": "model_file.parent",
                  "object_description": "Custom directory",
                  "object_id": "custom_directory",
                  "intention_description": "Ensure directory exists",
                  "intention_id": "ensure_directory_exists"
                },
                {
                  "action_api": "subprocess.call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "['wget', 'https://dsmn.ml/files/d2-net/'+conf['model_name'], '-O', str(model_file)]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "logging.warning()",
                  "action_description": "Writes log message to file or console",
                  "action_id": "write_file_content",
                  "object": "f'Cannot download the D2-Net model with `{cmd}`.'",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Access command error output",
                  "intention_id": "access_command_error_output"
                },
                {
                  "action_api": "exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "ret",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                },
                {
                  "action_api": "_D2Net()",
                  "action_description": "Instantiates D2Net class",
                  "action_id": "init_grabber_class",
                  "object": "model_file=model_file, use_relu=conf['use_relu'], use_cuda=False",
                  "object_description": "Function and arguments",
                  "object_id": "function_with_arguments",
                  "intention_description": "Initialize shell object",
                  "intention_id": "initialize_shell_object"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pyddq-5",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyddq-5.0.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyddq-5.0.0/pyddq-5.0.0/setup.py",
          "line_number": "37",
          "type_description": "code-execution",
          "context_snippet": "import sys\nimport os\nimport glob\nimport subprocess\nfrom setuptools import setup, Command\n\nclass IntegrationTestCommand(Command):\n    description = \"A command to run integration tests\"\n    user_options = [(\"jar=\", None, \"Path to Drunken Data Quality jar\")]\n    jar = None\n    addopts = None\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        if self.addopts is None:\n            exit(\"error: option addopts should be specified in setup.cfg\")\n        elif self.jar is None:\n            exit(\"error: path to Drunken Data Quality jar should be specified\")\n\n    def run(self):\n        log4j_path = os.path.abspath(\"../src/test/resources/log4j.properties\")\n        result = 0\n        try:\n            for filename in glob.glob(os.path.join(self.addopts, \"test_*.py\")):\n                result = result or subprocess.call([\n                    \"spark-submit\",\n                    \"--driver-java-options\",\n                    '\"-Dlog4j.configuration=file://{path}\"'.format(path=log4j_path),\n                    \"--driver-class-path\",\n                    self.jar,\n                    filename\n                ])\n        except OSError as e:\n            if e.errno == os.errno.ENOENT:\n                exit(\"spark-submit is not found!\")\n            else:\n                exit(str(e))\n        exit(result)",
          "hash_value": "f1c489293b8feb77a9eb2a03f85053b7",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import sys\nimport os\nimport glob\nimport subprocess\nfrom setuptools import setup, Command\n\nclass IntegrationTestCommand(Command):\n    description = \"A command to run integration tests\"\n    user_options = [(\"jar=\", None, \"Path to Drunken Data Quality jar\")]\n    jar = None\n    addopts = None\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        if self.addopts is None:\n            exit(\"error: option addopts should be specified in setup.cfg\")\n        elif self.jar is None:\n            exit(\"error: path to Drunken Data Quality jar should be specified\")\n\n    def run(self):\n        log4j_path = os.path.abspath(\"../src/test/resources/log4j.properties\")\n        result = 0\n        try:\n            for filename in glob.glob(os.path.join(self.addopts, \"test_*.py\")):\n                result = result or subprocess.call([\n                    \"spark-submit\",\n                    \"--driver-java-options\",\n                    '\"-Dlog4j.configuration=file://{path}\"'.format(path=log4j_path),\n                    \"--driver-class-path\",\n                    self.jar,\n                    filename\n                ])\n        except OSError as e:\n            if e.errno == os.errno.ENOENT:\n                exit(\"spark-submit is not found!\")\n            else:\n                exit(str(e))\n        exit(result)",
              "triple_sequences": [
                {
                  "action_api": "os.path.abspath()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "../src/test/resources/log4j.properties",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "glob.glob()",
                  "action_description": "List directory contents",
                  "action_id": "list_directory_contents",
                  "object": "os.path.join(self.addopts, \"test_*.py\")",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "List files in directory",
                  "intention_id": "list_directory_files"
                },
                {
                  "action_api": "os.path.join()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "self.addopts, \"test_*.py\"",
                  "object_description": "Directory path and file name",
                  "object_id": "directory_path_with_file",
                  "intention_description": "Construct file or directory path",
                  "intention_id": "construct_file_path"
                },
                {
                  "action_api": "subprocess.call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"spark-submit\", \"--driver-java-options\", '\"-Dlog4j.configuration=file://{path}\"'.format(path=log4j_path), \"--driver-class-path\", self.jar, filename]",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "error: option addopts should be specified in setup.cfg",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                },
                {
                  "action_api": "exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "error: path to Drunken Data Quality jar should be specified",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                },
                {
                  "action_api": "exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "spark-submit is not found!",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                },
                {
                  "action_api": "exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "str(e)",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                },
                {
                  "action_api": "exit()",
                  "action_description": "Exits program",
                  "action_id": "exit_program",
                  "object": "result",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Terminate program execution",
                  "intention_id": "terminate_program_execution"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "reportlab-4",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/reportlab-4.3.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/reportlab-4.3.1/reportlab-4.3.1/setup.py",
          "line_number": "37",
          "type_description": "code-execution",
          "context_snippet": "import os, sys, glob, shutil, re, sysconfig, traceback, io, subprocess\n\ndef spCall(cmd,*args,**kwds):\n    r = subprocess.call(\n            cmd,\n            stderr = subprocess.STDOUT,\n            stdout = subprocess.DEVNULL if kwds.pop('dropOutput',False) else None,\n            timeout = kwds.pop('timeout',3600),\n            )\n    if verbose>=3:\n        infoline('%r --> %s' % (' '.join(cmd),r), pfx='!!!!!' if r else '#####', add=False)\n    return r\n\n# Data dependencies:\n# - subprocess: imported at top\n# - cmd: argument to spCall\n# - kwds: argument to spCall\n# - subprocess.STDOUT, subprocess.DEVNULL: from subprocess\n# - verbose: set by 'verbose = specialOption('--verbose',ceq=True)' (global)\n# - infoline: defined above\n",
          "hash_value": "0f5c93f1645b2d80e0b4bec884f195eb",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os, sys, glob, shutil, re, sysconfig, traceback, io, subprocess\n\ndef spCall(cmd,*args,**kwds):\n    r = subprocess.call(\n            cmd,\n            stderr = subprocess.STDOUT,\n            stdout = subprocess.DEVNULL if kwds.pop('dropOutput',False) else None,\n            timeout = kwds.pop('timeout',3600),\n            )\n    if verbose>=3:\n        infoline('%r --> %s' % (' '.join(cmd),r), pfx='!!!!!' if r else '#####', add=False)\n    return r\n\n# Data dependencies:\n# - subprocess: imported at top\n# - cmd: argument to spCall\n# - kwds: argument to spCall\n# - subprocess.STDOUT, subprocess.DEVNULL: from subprocess\n# - verbose: set by 'verbose = specialOption('--verbose',ceq=True)' (global)\n# - infoline: defined above\n",
              "triple_sequences": [
                {
                  "action_api": "subprocess.call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "cmd",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "notifiers-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/notifiers-1.3.5.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "telegram.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/notifiers-1.3.5/notifiers-1.3.5/notifiers/providers/telegram.py",
          "line_number": "9",
          "type_description": "shady-links",
          "context_snippet": "class TelegramMixin:\n    \"\"\"Shared resources between :class:`TelegramUpdates` and :class:`Telegram`\"\"\"\n\n    base_url = \"https://api.telegram.org/bot{token}\"\n    name = \"telegram\"\n    path_to_errors = (\"description\",)",
          "hash_value": "085ecb96a6f09bdb1a6c8859b0f0fc45",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "class TelegramMixin:\n    \"\"\"Shared resources between :class:`TelegramUpdates` and :class:`Telegram`\"\"\"\n\n    base_url = \"https://api.telegram.org/bot{token}\"\n    name = \"telegram\"\n    path_to_errors = (\"description\",)",
              "triple_sequences": [
                {
                  "action_api": "",
                  "action_description": "Instantiates Telegram class",
                  "action_id": "init_telegram_class",
                  "object": "https://api.telegram.org/bot{token}",
                  "object_description": "Telegram API endpoint",
                  "object_id": "telegram_api_endpoint",
                  "intention_description": "Connect to remote server",
                  "intention_id": "connect_remote_server"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "mycli-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/mycli-1.29.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "iocommands.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/mycli-1.29.2/mycli-1.29.2/mycli/packages/special/iocommands.py",
          "line_number": "207",
          "type_description": "clipboard-access",
          "context_snippet": "import pyperclip\n\n@export\ndef copy_query_to_clipboard(sql=None):\n    \"\"\"Send query to the clipboard.\"\"\"\n\n    sql = sql or \"\"\n    message = None\n\n    try:\n        pyperclip.copy(\"{sql}\".format(sql=sql))\n    except RuntimeError as e:\n        message = \"Error clipping query: %s.\" % e.strerror\n\n    return message",
          "hash_value": "5d8aecd8a0a3610850bfdbcdd386f13d",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import pyperclip\n\n@export\ndef copy_query_to_clipboard(sql=None):\n    \"\"\"Send query to the clipboard.\"\"\"\n\n    sql = sql or \"\"\n    message = None\n\n    try:\n        pyperclip.copy(\"{sql}\".format(sql=sql))\n    except RuntimeError as e:\n        message = \"Error clipping query: %s.\" % e.strerror\n\n    return message",
              "triple_sequences": [
                {
                  "action_api": "pyperclip.copy()",
                  "action_description": "Copies specified text to system clipboard",
                  "action_id": "copy_to_clipboard",
                  "object": "\"{sql}\".format(sql=sql)",
                  "object_description": "Clipboard content data",
                  "object_id": "clipboard_data",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "pyautogen-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/pyautogen-0.8.6.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "get_youtube_caption.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyautogen-0.8.6/pyautogen-0.8.6/autogen/agentchat/contrib/captainagent/tools/information_retrieval/get_youtube_caption.py",
          "line_number": "31",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "def get_youtube_caption(video_id: str) -> str:\n    \"\"\"Retrieves the captions for a YouTube video.\n\n    Args:\n        video_id (str): The ID of the YouTube video.\n\n    Returns:\n        str: The captions of the YouTube video in text format.\n\n    Raises:\n        KeyError: If the RAPID_API_KEY environment variable is not set.\n    \"\"\"\n    import os\n\n    import requests\n\n    rapid_api_key = os.environ[\"RAPID_API_KEY\"]\n    video_url = f\"https://www.youtube.com/watch?v={video_id}\"\n    url = \"https://youtube-transcript3.p.rapidapi.com/api/transcript-with-url\"\n\n    querystring = {\"url\": video_url, \"lang\": \"en\", \"flat_text\": \"true\"}\n\n    headers = {\"X-RapidAPI-Key\": rapid_api_key, \"X-RapidAPI-Host\": \"youtube-transcript3.p.rapidapi.com\"}\n\n    response = requests.get(url, headers=headers, params=querystring)\n    response = response.json()\n    print(response)\n    return response[\"transcript\"]",
          "hash_value": "7e52d04e3c36e3bada7aeced8a32e571",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def get_youtube_caption(video_id: str) -> str:\n    \"\"\"Retrieves the captions for a YouTube video.\n\n    Args:\n        video_id (str): The ID of the YouTube video.\n\n    Returns:\n        str: The captions of the YouTube video in text format.\n\n    Raises:\n        KeyError: If the RAPID_API_KEY environment variable is not set.\n    \"\"\"\n    import os\n\n    import requests\n\n    rapid_api_key = os.environ[\"RAPID_API_KEY\"]\n    video_url = f\"https://www.youtube.com/watch?v={video_id}\"\n    url = \"https://youtube-transcript3.p.rapidapi.com/api/transcript-with-url\"\n\n    querystring = {\"url\": video_url, \"lang\": \"en\", \"flat_text\": \"true\"}\n\n    headers = {\"X-RapidAPI-Key\": rapid_api_key, \"X-RapidAPI-Host\": \"youtube-transcript3.p.rapidapi.com\"}\n\n    response = requests.get(url, headers=headers, params=querystring)\n    response = response.json()\n    print(response)\n    return response[\"transcript\"]",
              "triple_sequences": [
                {
                  "action_api": "os.environ.__getitem__()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"RAPID_API_KEY\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "\"https://youtube-transcript3.p.rapidapi.com/api/transcript-with-url\", headers=headers, params=querystring",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "response.json()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "print()",
                  "action_description": "Retrieves standard output stream object",
                  "action_id": "get_stdout_stream",
                  "object": "response",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Collect command output",
                  "intention_id": "collect_command_output"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "opencc-1",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/opencc-1.1.9.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/opencc-1.1.9/opencc-1.1.9/deps/pybind11-2.13.1/setup.py",
          "line_number": "138",
          "type_description": "code-execution",
          "context_snippet": "with remove_output(\"pybind11/include\", \"pybind11/share\"):\n    # Generate the files if they are not present.\n    with TemporaryDirectory() as tmpdir:\n        cmd = [\"cmake\", \"-S\", \".\", \"-B\", tmpdir] + [\n            \"-DCMAKE_INSTALL_PREFIX=pybind11\",\n            \"-DBUILD_TESTING=OFF\",\n            \"-DPYBIND11_NOPYTHON=ON\",\n            \"-Dprefix_for_pc_file=${pcfiledir}/../../\",\n        ]\n        if \"CMAKE_ARGS\" in os.environ:\n            fcommand = [\n                c\n                for c in os.environ[\"CMAKE_ARGS\"].split()\n                if \"DCMAKE_INSTALL_PREFIX\" not in c\n            ]\n            cmd += fcommand\n        subprocess.run(cmd, check=True, cwd=DIR, stdout=sys.stdout, stderr=sys.stderr)\n        subprocess.run(\n            [\"cmake\", \"--install\", tmpdir],\n            check=True,\n            cwd=DIR,\n            stdout=sys.stdout,\n            stderr=sys.stderr,\n        )",
          "hash_value": "b70511a5aec8110591ad3e376676d74e",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "with remove_output(\"pybind11/include\", \"pybind11/share\"):\n    # Generate the files if they are not present.\n    with TemporaryDirectory() as tmpdir:\n        cmd = [\"cmake\", \"-S\", \".\", \"-B\", tmpdir] + [\n            \"-DCMAKE_INSTALL_PREFIX=pybind11\",\n            \"-DBUILD_TESTING=OFF\",\n            \"-DPYBIND11_NOPYTHON=ON\",\n            \"-Dprefix_for_pc_file=${pcfiledir}/../../\",\n        ]\n        if \"CMAKE_ARGS\" in os.environ:\n            fcommand = [\n                c\n                for c in os.environ[\"CMAKE_ARGS\"].split()\n                if \"DCMAKE_INSTALL_PREFIX\" not in c\n            ]\n            cmd += fcommand\n        subprocess.run(cmd, check=True, cwd=DIR, stdout=sys.stdout, stderr=sys.stderr)\n        subprocess.run(\n            [\"cmake\", \"--install\", tmpdir],\n            check=True,\n            cwd=DIR,\n            stdout=sys.stdout,\n            stderr=sys.stderr,\n        )",
              "triple_sequences": [
                {
                  "action_api": "os.environ.__contains__()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "\"CMAKE_ARGS\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "os.environ.__getitem__()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "\"CMAKE_ARGS\"",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "str.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "os.environ[\"CMAKE_ARGS\"]",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "cmd, check=True, cwd=DIR, stdout=sys.stdout, stderr=sys.stderr",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                },
                {
                  "action_api": "subprocess.run()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "[\"cmake\", \"--install\", tmpdir], check=True, cwd=DIR, stdout=sys.stdout, stderr=sys.stderr",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "hypothesis-6",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/hypothesis-6.131.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "ghostwriter.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/hypothesis-6.131.0/hypothesis-6.131.0/src/hypothesis/extra/ghostwriter.py",
          "line_number": "224",
          "type_description": "obfuscation",
          "context_snippet": "def _exceptions_from_docstring(doc: str) -> tuple[type[Exception], ...]:\n    \"\"\"Return a tuple of exceptions that the docstring says may be raised.\n\n    Note that we ignore non-builtin exception types for simplicity, as this is\n    used directly in _write_call() and passing import sets around would be really\n    really annoying.\n    \"\"\"\n    # TODO: it would be great to handle Google- and Numpy-style docstrings\n    #       (e.g. by using the Napoleon Sphinx extension)\n    assert isinstance(doc, str), doc\n    raises = []\n    for excname in re.compile(r\"\\:raises\\s+(\\w+)\\:\", re.MULTILINE).findall(doc):\n        exc_type = getattr(builtins, excname, None)\n        if isinstance(exc_type, type) and issubclass(exc_type, Exception):\n            raises.append(exc_type)\n    return tuple(_dedupe_exceptions(tuple(raises)))",
          "hash_value": "6d6bc3ad98eff25ff287187a852fc2a9",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "def _exceptions_from_docstring(doc: str) -> tuple[type[Exception], ...]:\n    \"\"\"Return a tuple of exceptions that the docstring says may be raised.\n\n    Note that we ignore non-builtin exception types for simplicity, as this is\n    used directly in _write_call() and passing import sets around would be really\n    really annoying.\n    \"\"\"\n    # TODO: it would be great to handle Google- and Numpy-style docstrings\n    #       (e.g. by using the Napoleon Sphinx extension)\n    assert isinstance(doc, str), doc\n    raises = []\n    for excname in re.compile(r\"\\:raises\\s+(\\w+)\\:\", re.MULTILINE).findall(doc):\n        exc_type = getattr(builtins, excname, None)\n        if isinstance(exc_type, type) and issubclass(exc_type, Exception):\n            raises.append(exc_type)\n    return tuple(_dedupe_exceptions(tuple(raises)))",
              "triple_sequences": [
                {
                  "action_api": "isinstance()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "doc, str",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                },
                {
                  "action_api": "re.compile()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "r\"\\:raises\\s+(\\w+)\\:\", re.MULTILINE",
                  "object_description": "Regular expression pattern",
                  "object_id": "regex_pattern",
                  "intention_description": "Browser profile detection preparation",
                  "intention_id": "browser_profile_detection_preparation"
                },
                {
                  "action_api": "re.Pattern.findall()",
                  "action_description": "Compiles regular expression pattern",
                  "action_id": "compile_regex",
                  "object": "doc",
                  "object_description": "Regular expression and file content",
                  "object_id": "regex_file_content",
                  "intention_description": "Extract structured file data",
                  "intention_id": "extract_structured_file_data"
                },
                {
                  "action_api": "getattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "builtins, excname, None",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Access attribute value",
                  "intention_id": "access_attribute_value"
                },
                {
                  "action_api": "issubclass()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "exc_type, Exception",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                },
                {
                  "action_api": "_dedupe_exceptions()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "tuple(raises)",
                  "object_description": "Exception type name",
                  "object_id": "exception_type",
                  "intention_description": "Extract structured file data",
                  "intention_id": "extract_structured_file_data"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "dycw_utilities-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/dycw_utilities-0.105.0.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "http.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/dycw_utilities-0.105.0/dycw_utilities-0.105.0/src/utilities/http.py",
          "line_number": "14",
          "type_description": "shady-links",
          "context_snippet": "from __future__ import annotations\n\nfrom contextlib import contextmanager\nfrom http.client import HTTPSConnection\nfrom ipaddress import IPv4Address\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from collections.abc import Iterator\n\n\ndef get_public_ip(*, timeout: float | None = None) -> IPv4Address:\n    \"\"\"Get your public IP address.\"\"\"\n    with yield_connection(\"api.ipify.org\", timeout=timeout) as conn:  # pragma: no cover\n        conn.request(\"GET\", \"/?format=text\")\n        response = conn.getresponse()\n        address = response.read().decode(\"utf8\")\n    return IPv4Address(address)  # pragma: no cover\n\n\n@contextmanager\ndef yield_connection(\n    host: str, /, *, timeout: float | None = None\n) -> Iterator[HTTPSConnection]:\n    \"\"\"Yield an HTTP connection.\"\"\"\n    conn = HTTPSConnection(host, timeout=timeout)\n    try:\n        yield conn\n    finally:\n        conn.close()",
          "hash_value": "d6de9150db253c3d737c6a9142ea3cd7",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "from __future__ import annotations\n\nfrom contextlib import contextmanager\nfrom http.client import HTTPSConnection\nfrom ipaddress import IPv4Address\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from collections.abc import Iterator\n\n\ndef get_public_ip(*, timeout: float | None = None) -> IPv4Address:\n    \"\"\"Get your public IP address.\"\"\"\n    with yield_connection(\"api.ipify.org\", timeout=timeout) as conn:  # pragma: no cover\n        conn.request(\"GET\", \"/?format=text\")\n        response = conn.getresponse()\n        address = response.read().decode(\"utf8\")\n    return IPv4Address(address)  # pragma: no cover\n\n\n@contextmanager\ndef yield_connection(\n    host: str, /, *, timeout: float | None = None\n) -> Iterator[HTTPSConnection]:\n    \"\"\"Yield an HTTP connection.\"\"\"\n    conn = HTTPSConnection(host, timeout=timeout)\n    try:\n        yield conn\n    finally:\n        conn.close()",
              "triple_sequences": [
                {
                  "action_api": "HTTPSConnection()",
                  "action_description": "Creates HTTP connection to specified host",
                  "action_id": "create_http_connection",
                  "object": "api.ipify.org",
                  "object_description": "External domain",
                  "object_id": "external_domain",
                  "intention_description": "Connect to remote server",
                  "intention_id": "connect_remote_server"
                },
                {
                  "action_api": "HTTPSConnection.request()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "\"GET\", \"/?format=text\"",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "HTTPSConnection.getresponse()",
                  "action_description": "Process HTTP response content",
                  "action_id": "process_http_response",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Decode downloaded content",
                  "intention_id": "decode_downloaded_content"
                },
                {
                  "action_api": "HTTPResponse.read()",
                  "action_description": "Receives data from socket connection",
                  "action_id": "receive_socket_data",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "str.decode()",
                  "action_description": "Decodes bytes using specified codec",
                  "action_id": "decode_bytes_codec",
                  "object": "\"utf8\"",
                  "object_description": "Character encoding type",
                  "object_id": "character_encoding_type",
                  "intention_description": "Decode downloaded content",
                  "intention_id": "decode_downloaded_content"
                },
                {
                  "action_api": "IPv4Address()",
                  "action_description": "Converts 32-bit packed IPv4 address to string",
                  "action_id": "convert_ipv4_addr",
                  "object": "address",
                  "object_description": "Public IP address",
                  "object_id": "public_ip_address",
                  "intention_description": "Extract public IP address",
                  "intention_id": "extract_public_ip_address"
                },
                {
                  "action_api": "HTTPSConnection.close()",
                  "action_description": "Closes the socket connection",
                  "action_id": "close_socket",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Release connection resource",
                  "intention_id": "release_connection_resource"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "powerline-status-2",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/powerline-status-2.7.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/powerline-status-2.7/powerline-status-2.7/setup.py",
          "line_number": "35",
          "type_description": "code-execution",
          "context_snippet": "import os\nimport sys\nimport subprocess\nimport logging\nimport shlex\n\ndef compile_client():\n\t'''Compile the C powerline-client script.'''\n\n\tif hasattr(sys, 'getwindowsversion'):\n\t\traise NotImplementedError()\n\telse:\n\t\tfrom distutils.ccompiler import new_compiler\n\t\tcompiler = new_compiler().compiler\n\t\tcflags = os.environ.get('CFLAGS', str('-O3'))\n\t\t# A normal split would do a split on each space which might be incorrect. The\n\t\t# shlex will not split if a space occurs in an arguments value.\n\t\tsubprocess.check_call(compiler + shlex.split(cflags) + ['client/powerline.c', '-o', 'scripts/powerline'])",
          "hash_value": "a981eeeac474b082af187de8bc676e1e",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import os\nimport sys\nimport subprocess\nimport logging\nimport shlex\n\ndef compile_client():\n\t'''Compile the C powerline-client script.'''\n\n\tif hasattr(sys, 'getwindowsversion'):\n\t\traise NotImplementedError()\n\telse:\n\t\tfrom distutils.ccompiler import new_compiler\n\t\tcompiler = new_compiler().compiler\n\t\tcflags = os.environ.get('CFLAGS', str('-O3'))\n\t\t# A normal split would do a split on each space which might be incorrect. The\n\t\t# shlex will not split if a space occurs in an arguments value.\n\t\tsubprocess.check_call(compiler + shlex.split(cflags) + ['client/powerline.c', '-o', 'scripts/powerline'])",
              "triple_sequences": [
                {
                  "action_api": "hasattr()",
                  "action_description": "Checks if object is instance of specified type",
                  "action_id": "check_instance_type",
                  "object": "sys, 'getwindowsversion'",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine operating system",
                  "intention_id": "get_operating_system_name"
                },
                {
                  "action_api": "os.environ.get()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "'CFLAGS', str('-O3')",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "shlex.split()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "cflags",
                  "object_description": "String containing environment data",
                  "object_id": "string_environment_data",
                  "intention_description": "Prepare data for further processing",
                  "intention_id": "prepare_data_processing"
                },
                {
                  "action_api": "subprocess.check_call()",
                  "action_description": "Executes shell command",
                  "action_id": "execute_shell_command",
                  "object": "compiler + shlex.split(cflags) + ['client/powerline.c', '-o', 'scripts/powerline']",
                  "object_description": "Shell command",
                  "object_id": "shell_command",
                  "intention_description": "Execute command",
                  "intention_id": "execute_command"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "mouseinfo-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/mouseinfo-0.1.3.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "__init__.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/mouseinfo-0.1.3/MouseInfo-0.1.3/src/mouseinfo/__init__.py",
          "line_number": "358",
          "type_description": "clipboard-access",
          "context_snippet": "import pyperclip, sys, os, platform, webbrowser\n\nclass MouseInfoWindow:\n    def _copyText(self, textToCopy):\n        try:\n            pyperclip.copy(textToCopy)\n            self.statusbarSV.set('Copied ' + textToCopy)\n        except pyperclip.PyperclipException as e:\n            if platform.system() == 'Linux':\n                self.statusbarSV.set('Copy failed. Run \"sudo apt-get install xsel\".')\n            else:\n                self.statusbarSV.set('Clipboard error: ' + str(e))",
          "hash_value": "bc6dc5f1a186094193ee1a10c0bf2d92",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import pyperclip, sys, os, platform, webbrowser\n\nclass MouseInfoWindow:\n    def _copyText(self, textToCopy):\n        try:\n            pyperclip.copy(textToCopy)\n            self.statusbarSV.set('Copied ' + textToCopy)\n        except pyperclip.PyperclipException as e:\n            if platform.system() == 'Linux':\n                self.statusbarSV.set('Copy failed. Run \"sudo apt-get install xsel\".')\n            else:\n                self.statusbarSV.set('Clipboard error: ' + str(e))",
              "triple_sequences": [
                {
                  "action_api": "pyperclip.copy()",
                  "action_description": "Copies specified text to system clipboard",
                  "action_id": "copy_to_clipboard",
                  "object": "textToCopy",
                  "object_description": "Clipboard content data",
                  "object_id": "clipboard_data",
                  "intention_description": "Access clipboard data",
                  "intention_id": "access_clipboard_data"
                },
                {
                  "action_api": "platform.system()",
                  "action_description": "Retrieves operating system identifier",
                  "action_id": "get_os_id",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Determine operating system",
                  "intention_id": "determine_operating_system"
                },
                {
                  "action_api": "str(e)",
                  "action_description": "Converts bytes to string using default codec",
                  "action_id": "decode_bytes_default",
                  "object": "e",
                  "object_description": "Error message text",
                  "object_id": "error_message",
                  "intention_description": "Prepare string for further processing",
                  "intention_id": "prepare_string_processing"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "crewai_tools-0",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/crewai_tools-0.40.1.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "brave_search_tool.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/crewai_tools-0.40.1/crewai_tools-0.40.1/crewai_tools/tools/brave_search_tool/brave_search_tool.py",
          "line_number": "87",
          "type_description": "exfiltrate-sensitive-data",
          "context_snippet": "import datetime\nimport os\nimport time\nfrom typing import Any, ClassVar, Optional, Type\n\nimport requests\nfrom crewai.tools import BaseTool\nfrom pydantic import BaseModel, Field\n\n\ndef _save_results_to_file(content: str) -> None:\n    \"\"\"Saves the search results to a file.\"\"\"\n    filename = f\"search_results_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.txt\"\n    with open(filename, \"w\") as file:\n        file.write(content)\n    print(f\"Results saved to {filename}\")\n\n\nclass BraveSearchToolSchema(BaseModel):\n    \"\"\"Input for BraveSearchTool.\"\"\"\n\n    search_query: str = Field(\n        ..., description=\"Mandatory search query you want to use to search the internet\"\n    )\n\n\nclass BraveSearchTool(BaseTool):\n    \"\"\"\n    BraveSearchTool - A tool for performing web searches using the Brave Search API.\n\n    This module provides functionality to search the internet using Brave's Search API,\n    supporting customizable result counts and country-specific searches.\n\n    Dependencies:\n        - requests\n        - pydantic\n        - python-dotenv (for API key management)\n    \"\"\"\n\n    name: str = \"Brave Web Search the internet\"\n    description: str = (\n        \"A tool that can be used to search the internet with a search_query.\"\n    )\n    args_schema: Type[BaseModel] = BraveSearchToolSchema\n    search_url: str = \"https://api.search.brave.com/res/v1/web/search\"\n    country: Optional[str] = \"\"\n    n_results: int = 10\n    save_file: bool = False\n    _last_request_time: ClassVar[float] = 0\n    _min_request_interval: ClassVar[float] = 1.0  # seconds\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        if \"BRAVE_API_KEY\" not in os.environ:\n            raise ValueError(\n                \"BRAVE_API_KEY environment variable is required for BraveSearchTool\"\n            )\n\n    def _run(\n        self,\n        **kwargs: Any,\n    ) -> Any:\n        current_time = time.time()\n        if (current_time - self._last_request_time) < self._min_request_interval:\n            time.sleep(\n                self._min_request_interval - (current_time - self._last_request_time)\n            )\n        BraveSearchTool._last_request_time = time.time()\n        try:\n            search_query = kwargs.get(\"search_query\") or kwargs.get(\"query\")\n            if not search_query:\n                raise ValueError(\"Search query is required\")\n\n            save_file = kwargs.get(\"save_file\", self.save_file)\n            n_results = kwargs.get(\"n_results\", self.n_results)\n\n            payload = {\"q\": search_query, \"count\": n_results}\n\n            if self.country != \"\":\n                payload[\"country\"] = self.country\n\n            headers = {\n                \"X-Subscription-Token\": os.environ[\"BRAVE_API_KEY\"],\n                \"Accept\": \"application/json\",\n            }\n\n            response = requests.get(self.search_url, headers=headers, params=payload)\n            response.raise_for_status()  # Handle non-200 responses\n            results = response.json()\n\n            if \"web\" in results:\n                results = results[\"web\"][\"results\"]\n                string = []\n                for result in results:\n                    try:\n                        string.append(\n                            \"\\n\".join(\n                                [\n                                    f\"Title: {result['title']}\",\n                                    f\"Link: {result['url']}\",\n                                    f\"Snippet: {result['description']}\",\n                                    \"---\",\n                                ]\n                            )\n                        )\n                    except KeyError:\n                        continue\n\n            content = \"\\n\".join(string)\n        except requests.RequestException as e:\n            return f\"Error performing search: {str(e)}\"\n        except KeyError as e:\n            return f\"Error parsing search results: {str(e)}\"\n        if save_file:\n            _save_results_to_file(content)\n            return f\"\\nSearch results: {content}\\n\"\n        else:\n            return content",
          "hash_value": "467099438ffc5e58ee7ce793e0d4bf5d",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "import datetime\nimport os\nimport time\nfrom typing import Any, ClassVar, Optional, Type\n\nimport requests\nfrom crewai.tools import BaseTool\nfrom pydantic import BaseModel, Field\n\n\ndef _save_results_to_file(content: str) -> None:\n    \"\"\"Saves the search results to a file.\"\"\"\n    filename = f\"search_results_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.txt\"\n    with open(filename, \"w\") as file:\n        file.write(content)\n    print(f\"Results saved to {filename}\")\n\n\nclass BraveSearchToolSchema(BaseModel):\n    \"\"\"Input for BraveSearchTool.\"\"\"\n\n    search_query: str = Field(\n        ..., description=\"Mandatory search query you want to use to search the internet\"\n    )\n\n\nclass BraveSearchTool(BaseTool):\n    \"\"\"\n    BraveSearchTool - A tool for performing web searches using the Brave Search API.\n\n    This module provides functionality to search the internet using Brave's Search API,\n    supporting customizable result counts and country-specific searches.\n\n    Dependencies:\n        - requests\n        - pydantic\n        - python-dotenv (for API key management)\n    \"\"\"\n\n    name: str = \"Brave Web Search the internet\"\n    description: str = (\n        \"A tool that can be used to search the internet with a search_query.\"\n    )\n    args_schema: Type[BaseModel] = BraveSearchToolSchema\n    search_url: str = \"https://api.search.brave.com/res/v1/web/search\"\n    country: Optional[str] = \"\"\n    n_results: int = 10\n    save_file: bool = False\n    _last_request_time: ClassVar[float] = 0\n    _min_request_interval: ClassVar[float] = 1.0  # seconds\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        if \"BRAVE_API_KEY\" not in os.environ:\n            raise ValueError(\n                \"BRAVE_API_KEY environment variable is required for BraveSearchTool\"\n            )\n\n    def _run(\n        self,\n        **kwargs: Any,\n    ) -> Any:\n        current_time = time.time()\n        if (current_time - self._last_request_time) < self._min_request_interval:\n            time.sleep(\n                self._min_request_interval - (current_time - self._last_request_time)\n            )\n        BraveSearchTool._last_request_time = time.time()\n        try:\n            search_query = kwargs.get(\"search_query\") or kwargs.get(\"query\")\n            if not search_query:\n                raise ValueError(\"Search query is required\")\n\n            save_file = kwargs.get(\"save_file\", self.save_file)\n            n_results = kwargs.get(\"n_results\", self.n_results)\n\n            payload = {\"q\": search_query, \"count\": n_results}\n\n            if self.country != \"\":\n                payload[\"country\"] = self.country\n\n            headers = {\n                \"X-Subscription-Token\": os.environ[\"BRAVE_API_KEY\"],\n                \"Accept\": \"application/json\",\n            }\n\n            response = requests.get(self.search_url, headers=headers, params=payload)\n            response.raise_for_status()  # Handle non-200 responses\n            results = response.json()\n\n            if \"web\" in results:\n                results = results[\"web\"][\"results\"]\n                string = []\n                for result in results:\n                    try:\n                        string.append(\n                            \"\\n\".join(\n                                [\n                                    f\"Title: {result['title']}\",\n                                    f\"Link: {result['url']}\",\n                                    f\"Snippet: {result['description']}\",\n                                    \"---\",\n                                ]\n                            )\n                        )\n                    except KeyError:\n                        continue\n\n            content = \"\\n\".join(string)\n        except requests.RequestException as e:\n            return f\"Error performing search: {str(e)}\"\n        except KeyError as e:\n            return f\"Error parsing search results: {str(e)}\"\n        if save_file:\n            _save_results_to_file(content)\n            return f\"\\nSearch results: {content}\\n\"\n        else:\n            return content",
              "triple_sequences": [
                {
                  "action_api": "os.environ.__contains__()",
                  "action_description": "Checks if specified path exists in filesystem",
                  "action_id": "check_path_exists",
                  "object": "BRAVE_API_KEY",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Determine presence of valid authentication",
                  "intention_id": "determine_valid_authentication_presence"
                },
                {
                  "action_api": "os.environ.__getitem__()",
                  "action_description": "Retrieves value of environment variable",
                  "action_id": "get_env_var",
                  "object": "BRAVE_API_KEY",
                  "object_description": "Environment variable",
                  "object_id": "environment_variable",
                  "intention_description": "Collect environment variable",
                  "intention_id": "collect_environment_variable"
                },
                {
                  "action_api": "time.time()",
                  "action_description": "Returns current time",
                  "action_id": "get_current_time",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Get datetime epoch",
                  "intention_id": "get_datetime_epoch"
                },
                {
                  "action_api": "time.sleep()",
                  "action_description": "Suspends execution",
                  "action_id": "suspend_execution",
                  "object": "self._min_request_interval - (current_time - self._last_request_time)",
                  "object_description": "Delay duration in seconds",
                  "object_id": "delay_duration",
                  "intention_description": "Delay next operation",
                  "intention_id": "delay_next_operation"
                },
                {
                  "action_api": "requests.get()",
                  "action_description": "Sends HTTP request",
                  "action_id": "send_http_request",
                  "object": "self.search_url, headers=headers, params=payload",
                  "object_description": "API endpoint",
                  "object_id": "api_endpoint",
                  "intention_description": "Download remote content",
                  "intention_id": "download_remote_content"
                },
                {
                  "action_api": "response.raise_for_status()",
                  "action_description": "Raises HTTPError if response status code indicates error",
                  "action_id": "raise_http_error",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Stop execution on invalid input",
                  "intention_id": "stop_execution_invalid_input"
                },
                {
                  "action_api": "response.json()",
                  "action_description": "Deserializes JSON response body to Python object",
                  "action_id": "deserialize_json_response",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Parse JSON data",
                  "intention_id": "parse_json_data"
                },
                {
                  "action_api": "datetime.now().strftime()",
                  "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
                  "action_id": "path_string_operations",
                  "object": "'%Y-%m-%d_%H-%M-%S'",
                  "object_description": "String containing environment data",
                  "object_id": "string_environment_data",
                  "intention_description": "Prepare file for writing",
                  "intention_id": "prepare_file_writing"
                },
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for writing (normal writing, binary writing)",
                  "action_id": "basic_write_operations",
                  "object": "filename, \"w\"",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Open file for writing",
                  "intention_id": "open_file_writing"
                },
                {
                  "action_api": "file.write()",
                  "action_description": "File opening operations for writing (normal writing, binary writing)",
                  "action_id": "basic_write_operations",
                  "object": "content",
                  "object_description": "File text",
                  "object_id": "file_text",
                  "intention_description": "Write file content",
                  "intention_id": "write_file_content"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "metadata": {
        "package_name": "speechrecognition-3",
        "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/speechrecognition-3.14.2.json",
        "dataset_type": "benign"
      },
      "code_files": [
        {
          "pyfile": "setup.py",
          "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/speechrecognition-3.14.2/speechrecognition-3.14.2/setup.py",
          "line_number": "38",
          "type_description": "cmd-overwrite",
          "context_snippet": "setup(\n    name=\"SpeechRecognition\",\n    version=speech_recognition.__version__,\n    packages=find_packages(exclude=[\"tests.*\", \"test\"]),\n    include_package_data=True,\n    cmdclass={\"install\": InstallWithExtraSteps},\n\n    # PyPI metadata\n    author=speech_recognition.__author__,\n    author_email=\"azhang9@gmail.com\",\n    description=speech_recognition.__doc__,\n    long_description=open(\"README.rst\").read(),\n    long_description_content_type=\"text/x-rst\",\n    license=speech_recognition.__license__,\n    keywords=\"speech recognition voice sphinx google wit bing api houndify ibm snowboy\",\n    url=\"https://github.com/Uberi/speech_recognition#readme\",\n    classifiers=[\n        \"Development Status :: 5 - Production/Stable\",\n        \"Intended Audience :: Developers\",\n        \"Natural Language :: English\",\n        \"License :: OSI Approved :: BSD License\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX :: Linux\",\n        \"Operating System :: MacOS :: MacOS X\",\n        \"Operating System :: Other OS\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.12\",\n        \"Topic :: Software Development :: Libraries :: Python Modules\",\n        \"Topic :: Multimedia :: Sound/Audio :: Speech\",\n    ],\n    python_requires=\">=3.9\",\n    install_requires=[\n        \"typing-extensions\",\n        \"standard-aifc; python_version>='3.13'\",\n        \"audioop-lts; python_version>='3.13'\",\n    ],\n)\n\n# Data dependencies:\n# - InstallWithExtraSteps is defined as a subclass of setuptools.command.install.install\n# - speech_recognition is imported and provides __version__, __author__, __doc__, __license__\n# - find_packages is imported from setuptools\n# - open(\"README.rst\").read() is used for long_description\n# - FILES_TO_MARK_EXECUTABLE and logger are defined above\n# - The context is not inside a function, so the immediate block is the setup() call and its arguments",
          "hash_value": "0e00987d4828cf86c0d209d9dabab7f7",
          "detection_index": 1,
          "code_snippets": [
            {
              "snippet": "setup(\n    name=\"SpeechRecognition\",\n    version=speech_recognition.__version__,\n    packages=find_packages(exclude=[\"tests.*\", \"test\"]),\n    include_package_data=True,\n    cmdclass={\"install\": InstallWithExtraSteps},\n\n    # PyPI metadata\n    author=speech_recognition.__author__,\n    author_email=\"azhang9@gmail.com\",\n    description=speech_recognition.__doc__,\n    long_description=open(\"README.rst\").read(),\n    long_description_content_type=\"text/x-rst\",\n    license=speech_recognition.__license__,\n    keywords=\"speech recognition voice sphinx google wit bing api houndify ibm snowboy\",\n    url=\"https://github.com/Uberi/speech_recognition#readme\",\n    classifiers=[\n        \"Development Status :: 5 - Production/Stable\",\n        \"Intended Audience :: Developers\",\n        \"Natural Language :: English\",\n        \"License :: OSI Approved :: BSD License\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX :: Linux\",\n        \"Operating System :: MacOS :: MacOS X\",\n        \"Operating System :: Other OS\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.12\",\n        \"Topic :: Software Development :: Libraries :: Python Modules\",\n        \"Topic :: Multimedia :: Sound/Audio :: Speech\",\n    ],\n    python_requires=\">=3.9\",\n    install_requires=[\n        \"typing-extensions\",\n        \"standard-aifc; python_version>='3.13'\",\n        \"audioop-lts; python_version>='3.13'\",\n    ],\n)\n\n# Data dependencies:\n# - InstallWithExtraSteps is defined as a subclass of setuptools.command.install.install\n# - speech_recognition is imported and provides __version__, __author__, __doc__, __license__\n# - find_packages is imported from setuptools\n# - open(\"README.rst\").read() is used for long_description\n# - FILES_TO_MARK_EXECUTABLE and logger are defined above\n# - The context is not inside a function, so the immediate block is the setup() call and its arguments",
              "triple_sequences": [
                {
                  "action_api": "open()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "README.rst",
                  "object_description": "File path",
                  "object_id": "file_path",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "file.read()",
                  "action_description": "File opening operations for reading (normal reading, binary reading)",
                  "action_id": "basic_read_operations",
                  "object": "",
                  "object_description": "",
                  "object_id": "",
                  "intention_description": "Read file content",
                  "intention_id": "read_file_content"
                },
                {
                  "action_api": "setup()",
                  "action_description": "Configures and initiates Python package installation",
                  "action_id": "configure_package_install",
                  "object": "{name, version, packages, include_package_data, cmdclass, author, author_email, description, long_description, long_description_content_type, license, keywords, url, classifiers, python_requires, install_requires}",
                  "object_description": "Built-in module or package",
                  "object_id": "builtin_module",
                  "intention_description": "Install required Python package",
                  "intention_id": "install_required_python_package"
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}