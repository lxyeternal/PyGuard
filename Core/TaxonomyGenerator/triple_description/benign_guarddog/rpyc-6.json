{
  "metadata": {
    "package_name": "rpyc-6",
    "original_json_path": "/home2/blue/Documents/PyPIAgent/Codes/code_contexral/codesnippets/benign/rpyc-6.0.1.json",
    "dataset_type": "benign"
  },
  "code_files": [
    {
      "pyfile": "vinegar.py",
      "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/rpyc-6.0.1/rpyc-6.0.1/rpyc/core/vinegar.py",
      "line_number": "126",
      "type_description": "obfuscation",
      "context_snippet": "def load(val, import_custom_exceptions, instantiate_custom_exceptions, instantiate_oldstyle_exceptions):\n    \"\"\"\n    Loads a dumped exception (the tuple returned by :func:`dump`) info a\n    throwable exception object. If the exception cannot be instantiated for any\n    reason (i.e., the security parameters do not allow it, or the exception\n    class simply doesn't exist on the local machine), a :class:`GenericException`\n    instance will be returned instead, containing all of the original exception's\n    details.\n\n    :param val: the dumped exception\n    :param import_custom_exceptions: whether to allow this function to import custom modules\n                                     (imposes a security risk)\n    :param instantiate_custom_exceptions: whether to allow this function to instantiate \"custom\n                                          exceptions\" (i.e., not one of the built-in exceptions,\n                                          such as ``ValueError``, ``OSError``, etc.)\n    :param instantiate_oldstyle_exceptions: whether to allow this function to instantiate exception\n                                            classes that do not derive from ``BaseException``.\n                                            This is required to support old-style exceptions.\n                                            Not applicable for Python 3 and above.\n\n    :returns: A throwable exception object\n    \"\"\"\n    if val == consts.EXC_STOP_ITERATION:\n        return StopIteration  # optimization\n    if type(val) is str:\n        return val  # deprecated string exceptions\n\n    (modname, clsname), args, attrs, tbtext = val\n\n    if import_custom_exceptions and modname not in sys.modules:\n        try:\n            __import__(modname, None, None, \"*\")\n        except Exception:\n            pass\n\n    if instantiate_custom_exceptions:\n        if modname in sys.modules:\n            cls = getattr(sys.modules[modname], clsname, None)\n        else:\n            cls = None\n    elif modname == exceptions_module.__name__:\n        cls = getattr(exceptions_module, clsname, None)\n    else:\n        cls = None\n\n    if not isinstance(cls, type) or not issubclass(cls, BaseException):\n        cls = None\n\n    if cls is None:\n        fullname = f\"{modname}.{clsname}\"\n        # py2: `type()` expects `str` not `unicode`!\n        fullname = str(fullname)\n        if fullname not in _generic_exceptions_cache:\n            fakemodule = {\"__module__\": f\"{__name__}/{modname}\"}\n            if isinstance(GenericException, ClassType):\n                _generic_exceptions_cache[fullname] = ClassType(fullname, (GenericException,), fakemodule)\n            else:\n                _generic_exceptions_cache[fullname] = type(fullname, (GenericException,), fakemodule)\n        cls = _generic_exceptions_cache[fullname]\n\n    cls = _get_exception_class(cls)\n\n    # support old-style exception classes\n    if ClassType is not type and isinstance(cls, ClassType):\n        exc = InstanceType(cls)\n    else:\n        exc = cls.__new__(cls)\n\n    exc.args = args\n    for name, attrval in attrs:\n        try:\n            setattr(exc, name, attrval)\n        except AttributeError:      # handle immutable attrs (@property)\n            pass\n\n    # When possible and relevant, warn the user about mismatch in major versions between remote and local\n    remote_ver = getattr(exc, \"_remote_version\", \"<version denied>\")\n    if remote_ver != \"<version denied>\" and remote_ver.split('.')[0] != str(version.version[0]):\n        _warn = '\\nWARNING: Remote is on RPyC {} and local is on RPyC {}.\\n\\n'\n        tbtext += _warn.format(remote_ver, version.__version__)\n\n    exc._remote_tb = tbtext\n    return exc\n\n# Data dependencies:\n# - exceptions_module: imported at top of file (either 'exceptions' or 'builtins')\n# - clsname: unpacked from val, which is a tuple argument to load()\n# - cls: local variable, set by getattr(exceptions_module, clsname, None)\n# - The function uses sys, version, _generic_exceptions_cache, ClassType, GenericException, _get_exception_class, InstanceType, etc., all defined or imported in the file.",
      "hash_value": "85d5dc02c332aec97f84d76f693b20cd",
      "detection_index": 1,
      "code_snippets": [
        {
          "snippet": "def load(val, import_custom_exceptions, instantiate_custom_exceptions, instantiate_oldstyle_exceptions):\n    \"\"\"\n    Loads a dumped exception (the tuple returned by :func:`dump`) info a\n    throwable exception object. If the exception cannot be instantiated for any\n    reason (i.e., the security parameters do not allow it, or the exception\n    class simply doesn't exist on the local machine), a :class:`GenericException`\n    instance will be returned instead, containing all of the original exception's\n    details.\n\n    :param val: the dumped exception\n    :param import_custom_exceptions: whether to allow this function to import custom modules\n                                     (imposes a security risk)\n    :param instantiate_custom_exceptions: whether to allow this function to instantiate \"custom\n                                          exceptions\" (i.e., not one of the built-in exceptions,\n                                          such as ``ValueError``, ``OSError``, etc.)\n    :param instantiate_oldstyle_exceptions: whether to allow this function to instantiate exception\n                                            classes that do not derive from ``BaseException``.\n                                            This is required to support old-style exceptions.\n                                            Not applicable for Python 3 and above.\n\n    :returns: A throwable exception object\n    \"\"\"\n    if val == consts.EXC_STOP_ITERATION:\n        return StopIteration  # optimization\n    if type(val) is str:\n        return val  # deprecated string exceptions\n\n    (modname, clsname), args, attrs, tbtext = val\n\n    if import_custom_exceptions and modname not in sys.modules:\n        try:\n            __import__(modname, None, None, \"*\")\n        except Exception:\n            pass\n\n    if instantiate_custom_exceptions:\n        if modname in sys.modules:\n            cls = getattr(sys.modules[modname], clsname, None)\n        else:\n            cls = None\n    elif modname == exceptions_module.__name__:\n        cls = getattr(exceptions_module, clsname, None)\n    else:\n        cls = None\n\n    if not isinstance(cls, type) or not issubclass(cls, BaseException):\n        cls = None\n\n    if cls is None:\n        fullname = f\"{modname}.{clsname}\"\n        # py2: `type()` expects `str` not `unicode`!\n        fullname = str(fullname)\n        if fullname not in _generic_exceptions_cache:\n            fakemodule = {\"__module__\": f\"{__name__}/{modname}\"}\n            if isinstance(GenericException, ClassType):\n                _generic_exceptions_cache[fullname] = ClassType(fullname, (GenericException,), fakemodule)\n            else:\n                _generic_exceptions_cache[fullname] = type(fullname, (GenericException,), fakemodule)\n        cls = _generic_exceptions_cache[fullname]\n\n    cls = _get_exception_class(cls)\n\n    # support old-style exception classes\n    if ClassType is not type and isinstance(cls, ClassType):\n        exc = InstanceType(cls)\n    else:\n        exc = cls.__new__(cls)\n\n    exc.args = args\n    for name, attrval in attrs:\n        try:\n            setattr(exc, name, attrval)\n        except AttributeError:      # handle immutable attrs (@property)\n            pass\n\n    # When possible and relevant, warn the user about mismatch in major versions between remote and local\n    remote_ver = getattr(exc, \"_remote_version\", \"<version denied>\")\n    if remote_ver != \"<version denied>\" and remote_ver.split('.')[0] != str(version.version[0]):\n        _warn = '\\nWARNING: Remote is on RPyC {} and local is on RPyC {}.\\n\\n'\n        tbtext += _warn.format(remote_ver, version.__version__)\n\n    exc._remote_tb = tbtext\n    return exc\n\n# Data dependencies:\n# - exceptions_module: imported at top of file (either 'exceptions' or 'builtins')\n# - clsname: unpacked from val, which is a tuple argument to load()\n# - cls: local variable, set by getattr(exceptions_module, clsname, None)\n# - The function uses sys, version, _generic_exceptions_cache, ClassType, GenericException, _get_exception_class, InstanceType, etc., all defined or imported in the file.",
          "triple_sequences": [
            {
              "action_api": "__import__()",
              "action_description": "Dynamically imports specified module",
              "action_id": "import_dynamic",
              "object": "modname, None, None, \"*\"",
              "object_description": "Module name string",
              "object_id": "module_name_string",
              "intention_description": "Import module dynamically",
              "intention_id": "import_module_dynamically"
            },
            {
              "action_api": "getattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "sys.modules[modname], clsname, None",
              "object_description": "Module name string",
              "object_id": "module_name_string",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "getattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "exceptions_module, clsname, None",
              "object_description": "Module name string",
              "object_id": "module_name_string",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "isinstance()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "cls, type",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine presence of required module",
              "intention_id": "determine_required_module_presence"
            },
            {
              "action_api": "issubclass()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "cls, BaseException",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine presence of required module",
              "intention_id": "determine_required_module_presence"
            },
            {
              "action_api": "str()",
              "action_description": "Converts bytes to string using default codec",
              "action_id": "decode_bytes_default",
              "object": "fullname",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare string for further processing",
              "intention_id": "prepare_string_processing"
            },
            {
              "action_api": "isinstance()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "GenericException, ClassType",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine presence of required module",
              "intention_id": "determine_required_module_presence"
            },
            {
              "action_api": "type()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "fullname, (GenericException,), fakemodule",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "_get_exception_class()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "cls",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "isinstance()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "cls, ClassType",
              "object_description": "",
              "object_id": "",
              "intention_description": "Determine presence of required module",
              "intention_id": "determine_required_module_presence"
            },
            {
              "action_api": "InstanceType()",
              "action_description": "Instantiates class or object",
              "action_id": "init_setup_class",
              "object": "cls",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "cls.__new__()",
              "action_description": "Instantiates class or object",
              "action_id": "init_setup_class",
              "object": "cls",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            },
            {
              "action_api": "setattr()",
              "action_description": "Sets attribute on builtins object",
              "action_id": "set_builtin_attr",
              "object": "exc, name, attrval",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "getattr()",
              "action_description": "Checks if object is instance of specified type",
              "action_id": "check_instance_type",
              "object": "exc, \"_remote_version\", \"<version denied>\"",
              "object_description": "",
              "object_id": "",
              "intention_description": "Access attribute value",
              "intention_id": "access_attribute_value"
            },
            {
              "action_api": "str.split()",
              "action_description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
              "action_id": "path_string_operations",
              "object": "remote_ver, '.'",
              "object_description": "",
              "object_id": "",
              "intention_description": "Prepare data for further processing",
              "intention_id": "prepare_data_processing"
            }
          ]
        }
      ]
    }
  ]
}