[
  {
    "pyfile": "setup.py",
    "code_snippet": "# Relevant imports and global variables\nimport os\nimport shutil\nimport subprocess\nimport collections\nimport logging\nfrom platform import system\nfrom setuptools import setup, find_packages, Extension\nfrom setuptools.command import build_ext, sdist, install_lib, install\n\nCURRENT_DIR = os.path.abspath(os.path.dirname(__file__))\n\nUserOption = collections.namedtuple('UserOption', 'description is_boolean value')\n\nUSER_OPTIONS = {\n    'cmake-build-dir': UserOption(description='Build directory used for CMake build',\n                                  value='build', is_boolean=False)\n}\n\nNEED_CLEAN_TREE = set()\nNEED_CLEAN_FILE = set()\nBUILD_TEMP_DIR = None\n\ndef lib_name():\n    \"\"\"Return platform dependent shared object name.\"\"\"\n    if system() == 'Linux' or system().upper().endswith('BSD'):\n        name = 'libtreelite_runtime.so'\n    elif system() == 'Darwin':\n        name = 'libtreelite_runtime.dylib'\n    elif system() == 'Windows':\n        name = 'treelite_runtime.dll'\n    else:\n        raise RuntimeError('Unsupported operating system')\n    return name\n\ndef copy_tree(src_dir, target_dir):\n    \"\"\"Copy source tree into build directory.\"\"\"\n    logger = logging.getLogger('Treelite runtime copy_tree')\n    def clean_copy_tree(src, dst):\n        logger.info(f'Copy tree {src} -> {dst}')\n        shutil.copytree(src, dst)\n        NEED_CLEAN_TREE.add(os.path.abspath(dst))\n\n    def clean_copy_file(src, dst):\n        logger.info(f'Copy file {src} -> {dst}')\n        shutil.copy(src, dst)\n        NEED_CLEAN_FILE.add(os.path.abspath(dst))\n\n    cmake = os.path.join(src_dir, 'cmake')\n    inc = os.path.join(src_dir, 'include')\n    src = os.path.join(src_dir, 'src')\n\n    clean_copy_tree(cmake, os.path.join(target_dir, 'cmake'))\n    clean_copy_tree(inc, os.path.join(target_dir, 'include'))\n    clean_copy_tree(src, os.path.join(target_dir, 'src'))\n\n    cmake_list = os.path.join(src_dir, 'CMakeLists.txt')\n    clean_copy_file(cmake_list, os.path.join(target_dir, 'CMakeLists.txt'))\n    lic = os.path.join(src_dir, 'LICENSE')\n    clean_copy_file(lic, os.path.join(target_dir, 'LICENSE'))\n\ndef clean_up():\n    \"\"\"Removed copied files.\"\"\"\n    for path in NEED_CLEAN_TREE:\n        shutil.rmtree(path)\n    for path in NEED_CLEAN_FILE:\n        os.remove(path)\n\nclass CMakeExtension(Extension):  # pylint: disable=too-few-public-methods\n    \"\"\"Wrapper for libraries built with CMake\"\"\"\n    def __init__(self, name):\n        super().__init__(name=name, sources=[])\n\nclass SDist(sdist.sdist):       # pylint: disable=too-many-ancestors\n    logger = logging.getLogger('Treelite runtime sdist')\n\n    def run(self):\n        copy_tree(os.path.join(CURRENT_DIR, os.path.pardir, os.path.pardir),\n                  os.path.join(CURRENT_DIR, 'treelite_runtime'))\n        super().run()\n\nclass BuildExt(build_ext.build_ext):  # pylint: disable=too-many-ancestors\n    \"\"\"Custom build_ext command using CMake.\"\"\"\n\n    logger = logging.getLogger('Treelite runtime build_ext')\n\n    # pylint: disable=too-many-arguments,no-self-use\n    def build(self, src_dir, build_dir, generator, build_tool=None, use_omp=1):\n        \"\"\"Build the runtime with CMake.\"\"\"\n        cmake_cmd = ['cmake', src_dir, generator]\n\n        # Flag for cross-compiling for Apple Silicon\n        # We use environment variable because it's the only way to pass down custom flags\n        # through the cibuildwheel package, which otherwise calls `python setup.py bdist_wheel`\n        # command.\n        if 'CIBW_TARGET_OSX_ARM64' in os.environ:\n            cmake_cmd.append(\"-DCMAKE_OSX_ARCHITECTURES=arm64\")\n\n        self.logger.info('Run CMake command: %s', str(cmake_cmd))\n        subprocess.check_call(cmake_cmd, cwd=build_dir)\n\n        if system() != 'Windows':\n            nproc = os.cpu_count()\n            build_cmd = [build_tool, 'treelite_runtime', '-j' + str(nproc)]\n            subprocess.check_call(build_cmd, cwd=build_dir)\n        else:\n            subprocess.check_call(['cmake', '--build', '.', '--config', 'Release',\n                                   '--target', 'treelite_runtime'], cwd=build_dir)\n\n    def build_cmake_extension(self):\n        \"\"\"Configure and build using CMake\"\"\"\n        src_dir = 'treelite_runtime'\n        try:\n            copy_tree(os.path.join(CURRENT_DIR, os.path.pardir, os.path.pardir),\n                      os.path.join(self.build_temp, src_dir))\n        except Exception:  # pylint: disable=broad-except\n            copy_tree(src_dir, os.path.join(self.build_temp, src_dir))\n        build_dir = self.build_temp\n        global BUILD_TEMP_DIR  # pylint: disable=global-statement\n        BUILD_TEMP_DIR = build_dir\n        libruntime = os.path.abspath(\n            os.path.join(\n                CURRENT_DIR, os.path.pardir, os.path.pardir, USER_OPTIONS['cmake-build-dir'].value,\n                lib_name()))\n\n        if os.path.exists(libruntime):\n            self.logger.info('Found shared library, skipping build.')\n            return\n\n        self.logger.info('Building from source. %s', lib_name())\n        if not os.path.exists(build_dir):\n            os.mkdir(build_dir)\n        if shutil.which('ninja'):\n            build_tool = 'ninja'\n        else:\n            build_tool = 'make'\n\n        if system() == 'Windows':\n            # Pick up from LGB, just test every possible tool chain.\n            for vs in ('-GVisual Studio 16 2019', '-GVisual Studio 15 2017',\n                       '-GVisual Studio 14 2015', '-GMinGW Makefiles'):\n                try:\n                    self.build(src_dir, build_dir, vs)\n                    self.logger.info(\n                        '%s is used for building Windows distribution.', vs)\n                    break\n                except subprocess.CalledProcessError:\n                    continue\n        else:\n            gen = '-GNinja' if build_tool == 'ninja' else '-GUnix Makefiles'\n            self.build(src_dir, build_dir, gen, build_tool, use_omp=1)\n\n    def build_extension(self, ext):\n        \"\"\"Override the method for dispatching.\"\"\"\n        if isinstance(ext, CMakeExtension):\n            self.build_cmake_extension()\n        else:\n            super().build_extension(ext)\n\n    def copy_extensions_to_source(self):\n        \"\"\"Dummy override.  Invoked during editable installation.\"\"\"\n        if not os.path.exists(\n                os.path.join(CURRENT_DIR, os.path.pardir, os.path.pardir,\n                             USER_OPTIONS['cmake-build-dir'].value, lib_name())):\n            raise ValueError('For using editable installation, please ' +\n                             'build the shared object first with CMake.')\n\nclass InstallLib(install_lib.install_lib):\n    logger = logging.getLogger('Treelite runtime install_lib')\n\n    def install(self):\n\n        outfiles = super().install()\n\n        global BUILD_TEMP_DIR  # pylint: disable=global-statement\n\n        # Copy shared library\n        libruntime_name = lib_name()\n        dst_dir = os.path.join(self.install_dir, 'treelite_runtime', 'lib')\n        if not os.path.exists(dst_dir):\n            os.mkdir(dst_dir)\n        dst = os.path.join(dst_dir, libruntime_name)\n        # CMake build dir is specified relative to the project root directory\n        src_dir = os.path.join(\n            CURRENT_DIR, os.path.pardir, os.path.pardir, USER_OPTIONS['cmake-build-dir'].value)\n        if os.path.isdir(src_dir):\n            # The library was built by CMake\n            src = os.path.join(src_dir, libruntime_name)\n            if not os.path.exists(src):\n                raise Exception(\n                    f'Did not find {libruntime_name} from directory {os.path.normpath(src_dir)}. ' +\n                    f'Run CMake first to build shared lib {libruntime_name}.'\n                )\n            self.logger.info(f'Using {libruntime_name} built by CMake')\n        else:\n            # The library was built by setup.py\n            build_dir = BUILD_TEMP_DIR\n            src = os.path.join(build_dir, libruntime_name)\n            assert os.path.exists(src)\n            self.logger.info(f'Using {libruntime_name} built by setup.py')\n        self.logger.info(f'Installing shared library: {src} -> {dst}')\n        dst, _ = self.copy_file(src, dst)\n        outfiles.append(dst)\n\n        # Copy VERSION\n        dst_dir = os.path.join(self.install_dir, 'treelite_runtime')\n        assert os.path.isdir(dst_dir)\n        dst = os.path.join(dst_dir, 'VERSION')\n        src = os.path.join(CURRENT_DIR, 'treelite_runtime', 'VERSION')\n        assert os.path.exists(src)\n        self.logger.info(f'Installing VERSION: {src} -> {dst}')\n        dst, _ = self.copy_file(src, dst)\n        outfiles.append(dst)\n\n        return outfiles\n\nclass Install(install.install):  # pylint: disable=too-many-instance-attributes\n    logger = logging.getLogger('Treelite runtime install')\n    user_options = install.install.user_options + list(\n        (k + ('' if v.is_boolean else '='), None, v.description) for k, v in USER_OPTIONS.items())\n\n    def initialize_options(self):\n        super().initialize_options()\n        for k, v in USER_OPTIONS.items():\n            arg = k.replace('-', '_')\n            setattr(self, arg, v.value)\n\n    def run(self):\n        for k, v in USER_OPTIONS.items():\n            arg = k.replace('-', '_')\n            if hasattr(self, arg):\n                USER_OPTIONS[k] = USER_OPTIONS[k]._replace(value=getattr(self, arg))\n        super().run()\n\nif __name__ == '__main__':\n    # Supported commands:\n    # From PyPI:\n    # - pip install treelite_runtime\n    # From source tree `treelite/runtime/python`:\n    # - python setup.py install\n    # - python setup.py bdist_wheel && pip install <wheel-name>\n    logging.basicConfig(level=logging.INFO)\n    setup(name='treelite_runtime',\n          version=open(os.path.join(CURRENT_DIR, 'treelite_runtime/VERSION')).read().strip(),\n          description='Treelite runtime',\n          install_requires=['numpy', 'scipy'],\n          ext_modules=[CMakeExtension('libtreelite_runtime')],\n          cmdclass={\n              'build_ext': BuildExt,\n              'sdist': SDist,\n              'install_lib': InstallLib,\n              'install': Install\n          },\n          author='DMLC',\n          maintainer='Hyunsu Cho',\n          maintainer_email='chohyu01@cs.washington.edu',\n          zip_safe=False,\n          packages=find_packages(),\n          include_package_data=True,\n          license='Apache-2.0',\n          classifiers=['License :: OSI Approved :: Apache Software License',\n                       'Development Status :: 5 - Production/Stable',\n                       'Operating System :: OS Independent',\n                       'Programming Language :: Python',\n                       'Programming Language :: Python :: 3',\n                       'Programming Language :: Python :: 3.7',\n                       'Programming Language :: Python :: 3.8'],\n          python_requires='>=3.7',\n          url='https://github.com/dmlc/treelite')\n\n    clean_up()\n",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.abspath",
        "os.path.dirname",
        "os.path.join",
        "os.path.abspath",
        "os.path.join",
        "os.path.abspath",
        "os.path.join",
        "os.path.abspath",
        "os.path.join",
        "shutil.copytree",
        "os.path.abspath",
        "shutil.copytree",
        "os.path.abspath",
        "shutil.copytree",
        "os.path.abspath",
        "os.path.join",
        "shutil.copy",
        "os.path.abspath",
        "os.path.join",
        "shutil.copy",
        "os.path.abspath",
        "shutil.rmtree",
        "os.remove",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.exists",
        "os.cpu_count",
        "shutil.which",
        "subprocess.check_call",
        "subprocess.check_call",
        "subprocess.check_call",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.abspath",
        "os.path.exists",
        "os.path.exists",
        "os.mkdir",
        "shutil.which",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.exists",
        "os.mkdir",
        "os.path.isdir",
        "os.path.join",
        "os.path.exists",
        "os.path.normpath",
        "os.path.join",
        "os.path.join",
        "os.path.isdir",
        "os.path.join",
        "os.path.exists",
        "os.path.join",
        "os.path.join",
        "open",
        "os.path.join"
      ],
      "api_sequence_with_args": [
        "os.path.abspath(os.path.dirname(__file__))",
        "os.path.dirname(__file__)",
        "os.path.join(src_dir, 'cmake')",
        "os.path.abspath(dst)",
        "os.path.join(src_dir, 'include')",
        "os.path.abspath(dst)",
        "os.path.join(src_dir, 'src')",
        "os.path.abspath(dst)",
        "os.path.join(src_dir, 'CMakeLists.txt')",
        "shutil.copytree(src, dst)",
        "os.path.abspath(dst)",
        "shutil.copytree(src, dst)",
        "os.path.abspath(dst)",
        "shutil.copytree(src, dst)",
        "os.path.abspath(dst)",
        "os.path.join(src_dir, 'CMakeLists.txt')",
        "shutil.copy(src, dst)",
        "os.path.abspath(dst)",
        "os.path.join(src_dir, 'LICENSE')",
        "shutil.copy(src, dst)",
        "os.path.abspath(dst)",
        "shutil.rmtree(path)",
        "os.remove(path)",
        "os.path.join(CURRENT_DIR, os.path.pardir, os.path.pardir)",
        "os.path.join(CURRENT_DIR, 'treelite_runtime')",
        "os.path.join(CURRENT_DIR, os.path.pardir, os.path.pardir)",
        "os.path.join(self.build_temp, src_dir)",
        "os.path.abspath(os.path.join(CURRENT_DIR, os.path.pardir, os.path.pardir, USER_OPTIONS['cmake-build-dir'].value, lib_name()))",
        "os.path.exists(libruntime)",
        "os.cpu_count()",
        "shutil.which('ninja')",
        "subprocess.check_call(cmake_cmd, cwd=build_dir)",
        "subprocess.check_call(build_cmd, cwd=build_dir)",
        "subprocess.check_call(['cmake', '--build', '.', '--config', 'Release', '--target', 'treelite_runtime'], cwd=build_dir)",
        "os.path.join(CURRENT_DIR, os.path.pardir, os.path.pardir)",
        "os.path.join(self.build_temp, src_dir)",
        "os.path.join(CURRENT_DIR, os.path.pardir, os.path.pardir, USER_OPTIONS['cmake-build-dir'].value, lib_name())",
        "os.path.abspath(os.path.join(CURRENT_DIR, os.path.pardir, os.path.pardir, USER_OPTIONS['cmake-build-dir'].value, lib_name()))",
        "os.path.exists(libruntime)",
        "os.path.exists(build_dir)",
        "os.mkdir(build_dir)",
        "shutil.which('ninja')",
        "os.path.join(self.install_dir, 'treelite_runtime', 'lib')",
        "os.path.exists(dst_dir)",
        "os.mkdir(dst_dir)",
        "os.path.isdir(src_dir)",
        "os.path.join(src_dir, libruntime_name)",
        "os.path.exists(src)",
        "os.path.normpath(src_dir)",
        "os.path.join(build_dir, libruntime_name)",
        "os.path.exists(src)",
        "os.path.join(self.install_dir, 'treelite_runtime')",
        "os.path.isdir(dst_dir)",
        "os.path.join(dst_dir, 'VERSION')",
        "os.path.join(CURRENT_DIR, 'treelite_runtime', 'VERSION')",
        "os.path.exists(src)",
        "os.path.join(CURRENT_DIR, os.path.pardir, os.path.pardir, USER_OPTIONS['cmake-build-dir'].value, lib_name())",
        "open(os.path.join(CURRENT_DIR, 'treelite_runtime/VERSION'))",
        "os.path.join(CURRENT_DIR, 'treelite_runtime/VERSION')"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.abspath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.dirname",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "shutil.copytree",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "shutil.copy",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "shutil.rmtree",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.remove",
          "id": "delete_file",
          "description": "Deletes specified file from filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.cpu_count",
          "id": "get_processor_name",
          "description": "Retrieves processor name as string",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "hardware_information"
        },
        {
          "api_name": "shutil.which",
          "id": "find_packages",
          "description": "Finds all packages in current directory",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "package_configuration"
        },
        {
          "api_name": "subprocess.check_call",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "os.mkdir",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.isdir",
          "id": "check_directory_exists",
          "description": "Checks if specified path exists and is a directory",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.path.normpath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        }
      ],
      "contextual_code": "# Essential code context with sensitive API calls and dependencies\nimport os\nimport shutil\nimport subprocess\nimport logging\nfrom platform import system\nfrom setuptools import setup, find_packages, Extension\nfrom setuptools.command import build_ext, sdist, install_lib, install\n\nCURRENT_DIR = os.path.abspath(os.path.dirname(__file__))\n\n# --- copy_tree and clean_up ---\ndef copy_tree(src_dir, target_dir):\n    logger = logging.getLogger('Treelite runtime copy_tree')\n    def clean_copy_tree(src, dst):\n        logger.info(f'Copy tree {src} -> {dst}')\n        shutil.copytree(src, dst)\n        NEED_CLEAN_TREE.add(os.path.abspath(dst))\n    def clean_copy_file(src, dst):\n        logger.info(f'Copy file {src} -> {dst}')\n        shutil.copy(src, dst)\n        NEED_CLEAN_FILE.add(os.path.abspath(dst))\n    cmake = os.path.join(src_dir, 'cmake')\n    inc = os.path.join(src_dir, 'include')\n    src = os.path.join(src_dir, 'src')\n    clean_copy_tree(cmake, os.path.join(target_dir, 'cmake'))\n    clean_copy_tree(inc, os.path.join(target_dir, 'include'))\n    clean_copy_tree(src, os.path.join(target_dir, 'src'))\n    cmake_list = os.path.join(src_dir, 'CMakeLists.txt')\n    clean_copy_file(cmake_list, os.path.join(target_dir, 'CMakeLists.txt'))\n    lic = os.path.join(src_dir, 'LICENSE')\n    clean_copy_file(lic, os.path.join(target_dir, 'LICENSE'))\n\ndef clean_up():\n    for path in NEED_CLEAN_TREE:\n        shutil.rmtree(path)\n    for path in NEED_CLEAN_FILE:\n        os.remove(path)\n\n# --- BuildExt class (build_cmake_extension and build) ---\nclass BuildExt(build_ext.build_ext):\n    logger = logging.getLogger('Treelite runtime build_ext')\n    def build(self, src_dir, build_dir, generator, build_tool=None, use_omp=1):\n        cmake_cmd = ['cmake', src_dir, generator]\n        if 'CIBW_TARGET_OSX_ARM64' in os.environ:\n            cmake_cmd.append(\"-DCMAKE_OSX_ARCHITECTURES=arm64\")\n        self.logger.info('Run CMake command: %s', str(cmake_cmd))\n        subprocess.check_call(cmake_cmd, cwd=build_dir)\n        if system() != 'Windows':\n            nproc = os.cpu_count()\n            build_cmd = [build_tool, 'treelite_runtime', '-j' + str(nproc)]\n            subprocess.check_call(build_cmd, cwd=build_dir)\n        else:\n            subprocess.check_call(['cmake', '--build', '.', '--config', 'Release', '--target', 'treelite_runtime'], cwd=build_dir)\n    def build_cmake_extension(self):\n        src_dir = 'treelite_runtime'\n        try:\n            copy_tree(os.path.join(CURRENT_DIR, os.path.pardir, os.path.pardir), os.path.join(self.build_temp, src_dir))\n        except Exception:\n            copy_tree(src_dir, os.path.join(self.build_temp, src_dir))\n        build_dir = self.build_temp\n        global BUILD_TEMP_DIR\n        BUILD_TEMP_DIR = build_dir\n        libruntime = os.path.abspath(os.path.join(CURRENT_DIR, os.path.pardir, os.path.pardir, USER_OPTIONS['cmake-build-dir'].value, lib_name()))\n        if os.path.exists(libruntime):\n            self.logger.info('Found shared library, skipping build.')\n            return\n        self.logger.info('Building from source. %s', lib_name())\n        if not os.path.exists(build_dir):\n            os.mkdir(build_dir)\n        if shutil.which('ninja'):\n            build_tool = 'ninja'\n        else:\n            build_tool = 'make'\n        if system() == 'Windows':\n            for vs in ('-GVisual Studio 16 2019', '-GVisual Studio 15 2017', '-GVisual Studio 14 2015', '-GMinGW Makefiles'):\n                try:\n                    self.build(src_dir, build_dir, vs)\n                    self.logger.info('%s is used for building Windows distribution.', vs)\n                    break\n                except subprocess.CalledProcessError:\n                    continue\n        else:\n            gen = '-GNinja' if build_tool == 'ninja' else '-GUnix Makefiles'\n            self.build(src_dir, build_dir, gen, build_tool, use_omp=1)\n\n# --- InstallLib class (install method) ---\nclass InstallLib(install_lib.install_lib):\n    logger = logging.getLogger('Treelite runtime install_lib')\n    def install(self):\n        outfiles = super().install()\n        global BUILD_TEMP_DIR\n        libruntime_name = lib_name()\n        dst_dir = os.path.join(self.install_dir, 'treelite_runtime', 'lib')\n        if not os.path.exists(dst_dir):\n            os.mkdir(dst_dir)\n        dst = os.path.join(dst_dir, libruntime_name)\n        src_dir = os.path.join(CURRENT_DIR, os.path.pardir, os.path.pardir, USER_OPTIONS['cmake-build-dir'].value)\n        if os.path.isdir(src_dir):\n            src = os.path.join(src_dir, libruntime_name)\n            if not os.path.exists(src):\n                raise Exception(f'Did not find {libruntime_name} from directory {os.path.normpath(src_dir)}. Run CMake first to build shared lib {libruntime_name}.')\n            self.logger.info(f'Using {libruntime_name} built by CMake')\n        else:\n            build_dir = BUILD_TEMP_DIR\n            src = os.path.join(build_dir, libruntime_name)\n            assert os.path.exists(src)\n            self.logger.info(f'Using {libruntime_name} built by setup.py')\n        self.logger.info(f'Installing shared library: {src} -> {dst}')\n        dst, _ = self.copy_file(src, dst)\n        outfiles.append(dst)\n        dst_dir = os.path.join(self.install_dir, 'treelite_runtime')\n        assert os.path.isdir(dst_dir)\n        dst = os.path.join(dst_dir, 'VERSION')\n        src = os.path.join(CURRENT_DIR, 'treelite_runtime', 'VERSION')\n        assert os.path.exists(src)\n        self.logger.info(f'Installing VERSION: {src} -> {dst}')\n        dst, _ = self.copy_file(src, dst)\n        outfiles.append(dst)\n        return outfiles\n\n# --- setup() and open() usage ---\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.INFO)\n    setup(\n        name='treelite_runtime',\n        version=open(os.path.join(CURRENT_DIR, 'treelite_runtime/VERSION')).read().strip(),\n        ...\n    )\n    clean_up()\n"
    }
  },
  {
    "metadata": {
      "package_name": "treelite_runtime-3.9.1",
      "total_matches": 2
    }
  }
]