[
  {
    "pyfile": "setup.py",
    "code_snippet": "import ast\nimport contextlib\nimport glob\nimport io\nimport os\nimport platform\nimport re\nimport shutil\nimport struct\nimport subprocess\nimport sys\nimport sysconfig\nimport tempfile\nimport textwrap\nimport warnings\n\nHERE = os.path.abspath(os.path.dirname(__file__))\n\n# ...so we can import _common.py\nsys.path.insert(0, os.path.join(HERE, \"psutil\"))\n\nfrom _common import AIX  # noqa: E402\nfrom _common import BSD  # noqa: E402\nfrom _common import FREEBSD  # noqa: E402\nfrom _common import LINUX  # noqa: E402\nfrom _common import MACOS  # noqa: E402\nfrom _common import NETBSD  # noqa: E402\nfrom _common import OPENBSD  # noqa: E402\nfrom _common import POSIX  # noqa: E402\nfrom _common import SUNOS  # noqa: E402\nfrom _common import WINDOWS  # noqa: E402\nfrom _common import hilite  # noqa: E402\n\n\ndef get_long_description():\n    script = os.path.join(HERE, \"scripts\", \"internal\", \"convert_readme.py\")\n    readme = os.path.join(HERE, 'README.rst')\n    p = subprocess.Popen(\n        [sys.executable, script, readme],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        universal_newlines=True,\n    )\n    stdout, stderr = p.communicate()\n    if p.returncode != 0:\n        raise RuntimeError(stderr)\n    return stdout\n",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.abspath",
        "os.path.dirname",
        "sys.path.insert",
        "os.path.join",
        "os.path.join",
        "subprocess.Popen",
        "sys.executable",
        "subprocess.Popen.communicate"
      ],
      "api_sequence_with_args": [
        "os.path.abspath(os.path.dirname(__file__))",
        "os.path.dirname(__file__)",
        "sys.path.insert(0, os.path.join(HERE, \"psutil\"))",
        "os.path.join(HERE, \"scripts\", \"internal\", \"convert_readme.py\")",
        "os.path.join(HERE, 'README.rst')",
        "subprocess.Popen([sys.executable, script, readme], stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)",
        "sys.executable",
        "subprocess.Popen.communicate()"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.abspath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.dirname",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "sys.path.insert",
          "id": "insert_module_path",
          "description": "Inserts directory at start of module search path",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "subprocess.Popen",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "sys.executable",
          "id": "get_cmd_args",
          "description": "Retrieves command-line arguments passed to script",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "subprocess.Popen.communicate",
          "id": "read_process_stdout",
          "description": "Reads all bytes from process standard output",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        }
      ],
      "contextual_code": "HERE = os.path.abspath(os.path.dirname(__file__))\n\nsys.path.insert(0, os.path.join(HERE, \"psutil\"))\n\ndef get_long_description():\n    script = os.path.join(HERE, \"scripts\", \"internal\", \"convert_readme.py\")\n    readme = os.path.join(HERE, 'README.rst')\n    p = subprocess.Popen(\n        [sys.executable, script, readme],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        universal_newlines=True,\n    )\n    stdout, stderr = p.communicate()\n    if p.returncode != 0:\n        raise RuntimeError(stderr)\n    return stdout"
    }
  },
  {
    "metadata": {
      "package_name": "psutil-7.0.0",
      "total_matches": 1
    }
  }
]