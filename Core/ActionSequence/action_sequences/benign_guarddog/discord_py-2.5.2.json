[
  {
    "pyfile": "abc.py",
    "code_snippet": "    @property\n    def jump_url(self) -> str:\n        \"\"\":class:`str`: Returns a URL that allows the client to jump to the channel.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return f'https://discord.com/channels/{self.guild.id}/{self.id}'\n",
    "pattern_analysis": {
      "api_sequence": [],
      "api_sequence_with_args": [],
      "mapped_sequence": [],
      "contextual_code": "@property\ndef jump_url(self) -> str:\n    \"\"\":class:`str`: Returns a URL that allows the client to jump to the channel.\n\n    .. versionadded:: 2.0\n    \"\"\"\n    return f'https://discord.com/channels/{self.guild.id}/{self.id}'"
    }
  },
  {
    "pyfile": "errors.py",
    "code_snippet": "class PrivilegedIntentsRequired(ClientException):\n    \"\"\"Exception that's raised when the gateway is requesting privileged intents\n    but they're not ticked in the developer page yet.\n\n    Go to https://discord.com/developers/applications/ and enable the intents\n    that are required. Currently these are as follows:\n\n    - :attr:`Intents.members`\n    - :attr:`Intents.presences`\n    - :attr:`Intents.message_content`\n\n    Attributes\n    -----------\n    shard_id: Optional[:class:`int`]\n        The shard ID that got closed if applicable.\n    \"\"\"\n\n    def __init__(self, shard_id: Optional[int]):\n        self.shard_id: Optional[int] = shard_id\n        msg = (\n            'Shard ID %s is requesting privileged intents that have not been explicitly enabled in the '\n            'developer portal. It is recommended to go to https://discord.com/developers/applications/ '\n            'and explicitly enable the privileged intents within your application\\'s page. If this is not '\n            'possible, then consider disabling the privileged intents instead.'\n        )\n        super().__init__(msg % shard_id)\n",
    "pattern_analysis": {
      "api_sequence": [],
      "api_sequence_with_args": [],
      "mapped_sequence": [],
      "contextual_code": "class PrivilegedIntentsRequired(ClientException):\n    def __init__(self, shard_id: Optional[int]):\n        self.shard_id: Optional[int] = shard_id\n        msg = (\n            'Shard ID %s is requesting privileged intents that have not been explicitly enabled in the '\n            'developer portal. It is recommended to go to https://discord.com/developers/applications/ '\n            'and explicitly enable the privileged intents within your application\\'s page. If this is not '\n            'possible, then consider disabling the privileged intents instead.'\n        )\n        super().__init__(msg % shard_id)"
    }
  },
  {
    "pyfile": "http.py",
    "code_snippet": "import logging\nfrom typing import ClassVar\n\n_log = logging.getLogger(__name__)\n\nINTERNAL_API_VERSION: int = 10\n\nclass Route:\n    BASE: ClassVar[str] = 'https://discord.com/api/v10'\n\n    def __init__(self, method: str, path: str, *, metadata: Optional[str] = None, **parameters: Any) -> None:\n        self.path: str = path\n        self.method: str = method\n        # Metadata is a special string used to differentiate between known sub rate limits\n        # Since these can't be handled generically, this is the next best way to do so.\n        self.metadata: Optional[str] = metadata\n        url = self.BASE + self.path\n        if parameters:\n            url = url.format_map({k: _uriquote(v, safe='') if isinstance(v, str) else v for k, v in parameters.items()})\n        self.url: str = url\n\n        # major parameters:\n        self.channel_id: Optional[Snowflake] = parameters.get('channel_id')\n        self.guild_id: Optional[Snowflake] = parameters.get('guild_id')\n        self.webhook_id: Optional[Snowflake] = parameters.get('webhook_id')\n        self.webhook_token: Optional[str] = parameters.get('webhook_token')\n\n    @property\n    def key(self) -> str:\n        \"\"\"The bucket key is used to represent the route in various mappings.\"\"\"\n        if self.metadata:\n            return f'{self.method} {self.path}:{self.metadata}'\n        return f'{self.method} {self.path}'\n\n    @property\n    def major_parameters(self) -> str:\n        \"\"\"Returns the major parameters formatted a string.\n\n        This needs to be appended to a bucket hash to constitute as a full rate limit key.\n        \"\"\"\n        return '+'.join(\n            str(k) for k in (self.channel_id, self.guild_id, self.webhook_id, self.webhook_token) if k is not None\n        )\n\ndef _set_api_version(value: int):\n    global INTERNAL_API_VERSION\n\n    if not isinstance(value, int):\n        raise TypeError(f'expected int not {value.__class__.__name__}')\n\n    if value not in (9, 10):\n        raise ValueError(f'expected either 9 or 10 not {value}')\n\n    INTERNAL_API_VERSION = value\n    Route.BASE = f'https://discord.com/api/v{value}'\n",
    "pattern_analysis": {
      "api_sequence": [
        "logging.getLogger",
        "isinstance",
        "TypeError",
        "ValueError"
      ],
      "api_sequence_with_args": [
        "logging.getLogger(__name__)",
        "isinstance(value, int)",
        "TypeError(f'expected int not {value.__class__.__name__}')",
        "ValueError(f'expected either 9 or 10 not {value}')"
      ],
      "mapped_sequence": [
        {
          "api_name": "logging.getLogger",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "isinstance",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "TypeError",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "ValueError",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        }
      ],
      "contextual_code": "import logging\n\n_log = logging.getLogger(__name__)\n\ndef _set_api_version(value: int):\n    global INTERNAL_API_VERSION\n\n    if not isinstance(value, int):\n        raise TypeError(f'expected int not {value.__class__.__name__}')\n\n    if value not in (9, 10):\n        raise ValueError(f'expected either 9 or 10 not {value}')\n\n    INTERNAL_API_VERSION = value\n    Route.BASE = f'https://discord.com/api/v{value}'"
    }
  },
  {
    "pyfile": "scheduled_event.py",
    "code_snippet": "    @property\n    def url(self) -> str:\n        \"\"\":class:`str`: The url for the scheduled event.\"\"\"\n        return f'https://discord.com/events/{self.guild_id}/{self.id}'\n\n    # Data dependencies:\n    # - self.guild_id: Set in self._update(), which is called in __init__\n    # - self.id: Set in self._update(), which is called in __init__\n    #\n    # Relevant code for data dependencies:\n    def __init__(self, *, state: ConnectionState, data: GuildScheduledEventPayload) -> None:\n        self._state = state\n        self._users: Dict[int, User] = {}\n        self._update(data)\n\n    def _update(self, data: GuildScheduledEventPayload) -> None:\n        self.id: int = int(data['id'])\n        self.guild_id: int = int(data['guild_id'])\n        # ... other assignments ...\n",
    "pattern_analysis": {
      "api_sequence": [],
      "api_sequence_with_args": [],
      "mapped_sequence": [],
      "contextual_code": "    @property\n    def url(self) -> str:\n        \"\"\":class:`str`: The url for the scheduled event.\"\"\"\n        return f'https://discord.com/events/{self.guild_id}/{self.id}'\n\n    # Data dependencies:\n    # - self.guild_id: Set in self._update(), which is called in __init__\n    # - self.id: Set in self._update(), which is called in __init__\n    #\n    # Relevant code for data dependencies:\n    def __init__(self, *, state: ConnectionState, data: GuildScheduledEventPayload) -> None:\n        self._state = state\n        self._users: Dict[int, User] = {}\n        self._update(data)\n\n    def _update(self, data: GuildScheduledEventPayload) -> None:\n        self.id: int = int(data['id'])\n        self.guild_id: int = int(data['guild_id'])\n        # ... other assignments ...\n"
    }
  },
  {
    "pyfile": "threads.py",
    "code_snippet": "    @property\n    def jump_url(self) -> str:\n        \"\"\":class:`str`: Returns a URL that allows the client to jump to the thread.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return f'https://discord.com/channels/{self.guild.id}/{self.id}'\n\n    # Data dependencies:\n    # - self.guild: Set in __init__ as a parameter, type Guild\n    # - self.id: Set in _from_data, called from __init__, from data['id']\n    # - self: instance of Thread\n    #\n    # Relevant imports and types:\n    # from .guild import Guild\n    #\n    # The property is part of the Thread class, which is defined as:\n    # class Thread(Messageable, Hashable):\n    #     ...\n    #     def __init__(self, *, guild: Guild, state: ConnectionState, data: ThreadPayload) -> None:\n    #         self._state: ConnectionState = state\n    #         self.guild: Guild = guild\n    #         self._members: Dict[int, ThreadMember] = {}\n    #         self._from_data(data)\n    #     ...\n    #     def _from_data(self, data: ThreadPayload):\n    #         self.id: int = int(data['id'])\n    #         ...\n    #\n    # No external input is used in the URL construction; it is a formatted string using known IDs.",
    "pattern_analysis": {
      "api_sequence": [],
      "api_sequence_with_args": [],
      "mapped_sequence": [],
      "contextual_code": "    @property\n    def jump_url(self) -> str:\n        \"\"\":class:`str`: Returns a URL that allows the client to jump to the thread.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return f'https://discord.com/channels/{self.guild.id}/{self.id}'\n\n    # Data dependencies:\n    # - self.guild: Set in __init__ as a parameter, type Guild\n    # - self.id: Set in _from_data, called from __init__, from data['id']\n    # - self: instance of Thread\n    #\n    # Relevant imports and types:\n    # from .guild import Guild\n    #\n    # The property is part of the Thread class, which is defined as:\n    # class Thread(Messageable, Hashable):\n    #     ...\n    #     def __init__(self, *, guild: Guild, state: ConnectionState, data: ThreadPayload) -> None:\n    #         self._state: ConnectionState = state\n    #         self.guild: Guild = guild\n    #         self._members: Dict[int, ThreadMember] = {}\n    #         self._from_data(data)\n    #     ...\n    #     def _from_data(self, data: ThreadPayload):\n    #         self.id: int = int(data['id'])\n    #         ...\n    #\n    # No external input is used in the URL construction; it is a formatted string using known IDs."
    }
  },
  {
    "pyfile": "async_.py",
    "code_snippet": "    @property\n    def url(self) -> str:\n        \"\"\":class:`str` : Returns the webhook's url.\"\"\"\n        return f'https://discord.com/api/webhooks/{self.id}/{self.token}'\n\n    # Data dependencies:\n    # - self.id: Set in BaseWebhook.__init__ via self._update(data), which sets self.id = int(data['id'])\n    # - self.token: Set in BaseWebhook._update via self.token = data.get('token')\n    #   (or in Webhook.partial/from_url, data['token'] is set from input)\n    #\n    # Class inheritance:\n    # class Webhook(BaseWebhook):\n    #\n    # Relevant imports:\n    # import re\n    #\n    # The property is used to return the canonical Discord webhook URL for this webhook instance.\n",
    "pattern_analysis": {
      "api_sequence": [],
      "api_sequence_with_args": [],
      "mapped_sequence": [],
      "contextual_code": "@property\ndef url(self) -> str:\n    \"\"\":class:`str` : Returns the webhook's url.\"\"\"\n    return f'https://discord.com/api/webhooks/{self.id}/{self.token}'"
    }
  },
  {
    "pyfile": "sync.py",
    "code_snippet": "    @property\n    def url(self) -> str:\n        \"\"\":class:`str` : Returns the webhook's url.\"\"\"\n        return f'https://discord.com/api/webhooks/{self.id}/{self.token}'\n",
    "pattern_analysis": {
      "api_sequence": [],
      "api_sequence_with_args": [],
      "mapped_sequence": [],
      "contextual_code": "@property\ndef url(self) -> str:\n    \"\"\":class:`str` : Returns the webhook's url.\"\"\"\n    return f'https://discord.com/api/webhooks/{self.id}/{self.token}'"
    }
  },
  {
    "pyfile": "widget.py",
    "code_snippet": "    @property\n    def json_url(self) -> str:\n        \"\"\":class:`str`: The JSON URL of the widget.\"\"\"\n        return f\"https://discord.com/api/guilds/{self.id}/widget.json\"\n\n    @property\n    def invite_url(self) -> Optional[str]:\n        \"\"\"Optional[:class:`str`]: The invite URL for the guild, if available.\"\"\"\n        return self._invite\n\n    async def fetch_invite(self, *, with_counts: bool = True) -> Optional[Invite]:\n        \"\"\"|coro|\n\n        Retrieves an :class:`Invite` from the widget's invite URL.\n        This is the same as :meth:`Client.fetch_invite`; the invite\n        code is abstracted away.\n\n        Parameters\n        -----------\n        with_counts: :class:`bool`\n            Whether to include count information in the invite. This fills the\n            :attr:`Invite.approximate_member_count` and :attr:`Invite.approximate_presence_count`\n            fields.\n\n        Returns\n        --------\n        Optional[:class:`Invite`]\n            The invite from the widget's invite URL, if available.\n        \"\"\"\n        if self._invite:\n            resolved = resolve_invite(self._invite)\n            data = await self._state.http.get_invite(resolved.code, with_counts=with_counts)\n            return Invite.from_incomplete(state=self._state, data=data)\n        return None\n\n# Data dependencies and relevant imports\nfrom .utils import snowflake_time, _get_as_snowflake, resolve_invite\nfrom .invite import Invite\nfrom typing import Optional\n",
    "pattern_analysis": {
      "api_sequence": [
        "resolve_invite",
        "self._state.http.get_invite",
        "Invite.from_incomplete"
      ],
      "api_sequence_with_args": [
        "resolve_invite(self._invite)",
        "self._state.http.get_invite(resolved.code, with_counts=with_counts)",
        "Invite.from_incomplete(state=self._state, data=data)"
      ],
      "mapped_sequence": [
        {
          "api_name": "resolve_invite",
          "id": "check_discord_token",
          "description": "Checks validity of Discord token",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_control"
        },
        {
          "api_name": "self._state.http.get_invite",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "Invite.from_incomplete",
          "id": "deserialize_json_response",
          "description": "Deserializes JSON response body to Python object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        }
      ],
      "contextual_code": "async def fetch_invite(self, *, with_counts: bool = True) -> Optional[Invite]:\n    if self._invite:\n        resolved = resolve_invite(self._invite)\n        data = await self._state.http.get_invite(resolved.code, with_counts=with_counts)\n        return Invite.from_incomplete(state=self._state, data=data)\n    return None"
    }
  },
  {
    "pyfile": "setup.py",
    "code_snippet": "import re\nfrom setuptools import setup\n\n\ndef derive_version() -> str:\n    version = ''\n    with open('discord/__init__.py') as f:\n        version = re.search(r'^__version__\\s*=\\s*[\\'\"]([^\\'\"]*)[\\'\"]', f.read(), re.MULTILINE).group(1)\n\n    if not version:\n        raise RuntimeError('version is not set')\n\n    if version.endswith(('a', 'b', 'rc')):\n        # append version identifier based on commit count\n        try:\n            import subprocess\n\n            p = subprocess.Popen(['git', 'rev-list', '--count', 'HEAD'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            out, err = p.communicate()\n            if out:\n                version += out.decode('utf-8').strip()\n            p = subprocess.Popen(['git', 'rev-parse', '--short', 'HEAD'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            out, err = p.communicate()\n            if out:\n                version += '+g' + out.decode('utf-8').strip()\n        except Exception:\n            pass\n\n    return version\n\n\nsetup(version=derive_version())\n",
    "pattern_analysis": {
      "api_sequence": [
        "open",
        "re.search",
        "f.read",
        "subprocess.Popen",
        "subprocess.Popen.communicate",
        "out.decode",
        "subprocess.Popen",
        "subprocess.Popen.communicate",
        "out.decode",
        "setuptools.setup"
      ],
      "api_sequence_with_args": [
        "open('discord/__init__.py')",
        "re.search(r'^__version__\\s*=\\s*[\\'\"]([^\\'\"]*)[\\'\"]', f.read(), re.MULTILINE)",
        "f.read()",
        "subprocess.Popen(['git', 'rev-list', '--count', 'HEAD'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)",
        "subprocess.Popen.communicate()",
        "out.decode('utf-8').strip()",
        "subprocess.Popen(['git', 'rev-parse', '--short', 'HEAD'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)",
        "subprocess.Popen.communicate()",
        "out.decode('utf-8').strip()",
        "setuptools.setup(version=derive_version())"
      ],
      "mapped_sequence": [
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "re.search",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "f.read",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "subprocess.Popen",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "subprocess.Popen.communicate",
          "id": "read_process_stdout",
          "description": "Reads all bytes from process standard output",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "out.decode",
          "id": "decode_bytes_codec",
          "description": "Decodes bytes using specified codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "subprocess.Popen",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "subprocess.Popen.communicate",
          "id": "read_process_stdout",
          "description": "Reads all bytes from process standard output",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "out.decode",
          "id": "decode_bytes_codec",
          "description": "Decodes bytes using specified codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "setuptools.setup",
          "id": "configure_package_install",
          "description": "Configures and initiates Python package installation",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "package_configuration"
        }
      ],
      "contextual_code": "import re\nfrom setuptools import setup\n\ndef derive_version() -> str:\n    version = ''\n    with open('discord/__init__.py') as f:\n        version = re.search(r'^__version__\\s*=\\s*[\\'\"]([^\\'\"]*)[\\'\"]', f.read(), re.MULTILINE).group(1)\n\n    if not version:\n        raise RuntimeError('version is not set')\n\n    if version.endswith(('a', 'b', 'rc')):\n        try:\n            import subprocess\n            p = subprocess.Popen(['git', 'rev-list', '--count', 'HEAD'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            out, err = p.communicate()\n            if out:\n                version += out.decode('utf-8').strip()\n            p = subprocess.Popen(['git', 'rev-parse', '--short', 'HEAD'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            out, err = p.communicate()\n            if out:\n                version += '+g' + out.decode('utf-8').strip()\n        except Exception:\n            pass\n\n    return version\n\nsetup(version=derive_version())"
    }
  },
  {
    "metadata": {
      "package_name": "discord_py-2.5.2",
      "total_matches": 11
    }
  }
]