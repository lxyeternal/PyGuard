[
  {
    "pyfile": "setup.py",
    "code_snippet": "import os\nimport re\nimport sys\nimport functools\nimport setuptools\nimport subprocess\nfrom warnings import warn\nimport packaging.version\nimport sysconfig\n\nLIBERFADIR = os.path.join('liberfa', 'erfa')\nERFA_SRC = os.path.join(LIBERFADIR, 'src')\nGEN_FILES = [\n    os.path.join('erfa', 'core.py'),\n    os.path.join('erfa', 'ufunc.c'),\n]\n\nUSE_PY_LIMITED_API = not sysconfig.get_config_var(\"Py_GIL_DISABLED\")\n\ndef newer(source, target):\n    import pathlib\n\n    source = pathlib.Path(source)\n    if not source.exists():\n        raise FileNotFoundError(f\"file '{source.resolve()}' does not exist\")\n\n    target = pathlib.Path(target)\n    if not target.exists():\n        return 1\n\n    return source.stat().st_mtime > target.stat().st_mtime\n\ndef get_liberfa_versions(path=os.path.join(LIBERFADIR, 'configure.ac')):\n    with open(path) as fd:\n        s = fd.read()\n\n    mobj = re.search(r'AC_INIT\\(\\[erfa\\],\\[(?P<version>[0-9.]+)\\]\\)', s)\n    if not mobj:\n        warn('unable to detect liberfa version')\n        return []\n\n    version = packaging.version.parse(mobj.group('version'))\n\n    mobj = re.search(\n        r'AC_DEFINE\\(\\[SOFA_VERSION\\], \\[\"(?P<version>\\d{8}(_\\w)?)\"\\],', s)\n    if not mobj:\n        warn('unable to detect SOFA version')\n        return []\n    sofa_version = mobj.group('version')\n\n    return [\n        ('PACKAGE_VERSION', version.base_version),\n        ('PACKAGE_VERSION_MAJOR', version.major),\n        ('PACKAGE_VERSION_MINOR', version.minor),\n        ('PACKAGE_VERSION_MICRO', version.micro),\n        ('SOFA_VERSION', sofa_version),\n    ]\n\ndef get_extensions():\n    gen_files_exist = all(os.path.isfile(fn) for fn in GEN_FILES)\n    gen_files_outdated = False\n    if os.path.isdir(ERFA_SRC):\n        # assume that 'erfaversion.c' is updated at each release at least\n        src = os.path.join(ERFA_SRC, 'erfaversion.c')\n        gen_files_outdated = any(newer(src, fn) for fn in GEN_FILES)\n    elif not gen_files_exist:\n        raise RuntimeError(\n            'Missing \"liberfa\" source files, unable to generate '\n            '\"erfa/ufunc.c\" and \"erfa/core.py\". '\n            'Please check your source tree. '\n            'Maybe \"git submodule update\" could help.')\n\n    if not gen_files_exist or gen_files_outdated:\n        print('Run \"erfa_generator.py\"')\n        cmd = [sys.executable, 'erfa_generator.py', ERFA_SRC, '--quiet']\n        subprocess.run(cmd, check=True)\n\n    sources = [os.path.join('erfa', 'ufunc.c')]\n    include_dirs = []\n    libraries = []\n    define_macros = []\n\n    if int(os.environ.get('PYERFA_USE_SYSTEM_LIBERFA', 0)):\n        print('Using system liberfa')\n        libraries.append('erfa')\n    else:\n        # get all of the .c files in the liberfa/erfa/src directory\n        erfafns = os.listdir(ERFA_SRC)\n        sources.extend([os.path.join(ERFA_SRC, fn)\n                        for fn in erfafns\n                        if fn.endswith('.c') and not fn.startswith('t_')])\n\n        include_dirs.append(ERFA_SRC)\n\n        # liberfa configuration\n        config_h = os.path.join(LIBERFADIR, 'config.h')\n        if not os.path.exists(config_h):\n            print('Configure liberfa')\n            configure = os.path.join(LIBERFADIR, 'configure')\n            try:\n                if not os.path.exists(configure):\n                    subprocess.run(\n                        ['./bootstrap.sh'], check=True, cwd=LIBERFADIR)\n                subprocess.run(['./configure'], check=True, cwd=LIBERFADIR)\n            except (subprocess.SubprocessError, OSError) as exc:\n                warn(f'unable to configure liberfa: {exc}')\n\n        if not os.path.exists(config_h):\n            liberfa_versions = get_liberfa_versions()\n            if liberfa_versions:\n                print('Configure liberfa (\"configure.ac\" scan)')\n                lines = []\n                for name, value in liberfa_versions:\n                    # making sure strings are correctly quoted\n                    lines.append(f'#define {name} {value!r}'.replace(\"'\", '\"'))\n                with open(config_h, 'w') as fd:\n                    fd.write('\\n'.join(lines))\n            else:\n                warn('unable to get liberfa version')\n\n        if os.path.exists(config_h):\n            include_dirs.append(LIBERFADIR)\n            define_macros.append(('HAVE_CONFIG_H', '1'))\n        elif 'sdist' in sys.argv:\n            raise RuntimeError('missing \"configure\" script in \"liberfa/erfa\"')\n\n    if USE_PY_LIMITED_API:\n        define_macros.append((\"Py_LIMITED_API\", \"0x30900f0\"))\n\n    erfa_ext = NumpyExtension(\n        name=\"erfa.ufunc\",\n        sources=sources,\n        include_dirs=include_dirs,\n        libraries=libraries,\n        define_macros=define_macros,\n        py_limited_api=USE_PY_LIMITED_API,\n        language=\"c\")\n\n    return [erfa_ext]\n",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "sysconfig.get_config_var",
        "pathlib.Path",
        "pathlib.Path.exists",
        "pathlib.Path.resolve",
        "pathlib.Path",
        "pathlib.Path.exists",
        "pathlib.Path.stat",
        "pathlib.Path.stat",
        "open",
        "re.search",
        "packaging.version.parse",
        "re.search",
        "warn",
        "warn",
        "packaging.version.parse",
        "os.path.isfile",
        "os.path.isdir",
        "os.path.join",
        "newer",
        "newer",
        "os.path.isfile",
        "os.path.isdir",
        "os.path.join",
        "os.listdir",
        "os.path.join",
        "os.path.join",
        "os.path.exists",
        "os.path.join",
        "os.path.exists",
        "subprocess.run",
        "subprocess.run",
        "warn",
        "os.path.exists",
        "get_liberfa_versions",
        "open",
        "warn",
        "os.path.exists"
      ],
      "api_sequence_with_args": [
        "os.path.join('liberfa', 'erfa')",
        "os.path.join(LIBERFADIR, 'src')",
        "os.path.join('erfa', 'core.py')",
        "sysconfig.get_config_var(\"Py_GIL_DISABLED\")",
        "pathlib.Path(source)",
        "pathlib.Path(source).exists()",
        "pathlib.Path(source).resolve()",
        "pathlib.Path(target)",
        "pathlib.Path(target).exists()",
        "pathlib.Path(source).stat().st_mtime",
        "pathlib.Path(target).stat().st_mtime",
        "open(path)",
        "re.search(r'AC_INIT\\(\\[erfa\\],\\[(?P<version>[0-9.]+)\\]\\)', s)",
        "packaging.version.parse(mobj.group('version'))",
        "re.search(r'AC_DEFINE\\(\\[SOFA_VERSION\\], \\[\"(?P<version>\\d{8}(_\\w)?)\"\\],', s)",
        "warn('unable to detect liberfa version')",
        "warn('unable to detect SOFA version')",
        "packaging.version.parse(mobj.group('version'))",
        "os.path.isfile(fn) for fn in GEN_FILES",
        "os.path.isdir(ERFA_SRC)",
        "os.path.join(ERFA_SRC, 'erfaversion.c')",
        "newer(src, fn) for fn in GEN_FILES",
        "newer(src, fn) for fn in GEN_FILES",
        "os.path.isfile(fn) for fn in GEN_FILES",
        "os.path.isdir(ERFA_SRC)",
        "os.path.join(ERFA_SRC, fn)",
        "os.listdir(ERFA_SRC)",
        "os.path.join(LIBERFADIR, 'config.h')",
        "os.path.join(LIBERFADIR, 'configure')",
        "os.path.exists(config_h)",
        "os.path.join(LIBERFADIR, 'configure')",
        "os.path.exists(configure)",
        "subprocess.run(['./bootstrap.sh'], check=True, cwd=LIBERFADIR)",
        "subprocess.run(['./configure'], check=True, cwd=LIBERFADIR)",
        "warn(f'unable to configure liberfa: {exc}')",
        "os.path.exists(config_h)",
        "get_liberfa_versions()",
        "open(config_h, 'w')",
        "warn('unable to get liberfa version')",
        "os.path.exists(config_h)"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "sysconfig.get_config_var",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "pathlib.Path",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "pathlib.Path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "pathlib.Path.resolve",
          "id": "path_special_operations",
          "description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "pathlib.Path",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "pathlib.Path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "pathlib.Path.stat",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "pathlib.Path.stat",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "re.search",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "packaging.version.parse",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "re.search",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "warn",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "warn",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "packaging.version.parse",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "os.path.isfile",
          "id": "check_file_is_file",
          "description": "Checks if specified path exists and is a file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.path.isdir",
          "id": "check_directory_exists",
          "description": "Checks if specified path exists and is a directory",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "newer",
          "id": "get_exception_info",
          "description": "Retrieves exception information from current stack frame",
          "first_id": "data_transformation_processing",
          "second_id": "collection_operations",
          "third_id": "iterator_operations"
        },
        {
          "api_name": "newer",
          "id": "get_exception_info",
          "description": "Retrieves exception information from current stack frame",
          "first_id": "data_transformation_processing",
          "second_id": "collection_operations",
          "third_id": "iterator_operations"
        },
        {
          "api_name": "os.path.isfile",
          "id": "check_file_is_file",
          "description": "Checks if specified path exists and is a file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.path.isdir",
          "id": "check_directory_exists",
          "description": "Checks if specified path exists and is a directory",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "subprocess.run",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "subprocess.run",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "warn",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "get_liberfa_versions",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "warn",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        }
      ],
      "contextual_code": "import os\nimport re\nimport sys\nimport functools\nimport setuptools\nimport subprocess\nfrom warnings import warn\nimport packaging.version\nimport sysconfig\n\nLIBERFADIR = os.path.join('liberfa', 'erfa')\nERFA_SRC = os.path.join(LIBERFADIR, 'src')\nGEN_FILES = [\n    os.path.join('erfa', 'core.py'),\n    os.path.join('erfa', 'ufunc.c'),\n]\n\nUSE_PY_LIMITED_API = not sysconfig.get_config_var(\"Py_GIL_DISABLED\")\n\ndef newer(source, target):\n    import pathlib\n\n    source = pathlib.Path(source)\n    if not source.exists():\n        raise FileNotFoundError(f\"file '{source.resolve()}' does not exist\")\n\n    target = pathlib.Path(target)\n    if not target.exists():\n        return 1\n\n    return source.stat().st_mtime > target.stat().st_mtime\n\ndef get_liberfa_versions(path=os.path.join(LIBERFADIR, 'configure.ac')):\n    with open(path) as fd:\n        s = fd.read()\n\n    mobj = re.search(r'AC_INIT\\(\\[erfa\\],\\[(?P<version>[0-9.]+)\\]\\)', s)\n    if not mobj:\n        warn('unable to detect liberfa version')\n        return []\n\n    version = packaging.version.parse(mobj.group('version'))\n\n    mobj = re.search(\n        r'AC_DEFINE\\(\\[SOFA_VERSION\\], \\[\"(?P<version>\\d{8}(_\\w)?)\"\\],', s)\n    if not mobj:\n        warn('unable to detect SOFA version')\n        return []\n    sofa_version = mobj.group('version')\n\n    return [\n        ('PACKAGE_VERSION', version.base_version),\n        ('PACKAGE_VERSION_MAJOR', version.major),\n        ('PACKAGE_VERSION_MINOR', version.minor),\n        ('PACKAGE_VERSION_MICRO', version.micro),\n        ('SOFA_VERSION', sofa_version),\n    ]\n\ndef get_extensions():\n    gen_files_exist = all(os.path.isfile(fn) for fn in GEN_FILES)\n    gen_files_outdated = False\n    if os.path.isdir(ERFA_SRC):\n        src = os.path.join(ERFA_SRC, 'erfaversion.c')\n        gen_files_outdated = any(newer(src, fn) for fn in GEN_FILES)\n    elif not gen_files_exist:\n        raise RuntimeError(\n            'Missing \"liberfa\" source files, unable to generate '\n            '\"erfa/ufunc.c\" and \"erfa/core.py\". '\n            'Please check your source tree. '\n            'Maybe \"git submodule update\" could help.')\n\n    if not gen_files_exist or gen_files_outdated:\n        print('Run \"erfa_generator.py\"')\n        cmd = [sys.executable, 'erfa_generator.py', ERFA_SRC, '--quiet']\n        subprocess.run(cmd, check=True)\n\n    sources = [os.path.join('erfa', 'ufunc.c')]\n    include_dirs = []\n    libraries = []\n    define_macros = []\n\n    if int(os.environ.get('PYERFA_USE_SYSTEM_LIBERFA', 0)):\n        print('Using system liberfa')\n        libraries.append('erfa')\n    else:\n        erfafns = os.listdir(ERFA_SRC)\n        sources.extend([os.path.join(ERFA_SRC, fn)\n                        for fn in erfafns\n                        if fn.endswith('.c') and not fn.startswith('t_')])\n\n        include_dirs.append(ERFA_SRC)\n\n        config_h = os.path.join(LIBERFADIR, 'config.h')\n        if not os.path.exists(config_h):\n            print('Configure liberfa')\n            configure = os.path.join(LIBERFADIR, 'configure')\n            try:\n                if not os.path.exists(configure):\n                    subprocess.run(\n                        ['./bootstrap.sh'], check=True, cwd=LIBERFADIR)\n                subprocess.run(['./configure'], check=True, cwd=LIBERFADIR)\n            except (subprocess.SubprocessError, OSError) as exc:\n                warn(f'unable to configure liberfa: {exc}')\n\n        if not os.path.exists(config_h):\n            liberfa_versions = get_liberfa_versions()\n            if liberfa_versions:\n                print('Configure liberfa (\"configure.ac\" scan)')\n                lines = []\n                for name, value in liberfa_versions:\n                    lines.append(f'#define {name} {value!r}'.replace(\"'\", '\"'))\n                with open(config_h, 'w') as fd:\n                    fd.write('\\n'.join(lines))\n            else:\n                warn('unable to get liberfa version')\n\n        if os.path.exists(config_h):\n            include_dirs.append(LIBERFADIR)\n            define_macros.append(('HAVE_CONFIG_H', '1'))\n        elif 'sdist' in sys.argv:\n            raise RuntimeError('missing \"configure\" script in \"liberfa/erfa\"')\n\n    if USE_PY_LIMITED_API:\n        define_macros.append((\"Py_LIMITED_API\", \"0x30900f0\"))\n\n    erfa_ext = NumpyExtension(\n        name=\"erfa.ufunc\",\n        sources=sources,\n        include_dirs=include_dirs,\n        libraries=libraries,\n        define_macros=define_macros,\n        py_limited_api=USE_PY_LIMITED_API,\n        language=\"c\")\n\n    return [erfa_ext]"
    }
  },
  {
    "metadata": {
      "package_name": "pyerfa-2.0.1.5",
      "total_matches": 3
    }
  }
]