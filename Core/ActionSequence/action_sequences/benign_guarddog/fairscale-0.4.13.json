[
  {
    "pyfile": "setup.py",
    "code_snippet": "import os\nimport re\n\ndef find_version(version_file_path) -> str:\n    with open(version_file_path) as version_file:\n        version_match = re.search(r\"^__version_tuple__ = (.*)\", version_file.read(), re.M)\n        if version_match:\n            ver_tup = eval(version_match.group(1))\n            ver_str = \".\".join([str(x) for x in ver_tup])\n            return ver_str\n        raise RuntimeError(\"Unable to find version tuple.\")",
    "pattern_analysis": {
      "api_sequence": [
        "open",
        "re.search",
        "version_file.read",
        "eval",
        "str",
        "str",
        "RuntimeError"
      ],
      "api_sequence_with_args": [
        "open(version_file_path)",
        "re.search(r\"^__version_tuple__ = (.*)\", version_file.read(), re.M)",
        "version_file.read()",
        "eval(version_match.group(1))",
        "str(x)",
        "str(x)",
        "RuntimeError(\"Unable to find version tuple.\")"
      ],
      "mapped_sequence": [
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "re.search",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "version_file.read",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "eval",
          "id": "eval_python_expr",
          "description": "Evaluates string as Python expression",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "str",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "str",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "RuntimeError",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        }
      ],
      "contextual_code": "def find_version(version_file_path) -> str:\n    with open(version_file_path) as version_file:\n        version_match = re.search(r\"^__version_tuple__ = (.*)\", version_file.read(), re.M)\n        if version_match:\n            ver_tup = eval(version_match.group(1))\n            ver_str = \".\".join([str(x) for x in ver_tup])\n            return ver_str\n        raise RuntimeError(\"Unable to find version tuple.\")"
    }
  },
  {
    "metadata": {
      "package_name": "fairscale-0.4.13",
      "total_matches": 1
    }
  }
]