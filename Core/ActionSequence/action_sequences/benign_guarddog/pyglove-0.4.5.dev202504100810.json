[
  {
    "pyfile": "annotation_conversion.py",
    "code_snippet": "import builtins\nimport collections\nimport inspect\nimport types\nimport typing\n\nfrom pyglove.core import coding\nfrom pyglove.core import utils\nfrom pyglove.core.typing import annotated\nfrom pyglove.core.typing import class_schema\nfrom pyglove.core.typing import inspect as pg_inspect\nfrom pyglove.core.typing import key_specs as ks\nfrom pyglove.core.typing import value_specs as vs\n\n_NoneType = type(None)\n\n# Annotated is suppored after 3.9\n_Annotated = getattr(typing, 'Annotated', None)  # pylint: disable=invalid-name\n\n# UnionType is supported after 3.10.\n_UnionType = getattr(types, 'UnionType', None)  # pylint: disable=invalid-name\n\n\ndef annotation_from_str(\n    annotation_str: str,\n    parent_module: typing.Optional[types.ModuleType] = None,\n    ) -> typing.Any:\n  \"\"\"Parses annotations from str.\n\n  BNF for PyType annotations:\n\n  ```\n  <maybe_union>      ::= <type> | <type> \"|\" <maybe_union>\n  <type>             ::= <literal_type> | <non_literal_type>\n\n  <literal_type>     ::= \"Literal\"<literal_params>\n  <literal_params>   ::= \"[\"<python_values>\"]\" (parsed by `pg.coding.evaluate`)\n\n  <non_literal_type> ::= <type_id> | <type_id>\"[\"<type_arg>\"]\"\n  <type_arg>       ::= <maybe_type_list> | <maybe_type_list>\",\"<maybe_type_list>\n  <maybe_type_list>  ::= \"[\"<type_arg>\"]\" | <maybe_union>\n  <type_id>          ::= 'aAz_.1-9'\n  ```\n\n  Args:\n    annotation_str: String form of type annotations. E.g. \"list[str]\"\n    parent_module: The module where the annotation was defined.\n\n  Returns:\n    Object form of the annotation.\n\n  Raises:\n    SyntaxError: If the annotation string is invalid.\n  \"\"\"\n  s = annotation_str\n  context = dict(pos=0)\n\n  def _eof() -> bool:\n    return context['pos'] == len(s)\n\n  def _pos() -> int:\n    return context['pos']\n\n  def _next(n: int = 1, offset: int = 0) -> str:\n    if _eof():\n      return '<EOF>'\n    return s[_pos() + offset:_pos() + offset + n]\n\n  def _advance(n: int) -> None:\n    context['pos'] += n\n\n  def _error_illustration() -> str:\n    return f'{s}\\n{\" \" * _pos()}' + '^'\n\n  def _match(ch) -> bool:\n    if _next(len(ch)) == ch:\n      _advance(len(ch))\n      return True\n    return False\n\n  def _skip_whitespaces() -> None:\n    while _next() in ' \\t':\n      _advance(1)\n\n  def _maybe_union():\n    t = _type()\n    while not _eof():\n      _skip_whitespaces()\n      if _match('|'):\n        t = t | _type()\n      else:\n        break\n    return t\n\n  def _type():\n    type_id = _type_id()\n    t = _resolve(type_id)\n    if t is typing.Literal:\n      return t[_literal_params()]\n    elif _match('['):\n      arg = _type_arg()\n      if not _match(']'):\n        raise SyntaxError(\n            f'Expected \"]\" at position {_pos()}.\\n\\n' + _error_illustration()\n        )\n      return t[arg]\n    return t\n\n  def _literal_params():\n    if not _match('['):\n      raise SyntaxError(\n          f'Expected \"[\" at position {_pos()}.\\n\\n' + _error_illustration()\n      )\n    arg_start = _pos()\n    in_str = False\n    escape_mode = False\n    num_open_bracket = 1\n\n    while num_open_bracket > 0:\n      ch = _next()\n      if _eof():\n        raise SyntaxError(\n            f'Unexpected end of annotation at position {_pos()}.\\n\\n'\n            + _error_illustration()\n        )\n      if ch == '\\\\':\n        escape_mode = not escape_mode\n      else:\n        escape_mode = False\n\n      if ch == \"'\" and not escape_mode:\n        in_str = not in_str\n      elif not in_str:\n        if ch == '[':\n          num_open_bracket += 1\n        elif ch == ']':\n          num_open_bracket -= 1\n      _advance(1)\n\n    arg_str = s[arg_start:_pos() - 1]\n    return coding.evaluate(\n        '(' + arg_str + ')', permission=coding.CodePermission.BASIC\n    )\n\n  def _type_arg():\n    t_args = []\n    t_args.append(_maybe_type_list())\n    while _match(','):\n      t_args.append(_maybe_type_list())\n    return tuple(t_args) if len(t_args) > 1 else t_args[0]\n\n  def _maybe_type_list():\n    if _match('['):\n      ret = _type_arg()\n      if not _match(']'):\n        raise SyntaxError(\n            f'Expected \"]\" at position {_pos()}.\\n\\n' + _error_illustration()\n        )\n      return list(ret) if isinstance(ret, tuple) else [ret]\n    return _maybe_union()\n\n  def _type_id() -> str:\n    _skip_whitespaces()\n    if _match('...'):\n      return '...'\n    start = _pos()\n    while not _eof():\n      c = _next()\n      if c.isalnum() or c in '_.':\n        _advance(1)\n      else:\n        break\n    t_id = s[start:_pos()]\n    if not all(x.isidentifier() for x in t_id.split('.')):\n      raise SyntaxError(\n          f'Expected type identifier, got {t_id!r} at position {start}.\\n\\n'\n          + _error_illustration()\n      )\n    return t_id\n\n  def _resolve(type_id: str):\n\n    def _as_forward_ref() -> typing.ForwardRef:\n      return typing.ForwardRef(type_id, False, parent_module)  # pytype: disable=not-callable\n\n    def _resolve_name(name: str, parent_obj: typing.Any):\n      if name == 'None':\n        return None, True\n      if parent_obj is not None and hasattr(parent_obj, name):\n        return getattr(parent_obj, name), False\n      if hasattr(builtins, name):\n        return getattr(builtins, name), True\n      if type_id == '...':\n        return ..., True\n      return utils.MISSING_VALUE, False\n\n    names = type_id.split('.')\n    if len(names) == 1:\n      reference, is_builtin = _resolve_name(names[0], parent_module)\n      if is_builtin:\n        return reference\n      if not is_builtin and (\n          # When reference is not found, we should treat it as a forward\n          # reference.\n          reference == utils.MISSING_VALUE\n          # When module is being reloaded, we should treat all non-builtin\n          # references as forward references.\n          or getattr(parent_module, '__reloading__', False)\n      ):\n        return _as_forward_ref()\n      return reference\n\n    root_obj, _ = _resolve_name(names[0], parent_module)\n    # When root object is not found, we should treat it as a forward reference.\n    if root_obj == utils.MISSING_VALUE:\n      return _as_forward_ref()\n\n    parent_obj = root_obj\n    # When root object is a module, we should treat reference to its children\n    # as non-forward references.\n    if inspect.ismodule(root_obj):\n      for name in names[1:]:\n        parent_obj, _ = _resolve_name(name, parent_obj)\n        if parent_obj == utils.MISSING_VALUE:\n          raise TypeError(f'{type_id!r} does not exist.')\n      return parent_obj\n    # When root object is non-module variable of current module, and when the\n    # module is being reloaded, we should treat reference to its children as\n    # forward references.\n    elif getattr(parent_module, '__reloading__', False):\n      return _as_forward_ref()\n    # When root object is non-module variable of current module, we should treat\n    # unresolved reference to its children as forward references.\n    else:\n      for name in names[1:]:\n        parent_obj, _ = _resolve_name(name, parent_obj)\n        if parent_obj == utils.MISSING_VALUE:\n          return _as_forward_ref()\n      return parent_obj\n\n  root = _maybe_union()\n  if _pos() != len(s):\n    raise SyntaxError(\n        'Unexpected end of annotation.\\n\\n' + _error_illustration()\n    )\n  return root\n",
    "pattern_analysis": {
      "api_sequence": [],
      "api_sequence_with_args": [],
      "mapped_sequence": [],
      "contextual_code": ""
    }
  },
  {
    "metadata": {
      "package_name": "pyglove-0.4.5.dev202504100810",
      "total_matches": 1
    }
  }
]