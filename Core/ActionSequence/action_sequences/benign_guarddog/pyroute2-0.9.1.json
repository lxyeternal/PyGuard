[
  {
    "pyfile": "__init__.py",
    "code_snippet": "import builtins\nimport json\nimport struct\n\nfrom pyroute2.netlink import nlmsg\nfrom pyroute2.netlink.nlsocket import Marshal\n\nTversion = 100\nRversion = 101\nTauth = 102\nRauth = 103\nTattach = 104\nRattach = 105\nTerror = 106  # illegal\nRerror = 107\nTflush = 108\nRflush = 109\nTwalk = 110\nRwalk = 111\nTopen = 112\nRopen = 113\nTcreate = 114\nRcreate = 115\nTread = 116\nRread = 117\nTwrite = 118\nRwrite = 119\nTclunk = 120\nRclunk = 121\nTremove = 122\nRremove = 123\nTstat = 124\nRstat = 125\nTwstat = 126\nRwstat = 127\nTopenfd = 98\nRopenfd = 99\n\n# 9P2000.pr2 extensions\nTcall = 80\nRcall = 81\n\nclass Plan9Exit(Exception):\n    pass\n\nclass Marshal9P(Marshal):\n    default_message_class = msg_rerror\n\n    msg_map = {\n        Tversion: msg_tversion,\n        Rversion: msg_rversion,\n        Tauth: msg_tauth,\n        Rauth: msg_rauth,\n        Tattach: msg_tattach,\n        Rattach: msg_rattach,\n        Rerror: msg_rerror,\n        Twalk: msg_twalk,\n        Rwalk: msg_rwalk,\n        Topen: msg_topen,\n        Ropen: msg_ropen,\n        Tread: msg_tread,\n        Rread: msg_rread,\n        Tclunk: msg_tclunk,\n        Rclunk: msg_rclunk,\n        Tstat: msg_tstat,\n        Rstat: msg_rstat,\n        Twstat: msg_twstat,\n        Rwstat: msg_rwstat,\n        Twrite: msg_twrite,\n        Rwrite: msg_rwrite,\n        Tcall: msg_tcall,\n        Rcall: msg_rcall,\n        Tcreate: msg_base,\n        Rcreate: msg_base,\n        Tremove: msg_base,\n        Rremove: msg_base,\n    }\n\n    def parse(self, data, seq=None, callback=None, skip_alien_seq=False):\n        offset = 0\n        while offset <= len(data) - 5:\n            (length, key, tag) = struct.unpack_from('=IBH', data, offset)\n            if skip_alien_seq and tag != seq:\n                continue\n            if not 0 < length <= len(data):\n                break\n            parser = self.get_parser(key, 0, tag)\n            msg = parser(data, offset, length)\n            if key == Rerror:\n                spec = json.loads(msg['ename'])\n                if spec['class'] in dir(builtins):\n                    cls = getattr(builtins, spec['class'])\n                elif spec['class'] == 'Plan9Exit':\n                    cls = Plan9Exit\n                else:\n                    cls = Exception\n                if not spec.get('argv'):\n                    spec['argv'] = [spec['str']]\n                raise cls(*spec['argv'])\n            offset += length\n            if msg is None:\n                continue\n            yield msg",
    "pattern_analysis": {
      "api_sequence": [
        "struct.unpack_from",
        "json.loads",
        "builtins.dir",
        "builtins.getattr",
        "builtins.Exception",
        "builtins.Plan9Exit",
        "builtins.Exception",
        "builtins.raise"
      ],
      "api_sequence_with_args": [
        "struct.unpack_from('=IBH', data, offset)",
        "json.loads(msg['ename'])",
        "builtins.dir(builtins)",
        "builtins.getattr(builtins, spec['class'])",
        "builtins.Exception",
        "builtins.Plan9Exit",
        "builtins.Exception",
        "raise cls(*spec['argv'])"
      ],
      "mapped_sequence": [
        {
          "api_name": "struct.unpack_from",
          "id": "pack_values",
          "description": "Packs values into bytes using specified format",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "builtins.dir",
          "id": "get_global_symbols",
          "description": "Retrieves global symbol table as dictionary",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "builtins.getattr",
          "id": "get_global_symbols",
          "description": "Retrieves global symbol table as dictionary",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "builtins.Exception",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "builtins.Plan9Exit",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "builtins.Exception",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "raise",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        }
      ],
      "contextual_code": "def parse(self, data, seq=None, callback=None, skip_alien_seq=False):\n    offset = 0\n    while offset <= len(data) - 5:\n        (length, key, tag) = struct.unpack_from('=IBH', data, offset)\n        if skip_alien_seq and tag != seq:\n            continue\n        if not 0 < length <= len(data):\n            break\n        parser = self.get_parser(key, 0, tag)\n        msg = parser(data, offset, length)\n        if key == Rerror:\n            spec = json.loads(msg['ename'])\n            if spec['class'] in dir(builtins):\n                cls = getattr(builtins, spec['class'])\n            elif spec['class'] == 'Plan9Exit':\n                cls = Plan9Exit\n            else:\n                cls = Exception\n            if not spec.get('argv'):\n                spec['argv'] = [spec['str']]\n            raise cls(*spec['argv'])\n        offset += length\n        if msg is None:\n            continue\n        yield msg"
    }
  },
  {
    "pyfile": "process.py",
    "code_snippet": "import builtins\nimport gc\nimport json\nimport logging\nimport multiprocessing\nimport os\nimport select\nimport signal\nimport socket\nimport struct\nfrom collections import namedtuple\nfrom typing import Any, Callable, Optional, Union\n\nfrom pyroute2 import config\nfrom pyroute2.common import USE_DEFAULT_TIMEOUT\nfrom pyroute2.netlink import exceptions as pyroute2_exceptions\n\nlog = logging.getLogger(__name__)\n\nChildProcessReturnValue = namedtuple(\n    'ChildProcessReturnValue', ('payload', 'fds')\n)\nChildFuncReturnType = Union[None, ChildProcessReturnValue, bytearray, bytes]\n\nclass ChildProcess:\n    ctrl_r: socket.socket\n    ctrl_w: socket.socket\n\n    def __init__(\n        self, target: Callable[..., ChildFuncReturnType], args: list[Any]\n    ):\n        self._mode: str = config.child_process_mode\n        self._target: Callable[..., ChildFuncReturnType] = target\n        self._args: list[Any] = args\n        self._proc: Optional[multiprocessing.Process] = None\n        self._running: bool = False\n        self._exitcode: Optional[int] = None\n        self._pid: Optional[int] = None\n\n    def close(self):\n        self.stop()\n\n    def __enter__(self):\n        self.run()\n        return self\n\n    def __exit__(self, *_):\n        self.close()\n\n    @property\n    def mode(self):\n        return self._mode\n\n    @property\n    def pid(self):\n        return self._pid\n\n    def communicate(\n        self, timeout: int = USE_DEFAULT_TIMEOUT\n    ) -> tuple[bytes, list[int]]:\n        '''Communicate with the child process.\n\n        Raises:\n\n        * struct.error -- error unpacking response from the child process\n        * OSError -- OS level error communicating with the child process\n        * TimeoutError -- the child process is alive, but doesn't response\n        * RuntimeError -- the child process is dead or not started\n        * TypeError -- error loading propagated exception\n        '''\n        if not self._running:\n            raise RuntimeError('child process not started yet')\n        if timeout == USE_DEFAULT_TIMEOUT:\n            timeout = config.default_communicate_timeout\n        rl, _, _ = select.select([self.ctrl_r], [], [], timeout)\n        if not len(rl):\n            # no data received within timeout\n            # 1. the child process is killed\n            # 2. the child process is stuck\n            #\n            # So first check the process, if it is killed, raise\n            # RuntimeError, otherwise raise TimeoutError.\n            #\n            c_pid, w_status = os.waitpid(self.pid, os.WNOHANG)\n            if c_pid != 0:\n                # process is dead\n                self._exitcode = os.waitstatus_to_exitcode(w_status)\n                raise RuntimeError(\n                    f'child process is dead, status: {self.exitcode}'\n                )\n            # process is alive, but stuck, kill it\n            self.stop(kill=True, reason='no response from the child')\n            raise TimeoutError(f'no response from the child pid {self.pid}')\n\n        ret_data = b''\n        # raises OSError\n        (raw_data, fds, _, _) = socket.recv_fds(self.ctrl_r, 1024, 1)\n        # get the return type\n        # raises struct.error\n        (ret_type,) = struct.unpack('B', raw_data[:1])\n        raw_data = raw_data[1:]\n        if ret_type == 1:\n            # exception\n            payload = json.loads(raw_data.decode('utf-8'))\n            if not set(payload.keys()) == set(('exception', 'options')):\n                raise TypeError('error loading child exception')\n            if payload.get('exception') is not None:\n                error_class = getattr(builtins, payload['exception'], None)\n                if error_class is None:\n                    error_class = getattr(\n                        pyroute2_exceptions, payload['exception'], None\n                    )\n                if error_class is None:\n                    error_class = Exception\n                if not issubclass(error_class, Exception):\n                    raise TypeError('error loading child error')\n                raise error_class(*payload['options'])\n        elif ret_type == 2:\n            # raw_data\n            ret_data = raw_data\n        return ret_data, fds\n\n    def get_data(self, timeout: int = USE_DEFAULT_TIMEOUT) -> bytes:\n        return self.communicate(timeout)[0]\n\n    def get_fds(self, timeout: int = USE_DEFAULT_TIMEOUT) -> list[int]:\n        return self.communicate(timeout)[1]\n\n    @property\n    def proc(self) -> multiprocessing.Process:\n        if self._proc is None:\n            raise RuntimeError('not started')\n        return self._proc\n\n    @proc.setter\n    def proc(self, value: Optional[multiprocessing.Process]) -> None:\n        self._proc = value\n\n    def _unsupported(self) -> Exception:\n        return TypeError('unsupported mode')\n\n    def run(self) -> None:\n        if self._running:\n            return\n        self._running = True\n        self.ctrl_r, self.ctrl_w = socket.socketpair(\n            socket.AF_UNIX, socket.SOCK_DGRAM\n        )\n        if self.mode == 'fork':\n            self._pid = os.fork()\n            if self._pid == 0:\n                wrapper(self.ctrl_w, self._target, self._args)\n                os._exit(0)\n        elif self.mode == 'mp':\n            self.proc = multiprocessing.Process(\n                target=wrapper, args=[self.ctrl_w, self._target, self._args]\n            )\n            self.proc.start()\n            self._pid = self.proc.pid\n        else:\n            raise self._unsupported()\n\n    def stop(self, kill: bool = False, reason: Optional[str] = None) -> None:\n        if not self._running:\n            return\n        self._running = False\n        self.ctrl_r.close()\n        self.ctrl_w.close()\n        if config.force_gc:\n            gc.collect()\n        if self.mode == 'fork':\n            try:\n                if kill:\n                    os.kill(self.pid, signal.SIGKILL)\n                else:\n                    os.kill(self.pid, signal.SIGTERM)\n                _, status = os.waitpid(self.pid, 0)\n                self._exitcode = os.waitstatus_to_exitcode(status)\n            except ProcessLookupError:\n                # the child process has already exited\n                pass\n        elif self.mode == 'mp':\n            if kill:\n                self.proc.kill()\n            else:\n                self.proc.terminate()\n            self.proc.join()\n        else:\n            raise self._unsupported()\n        if reason is not None:\n            log.warning(reason)\n\n    @property\n    def exitcode(self) -> Optional[int]:\n        if self.mode == 'fork':\n            return self._exitcode\n        elif self.mode == 'mp':\n            return self.proc.exitcode\n        else:\n            raise self._unsupported()\n",
    "pattern_analysis": {
      "api_sequence": [
        "select.select",
        "os.waitpid",
        "os.waitstatus_to_exitcode",
        "self.stop",
        "socket.recv_fds",
        "struct.unpack",
        "json.loads",
        "builtins.getattr",
        "pyroute2.netlink.exceptions.getattr",
        "issubclass",
        "raise",
        "socket.socketpair",
        "os.fork",
        "os._exit",
        "multiprocessing.Process",
        "multiprocessing.Process.start",
        "multiprocessing.Process.pid",
        "self.stop",
        "socket.socket.close",
        "socket.socket.close",
        "gc.collect",
        "os.kill",
        "os.waitpid",
        "os.waitstatus_to_exitcode",
        "multiprocessing.Process.kill",
        "multiprocessing.Process.terminate",
        "multiprocessing.Process.join",
        "logging.Logger.warning"
      ],
      "api_sequence_with_args": [
        "select.select([self.ctrl_r], [], [], timeout)",
        "os.waitpid(self.pid, os.WNOHANG)",
        "os.waitstatus_to_exitcode(w_status)",
        "self.stop(kill=True, reason='no response from the child')",
        "socket.recv_fds(self.ctrl_r, 1024, 1)",
        "struct.unpack('B', raw_data[:1])",
        "json.loads(raw_data.decode('utf-8'))",
        "builtins.getattr(builtins, payload['exception'], None)",
        "pyroute2.netlink.exceptions.getattr(pyroute2_exceptions, payload['exception'], None)",
        "issubclass(error_class, Exception)",
        "raise error_class(*payload['options'])",
        "socket.socketpair(socket.AF_UNIX, socket.SOCK_DGRAM)",
        "os.fork()",
        "os._exit(0)",
        "multiprocessing.Process(target=wrapper, args=[self.ctrl_w, self._target, self._args])",
        "multiprocessing.Process.start()",
        "multiprocessing.Process.pid",
        "self.stop(kill=kill, reason=reason)",
        "socket.socket.close()  # self.ctrl_r.close()",
        "socket.socket.close()  # self.ctrl_w.close()",
        "gc.collect()",
        "os.kill(self.pid, signal.SIGKILL or signal.SIGTERM)",
        "os.waitpid(self.pid, 0)",
        "os.waitstatus_to_exitcode(status)",
        "multiprocessing.Process.kill()",
        "multiprocessing.Process.terminate()",
        "multiprocessing.Process.join()",
        "logging.Logger.warning(reason)"
      ],
      "mapped_sequence": [
        {
          "api_name": "select.select",
          "id": "receive_socket_data",
          "description": "Receives data from socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "os.waitpid",
          "id": "wait_process_completion",
          "description": "Waits for process to complete execution",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "os.waitstatus_to_exitcode",
          "id": "check_process_terminated",
          "description": "Checks if process has terminated",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "self.stop",
          "id": "terminate_process",
          "description": "Terminates the process",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "socket.recv_fds",
          "id": "receive_socket_data",
          "description": "Receives data from socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "struct.unpack",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "builtins.getattr",
          "id": "get_global_symbols",
          "description": "Retrieves global symbol table as dictionary",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "pyroute2.netlink.exceptions.getattr",
          "id": "get_global_symbols",
          "description": "Retrieves global symbol table as dictionary",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "issubclass",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "raise",
          "id": "raise_hard_error",
          "description": "Raises a hard error in Windows",
          "first_id": "system_operations",
          "second_id": "window_management",
          "third_id": "window_control"
        },
        {
          "api_name": "socket.socketpair",
          "id": "create_socket",
          "description": "Creates new socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_creation"
        },
        {
          "api_name": "os.fork",
          "id": "create_child_process",
          "description": "Creates child process by duplicating current process",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "os._exit",
          "id": "exit_program",
          "description": "Exits program with specified status code",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "multiprocessing.Process",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "multiprocessing.Process.start",
          "id": "start_thread",
          "description": "Starts thread execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "multiprocessing.Process.pid",
          "id": "get_process_info",
          "description": "Retrieves process information as dictionary",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "self.stop",
          "id": "terminate_process",
          "description": "Terminates the process",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "socket.socket.close",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "socket.socket.close",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "gc.collect",
          "id": "free_local_memory",
          "description": "Frees memory allocated by LocalAlloc",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "os.kill",
          "id": "terminate_process",
          "description": "Terminates the process",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "os.waitpid",
          "id": "wait_process_completion",
          "description": "Waits for process to complete execution",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "os.waitstatus_to_exitcode",
          "id": "check_process_terminated",
          "description": "Checks if process has terminated",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "multiprocessing.Process.kill",
          "id": "terminate_process",
          "description": "Terminates the process",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "multiprocessing.Process.terminate",
          "id": "terminate_process",
          "description": "Terminates the process",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "multiprocessing.Process.join",
          "id": "wait_thread",
          "description": "Waits for thread to finish execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "logging.Logger.warning",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        }
      ],
      "contextual_code": "def communicate(self, timeout: int = USE_DEFAULT_TIMEOUT) -> tuple[bytes, list[int]]:\n    if not self._running:\n        raise RuntimeError('child process not started yet')\n    if timeout == USE_DEFAULT_TIMEOUT:\n        timeout = config.default_communicate_timeout\n    rl, _, _ = select.select([self.ctrl_r], [], [], timeout)\n    if not len(rl):\n        c_pid, w_status = os.waitpid(self.pid, os.WNOHANG)\n        if c_pid != 0:\n            self._exitcode = os.waitstatus_to_exitcode(w_status)\n            raise RuntimeError(f'child process is dead, status: {self.exitcode}')\n        self.stop(kill=True, reason='no response from the child')\n        raise TimeoutError(f'no response from the child pid {self.pid}')\n    ret_data = b''\n    (raw_data, fds, _, _) = socket.recv_fds(self.ctrl_r, 1024, 1)\n    (ret_type,) = struct.unpack('B', raw_data[:1])\n    raw_data = raw_data[1:]\n    if ret_type == 1:\n        payload = json.loads(raw_data.decode('utf-8'))\n        if not set(payload.keys()) == set(('exception', 'options')):\n            raise TypeError('error loading child exception')\n        if payload.get('exception') is not None:\n            error_class = getattr(builtins, payload['exception'], None)\n            if error_class is None:\n                error_class = getattr(pyroute2_exceptions, payload['exception'], None)\n            if error_class is None:\n                error_class = Exception\n            if not issubclass(error_class, Exception):\n                raise TypeError('error loading child error')\n            raise error_class(*payload['options'])\n    elif ret_type == 2:\n        ret_data = raw_data\n    return ret_data, fds\n\ndef run(self) -> None:\n    if self._running:\n        return\n    self._running = True\n    self.ctrl_r, self.ctrl_w = socket.socketpair(socket.AF_UNIX, socket.SOCK_DGRAM)\n    if self.mode == 'fork':\n        self._pid = os.fork()\n        if self._pid == 0:\n            wrapper(self.ctrl_w, self._target, self._args)\n            os._exit(0)\n    elif self.mode == 'mp':\n        self.proc = multiprocessing.Process(target=wrapper, args=[self.ctrl_w, self._target, self._args])\n        self.proc.start()\n        self._pid = self.proc.pid\n    else:\n        raise self._unsupported()\n\ndef stop(self, kill: bool = False, reason: Optional[str] = None) -> None:\n    if not self._running:\n        return\n    self._running = False\n    self.ctrl_r.close()\n    self.ctrl_w.close()\n    if config.force_gc:\n        gc.collect()\n    if self.mode == 'fork':\n        try:\n            if kill:\n                os.kill(self.pid, signal.SIGKILL)\n            else:\n                os.kill(self.pid, signal.SIGTERM)\n            _, status = os.waitpid(self.pid, 0)\n            self._exitcode = os.waitstatus_to_exitcode(status)\n        except ProcessLookupError:\n            pass\n    elif self.mode == 'mp':\n        if kill:\n            self.proc.kill()\n        else:\n            self.proc.terminate()\n        self.proc.join()\n    else:\n        raise self._unsupported()\n    if reason is not None:\n        log.warning(reason)"
    }
  },
  {
    "metadata": {
      "package_name": "pyroute2-0.9.1",
      "total_matches": 2
    }
  }
]