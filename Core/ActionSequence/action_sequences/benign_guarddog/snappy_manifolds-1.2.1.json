[
  {
    "pyfile": "setup.py",
    "code_snippet": "import re, sys, subprocess, os, shutil, glob, sysconfig\nfrom setuptools import setup, Command\nfrom setuptools.command.build_py import build_py\n\nsqlite_files = ['manifolds.sqlite',\n                'more_manifolds.sqlite',\n                'platonic_manifolds.sqlite']\n\ndef check_call(args):\n    try:\n        subprocess.check_call(args)\n    except subprocess.CalledProcessError:\n        executable = args[0]\n        command = [a for a in args if not a.startswith('-')][-1]\n        raise RuntimeError(command + ' failed for ' + executable)\n\nclass BuildPy(build_py):\n    \"\"\"\n    Rebuilds the sqlite database files if needed.\n    \"\"\"\n    def initialize_options(self):\n        build_py.initialize_options(self)\n        os.chdir('manifold_src')        \n        csv_source_files = glob.glob(\n            os.path.join('original_manifold_sources', '*.csv'))\n        # When there are no csv files, we are in an sdist tarball\n        if len(csv_source_files) != 0:\n            if self.force:\n                for file in glob.glob('*.sqlite'):\n                    os.remove(file)\n            print('Rebuilding stale sqlite databases from csv sources...')\n            check_call([sys.executable, 'make_sqlite_db.py'])\n        os.chdir('..')\n\nclass Release(Command):\n    user_options = [('install', 'i', 'install the release into each Python')]\n    def initialize_options(self):\n        self.install = False\n    def finalize_options(self):\n        pass\n    def run(self):\n        pythons = os.environ.get('RELEASE_PYTHONS', sys.executable).split(',')\n        check_call([pythons[0], 'setup.py', 'clean'])\n        check_call([pythons[0], 'setup.py', 'bdist_wheel', '--universal'])\n        check_call([pythons[0], 'setup.py', 'sdist'])\n        if self.install:\n            for python in pythons:\n                check_call([python, 'setup.py', 'pip_install', '--no-build-wheel'])\n\nclass PipInstall(Command):\n    user_options = [('no-build-wheel', 'n', 'assume wheel has already been built')]\n    def initialize_options(self):\n        self.no_build_wheel = False\n    def finalize_options(self):\n        pass\n    def run(self): \n        python = sys.executable\n        check_call([python, 'setup.py', 'build'])\n        if not self.no_build_wheel:\n            check_call([python, 'setup.py', 'bdist_wheel', '--universal'])\n        egginfo = 'snappy_manifolds.egg-info'\n        if os.path.exists(egginfo):\n            shutil.rmtree(egginfo)\n        wheels = glob.glob('dist' + os.sep + '*.whl')\n        new_wheel = max(wheels, key=os.path.getmtime)            \n        check_call([python, '-m', 'pip', 'install', '--upgrade',\n                    '--upgrade-strategy', 'only-if-needed',\n                    '--force-reinstall', new_wheel])\n",
    "pattern_analysis": {
      "api_sequence": [
        "os.chdir",
        "os.path.join",
        "glob.glob",
        "glob.glob",
        "os.remove",
        "print",
        "check_call",
        "os.chdir",
        "os.environ.get",
        "check_call",
        "check_call",
        "check_call",
        "check_call",
        "os.path.exists",
        "shutil.rmtree",
        "glob.glob",
        "os.path.getmtime",
        "max",
        "check_call"
      ],
      "api_sequence_with_args": [
        "os.chdir('manifold_src')",
        "os.path.join('original_manifold_sources', '*.csv')",
        "glob.glob(os.path.join('original_manifold_sources', '*.csv'))",
        "glob.glob('*.sqlite')",
        "os.remove(file)",
        "print('Rebuilding stale sqlite databases from csv sources...')",
        "check_call([sys.executable, 'make_sqlite_db.py'])",
        "os.chdir('..')",
        "os.environ.get('RELEASE_PYTHONS', sys.executable)",
        "check_call([pythons[0], 'setup.py', 'clean'])",
        "check_call([pythons[0], 'setup.py', 'bdist_wheel', '--universal'])",
        "check_call([pythons[0], 'setup.py', 'sdist'])",
        "check_call([python, 'setup.py', 'pip_install', '--no-build-wheel'])",
        "os.path.exists(egginfo)",
        "shutil.rmtree(egginfo)",
        "glob.glob('dist' + os.sep + '*.whl')",
        "os.path.getmtime",
        "max(wheels, key=os.path.getmtime)",
        "check_call([python, '-m', 'pip', 'install', '--upgrade', '--upgrade-strategy', 'only-if-needed', '--force-reinstall', new_wheel])"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.chdir",
          "id": "change_working_dir",
          "description": "Changes current working directory",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "glob.glob",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "glob.glob",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.remove",
          "id": "delete_file",
          "description": "Deletes specified file from filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "check_call",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "os.environ.get",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.rmtree",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.getmtime",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        }
      ],
      "contextual_code": "import os, shutil, glob, sys\n\ndef check_call(args):\n    try:\n        subprocess.check_call(args)\n    except subprocess.CalledProcessError:\n        executable = args[0]\n        command = [a for a in args if not a.startswith('-')][-1]\n        raise RuntimeError(command + ' failed for ' + executable)\n\nclass BuildPy(build_py):\n    def initialize_options(self):\n        build_py.initialize_options(self)\n        os.chdir('manifold_src')        \n        csv_source_files = glob.glob(\n            os.path.join('original_manifold_sources', '*.csv'))\n        if len(csv_source_files) != 0:\n            if self.force:\n                for file in glob.glob('*.sqlite'):\n                    os.remove(file)\n            print('Rebuilding stale sqlite databases from csv sources...')\n            check_call([sys.executable, 'make_sqlite_db.py'])\n        os.chdir('..')\n\nclass Release(Command):\n    def run(self):\n        pythons = os.environ.get('RELEASE_PYTHONS', sys.executable).split(',')\n        check_call([pythons[0], 'setup.py', 'clean'])\n        check_call([pythons[0], 'setup.py', 'bdist_wheel', '--universal'])\n        check_call([pythons[0], 'setup.py', 'sdist'])\n        if self.install:\n            for python in pythons:\n                check_call([python, 'setup.py', 'pip_install', '--no-build-wheel'])\n\nclass PipInstall(Command):\n    def run(self): \n        python = sys.executable\n        check_call([python, 'setup.py', 'build'])\n        if not self.no_build_wheel:\n            check_call([python, 'setup.py', 'bdist_wheel', '--universal'])\n        egginfo = 'snappy_manifolds.egg-info'\n        if os.path.exists(egginfo):\n            shutil.rmtree(egginfo)\n        wheels = glob.glob('dist' + os.sep + '*.whl')\n        new_wheel = max(wheels, key=os.path.getmtime)            \n        check_call([python, '-m', 'pip', 'install', '--upgrade',\n                    '--upgrade-strategy', 'only-if-needed',\n                    '--force-reinstall', new_wheel])"
    }
  },
  {
    "metadata": {
      "package_name": "snappy_manifolds-1.2.1",
      "total_matches": 2
    }
  }
]