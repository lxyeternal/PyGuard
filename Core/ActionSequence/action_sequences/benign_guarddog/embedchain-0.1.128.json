[
  {
    "pyfile": "add_config.py",
    "code_snippet": "import builtins\nimport logging\nfrom collections.abc import Callable\nfrom importlib import import_module\nfrom typing import Optional\n\nfrom embedchain.config.base_config import BaseConfig\nfrom embedchain.helpers.json_serializable import register_deserializable\n\n\n@register_deserializable\nclass ChunkerConfig(BaseConfig):\n    \"\"\"\n    Config for the chunker used in `add` method\n    \"\"\"\n\n    def __init__(\n        self,\n        chunk_size: Optional[int] = 2000,\n        chunk_overlap: Optional[int] = 0,\n        length_function: Optional[Callable[[str], int]] = None,\n        min_chunk_size: Optional[int] = 0,\n    ):\n        self.chunk_size = chunk_size\n        self.chunk_overlap = chunk_overlap\n        self.min_chunk_size = min_chunk_size\n        if self.min_chunk_size >= self.chunk_size:\n            raise ValueError(f\"min_chunk_size {min_chunk_size} should be less than chunk_size {chunk_size}\")\n        if self.min_chunk_size < self.chunk_overlap:\n            logging.warning(\n                f\"min_chunk_size {min_chunk_size} should be greater than chunk_overlap {chunk_overlap}, otherwise it is redundant.\"  # noqa:E501\n            )\n\n        if isinstance(length_function, str):\n            self.length_function = self.load_func(length_function)\n        else:\n            self.length_function = length_function if length_function else len\n\n    @staticmethod\n    def load_func(dotpath: str):\n        if \".\" not in dotpath:\n            return getattr(builtins, dotpath)\n        else:\n            module_, func = dotpath.rsplit(\".\", maxsplit=1)\n            m = import_module(module_)\n            return getattr(m, func)\n",
    "pattern_analysis": {
      "api_sequence": [
        "isinstance",
        "getattr",
        "importlib.import_module",
        "getattr"
      ],
      "api_sequence_with_args": [
        "isinstance(length_function, str)",
        "getattr(builtins, dotpath)",
        "importlib.import_module(module_)",
        "getattr(m, func)"
      ],
      "mapped_sequence": [
        {
          "api_name": "isinstance",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "getattr",
          "id": "get_global_symbols",
          "description": "Retrieves global symbol table as dictionary",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "importlib.import_module",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "getattr",
          "id": "get_global_symbols",
          "description": "Retrieves global symbol table as dictionary",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        }
      ],
      "contextual_code": "if isinstance(length_function, str):\n    self.length_function = self.load_func(length_function)\nelse:\n    self.length_function = length_function if length_function else len\n\n@staticmethod\ndef load_func(dotpath: str):\n    if \".\" not in dotpath:\n        return getattr(builtins, dotpath)\n    else:\n        module_, func = dotpath.rsplit(\".\", maxsplit=1)\n        m = importlib.import_module(module_)\n        return getattr(m, func)"
    }
  },
  {
    "metadata": {
      "package_name": "embedchain-0.1.128",
      "total_matches": 1
    }
  }
]