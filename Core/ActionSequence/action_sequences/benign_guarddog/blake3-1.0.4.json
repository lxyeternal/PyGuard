[
  {
    "pyfile": "setup.py",
    "code_snippet": "import subprocess\nimport platform\nimport os\nfrom os import path\nfrom distutils import ccompiler\nimport sys\nimport setuptools\n\nVERSION = \"0.0.1\"\nDESCRIPTION = \"experimental bindings for the BLAKE3 C implementation, API-compatible with the Rust-based blake3 module\"\n\nunix_asm_files = [\n    \"vendor/blake3_sse2_x86-64_unix.S\",\n    \"vendor/blake3_sse41_x86-64_unix.S\",\n    \"vendor/blake3_avx2_x86-64_unix.S\",\n    \"vendor/blake3_avx512_x86-64_unix.S\",\n]\n\nwindows_msvc_asm_files = [\n    \"vendor/blake3_sse2_x86-64_windows_msvc.asm\",\n    \"vendor/blake3_sse41_x86-64_windows_msvc.asm\",\n    \"vendor/blake3_avx2_x86-64_windows_msvc.asm\",\n    \"vendor/blake3_avx512_x86-64_windows_msvc.asm\",\n]\n\n# path, unix_flags, win_flags\nx86_intrinsics_files = [\n    (\"vendor/blake3_sse2.c\", [\"-msse2\"], []),\n    (\"vendor/blake3_sse41.c\", [\"-msse4.1\"], []),\n    (\"vendor/blake3_avx2.c\", [\"-mavx2\"], [\"/arch:AVX2\"]),\n    (\"vendor/blake3_avx512.c\", [\"-mavx512f\", \"-mavx512vl\"], [\"/arch:AVX512\"]),\n]\n\ndef is_windows():\n    return sys.platform.startswith(\"win32\")\n\ndef is_macos():\n    return sys.platform.startswith(\"darwin\")\n\ndef targeting_x86_64():\n    # We use *Python's* word size to determine whether we're targeting 64-bit,\n    # not the machine's.\n    assert sys.maxsize.bit_length() in (31, 63)\n    return (\n        platform.machine().lower() in (\"x86_64\", \"amd64\")\n        and sys.maxsize.bit_length() == 63\n    )\n\ndef targeting_x86_32():\n    # We use *Python's* word size to determine whether we're targeting 64-bit,\n    # not the machine's. Also I'm not exactly sure what the full set of\n    # \"machine\" values is, and this is partly copying upstream build.rs.\n    assert sys.maxsize.bit_length() in (31, 63)\n    return (\n        platform.machine().lower() in (\"i386\", \"i586\", \"i686\", \"x86_64\", \"amd64\")\n        and sys.maxsize.bit_length() == 31\n    )\n\ndef is_aarch64():\n    return platform.machine().lower() in (\"aarch64\", \"arm64\")\n\ndef force_intrinsics():\n    return os.environ.get(\"FORCE_INTRINSICS\") == \"1\"\n\ndef compile_x86_intrinsics():\n    object_files = []\n    for (\n        filepath,\n        unix_intrinsics_flags,\n        windows_intrinsics_flags,\n    ) in x86_intrinsics_files:\n        cc = ccompiler.new_compiler()\n        if is_windows():\n            args = [\"/O2\"] + windows_intrinsics_flags\n        else:\n            args = [\"-O3\"] + unix_intrinsics_flags\n        print(f\"compiling {filepath} with {args}\")\n        object_files += cc.compile([filepath], extra_preargs=args)\n    return object_files\n\ndef compile_macos_universal_staticlib():\n    assert is_macos()\n\n    def run(command):\n        print(\" \".join(command))\n        subprocess.run(command, check=True)\n\n    # Build the x86 implementations (either asm or intrinsics). There are\n    # several of them, so wrap them in into a .a file. The `lipo` tool wants\n    # one file per architecture.\n    x86_object_files = []\n    if force_intrinsics():\n        for filepath, unix_intrinsics_flags, _ in x86_intrinsics_files:\n            output = filepath.replace(\".c\", \".o\")\n            run(\n                [\n                    \"clang\",\n                    \"-arch\",\n                    \"x86_64\",\n                    \"-O3\",\n                    *unix_intrinsics_flags,\n                    \"-c\",\n                    filepath,\n                    \"-o\",\n                    output,\n                ]\n            )\n            x86_object_files.append(output)\n    else:\n        for filepath in unix_asm_files:\n            output = filepath.replace(\".S\", \".o\")\n            run([\"clang\", \"-arch\", \"x86_64\", \"-c\", filepath, \"-o\", output])\n            x86_object_files.append(output)\n    x86_staticlib = \"vendor/blake3_x86.a\"\n    run([\"ar\", \"rcs\", x86_staticlib, *x86_object_files])\n\n    # Build the ARM NEON implementation, which is currently just intrinsics.\n    # Since this is one file we don't need a .a file.\n    neon_output = \"vendor/blake3_neon.o\"\n    run(\n        [\n            \"clang\",\n            \"-arch\",\n            \"arm64\",\n            \"-O3\",\n            \"-c\",\n            \"vendor/blake3_neon.c\",\n            \"-o\",\n            neon_output,\n        ]\n    )\n\n    # Package the x86 output and the ARM output into a single \"universal\"\n    # staticlib. Note that these define different functions with\n    # architecture-specific names, but blake3_dispatch.c will end up getting\n    # compiled for both architectures and calling the right functions in each\n    # case.\n    universal_output = \"vendor/blake3_universal.a\"\n    run(\n        [\n            \"lipo\",\n            \"-create\",\n            x86_staticlib,\n            neon_output,\n            \"-output\",\n            universal_output,\n        ]\n    )\n    return [universal_output]\n\ndef windows_ml64_path():\n    vswhere_path = (\n        r\"C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\\\\Installer\\\\vswhere.exe\"\n    )\n    if not path.exists(vswhere_path):\n        raise RuntimeError(vswhere_path + \" doesn't exist.\")\n    vswhere_cmd = [\n        vswhere_path,\n        \"-latest\",\n        \"-requires\",\n        \"Microsoft.VisualStudio.Component.VC.Tools.x86.x64\",\n        \"-products\",\n        \"*\",\n        \"-find\",\n        r\"**\\\\Hostx64\\\\x64\\\\ml64.exe\",\n    ]\n    result = subprocess.run(vswhere_cmd, check=True, stdout=subprocess.PIPE, text=True)\n    vswhere_output = result.stdout.strip()\n    if not result.stdout:\n        raise RuntimeError(\"vswhere.exe didn't output a path\")\n    ml64_path = vswhere_output.splitlines()[-1]\n    if not path.exists(ml64_path):\n        raise RuntimeError(ml64_path + \" doesn't exist\")\n    return ml64_path\n\ndef compile_windows_msvc_asm():\n    ml64 = windows_ml64_path()\n    object_files = []\n    for filepath in windows_msvc_asm_files:\n        obj_path = path.splitext(filepath)[0] + \".obj\"\n        cmd = [ml64, \"/Fo\", obj_path, \"/c\", filepath]\n        print(\" \".join(cmd))\n        subprocess.run(cmd, check=True)\n        object_files.append(obj_path)\n    return object_files\n",
    "pattern_analysis": {
      "api_sequence": [
        "sys.platform.startswith",
        "sys.maxsize.bit_length",
        "platform.machine",
        "sys.maxsize.bit_length",
        "platform.machine",
        "sys.maxsize.bit_length",
        "platform.machine",
        "os.environ.get",
        "distutils.ccompiler.new_compiler",
        "ccompiler.CCompiler.compile",
        "platform.machine",
        "os.path.exists",
        "subprocess.run",
        "os.path.exists",
        "subprocess.run",
        "subprocess.run",
        "os.path.exists",
        "subprocess.run"
      ],
      "api_sequence_with_args": [
        "sys.platform.startswith(\"win32\")",
        "sys.maxsize.bit_length()",
        "platform.machine().lower()",
        "sys.maxsize.bit_length()",
        "platform.machine().lower()",
        "sys.maxsize.bit_length()",
        "platform.machine().lower()",
        "os.environ.get(\"FORCE_INTRINSICS\")",
        "distutils.ccompiler.new_compiler()",
        "ccompiler.CCompiler.compile([filepath], extra_preargs=args)",
        "platform.machine().lower()",
        "os.path.exists(vswhere_path)",
        "subprocess.run(vswhere_cmd, check=True, stdout=subprocess.PIPE, text=True)",
        "os.path.exists(ml64_path)",
        "subprocess.run(cmd, check=True)",
        "os.path.exists(vswhere_path)",
        "subprocess.run(vswhere_cmd, check=True, stdout=subprocess.PIPE, text=True)"
      ],
      "mapped_sequence": [
        {
          "api_name": "sys.platform.startswith",
          "id": "get_os_id",
          "description": "Retrieves operating system identifier",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "sys.maxsize.bit_length",
          "id": "get_os_id",
          "description": "Retrieves operating system identifier",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "platform.machine",
          "id": "get_machine_type",
          "description": "Retrieves machine type, e.g., 'x86_64'",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "hardware_information"
        },
        {
          "api_name": "sys.maxsize.bit_length",
          "id": "get_os_id",
          "description": "Retrieves operating system identifier",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "platform.machine",
          "id": "get_machine_type",
          "description": "Retrieves machine type, e.g., 'x86_64'",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "hardware_information"
        },
        {
          "api_name": "sys.maxsize.bit_length",
          "id": "get_os_id",
          "description": "Retrieves operating system identifier",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "platform.machine",
          "id": "get_machine_type",
          "description": "Retrieves machine type, e.g., 'x86_64'",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "hardware_information"
        },
        {
          "api_name": "os.environ.get",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "distutils.ccompiler.new_compiler",
          "id": "init_setup_class",
          "description": "Instantiates Setup class",
          "first_id": "data_exfiltration",
          "second_id": "data_transmission_channels",
          "third_id": "exfiltration_channel_establishment"
        },
        {
          "api_name": "ccompiler.CCompiler.compile",
          "id": "configure_package_install",
          "description": "Configures and initiates Python package installation",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "package_configuration"
        },
        {
          "api_name": "platform.machine",
          "id": "get_machine_type",
          "description": "Retrieves machine type, e.g., 'x86_64'",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "hardware_information"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "subprocess.run",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "subprocess.run",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "subprocess.run",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "subprocess.run",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        }
      ],
      "contextual_code": "import subprocess\nimport platform\nimport os\nfrom os import path\nfrom distutils import ccompiler\nimport sys\n\ndef is_windows():\n    return sys.platform.startswith(\"win32\")\n\ndef is_macos():\n    return sys.platform.startswith(\"darwin\")\n\ndef targeting_x86_64():\n    assert sys.maxsize.bit_length() in (31, 63)\n    return (\n        platform.machine().lower() in (\"x86_64\", \"amd64\")\n        and sys.maxsize.bit_length() == 63\n    )\n\ndef targeting_x86_32():\n    assert sys.maxsize.bit_length() in (31, 63)\n    return (\n        platform.machine().lower() in (\"i386\", \"i586\", \"i686\", \"x86_64\", \"amd64\")\n        and sys.maxsize.bit_length() == 31\n    )\n\ndef is_aarch64():\n    return platform.machine().lower() in (\"aarch64\", \"arm64\")\n\ndef force_intrinsics():\n    return os.environ.get(\"FORCE_INTRINSICS\") == \"1\"\n\ndef compile_x86_intrinsics():\n    object_files = []\n    for (\n        filepath,\n        unix_intrinsics_flags,\n        windows_intrinsics_flags,\n    ) in x86_intrinsics_files:\n        cc = ccompiler.new_compiler()\n        if is_windows():\n            args = [\"/O2\"] + windows_intrinsics_flags\n        else:\n            args = [\"-O3\"] + unix_intrinsics_flags\n        print(f\"compiling {filepath} with {args}\")\n        object_files += cc.compile([filepath], extra_preargs=args)\n    return object_files\n\ndef windows_ml64_path():\n    vswhere_path = (\n        r\"C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\\\\Installer\\\\vswhere.exe\"\n    )\n    if not path.exists(vswhere_path):\n        raise RuntimeError(vswhere_path + \" doesn't exist.\")\n    vswhere_cmd = [\n        vswhere_path,\n        \"-latest\",\n        \"-requires\",\n        \"Microsoft.VisualStudio.Component.VC.Tools.x86.x64\",\n        \"-products\",\n        \"*\",\n        \"-find\",\n        r\"**\\\\Hostx64\\\\x64\\\\ml64.exe\",\n    ]\n    result = subprocess.run(vswhere_cmd, check=True, stdout=subprocess.PIPE, text=True)\n    vswhere_output = result.stdout.strip()\n    if not result.stdout:\n        raise RuntimeError(\"vswhere.exe didn't output a path\")\n    ml64_path = vswhere_output.splitlines()[-1]\n    if not path.exists(ml64_path):\n        raise RuntimeError(ml64_path + \" doesn't exist\")\n    return ml64_path\n\ndef compile_windows_msvc_asm():\n    ml64 = windows_ml64_path()\n    object_files = []\n    for filepath in windows_msvc_asm_files:\n        obj_path = path.splitext(filepath)[0] + \".obj\"\n        cmd = [ml64, \"/Fo\", obj_path, \"/c\", filepath]\n        print(\" \".join(cmd))\n        subprocess.run(cmd, check=True)\n        object_files.append(obj_path)\n    return object_files"
    }
  },
  {
    "metadata": {
      "package_name": "blake3-1.0.4",
      "total_matches": 8
    }
  }
]