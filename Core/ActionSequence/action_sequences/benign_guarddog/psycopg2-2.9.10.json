[
  {
    "pyfile": "setup.py",
    "code_snippet": "import os\nimport sys\nimport re\nimport subprocess\nfrom setuptools import setup, Extension\nfrom distutils.command.build_ext import build_ext\nfrom distutils.ccompiler import get_default_compiler\nfrom distutils.errors import CompileError\n\nimport configparser\n\nPLATFORM_IS_WINDOWS = sys.platform.lower().startswith('win')\n\nclass PostgresConfig:\n    def __init__(self, build_ext):\n        self.build_ext = build_ext\n        self.pg_config_exe = self.build_ext.pg_config\n        if not self.pg_config_exe:\n            self.pg_config_exe = self.autodetect_pg_config_path()\n        if self.pg_config_exe is None:\n            sys.stderr.write(\"\"\"\nError: pg_config executable not found.\n\npg_config is required to build psycopg2 from source.  Please add the directory\ncontaining pg_config to the $PATH or specify the full executable path with the\noption:\n\n    python setup.py build_ext --pg-config /path/to/pg_config build ...\n\nor with the pg_config option in 'setup.cfg'.\n\nIf you prefer to avoid building psycopg2 from source, please install the PyPI\n'psycopg2-binary' package instead.\n\nFor further information please check the 'doc/src/install.rst' file (also at\n<https://www.psycopg.org/docs/install.html>).\n\n\"\"\")\n            sys.exit(1)\n\n    def query(self, attr_name, *, empty_ok=False):\n        \"\"\"Spawn the pg_config executable, querying for the given config\n        name, and return the printed value, sanitized. \"\"\"\n        try:\n            pg_config_process = subprocess.run(\n                [self.pg_config_exe, \"--\" + attr_name],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE)\n        except OSError:\n            raise Warning(\n                f\"Unable to find 'pg_config' file in '{self.pg_config_exe}'\")\n        if pg_config_process.returncode:\n            err = pg_config_process.stderr.decode(errors='backslashreplace')\n            raise Warning(f\"pg_config --{attr_name} failed: {err}\")\n        result = pg_config_process.stdout.decode().strip()\n        if not result and not empty_ok:\n            raise Warning(f\"pg_config --{attr_name} is empty\")\n        return result\n\n    def find_on_path(self, exename, path_directories=None):\n        if not path_directories:\n            path_directories = os.environ['PATH'].split(os.pathsep)\n        for dir_name in path_directories:\n            fullpath = os.path.join(dir_name, exename)\n            if os.path.isfile(fullpath):\n                return fullpath\n        return None\n\n    def autodetect_pg_config_path(self):\n        \"\"\"Find and return the path to the pg_config executable.\"\"\"\n        if PLATFORM_IS_WINDOWS:\n            return self.autodetect_pg_config_path_windows()\n        else:\n            return self.find_on_path('pg_config')\n\n    def autodetect_pg_config_path_windows(self):\n        \"\"\"Attempt several different ways of finding the pg_config\n        executable on Windows, and return its full path, if found.\"\"\"\n\n        # This code only runs if they have not specified a pg_config option\n        # in the config file or via the commandline.\n\n        # First, check for pg_config.exe on the PATH, and use that if found.\n        pg_config_exe = self.find_on_path('pg_config.exe')\n        if pg_config_exe:\n            return pg_config_exe\n\n        # Now, try looking in the Windows Registry to find a PostgreSQL\n        # installation, and infer the path from that.\n        pg_config_exe = self._get_pg_config_from_registry()\n        if pg_config_exe:\n            return pg_config_exe\n\n        return None\n\n    def _get_pg_config_from_registry(self):\n        import winreg\n\n        reg = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)\n        try:\n            pg_inst_list_key = winreg.OpenKey(reg,\n                'SOFTWARE\\\\PostgreSQL\\\\Installations')\n        except OSError:\n            # No PostgreSQL installation, as best as we can tell.\n            return None\n\n        try:\n            # Determine the name of the first subkey, if any:\n            try:\n                first_sub_key_name = winreg.EnumKey(pg_inst_list_key, 0)\n            except OSError:\n                return None\n\n            pg_first_inst_key = winreg.OpenKey(reg,\n                'SOFTWARE\\\\PostgreSQL\\\\Installations\\\\' + first_sub_key_name)\n            try:\n                pg_inst_base_dir = winreg.QueryValueEx(\n                    pg_first_inst_key, 'Base Directory')[0]\n            finally:\n                winreg.CloseKey(pg_first_inst_key)\n\n        finally:\n            winreg.CloseKey(pg_inst_list_key)\n\n        pg_config_path = os.path.join(\n            pg_inst_base_dir, 'bin', 'pg_config.exe')\n        if not os.path.exists(pg_config_path):\n            return None\n\n        return pg_config_path\n",
    "pattern_analysis": {
      "api_sequence": [
        "sys.platform",
        "os.environ",
        "os.pathsep",
        "os.path.join",
        "os.path.isfile",
        "os.path.join",
        "os.path.exists",
        "subprocess.run",
        "sys.stderr.write",
        "sys.exit",
        "winreg.ConnectRegistry",
        "winreg.OpenKey",
        "winreg.EnumKey",
        "winreg.OpenKey",
        "winreg.QueryValueEx",
        "winreg.CloseKey",
        "winreg.CloseKey"
      ],
      "api_sequence_with_args": [
        "sys.platform.lower().startswith('win')",
        "os.environ['PATH']",
        "os.pathsep",
        "os.path.join(dir_name, exename)",
        "os.path.isfile(fullpath)",
        "os.path.join(pg_inst_base_dir, 'bin', 'pg_config.exe')",
        "os.path.exists(pg_config_path)",
        "subprocess.run([self.pg_config_exe, '--' + attr_name], stdout=subprocess.PIPE, stderr=subprocess.PIPE)",
        "sys.stderr.write('...')",
        "sys.exit(1)",
        "winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)",
        "winreg.OpenKey(reg, 'SOFTWARE\\PostgreSQL\\Installations')",
        "winreg.EnumKey(pg_inst_list_key, 0)",
        "winreg.OpenKey(reg, 'SOFTWARE\\PostgreSQL\\Installations\\' + first_sub_key_name)",
        "winreg.QueryValueEx(pg_first_inst_key, 'Base Directory')",
        "winreg.CloseKey(pg_first_inst_key)",
        "winreg.CloseKey(pg_inst_list_key)"
      ],
      "mapped_sequence": [
        {
          "api_name": "sys.platform",
          "id": "get_os_id",
          "description": "Retrieves operating system identifier",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "os.environ",
          "id": "get_env_vars",
          "description": "Retrieves environment variables mapping",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.pathsep",
          "id": "get_os_path_sep",
          "description": "Retrieves operating system path separator",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.isfile",
          "id": "check_file_is_file",
          "description": "Checks if specified path exists and is a file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "subprocess.run",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "sys.stderr.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "sys.exit",
          "id": "exit_program",
          "description": "Exits program with specified status code",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "winreg.ConnectRegistry",
          "id": "open_registry_key",
          "description": "Opens registry key with specified access",
          "first_id": "system_operations",
          "second_id": "registry_operations",
          "third_id": "registry_access"
        },
        {
          "api_name": "winreg.OpenKey",
          "id": "open_registry_key",
          "description": "Opens registry key with specified access",
          "first_id": "system_operations",
          "second_id": "registry_operations",
          "third_id": "registry_access"
        },
        {
          "api_name": "winreg.EnumKey",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "winreg.OpenKey",
          "id": "open_registry_key",
          "description": "Opens registry key with specified access",
          "first_id": "system_operations",
          "second_id": "registry_operations",
          "third_id": "registry_access"
        },
        {
          "api_name": "winreg.QueryValueEx",
          "id": "get_registry_value",
          "description": "Retrieves value and data type for specified registry value",
          "first_id": "system_operations",
          "second_id": "registry_operations",
          "third_id": "registry_modification"
        },
        {
          "api_name": "winreg.CloseKey",
          "id": "close_registry_key",
          "description": "Closes the opened registry key",
          "first_id": "system_operations",
          "second_id": "registry_operations",
          "third_id": "registry_access"
        },
        {
          "api_name": "winreg.CloseKey",
          "id": "close_registry_key",
          "description": "Closes the opened registry key",
          "first_id": "system_operations",
          "second_id": "registry_operations",
          "third_id": "registry_access"
        }
      ],
      "contextual_code": "import os\nimport sys\nimport subprocess\n\nPLATFORM_IS_WINDOWS = sys.platform.lower().startswith('win')\n\nclass PostgresConfig:\n    def find_on_path(self, exename, path_directories=None):\n        if not path_directories:\n            path_directories = os.environ['PATH'].split(os.pathsep)\n        for dir_name in path_directories:\n            fullpath = os.path.join(dir_name, exename)\n            if os.path.isfile(fullpath):\n                return fullpath\n        return None\n\n    def autodetect_pg_config_path(self):\n        if PLATFORM_IS_WINDOWS:\n            return self.autodetect_pg_config_path_windows()\n        else:\n            return self.find_on_path('pg_config')\n\n    def autodetect_pg_config_path_windows(self):\n        pg_config_exe = self.find_on_path('pg_config.exe')\n        if pg_config_exe:\n            return pg_config_exe\n        pg_config_exe = self._get_pg_config_from_registry()\n        if pg_config_exe:\n            return pg_config_exe\n        return None\n\n    def _get_pg_config_from_registry(self):\n        import winreg\n        reg = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)\n        try:\n            pg_inst_list_key = winreg.OpenKey(reg, 'SOFTWARE\\\\PostgreSQL\\\\Installations')\n        except OSError:\n            return None\n        try:\n            try:\n                first_sub_key_name = winreg.EnumKey(pg_inst_list_key, 0)\n            except OSError:\n                return None\n            pg_first_inst_key = winreg.OpenKey(reg, 'SOFTWARE\\\\PostgreSQL\\\\Installations\\\\' + first_sub_key_name)\n            try:\n                pg_inst_base_dir = winreg.QueryValueEx(pg_first_inst_key, 'Base Directory')[0]\n            finally:\n                winreg.CloseKey(pg_first_inst_key)\n        finally:\n            winreg.CloseKey(pg_inst_list_key)\n        pg_config_path = os.path.join(pg_inst_base_dir, 'bin', 'pg_config.exe')\n        if not os.path.exists(pg_config_path):\n            return None\n        return pg_config_path\n\n    def query(self, attr_name, *, empty_ok=False):\n        try:\n            pg_config_process = subprocess.run([\n                self.pg_config_exe, \"--\" + attr_name],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE)\n        except OSError:\n            raise Warning(f\"Unable to find 'pg_config' file in '{self.pg_config_exe}'\")\n        if pg_config_process.returncode:\n            err = pg_config_process.stderr.decode(errors='backslashreplace')\n            raise Warning(f\"pg_config --{attr_name} failed: {err}\")\n        result = pg_config_process.stdout.decode().strip()\n        if not result and not empty_ok:\n            raise Warning(f\"pg_config --{attr_name} is empty\")\n        return result\n\n    def __init__(self, build_ext):\n        self.build_ext = build_ext\n        self.pg_config_exe = self.build_ext.pg_config\n        if not self.pg_config_exe:\n            self.pg_config_exe = self.autodetect_pg_config_path()\n        if self.pg_config_exe is None:\n            sys.stderr.write('''\\nError: pg_config executable not found.\\n\\npg_config is required to build psycopg2 from source.  Please add the directory\\ncontaining pg_config to the $PATH or specify the full executable path with the\\noption:\\n\\n    python setup.py build_ext --pg-config /path/to/pg_config build ...\\n\\nor with the pg_config option in 'setup.cfg'.\\n\\nIf you prefer to avoid building psycopg2 from source, please install the PyPI\\n'psycopg2-binary' package instead.\\n\\nFor further information please check the 'doc/src/install.rst' file (also at\\n<https://www.psycopg.org/docs/install.html>).\\n\\n''')\n            sys.exit(1)"
    }
  },
  {
    "metadata": {
      "package_name": "psycopg2-2.9.10",
      "total_matches": 1
    }
  }
]