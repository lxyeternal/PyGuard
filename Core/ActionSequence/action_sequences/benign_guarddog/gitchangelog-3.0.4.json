[
  {
    "pyfile": "setup.py",
    "code_snippet": "# Context for Match 1 (Line 45):\n\n# The flagged line is:\n#   os.system('%s%s > .autogen.sh.output'\n#             % (\"bash \" if WIN32 else \"\",\n#                autogen))\n#\n# This is outside a function, inside a conditional block. We extract the full block, including all variable assignments, imports, and control flow leading to this line, as well as data dependencies (WIN32, autogen).\n\n#!/usr/bin/env python\n\ntry:\n    from setuptools import setup\nexcept ImportError:\n    from distribute_setup import use_setuptools\n    use_setuptools()\n    from setuptools import setup\n\nif \"3.0.4\".startswith(\"%%\"):\n    import os.path\n    import sys\n    WIN32 = sys.platform == 'win32'\n    autogen = os.path.join(\".\", \"autogen.sh\")\n    if not os.path.exists(autogen):\n        sys.stderr.write(\n            \"This source repository was not configured.\\n\"\n            \"Please ensure ``./autogen.sh`` exists and that you are running \"\n            \"``setup.py`` from the project root directory.\\n\")\n        sys.exit(1)\n    if os.path.exists('.autogen.sh.output'):\n        sys.stderr.write(\n            \"It seems that ``./autogen.sh`` couldn't do its job as expected.\\n\"\n            \"Please try to launch ``./autogen.sh`` manualy, and send the \"\n            \"results to the\\nmaintainer of this package.\\n\"\n            \"Package will not be installed !\\n\")\n        sys.exit(1)\n    sys.stderr.write(\"Missing version information: \"\n                     \"running './autogen.sh'...\\n\")\n    import os\n    import subprocess\n    os.system('%s%s > .autogen.sh.output'\n              % (\"bash \" if WIN32 else \"\",\n                 autogen))\n    cmdline = sys.argv[:]\n    if cmdline[0] == \"-c\":\n        ## for some reason, this is needed when launched from pip\n        cmdline[0] = \"setup.py\"\n    errlvl = subprocess.call([\"python\", ] + cmdline)\n    os.unlink(\".autogen.sh.output\")\n    sys.exit(errlvl)\n\n# Data dependencies:\n# - WIN32: set as WIN32 = sys.platform == 'win32' above\n# - autogen: set as autogen = os.path.join(\".\", \"autogen.sh\") above\n# - os: imported above\n\n# Context for Match 2 (Line 52):\n\n# The flagged line is:\n#   errlvl = subprocess.call([\"python\", ] + cmdline)\n#\n# This is in the same block as above, so the context is the same. The variables used:\n# - subprocess: imported above\n# - cmdline: set as cmdline = sys.argv[:] above, possibly modified if cmdline[0] == \"-c\"\n\n# The full extracted context for both flagged lines is as follows:\n\n#!/usr/bin/env python\n\ntry:\n    from setuptools import setup\nexcept ImportError:\n    from distribute_setup import use_setuptools\n    use_setuptools()\n    from setuptools import setup\n\nif \"3.0.4\".startswith(\"%%\"):\n    import os.path\n    import sys\n    WIN32 = sys.platform == 'win32'\n    autogen = os.path.join(\".\", \"autogen.sh\")\n    if not os.path.exists(autogen):\n        sys.stderr.write(\n            \"This source repository was not configured.\\n\"\n            \"Please ensure ``./autogen.sh`` exists and that you are running \"\n            \"``setup.py`` from the project root directory.\\n\")\n        sys.exit(1)\n    if os.path.exists('.autogen.sh.output'):\n        sys.stderr.write(\n            \"It seems that ``./autogen.sh`` couldn't do its job as expected.\\n\"\n            \"Please try to launch ``./autogen.sh`` manualy, and send the \"\n            \"results to the\\nmaintainer of this package.\\n\"\n            \"Package will not be installed !\\n\")\n        sys.exit(1)\n    sys.stderr.write(\"Missing version information: \"\n                     \"running './autogen.sh'...\\n\")\n    import os\n    import subprocess\n    os.system('%s%s > .autogen.sh.output'\n              % (\"bash \" if WIN32 else \"\",\n                 autogen))\n    cmdline = sys.argv[:]\n    if cmdline[0] == \"-c\":\n        ## for some reason, this is needed when launched from pip\n        cmdline[0] = \"setup.py\"\n    errlvl = subprocess.call([\"python\", ] + cmdline)\n    os.unlink(\".autogen.sh.output\")\n    sys.exit(errlvl)\n",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.join",
        "sys.platform",
        "os.path.exists",
        "sys.stderr.write",
        "sys.exit",
        "os.path.exists",
        "sys.stderr.write",
        "sys.exit",
        "sys.stderr.write",
        "os.system",
        "sys.argv",
        "subprocess.call",
        "os.unlink",
        "sys.exit"
      ],
      "api_sequence_with_args": [
        "os.path.join('.', 'autogen.sh')",
        "sys.platform",
        "os.path.exists(autogen)",
        "sys.stderr.write('This source repository was not configured.\\nPlease ensure ``./autogen.sh`` exists and that you are running ``setup.py`` from the project root directory.\\n')",
        "sys.exit(1)",
        "os.path.exists('.autogen.sh.output')",
        "sys.stderr.write('It seems that ``./autogen.sh`` couldn\\'t do its job as expected.\\nPlease try to launch ``./autogen.sh`` manualy, and send the results to the\\nmaintainer of this package.\\nPackage will not be installed !\\n')",
        "sys.exit(1)",
        "sys.stderr.write(\"Missing version information: running './autogen.sh'...\\n\")",
        "os.system('%s%s > .autogen.sh.output' % (\"bash \" if WIN32 else \"\", autogen))",
        "sys.argv[:]",
        "subprocess.call([\"python\", ] + cmdline)",
        "os.unlink('.autogen.sh.output')",
        "sys.exit(errlvl)"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "sys.platform",
          "id": "get_os_id",
          "description": "Retrieves operating system identifier",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "sys.stderr.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "sys.exit",
          "id": "exit_program",
          "description": "Exits program with specified status code",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "sys.stderr.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "sys.exit",
          "id": "exit_program",
          "description": "Exits program with specified status code",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "sys.stderr.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "os.system",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "sys.argv",
          "id": "get_cmd_args",
          "description": "Retrieves command-line arguments passed to script",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "subprocess.call",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "os.unlink",
          "id": "delete_file",
          "description": "Deletes specified file from filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "sys.exit",
          "id": "exit_program",
          "description": "Exits program with specified status code",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        }
      ],
      "contextual_code": "#!/usr/bin/env python\n\ntry:\n    from setuptools import setup\nexcept ImportError:\n    from distribute_setup import use_setuptools\n    use_setuptools()\n    from setuptools import setup\n\nif \"3.0.4\".startswith(\"%%\"):\n    import os.path\n    import sys\n    WIN32 = sys.platform == 'win32'\n    autogen = os.path.join(\".\", \"autogen.sh\")\n    if not os.path.exists(autogen):\n        sys.stderr.write(\n            \"This source repository was not configured.\\n\"\n            \"Please ensure ``./autogen.sh`` exists and that you are running \"\n            \"``setup.py`` from the project root directory.\\n\")\n        sys.exit(1)\n    if os.path.exists('.autogen.sh.output'):\n        sys.stderr.write(\n            \"It seems that ``./autogen.sh`` couldn't do its job as expected.\\n\"\n            \"Please try to launch ``./autogen.sh`` manualy, and send the \"\n            \"results to the\\nmaintainer of this package.\\n\"\n            \"Package will not be installed !\\n\")\n        sys.exit(1)\n    sys.stderr.write(\"Missing version information: \"\n                     \"running './autogen.sh'...\\n\")\n    import os\n    import subprocess\n    os.system('%s%s > .autogen.sh.output'\n              % (\"bash \" if WIN32 else \"\",\n                 autogen))\n    cmdline = sys.argv[:]\n    if cmdline[0] == \"-c\":\n        ## for some reason, this is needed when launched from pip\n        cmdline[0] = \"setup.py\"\n    errlvl = subprocess.call([\"python\", ] + cmdline)\n    os.unlink(\".autogen.sh.output\")\n    sys.exit(errlvl)"
    }
  },
  {
    "metadata": {
      "package_name": "gitchangelog-3.0.4",
      "total_matches": 2
    }
  }
]