[
  {
    "pyfile": "dota2_loader.py",
    "code_snippet": "import requests\n\nclass Dota2Loader(BaseLoader):\n    track_color = \"#567433\"\n    unit = \"games\"\n\n    def __init__(self, from_year, to_year, _type, **kwargs):\n        super().__init__(from_year, to_year, _type)\n        self.dota2_id = kwargs.get(\"dota2_id\", \"\")\n\n    @classmethod\n    def add_loader_arguments(cls, parser, optional):\n        parser.add_argument(\n            \"--dota2_id\",\n            dest=\"dota2_id\",\n            type=str,\n            required=optional,\n            help=\"Check your dota2-id in-game or on the website(steamid32): \"\n            \"https://steamid.xyz/\",\n        )\n",
    "pattern_analysis": {
      "api_sequence": [],
      "api_sequence_with_args": [],
      "mapped_sequence": [],
      "contextual_code": ""
    }
  },
  {
    "pyfile": "bbdc_loader.py",
    "code_snippet": "import json\nimport os.path\nfrom datetime import datetime\n\nimport requests\n\nfrom github_heatmap.loader.base_loader import BaseLoader, LoadError\nfrom github_heatmap.loader.config import BBDC_API_URL\n\nclass BBDCLoader(BaseLoader):\n    unit = \"minutes\"\n\n    def __init__(self, from_year, to_year, _type, **kwargs):\n        super().__init__(from_year, to_year, _type)\n        self.user_id = kwargs.get(\"bbdc_user_id\", \"\")\n        self.type = kwargs.get(\"bbdc_type\", \"time\")\n\n    @classmethod\n    def add_loader_arguments(cls, parser, optional):\n        parser.add_argument(\n            \"--bbdc_user_id\",\n            dest=\"bbdc_user_id\",\n            type=str,\n            required=optional,\n            help=\"BBDC user id\",\n        )\n        parser.add_argument(\n            \"--bbdc_type\",\n            dest=\"bbdc_type\",\n            type=str,\n            default=\"time\",\n            choices=[\"time\", \"word\"],\n            help=\"generate count type [time,word]\",\n        )\n\n    def _update_cache(self):\n        \"\"\"\n        cache structure\n\n        id: user-id\n        data:\n          2021-1-1:\n            learn: 20\n            time: 5\n            review: 20\n        \"\"\"\n\n        data_path = os.path.join(os.getcwd(), \"data\")\n        cache_path = os.path.join(os.getcwd(), \"data\", \"bbdc.json\")\n\n        if not os.path.exists(data_path):\n            os.mkdir(data_path)\n        if not os.path.exists(cache_path):\n            if not self.user_id:\n                raise LoadError(\"user id is required\")\n            cache = {\"id\": self.user_id, \"data\": {}}\n        else:\n            with open(cache_path, \"r\", encoding=\"utf-8\") as f:\n                cache = json.load(f)\n                self.user_id = cache.get(\"id\", \"\")\n                if not self.user_id:\n                    raise LoadError(\"user_id not found in cache.\")\n\n        resp = requests.get(BBDC_API_URL.format(user_id=self.user_id))\n        if not resp.ok:\n            raise LoadError(f\"Meet network error. {resp.reason}\")\n        data = resp.json()\n        if data[\"result_code\"] != 200:\n            raise LoadError(f\"Unexpected error. {data}\")\n\n        body = data[\"data_body\"]\n        duration = body[\"durationList\"]\n        learn = body[\"learnList\"]\n\n        for i in duration:\n            full_date = self.today_transform(i[\"date\"])\n            if full_date not in cache[\"data\"]:\n                cache[\"data\"][full_date] = {}\n\n            dur = i[\"duration\"]\n            cache[\"data\"][full_date][\"time\"] = dur\n\n        for i in learn:\n            full_date = self.today_transform(i[\"date\"])\n            if full_date not in cache[\"data\"]:\n                cache[\"data\"][full_date] = {}\n\n            learn = i[\"learnNum\"]\n            review = i[\"reviewNum\"]\n            cache[\"data\"][full_date][\"learn\"] = learn\n            cache[\"data\"][full_date][\"review\"] = review\n\n        with open(cache_path, \"w\", encoding=\"utf-8\") as f:\n            json.dump(cache, f, ensure_ascii=False)\n\n        return cache\n\n    @staticmethod\n    def today_transform(date):\n        if not date == \"今日\":\n            return f\"{datetime.today().year}-{date}\"\n        else:\n            return datetime.today().strftime(\"%Y-%m-%d\")\n",
    "pattern_analysis": {
      "api_sequence": [
        "os.getcwd",
        "os.path.join",
        "os.getcwd",
        "os.path.join",
        "os.path.exists",
        "os.path.exists",
        "os.mkdir",
        "os.path.exists",
        "open",
        "json.load",
        "requests.get",
        "requests.get.ok",
        "requests.get.reason",
        "requests.get.json",
        "open",
        "json.dump"
      ],
      "api_sequence_with_args": [
        "os.getcwd()",
        "os.path.join(os.getcwd(), \"data\")",
        "os.getcwd()",
        "os.path.join(os.getcwd(), \"data\", \"bbdc.json\")",
        "os.path.exists(data_path)",
        "os.path.exists(cache_path)",
        "os.mkdir(data_path)",
        "os.path.exists(cache_path)",
        "open(cache_path, \"r\", encoding=\"utf-8\")",
        "json.load(f)",
        "requests.get(BBDC_API_URL.format(user_id=self.user_id))",
        "resp.ok",
        "resp.reason",
        "resp.json()",
        "open(cache_path, \"w\", encoding=\"utf-8\")",
        "json.dump(cache, f, ensure_ascii=False)"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.getcwd",
          "id": "get_working_dir",
          "description": "Returns current working directory",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.getcwd",
          "id": "get_working_dir",
          "description": "Returns current working directory",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.mkdir",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "json.load",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "resp.ok",
          "id": "get_http_status",
          "description": "Retrieves HTTP response status code",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "resp.reason",
          "id": "get_http_status",
          "description": "Retrieves HTTP response status code",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "resp.json",
          "id": "deserialize_json_response",
          "description": "Deserializes JSON response body to Python object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "json.dump",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        }
      ],
      "contextual_code": "import json\nimport os.path\nimport requests\nfrom github_heatmap.loader.base_loader import LoadError\nfrom github_heatmap.loader.config import BBDC_API_URL\n\nclass BBDCLoader(BaseLoader):\n    def _update_cache(self):\n        data_path = os.path.join(os.getcwd(), \"data\")\n        cache_path = os.path.join(os.getcwd(), \"data\", \"bbdc.json\")\n\n        if not os.path.exists(data_path):\n            os.mkdir(data_path)\n        if not os.path.exists(cache_path):\n            if not self.user_id:\n                raise LoadError(\"user id is required\")\n            cache = {\"id\": self.user_id, \"data\": {}}\n        else:\n            with open(cache_path, \"r\", encoding=\"utf-8\") as f:\n                cache = json.load(f)\n                self.user_id = cache.get(\"id\", \"\")\n                if not self.user_id:\n                    raise LoadError(\"user_id not found in cache.\")\n\n        resp = requests.get(BBDC_API_URL.format(user_id=self.user_id))\n        if not resp.ok:\n            raise LoadError(f\"Meet network error. {resp.reason}\")\n        data = resp.json()\n        if data[\"result_code\"] != 200:\n            raise LoadError(f\"Unexpected error. {data}\")\n\n        # ... (processing data omitted for brevity)\n\n        with open(cache_path, \"w\", encoding=\"utf-8\") as f:\n            json.dump(cache, f, ensure_ascii=False)\n\n        return cache"
    }
  },
  {
    "metadata": {
      "package_name": "github_heatmap-1.2.7",
      "total_matches": 2
    }
  }
]