[
  {
    "pyfile": "vinegar.py",
    "code_snippet": "import sys\nimport traceback\ntry:\n    import exceptions as exceptions_module\nexcept ImportError:\n    import builtins as exceptions_module\ntry:\n    from types import InstanceType, ClassType\nexcept ImportError:\n    ClassType = type\n\nfrom rpyc.core import brine\nfrom rpyc.core import consts\nfrom rpyc import version\n\n_generic_exceptions_cache = {}\n_exception_classes_cache = {}\n\nclass GenericException(Exception):\n    \"\"\"A 'generic exception' that is raised when the exception the gotten from\n    the other party cannot be instantiated locally\"\"\"\n    pass\n\ndef _get_exception_class(cls):\n    if cls in _exception_classes_cache:\n        return _exception_classes_cache[cls]\n\n    # subclass the exception class' to provide a version of __str__ that supports _remote_tb\n    class Derived(cls):\n        def __str__(self):\n            try:\n                text = cls.__str__(self)\n            except Exception:\n                text = \"<Unprintable exception>\"\n            if hasattr(self, \"_remote_tb\"):\n                text += REMOTE_LINE.format(self._remote_tb.count(REMOTE_LINE_START) + 1)\n                text += self._remote_tb\n            return text\n\n        def __repr__(self):\n            return str(self)\n\n    Derived.__name__ = cls.__name__\n    Derived.__module__ = cls.__module__\n    _exception_classes_cache[cls] = Derived\n    return Derived\n\ndef load(val, import_custom_exceptions, instantiate_custom_exceptions, instantiate_oldstyle_exceptions):\n    \"\"\"\n    Loads a dumped exception (the tuple returned by :func:`dump`) info a\n    throwable exception object. If the exception cannot be instantiated for any\n    reason (i.e., the security parameters do not allow it, or the exception\n    class simply doesn't exist on the local machine), a :class:`GenericException`\n    instance will be returned instead, containing all of the original exception's\n    details.\n\n    :param val: the dumped exception\n    :param import_custom_exceptions: whether to allow this function to import custom modules\n                                     (imposes a security risk)\n    :param instantiate_custom_exceptions: whether to allow this function to instantiate \"custom\n                                          exceptions\" (i.e., not one of the built-in exceptions,\n                                          such as ``ValueError``, ``OSError``, etc.)\n    :param instantiate_oldstyle_exceptions: whether to allow this function to instantiate exception\n                                            classes that do not derive from ``BaseException``.\n                                            This is required to support old-style exceptions.\n                                            Not applicable for Python 3 and above.\n\n    :returns: A throwable exception object\n    \"\"\"\n    if val == consts.EXC_STOP_ITERATION:\n        return StopIteration  # optimization\n    if type(val) is str:\n        return val  # deprecated string exceptions\n\n    (modname, clsname), args, attrs, tbtext = val\n\n    if import_custom_exceptions and modname not in sys.modules:\n        try:\n            __import__(modname, None, None, \"*\")\n        except Exception:\n            pass\n\n    if instantiate_custom_exceptions:\n        if modname in sys.modules:\n            cls = getattr(sys.modules[modname], clsname, None)\n        else:\n            cls = None\n    elif modname == exceptions_module.__name__:\n        cls = getattr(exceptions_module, clsname, None)\n    else:\n        cls = None\n\n    if not isinstance(cls, type) or not issubclass(cls, BaseException):\n        cls = None\n\n    if cls is None:\n        fullname = f\"{modname}.{clsname}\"\n        # py2: `type()` expects `str` not `unicode`!\n        fullname = str(fullname)\n        if fullname not in _generic_exceptions_cache:\n            fakemodule = {\"__module__\": f\"{__name__}/{modname}\"}\n            if isinstance(GenericException, ClassType):\n                _generic_exceptions_cache[fullname] = ClassType(fullname, (GenericException,), fakemodule)\n            else:\n                _generic_exceptions_cache[fullname] = type(fullname, (GenericException,), fakemodule)\n        cls = _generic_exceptions_cache[fullname]\n\n    cls = _get_exception_class(cls)\n\n    # support old-style exception classes\n    if ClassType is not type and isinstance(cls, ClassType):\n        exc = InstanceType(cls)\n    else:\n        exc = cls.__new__(cls)\n\n    exc.args = args\n    for name, attrval in attrs:\n        try:\n            setattr(exc, name, attrval)\n        except AttributeError:      # handle immutable attrs (@property)\n            pass\n\n    # When possible and relevant, warn the user about mismatch in major versions between remote and local\n    remote_ver = getattr(exc, \"_remote_version\", \"<version denied>\")\n    if remote_ver != \"<version denied>\" and remote_ver.split('.')[0] != str(version.version[0]):\n        _warn = '\\nWARNING: Remote is on RPyC {} and local is on RPyC {}.\\n\\n'\n        tbtext += _warn.format(remote_ver, version.__version__)\n\n    exc._remote_tb = tbtext\n    return exc\n",
    "pattern_analysis": {
      "api_sequence": [
        "sys.modules",
        "__import__",
        "getattr",
        "getattr",
        "setattr"
      ],
      "api_sequence_with_args": [
        "sys.modules",
        "__import__(modname, None, None, \"*\")",
        "getattr(sys.modules[modname], clsname, None)",
        "getattr(exceptions_module, clsname, None)",
        "setattr(exc, name, attrval)"
      ],
      "mapped_sequence": [
        {
          "api_name": "sys.modules",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "__import__",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "getattr",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "getattr",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "setattr",
          "id": "set_builtin_attr",
          "description": "Sets attribute on builtins object",
          "first_id": "persistence_stealth",
          "second_id": "stealth_techniques",
          "third_id": "warning_disabling"
        }
      ],
      "contextual_code": "def load(val, import_custom_exceptions, instantiate_custom_exceptions, instantiate_oldstyle_exceptions):\n    if import_custom_exceptions and modname not in sys.modules:\n        try:\n            __import__(modname, None, None, \"*\")\n        except Exception:\n            pass\n\n    if instantiate_custom_exceptions:\n        if modname in sys.modules:\n            cls = getattr(sys.modules[modname], clsname, None)\n        else:\n            cls = None\n    elif modname == exceptions_module.__name__:\n        cls = getattr(exceptions_module, clsname, None)\n    else:\n        cls = None\n\n    ...\n    for name, attrval in attrs:\n        try:\n            setattr(exc, name, attrval)\n        except AttributeError:\n            pass"
    }
  },
  {
    "metadata": {
      "package_name": "rpyc-6.0.1",
      "total_matches": 1
    }
  }
]