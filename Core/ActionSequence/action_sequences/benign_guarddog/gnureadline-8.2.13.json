[
  {
    "pyfile": "setup.py",
    "code_snippet": "# Relevant imports\nimport os\nimport sys\nfrom setuptools.command.build_ext import build_ext\nimport subprocess\n\n# Helper function used in flagged lines\ndef which_shell():\n    valid_paths = [\"/bin/bash\", \"/usr/local/bin/bash\", \"/bin/sh\"]\n    for path in valid_paths:\n        if os.path.exists(path):\n            return path\n    raise IOError(\"No Shell Found\")\n\n# Variable declarations and assignments used by flagged lines\nbuilding = False\nverbose = True\nfor s in sys.argv[1:]:\n    if s.startswith('bdist') or s.startswith('build') or s.startswith('install'):\n        building = True\n    if s in ['--quiet', '-q']:\n        verbose = False\n    if s in ['--verbose', '-v']:\n        verbose = True\n\n# Context block for flagged lines 79 and 82\n# (os.system usage for building the readline library)\nif building and not os.path.exists('readline/libreadline.a'):\n    shell_path = which_shell()\n    if verbose:\n        print(\"\\n============ Building the readline library ============\\n\")\n        os.system('cd rl && %s ./build.sh' % shell_path)\n        print(\"\\n============ Building the readline extension module ============\\n\")\n    else:\n        os.system('cd rl && %s ./build.sh > /dev/null 2>&1' % shell_path)\n    # Add symlink that simplifies include and link paths to real library\n    if not (os.path.exists('readline') or os.path.islink('readline')):\n        os.symlink(os.path.join('rl', 'readline-lib'), 'readline')\n\n# Context for flagged line 98 (subprocess.Popen usage in build_ext_subclass)\nclass build_ext_subclass(build_ext):\n    def build_extensions(self):\n        if sys.platform == 'darwin':\n            # Test the compiler that will actually be used to see if it likes flags\n            proc = subprocess.Popen(self.compiler.compiler + ['-v'],\n                                    stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                                    universal_newlines=True)\n            stdout, stderr = proc.communicate()\n            clang_mesg = \"clang: error: unknown argument: '-mno-fused-madd'\"\n            if proc.returncode and stderr.splitlines()[0].startswith(clang_mesg):\n                for ext in self.extensions:\n                    # Use temporary workaround to ignore invalid compiler option\n                    # Hopefully -mno-fused-madd goes away before this workaround!\n                    ext.extra_compile_args += ['-Wno-error=unused-command-line-argument-hard-error-in-future']\n        build_ext.build_extensions(self)\n",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.exists",
        "os.path.exists",
        "os.system",
        "os.path.exists",
        "os.path.islink",
        "os.path.join",
        "os.symlink",
        "subprocess.Popen",
        "subprocess.Popen.communicate"
      ],
      "api_sequence_with_args": [
        "os.path.exists(path)",
        "os.path.exists('readline/libreadline.a')",
        "os.system('cd rl && %s ./build.sh' % shell_path)",
        "os.path.exists('readline')",
        "os.path.islink('readline')",
        "os.path.join('rl', 'readline-lib')",
        "os.symlink(os.path.join('rl', 'readline-lib'), 'readline')",
        "subprocess.Popen(self.compiler.compiler + ['-v'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)",
        "subprocess.Popen.communicate()"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.system",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.path.islink",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.symlink",
          "id": "rename_file",
          "description": "Renames file or moves it to new location",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "subprocess.Popen",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "subprocess.Popen.communicate",
          "id": "read_process_stdout",
          "description": "Reads all bytes from process standard output",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        }
      ],
      "contextual_code": "# Helper function used in flagged lines\ndef which_shell():\n    valid_paths = [\"/bin/bash\", \"/usr/local/bin/bash\", \"/bin/sh\"]\n    for path in valid_paths:\n        if os.path.exists(path):\n            return path\n    raise IOError(\"No Shell Found\")\n\n# Variable declarations and assignments used by flagged lines\nbuilding = False\nverbose = True\nfor s in sys.argv[1:]:\n    if s.startswith('bdist') or s.startswith('build') or s.startswith('install'):\n        building = True\n    if s in ['--quiet', '-q']:\n        verbose = False\n    if s in ['--verbose', '-v']:\n        verbose = True\n\n# Context block for flagged lines (os.system usage for building the readline library)\nif building and not os.path.exists('readline/libreadline.a'):\n    shell_path = which_shell()\n    if verbose:\n        print(\"\\n============ Building the readline library ============\\n\")\n        os.system('cd rl && %s ./build.sh' % shell_path)\n        print(\"\\n============ Building the readline extension module ============\\n\")\n    else:\n        os.system('cd rl && %s ./build.sh > /dev/null 2>&1' % shell_path)\n    # Add symlink that simplifies include and link paths to real library\n    if not (os.path.exists('readline') or os.path.islink('readline')):\n        os.symlink(os.path.join('rl', 'readline-lib'), 'readline')\n\n# Context for subprocess.Popen usage in build_ext_subclass\nclass build_ext_subclass(build_ext):\n    def build_extensions(self):\n        if sys.platform == 'darwin':\n            # Test the compiler that will actually be used to see if it likes flags\n            proc = subprocess.Popen(self.compiler.compiler + ['-v'],\n                                    stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                                    universal_newlines=True)\n            stdout, stderr = proc.communicate()\n            clang_mesg = \"clang: error: unknown argument: '-mno-fused-madd'\"\n            if proc.returncode and stderr.splitlines()[0].startswith(clang_mesg):\n                for ext in self.extensions:\n                    ext.extra_compile_args += ['-Wno-error=unused-command-line-argument-hard-error-in-future']\n        build_ext.build_extensions(self)\n"
    }
  },
  {
    "metadata": {
      "package_name": "gnureadline-8.2.13",
      "total_matches": 3
    }
  }
]