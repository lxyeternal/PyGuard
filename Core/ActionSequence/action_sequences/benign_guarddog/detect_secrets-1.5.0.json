[
  {
    "pyfile": "ibm_cos_hmac.py",
    "code_snippet": "import datetime\nimport hashlib\nimport hmac\nfrom typing import List\n\nimport requests\n\nfrom ..constants import VerifiedResult\nfrom ..util.code_snippet import CodeSnippet\nfrom .base import RegexBasedDetector\n\n\ndef verify_ibm_cos_hmac_credentials(\n    access_key: str,\n    secret_key: str,\n    host: str = 's3.us.cloud-object-storage.appdomain.cloud',\n) -> bool:\n    response = query_ibm_cos_hmac(access_key, secret_key, host)\n    return response.status_code == 200\n\n\ndef query_ibm_cos_hmac(\n    access_key: str,\n    secret_key: str,\n    host: str = 's3.us.cloud-object-storage.appdomain.cloud',\n) -> requests.Response:\n    # Sample code referenced from link below\n    # https://cloud.ibm.com/docs/services/cloud-object-storage/api-reference?topic=cloud-object-storage-hmac-signature  # noqa: E501\n\n    # request elements\n    http_method = 'GET'\n    # region is a wildcard value that takes the place of the AWS region value\n    # as COS doesn't use the same conventions for regions, this parameter can accept any string\n    region = 'us-standard'\n    endpoint = 'https://{}'.format(host)\n    bucket = ''  # add a '/' before the bucket name to list buckets\n    object_key = ''\n    request_parameters = ''\n\n    # assemble the standardized request\n    time = datetime.datetime.utcnow()\n    timestamp = time.strftime('%Y%m%dT%H%M%SZ')\n    datestamp = time.strftime('%Y%m%d')\n\n    standardized_resource = '/' + bucket + '/' + object_key\n    standardized_querystring = request_parameters\n    standardized_headers = 'host:' + host + '\\n' + 'x-amz-date:' + timestamp + '\\n'\n    signed_headers = 'host;x-amz-date'\n    payload_hash = hashlib.sha256(''.encode('utf-8')).hexdigest()\n\n    standardized_request = (\n        http_method + '\\n'\n        + standardized_resource + '\\n'\n        + standardized_querystring + '\\n'\n        + standardized_headers + '\\n'\n        + signed_headers + '\\n'\n        + payload_hash\n    ).encode('utf-8')\n\n    # assemble string-to-sign\n    hashing_algorithm = 'AWS4-HMAC-SHA256'\n    credential_scope = datestamp + '/' + region + '/' + 's3' + '/' + 'aws4_request'\n    sts = (\n        hashing_algorithm + '\\n'\n        + timestamp + '\\n'\n        + credential_scope + '\\n'\n        + hashlib.sha256(standardized_request).hexdigest()\n    )\n\n    # generate the signature\n    signature_key = createSignatureKey(secret_key, datestamp, region, 's3')\n    signature = hmac.new(\n        signature_key,\n        (sts).encode('utf-8'),\n        hashlib.sha256,\n    ).hexdigest()\n\n    # assemble all elements into the 'authorization' header\n    v4auth_header = (\n        hashing_algorithm + ' '\n        + 'Credential=' + access_key + '/' + credential_scope + ', '\n        + 'SignedHeaders=' + signed_headers + ', '\n        + 'Signature=' + signature\n    )\n\n    # create and send the request\n    headers = {'x-amz-date': timestamp, 'Authorization': v4auth_header}\n    # the 'requests' package automatically adds the required 'host' header\n    request_url = endpoint + standardized_resource + standardized_querystring\n\n    request = requests.get(request_url, headers=headers)\n\n    return request\n\n\ndef createSignatureKey(key: str, datestamp: str, region: str, service: str) -> bytes:\n    keyDate = hash(('AWS4' + key).encode('utf-8'), datestamp)\n    keyString = hash(keyDate, region)\n    keyService = hash(keyString, service)\n    keySigning = hash(keyService, 'aws4_request')\n    return keySigning\n\n\ndef hash(key: bytes, msg: str) -> bytes:\n    return hmac.new(key, msg.encode('utf-8'), hashlib.sha256).digest()\n",
    "pattern_analysis": {
      "api_sequence": [
        "datetime.datetime.utcnow",
        "datetime.datetime.strftime",
        "datetime.datetime.strftime",
        "hashlib.sha256",
        "hashlib.sha256",
        "hmac.new",
        "hmac.new",
        "hmac.new",
        "hmac.new",
        "hmac.new",
        "requests.get"
      ],
      "api_sequence_with_args": [
        "datetime.datetime.utcnow()",
        "datetime.datetime.strftime('%Y%m%dT%H%M%SZ')",
        "datetime.datetime.strftime('%Y%m%d')",
        "hashlib.sha256(''.encode('utf-8')).hexdigest()",
        "hashlib.sha256(standardized_request).hexdigest()",
        "hmac.new(('AWS4' + key).encode('utf-8'), datestamp.encode('utf-8'), hashlib.sha256).digest()",
        "hmac.new(keyDate, region.encode('utf-8'), hashlib.sha256).digest()",
        "hmac.new(keyString, service.encode('utf-8'), hashlib.sha256).digest()",
        "hmac.new(keyService, 'aws4_request'.encode('utf-8'), hashlib.sha256).digest()",
        "hmac.new(signature_key, sts.encode('utf-8'), hashlib.sha256).hexdigest()",
        "requests.get(request_url, headers=headers)"
      ],
      "mapped_sequence": [
        {
          "api_name": "datetime.datetime.utcnow",
          "id": "get_current_time",
          "description": "Returns current time in seconds since epoch",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "datetime.datetime.strftime",
          "id": "format_local_time",
          "description": "Formats local time tuple as string",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "datetime.datetime.strftime",
          "id": "format_local_time",
          "description": "Formats local time tuple as string",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "hashlib.sha256",
          "id": "create_sha256_hash",
          "description": "Creates SHA-256 hash object from encoded string",
          "first_id": "encryption_hashing",
          "second_id": "hash_calculation",
          "third_id": "hash_object_creation"
        },
        {
          "api_name": "hashlib.sha256",
          "id": "create_sha256_hash",
          "description": "Creates SHA-256 hash object from encoded string",
          "first_id": "encryption_hashing",
          "second_id": "hash_calculation",
          "third_id": "hash_object_creation"
        },
        {
          "api_name": "hmac.new",
          "id": "create_sha256_hash",
          "description": "Creates SHA-256 hash object from encoded string",
          "first_id": "encryption_hashing",
          "second_id": "hash_calculation",
          "third_id": "hash_object_creation"
        },
        {
          "api_name": "hmac.new",
          "id": "create_sha256_hash",
          "description": "Creates SHA-256 hash object from encoded string",
          "first_id": "encryption_hashing",
          "second_id": "hash_calculation",
          "third_id": "hash_object_creation"
        },
        {
          "api_name": "hmac.new",
          "id": "create_sha256_hash",
          "description": "Creates SHA-256 hash object from encoded string",
          "first_id": "encryption_hashing",
          "second_id": "hash_calculation",
          "third_id": "hash_object_creation"
        },
        {
          "api_name": "hmac.new",
          "id": "create_sha256_hash",
          "description": "Creates SHA-256 hash object from encoded string",
          "first_id": "encryption_hashing",
          "second_id": "hash_calculation",
          "third_id": "hash_object_creation"
        },
        {
          "api_name": "hmac.new",
          "id": "create_sha256_hash",
          "description": "Creates SHA-256 hash object from encoded string",
          "first_id": "encryption_hashing",
          "second_id": "hash_calculation",
          "third_id": "hash_object_creation"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        }
      ],
      "contextual_code": "import datetime\nimport hashlib\nimport hmac\nimport requests\n\ndef query_ibm_cos_hmac(\n    access_key: str,\n    secret_key: str,\n    host: str = 's3.us.cloud-object-storage.appdomain.cloud',\n) -> requests.Response:\n    http_method = 'GET'\n    region = 'us-standard'\n    endpoint = 'https://{}'.format(host)\n    bucket = ''\n    object_key = ''\n    request_parameters = ''\n\n    time = datetime.datetime.utcnow()\n    timestamp = time.strftime('%Y%m%dT%H%M%SZ')\n    datestamp = time.strftime('%Y%m%d')\n\n    standardized_resource = '/' + bucket + '/' + object_key\n    standardized_querystring = request_parameters\n    standardized_headers = 'host:' + host + '\\n' + 'x-amz-date:' + timestamp + '\\n'\n    signed_headers = 'host;x-amz-date'\n    payload_hash = hashlib.sha256(''.encode('utf-8')).hexdigest()\n\n    standardized_request = (\n        http_method + '\\n'\n        + standardized_resource + '\\n'\n        + standardized_querystring + '\\n'\n        + standardized_headers + '\\n'\n        + signed_headers + '\\n'\n        + payload_hash\n    ).encode('utf-8')\n\n    hashing_algorithm = 'AWS4-HMAC-SHA256'\n    credential_scope = datestamp + '/' + region + '/' + 's3' + '/' + 'aws4_request'\n    sts = (\n        hashing_algorithm + '\\n'\n        + timestamp + '\\n'\n        + credential_scope + '\\n'\n        + hashlib.sha256(standardized_request).hexdigest()\n    )\n\n    signature_key = createSignatureKey(secret_key, datestamp, region, 's3')\n    signature = hmac.new(\n        signature_key,\n        (sts).encode('utf-8'),\n        hashlib.sha256,\n    ).hexdigest()\n\n    v4auth_header = (\n        hashing_algorithm + ' '\n        + 'Credential=' + access_key + '/' + credential_scope + ', '\n        + 'SignedHeaders=' + signed_headers + ', '\n        + 'Signature=' + signature\n    )\n\n    headers = {'x-amz-date': timestamp, 'Authorization': v4auth_header}\n    request_url = endpoint + standardized_resource + standardized_querystring\n\n    request = requests.get(request_url, headers=headers)\n\n    return request\n\ndef createSignatureKey(key: str, datestamp: str, region: str, service: str) -> bytes:\n    keyDate = hash(('AWS4' + key).encode('utf-8'), datestamp)\n    keyString = hash(keyDate, region)\n    keyService = hash(keyString, service)\n    keySigning = hash(keyService, 'aws4_request')\n    return keySigning\n\ndef hash(key: bytes, msg: str) -> bytes:\n    return hmac.new(key, msg.encode('utf-8'), hashlib.sha256).digest()"
    }
  },
  {
    "pyfile": "telegram_token.py",
    "code_snippet": "import re\n\nimport requests\n\nfrom ..constants import VerifiedResult\nfrom detect_secrets.plugins.base import RegexBasedDetector\n\nclass TelegramBotTokenDetector(RegexBasedDetector):\n    \"\"\"Scans for Telegram bot tokens.\"\"\"\n    secret_type = 'Telegram Bot Token'\n\n    denylist = [\n        # refs https://core.telegram.org/bots/api#authorizing-your-bot\n        re.compile(r'\\d{8,10}:[0-9A-Za-z_-]{35}'),\n    ]\n\n    def verify(self, secret: str) -> VerifiedResult:  # pragma: no cover\n        response = requests.get(\n            'https://api.telegram.org/bot{}/getMe'.format(\n                secret,\n            ),\n        )\n        return (\n            VerifiedResult.VERIFIED_TRUE\n            if response.status_code == 200\n            else VerifiedResult.VERIFIED_FALSE\n        )\n",
    "pattern_analysis": {
      "api_sequence": [
        "re.compile",
        "requests.get"
      ],
      "api_sequence_with_args": [
        "re.compile(r'\\d{8,10}:[0-9A-Za-z_-]{35}')",
        "requests.get('https://api.telegram.org/bot{}/getMe'.format(secret))"
      ],
      "mapped_sequence": [
        {
          "api_name": "re.compile",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        }
      ],
      "contextual_code": "import re\nimport requests\n\nclass TelegramBotTokenDetector(RegexBasedDetector):\n    denylist = [\n        re.compile(r'\\d{8,10}:[0-9A-Za-z_-]{35}'),\n    ]\n\n    def verify(self, secret: str) -> VerifiedResult:\n        response = requests.get(\n            'https://api.telegram.org/bot{}/getMe'.format(secret),\n        )\n        return (\n            VerifiedResult.VERIFIED_TRUE\n            if response.status_code == 200\n            else VerifiedResult.VERIFIED_FALSE\n        )"
    }
  },
  {
    "metadata": {
      "package_name": "detect_secrets-1.5.0",
      "total_matches": 3
    }
  }
]