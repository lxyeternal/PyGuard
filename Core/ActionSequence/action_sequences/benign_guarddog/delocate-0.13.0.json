[
  {
    "pyfile": "setup.py",
    "code_snippet": "from os.path import abspath, dirname\nfrom os.path import join as pjoin\nfrom subprocess import check_call\n\nfrom setuptools import Extension, setup\n\nHERE = abspath(dirname(__file__))\nLIBS = pjoin(HERE, \"libs\")\nextlib = pjoin(LIBS, \"libextfunc.dylib\")\n\n# Compile external extension with absolute path in install id\narch_flags = [\"-arch\", \"arm64\", \"-arch\", \"x86_64\"]  # dual arch\ncheck_call(\n    [\"cc\", \"-dynamiclib\", pjoin(LIBS, \"extfunc.c\"), \"-o\", extlib] + arch_flags\n)\ncheck_call([\"install_name_tool\", \"-id\", \"libextfunc.dylib\", extlib])\n\nexts = [\n    Extension(\n        \"fakepkg1.subpkg.module2\",\n        [pjoin(\"fakepkg1\", \"subpkg\", \"module2.c\")],\n        libraries=[\"extfunc\"],\n        extra_compile_args=arch_flags,\n        extra_link_args=[\"-L\" + LIBS] + arch_flags,\n        py_limited_api=True,\n    )\n]\n\nsetup(\n    ext_modules=exts,\n    name=\"fakepkg1\",\n    version=\"1.0\",\n    scripts=[pjoin(\"scripts\", \"fakescript.py\")],\n    package_data={\"fakepkg1\": [\"ascript\"]},\n    packages=[\"fakepkg1\", \"fakepkg1.subpkg\", \"fakepkg1.tests\"],\n)\n",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.abspath",
        "os.path.dirname",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "subprocess.check_call",
        "os.path.join",
        "subprocess.check_call",
        "setuptools.Extension",
        "setuptools.setup"
      ],
      "api_sequence_with_args": [
        "os.path.abspath(os.path.dirname(__file__))",
        "os.path.dirname(__file__)",
        "os.path.join(HERE, \"libs\")",
        "os.path.join(LIBS, \"libextfunc.dylib\")",
        "os.path.join(LIBS, \"extfunc.c\")",
        "subprocess.check_call([\"cc\", \"-dynamiclib\", os.path.join(LIBS, \"extfunc.c\"), \"-o\", extlib] + arch_flags)",
        "os.path.join(\"scripts\", \"fakescript.py\")",
        "subprocess.check_call([\"install_name_tool\", \"-id\", \"libextfunc.dylib\", extlib])",
        "setuptools.Extension(\"fakepkg1.subpkg.module2\", [os.path.join(\"fakepkg1\", \"subpkg\", \"module2.c\")], libraries=[\"extfunc\"], extra_compile_args=arch_flags, extra_link_args=[\"-L\" + LIBS] + arch_flags, py_limited_api=True)",
        "setuptools.setup(ext_modules=exts, name=\"fakepkg1\", version=\"1.0\", scripts=[os.path.join(\"scripts\", \"fakescript.py\")], package_data={\"fakepkg1\": [\"ascript\"]}, packages=[\"fakepkg1\", \"fakepkg1.subpkg\", \"fakepkg1.tests\"])"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.abspath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.dirname",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "subprocess.check_call",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "subprocess.check_call",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "setuptools.Extension",
          "id": "configure_package_install",
          "description": "Configures and initiates Python package installation",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "package_configuration"
        },
        {
          "api_name": "setuptools.setup",
          "id": "configure_package_install",
          "description": "Configures and initiates Python package installation",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "package_configuration"
        }
      ],
      "contextual_code": "from os.path import abspath, dirname\nfrom os.path import join as pjoin\nfrom subprocess import check_call\nfrom setuptools import Extension, setup\n\nHERE = abspath(dirname(__file__))\nLIBS = pjoin(HERE, \"libs\")\nextlib = pjoin(LIBS, \"libextfunc.dylib\")\n\narch_flags = [\"-arch\", \"arm64\", \"-arch\", \"x86_64\"]\ncheck_call([\"cc\", \"-dynamiclib\", pjoin(LIBS, \"extfunc.c\"), \"-o\", extlib] + arch_flags)\ncheck_call([\"install_name_tool\", \"-id\", \"libextfunc.dylib\", extlib])\n\nexts = [\n    Extension(\n        \"fakepkg1.subpkg.module2\",\n        [pjoin(\"fakepkg1\", \"subpkg\", \"module2.c\")],\n        libraries=[\"extfunc\"],\n        extra_compile_args=arch_flags,\n        extra_link_args=[\"-L\" + LIBS] + arch_flags,\n        py_limited_api=True,\n    )\n]\n\nsetup(\n    ext_modules=exts,\n    name=\"fakepkg1\",\n    version=\"1.0\",\n    scripts=[pjoin(\"scripts\", \"fakescript.py\")],\n    package_data={\"fakepkg1\": [\"ascript\"]},\n    packages=[\"fakepkg1\", \"fakepkg1.subpkg\", \"fakepkg1.tests\"],\n)\n"
    }
  },
  {
    "pyfile": "setup.py",
    "code_snippet": "import subprocess\nfrom pathlib import Path\n\nfrom setuptools import Extension, setup  # type: ignore\n\nHERE = Path(__file__).parent.resolve(strict=True)\nLIBS = HERE / \"libs\"\nARCH_FLAGS = [\"-arch\", \"arm64\", \"-arch\", \"x86_64\"]  # Dual architecture.\n\nsubprocess.run(\n    [\n        \"cc\",\n        str(LIBS / \"extfunc2.c\"),\n        \"-dynamiclib\",\n        \"-install_name\",\n        \"@rpath/libextfunc2_rpath.dylib\",\n        \"-o\",\n        str(LIBS / \"libextfunc2_rpath.dylib\"),\n    ]\n    + ARCH_FLAGS,\n    check=True,\n)\n",
    "pattern_analysis": {
      "api_sequence": [
        "pathlib.Path.__file__",
        "pathlib.Path.parent",
        "pathlib.Path.resolve",
        "subprocess.run"
      ],
      "api_sequence_with_args": [
        "pathlib.Path(__file__)",
        "pathlib.Path(__file__).parent",
        "pathlib.Path(__file__).parent.resolve(strict=True)",
        "subprocess.run([\"cc\", str(LIBS / \"extfunc2.c\"), \"-dynamiclib\", \"-install_name\", \"@rpath/libextfunc2_rpath.dylib\", \"-o\", str(LIBS / \"libextfunc2_rpath.dylib\")] + ARCH_FLAGS, check=True)"
      ],
      "mapped_sequence": [
        {
          "api_name": "pathlib.Path.__file__",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "pathlib.Path.parent",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "pathlib.Path.resolve",
          "id": "path_special_operations",
          "description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "subprocess.run",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        }
      ],
      "contextual_code": "from pathlib import Path\nimport subprocess\n\nHERE = Path(__file__).parent.resolve(strict=True)\nLIBS = HERE / \"libs\"\nARCH_FLAGS = [\"-arch\", \"arm64\", \"-arch\", \"x86_64\"]\n\nsubprocess.run(\n    [\n        \"cc\",\n        str(LIBS / \"extfunc2.c\"),\n        \"-dynamiclib\",\n        \"-install_name\",\n        \"@rpath/libextfunc2_rpath.dylib\",\n        \"-o\",\n        str(LIBS / \"libextfunc2_rpath.dylib\"),\n    ]\n    + ARCH_FLAGS,\n    check=True,\n)"
    }
  },
  {
    "pyfile": "setup.py",
    "code_snippet": "from os.path import abspath, dirname\nfrom os.path import join as pjoin\nfrom subprocess import check_call\n\nfrom setuptools import Extension, setup\n\nHERE = abspath(dirname(__file__))\nLIBS = pjoin(HERE, \"libs\")\n\narch_flags = [\"-arch\", \"arm64\", \"-arch\", \"x86_64\"]  # dual arch\n\nEXTLIB2 = pjoin(LIBS, \"libextfunc2_rpath.dylib\")\nINSTALL_NAME2 = \"@rpath/libextfunc2_rpath.dylib\"\ncheck_call(\n    [\n        \"cc\",\n        pjoin(LIBS, \"extfunc2.c\"),\n        \"-dynamiclib\",\n        \"-install_name\",\n        INSTALL_NAME2,\n        \"-o\",\n        EXTLIB2,\n    ]\n    + arch_flags\n)\n\nEXTLIB = pjoin(LIBS, \"libextfunc_rpath.dylib\")\nINSTALL_NAME = \"@rpath/libextfunc_rpath.dylib\"\ncheck_call(\n    [\n        \"cc\",\n        pjoin(LIBS, \"extfunc.c\"),\n        \"-dynamiclib\",\n        \"-install_name\",\n        INSTALL_NAME,\n        \"-L\",\n        LIBS,\n        \"-l\",\n        \"extfunc2_rpath\",\n        \"-rpath\",\n        \"@executable_path/\",\n        \"-rpath\",\n        \"@loader_path/\",\n        \"-o\",\n        EXTLIB,\n    ]\n    + arch_flags\n)\n\ncheck_call([\"codesign\", \"--sign\", \"-\", EXTLIB])\ncheck_call([\"codesign\", \"--sign\", \"-\", EXTLIB2])",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.abspath",
        "os.path.dirname",
        "os.path.join",
        "os.path.join",
        "subprocess.check_call",
        "os.path.join",
        "subprocess.check_call",
        "subprocess.check_call",
        "subprocess.check_call"
      ],
      "api_sequence_with_args": [
        "os.path.abspath(os.path.dirname(__file__))",
        "os.path.dirname(__file__)",
        "os.path.join(HERE, \"libs\")",
        "os.path.join(LIBS, \"libextfunc2_rpath.dylib\")",
        "subprocess.check_call([\"cc\", os.path.join(LIBS, \"extfunc2.c\"), \"-dynamiclib\", \"-install_name\", INSTALL_NAME2, \"-o\", EXTLIB2] + arch_flags)",
        "os.path.join(LIBS, \"libextfunc_rpath.dylib\")",
        "subprocess.check_call([\"cc\", os.path.join(LIBS, \"extfunc.c\"), \"-dynamiclib\", \"-install_name\", INSTALL_NAME, \"-L\", LIBS, \"-l\", \"extfunc2_rpath\", \"-rpath\", \"@executable_path/\", \"-rpath\", \"@loader_path/\", \"-o\", EXTLIB] + arch_flags)",
        "subprocess.check_call([\"codesign\", \"--sign\", \"-\", EXTLIB])",
        "subprocess.check_call([\"codesign\", \"--sign\", \"-\", EXTLIB2])"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.abspath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.dirname",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "subprocess.check_call",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "subprocess.check_call",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "subprocess.check_call",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "subprocess.check_call",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        }
      ],
      "contextual_code": "from os.path import abspath, dirname\nfrom os.path import join as pjoin\nfrom subprocess import check_call\n\nHERE = abspath(dirname(__file__))\nLIBS = pjoin(HERE, \"libs\")\n\narch_flags = [\"-arch\", \"arm64\", \"-arch\", \"x86_64\"]  # dual arch\n\nEXTLIB2 = pjoin(LIBS, \"libextfunc2_rpath.dylib\")\nINSTALL_NAME2 = \"@rpath/libextfunc2_rpath.dylib\"\ncheck_call(\n    [\n        \"cc\",\n        pjoin(LIBS, \"extfunc2.c\"),\n        \"-dynamiclib\",\n        \"-install_name\",\n        INSTALL_NAME2,\n        \"-o\",\n        EXTLIB2,\n    ]\n    + arch_flags\n)\n\nEXTLIB = pjoin(LIBS, \"libextfunc_rpath.dylib\")\nINSTALL_NAME = \"@rpath/libextfunc_rpath.dylib\"\ncheck_call(\n    [\n        \"cc\",\n        pjoin(LIBS, \"extfunc.c\"),\n        \"-dynamiclib\",\n        \"-install_name\",\n        INSTALL_NAME,\n        \"-L\",\n        LIBS,\n        \"-l\",\n        \"extfunc2_rpath\",\n        \"-rpath\",\n        \"@executable_path/\",\n        \"-rpath\",\n        \"@loader_path/\",\n        \"-o\",\n        EXTLIB,\n    ]\n    + arch_flags\n)\n\ncheck_call([\"codesign\", \"--sign\", \"-\", EXTLIB])\ncheck_call([\"codesign\", \"--sign\", \"-\", EXTLIB2])"
    }
  },
  {
    "pyfile": "setup.py",
    "code_snippet": "import subprocess\nfrom pathlib import Path\n\nfrom setuptools import Extension, setup  # type: ignore\n\nHERE = Path(__file__).parent.resolve(strict=True)\nLIBS = HERE / \"libs\"\nARCH_FLAGS = [\"-arch\", \"arm64\", \"-arch\", \"x86_64\"]  # Dual architecture.\n\nsubprocess.run(\n    [\n        \"cc\",\n        str(LIBS / \"extfunc2.c\"),\n        \"-dynamiclib\",\n        \"-install_name\",\n        \"@rpath/libextfunc2_rpath.dylib\",\n        \"-o\",\n        str(LIBS / \"libextfunc2_rpath.dylib\"),\n    ]\n    + ARCH_FLAGS,\n    check=True,\n)\n",
    "pattern_analysis": {
      "api_sequence": [
        "pathlib.Path.__file__",
        "pathlib.Path.parent",
        "pathlib.Path.resolve",
        "subprocess.run"
      ],
      "api_sequence_with_args": [
        "pathlib.Path(__file__)",
        "pathlib.Path(__file__).parent",
        "pathlib.Path(__file__).parent.resolve(strict=True)",
        "subprocess.run([\"cc\", str(LIBS / \"extfunc2.c\"), \"-dynamiclib\", \"-install_name\", \"@rpath/libextfunc2_rpath.dylib\", \"-o\", str(LIBS / \"libextfunc2_rpath.dylib\")] + ARCH_FLAGS, check=True)"
      ],
      "mapped_sequence": [
        {
          "api_name": "pathlib.Path.__file__",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "pathlib.Path.parent",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "pathlib.Path.resolve",
          "id": "path_special_operations",
          "description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "subprocess.run",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        }
      ],
      "contextual_code": "import subprocess\nfrom pathlib import Path\n\nHERE = Path(__file__).parent.resolve(strict=True)\nLIBS = HERE / \"libs\"\nARCH_FLAGS = [\"-arch\", \"arm64\", \"-arch\", \"x86_64\"]\n\nsubprocess.run(\n    [\n        \"cc\",\n        str(LIBS / \"extfunc2.c\"),\n        \"-dynamiclib\",\n        \"-install_name\",\n        \"@rpath/libextfunc2_rpath.dylib\",\n        \"-o\",\n        str(LIBS / \"libextfunc2_rpath.dylib\"),\n    ]\n    + ARCH_FLAGS,\n    check=True,\n)"
    }
  },
  {
    "metadata": {
      "package_name": "delocate-0.13.0",
      "total_matches": 8
    }
  }
]