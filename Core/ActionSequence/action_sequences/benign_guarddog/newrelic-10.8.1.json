[
  {
    "pyfile": "object_names.py",
    "code_snippet": "import builtins\n\ndef callable_name(object, separator=\":\"):  # noqa: A002\n    \"\"\"Returns a string name identifying the supplied object. This will be\n    of the form 'module:object_path'.\n\n    If object were a function, then the name would be 'module:function. If\n    a class, 'module:class'. If a member function, 'module:class.function'.\n\n    By default the separator between the module path and the object path is\n    ':' but can be overridden if necessary. The convention used by the\n    Python Agent is that of using a ':' so it is clearer which part is the\n    module name and which is the name of the object.\n\n    \"\"\"\n\n    # The details are the module name and path. Join them with\n    # the specified separator.\n\n    return separator.join(object_context(object))\n\ndef expand_builtin_exception_name(name):\n    # Convert name to module:name format, if it's a builtin Exception.\n    # Otherwise, return it unchanged.\n\n    try:\n        exception = getattr(builtins, name)\n    except AttributeError:\n        pass\n    else:\n        if type(exception) is type and issubclass(exception, BaseException):\n            return callable_name(exception)\n\n    return name\n\ndef object_context(target):\n    \"\"\"Returns a tuple identifying the supplied object. This will be of\n    the form (module, object_path).\n\n    \"\"\"\n\n    # Check whether the target is a functools.partial so we\n    # can actually extract the contained function and use it.\n\n    if isinstance(target, functools.partial):\n        target = target.func\n\n    # Check whether we have previously calculated the name\n    # details for the target object and cached it against the\n    # actual target object.\n\n    details = getattr(target, \"_nr_object_path\", None)\n\n    # Disallow cache lookup for methods. In the case where the method\n    # is defined on a parent class, the name of the parent class is incorrectly\n    # returned. Avoid this by recalculating the details each time.\n\n    if details and not inspect.ismethod(target):\n        return details\n\n    # Check whether the object is actually one of our own\n    # wrapper classes. For these we use the convention that the\n    # attribute _nr_last_object refers to the wrapped object\n    # beneath the wrappers, there possibly being more than one\n    # wrapper. We use the wrapped object when deriving the name\n    # details and so bypass that chained calls that would need\n    # to occur through the wrappers to get the attributes of the\n    # original. For good measure, check that this wrapped object\n    # didn't have the name details cached against it already.\n\n    source = getattr(target, \"_nr_last_object\", None)\n\n    if source:\n        details = getattr(source, \"_nr_object_path\", None)\n\n        if details and not inspect.ismethod(source):\n            return details\n\n    else:\n        source = target\n\n    # If it wasn't cached we generate the name details and then\n    # attempt to cache them against the object.\n    details = _object_context(source)\n\n    try:\n        # If the original target is not the same as the source we\n        # derive the name details from, then we are dealing with\n        # a wrapper.\n\n        if target is not source:\n            # Although the original target could be a bound\n            # wrapper still cache it against it anyway, in case\n            # the bound wrapper is actually cached by the program\n            # and used more than the one time.\n\n            target._nr_object_path = details\n\n        # Finally attempt to cache the name details against what\n        # we derived them from. We may not be able to cache it if\n        # it is a type implemented as C code or an object with\n        # slots, which doesn't allow arbitrary addition of extra\n        # attributes. In that case, if we actually have to rely\n        # on the name details being cached against it and it fails,\n        # we have no choice but to recalculate them every time.\n        #\n        # XXX We could consider for the case where it fails\n        # storing it in a dictionary where the key is a weak\n        # function proxy with a callback to remove the entry if\n        # it ever expires. That would be another lookup we would\n        # have to make and we are already doing a lot so would\n        # have to properly benchmarks overhead before making that\n        # choice.\n\n        source._nr_object_path = details\n\n    except Exception:\n        pass\n\n    return details\n\ndef _object_context(object):  # noqa: A002\n    if inspect.ismethod(object):\n        # In Python 3, ismethod() returns True for bound methods. We\n        # need to distinguish between class methods and instance methods.\n        #\n        # First, test for class methods.\n\n        cname = getattr(object.__self__, \"__qualname__\", None)\n\n        # If it's not a class method, it must be an instance method.\n\n        if cname is None:\n            cname = object.__self__.__class__.__qualname__\n\n        path = f\"{cname}.{object.__name__}\"\n\n    else:\n        # For functions, the __qualname__ attribute gives us the name.\n        # This will be a qualified name including the context in which\n        # the function is defined in, such as an outer function in the\n        # case of a nested function.\n\n        path = getattr(object, \"__qualname__\", None)\n\n        # If there is no __qualname__ it should mean it is a type\n        # object of some sort. In this case we use the name from the\n        # __class__. That also can be nested so need to use the\n        # qualified name.\n\n        if path is None and hasattr(object, \"__class__\"):\n            path = object.__class__.__qualname__\n\n    # Now calculate the name of the module object is defined in.\n\n    owner = None\n\n    if inspect.ismethod(object):\n        if object.__self__ is not None:\n            cname = getattr(object.__self__, \"__name__\", None)\n            if cname is None:\n                owner = object.__self__.__class__  # bound method\n            else:\n                owner = object.__self__  # class method\n\n    mname = _module_name(owner or object)\n\n    return (mname, path)\n\ndef _module_name(object):  # noqa: A002\n    mname = None\n\n    # For the module name we first need to deal with the special\n    # case of getset and member descriptors. In this case we\n    # grab the module name from the class the descriptor was\n    # being used in which is held in __objclass__.\n\n    if hasattr(object, \"__objclass__\"):\n        mname = getattr(object.__objclass__, \"__module__\", None)\n\n    # The standard case is that we can just grab the __module__\n    # attribute from the object.\n\n    if mname is None:\n        mname = getattr(object, \"__module__\", None)\n\n    # An exception to that is builtins or any types which are\n    # implemented in C code. For that we need to grab the module\n    # name from the __class__. In doing this though, we need to\n    # ensure we check for case of a bound method. In that case\n    # we need to grab the module from the class of the instance\n    # to which the method is bound.\n\n    if mname is None:\n        self = getattr(object, \"__self__\", None)\n        if self is not None and hasattr(self, \"__class__\"):\n            mname = getattr(self.__class__, \"__module__\", None)\n\n    if mname is None and hasattr(object, \"__class__\"):\n        mname = getattr(object.__class__, \"__module__\", None)\n\n    # Finally, if the module name isn't in sys.modules, we will\n    # format it within '<>' to denote that it is a generated\n    # class of some sort where a fake namespace was used. This\n    # happens for example with namedtuple classes in Python 3.\n\n    if mname and mname not in sys.modules:\n        mname = f\"<{mname}>\"\n\n    # If unable to derive the module name, fallback to unknown.\n\n    if not mname:\n        mname = \"<unknown>\"\n\n    return mname\n",
    "pattern_analysis": {
      "api_sequence": [
        "getattr",
        "isinstance",
        "getattr",
        "getattr",
        "getattr",
        "getattr"
      ],
      "api_sequence_with_args": [
        "getattr(builtins, name)",
        "isinstance(target, functools.partial)",
        "getattr(target, \"_nr_object_path\", None)",
        "getattr(target, \"_nr_last_object\", None)",
        "getattr(source, \"_nr_object_path\", None)",
        "getattr(object, \"__qualname__\", None)"
      ],
      "mapped_sequence": [
        {
          "api_name": "getattr",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "isinstance",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "getattr",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "getattr",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "getattr",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "getattr",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        }
      ],
      "contextual_code": "import builtins\n\ndef expand_builtin_exception_name(name):\n    try:\n        exception = getattr(builtins, name)\n    except AttributeError:\n        pass\n    else:\n        if type(exception) is type and issubclass(exception, BaseException):\n            return callable_name(exception)\n    return name\n\ndef object_context(target):\n    if isinstance(target, functools.partial):\n        target = target.func\n    details = getattr(target, \"_nr_object_path\", None)\n    source = getattr(target, \"_nr_last_object\", None)\n    if source:\n        details = getattr(source, \"_nr_object_path\", None)\n    else:\n        source = target\n    details = _object_context(source)\n    try:\n        if target is not source:\n            target._nr_object_path = details\n        source._nr_object_path = details\n    except Exception:\n        pass\n    return details\n\ndef _object_context(object):\n    if inspect.ismethod(object):\n        cname = getattr(object.__self__, \"__qualname__\", None)\n        if cname is None:\n            cname = object.__self__.__class__.__qualname__\n        path = f\"{cname}.{object.__name__}\"\n    else:\n        path = getattr(object, \"__qualname__\", None)\n        if path is None and hasattr(object, \"__class__\"):\n            path = object.__class__.__qualname__\n    # ... (rest omitted for brevity)"
    }
  },
  {
    "pyfile": "decorators.py",
    "code_snippet": "import sys\n\nPY2 = sys.version_info[0] == 2\n\nif PY2:\n    string_types = basestring,\n\n    def exec_(_code_, _globs_=None, _locs_=None):\n        \"\"\"Execute code in a namespace.\"\"\"\n        if _globs_ is None:\n            frame = sys._getframe(1)\n            _globs_ = frame.f_globals\n            if _locs_ is None:\n                _locs_ = frame.f_locals\n            del frame\n        elif _locs_ is None:\n            _locs_ = _globs_\n        exec(\"\"\"exec _code_ in _globs_, _locs_\"\"\")\n\nelse:\n    string_types = str,\n\n    import builtins\n\n    exec_ = getattr(builtins, \"exec\")\n    del builtins",
    "pattern_analysis": {
      "api_sequence": [
        "sys.version_info",
        "sys._getframe",
        "exec",
        "getattr"
      ],
      "api_sequence_with_args": [
        "sys.version_info[0]",
        "sys._getframe(1)",
        "exec(\"\"\"exec _code_ in _globs_, _locs_\"\"\")",
        "getattr(builtins, \"exec\")"
      ],
      "mapped_sequence": [
        {
          "api_name": "sys.version_info",
          "id": "get_python_version",
          "description": "Retrieves Python interpreter version",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "sys._getframe",
          "id": "extract_call_stack",
          "description": "Extracts current call stack as FrameSummary objects",
          "first_id": "data_transformation_processing",
          "second_id": "collection_operations",
          "third_id": "iterator_operations"
        },
        {
          "api_name": "exec",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "getattr",
          "id": "get_global_symbols",
          "description": "Retrieves global symbol table as dictionary",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        }
      ],
      "contextual_code": "import sys\n\nPY2 = sys.version_info[0] == 2\n\nif PY2:\n    def exec_(_code_, _globs_=None, _locs_=None):\n        if _globs_ is None:\n            frame = sys._getframe(1)\n            _globs_ = frame.f_globals\n            if _locs_ is None:\n                _locs_ = frame.f_locals\n            del frame\n        elif _locs_ is None:\n            _locs_ = _globs_\n        exec(\"\"\"exec _code_ in _globs_, _locs_\"\"\")\nelse:\n    import builtins\n    exec_ = getattr(builtins, \"exec\")\n    del builtins"
    }
  },
  {
    "metadata": {
      "package_name": "newrelic-10.8.1",
      "total_matches": 2
    }
  }
]