[
  {
    "pyfile": "messages.py",
    "code_snippet": "import os\nfrom typing import Any, Dict\n\nimport requests\n\nNUCLEUS_URL = os.environ.get(\"LATCH_CLI_NUCLEUS_URL\", \"https://nucleus.latch.bio\")\nADD_MESSAGE_ENDPOINT = f\"{NUCLEUS_URL}/sdk/add-task-execution-message\"\n\n\ndef message(typ: str, data: Dict[str, Any]) -> None:\n    \"\"\"Display a message prominently on the Latch console during and after a\n    task execution.\n\n    The Latch platform first processes this message internally, then displays it\n    under your task's execution page.\n\n    Args:\n        typ:\n            A message type that determines how your message is displayed.\n            Currently one of 'info', 'warning', or 'error'.\n        data:\n            The data displayed on the Latch console, formatted as follows:\n            ```{'title': ..., 'body': ...}```.\n\n    Raises:\n        RuntimeError: If an internal error occurs while processing the message.\n\n    Example usage: ::\n\n        @small_task\n        def task():\n\n            ...\n\n            try:\n                ...\n            catch ValueError:\n                title = 'Invalid sample ID column selected'\n                body = 'Your file indicates that sample columns a, b are valid'\n                message(type='error', data={'title': title, 'body': body})\n\n            ...\n    \"\"\"\n    task_project = os.environ.get(\"FLYTE_INTERNAL_TASK_PROJECT\")\n    task_domain = os.environ.get(\"FLYTE_INTERNAL_TASK_DOMAIN\")\n    task_name = os.environ.get(\"FLYTE_INTERNAL_TASK_NAME\")\n    task_version = os.environ.get(\"FLYTE_INTERNAL_TASK_VERSION\")\n    task_attempt_number = os.environ.get(\"FLYTE_ATTEMPT_NUMBER\")\n    execution_token = os.environ.get(\"FLYTE_INTERNAL_EXECUTION_ID\")\n    array_index = os.environ.get(\"FLYTE_K8S_ARRAY_INDEX\")\n\n    if task_project is None:\n        print(f\"Local execution message:\\n[{typ}]: {data}\")\n        return\n\n    response = requests.post(\n        url=ADD_MESSAGE_ENDPOINT,\n        json={\n            \"execution_token\": execution_token,\n            \"task\": {\n                \"project\": task_project,\n                \"domain\": task_domain,\n                \"name\": task_name,\n                \"version\": task_version,\n            },\n            \"task_attempt_number\": task_attempt_number,\n            \"task_array_index\": array_index,\n            \"type\": typ,\n            \"data\": data,\n        },\n    )\n\n    if response.status_code != 200:\n        raise RuntimeError(\"Could not add task execution message to Latch.\")\n",
    "pattern_analysis": {
      "api_sequence": [
        "os.environ.get",
        "os.environ.get",
        "os.environ.get",
        "os.environ.get",
        "os.environ.get",
        "os.environ.get",
        "os.environ.get",
        "requests.post",
        "response.status_code"
      ],
      "api_sequence_with_args": [
        "os.environ.get(\"LATCH_CLI_NUCLEUS_URL\", \"https://nucleus.latch.bio\")",
        "os.environ.get(\"FLYTE_INTERNAL_TASK_PROJECT\")",
        "os.environ.get(\"FLYTE_INTERNAL_TASK_DOMAIN\")",
        "os.environ.get(\"FLYTE_INTERNAL_TASK_NAME\")",
        "os.environ.get(\"FLYTE_INTERNAL_TASK_VERSION\")",
        "os.environ.get(\"FLYTE_ATTEMPT_NUMBER\")",
        "os.environ.get(\"FLYTE_INTERNAL_EXECUTION_ID\")",
        "os.environ.get(\"FLYTE_K8S_ARRAY_INDEX\")",
        "requests.post(url=ADD_MESSAGE_ENDPOINT, json={...})",
        "response.status_code"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.environ.get",
          "id": "get_env_vars",
          "description": "Retrieves environment variables mapping",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.environ.get",
          "id": "get_env_vars",
          "description": "Retrieves environment variables mapping",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.environ.get",
          "id": "get_env_vars",
          "description": "Retrieves environment variables mapping",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.environ.get",
          "id": "get_env_vars",
          "description": "Retrieves environment variables mapping",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.environ.get",
          "id": "get_env_vars",
          "description": "Retrieves environment variables mapping",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.environ.get",
          "id": "get_env_vars",
          "description": "Retrieves environment variables mapping",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.environ.get",
          "id": "get_env_vars",
          "description": "Retrieves environment variables mapping",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "requests.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "response.status_code",
          "id": "get_http_status",
          "description": "Retrieves HTTP response status code",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        }
      ],
      "contextual_code": "import os\nimport requests\n\nNUCLEUS_URL = os.environ.get(\"LATCH_CLI_NUCLEUS_URL\", \"https://nucleus.latch.bio\")\nADD_MESSAGE_ENDPOINT = f\"{NUCLEUS_URL}/sdk/add-task-execution-message\"\n\ndef message(typ: str, data: dict) -> None:\n    task_project = os.environ.get(\"FLYTE_INTERNAL_TASK_PROJECT\")\n    task_domain = os.environ.get(\"FLYTE_INTERNAL_TASK_DOMAIN\")\n    task_name = os.environ.get(\"FLYTE_INTERNAL_TASK_NAME\")\n    task_version = os.environ.get(\"FLYTE_INTERNAL_TASK_VERSION\")\n    task_attempt_number = os.environ.get(\"FLYTE_ATTEMPT_NUMBER\")\n    execution_token = os.environ.get(\"FLYTE_INTERNAL_EXECUTION_ID\")\n    array_index = os.environ.get(\"FLYTE_K8S_ARRAY_INDEX\")\n\n    if task_project is None:\n        print(f\"Local execution message:\\n[{typ}]: {data}\")\n        return\n\n    response = requests.post(\n        url=ADD_MESSAGE_ENDPOINT,\n        json={\n            \"execution_token\": execution_token,\n            \"task\": {\n                \"project\": task_project,\n                \"domain\": task_domain,\n                \"name\": task_name,\n                \"version\": task_version,\n            },\n            \"task_attempt_number\": task_attempt_number,\n            \"task_array_index\": array_index,\n            \"type\": typ,\n            \"data\": data,\n        },\n    )\n\n    if response.status_code != 200:\n        raise RuntimeError(\"Could not add task execution message to Latch.\")"
    }
  },
  {
    "pyfile": "utils.py",
    "code_snippet": "import base64\nimport contextlib\nimport importlib.machinery as im\nimport importlib.util as iu\nimport io\nimport os\nimport sys\nimport typing\nfrom pathlib import Path\nfrom typing import (\n    TYPE_CHECKING,\n    Dict,\n    Iterable,\n    List,\n    Optional,\n    Tuple,\n    TypedDict,\n    Union,\n)\n\nimport boto3\nimport click\nimport docker\nimport requests\n\nfrom latch.utils import current_workspace\nfrom latch_sdk_config.latch import config\n\nif TYPE_CHECKING:\n    from ...centromere.ctx import _CentromereCtx\nelse:\n    _CentromereCtx = \"\"\n\n\ndef register_serialized_pkg(\n    files: List[Path],\n    token: Optional[str],\n    version: str,\n    workspace_id: str,\n    latch_register_url: str = config.api.workflow.register,\n) -> object:\n    if token is None:\n        token = os.environ.get(\"FLYTE_INTERNAL_EXECUTION_ID\", \"\")\n        if token != \"\":\n            headers = {\"Authorization\": f\"Latch-Execution-Token {token}\"}\n        else:\n            raise OSError(\n                \"The environment variable FLYTE_INTERNAL_EXECUTION_ID does not exist\"\n            )\n    else:\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n\n    serialize_files: Dict[str, Union[bytes, io.BufferedReader]] = {\n        \"version\": version.encode(\"utf-8\"),\n        \".latch_ws\": workspace_id.encode(\"utf-8\"),\n    }\n    with contextlib.ExitStack() as stack:\n        for file in files:\n            fh = open(file, \"rb\")\n            stack.enter_context(fh)\n\n            serialize_files[fh.name] = fh\n\n        response = requests.post(\n            latch_register_url, headers=headers, files=serialize_files\n        )\n        response.raise_for_status()\n        return response.json()\n",
    "pattern_analysis": {
      "api_sequence": [
        "os.environ.get",
        "open",
        "requests.post",
        "requests.Response.raise_for_status",
        "requests.Response.json"
      ],
      "api_sequence_with_args": [
        "os.environ.get(\"FLYTE_INTERNAL_EXECUTION_ID\", \"\")",
        "open(file, \"rb\")",
        "requests.post(latch_register_url, headers=headers, files=serialize_files)",
        "response.raise_for_status()",
        "response.json()"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.environ.get",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "requests.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "requests.Response.raise_for_status",
          "id": "raise_http_error",
          "description": "Raises HTTPError if response status code indicates error",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "requests.Response.json",
          "id": "deserialize_json_response",
          "description": "Deserializes JSON response body to Python object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        }
      ],
      "contextual_code": "def register_serialized_pkg(\n    files: List[Path],\n    token: Optional[str],\n    version: str,\n    workspace_id: str,\n    latch_register_url: str = config.api.workflow.register,\n) -> object:\n    if token is None:\n        token = os.environ.get(\"FLYTE_INTERNAL_EXECUTION_ID\", \"\")\n        if token != \"\":\n            headers = {\"Authorization\": f\"Latch-Execution-Token {token}\"}\n        else:\n            raise OSError(\n                \"The environment variable FLYTE_INTERNAL_EXECUTION_ID does not exist\"\n            )\n    else:\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n\n    serialize_files: Dict[str, Union[bytes, io.BufferedReader]] = {\n        \"version\": version.encode(\"utf-8\"),\n        \".latch_ws\": workspace_id.encode(\"utf-8\"),\n    }\n    with contextlib.ExitStack() as stack:\n        for file in files:\n            fh = open(file, \"rb\")\n            stack.enter_context(fh)\n            serialize_files[fh.name] = fh\n\n        response = requests.post(\n            latch_register_url, headers=headers, files=serialize_files\n        )\n        response.raise_for_status()\n        return response.json()"
    }
  },
  {
    "metadata": {
      "package_name": "latch-2.58.2",
      "total_matches": 2
    }
  }
]