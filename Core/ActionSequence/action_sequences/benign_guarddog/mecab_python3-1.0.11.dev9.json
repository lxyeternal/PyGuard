[
  {
    "pyfile": "setup.py",
    "code_snippet": "import os\nimport subprocess\nimport sys\n\n# ... (other imports and global variables)\n\n# We can build using either a local bundled copy of libmecab, or a\n# system-provided one.  Delay deciding which of these to do until\n# `build_ext` is invoked, because if `build_ext` isn't going to be\n# invoked, we shouldn't either attempt to build the bundled copy\n# or run the external `mecab-config` utility.\ndef maybe_build_libmecab_and_adjust_flags(ext):\n    if USE_BUNDLED_LIBMECAB:\n        subprocess.check_call([\n            sys.executable,\n            os.path.join(SRCDIR, \"scripts/build-bundled-libmecab.py\"),\n            SRCDIR\n        ])\n        inc_dir  = [os.path.join(SRCDIR, \"build/libmecab/mecab/src\")]\n        lib_dirs = [os.path.join(SRCDIR, \"build/libmecab/mecab/src\")]\n\n        # mecab-config --libs-only-l will produce the list of\n        # libraries needed to link with a hypothetical *shared*\n        # libmecab; we built a *static* libmecab, so what we actually\n        # need is -lmecab + the value of the LIBS substitution\n        # variable from the Makefile.\n        libs = [\"mecab\"]\n        with open(os.path.join(SRCDIR, \"build/libmecab/mecab/Makefile\"),\n                  \"rt\") as fp:\n            for line in fp:\n                if line.startswith(\"LIBS =\"):\n                    for lib in line.partition(\"=\")[2].split():\n                        if lib[:2] == \"-l\":\n                            libs.append(lib[2:])\n                    break\n\n    else:\n        # Ensure use of the \"C\" locale when invoking mecab-config.\n        # (\"C.UTF-8\" would be better if available, but there's no\n        # good way to find out whether it's available.)\n        clocale_env = {}\n        for k, v in os.environ.items():\n            if not (k.startswith(\"LC_\") or k == \"LANG\" or k == \"LANGUAGE\"):\n                clocale_env[k] = v\n        clocale_env[\"LC_ALL\"] = \"C\"\n\n        def mecab_config(arg):\n            output = subprocess.check_output([\"mecab-config\", arg],\n                                             env=clocale_env)\n            if not isinstance(output, str):\n                output = output.decode(\"utf-8\")\n            return output.split()\n\n        inc_dir  = mecab_config(\"--inc-dir\")\n        lib_dirs = mecab_config(\"--libs-only-L\")\n        libs     = mecab_config(\"--libs-only-l\")\n\n    swig_opts = [\"-O\", \"-builtin\", \"-c++\"]\n\n    if sys.version_info.major >= 3:\n        swig_opts.append(\"-py3\")\n\n    swig_opts.extend(\"-I\"+d for d in inc_dir)\n\n    ext.include_dirs = inc_dir\n    ext.library_dirs = lib_dirs\n    ext.libraries    = libs\n    ext.swig_opts    = swig_opts\n    ext.extra_compile_args = [\"-Wno-unused-variable\"]\n\n    sys.stderr.write(\"Extension build configuration adjusted:\\n\"\n                     \" include_dirs = {!r}\\n\"\n                     \" library_dirs = {!r}\\n\"\n                     \" libraries    = {!r}\\n\"\n                     \" swig_opts    = {!r}\\n\"\n                     .format(inc_dir, lib_dirs, libs, swig_opts))\n",
    "pattern_analysis": {
      "api_sequence": [
        "subprocess.check_call",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "open",
        "os.path.join",
        "os.environ.items",
        "subprocess.check_output",
        "sys.stderr.write"
      ],
      "api_sequence_with_args": [
        "subprocess.check_call([sys.executable, os.path.join(SRCDIR, \"scripts/build-bundled-libmecab.py\"), SRCDIR])",
        "os.path.join(SRCDIR, \"build/libmecab/mecab/src\")",
        "os.path.join(SRCDIR, \"build/libmecab/mecab/src\")",
        "os.path.join(SRCDIR, \"build/libmecab/mecab/Makefile\")",
        "open(os.path.join(SRCDIR, \"build/libmecab/mecab/Makefile\"), \"rt\")",
        "os.path.join(SRCDIR, \"build/libmecab/mecab/Makefile\")",
        "os.environ.items()",
        "subprocess.check_output([\"mecab-config\", arg], env=clocale_env)",
        "sys.stderr.write(\"Extension build configuration adjusted:\\n include_dirs = {!r}\\n library_dirs = {!r}\\n libraries    = {!r}\\n swig_opts    = {!r}\\n\".format(inc_dir, lib_dirs, libs, swig_opts))"
      ],
      "mapped_sequence": [
        {
          "api_name": "subprocess.check_call",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.environ.items",
          "id": "get_env_vars",
          "description": "Retrieves environment variables mapping",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "subprocess.check_output",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "sys.stderr.write",
          "id": "read_user_input",
          "description": "Reads user input from standard input",
          "first_id": "persistence_stealth",
          "second_id": "user_interaction",
          "third_id": "interface_control"
        }
      ],
      "contextual_code": "import os\nimport subprocess\nimport sys\n\ndef maybe_build_libmecab_and_adjust_flags(ext):\n    if USE_BUNDLED_LIBMECAB:\n        subprocess.check_call([\n            sys.executable,\n            os.path.join(SRCDIR, \"scripts/build-bundled-libmecab.py\"),\n            SRCDIR\n        ])\n        inc_dir  = [os.path.join(SRCDIR, \"build/libmecab/mecab/src\")]\n        lib_dirs = [os.path.join(SRCDIR, \"build/libmecab/mecab/src\")]\n        libs = [\"mecab\"]\n        with open(os.path.join(SRCDIR, \"build/libmecab/mecab/Makefile\"), \"rt\") as fp:\n            for line in fp:\n                if line.startswith(\"LIBS =\"):\n                    for lib in line.partition(\"=\")[2].split():\n                        if lib[:2] == \"-l\":\n                            libs.append(lib[2:])\n                    break\n    else:\n        clocale_env = {}\n        for k, v in os.environ.items():\n            if not (k.startswith(\"LC_\") or k == \"LANG\" or k == \"LANGUAGE\"):\n                clocale_env[k] = v\n        clocale_env[\"LC_ALL\"] = \"C\"\n        def mecab_config(arg):\n            output = subprocess.check_output([\"mecab-config\", arg], env=clocale_env)\n            if not isinstance(output, str):\n                output = output.decode(\"utf-8\")\n            return output.split()\n        inc_dir  = mecab_config(\"--inc-dir\")\n        lib_dirs = mecab_config(\"--libs-only-L\")\n        libs     = mecab_config(\"--libs-only-l\")\n    sys.stderr.write(\"Extension build configuration adjusted:\\n\"\n                     \" include_dirs = {!r}\\n\"\n                     \" library_dirs = {!r}\\n\"\n                     \" libraries    = {!r}\\n\"\n                     \" swig_opts    = {!r}\\n\"\n                     .format(inc_dir, lib_dirs, libs, swig_opts))"
    }
  },
  {
    "metadata": {
      "package_name": "mecab_python3-1.0.11.dev9",
      "total_matches": 1
    }
  }
]