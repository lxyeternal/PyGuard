[
  {
    "pyfile": "setup.py",
    "code_snippet": "import os\nimport platform\nimport shutil\nimport subprocess\nfrom distutils.command.build import build\nfrom os import makedirs, path\n\nfrom setuptools import Extension, setup\n\nHERE = path.abspath(path.dirname(__file__))\n\nPROTOS = [\"sentence.proto\", \"feature_extractor.proto\", \"task_spec.proto\"]\n\nclass BuildProtobuf(build):\n    \"\"\"Compile protocol buffers via `protoc` compiler.\"\"\"\n\n    def run(self):\n\n        # Raise & exit early if `protoc` compiler not available\n        if shutil.which(\"protoc\") is None:\n            raise RuntimeError(\n                \"The Protobuf compiler, `protoc`, which is required for\"\n                \" building this package, could not be found.\\n\"\n                \"See https://github.com/protocolbuffers/protobuf for\"\n                \" information on installing Protobuf.\"\n            )\n\n        # Create protobufs dir if it does not exist\n        protobuf_dir = path.join(HERE, \"src/cld_3/protos/\")\n        if not path.exists(protobuf_dir):\n            print(\"Creating dirs at \\033[1m{}\\033[0;0m\".format(protobuf_dir))\n            makedirs(protobuf_dir)\n\n        # Run command via subprocess, using protoc compiler on .proto\n        # files\n        #\n        # $ cd src && protoc --cpp-_ut cld_3/protos \\\n        # >     sentence.proto feature_extractor.proto task_spec.proto\n        command = [\"protoc\"]\n        command.extend(PROTOS)\n        command.append(\n            \"--cpp_out={}\".format(path.join(HERE, \"src/cld_3/protos/\"))\n        )\n        print(\"Running \\033[1m{}\\033[0;0m\".format(\" \".join(command)))\n        subprocess.run(command, check=True, cwd=path.join(HERE, \"src/\"))\n        build.run(self)\n",
    "pattern_analysis": {
      "api_sequence": [
        "shutil.which",
        "os.path.join",
        "os.path.exists",
        "os.makedirs",
        "os.path.join",
        "subprocess.run",
        "distutils.command.build.build.run"
      ],
      "api_sequence_with_args": [
        "shutil.which(\"protoc\")",
        "os.path.join(HERE, \"src/cld_3/protos/\")",
        "os.path.exists(protobuf_dir)",
        "os.makedirs(protobuf_dir)",
        "os.path.join(HERE, \"src/\")",
        "subprocess.run(command, check=True, cwd=os.path.join(HERE, \"src/\"))",
        "distutils.command.build.build.run(self)"
      ],
      "mapped_sequence": [
        {
          "api_name": "shutil.which",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.makedirs",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "subprocess.run",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "distutils.command.build.build.run",
          "id": "exec_setuptools_dev",
          "description": "Executes setuptools development procedure",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "package_configuration"
        }
      ],
      "contextual_code": "import os\nimport shutil\nimport subprocess\nfrom distutils.command.build import build\nfrom os import makedirs, path\n\nHERE = path.abspath(path.dirname(__file__))\n\nclass BuildProtobuf(build):\n    def run(self):\n        if shutil.which(\"protoc\") is None:\n            raise RuntimeError(\"The Protobuf compiler, `protoc`, which is required for building this package, could not be found.\")\n        protobuf_dir = path.join(HERE, \"src/cld_3/protos/\")\n        if not path.exists(protobuf_dir):\n            makedirs(protobuf_dir)\n        command = [\"protoc\"]\n        command.extend(PROTOS)\n        command.append(\"--cpp_out={}\".format(path.join(HERE, \"src/cld_3/protos/\")))\n        subprocess.run(command, check=True, cwd=path.join(HERE, \"src/\"))\n        build.run(self)"
    }
  },
  {
    "metadata": {
      "package_name": "pycld3-0.22",
      "total_matches": 1
    }
  }
]