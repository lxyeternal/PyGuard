[
  {
    "pyfile": "parent_selection.py",
    "code_snippet": "import numpy\n\nclass ParentSelection:\n\n    def steady_state_selection(self, fitness, num_parents):\n\n        \"\"\"\n        Selects the parents using the steady-state selection technique. \n        This is by sorting the solutions based on the fitness and select the best ones as parents.\n        Later, these parents will mate to produce the offspring.\n\n        It accepts 2 parameters:\n            -fitness: The fitness values of the solutions in the current population.\n            -num_parents: The number of parents to be selected.\n        It returns:\n            -An array of the selected parents.\n            -The indices of the selected solutions.\n        \"\"\"\n\n        # Return the indices of the sorted solutions (all solutions in the population).\n        # This function works with both single- and multi-objective optimization problems.\n        fitness_sorted = self.sort_solutions_nsga2(fitness=fitness)\n\n        # Selecting the best individuals in the current generation as parents for producing the offspring of the next generation.\n        if self.gene_type_single == True:\n            parents = numpy.empty((num_parents, self.population.shape[1]), dtype=self.gene_type[0])\n        else:\n            parents = numpy.empty((num_parents, self.population.shape[1]), dtype=object)\n\n        for parent_num in range(num_parents):\n            parents[parent_num, :] = self.population[fitness_sorted[parent_num], :].copy()\n\n        return parents, numpy.array(fitness_sorted[:num_parents])",
    "pattern_analysis": {
      "api_sequence": [
        "ParentSelection.sort_solutions_nsga2",
        "numpy.empty",
        "numpy.empty",
        "self.population.shape",
        "self.population.shape",
        "self.population.__getitem__",
        "numpy.array"
      ],
      "api_sequence_with_args": [
        "ParentSelection.sort_solutions_nsga2(fitness=fitness)",
        "numpy.empty((num_parents, self.population.shape[1]), dtype=self.gene_type[0])",
        "numpy.empty((num_parents, self.population.shape[1]), dtype=object)",
        "self.population.shape[1]",
        "self.population.shape[1]",
        "self.population[fitness_sorted[parent_num], :].copy()",
        "numpy.array(fitness_sorted[:num_parents])"
      ],
      "mapped_sequence": [
        {
          "api_name": "ParentSelection.sort_solutions_nsga2",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "numpy.empty",
          "id": "create_memory_bytes",
          "description": "Creates in-memory bytes buffer from encoded string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "numpy.empty",
          "id": "create_memory_bytes",
          "description": "Creates in-memory bytes buffer from encoded string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "self.population.shape",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "self.population.shape",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "self.population.__getitem__",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "numpy.array",
          "id": "create_memory_bytes",
          "description": "Creates in-memory bytes buffer from encoded string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        }
      ],
      "contextual_code": "import numpy\n\nclass ParentSelection:\n\n    def steady_state_selection(self, fitness, num_parents):\n        fitness_sorted = self.sort_solutions_nsga2(fitness=fitness)\n        if self.gene_type_single == True:\n            parents = numpy.empty((num_parents, self.population.shape[1]), dtype=self.gene_type[0])\n        else:\n            parents = numpy.empty((num_parents, self.population.shape[1]), dtype=object)\n        for parent_num in range(num_parents):\n            parents[parent_num, :] = self.population[fitness_sorted[parent_num], :].copy()\n        return parents, numpy.array(fitness_sorted[:num_parents])"
    }
  },
  {
    "metadata": {
      "package_name": "pygad-3.4.0",
      "total_matches": 2
    }
  }
]