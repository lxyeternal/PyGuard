[
  {
    "pyfile": "repl.py",
    "code_snippet": "import pyperclip\n\nclass Repl(metaclass=abc.ABCMeta):\n    ...\n    def get_session_formatted_for_file(self) -> str:\n        \"\"\"Format the stdout buffer to something suitable for writing to disk,\n        i.e. without >>> and ... at input lines and with \"# OUT: \" prepended to\n        output lines and \"### \" prepended to current line\"\"\"\n\n        session_output = self.getstdout()\n\n        def process():\n            for line in session_output.split(\"\\n\"):\n                if line.startswith(self.ps1):\n                    yield line[len(self.ps1) :]\n                elif line.startswith(self.ps2):\n                    yield line[len(self.ps2) :]\n                elif line.rstrip():\n                    yield f\"# OUT: {line}\"\n\n        return \"\\n\".join(process())\n\n    def copy2clipboard(self) -> None:\n        \"\"\"Copy current content to clipboard.\"\"\"\n\n        if not have_pyperclip:\n            self.interact.notify(_(\"No clipboard available.\"))\n            return\n\n        content = self.get_session_formatted_for_file()\n        try:\n            pyperclip.copy(content)\n        except pyperclip.PyperclipException:\n            self.interact.notify(_(\"Could not copy to clipboard.\"))\n        else:\n            self.interact.notify(_(\"Copied content to clipboard.\"))\n\n# Relevant global variable and import\nhave_pyperclip = True\ntry:\n    import pyperclip\nexcept ImportError:\n    have_pyperclip = False\n",
    "pattern_analysis": {
      "api_sequence": [
        "pyperclip.copy"
      ],
      "api_sequence_with_args": [
        "pyperclip.copy(content)"
      ],
      "mapped_sequence": [
        {
          "api_name": "pyperclip.copy",
          "id": "copy_to_clipboard",
          "description": "Copies specified text to system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        }
      ],
      "contextual_code": "def copy2clipboard(self) -> None:\n    \"\"\"Copy current content to clipboard.\"\"\"\n\n    if not have_pyperclip:\n        self.interact.notify(_(\"No clipboard available.\"))\n        return\n\n    content = self.get_session_formatted_for_file()\n    try:\n        pyperclip.copy(content)\n    except pyperclip.PyperclipException:\n        self.interact.notify(_(\"Could not copy to clipboard.\"))\n    else:\n        self.interact.notify(_(\"Copied content to clipboard.\"))"
    }
  },
  {
    "pyfile": "simpleeval.py",
    "code_snippet": "import ast\nimport sys\nimport builtins\nfrom typing import Dict, Any, Optional\n\nfrom . import line as line_properties\nfrom .inspection import getattr_safe\n\n_string_type_nodes = (ast.Str, ast.Bytes)\n_numeric_types = (int, float, complex)\n_name_type_nodes = (ast.Name,)\n\nclass EvaluationError(Exception):\n    \"\"\"Raised if an exception occurred in safe_eval.\"\"\"\n\ndef simple_eval(node_or_string, namespace=None):\n    \"\"\"\n    Safely evaluate an expression node or a string containing a Python\n    expression without triggering any user code.\n\n    The string or node provided may only consist of:\n    * the following Python literal structures: strings, numbers, tuples,\n        lists, dicts, and sets\n    * variable names causing lookups in the passed in namespace or builtins\n    * getitem calls using the [] syntax on objects of the types above\n\n    Like Python 3's literal_eval, unary and binary + and - operations are\n    allowed on all builtin numeric types.\n\n    The optional namespace dict-like ought not to cause side effects on lookup.\n    \"\"\"\n    if namespace is None:\n        namespace = {}\n    if isinstance(node_or_string, str):\n        node_or_string = ast.parse(node_or_string, mode=\"eval\")\n    if isinstance(node_or_string, ast.Expression):\n        node_or_string = node_or_string.body\n\n    def _convert(node):\n        if isinstance(node, ast.Constant):\n            return node.value\n        elif isinstance(node, ast.Tuple):\n            return tuple(map(_convert, node.elts))\n        elif isinstance(node, ast.List):\n            return list(map(_convert, node.elts))\n        elif isinstance(node, ast.Dict):\n            return {\n                _convert(k): _convert(v) for k, v in zip(node.keys, node.values)\n            }\n        elif isinstance(node, ast.Set):\n            return set(map(_convert, node.elts))\n        elif (\n            isinstance(node, ast.Call)\n            and isinstance(node.func, ast.Name)\n            and node.func.id == \"set\"\n            and node.args == node.keywords == []\n        ):\n            return set()\n\n        # this is a deviation from literal_eval: we evaluate tuple() and list()\n        elif (\n            isinstance(node, ast.Call)\n            and isinstance(node.func, ast.Name)\n            and node.func.id == \"tuple\"\n            and node.args == node.keywords == []\n        ):\n            return tuple()\n        elif (\n            isinstance(node, ast.Call)\n            and isinstance(node.func, ast.Name)\n            and node.func.id == \"list\"\n            and node.args == node.keywords == []\n        ):\n            return list()\n\n        # this is a deviation from literal_eval: we allow non-literals\n        elif isinstance(node, _name_type_nodes):\n            try:\n                return namespace[node.id]\n            except KeyError:\n                try:\n                    return getattr(builtins, node.id)\n                except AttributeError:\n                    raise EvaluationError(\"can't lookup %s\" % node.id)\n\n        # unary + and - are allowed on any type\n        elif isinstance(node, ast.UnaryOp) and isinstance(\n            node.op, (ast.UAdd, ast.USub)\n        ):\n            # ast.literal_eval does ast typechecks here, we use type checks\n            operand = _convert(node.operand)\n            if not type(operand) in _numeric_types:\n                raise ValueError(\"unary + and - only allowed on builtin nums\")\n            if isinstance(node.op, ast.UAdd):\n                return +operand\n            else:\n                return -operand\n        elif isinstance(node, ast.BinOp) and isinstance(\n            node.op, (ast.Add, ast.Sub)\n        ):\n            # ast.literal_eval does ast typechecks here, we use type checks\n            left = _convert(node.left)\n            right = _convert(node.right)\n            if not (\n                isinstance(left, _numeric_types)\n                and isinstance(right, _numeric_types)\n            ):\n                raise ValueError(\"binary + and - only allowed on builtin nums\")\n            if isinstance(node.op, ast.Add):\n                return left + right\n            else:\n                return left - right\n\n        # this is a deviation from literal_eval: we allow indexing\n        elif isinstance(node, ast.Subscript) and isinstance(\n            node.slice, (ast.Constant, ast.Name)\n        ):\n            obj = _convert(node.value)\n            index = _convert(node.slice)\n            return safe_getitem(obj, index)\n\n        # this is a deviation from literal_eval: we allow attribute access\n        if isinstance(node, ast.Attribute):\n            obj = _convert(node.value)\n            attr = node.attr\n            return getattr_safe(obj, attr)\n\n        raise ValueError(f\"malformed node or string: {node!r}\")\n\n    return _convert(node_or_string)\n",
    "pattern_analysis": {
      "api_sequence": [
        "ast.parse",
        "ast.Expression.body",
        "ast.Constant.value",
        "ast.Tuple.elts",
        "ast.List.elts",
        "ast.Dict.keys",
        "ast.Dict.values",
        "ast.Set.elts",
        "ast.Name.id",
        "builtins.getattr",
        "getattr_safe"
      ],
      "api_sequence_with_args": [
        "ast.parse(node_or_string, mode=\"eval\")",
        "ast.Expression.body",
        "ast.Constant.value",
        "ast.Tuple.elts",
        "ast.List.elts",
        "ast.Dict.keys",
        "ast.Dict.values",
        "ast.Set.elts",
        "ast.Name.id",
        "builtins.getattr(builtins, node.id)",
        "getattr_safe(obj, attr)"
      ],
      "mapped_sequence": [
        {
          "api_name": "ast.parse",
          "id": "compile_code_object",
          "description": "Compiles source code string into executable code object",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "ast.Expression.body",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "ast.Constant.value",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "ast.Tuple.elts",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "ast.List.elts",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "ast.Dict.keys",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "ast.Dict.values",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "ast.Set.elts",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "ast.Name.id",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "builtins.getattr",
          "id": "get_builtin_attr",
          "description": "Sets attribute on builtins object",
          "first_id": "",
          "second_id": "",
          "third_id": ""
        },
        {
          "api_name": "getattr_safe",
          "id": "get_builtin_attr",
          "description": "Sets attribute on builtins object",
          "first_id": "",
          "second_id": "",
          "third_id": ""
        }
      ],
      "contextual_code": "import ast\nimport builtins\nfrom .inspection import getattr_safe\n\ndef simple_eval(node_or_string, namespace=None):\n    if namespace is None:\n        namespace = {}\n    if isinstance(node_or_string, str):\n        node_or_string = ast.parse(node_or_string, mode=\"eval\")\n    if isinstance(node_or_string, ast.Expression):\n        node_or_string = node_or_string.body\n\n    def _convert(node):\n        if isinstance(node, ast.Constant):\n            return node.value\n        elif isinstance(node, ast.Tuple):\n            return tuple(map(_convert, node.elts))\n        elif isinstance(node, ast.List):\n            return list(map(_convert, node.elts))\n        elif isinstance(node, ast.Dict):\n            return {\n                _convert(k): _convert(v) for k, v in zip(node.keys, node.values)\n            }\n        elif isinstance(node, ast.Set):\n            return set(map(_convert, node.elts))\n        elif isinstance(node, ast.Name):\n            try:\n                return namespace[node.id]\n            except KeyError:\n                try:\n                    return getattr(builtins, node.id)\n                except AttributeError:\n                    raise EvaluationError(\"can't lookup %s\" % node.id)\n        if isinstance(node, ast.Attribute):\n            obj = _convert(node.value)\n            attr = node.attr\n            return getattr_safe(obj, attr)\n        # ... (other code omitted for brevity)\n    return _convert(node_or_string)"
    }
  },
  {
    "pyfile": "setup.py",
    "code_snippet": "import os\nimport platform\nimport re\nimport subprocess\n\nversion_file = \"bpython/_version.py\"\nversion = \"unknown\"\n\ntry:\n    # get version from git describe\n    proc = subprocess.Popen(\n        [\"git\", \"describe\", \"--tags\", \"--first-parent\"],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n    )\n    stdout = proc.communicate()[0].strip()\n    stdout = stdout.decode(\"ascii\")\n\n    if proc.returncode == 0:\n        version = git_describe_to_python_version(stdout)\nexcept OSError:\n    pass\n",
    "pattern_analysis": {
      "api_sequence": [
        "subprocess.Popen",
        "subprocess.Popen.communicate",
        "bytes.strip",
        "bytes.decode"
      ],
      "api_sequence_with_args": [
        "subprocess.Popen([\"git\", \"describe\", \"--tags\", \"--first-parent\"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)",
        "subprocess.Popen.communicate()",
        "stdout.strip()",
        "stdout.decode(\"ascii\")"
      ],
      "mapped_sequence": [
        {
          "api_name": "subprocess.Popen",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "subprocess.Popen.communicate",
          "id": "read_process_stdout",
          "description": "Reads all bytes from process standard output",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "bytes.strip",
          "id": "decode_bytes_default",
          "description": "Decodes bytes using default codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "bytes.decode",
          "id": "decode_bytes_codec",
          "description": "Decodes bytes using specified codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        }
      ],
      "contextual_code": "import subprocess\n\ntry:\n    proc = subprocess.Popen(\n        [\"git\", \"describe\", \"--tags\", \"--first-parent\"],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n    )\n    stdout = proc.communicate()[0].strip()\n    stdout = stdout.decode(\"ascii\")\n    if proc.returncode == 0:\n        version = git_describe_to_python_version(stdout)\nexcept OSError:\n    pass"
    }
  },
  {
    "metadata": {
      "package_name": "bpython-0.25",
      "total_matches": 3
    }
  }
]