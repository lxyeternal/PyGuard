[
  {
    "pyfile": "setup.py",
    "code_snippet": "import sys\nimport time\nimport os\nimport glob\nimport shutil\nimport itertools\nimport tempfile\nfrom distutils.errors import DistutilsSetupError\nfrom distutils import log\n\nclass JavaLib(object):\n\n    def __init__(self):\n        self.jar_name = pydoop.jar_name()\n        self.classpath = pydoop.hadoop_classpath()\n        self.java_files = glob.glob(\n            \"src/it/crs4/pydoop/mapreduce/pipes/*.java\"\n        ) + [\"src/it/crs4/pydoop/NoSeparatorTextOutputFormat.java\"]\n        self.dependencies = glob.glob('lib/*.jar')\n        self.properties = [(\n            os.path.join(\"it/crs4/pydoop/mapreduce/pipes\", PROP_BN),\n            PROP_FN\n        )]\n\nclass JavaBuilder(object):\n\n    def __init__(self, build_temp, build_lib):\n        self.build_temp = build_temp\n        self.build_lib = build_lib\n        self.java_libs = [JavaLib()]\n\n    def run(self):\n        for jlib in self.java_libs:\n            self.__build_java_lib(jlib)\n\n    def __build_java_lib(self, jlib):\n        package_path = os.path.join(self.build_lib, \"pydoop\")\n        compile_cmd = \"javac\"\n        if jlib.classpath:\n            classpath = [jlib.classpath]\n            for src in jlib.dependencies:\n                dest = os.path.join(package_path, os.path.basename(src))\n                shutil.copyfile(src, dest)\n                classpath.append(dest)\n            compile_cmd += \" -classpath %s\" % (':'.join(classpath))\n        else:\n            log.warn(\n                \"WARNING: could not set classpath, java code may not compile\"\n            )\n        class_dir = os.path.join(\n            self.build_temp, \"pipes\"\n        )\n        jar_path = os.path.join(package_path, jlib.jar_name)\n        if not os.path.exists(class_dir):\n            os.mkdir(class_dir)\n        compile_cmd += \" -d '%s'\" % class_dir\n        log.info(\"Compiling Java classes\")\n        for f in jlib.java_files:\n            compile_cmd += \" %s\" % f\n        ret = os.system(compile_cmd)\n        if ret:\n            raise DistutilsSetupError(\n                \"Error compiling java component.  Command: %s\" % compile_cmd\n            )\n        log.info(\"Copying properties file\")\n        for p in jlib.properties:\n            prop_file_dest = os.path.join(class_dir, p[0])\n            shutil.copyfile(p[1], prop_file_dest)\n        log.info(\"Making Jar: %s\", jar_path)\n        package_cmd = \"jar -cf %(jar_path)s -C %(class_dir)s ./it\" % {\n            'jar_path': jar_path, 'class_dir': class_dir\n        }\n        log.info(\"Packaging Java classes\")\n        log.info(\"Command: %s\", package_cmd)\n        ret = os.system(package_cmd)\n        if ret:\n            raise DistutilsSetupError(\n                \"Error packaging java component.  Command: %s\" % package_cmd\n            )\n",
    "pattern_analysis": {
      "api_sequence": [
        "pydoop.jar_name",
        "pydoop.hadoop_classpath",
        "glob.glob",
        "glob.glob",
        "os.path.join",
        "os.path.join",
        "os.path.basename",
        "shutil.copyfile",
        "os.path.exists",
        "os.mkdir",
        "os.system",
        "os.path.join",
        "shutil.copyfile",
        "os.system"
      ],
      "api_sequence_with_args": [
        "pydoop.jar_name()",
        "pydoop.hadoop_classpath()",
        "glob.glob(\"src/it/crs4/pydoop/mapreduce/pipes/*.java\")",
        "glob.glob('lib/*.jar')",
        "os.path.join(self.build_lib, \"pydoop\")",
        "os.path.join(package_path, os.path.basename(src))",
        "os.path.basename(src)",
        "shutil.copyfile(src, dest)",
        "os.path.exists(class_dir)",
        "os.mkdir(class_dir)",
        "os.system(compile_cmd)",
        "os.path.join(class_dir, p[0])",
        "shutil.copyfile(p[1], prop_file_dest)",
        "os.system(package_cmd)"
      ],
      "mapped_sequence": [
        {
          "api_name": "pydoop.jar_name",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "pydoop.hadoop_classpath",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "glob.glob",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "glob.glob",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.basename",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "shutil.copyfile",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.mkdir",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.system",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "shutil.copyfile",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "os.system",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        }
      ],
      "contextual_code": "class JavaLib(object):\n    def __init__(self):\n        self.jar_name = pydoop.jar_name()\n        self.classpath = pydoop.hadoop_classpath()\n        self.java_files = glob.glob(\n            \"src/it/crs4/pydoop/mapreduce/pipes/*.java\"\n        ) + [\"src/it/crs4/pydoop/NoSeparatorTextOutputFormat.java\"]\n        self.dependencies = glob.glob('lib/*.jar')\n        self.properties = [(\n            os.path.join(\"it/crs4/pydoop/mapreduce/pipes\", PROP_BN),\n            PROP_FN\n        )]\n\nclass JavaBuilder(object):\n    def __init__(self, build_temp, build_lib):\n        self.build_temp = build_temp\n        self.build_lib = build_lib\n        self.java_libs = [JavaLib()]\n\n    def run(self):\n        for jlib in self.java_libs:\n            self.__build_java_lib(jlib)\n\n    def __build_java_lib(self, jlib):\n        package_path = os.path.join(self.build_lib, \"pydoop\")\n        compile_cmd = \"javac\"\n        if jlib.classpath:\n            classpath = [jlib.classpath]\n            for src in jlib.dependencies:\n                dest = os.path.join(package_path, os.path.basename(src))\n                shutil.copyfile(src, dest)\n                classpath.append(dest)\n            compile_cmd += \" -classpath %s\" % (':'.join(classpath))\n        else:\n            log.warn(\n                \"WARNING: could not set classpath, java code may not compile\"\n            )\n        class_dir = os.path.join(\n            self.build_temp, \"pipes\"\n        )\n        jar_path = os.path.join(package_path, jlib.jar_name)\n        if not os.path.exists(class_dir):\n            os.mkdir(class_dir)\n        compile_cmd += \" -d '%s'\" % class_dir\n        log.info(\"Compiling Java classes\")\n        for f in jlib.java_files:\n            compile_cmd += \" %s\" % f\n        ret = os.system(compile_cmd)\n        if ret:\n            raise DistutilsSetupError(\n                \"Error compiling java component.  Command: %s\" % compile_cmd\n            )\n        log.info(\"Copying properties file\")\n        for p in jlib.properties:\n            prop_file_dest = os.path.join(class_dir, p[0])\n            shutil.copyfile(p[1], prop_file_dest)\n        log.info(\"Making Jar: %s\", jar_path)\n        package_cmd = \"jar -cf %(jar_path)s -C %(class_dir)s ./it\" % {\n            'jar_path': jar_path, 'class_dir': class_dir\n        }\n        log.info(\"Packaging Java classes\")\n        log.info(\"Command: %s\", package_cmd)\n        ret = os.system(package_cmd)\n        if ret:\n            raise DistutilsSetupError(\n                \"Error packaging java component.  Command: %s\" % package_cmd\n            )"
    }
  },
  {
    "metadata": {
      "package_name": "pydoop-2.0.0",
      "total_matches": 2
    }
  }
]