[
  {
    "pyfile": "setup.py",
    "code_snippet": "import os\nimport platform\nimport shutil\nimport site\nimport subprocess\nimport sys\nfrom glob import glob\nfrom pathlib import Path\nfrom typing import Optional\n\nfrom pybind11.setup_helpers import Pybind11Extension, build_ext\nfrom setuptools import setup\n\nis_windows = platform.system() == \"Windows\"\n\nprefix_paths = [\n    Path(sys.prefix),\n    Path(site.getuserbase()),\n    Path.home() / \".local\",\n]\n\nclass Executable:\n    def __init__(self, command: str):\n        self._command = command\n\n    def __call__(self, *args) -> str:\n        if self.executable is None:\n            raise RuntimeError(f\"{self._command} not found\")\n\n        return subprocess.check_output([self.executable, *args], encoding=\"utf-8\").strip()\n\n    def exists(self) -> bool:\n        return self.executable is not None\n\n    @property\n    def executable(self) -> Optional[str]:\n        paths = [str(path / \"bin\") for path in prefix_paths]\n        paths.append(os.environ[\"PATH\"])\n        return shutil.which(self._command, path=os.pathsep.join(paths))",
    "pattern_analysis": {
      "api_sequence": [
        "platform.system",
        "Path",
        "site.getuserbase",
        "Path.home",
        "os.environ",
        "shutil.which",
        "os.pathsep.join",
        "subprocess.check_output"
      ],
      "api_sequence_with_args": [
        "platform.system()",
        "Path(sys.prefix)",
        "site.getuserbase()",
        "Path.home()",
        "os.environ[\"PATH\"]",
        "shutil.which(self._command, path=os.pathsep.join(paths))",
        "os.pathsep.join(paths)",
        "subprocess.check_output([self.executable, *args], encoding=\"utf-8\")"
      ],
      "mapped_sequence": [
        {
          "api_name": "platform.system",
          "id": "get_os_id",
          "description": "Retrieves operating system identifier",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "Path",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "site.getuserbase",
          "id": "get_site_packages",
          "description": "Returns list of all global site-packages directories",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "package_configuration"
        },
        {
          "api_name": "Path.home",
          "id": "path_special_operations",
          "description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.environ",
          "id": "get_env_vars",
          "description": "Retrieves environment variables mapping",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "shutil.which",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.pathsep.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "subprocess.check_output",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        }
      ],
      "contextual_code": "import os\nimport platform\nimport shutil\nimport site\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nis_windows = platform.system() == \"Windows\"\n\nprefix_paths = [\n    Path(sys.prefix),\n    Path(site.getuserbase()),\n    Path.home() / \".local\",\n]\n\nclass Executable:\n    def __init__(self, command: str):\n        self._command = command\n\n    def __call__(self, *args) -> str:\n        if self.executable is None:\n            raise RuntimeError(f\"{self._command} not found\")\n        return subprocess.check_output([self.executable, *args], encoding=\"utf-8\").strip()\n\n    def exists(self) -> bool:\n        return self.executable is not None\n\n    @property\n    def executable(self) -> Optional[str]:\n        paths = [str(path / \"bin\") for path in prefix_paths]\n        paths.append(os.environ[\"PATH\"])\n        return shutil.which(self._command, path=os.pathsep.join(paths))"
    }
  },
  {
    "metadata": {
      "package_name": "python_mecab_ko-1.3.7",
      "total_matches": 1
    }
  }
]