[
  {
    "metadata": {
      "package_name": "delvewheel-1.10.0",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "_wheel_repair.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/delvewheel-1.10.0/delvewheel-1.10.0/delvewheel/_wheel_repair.py",
    "line_number": "390",
    "type_description": "B832:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "389\t                file.write('\\n\\n\\n')\n390\t                file.write(patch_py_contents)\n391\t                if remainder := ''.join(py_contents_split[future_import_lineno:]).lstrip():",
    "code_snippet": "def _patch_py_file(self, py_path: str, libs_dir: str, load_order_filename: typing.Optional[str], depth: int) -> None:\n    \"\"\"Given the path to a .py file, create or patch the file so that\n    vendored DLLs can be loaded at runtime. The patch is placed at the\n    topmost location after the shebang (if any), docstring or header\n    comments (if any), and any \"from __future__ import\" statements.\n\n    py_path is the path to the .py file to create or patch\n    libs_dir is the name of the directory where DLLs are stored.\n    load_order_filename is the name of the .load-order file, or None if the\n        file is not used\n    depth is the number of parent directories to traverse to reach the\n        site-packages directory at runtime starting from the directory\n        containing the .py file\"\"\"\n    print(f'patching {os.path.relpath(py_path, self._extract_dir)}')\n\n    py_name = os.path.basename(py_path)\n    if py_name.lower() == '__init__.py':\n        package_dir = os.path.dirname(os.path.relpath(py_path, self._extract_dir))\n        if os.path.isfile(py_path):\n            search = (\n                \"__path__=__import__('pkgutil').extend_path(__path__,__name__)\",\n                '__path__=__import__(\"pkgutil\").extend_path(__path__,__name__)',\n                \"__import__('pkg_resources').declare_namespace(__name__)\",\n                '__import__(\"pkg_resources\").declare_namespace(__name__)'\n            )\n            with open(py_path) as file:\n                for line in file:\n                    if line.rstrip().replace(' ', '') in search:\n                        warnings.warn(\n                            f'{package_dir} appears to be a namespace '\n                            f'package. If so, use the --namespace-pkg '\n                            f'option.')\n                        break\n        else:\n            warnings.warn(\n                f'{package_dir} does not contain __init__.py. If it is a '\n                f'namespace package, use the --namespace-pkg option. '\n                f'Otherwise, create an empty __init__.py file to silence '\n                f'this warning.')\n\n    open(py_path, 'a+').close()  # create file if it doesn't exist\n    with open(py_path, newline='') as file:\n        line = file.readline()\n    for newline in ('\\r\\n', '\\r', '\\n'):\n        if line.endswith(newline):\n            break\n    else:\n        newline = '\\r\\n'\n\n    with open(py_path) as file:\n        py_contents = file.read()\n    node = ast.parse(py_contents)\n    docstring = ast.get_docstring(node, False)\n    children = list(ast.iter_child_nodes(node))\n    for child in reversed(children):\n        if isinstance(child, ast.ImportFrom) and child.module == '__future__':\n            future_import_lineno = child.lineno\n            break\n    else:\n        future_import_lineno = 0  # no \"from __future__ import\" statement found\n\n    if future_import_lineno > 0:\n        # insert patch after the last __future__ import\n        patch_py_contents = self._patch_py_contents(False, libs_dir, load_order_filename, depth)\n        py_contents_split = py_contents.splitlines(True)\n        with open(py_path, 'w', newline=newline) as file:\n            file.write(''.join(py_contents_split[:future_import_lineno]).rstrip())\n            file.write('\\n\\n\\n')\n            file.write(patch_py_contents)\n            if remainder := ''.join(py_contents_split[future_import_lineno:]).lstrip():\n                file.write('\\n')\n                file.write(remainder)\n    elif docstring is not None:\n        # place patch just after docstring\n        patch_py_contents = self._patch_py_contents(False, libs_dir, load_order_filename, depth)\n        if len(children) == 0 or not isinstance(children[0], ast.Expr) or ast.literal_eval(children[0].value) != docstring:\n            # verify that the first child node is the docstring\n            raise ValueError(f'Error parsing {py_name}: docstring exists but is not the first element of the parse tree')\n        if len(children) == 1:\n            # append patch\n            with open(py_path, 'w', newline=newline) as file:\n                file.write(py_contents.rstrip())\n                file.write('\\n\\n\\n')\n                file.write(patch_py_contents)\n        else:\n            # insert patch after docstring\n            py_contents = '\\n'.join(py_contents.splitlines())  # normalize line endings\n            docstring_search_start_index = 0\n            for line in py_contents.splitlines(True):\n                if line.lstrip().startswith('#'):\n                    # ignore comments at start of file\n                    docstring_search_start_index += len(line)\n                else:\n                    break\n            pattern = (r'\"\"\"([^\\\\]|\\\\.)*?\"\"\"|'  # 3 double quotes\n                       r\"'''([^\\\\]|\\\\.)*?'''|\"  # 3 single quotes\n                       r'\"([^\\\\\\n]|\\\\.)*?\"|'  # 1 double quote\n                       r\"'([^\\\\\\n]|\\\\.)*?'\" )  # 1 single quote\n            if not (match := re.search(pattern, py_contents[docstring_search_start_index:], re.DOTALL)):\n                raise ValueError(f'Error parsing {py_name}: docstring exists but was not found')\n            docstring_end_index = docstring_search_start_index + match.end()\n            docstring_end_line = py_contents.find('\\n', docstring_end_index)\n            if docstring_end_line == -1:\n                docstring_end_line = len(py_contents)\n            if (extra_text := py_contents[docstring_end_index: docstring_end_line]) and not extra_text.isspace():\n                raise ValueError(f'Error parsing {py_name}: extra text {extra_text!r} is on the line where the docstring ends. Move the extra text to a new line and try again.')\n            with open(py_path, 'w', newline=newline) as file:\n                file.write(py_contents[:docstring_end_index].rstrip())\n                file.write('\\n\\n\\n')\n                file.write(patch_py_contents)\n                file.write('\\n')\n                file.write(py_contents[docstring_end_index:].lstrip())\n    else:\n        py_contents_lines = py_contents.splitlines()\n        start = 0\n        if py_contents_lines and py_contents_lines[0].startswith('#!'):\n            start = 1\n        while start < len(py_contents_lines) and py_contents_lines[start].strip() in ('', '#'):\n            start += 1\n        if start < len(py_contents_lines) and py_contents_lines[start][:1] == '#':\n            # insert patch after header comments\n            end = start + 1\n            while end < len(py_contents_lines) and py_contents_lines[end][:1] == '#':\n                end += 1\n            patch_py_contents = self._patch_py_contents(False, libs_dir, load_order_filename, depth)\n            with open(py_path, 'w', newline=newline) as file:\n                file.write('\\n'.join(py_contents_lines[:end]).rstrip())\n                file.write('\\n\\n\\n')\n                file.write(patch_py_contents)\n                if remainder := '\\n'.join(py_contents_lines[end:]).lstrip():\n                    file.write('\\n')\n                    file.write(remainder)\n                    if not remainder.endswith('\\n'):\n                        file.write('\\n')\n        elif py_contents_lines and py_contents_lines[0].startswith('#!'):\n            # insert patch after shebang\n            patch_py_contents = self._patch_py_contents(False, libs_dir, load_order_filename, depth)\n            with open(py_path, 'w', newline=newline) as file:\n                file.write(py_contents_lines[0].rstrip())\n                file.write('\\n\\n\\n')\n                file.write(patch_py_contents)\n                if remainder := '\\n'.join(py_contents_lines[1:]).lstrip():\n                    file.write('\\n')\n                    file.write(remainder)\n                    if not remainder.endswith('\\n'):\n                        file.write('\\n')\n        else:\n            # prepend patch\n            patch_py_contents = self._patch_py_contents(True, libs_dir, load_order_filename, depth)\n            with open(py_path, 'w', newline=newline) as file:\n                file.write(patch_py_contents)\n                if remainder := py_contents.lstrip():\n                    file.write('\\n')\n                    file.write(remainder)\n                    if not remainder.endswith('\\n'):\n                        file.write('\\n')\n\n    # verify that the file can be parsed properly\n    with open(py_path) as file:\n        try:\n            ast.parse(file.read())\n        except SyntaxError:\n            raise ValueError(f'Error parsing {py_name}: Patch failed. This might occur if a node is split across multiple lines.')",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.relpath",
        "os.path.basename",
        "os.path.dirname",
        "os.path.relpath",
        "os.path.isfile",
        "open",
        "open",
        "open",
        "open",
        "open",
        "open",
        "open",
        "open",
        "open"
      ],
      "api_sequence_with_args": [
        "os.path.relpath(py_path, self._extract_dir)",
        "os.path.basename(py_path)",
        "os.path.dirname(os.path.relpath(py_path, self._extract_dir))",
        "os.path.relpath(py_path, self._extract_dir)",
        "os.path.isfile(py_path)",
        "open(py_path)",
        "open(py_path, 'a+')",
        "open(py_path, newline='')",
        "open(py_path)",
        "open(py_path, 'w', newline=newline)",
        "open(py_path)",
        "open(py_path, 'w', newline=newline)",
        "open(py_path, 'w', newline=newline)",
        "open(py_path)"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.relpath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.basename",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.dirname",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.relpath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.isfile",
          "id": "check_file_is_file",
          "description": "Checks if specified path exists and is a file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open",
          "id": "combined_mode_operations",
          "description": "Combined mode file opening operations (read-write mode, append mode, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        }
      ],
      "contextual_code": "import os\nimport ast\nimport re\nimport warnings\n\ndef _patch_py_file(self, py_path: str, libs_dir: str, load_order_filename: typing.Optional[str], depth: int) -> None:\n    print(f'patching {os.path.relpath(py_path, self._extract_dir)}')\n\n    py_name = os.path.basename(py_path)\n    if py_name.lower() == '__init__.py':\n        package_dir = os.path.dirname(os.path.relpath(py_path, self._extract_dir))\n        if os.path.isfile(py_path):\n            with open(py_path) as file:\n                for line in file:\n                    ...\n        ...\n    open(py_path, 'a+').close()\n    with open(py_path, newline='') as file:\n        line = file.readline()\n    with open(py_path) as file:\n        py_contents = file.read()\n    node = ast.parse(py_contents)\n    ...\n    if future_import_lineno > 0:\n        ...\n        with open(py_path, 'w', newline=newline) as file:\n            ...\n    elif docstring is not None:\n        ...\n        with open(py_path, 'w', newline=newline) as file:\n            ...\n    else:\n        ...\n        if start < len(py_contents_lines) and py_contents_lines[start][:1] == '#':\n            ...\n            with open(py_path, 'w', newline=newline) as file:\n                ...\n        elif py_contents_lines and py_contents_lines[0].startswith('#!'):\n            ...\n            with open(py_path, 'w', newline=newline) as file:\n                ...\n        else:\n            ...\n            with open(py_path, 'w', newline=newline) as file:\n                ...\n    with open(py_path) as file:\n        try:\n            ast.parse(file.read())\n        except SyntaxError:\n            raise ValueError(f'Error parsing {py_name}: Patch failed. This might occur if a node is split across multiple lines.')"
    }
  }
]