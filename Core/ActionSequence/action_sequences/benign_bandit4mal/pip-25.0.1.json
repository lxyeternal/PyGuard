[
  {
    "metadata": {
      "package_name": "pip-25.0.1",
      "total_matches": 3,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "wheel.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pip-25.0.1/pip-25.0.1/src/pip/_internal/operations/install/wheel.py",
    "line_number": "618",
    "type_description": "B843:compile_file",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "617\t                for path in pyc_source_file_paths():\n618\t                    success = compileall.compile_file(path, force=True, quiet=True)\n619\t                    if success:",
    "code_snippet": "def _install_wheel(  # noqa: C901, PLR0915 function is too long\n    name: str,\n    wheel_zip: ZipFile,\n    wheel_path: str,\n    scheme: Scheme,\n    pycompile: bool = True,\n    warn_script_location: bool = True,\n    direct_url: Optional[DirectUrl] = None,\n    requested: bool = False,\n) -> None:\n    \"\"\"Install a wheel.\n\n    :param name: Name of the project to install\n    :param wheel_zip: open ZipFile for wheel being installed\n    :param scheme: Distutils scheme dictating the install directories\n    :param req_description: String used in place of the requirement, for\n        logging\n    :param pycompile: Whether to byte-compile installed Python files\n    :param warn_script_location: Whether to check that scripts are installed\n        into a directory on PATH\n    :raises UnsupportedWheel:\n        * when the directory holds an unpacked wheel with incompatible\n          Wheel-Version\n        * when the .dist-info dir does not match the wheel\n    \"\"\"\n    info_dir, metadata = parse_wheel(wheel_zip, name)\n\n    if wheel_root_is_purelib(metadata):\n        lib_dir = scheme.purelib\n    else:\n        lib_dir = scheme.platlib\n\n    # Record details of the files moved\n    #   installed = files copied from the wheel to the destination\n    #   changed = files changed while installing (scripts #! line typically)\n    #   generated = files newly generated during the install (script wrappers)\n    installed: Dict[RecordPath, RecordPath] = {}\n    changed: Set[RecordPath] = set()\n    generated: List[str] = []\n\n    def record_installed(\n        srcfile: RecordPath, destfile: str, modified: bool = False\n    ) -> None:\n        \"\"\"Map archive RECORD paths to installation RECORD paths.\"\"\"\n        newpath = _fs_to_record_path(destfile, lib_dir)\n        installed[srcfile] = newpath\n        if modified:\n            changed.add(newpath)\n\n    def is_dir_path(path: RecordPath) -> bool:\n        return path.endswith(\"/\")\n\n    def assert_no_path_traversal(dest_dir_path: str, target_path: str) -> None:\n        if not is_within_directory(dest_dir_path, target_path):\n            message = (\n                \"The wheel {!r} has a file {!r} trying to install\"\n                \" outside the target directory {!r}\"\n            )\n            raise InstallationError(\n                message.format(wheel_path, target_path, dest_dir_path)\n            )\n\n    def root_scheme_file_maker(\n        zip_file: ZipFile, dest: str\n    ) -> Callable[[RecordPath], \"File\"]:\n        def make_root_scheme_file(record_path: RecordPath) -> \"File\":\n            normed_path = os.path.normpath(record_path)\n            dest_path = os.path.join(dest, normed_path)\n            assert_no_path_traversal(dest, dest_path)\n            return ZipBackedFile(record_path, dest_path, zip_file)\n\n        return make_root_scheme_file\n\n    def data_scheme_file_maker(\n        zip_file: ZipFile, scheme: Scheme\n    ) -> Callable[[RecordPath], \"File\"]:\n        scheme_paths = {key: getattr(scheme, key) for key in SCHEME_KEYS}\n\n        def make_data_scheme_file(record_path: RecordPath) -> \"File\":\n            normed_path = os.path.normpath(record_path)\n            try:\n                _, scheme_key, dest_subpath = normed_path.split(os.path.sep, 2)\n            except ValueError:\n                message = (\n                    f\"Unexpected file in {wheel_path}: {record_path!r}. .data directory\"\n                    \" contents should be named like: '<scheme key>/<path>'.\"\n                )\n                raise InstallationError(message)\n\n            try:\n                scheme_path = scheme_paths[scheme_key]\n            except KeyError:\n                valid_scheme_keys = \", \".join(sorted(scheme_paths))\n                message = (\n                    f\"Unknown scheme key used in {wheel_path}: {scheme_key} \"\n                    f\"(for file {record_path!r}). .data directory contents \"\n                    f\"should be in subdirectories named with a valid scheme \"\n                    f\"key ({valid_scheme_keys})\"\n                )\n                raise InstallationError(message)\n\n            dest_path = os.path.join(scheme_path, dest_subpath)\n            assert_no_path_traversal(scheme_path, dest_path)\n            return ZipBackedFile(record_path, dest_path, zip_file)\n\n        return make_data_scheme_file\n\n    def is_data_scheme_path(path: RecordPath) -> bool:\n        return path.split(\"/\", 1)[0].endswith(\".data\")\n\n    paths = cast(List[RecordPath], wheel_zip.namelist())\n    file_paths = filterfalse(is_dir_path, paths)\n    root_scheme_paths, data_scheme_paths = partition(is_data_scheme_path, file_paths)\n\n    make_root_scheme_file = root_scheme_file_maker(wheel_zip, lib_dir)\n    files: Iterator[File] = map(make_root_scheme_file, root_scheme_paths)\n\n    def is_script_scheme_path(path: RecordPath) -> bool:\n        parts = path.split(\"/\", 2)\n        return len(parts) > 2 and parts[0].endswith(\".data\") and parts[1] == \"scripts\"\n\n    other_scheme_paths, script_scheme_paths = partition(\n        is_script_scheme_path, data_scheme_paths\n    )\n\n    make_data_scheme_file = data_scheme_file_maker(wheel_zip, scheme)\n    other_scheme_files = map(make_data_scheme_file, other_scheme_paths)\n    files = chain(files, other_scheme_files)\n\n    # Get the defined entry points\n    distribution = get_wheel_distribution(\n        FilesystemWheel(wheel_path),\n        canonicalize_name(name),\n    )\n    console, gui = get_entrypoints(distribution)\n\n    def is_entrypoint_wrapper(file: \"File\") -> bool:\n        # EP, EP.exe and EP-script.py are scripts generated for\n        # entry point EP by setuptools\n        path = file.dest_path\n        name = os.path.basename(path)\n        if name.lower().endswith(\".exe\"):\n            matchname = name[:-4]\n        elif name.lower().endswith(\"-script.py\"):\n            matchname = name[:-10]\n        elif name.lower().endswith(\".pya\"):\n            matchname = name[:-4]\n        else:\n            matchname = name\n        # Ignore setuptools-generated scripts\n        return matchname in console or matchname in gui\n\n    script_scheme_files: Iterator[File] = map(\n        make_data_scheme_file, script_scheme_paths\n    )\n    script_scheme_files = filterfalse(is_entrypoint_wrapper, script_scheme_files)\n    script_scheme_files = map(ScriptFile, script_scheme_files)\n    files = chain(files, script_scheme_files)\n\n    existing_parents = set()\n    for file in files:\n        # directory creation is lazy and after file filtering\n        # to ensure we don't install empty dirs; empty dirs can't be\n        # uninstalled.\n        parent_dir = os.path.dirname(file.dest_path)\n        if parent_dir not in existing_parents:\n            ensure_dir(parent_dir)\n            existing_parents.add(parent_dir)\n        file.save()\n        record_installed(file.src_record_path, file.dest_path, file.changed)\n\n    def pyc_source_file_paths() -> Generator[str, None, None]:\n        # We de-duplicate installation paths, since there can be overlap (e.g.\n        # file in .data maps to same location as file in wheel root).\n        # Sorting installation paths makes it easier to reproduce and debug\n        # issues related to permissions on existing files.\n        for installed_path in sorted(set(installed.values())):\n            full_installed_path = os.path.join(lib_dir, installed_path)\n            if not os.path.isfile(full_installed_path):\n                continue\n            if not full_installed_path.endswith(\".py\"):\n                continue\n            yield full_installed_path\n\n    def pyc_output_path(path: str) -> str:\n        \"\"\"Return the path the pyc file would have been written to.\"\"\"\n        return importlib.util.cache_from_source(path)\n\n    # Compile all of the pyc files for the installed files\n    if pycompile:\n        with contextlib.redirect_stdout(\n            StreamWrapper.from_stream(sys.stdout)\n        ) as stdout:\n            with warnings.catch_warnings():\n                warnings.filterwarnings(\"ignore\")\n                for path in pyc_source_file_paths():\n                    success = compileall.compile_file(path, force=True, quiet=True)\n                    if success:\n                        pyc_path = pyc_output_path(path)\n                        assert os.path.exists(pyc_path)\n                        pyc_record_path = cast(\n                            \"RecordPath\", pyc_path.replace(os.path.sep, \"/\")\n                        )\n                        record_installed(pyc_record_path, pyc_path)\n        logger.debug(stdout.getvalue())\n\n    maker = PipScriptMaker(None, scheme.scripts)\n\n    # Ensure old scripts are overwritten.\n    # See https://github.com/pypa/pip/issues/1800\n    maker.clobber = True\n\n    # Ensure we don't generate any variants for scripts because this is almost\n    # never what somebody wants.\n    # See https://bitbucket.org/pypa/distlib/issue/35/\n    maker.variants = {\"\"}\n\n    # This is required because otherwise distlib creates scripts that are not\n    # executable.\n    # See https://bitbucket.org/pypa/distlib/issue/32/\n    maker.set_mode = True\n\n    # Generate the console and GUI entry points specified in the wheel\n    scripts_to_generate = get_console_script_specs(console)\n\n    gui_scripts_to_generate = list(starmap(\"{} = {}\".format, gui.items()))\n\n    generated_console_scripts = maker.make_multiple(scripts_to_generate)\n    generated.extend(generated_console_scripts)\n\n    generated.extend(maker.make_multiple(gui_scripts_to_generate, {\"gui\": True}))\n\n    if warn_script_location:\n        msg = message_about_scripts_not_on_PATH(generated_console_scripts)\n        if msg is not None:\n            logger.warning(msg)\n\n    generated_file_mode = 0o666 & ~current_umask()\n\n    @contextlib.contextmanager\n    def _generate_file(path: str, **kwargs: Any) -> Generator[BinaryIO, None, None]:\n        with adjacent_tmp_file(path, **kwargs) as f:\n            yield f\n        os.chmod(f.name, generated_file_mode)\n        replace(f.name, path)\n\n    dest_info_dir = os.path.join(lib_dir, info_dir)\n\n    # Record pip as the installer\n    installer_path = os.path.join(dest_info_dir, \"INSTALLER\")\n    with _generate_file(installer_path) as installer_file:\n        installer_file.write(b\"pip\\n\")\n    generated.append(installer_path)\n\n    # Record the PEP 610 direct URL reference\n    if direct_url is not None:\n        direct_url_path = os.path.join(dest_info_dir, DIRECT_URL_METADATA_NAME)\n        with _generate_file(direct_url_path) as direct_url_file:\n            direct_url_file.write(direct_url.to_json().encode(\"utf-8\"))\n        generated.append(direct_url_path)\n\n    # Record the REQUESTED file\n    if requested:\n        requested_path = os.path.join(dest_info_dir, \"REQUESTED\")\n        with open(requested_path, \"wb\"):\n            pass\n        generated.append(requested_path)\n\n    record_text = distribution.read_text(\"RECORD\")\n    record_rows = list(csv.reader(record_text.splitlines()))\n\n    rows = get_csv_rows_for_installed(\n        record_rows,\n        installed=installed,\n        changed=changed,\n        generated=generated,\n        lib_dir=lib_dir,\n    )\n\n    # Record details of all files installed\n    record_path = os.path.join(dest_info_dir, \"RECORD\")\n\n    with _generate_file(record_path, **csv_io_kwargs(\"w\")) as record_file:\n        # Explicitly cast to typing.IO[str] as a workaround for the mypy error:\n        # \"writer\" has incompatible type \"BinaryIO\"; expected \"_Writer\"\n        writer = csv.writer(cast(\"IO[str]\", record_file))\n        writer.writerows(_normalized_outrows(rows))",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.normpath",
        "os.path.join",
        "os.path.normpath",
        "os.path.sep",
        "os.path.join",
        "os.path.join",
        "os.path.basename",
        "os.path.dirname",
        "os.path.dirname",
        "os.path.isfile",
        "os.path.join",
        "os.path.exists",
        "importlib.util.cache_from_source",
        "contextlib.redirect_stdout",
        "warnings.catch_warnings",
        "warnings.filterwarnings",
        "compileall.compile_file",
        "os.path.exists",
        "os.path.sep",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.chmod",
        "replace",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "open"
      ],
      "api_sequence_with_args": [
        "os.path.normpath(record_path)",
        "os.path.join(dest, normed_path)",
        "os.path.normpath(record_path)",
        "os.path.sep",
        "os.path.join(scheme_path, dest_subpath)",
        "os.path.join(lib_dir, installed_path)",
        "os.path.basename(path)",
        "os.path.dirname(file.dest_path)",
        "os.path.dirname(file.dest_path)",
        "os.path.isfile(full_installed_path)",
        "os.path.join(lib_dir, installed_path)",
        "os.path.exists(pyc_path)",
        "importlib.util.cache_from_source(path)",
        "contextlib.redirect_stdout(StreamWrapper.from_stream(sys.stdout))",
        "warnings.catch_warnings()",
        "warnings.filterwarnings(\"ignore\")",
        "compileall.compile_file(path, force=True, quiet=True)",
        "os.path.exists(pyc_path)",
        "os.path.sep",
        "os.path.join(dest_info_dir, \"INSTALLER\")",
        "os.path.join(dest_info_dir, DIRECT_URL_METADATA_NAME)",
        "os.path.join(dest_info_dir, \"REQUESTED\")",
        "os.chmod(f.name, generated_file_mode)",
        "replace(f.name, path)",
        "os.path.join(dest_info_dir, \"RECORD\")",
        "os.path.join(dest_info_dir, \"RECORD\")",
        "os.path.join(dest_info_dir, \"REQUESTED\")",
        "open(requested_path, \"wb\")"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.normpath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.normpath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.sep",
          "id": "get_os_path_sep",
          "description": "Retrieves operating system path separator",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.basename",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.dirname",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.dirname",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.isfile",
          "id": "check_file_is_file",
          "description": "Checks if specified path exists and is a file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "importlib.util.cache_from_source",
          "id": "compile_code_object",
          "description": "Compiles source code string into executable code object",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "contextlib.redirect_stdout",
          "id": "error_handling_operations",
          "description": "File opening operations with error handling (ignore errors, custom error handling, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "warnings.catch_warnings",
          "id": "error_handling_operations",
          "description": "File opening operations with error handling (ignore errors, custom error handling, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "warnings.filterwarnings",
          "id": "error_handling_operations",
          "description": "File opening operations with error handling (ignore errors, custom error handling, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "compileall.compile_file",
          "id": "compile_code_object",
          "description": "Compiles source code string into executable code object",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.path.sep",
          "id": "get_os_path_sep",
          "description": "Retrieves operating system path separator",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.chmod",
          "id": "set_file_attributes",
          "description": "Sets file attributes for specified file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_attribute_management"
        },
        {
          "api_name": "replace",
          "id": "rename_file",
          "description": "Renames file or moves it to new location",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        }
      ],
      "contextual_code": "def _install_wheel(...):\n    ...\n    def root_scheme_file_maker(zip_file: ZipFile, dest: str):\n        def make_root_scheme_file(record_path: RecordPath):\n            normed_path = os.path.normpath(record_path)\n            dest_path = os.path.join(dest, normed_path)\n            ...\n            return ZipBackedFile(record_path, dest_path, zip_file)\n        return make_root_scheme_file\n\n    def data_scheme_file_maker(zip_file: ZipFile, scheme: Scheme):\n        ...\n        def make_data_scheme_file(record_path: RecordPath):\n            normed_path = os.path.normpath(record_path)\n            ...\n            _, scheme_key, dest_subpath = normed_path.split(os.path.sep, 2)\n            ...\n            dest_path = os.path.join(scheme_path, dest_subpath)\n            ...\n            return ZipBackedFile(record_path, dest_path, zip_file)\n        return make_data_scheme_file\n\n    ...\n    for file in files:\n        parent_dir = os.path.dirname(file.dest_path)\n        ...\n        file.save()\n        ...\n\n    def pyc_source_file_paths():\n        for installed_path in sorted(set(installed.values())):\n            full_installed_path = os.path.join(lib_dir, installed_path)\n            if not os.path.isfile(full_installed_path):\n                continue\n            if not full_installed_path.endswith(\".py\"):\n                continue\n            yield full_installed_path\n\n    def pyc_output_path(path: str) -> str:\n        return importlib.util.cache_from_source(path)\n\n    if pycompile:\n        with contextlib.redirect_stdout(StreamWrapper.from_stream(sys.stdout)) as stdout:\n            with warnings.catch_warnings():\n                warnings.filterwarnings(\"ignore\")\n                for path in pyc_source_file_paths():\n                    success = compileall.compile_file(path, force=True, quiet=True)\n                    if success:\n                        pyc_path = pyc_output_path(path)\n                        assert os.path.exists(pyc_path)\n                        ...\n                        record_installed(pyc_record_path, pyc_path)\n        logger.debug(stdout.getvalue())\n\n    ...\n    @contextlib.contextmanager\n    def _generate_file(path: str, **kwargs: Any):\n        with adjacent_tmp_file(path, **kwargs) as f:\n            yield f\n        os.chmod(f.name, generated_file_mode)\n        replace(f.name, path)\n\n    dest_info_dir = os.path.join(lib_dir, info_dir)\n    installer_path = os.path.join(dest_info_dir, \"INSTALLER\")\n    with _generate_file(installer_path) as installer_file:\n        installer_file.write(b\"pip\\n\")\n    ...\n    if direct_url is not None:\n        direct_url_path = os.path.join(dest_info_dir, DIRECT_URL_METADATA_NAME)\n        with _generate_file(direct_url_path) as direct_url_file:\n            direct_url_file.write(direct_url.to_json().encode(\"utf-8\"))\n        ...\n    if requested:\n        requested_path = os.path.join(dest_info_dir, \"REQUESTED\")\n        with open(requested_path, \"wb\"):\n            pass\n        ...\n    record_path = os.path.join(dest_info_dir, \"RECORD\")\n    with _generate_file(record_path, **csv_io_kwargs(\"w\")) as record_file:\n        writer = csv.writer(cast(\"IO[str]\", record_file))\n        writer.writerows(_normalized_outrows(rows))"
    }
  },
  {
    "pyfile": "pyopenssl.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pip-25.0.1/pip-25.0.1/src/pip/_vendor/urllib3/contrib/pyopenssl.py",
    "line_number": "378",
    "type_description": "B807:close",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "377\t                self._closed = True\n378\t                return self.connection.close()\n379\t            except OpenSSL.SSL.Error:",
    "code_snippet": "def close(self):\n    if self._makefile_refs < 1:\n        try:\n            self._closed = True\n            return self.connection.close()\n        except OpenSSL.SSL.Error:\n            return\n    else:\n        self._makefile_refs -= 1",
    "pattern_analysis": {
      "api_sequence": [
        "self.connection.close"
      ],
      "api_sequence_with_args": [
        "self.connection.close()"
      ],
      "mapped_sequence": [
        {
          "api_name": "self.connection.close",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        }
      ],
      "contextual_code": "def close(self):\n    if self._makefile_refs < 1:\n        try:\n            self._closed = True\n            return self.connection.close()\n        except OpenSSL.SSL.Error:\n            return\n    else:\n        self._makefile_refs -= 1"
    }
  },
  {
    "pyfile": "pyopenssl.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pip-25.0.1/pip-25.0.1/src/pip/_vendor/urllib3/contrib/pyopenssl.py",
    "line_number": "349",
    "type_description": "B808:settimeout",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "348\t    def settimeout(self, timeout):\n349\t        return self.socket.settimeout(timeout)\n350",
    "code_snippet": "class WrappedSocket(object):\n    \"\"\"API-compatibility wrapper for Python OpenSSL's Connection-class.\n\n    Note: _makefile_refs, _drop() and _reuse() are needed for the garbage\n    collector of pypy.\n    \"\"\"\n\n    def __init__(self, connection, socket, suppress_ragged_eofs=True):\n        self.connection = connection\n        self.socket = socket\n        self.suppress_ragged_eofs = suppress_ragged_eofs\n        self._makefile_refs = 0\n        self._closed = False\n\n    def fileno(self):\n        return self.socket.fileno()\n\n    # Copy-pasted from Python 3.5 source code\n    def _decref_socketios(self):\n        if self._makefile_refs > 0:\n            self._makefile_refs -= 1\n        if self._closed:\n            self.close()\n\n    def recv(self, *args, **kwargs):\n        try:\n            data = self.connection.recv(*args, **kwargs)\n        except OpenSSL.SSL.SysCallError as e:\n            if self.suppress_ragged_eofs and e.args == (-1, \"Unexpected EOF\"):\n                return b\"\"\n            else:\n                raise SocketError(str(e))\n        except OpenSSL.SSL.ZeroReturnError:\n            if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:\n                return b\"\"\n            else:\n                raise\n        except OpenSSL.SSL.WantReadError:\n            if not util.wait_for_read(self.socket, self.socket.gettimeout()):\n                raise timeout(\"The read operation timed out\")\n            else:\n                return self.recv(*args, **kwargs)\n\n        # TLS 1.3 post-handshake authentication\n        except OpenSSL.SSL.Error as e:\n            raise ssl.SSLError(\"read error: %r\" % e)\n        else:\n            return data\n\n    def recv_into(self, *args, **kwargs):\n        try:\n            return self.connection.recv_into(*args, **kwargs)\n        except OpenSSL.SSL.SysCallError as e:\n            if self.suppress_ragged_eofs and e.args == (-1, \"Unexpected EOF\"):\n                return 0\n            else:\n                raise SocketError(str(e))\n        except OpenSSL.SSL.ZeroReturnError:\n            if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:\n                return 0\n            else:\n                raise\n        except OpenSSL.SSL.WantReadError:\n            if not util.wait_for_read(self.socket, self.socket.gettimeout()):\n                raise timeout(\"The read operation timed out\")\n            else:\n                return self.recv_into(*args, **kwargs)\n\n        # TLS 1.3 post-handshake authentication\n        except OpenSSL.SSL.Error as e:\n            raise ssl.SSLError(\"read error: %r\" % e)\n\n    def settimeout(self, timeout):\n        return self.socket.settimeout(timeout)\n",
    "pattern_analysis": {
      "api_sequence": [
        "socket.fileno",
        "connection.recv",
        "OpenSSL.SSL.SysCallError",
        "OpenSSL.SSL.ZeroReturnError",
        "connection.get_shutdown",
        "OpenSSL.SSL.WantReadError",
        "util.wait_for_read",
        "socket.gettimeout",
        "OpenSSL.SSL.Error",
        "ssl.SSLError",
        "connection.recv_into",
        "socket.settimeout"
      ],
      "api_sequence_with_args": [
        "socket.fileno()",
        "connection.recv(*args, **kwargs)",
        "OpenSSL.SSL.SysCallError as e",
        "OpenSSL.SSL.ZeroReturnError",
        "connection.get_shutdown()",
        "OpenSSL.SSL.WantReadError",
        "util.wait_for_read(self.socket, self.socket.gettimeout())",
        "socket.gettimeout()",
        "OpenSSL.SSL.Error as e",
        "ssl.SSLError(\"read error: %r\" % e)",
        "connection.recv_into(*args, **kwargs)",
        "socket.settimeout(timeout)"
      ],
      "mapped_sequence": [
        {
          "api_name": "socket.fileno",
          "id": "get_socket_fd",
          "description": "Retrieves file descriptor for socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "connection.recv",
          "id": "receive_socket_data",
          "description": "Receives data from socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "OpenSSL.SSL.SysCallError",
          "id": "handle_socket_timeout",
          "description": "Handles socket timeout exception",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_configuration"
        },
        {
          "api_name": "OpenSSL.SSL.ZeroReturnError",
          "id": "handle_socket_timeout",
          "description": "Handles socket timeout exception",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_configuration"
        },
        {
          "api_name": "connection.get_shutdown",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "OpenSSL.SSL.WantReadError",
          "id": "handle_socket_timeout",
          "description": "Handles socket timeout exception",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_configuration"
        },
        {
          "api_name": "util.wait_for_read",
          "id": "set_socket_timeout",
          "description": "Sets timeout for socket operations",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_configuration"
        },
        {
          "api_name": "socket.gettimeout",
          "id": "set_socket_timeout",
          "description": "Sets timeout for socket operations",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_configuration"
        },
        {
          "api_name": "OpenSSL.SSL.Error",
          "id": "handle_socket_timeout",
          "description": "Handles socket timeout exception",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_configuration"
        },
        {
          "api_name": "ssl.SSLError",
          "id": "handle_socket_timeout",
          "description": "Handles socket timeout exception",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_configuration"
        },
        {
          "api_name": "connection.recv_into",
          "id": "receive_socket_data",
          "description": "Receives data from socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "socket.settimeout",
          "id": "set_socket_timeout",
          "description": "Sets timeout for socket operations",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_configuration"
        }
      ],
      "contextual_code": "class WrappedSocket(object):\n    def fileno(self):\n        return self.socket.fileno()\n\n    def recv(self, *args, **kwargs):\n        try:\n            data = self.connection.recv(*args, **kwargs)\n        except OpenSSL.SSL.SysCallError as e:\n            if self.suppress_ragged_eofs and e.args == (-1, \"Unexpected EOF\"):\n                return b\"\"\n            else:\n                raise SocketError(str(e))\n        except OpenSSL.SSL.ZeroReturnError:\n            if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:\n                return b\"\"\n            else:\n                raise\n        except OpenSSL.SSL.WantReadError:\n            if not util.wait_for_read(self.socket, self.socket.gettimeout()):\n                raise timeout(\"The read operation timed out\")\n            else:\n                return self.recv(*args, **kwargs)\n        except OpenSSL.SSL.Error as e:\n            raise ssl.SSLError(\"read error: %r\" % e)\n        else:\n            return data\n\n    def recv_into(self, *args, **kwargs):\n        try:\n            return self.connection.recv_into(*args, **kwargs)\n        except OpenSSL.SSL.SysCallError as e:\n            if self.suppress_ragged_eofs and e.args == (-1, \"Unexpected EOF\"):\n                return 0\n            else:\n                raise SocketError(str(e))\n        except OpenSSL.SSL.ZeroReturnError:\n            if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:\n                return 0\n            else:\n                raise\n        except OpenSSL.SSL.WantReadError:\n            if not util.wait_for_read(self.socket, self.socket.gettimeout()):\n                raise timeout(\"The read operation timed out\")\n            else:\n                return self.recv_into(*args, **kwargs)\n        except OpenSSL.SSL.Error as e:\n            raise ssl.SSLError(\"read error: %r\" % e)\n\n    def settimeout(self, timeout):\n        return self.socket.settimeout(timeout)"
    }
  }
]