[
  {
    "metadata": {
      "package_name": "snowflake_core-1.3.0",
      "total_matches": 6,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "api_client.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/snowflake_core-1.3.0/snowflake_core-1.3.0/src/snowflake/core/cortex/inference_service/_generated/api_client.py",
    "line_number": "563",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "code_snippet": "def request_with_retry(self,\n                       root,\n                       method,\n                       url,\n                       query_params=None,\n                       headers=None,\n                       post_params=None,\n                       body=None,\n                       _preload_content=True,\n                       _request_timeout=None):\n    \"\"\"Response time by default one hour.\"\"\"\n    enter_timing = time.time()\n    response_data = self.request(root,\n                                 method,\n                                 url,\n                                 query_params=query_params,\n                                 headers=headers,\n                                 post_params=post_params,\n                                 body=body,\n                                 _preload_content=_preload_content,\n                                 _request_timeout=_request_timeout)\n\n    if not root.parameters(\n    ).should_retry_request or response_data.status not in rest.RETRY_STATUS_CODES:\n        return response_data\n\n    logger.info(\n        f\"Request Status {response_data.status} ({snowflake.core._http_requests.STATUS_CODES_MAPPING.get(response_data.status)}) Retrying...\"\n    )\n    # Query retry support\n    result_endpoint = response_data.getheader('Location')\n    if response_data.status == 202 and result_endpoint is None:\n        raise InvalidResponseError(\n            f\"{snowflake.core._http_requests.STATUS_CODES_MAPPING.get(response_data.status)} result endpoint is missing\"\n        )\n\n    if _request_timeout is None:\n        _request_timeout = snowflake.core._http_requests.DEFAULT_RETRY_TIMEOUT_SECONDS\n    wait_for_results_timeout = enter_timing + _request_timeout\n\n    exponential_wait_time = 1  # wait time increases exponentially, 30% more everytime\n    while True:\n        time_remaining = wait_for_results_timeout - time.time()\n        if time_remaining <= 0:\n            break\n        # Full Jitter\n        # ref: https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\n        # Take max(1, wait_time) to avoid making too many requests in a short period\n        wait_time = max(\n            1,\n            random.randint(0,\n                           int(min(exponential_wait_time,\n                                   time_remaining))))\n\n        if response_data.status in rest.RETRY_STATUS_CODES:\n            logger.info(\n                f\"{snowflake.core._http_requests.STATUS_CODES_MAPPING.get(response_data.status)} detected. Sleeping for {wait_time} seconds before checking again\"\n            )\n\n            time.sleep(wait_time)\n\n            new_url = url\n            if response_data.status == 202:\n                new_url = self.configuration.host + result_endpoint\n                method = \"GET\"\n\n            response_data = self.request(\n                root,\n                method,\n                new_url,\n                query_params=query_params,\n                headers=headers,\n                post_params=post_params,\n                body=body,\n                _preload_content=_preload_content,\n                _request_timeout=max(time_remaining - wait_time, 1)\n                # request_timeout can never be zero\n            )\n        else:\n            logger.info(\n                f\"{snowflake.core._http_requests.STATUS_CODES_MAPPING.get(response_data.status)} query completed\"\n            )\n            return response_data\n\n        exponential_wait_time *= 1.3\n\n    raise RetryTimeoutError(\n        f\"{response_data.status} {snowflake.core._http_requests.STATUS_CODES_MAPPING.get(response_data.status)} query timeout\"\n    )",
    "pattern_analysis": {
      "api_sequence": [
        "time.time",
        "self.request",
        "root.parameters",
        "logger.info",
        "response_data.getheader",
        "time.time",
        "random.randint",
        "logger.info",
        "time.sleep",
        "self.request",
        "logger.info"
      ],
      "api_sequence_with_args": [
        "time.time()",
        "self.request(root, method, url, query_params=query_params, headers=headers, post_params=post_params, body=body, _preload_content=_preload_content, _request_timeout=_request_timeout)",
        "root.parameters()",
        "logger.info(f\"Request Status {response_data.status} ({snowflake.core._http_requests.STATUS_CODES_MAPPING.get(response_data.status)}) Retrying...\")",
        "response_data.getheader('Location')",
        "time.time()",
        "random.randint(0, int(min(exponential_wait_time, time_remaining)))",
        "logger.info(f\"{snowflake.core._http_requests.STATUS_CODES_MAPPING.get(response_data.status)} detected. Sleeping for {wait_time} seconds before checking again\")",
        "time.sleep(wait_time)",
        "self.request(root, method, new_url, query_params=query_params, headers=headers, post_params=post_params, body=body, _preload_content=_preload_content, _request_timeout=max(time_remaining - wait_time, 1))",
        "logger.info(f\"{snowflake.core._http_requests.STATUS_CODES_MAPPING.get(response_data.status)} query completed\")"
      ],
      "mapped_sequence": [
        {
          "api_name": "time.time",
          "id": "get_current_time",
          "description": "Returns current time in seconds since epoch",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "self.request",
          "id": "send_http_custom",
          "description": "Sends HTTP request with specified method and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "root.parameters",
          "id": "get_global_symbols",
          "description": "Retrieves global symbol table as dictionary",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "logger.info",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "response_data.getheader",
          "id": "get_response_body",
          "description": "Retrieves response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "time.time",
          "id": "get_current_time",
          "description": "Returns current time in seconds since epoch",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "random.randint",
          "id": "get_global_symbols",
          "description": "Retrieves global symbol table as dictionary",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "logger.info",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "time.sleep",
          "id": "suspend_execution",
          "description": "Suspends execution for specified seconds",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "self.request",
          "id": "send_http_custom",
          "description": "Sends HTTP request with specified method and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "logger.info",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        }
      ],
      "contextual_code": "def request_with_retry(self,\n                       root,\n                       method,\n                       url,\n                       query_params=None,\n                       headers=None,\n                       post_params=None,\n                       body=None,\n                       _preload_content=True,\n                       _request_timeout=None):\n    enter_timing = time.time()\n    response_data = self.request(root,\n                                 method,\n                                 url,\n                                 query_params=query_params,\n                                 headers=headers,\n                                 post_params=post_params,\n                                 body=body,\n                                 _preload_content=_preload_content,\n                                 _request_timeout=_request_timeout)\n\n    if not root.parameters().should_retry_request or response_data.status not in rest.RETRY_STATUS_CODES:\n        return response_data\n\n    logger.info(f\"Request Status {response_data.status} ({snowflake.core._http_requests.STATUS_CODES_MAPPING.get(response_data.status)}) Retrying...\")\n    result_endpoint = response_data.getheader('Location')\n    if response_data.status == 202 and result_endpoint is None:\n        raise InvalidResponseError(\n            f\"{snowflake.core._http_requests.STATUS_CODES_MAPPING.get(response_data.status)} result endpoint is missing\"\n        )\n\n    if _request_timeout is None:\n        _request_timeout = snowflake.core._http_requests.DEFAULT_RETRY_TIMEOUT_SECONDS\n    wait_for_results_timeout = enter_timing + _request_timeout\n\n    exponential_wait_time = 1\n    while True:\n        time_remaining = wait_for_results_timeout - time.time()\n        if time_remaining <= 0:\n            break\n        wait_time = max(\n            1,\n            random.randint(0,\n                           int(min(exponential_wait_time,\n                                   time_remaining))))\n\n        if response_data.status in rest.RETRY_STATUS_CODES:\n            logger.info(f\"{snowflake.core._http_requests.STATUS_CODES_MAPPING.get(response_data.status)} detected. Sleeping for {wait_time} seconds before checking again\")\n            time.sleep(wait_time)\n            new_url = url\n            if response_data.status == 202:\n                new_url = self.configuration.host + result_endpoint\n                method = \"GET\"\n            response_data = self.request(\n                root,\n                method,\n                new_url,\n                query_params=query_params,\n                headers=headers,\n                post_params=post_params,\n                body=body,\n                _preload_content=_preload_content,\n                _request_timeout=max(time_remaining - wait_time, 1)\n            )\n        else:\n            logger.info(f\"{snowflake.core._http_requests.STATUS_CODES_MAPPING.get(response_data.status)} query completed\")\n            return response_data\n        exponential_wait_time *= 1.3\n    raise RetryTimeoutError(\n        f\"{response_data.status} {snowflake.core._http_requests.STATUS_CODES_MAPPING.get(response_data.status)} query timeout\"\n    )"
    }
  },
  {
    "pyfile": "rest.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/snowflake_core-1.3.0/snowflake_core-1.3.0/src/snowflake/core/stage/_generated/rest.py",
    "line_number": "403",
    "type_description": "B822:request",
    "severity": "High",
    "confidence": "Medium",
    "code_snippet": "def request(\n    self,\n    root,\n    method,\n    url,\n    query_params={},\n    headers={},\n    body={},\n    post_params={},\n    _preload_content=True,\n    _request_timeout=None,\n):\n    \"\"\"Perform requests.\n    :param method: http request method\n    :param url: http request url\n    :param query_params: query parameters in the url\n    :param headers: http request headers\n    :param body: request json body, for `application/json`\n    :param post_params: request post parameters,\n                        `application/x-www-form-urlencoded`\n                        and `multipart/form-data`\n    :param _preload_content: if False, the urllib3.HTTPResponse object will\n                             be returned without reading/decoding response\n                             data. Default is True.\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    \"\"\"\n    method = method.upper()\n    assert method in [\n        'GET', 'HEAD', 'DELETE', 'POST', 'PUT', 'PATCH', 'OPTIONS'\n    ]\n    import _snowflake\n    parsed_url = urllib3.util.parse_url(url)\n    query_params = query_params or {}\n    response_dict = _snowflake.send_snow_api_request(\n        method, parsed_url.path, dict(query_params), headers, body,\n        post_params, _request_timeout)\n    json_content = json.loads(response_dict[\"content\"])\n    if self._is_correct_xp_request(json_content):\n        r = urllib3.HTTPResponse(body=json.dumps(json_content[\"data\"]))\n    else:\n        r = urllib3.HTTPResponse(\n            body=json.dumps(json_content).encode(\"utf-8\"))\n    r.status = response_dict[\"status\"]\n    formatted_headers = {\n        key.strip(): value\n        for key, value in response_dict[\"headers\"].items()\n    }\n    r.headers = formatted_headers\n    logger.info(\n        \"Received an HTTP response of status %d\",\n        r.status,\n    )\n    if _preload_content:\n        r = RESTResponse(r)\n        # log response body\n        logger.debug(\"response body: %s\", r.data)\n\n    return evaluate_status_codes(root, r)",
    "pattern_analysis": {
      "api_sequence": [
        "urllib3.util.parse_url",
        "_snowflake.send_snow_api_request",
        "json.loads",
        "self._is_correct_xp_request",
        "json.dumps",
        "urllib3.HTTPResponse",
        "json.dumps",
        "encode",
        "urllib3.HTTPResponse",
        "logger.info",
        "RESTResponse",
        "logger.debug",
        "evaluate_status_codes"
      ],
      "api_sequence_with_args": [
        "urllib3.util.parse_url(url)",
        "_snowflake.send_snow_api_request(method, parsed_url.path, dict(query_params), headers, body, post_params, _request_timeout)",
        "json.loads(response_dict[\"content\"])",
        "self._is_correct_xp_request(json_content)",
        "json.dumps(json_content[\"data\"])",
        "urllib3.HTTPResponse(body=json.dumps(json_content[\"data\"]))",
        "json.dumps(json_content)",
        "json.dumps(json_content).encode(\"utf-8\")",
        "urllib3.HTTPResponse(body=json.dumps(json_content).encode(\"utf-8\"))",
        "logger.info(\"Received an HTTP response of status %d\", r.status)",
        "RESTResponse(r)",
        "logger.debug(\"response body: %s\", r.data)",
        "evaluate_status_codes(root, r)"
      ],
      "mapped_sequence": [
        {
          "api_name": "urllib3.util.parse_url",
          "id": "percent_encode_url",
          "description": "Percent-encodes bytes for use in URL",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "_snowflake.send_snow_api_request",
          "id": "send_http_custom",
          "description": "Sends HTTP request with specified method and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "self._is_correct_xp_request",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "json.dumps",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "urllib3.HTTPResponse",
          "id": "get_response_body",
          "description": "Retrieves response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "json.dumps",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "encode",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "urllib3.HTTPResponse",
          "id": "get_response_body",
          "description": "Retrieves response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "logger.info",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "RESTResponse",
          "id": "get_response_body",
          "description": "Retrieves response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "logger.debug",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "evaluate_status_codes",
          "id": "get_http_status",
          "description": "Retrieves HTTP response status code",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        }
      ],
      "contextual_code": "def request(self, root, method, url, query_params={}, headers={}, body={}, post_params={}, _preload_content=True, _request_timeout=None):\n    method = method.upper()\n    assert method in [\n        'GET', 'HEAD', 'DELETE', 'POST', 'PUT', 'PATCH', 'OPTIONS'\n    ]\n    import _snowflake\n    parsed_url = urllib3.util.parse_url(url)\n    query_params = query_params or {}\n    response_dict = _snowflake.send_snow_api_request(\n        method, parsed_url.path, dict(query_params), headers, body,\n        post_params, _request_timeout)\n    json_content = json.loads(response_dict[\"content\"])\n    if self._is_correct_xp_request(json_content):\n        r = urllib3.HTTPResponse(body=json.dumps(json_content[\"data\"]))\n    else:\n        r = urllib3.HTTPResponse(\n            body=json.dumps(json_content).encode(\"utf-8\"))\n    r.status = response_dict[\"status\"]\n    formatted_headers = {\n        key.strip(): value\n        for key, value in response_dict[\"headers\"].items()\n    }\n    r.headers = formatted_headers\n    logger.info(\n        \"Received an HTTP response of status %d\",\n        r.status,\n    )\n    if _preload_content:\n        r = RESTResponse(r)\n        logger.debug(\"response body: %s\", r.data)\n\n    return evaluate_status_codes(root, r)"
    }
  },
  {
    "pyfile": "rest.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/snowflake_core-1.3.0/snowflake_core-1.3.0/src/snowflake/core/alert/_generated/rest.py",
    "line_number": "285",
    "type_description": "B822:request",
    "severity": "High",
    "confidence": "Medium",
    "code_snippet": "def delete_request(self,\n                   root,\n                   url,\n                   headers=None,\n                   query_params=None,\n                   body=None,\n                   _preload_content=True,\n                   _request_timeout=None):\n    return self.request(\n        root,\n        \"DELETE\",\n        url,\n        headers=headers,\n        query_params=query_params,\n        _preload_content=_preload_content,\n        _request_timeout=_request_timeout,\n        body=body,\n    )",
    "pattern_analysis": {
      "api_sequence": [
        "self.request"
      ],
      "api_sequence_with_args": [
        "self.request(root, \"DELETE\", url, headers=headers, query_params=query_params, _preload_content=_preload_content, _request_timeout=_request_timeout, body=body)"
      ],
      "mapped_sequence": [
        {
          "api_name": "self.request",
          "id": "send_http_delete",
          "description": "Sends HTTP DELETE request with parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        }
      ],
      "contextual_code": "def delete_request(self,\n                   root,\n                   url,\n                   headers=None,\n                   query_params=None,\n                   body=None,\n                   _preload_content=True,\n                   _request_timeout=None):\n    return self.request(\n        root,\n        \"DELETE\",\n        url,\n        headers=headers,\n        query_params=query_params,\n        _preload_content=_preload_content,\n        _request_timeout=_request_timeout,\n        body=body,\n    )"
    }
  },
  {
    "pyfile": "rest.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/snowflake_core-1.3.0/snowflake_core-1.3.0/src/snowflake/core/managed_account/_generated/rest.py",
    "line_number": "181",
    "type_description": "B822:request",
    "severity": "High",
    "confidence": "Medium",
    "code_snippet": "def request(\n        self,\n        root,\n        method,\n        url,\n        query_params=None,\n        headers=None,\n        body=None,\n        post_params=None,\n        _preload_content=True,\n        _request_timeout=None,\n    ):\n        \"\"\"Perform requests.\n\n        :param method: http request method\n        :param url: http request url\n        :param query_params: query parameters in the url\n        :param headers: http request headers\n        :param body: request json body, for `application/json`\n        :param post_params: request post parameters,\n                            `application/x-www-form-urlencoded`\n                            and `multipart/form-data`\n        :param _preload_content: if False, the urllib3.HTTPResponse object will\n                                 be returned without reading/decoding response\n                                 data. Default is True.\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        \"\"\"\n        method = method.upper()\n        assert method in [\n            'GET', 'HEAD', 'DELETE', 'POST', 'PUT', 'PATCH', 'OPTIONS'\n        ]\n\n        if post_params and body:\n            raise _APIValueError(\n                \"body parameter cannot be used with post_params parameter.\")\n\n        post_params = post_params or {}\n        headers = headers or {}\n        # url already contains the URL query string\n        # so reset query_params to empty dict\n        query_params = {}\n\n        timeout = None\n        if _request_timeout:\n            if isinstance(_request_timeout, (int, float)):  # noqa: E501,F821\n                timeout = urllib3.Timeout(total=_request_timeout)\n            elif (isinstance(_request_timeout, tuple)\n                  and len(_request_timeout) == 2):\n                timeout = urllib3.Timeout(connect=_request_timeout[0],\n                                          read=_request_timeout[1])\n\n        try:\n            # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`\n            if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:\n\n                # no content type provided or payload is json\n                if not headers.get('Content-Type') or re.search(\n                        'json', headers['Content-Type'], re.IGNORECASE):\n                    request_body = None\n                    if body is not None:\n                        request_body = json.dumps(body)\n                    r = self.pool_manager.request(\n                        root,\n                        method,\n                        url,\n                        body=request_body,\n                        preload_content=_preload_content,\n                        timeout=timeout,\n                        headers=headers)\n                elif headers[\n                        'Content-Type'] == 'application/x-www-form-urlencoded':  # noqa: E501\n                    r = self.pool_manager.request(\n                        root,\n                        method,\n                        url,\n                        fields=post_params,\n                        encode_multipart=False,\n                        preload_content=_preload_content,\n                        timeout=timeout,\n                        headers=headers)\n                elif headers['Content-Type'] == 'multipart/form-data':\n                    # must del headers['Content-Type'], or the correct\n                    # Content-Type which generated by urllib3 will be\n                    # overwritten.\n                    del headers['Content-Type']\n                    r = self.pool_manager.request(\n                        root,\n                        method,\n                        url,\n                        fields=post_params,\n                        encode_multipart=True,\n                        preload_content=_preload_content,\n                        timeout=timeout,\n                        headers=headers)\n                # Pass a `string` parameter directly in the body to support\n                # other content types than Json when `body` argument is\n                # provided in serialized form\n                elif isinstance(body, str) or isinstance(body, bytes):\n                    request_body = body\n                    r = self.pool_manager.request(\n                        root,\n                        method,\n                        url,\n                        body=request_body,\n                        preload_content=_preload_content,\n                        timeout=timeout,\n                        headers=headers)\n                else:\n                    # Cannot generate the request from given parameters\n                    msg = \"\"\"Cannot prepare a request message for provided\n                             arguments. Please check that your arguments match\n                             declared content type.\"\"\"\n                    raise APIError(status=0, reason=msg, root=root)\n            # For `GET`, `HEAD`\n            else:\n                r = self.pool_manager.request(\n                    root,\n                    method,\n                    url,\n                    fields={},\n                    preload_content=_preload_content,\n                    timeout=timeout,\n                    headers=headers,\n                )\n        except urllib3.exceptions.SSLError as e:\n            msg = \"{0}\\n{1}\".format(type(e).__name__, str(e))\n            raise APIError(status=0, reason=msg, root=root)\n\n        if _preload_content:\n            r = RESTResponse(r)\n\n            # log response body\n            logger.debug(\"response body: %s\", r.data)\n\n        return evaluate_status_codes(root, r)",
    "pattern_analysis": {
      "api_sequence": [
        "urllib3.Timeout",
        "urllib3.Timeout",
        "re.search",
        "json.dumps",
        "self.pool_manager.request",
        "self.pool_manager.request",
        "self.pool_manager.request",
        "self.pool_manager.request",
        "self.pool_manager.request",
        "RESTResponse",
        "logger.debug",
        "evaluate_status_codes"
      ],
      "api_sequence_with_args": [
        "urllib3.Timeout(total=_request_timeout)",
        "urllib3.Timeout(connect=_request_timeout[0], read=_request_timeout[1])",
        "re.search('json', headers['Content-Type'], re.IGNORECASE)",
        "json.dumps(body)",
        "self.pool_manager.request(root, method, url, body=request_body, preload_content=_preload_content, timeout=timeout, headers=headers)",
        "self.pool_manager.request(root, method, url, fields=post_params, encode_multipart=False, preload_content=_preload_content, timeout=timeout, headers=headers)",
        "self.pool_manager.request(root, method, url, fields=post_params, encode_multipart=True, preload_content=_preload_content, timeout=timeout, headers=headers)",
        "self.pool_manager.request(root, method, url, body=request_body, preload_content=_preload_content, timeout=timeout, headers=headers)",
        "self.pool_manager.request(root, method, url, fields={}, preload_content=_preload_content, timeout=timeout, headers=headers)",
        "RESTResponse(r)",
        "logger.debug(\"response body: %s\", r.data)",
        "evaluate_status_codes(root, r)"
      ],
      "mapped_sequence": [
        {
          "api_name": "urllib3.Timeout",
          "id": "open_url_get_timeout",
          "description": "Opens URL with GET parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "urllib3.Timeout",
          "id": "open_url_get_timeout",
          "description": "Opens URL with GET parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "re.search",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "json.dumps",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "self.pool_manager.request",
          "id": "send_http_custom",
          "description": "Sends HTTP request with specified method and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "self.pool_manager.request",
          "id": "send_http_custom",
          "description": "Sends HTTP request with specified method and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "self.pool_manager.request",
          "id": "send_http_custom",
          "description": "Sends HTTP request with specified method and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "self.pool_manager.request",
          "id": "send_http_custom",
          "description": "Sends HTTP request with specified method and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "self.pool_manager.request",
          "id": "send_http_custom",
          "description": "Sends HTTP request with specified method and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "RESTResponse",
          "id": "deserialize_json_response",
          "description": "Deserializes JSON response body to Python object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "logger.debug",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "evaluate_status_codes",
          "id": "raise_http_error",
          "description": "Raises HTTPError if response status code indicates error",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        }
      ],
      "contextual_code": "if _request_timeout:\n    if isinstance(_request_timeout, (int, float)):\n        timeout = urllib3.Timeout(total=_request_timeout)\n    elif (isinstance(_request_timeout, tuple) and len(_request_timeout) == 2):\n        timeout = urllib3.Timeout(connect=_request_timeout[0], read=_request_timeout[1])\n\ntry:\n    if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:\n        if not headers.get('Content-Type') or re.search('json', headers['Content-Type'], re.IGNORECASE):\n            request_body = None\n            if body is not None:\n                request_body = json.dumps(body)\n            r = self.pool_manager.request(root, method, url, body=request_body, preload_content=_preload_content, timeout=timeout, headers=headers)\n        elif headers['Content-Type'] == 'application/x-www-form-urlencoded':\n            r = self.pool_manager.request(root, method, url, fields=post_params, encode_multipart=False, preload_content=_preload_content, timeout=timeout, headers=headers)\n        elif headers['Content-Type'] == 'multipart/form-data':\n            del headers['Content-Type']\n            r = self.pool_manager.request(root, method, url, fields=post_params, encode_multipart=True, preload_content=_preload_content, timeout=timeout, headers=headers)\n        elif isinstance(body, str) or isinstance(body, bytes):\n            request_body = body\n            r = self.pool_manager.request(root, method, url, body=request_body, preload_content=_preload_content, timeout=timeout, headers=headers)\n        else:\n            msg = \"\"\"Cannot prepare a request message for provided arguments. Please check that your arguments match declared content type.\"\"\"\n            raise APIError(status=0, reason=msg, root=root)\n    else:\n        r = self.pool_manager.request(root, method, url, fields={}, preload_content=_preload_content, timeout=timeout, headers=headers)\nexcept urllib3.exceptions.SSLError as e:\n    msg = \"{0}\\n{1}\".format(type(e).__name__, str(e))\n    raise APIError(status=0, reason=msg, root=root)\n\nif _preload_content:\n    r = RESTResponse(r)\n    logger.debug(\"response body: %s\", r.data)\n\nreturn evaluate_status_codes(root, r)"
    }
  },
  {
    "pyfile": "rest.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/snowflake_core-1.3.0/snowflake_core-1.3.0/src/snowflake/core/grant/_generated/rest.py",
    "line_number": "522",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "code_snippet": "def post_request(self,\n                 root,\n                 url,\n                 headers=None,\n                 query_params=None,\n                 post_params=None,\n                 body=None,\n                 _preload_content=True,\n                 _request_timeout=None):\n    return self.request(\n        root,\n        \"POST\",\n        url,\n        headers=headers,\n        query_params=query_params,\n        post_params=post_params,\n        _preload_content=_preload_content,\n        _request_timeout=_request_timeout,\n        body=body,\n    )",
    "pattern_analysis": {
      "api_sequence": [
        "self.request"
      ],
      "api_sequence_with_args": [
        "self.request(root, \"POST\", url, headers=headers, query_params=query_params, post_params=post_params, _preload_content=_preload_content, _request_timeout=_request_timeout, body=body)"
      ],
      "mapped_sequence": [
        {
          "api_name": "self.request",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        }
      ],
      "contextual_code": "def post_request(self,\n                 root,\n                 url,\n                 headers=None,\n                 query_params=None,\n                 post_params=None,\n                 body=None,\n                 _preload_content=True,\n                 _request_timeout=None):\n    return self.request(\n        root,\n        \"POST\",\n        url,\n        headers=headers,\n        query_params=query_params,\n        post_params=post_params,\n        _preload_content=_preload_content,\n        _request_timeout=_request_timeout,\n        body=body,\n    )"
    }
  },
  {
    "pyfile": "api_client.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/snowflake_core-1.3.0/snowflake_core-1.3.0/src/snowflake/core/cortex/chat_service/_generated/api_client.py",
    "line_number": "656",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "code_snippet": "def request(self,\n            root,\n            method,\n            url,\n            query_params=None,\n            headers=None,\n            post_params=None,\n            body=None,\n            _preload_content=True,\n            _request_timeout=None):\n    \"\"\"Makes the HTTP request using RESTClient.\"\"\"\n    if method == \"GET\":\n        return self.rest_client.get_request(\n            root,\n            url,\n            query_params=query_params,\n            _preload_content=_preload_content,\n            _request_timeout=_request_timeout,\n            headers=headers,\n        )\n    elif method == \"HEAD\":\n        return self.rest_client.head_request(\n            root,\n            url,\n            query_params=query_params,\n            _preload_content=_preload_content,\n            _request_timeout=_request_timeout,\n            headers=headers,\n        )\n    elif method == \"OPTIONS\":\n        return self.rest_client.options_request(\n            root,\n            url,\n            query_params=query_params,\n            headers=headers,\n            _preload_content=_preload_content,\n            _request_timeout=_request_timeout,\n        )\n    elif method == \"POST\":\n        return self.rest_client.post_request(\n            root,\n            url,\n            query_params=query_params,\n            headers=headers,\n            post_params=post_params,\n            _preload_content=_preload_content,\n            _request_timeout=_request_timeout,\n            body=body,\n        )\n    elif method == \"PUT\":\n        try:\n            return self.rest_client.put_request(\n                root,\n                url,\n                query_params=query_params,\n                headers=headers,\n                post_params=post_params,\n                _preload_content=_preload_content,\n                _request_timeout=_request_timeout,\n                body=body,\n            )\n        except APIError as error:\n            # Raise a more helpful user error if CoA is not supported for this resource;\n            # this is represented as either 405 or 501 on the server.\n            if error.status in (405, 501):\n                raise NotImplementedError(\n                    'create_or_update is not yet supported for chat_service. Updating chat_service '\n                    'objects is not supported yet; use create() for creating a chat_service.'\n                )\n            raise\n\n    elif method == \"PATCH\":\n        return self.rest_client.patch_request(\n            root,\n            url,\n            query_params=query_params,\n            headers=headers,\n            post_params=post_params,\n            _preload_content=_preload_content,\n            _request_timeout=_request_timeout,\n            body=body,\n        )\n    elif method == \"DELETE\":\n        return self.rest_client.delete_request(\n            root,\n            url,\n            query_params=query_params,\n            headers=headers,\n            _preload_content=_preload_content,\n            _request_timeout=_request_timeout,\n            body=body,\n        )\n    else:\n        raise _APIValueError(\n            \"http method must be `GET`, `HEAD`, `OPTIONS`,\"\n            \" `POST`, `PATCH`, `PUT` or `DELETE`.\")",
    "pattern_analysis": {
      "api_sequence": [
        "self.rest_client.get_request",
        "self.rest_client.head_request",
        "self.rest_client.options_request",
        "self.rest_client.post_request",
        "self.rest_client.put_request",
        "self.rest_client.patch_request",
        "self.rest_client.delete_request"
      ],
      "api_sequence_with_args": [
        "self.rest_client.get_request(root, url, query_params=query_params, _preload_content=_preload_content, _request_timeout=_request_timeout, headers=headers)",
        "self.rest_client.head_request(root, url, query_params=query_params, _preload_content=_preload_content, _request_timeout=_request_timeout, headers=headers)",
        "self.rest_client.options_request(root, url, query_params=query_params, headers=headers, _preload_content=_preload_content, _request_timeout=_request_timeout)",
        "self.rest_client.post_request(root, url, query_params=query_params, headers=headers, post_params=post_params, _preload_content=_preload_content, _request_timeout=_request_timeout, body=body)",
        "self.rest_client.put_request(root, url, query_params=query_params, headers=headers, post_params=post_params, _preload_content=_preload_content, _request_timeout=_request_timeout, body=body)",
        "self.rest_client.patch_request(root, url, query_params=query_params, headers=headers, post_params=post_params, _preload_content=_preload_content, _request_timeout=_request_timeout, body=body)",
        "self.rest_client.delete_request(root, url, query_params=query_params, headers=headers, _preload_content=_preload_content, _request_timeout=_request_timeout, body=body)"
      ],
      "mapped_sequence": [
        {
          "api_name": "self.rest_client.get_request",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "self.rest_client.head_request",
          "id": "send_http_head",
          "description": "Sends HTTP HEAD request with parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "self.rest_client.options_request",
          "id": "send_http_options",
          "description": "Sends HTTP OPTIONS request with parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "self.rest_client.post_request",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "self.rest_client.put_request",
          "id": "send_http_put",
          "description": "Sends HTTP PUT request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "self.rest_client.patch_request",
          "id": "send_http_patch",
          "description": "Sends HTTP PATCH request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "self.rest_client.delete_request",
          "id": "send_http_delete",
          "description": "Sends HTTP DELETE request with parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        }
      ],
      "contextual_code": "def request(self,\n            root,\n            method,\n            url,\n            query_params=None,\n            headers=None,\n            post_params=None,\n            body=None,\n            _preload_content=True,\n            _request_timeout=None):\n    \"\"\"Makes the HTTP request using RESTClient.\"\"\"\n    if method == \"GET\":\n        return self.rest_client.get_request(\n            root,\n            url,\n            query_params=query_params,\n            _preload_content=_preload_content,\n            _request_timeout=_request_timeout,\n            headers=headers,\n        )\n    elif method == \"HEAD\":\n        return self.rest_client.head_request(\n            root,\n            url,\n            query_params=query_params,\n            _preload_content=_preload_content,\n            _request_timeout=_request_timeout,\n            headers=headers,\n        )\n    elif method == \"OPTIONS\":\n        return self.rest_client.options_request(\n            root,\n            url,\n            query_params=query_params,\n            headers=headers,\n            _preload_content=_preload_content,\n            _request_timeout=_request_timeout,\n        )\n    elif method == \"POST\":\n        return self.rest_client.post_request(\n            root,\n            url,\n            query_params=query_params,\n            headers=headers,\n            post_params=post_params,\n            _preload_content=_preload_content,\n            _request_timeout=_request_timeout,\n            body=body,\n        )\n    elif method == \"PUT\":\n        try:\n            return self.rest_client.put_request(\n                root,\n                url,\n                query_params=query_params,\n                headers=headers,\n                post_params=post_params,\n                _preload_content=_preload_content,\n                _request_timeout=_request_timeout,\n                body=body,\n            )\n        except APIError as error:\n            if error.status in (405, 501):\n                raise NotImplementedError(\n                    'create_or_update is not yet supported for chat_service. Updating chat_service '\n                    'objects is not supported yet; use create() for creating a chat_service.'\n                )\n            raise\n\n    elif method == \"PATCH\":\n        return self.rest_client.patch_request(\n            root,\n            url,\n            query_params=query_params,\n            headers=headers,\n            post_params=post_params,\n            _preload_content=_preload_content,\n            _request_timeout=_request_timeout,\n            body=body,\n        )\n    elif method == \"DELETE\":\n        return self.rest_client.delete_request(\n            root,\n            url,\n            query_params=query_params,\n            headers=headers,\n            _preload_content=_preload_content,\n            _request_timeout=_request_timeout,\n            body=body,\n        )\n    else:\n        raise _APIValueError(\n            \"http method must be `GET`, `HEAD`, `OPTIONS`,\"\n            \" `POST`, `PATCH`, `PUT` or `DELETE`.\")"
    }
  }
]