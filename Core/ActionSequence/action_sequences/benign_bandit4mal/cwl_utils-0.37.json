[
  {
    "metadata": {
      "package_name": "cwl_utils-0.37",
      "total_matches": 6,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "cwl_v1_2.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cwl_utils-0.37/cwl_utils-0.37/cwl_utils/parser/cwl_v1_2.py",
    "line_number": "12379",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "12378\t                else:\n12379\t                    val = _doc.get(\"streamable\")\n12380\t                    if error_message != str(e):",
    "code_snippet": "else:\n    val = _doc.get(\"streamable\")",
    "pattern_analysis": {
      "api_sequence": [],
      "api_sequence_with_args": [],
      "mapped_sequence": [],
      "contextual_code": "else:\n    val = _doc.get(\"streamable\")"
    }
  },
  {
    "pyfile": "cwl_v1_1.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cwl_utils-0.37/cwl_utils-0.37/cwl_utils/parser/cwl_v1_1.py",
    "line_number": "25929",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "25928\t        try:\n25929\t            if _doc.get(\"shmSize\") is None:\n25930\t                raise ValidationException(\"missing required field `shmSize`\", None, [])",
    "code_snippet": "class ShmSize(ProcessRequirement):\n    def __init__(\n        self,\n        shmSize: Any,\n        extension_fields: Optional[dict[str, Any]] = None,\n        loadingOptions: Optional[LoadingOptions] = None,\n    ) -> None:\n        if extension_fields:\n            self.extension_fields = extension_fields\n        else:\n            self.extension_fields = CommentedMap()\n        if loadingOptions:\n            self.loadingOptions = loadingOptions\n        else:\n            self.loadingOptions = LoadingOptions()\n        self.class_ = \"ShmSize\"\n        self.shmSize = shmSize\n\n    def __eq__(self, other: Any) -> bool:\n        if isinstance(other, ShmSize):\n            return bool(self.class_ == other.class_ and self.shmSize == other.shmSize)\n        return False\n\n    def __hash__(self) -> int:\n        return hash((self.class_, self.shmSize))\n\n    @classmethod\n    def fromDoc(\n        cls,\n        doc: Any,\n        baseuri: str,\n        loadingOptions: LoadingOptions,\n        docRoot: Optional[str] = None\n    ) -> \"ShmSize\":\n        _doc = copy.copy(doc)\n\n        if hasattr(doc, \"lc\"):\n            _doc.lc.data = doc.lc.data\n            _doc.lc.filename = doc.lc.filename\n        _errors__ = []\n        try:\n            if _doc.get(\"class\") is None:\n                raise ValidationException(\"missing required field `class`\", None, [])\n\n            class_ = load_field(\n                _doc.get(\"class\"),\n                uri_strtype_False_True_None_None,\n                baseuri,\n                loadingOptions,\n                lc=_doc.get(\"class\")\n            )\n\n            if class_ not in (cls.__name__, loadingOptions.vocab.get(cls.__name__)):\n               raise ValidationException(f\"tried `{cls.__name__}` but\")\n        except ValidationException as e:\n               raise e\n        try:\n            if _doc.get(\"shmSize\") is None:\n                raise ValidationException(\"missing required field `shmSize\"\", None, [])\n\n            shmSize = load_field(\n                _doc.get(\"shmSize\"),\n                strtype,\n                baseuri,\n                loadingOptions,\n                lc=_doc.get(\"shmSize\")\n            )\n\n        except ValidationException as e:\n            error_message, to_print, verb_tensage = parse_errors(str(e))\n\n            if str(e) == \"missing required field `shmSize`\":\n                _errors__.append(\n                    ValidationException(\n                        str(e),\n                        None\n                    )\n                )\n            else:\n                val = _doc.get(\"shmSize\")\n                if error_message != str(e):\n                    val_type = convert_typing(extract_type(type(val)))\n                    _errors__.append(\n                        ValidationException(\n                            \"the `shmSize` field is not valid because:\",\n                            SourceLine(_doc, \"shmSize\", str),\n                            [ValidationException(f\"Value is a {val_type}, \"\n                                                 f\"but valid {to_print} for this field \"\n                                                 f\"{verb_tensage} {error_message}\",\n                                                 detailed_message=f\"Value `{val}` is a {val_type}, \"\n                                                 f\"but valid {to_print} for this field \"\n                                                 f\"{verb_tensage} {error_message}\")],\n                        )\n                    )\n                else:\n                    _errors__.append(\n                        ValidationException(\n                            \"the `shmSize` field is not valid because:\",\n                            SourceLine(_doc, \"shmSize\", str),\n                            [e],\n                            detailed_message=f\"the `shmSize` field with value `{val}` \"\n                            \"is not valid because:\",\n                        )\n                    )\n        extension_fields: dict[str, Any] = {}\n        for k in _doc.keys():\n            if k not in cls.attrs:\n                if not k:\n                    _errors__.append(\n                        ValidationException(\"mapping with implicit null key\")\n                    )\n                elif \":\" in k:\n                    ex = expand_url(\n                        k, \"\", loadingOptions, scoped_id=False, vocab_term=False\n                    )\n                    extension_fields[ex] = _doc[k]\n                else:\n                    _errors__.append(\n                        ValidationException(\n                            \"invalid field `{}`, expected one of: `class`, `shmSize`\".format(\n                                k\n                            ),\n                            SourceLine(_doc, k, str),\n                        )\n                    )\n\n        if _errors__:\n            raise ValidationException(\"\", None, _errors__, \"*\")\n        _constructed = cls(\n            shmSize=shmSize,\n            extension_fields=extension_fields,\n            loadingOptions=loadingOptions,\n        )\n        return _constructed\n",
    "pattern_analysis": {
      "api_sequence": [
        "copy.copy",
        "hasattr",
        "load_field",
        "load_field",
        "expand_url"
      ],
      "api_sequence_with_args": [
        "copy.copy(doc)",
        "hasattr(doc, \"lc\")",
        "load_field(_doc.get(\"class\"), uri_strtype_False_True_None_None, baseuri, loadingOptions, lc=_doc.get(\"class\"))",
        "load_field(_doc.get(\"shmSize\"), strtype, baseuri, loadingOptions, lc=_doc.get(\"shmSize\"))",
        "expand_url(k, \"\", loadingOptions, scoped_id=False, vocab_term=False)"
      ],
      "mapped_sequence": [
        {
          "api_name": "copy.copy",
          "id": "copy_memory",
          "description": "Copies memory from source to destination buffer",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "hasattr",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "load_field",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "load_field",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "expand_url",
          "id": "percent_encode_url",
          "description": "Percent-encodes bytes for use in URL",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        }
      ],
      "contextual_code": "def fromDoc(\n    cls,\n    doc: Any,\n    baseuri: str,\n    loadingOptions: LoadingOptions,\n    docRoot: Optional[str] = None\n) -> \"ShmSize\":\n    _doc = copy.copy(doc)\n\n    if hasattr(doc, \"lc\"):\n        _doc.lc.data = doc.lc.data\n        _doc.lc.filename = doc.lc.filename\n    _errors__ = []\n    try:\n        if _doc.get(\"class\") is None:\n            raise ValidationException(\"missing required field `class`\", None, [])\n\n        class_ = load_field(\n            _doc.get(\"class\"),\n            uri_strtype_False_True_None_None,\n            baseuri,\n            loadingOptions,\n            lc=_doc.get(\"class\")\n        )\n\n        if class_ not in (cls.__name__, loadingOptions.vocab.get(cls.__name__)):\n           raise ValidationException(f\"tried `{cls.__name__}` but\")\n    except ValidationException as e:\n           raise e\n    try:\n        if _doc.get(\"shmSize\") is None:\n            raise ValidationException(\"missing required field `shmSize\"\", None, [])\n\n        shmSize = load_field(\n            _doc.get(\"shmSize\"),\n            strtype,\n            baseuri,\n            loadingOptions,\n            lc=_doc.get(\"shmSize\")\n        )\n\n    except ValidationException as e:\n        # ... error handling omitted for brevity ...\n        pass\n    extension_fields: dict[str, Any] = {}\n    for k in _doc.keys():\n        if k not in cls.attrs:\n            if not k:\n                _errors__.append(\n                    ValidationException(\"mapping with implicit null key\")\n                )\n            elif \":\" in k:\n                ex = expand_url(\n                    k, \"\", loadingOptions, scoped_id=False, vocab_term=False\n                )\n                extension_fields[ex] = _doc[k]\n            else:\n                _errors__.append(\n                    ValidationException(\n                        \"invalid field `{}`, expected one of: `class`, `shmSize`\".format(\n                            k\n                        ),\n                        SourceLine(_doc, k, str),\n                    )\n                )"
    }
  },
  {
    "pyfile": "cwl_v1_1.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cwl_utils-0.37/cwl_utils-0.37/cwl_utils/parser/cwl_v1_1.py",
    "line_number": "12707",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "12706\t                    loadingOptions,\n12707\t                    lc=_doc.get(\"fields\")\n12708\t                )",
    "code_snippet": "fields = None\nif \"fields\" in _doc:\n    try:\n        fields = load_field(\n            _doc.get(\"fields\"),\n            idmap_fields_union_of_None_type_or_array_of_RecordFieldLoader,\n            baseuri,\n            loadingOptions,\n            lc=_doc.get(\"fields\")\n        )\n\n    except ValidationException as e:\n        error_message, to_print, verb_tensage = parse_errors(str(e))\n\n        if str(e) == \"missing required field `fields`\":\n            _errors__.append(\n                ValidationException(\n                    str(e),\n                    None\n                )\n            )\n        else:\n            val = _doc.get(\"fields\")\n            if error_message != str(e):\n                val_type = convert_typing(extract_type(type(val)))\n                _errors__.append(\n                    ValidationException(\n                        \"the `fields` field is not valid because:\",\n                        SourceLine(_doc, \"fields\", str),\n                        [ValidationException(f\"Value is a {val_type}, \"\n                                             f\"but valid {to_print} for this field \"\n                                             f\"{verb_tensage} {error_message}\",\n                                             detailed_message=f\"Value `{val}` is a {val_type}, \"\n                                             f\"but valid {to_print} for this field \"\n                                             f\"{verb_tensage} {error_message}\")],\n                    )\n                )\n            else:\n                _errors__.append(\n                    ValidationException(\n                        \"the `fields` field is not valid because:\",\n                        SourceLine(_doc, \"fields\", str),\n                        [e],\n                        detailed_message=f\"the `fields` field with value `{val}` \"\n                        \"is not valid because:\",\n                    )\n                )",
    "pattern_analysis": {
      "api_sequence": [
        "_doc.get",
        "load_field",
        "parse_errors",
        "str",
        "_doc.get",
        "ValidationException",
        "str",
        "_errors__.append",
        "_doc.get",
        "convert_typing",
        "extract_type",
        "type",
        "_errors__.append",
        "ValidationException",
        "SourceLine",
        "ValidationException",
        "_errors__.append",
        "ValidationException",
        "SourceLine"
      ],
      "api_sequence_with_args": [
        "_doc.get(\"fields\")",
        "load_field(_doc.get(\"fields\"), idmap_fields_union_of_None_type_or_array_of_RecordFieldLoader, baseuri, loadingOptions, lc=_doc.get(\"fields\"))",
        "parse_errors(str(e))",
        "str(e)",
        "_doc.get(\"fields\")",
        "ValidationException(str(e), None)",
        "str(e)",
        "_errors__.append(ValidationException(str(e), None))",
        "_doc.get(\"fields\")",
        "convert_typing(extract_type(type(val)))",
        "extract_type(type(val))",
        "type(val)",
        "_errors__.append(ValidationException(...))",
        "ValidationException(\"the `fields` field is not valid because:\", SourceLine(_doc, \"fields\", str), [ValidationException(...)])",
        "SourceLine(_doc, \"fields\", str)",
        "ValidationException(f\"Value is a {val_type}, ...\")",
        "_errors__.append(ValidationException(...))",
        "ValidationException(\"the `fields` field is not valid because:\", SourceLine(_doc, \"fields\", str), [e], detailed_message=...)"
      ],
      "mapped_sequence": [
        {
          "api_name": "_doc.get",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "load_field",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "parse_errors",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "str",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "_doc.get",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "ValidationException",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "str",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "_errors__.append",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "_doc.get",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "convert_typing",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "extract_type",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "type",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "_errors__.append",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "ValidationException",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "SourceLine",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "ValidationException",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "_errors__.append",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "ValidationException",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "SourceLine",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        }
      ],
      "contextual_code": "fields = None\nif \"fields\" in _doc:\n    try:\n        fields = load_field(\n            _doc.get(\"fields\"),\n            idmap_fields_union_of_None_type_or_array_of_RecordFieldLoader,\n            baseuri,\n            loadingOptions,\n            lc=_doc.get(\"fields\")\n        )\n\n    except ValidationException as e:\n        error_message, to_print, verb_tensage = parse_errors(str(e))\n\n        if str(e) == \"missing required field `fields`\":\n            _errors__.append(\n                ValidationException(\n                    str(e),\n                    None\n                )\n            )\n        else:\n            val = _doc.get(\"fields\")\n            if error_message != str(e):\n                val_type = convert_typing(extract_type(type(val)))\n                _errors__.append(\n                    ValidationException(\n                        \"the `fields` field is not valid because:\",\n                        SourceLine(_doc, \"fields\", str),\n                        [ValidationException(f\"Value is a {val_type}, \"\n                                             f\"but valid {to_print} for this field \"\n                                             f\"{verb_tensage} {error_message}\",\n                                             detailed_message=f\"Value `{val}` is a {val_type}, \"\n                                             f\"but valid {to_print} for this field \"\n                                             f\"{verb_tensage} {error_message}\")],\n                    )\n                )\n            else:\n                _errors__.append(\n                    ValidationException(\n                        \"the `fields` field is not valid because:\",\n                        SourceLine(_doc, \"fields\", str),\n                        [e],\n                        detailed_message=f\"the `fields` field with value `{val}` \"\n                        \"is not valid because:\",\n                    )\n                )"
    }
  },
  {
    "pyfile": "cwl_v1_1.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cwl_utils-0.37/cwl_utils-0.37/cwl_utils/parser/cwl_v1_1.py",
    "line_number": "13971",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "13970\t                    loadingOptions,\n13971\t                    lc=_doc.get(\"streamable\")\n13972\t                )",
    "code_snippet": "def load_field(\n    val: Union[str, dict[str, str]],\n    fieldtype: \"_Loader\",\n    baseuri: str,\n    loadingOptions: LoadingOptions,\n    lc: Optional[list[Any]] = None,\n) -> Any:\n    \"\"\"Load field.\"\"\"\n    if isinstance(val, MutableMapping):\n        if \"$import\" in val:\n            if loadingOptions.fileuri is None:\n                raise SchemaSaladException(\"Cannot load $import without fileuri\")\n            url = loadingOptions.fetcher.urljoin(loadingOptions.fileuri, val[\"$import\"])\n            result, metadata = _document_load_by_url(\n                fieldtype,\n                url,\n                loadingOptions,\n            )\n            loadingOptions.imports.append(url)\n            return result\n        if \"$include\" in val:\n            if loadingOptions.fileuri is None:\n                raise SchemaSaladException(\"Cannot load $import without fileuri\")\n            url = loadingOptions.fetcher.urljoin(loadingOptions.fileuri, val[\"$include\"])\n            val = loadingOptions.fetcher.fetch_text(url)\n            loadingOptions.includes.append(url)\n    return fieldtype.load(val, baseuri, loadingOptions, lc=lc)",
    "pattern_analysis": {
      "api_sequence": [
        "loadingOptions.fetcher.urljoin",
        "_document_load_by_url",
        "loadingOptions.imports.append",
        "loadingOptions.fetcher.urljoin",
        "loadingOptions.fetcher.fetch_text",
        "loadingOptions.includes.append",
        "fieldtype.load"
      ],
      "api_sequence_with_args": [
        "loadingOptions.fetcher.urljoin(loadingOptions.fileuri, val[\"$import\"])",
        "_document_load_by_url(fieldtype, url, loadingOptions)",
        "loadingOptions.imports.append(url)",
        "loadingOptions.fetcher.urljoin(loadingOptions.fileuri, val[\"$include\"])",
        "loadingOptions.fetcher.fetch_text(url)",
        "loadingOptions.includes.append(url)",
        "fieldtype.load(val, baseuri, loadingOptions, lc=lc)"
      ],
      "mapped_sequence": [
        {
          "api_name": "loadingOptions.fetcher.urljoin",
          "id": "encode_url_query",
          "description": "Encodes mapping object to URL query string",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "_document_load_by_url",
          "id": "open_url_get",
          "description": "Opens URL with GET parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "loadingOptions.imports.append",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "loadingOptions.fetcher.urljoin",
          "id": "encode_url_query",
          "description": "Encodes mapping object to URL query string",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "loadingOptions.fetcher.fetch_text",
          "id": "open_url_get",
          "description": "Opens URL with GET parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "loadingOptions.includes.append",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "fieldtype.load",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        }
      ],
      "contextual_code": "def load_field(val, fieldtype, baseuri, loadingOptions, lc=None):\n    if isinstance(val, MutableMapping):\n        if \"$import\" in val:\n            if loadingOptions.fileuri is None:\n                raise SchemaSaladException(\"Cannot load $import without fileuri\")\n            url = loadingOptions.fetcher.urljoin(loadingOptions.fileuri, val[\"$import\"])\n            result, metadata = _document_load_by_url(fieldtype, url, loadingOptions)\n            loadingOptions.imports.append(url)\n            return result\n        if \"$include\" in val:\n            if loadingOptions.fileuri is None:\n                raise SchemaSaladException(\"Cannot load $import without fileuri\")\n            url = loadingOptions.fetcher.urljoin(loadingOptions.fileuri, val[\"$include\"])\n            val = loadingOptions.fetcher.fetch_text(url)\n            loadingOptions.includes.append(url)\n    return fieldtype.load(val, baseuri, loadingOptions, lc=lc)"
    }
  },
  {
    "pyfile": "cwl_v1_0.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cwl_utils-0.37/cwl_utils-0.37/cwl_utils/parser/cwl_v1_0.py",
    "line_number": "5008",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "5007\t                else:\n5008\t                    val = _doc.get(\"label\")\n5009\t                    if error_message != str(e):",
    "code_snippet": "else:\n    val = _doc.get(\"label\")\n    if error_message != str(e):",
    "pattern_analysis": {
      "api_sequence": [],
      "api_sequence_with_args": [],
      "mapped_sequence": [],
      "contextual_code": "else:\n    val = _doc.get(\"label\")\n    if error_message != str(e):"
    }
  },
  {
    "pyfile": "cwl_v1_1.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cwl_utils-0.37/cwl_utils-0.37/cwl_utils/parser/cwl_v1_1.py",
    "line_number": "9327",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "9326\t                else:\n9327\t                    val = _doc.get(\"valueFrom\")\n9328\t                    if error_message != str(e):",
    "code_snippet": "    @classmethod\n    def fromDoc(\n        cls,\n        doc: Any,\n        baseuri: str,\n        loadingOptions: LoadingOptions,\n        docRoot: Optional[str] = None\n    ) -> \"CommandLineBinding\":\n        _doc = copy.copy(doc)\n\n        if hasattr(doc, \"lc\"):\n            _doc.lc.data = doc.lc.data\n            _doc.lc.filename = doc.lc.filename\n        _errors__ = []\n        loadContents = None\n        if \"loadContents\" in _doc:\n            try:\n                loadContents = load_field(\n                    _doc.get(\"loadContents\"),\n                    union_of_None_type_or_booltype,\n                    baseuri,\n                    loadingOptions,\n                    lc=_doc.get(\"loadContents\")\n                )\n\n            except ValidationException as e:\n                error_message, to_print, verb_tensage = parse_errors(str(e))\n\n                if str(e) == \"missing required field `loadContents`\":\n                    _errors__.append(\n                        ValidationException(\n                            str(e),\n                            None\n                        )\n                    )\n                else:\n                    val = _doc.get(\"loadContents\")\n                    if error_message != str(e):\n                        val_type = convert_typing(extract_type(type(val)))\n                        _errors__.append(\n                            ValidationException(\n                                \"the `loadContents` field is not valid because:\",\n                                SourceLine(_doc, \"loadContents\", str),\n                                [ValidationException(f\"Value is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\",\n                                                     detailed_message=f\"Value `{val}` is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\")],\n                            )\n                        )\n                    else:\n                        _errors__.append(\n                            ValidationException(\n                                \"the `loadContents` field is not valid because:\",\n                                SourceLine(_doc, \"loadContents\", str),\n                                [e],\n                                detailed_message=f\"the `loadContents` field with value `{val}` \"\n                                \"is not valid because:\",\n                            )\n                        )\n        position = None\n        if \"position\" in _doc:\n            try:\n                position = load_field(\n                    _doc.get(\"position\"),\n                    union_of_None_type_or_inttype_or_ExpressionLoader,\n                    baseuri,\n                    loadingOptions,\n                    lc=_doc.get(\"position\")\n                )\n\n            except ValidationException as e:\n                error_message, to_print, verb_tensage = parse_errors(str(e))\n\n                if str(e) == \"missing required field `position`\":\n                    _errors__.append(\n                        ValidationException(\n                            str(e),\n                            None\n                        )\n                    )\n                else:\n                    val = _doc.get(\"position\")\n                    if error_message != str(e):\n                        val_type = convert_typing(extract_type(type(val)))\n                        _errors__.append(\n                            ValidationException(\n                                \"the `position` field is not valid because:\",\n                                SourceLine(_doc, \"position\", str),\n                                [ValidationException(f\"Value is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\",\n                                                     detailed_message=f\"Value `{val}` is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\")],\n                            )\n                        )\n                    else:\n                        _errors__.append(\n                            ValidationException(\n                                \"the `position` field is not valid because:\",\n                                SourceLine(_doc, \"position\", str),\n                                [e],\n                                detailed_message=f\"the `position` field with value `{val}` \"\n                                \"is not valid because:\",\n                            )\n                        )\n        prefix = None\n        if \"prefix\" in _doc:\n            try:\n                prefix = load_field(\n                    _doc.get(\"prefix\"),\n                    union_of_None_type_or_strtype,\n                    baseuri,\n                    loadingOptions,\n                    lc=_doc.get(\"prefix\")\n                )\n\n            except ValidationException as e:\n                error_message, to_print, verb_tensage = parse_errors(str(e))\n\n                if str(e) == \"missing required field `prefix`\":\n                    _errors__.append(\n                        ValidationException(\n                            str(e),\n                            None\n                        )\n                    )\n                else:\n                    val = _doc.get(\"prefix\")\n                    if error_message != str(e):\n                        val_type = convert_typing(extract_type(type(val)))\n                        _errors__.append(\n                            ValidationException(\n                                \"the `prefix` field is not valid because:\",\n                                SourceLine(_doc, \"prefix\", str),\n                                [ValidationException(f\"Value is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\",\n                                                     detailed_message=f\"Value `{val}` is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\")],\n                            )\n                        )\n                    else:\n                        _errors__.append(\n                            ValidationException(\n                                \"the `prefix` field is not valid because:\",\n                                SourceLine(_doc, \"prefix\", str),\n                                [e],\n                                detailed_message=f\"the `prefix` field with value `{val}` \"\n                                \"is not valid because:\",\n                            )\n                        )\n        separate = None\n        if \"separate\" in _doc:\n            try:\n                separate = load_field(\n                    _doc.get(\"separate\"),\n                    union_of_None_type_or_booltype,\n                    baseuri,\n                    loadingOptions,\n                    lc=_doc.get(\"separate\")\n                )\n\n            except ValidationException as e:\n                error_message, to_print, verb_tensage = parse_errors(str(e))\n\n                if str(e) == \"missing required field `separate`\":\n                    _errors__.append(\n                        ValidationException(\n                            str(e),\n                            None\n                        )\n                    )\n                else:\n                    val = _doc.get(\"separate\")\n                    if error_message != str(e):\n                        val_type = convert_typing(extract_type(type(val)))\n                        _errors__.append(\n                            ValidationException(\n                                \"the `separate` field is not valid because:\",\n                                SourceLine(_doc, \"separate\", str),\n                                [ValidationException(f\"Value is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\",\n                                                     detailed_message=f\"Value `{val}` is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\")],\n                            )\n                        )\n                    else:\n                        _errors__.append(\n                            ValidationException(\n                                \"the `separate` field is not valid because:\",\n                                SourceLine(_doc, \"separate\", str),\n                                [e],\n                                detailed_message=f\"the `separate` field with value `{val}` \"\n                                \"is not valid because:\",\n                            )\n                        )\n        itemSeparator = None\n        if \"itemSeparator\" in _doc:\n            try:\n                itemSeparator = load_field(\n                    _doc.get(\"itemSeparator\"),\n                    union_of_None_type_or_strtype,\n                    baseuri,\n                    loadingOptions,\n                    lc=_doc.get(\"itemSeparator\")\n                )\n\n            except ValidationException as e:\n                error_message, to_print, verb_tensage = parse_errors(str(e))\n\n                if str(e) == \"missing required field `itemSeparator`\":\n                    _errors__.append(\n                        ValidationException(\n                            str(e),\n                            None\n                        )\n                    )\n                else:\n                    val = _doc.get(\"itemSeparator\")\n                    if error_message != str(e):\n                        val_type = convert_typing(extract_type(type(val)))\n                        _errors__.append(\n                            ValidationException(\n                                \"the `itemSeparator` field is not valid because:\",\n                                SourceLine(_doc, \"itemSeparator\", str),\n                                [ValidationException(f\"Value is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\",\n                                                     detailed_message=f\"Value `{val}` is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\")],\n                            )\n                        )\n                    else:\n                        _errors__.append(\n                            ValidationException(\n                                \"the `itemSeparator` field is not valid because:\",\n                                SourceLine(_doc, \"itemSeparator\", str),\n                                [e],\n                                detailed_message=f\"the `itemSeparator` field with value `{val}` \"\n                                \"is not valid because:\",\n                            )\n                        )\n        valueFrom = None\n        if \"valueFrom\" in _doc:\n            try:\n                valueFrom = load_field(\n                    _doc.get(\"valueFrom\"),\n                    union_of_None_type_or_strtype_or_ExpressionLoader,\n                    baseuri,\n                    loadingOptions,\n                    lc=_doc.get(\"valueFrom\")\n                )\n\n            except ValidationException as e:\n                error_message, to_print, verb_tensage = parse_errors(str(e))\n\n                if str(e) == \"missing required field `valueFrom`\":\n                    _errors__.append(\n                        ValidationException(\n                            str(e),\n                            None\n                        )\n                    )\n                else:\n                    val = _doc.get(\"valueFrom\")\n                    if error_message != str(e):\n                        val_type = convert_typing(extract_type(type(val)))\n                        _errors__.append(\n                            ValidationException(\n                                \"the `valueFrom` field is not valid because:\",\n                                SourceLine(_doc, \"valueFrom\", str),\n                                [ValidationException(f\"Value is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\",\n                                                     detailed_message=f\"Value `{val}` is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\")],\n                            )\n                        )\n                    else:\n                        _errors__.append(\n                            ValidationException(\n                                \"the `valueFrom` field is not valid because:\",\n                                SourceLine(_doc, \"valueFrom\", str),\n                                [e],\n                                detailed_message=f\"the `valueFrom` field with value `{val}` \"\n                                \"is not valid because:\",\n                            )\n                        )\n        shellQuote = None\n        if \"shellQuote\" in _doc:\n            try:\n                shellQuote = load_field(\n                    _doc.get(\"shellQuote\"),\n                    union_of_None_type_or_booltype,\n                    baseuri,\n                    loadingOptions,\n                    lc=_doc.get(\"shellQuote\")\n                )\n\n            except ValidationException as e:\n                error_message, to_print, verb_tensage = parse_errors(str(e))\n\n                if str(e) == \"missing required field `shellQuote`\":\n                    _errors__.append(\n                        ValidationException(\n                            str(e),\n                            None\n                        )\n                    )\n                else:\n                    val = _doc.get(\"shellQuote\")\n                    if error_message != str(e):\n                        val_type = convert_typing(extract_type(type(val)))\n                        _errors__.append(\n                            ValidationException(\n                                \"the `shellQuote` field is not valid because:\",\n                                SourceLine(_doc, \"shellQuote\", str),\n                                [ValidationException(f\"Value is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\",\n                                                     detailed_message=f\"Value `{val}` is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\")],\n                            )\n                        )\n                    else:\n                        _errors__.append(\n                            ValidationException(\n                                \"the `shellQuote` field is not valid because:\",\n                                SourceLine(_doc, \"shellQuote\", str),\n                                [e],\n                                detailed_message=f\"the `shellQuote` field with value `{val}` \"\n                                \"is not valid because:\",\n                            )\n                        )\n        extension_fields: dict[str, Any] = {}\n        for k in _doc.keys():\n            if k not in cls.attrs:\n                if not k:\n                    _errors__.append(\n                        ValidationException(\"mapping with implicit null key\")\n                    )\n                elif \":\" in k:\n                    ex = expand_url(\n                        k, \"\", loadingOptions, scoped_id=False, vocab_term=False\n                    )\n                    extension_fields[ex] = _doc[k]\n                else:\n                    _errors__.append(\n                        ValidationException(\n                            \"invalid field `{}`, expected one of: `loadContents`, `position`, `prefix`, `separate`, `itemSeparator`, `valueFrom`, `shellQuote`\".format(\n                                k\n                            ),\n                            SourceLine(_doc, k, str),\n                        )\n                    )\n\n        if _errors__:\n            raise ValidationException(\"\", None, _errors__, \"*\")\n        _constructed = cls(\n            loadContents=loadContents,\n            position=position,\n            prefix=prefix,\n            separate=separate,\n            itemSeparator=itemSeparator,\n            valueFrom=valueFrom,\n            shellQuote=shellQuote,\n            extension_fields=extension_fields,\n            loadingOptions=loadingOptions,\n        )\n        return _constructed",
    "pattern_analysis": {
      "api_sequence": [],
      "api_sequence_with_args": [],
      "mapped_sequence": [],
      "contextual_code": ""
    }
  }
]