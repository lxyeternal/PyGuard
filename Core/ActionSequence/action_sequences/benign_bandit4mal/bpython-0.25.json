[
  {
    "metadata": {
      "package_name": "bpython-0.25",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "repl.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/bpython-0.25/bpython-0.25/bpython/curtsiesfrontend/repl.py",
    "line_number": "2102",
    "type_description": "B828:signal",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "2101\t        finally:\n2102\t            signal.signal(signal.SIGWINCH, prev_sigwinch_handler)\n2103",
    "code_snippet": "def focus_on_subprocess(self, args):\n    prev_sigwinch_handler = signal.getsignal(signal.SIGWINCH)\n    try:\n        signal.signal(signal.SIGWINCH, self.orig_sigwinch_handler)\n        with Termmode(self.orig_stdin, self.orig_tcattrs):\n            terminal = self.window.t\n            with terminal.fullscreen():\n                sys.__stdout__.write(terminal.save)\n                sys.__stdout__.write(terminal.move(0, 0))\n                sys.__stdout__.flush()\n                p = subprocess.Popen(\n                    args,\n                    stdin=self.orig_stdin,\n                    stderr=sys.__stderr__,\n                    stdout=sys.__stdout__,\n                )\n                p.wait()\n                sys.__stdout__.write(terminal.restore)\n                sys.__stdout__.flush()\n    finally:\n        signal.signal(signal.SIGWINCH, prev_sigwinch_handler)",
    "pattern_analysis": {
      "api_sequence": [
        "signal.getsignal",
        "signal.signal",
        "Termmode.__enter__",
        "terminal.fullscreen.__enter__",
        "sys.__stdout__.write",
        "sys.__stdout__.write",
        "sys.__stdout__.flush",
        "subprocess.Popen",
        "subprocess.Popen.wait",
        "sys.__stdout__.write",
        "sys.__stdout__.flush",
        "terminal.fullscreen.__exit__",
        "Termmode.__exit__",
        "signal.signal"
      ],
      "api_sequence_with_args": [
        "signal.getsignal(signal.SIGWINCH)",
        "signal.signal(signal.SIGWINCH, self.orig_sigwinch_handler)",
        "Termmode(self.orig_stdin, self.orig_tcattrs).__enter__()",
        "terminal.fullscreen().__enter__()",
        "sys.__stdout__.write(terminal.save)",
        "sys.__stdout__.write(terminal.move(0, 0))",
        "sys.__stdout__.flush()",
        "subprocess.Popen(args, stdin=self.orig_stdin, stderr=sys.__stderr__, stdout=sys.__stdout__)",
        "subprocess.Popen.wait()",
        "sys.__stdout__.write(terminal.restore)",
        "sys.__stdout__.flush()",
        "terminal.fullscreen().__exit__()",
        "Termmode(self.orig_stdin, self.orig_tcattrs).__exit__()",
        "signal.signal(signal.SIGWINCH, prev_sigwinch_handler)"
      ],
      "mapped_sequence": [
        {
          "api_name": "signal.getsignal",
          "id": "error_handling_operations",
          "description": "File opening operations with error handling (ignore errors, custom error handling, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "signal.signal",
          "id": "error_handling_operations",
          "description": "File opening operations with error handling (ignore errors, custom error handling, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "subprocess.Popen",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "subprocess.Popen.wait",
          "id": "wait_process_completion",
          "description": "Waits for process to complete execution",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        }
      ],
      "contextual_code": "def focus_on_subprocess(self, args):\n    prev_sigwinch_handler = signal.getsignal(signal.SIGWINCH)\n    try:\n        signal.signal(signal.SIGWINCH, self.orig_sigwinch_handler)\n        with Termmode(self.orig_stdin, self.orig_tcattrs):\n            terminal = self.window.t\n            with terminal.fullscreen():\n                sys.__stdout__.write(terminal.save)\n                sys.__stdout__.write(terminal.move(0, 0))\n                sys.__stdout__.flush()\n                p = subprocess.Popen(\n                    args,\n                    stdin=self.orig_stdin,\n                    stderr=sys.__stderr__,\n                    stdout=sys.__stdout__,\n                )\n                p.wait()\n                sys.__stdout__.write(terminal.restore)\n                sys.__stdout__.flush()\n    finally:\n        signal.signal(signal.SIGWINCH, prev_sigwinch_handler)"
    }
  },
  {
    "pyfile": "repl.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/bpython-0.25/bpython-0.25/bpython/repl.py",
    "line_number": "999",
    "type_description": "B842:runsource",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "998\n999\t        more: bool = self.interp.runsource(\"\\n\".join(self.buffer))\n1000",
    "code_snippet": "def push(self, s, insert_into_history=True) -> bool:\n    \"\"\"Push a line of code onto the buffer so it can process it all\n    at once when a code block ends\"\"\"\n    # This push method is used by cli and urwid, but not curtsies\n    s = s.rstrip(\"\\n\")\n    self.buffer.append(s)\n\n    if insert_into_history:\n        self.insert_into_history(s)\n\n    more: bool = self.interp.runsource(\"\\n\".join(self.buffer))\n\n    if not more:\n        self.buffer = []\n\n    return more",
    "pattern_analysis": {
      "api_sequence": [
        "self.insert_into_history",
        "self.interp.runsource"
      ],
      "api_sequence_with_args": [
        "self.insert_into_history(s)",
        "self.interp.runsource(\"\\n\".join(self.buffer))"
      ],
      "mapped_sequence": [
        {
          "api_name": "self.insert_into_history",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "self.interp.runsource",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        }
      ],
      "contextual_code": "def push(self, s, insert_into_history=True) -> bool:\n    s = s.rstrip(\"\\n\")\n    self.buffer.append(s)\n\n    if insert_into_history:\n        self.insert_into_history(s)\n\n    more: bool = self.interp.runsource(\"\\n\".join(self.buffer))\n\n    if not more:\n        self.buffer = []\n\n    return more"
    }
  }
]