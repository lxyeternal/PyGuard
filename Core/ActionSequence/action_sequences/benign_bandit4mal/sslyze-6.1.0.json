[
  {
    "metadata": {
      "package_name": "sslyze-6.1.0",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:40"
    }
  },
  {
    "pyfile": "session_renegotiation_plugin.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/sslyze-6.1.0/sslyze-6.1.0/sslyze/plugins/session_renegotiation_plugin.py",
    "line_number": "155",
    "type_description": "B804:connect",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "154\t        # Perform the TLS handshake\n155\t        ssl_connection.connect()\n156\t        supports_secure_renegotiation = ssl_connection.ssl_client.get_secure_renegotiation_support()",
    "code_snippet": "def _test_secure_renegotiation(server_info: ServerConnectivityInfo) -> Tuple[_ScanJobResultEnum, bool]:\n    \"\"\"Check whether the server supports secure renegotiation.\"\"\"\n    # Try with TLS 1.2 even if the server supports TLS 1.3 or higher as there is no reneg with TLS 1.3\n    if server_info.tls_probing_result.highest_tls_version_supported.value >= TlsVersionEnum.TLS_1_3.value:\n        tls_version_to_use = TlsVersionEnum.TLS_1_2\n        downgraded_from_tls_1_3 = True\n    else:\n        tls_version_to_use = server_info.tls_probing_result.highest_tls_version_supported\n        downgraded_from_tls_1_3 = False\n\n    ssl_connection = server_info.get_preconfigured_tls_connection(\n        override_tls_version=tls_version_to_use,\n        should_use_legacy_openssl=True,  # Only the legacy SSL client has methods to check for secure reneg\n    )\n    if not isinstance(ssl_connection.ssl_client, LegacySslClient):\n        raise RuntimeError(\"Should never happen\")\n\n    try:\n        # Perform the TLS handshake\n        ssl_connection.connect()\n        supports_secure_renegotiation = ssl_connection.ssl_client.get_secure_renegotiation_support()\n\n    # Should only happen when the server only supports TLS 1.3\n    except ServerRejectedTlsHandshake:\n        if downgraded_from_tls_1_3:\n            supports_secure_renegotiation = True  # Technically TLS 1.3 has no renegotiation therefore it is secure\n        else:\n            raise\n\n    finally:\n        ssl_connection.close()\n\n    return _ScanJobResultEnum.SUPPORTS_SECURE_RENEG, supports_secure_renegotiation",
    "pattern_analysis": {
      "api_sequence": [
        "server_info.get_preconfigured_tls_connection",
        "isinstance",
        "ssl_connection.connect",
        "ssl_connection.ssl_client.get_secure_renegotiation_support",
        "ssl_connection.close"
      ],
      "api_sequence_with_args": [
        "server_info.get_preconfigured_tls_connection(override_tls_version=tls_version_to_use, should_use_legacy_openssl=True)",
        "isinstance(ssl_connection.ssl_client, LegacySslClient)",
        "ssl_connection.connect()",
        "ssl_connection.ssl_client.get_secure_renegotiation_support()",
        "ssl_connection.close()"
      ],
      "mapped_sequence": [
        {
          "api_name": "server_info.get_preconfigured_tls_connection",
          "id": "wrap_socket_ssl",
          "description": "Wraps socket for SSL/TLS communication",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "isinstance",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "ssl_connection.connect",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "ssl_connection.ssl_client.get_secure_renegotiation_support",
          "id": "wrap_socket_ssl",
          "description": "Wraps socket for SSL/TLS communication",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "ssl_connection.close",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        }
      ],
      "contextual_code": "def _test_secure_renegotiation(server_info: ServerConnectivityInfo) -> Tuple[_ScanJobResultEnum, bool]:\n    if server_info.tls_probing_result.highest_tls_version_supported.value >= TlsVersionEnum.TLS_1_3.value:\n        tls_version_to_use = TlsVersionEnum.TLS_1_2\n        downgraded_from_tls_1_3 = True\n    else:\n        tls_version_to_use = server_info.tls_probing_result.highest_tls_version_supported\n        downgraded_from_tls_1_3 = False\n\n    ssl_connection = server_info.get_preconfigured_tls_connection(\n        override_tls_version=tls_version_to_use,\n        should_use_legacy_openssl=True,\n    )\n    if not isinstance(ssl_connection.ssl_client, LegacySslClient):\n        raise RuntimeError(\"Should never happen\")\n\n    try:\n        ssl_connection.connect()\n        supports_secure_renegotiation = ssl_connection.ssl_client.get_secure_renegotiation_support()\n    except ServerRejectedTlsHandshake:\n        if downgraded_from_tls_1_3:\n            supports_secure_renegotiation = True\n        else:\n            raise\n    finally:\n        ssl_connection.close()"
    }
  }
]