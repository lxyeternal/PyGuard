[
  {
    "metadata": {
      "package_name": "pytest-8.3.5",
      "total_matches": 5,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "helpconfig.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pytest-8.3.5/pytest-8.3.5/src/_pytest/helpconfig.py",
    "line_number": "144",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "143\t            for line in plugininfo:\n144\t                sys.stdout.write(line + \"\\n\")\n145\t    else:",
    "code_snippet": "def showversion(config: Config) -> None:\n    if config.option.version > 1:\n        sys.stdout.write(\n            f\"This is pytest version {pytest.__version__}, imported from {pytest.__file__}\\n\"\n        )\n        plugininfo = getpluginversioninfo(config)\n        if plugininfo:\n            for line in plugininfo:\n                sys.stdout.write(line + \"\\n\")\n    else:\n        sys.stdout.write(f\"pytest {pytest.__version__}\\n\")\n\ndef getpluginversioninfo(config: Config) -> list[str]:\n    lines = []\n    plugininfo = config.pluginmanager.list_plugin_distinfo()\n    if plugininfo:\n        lines.append(\"registered third-party plugins:\")\n        for plugin, dist in plugininfo:\n            loc = getattr(plugin, \"__file__\", repr(plugin))\n            content = f\"{dist.project_name}-{dist.version} at {loc}\"\n            lines.append(\"  \" + content)\n    return lines",
    "pattern_analysis": {
      "api_sequence": [
        "sys.stdout.write",
        "getpluginversioninfo",
        "config.pluginmanager.list_plugin_distinfo",
        "getattr"
      ],
      "api_sequence_with_args": [
        "sys.stdout.write(f\"This is pytest version {pytest.__version__}, imported from {pytest.__file__}\\n\")",
        "getpluginversioninfo(config)",
        "config.pluginmanager.list_plugin_distinfo()",
        "getattr(plugin, \"__file__\", repr(plugin))"
      ],
      "mapped_sequence": [
        {
          "api_name": "sys.stdout.write",
          "id": "get_stdout_stream",
          "description": "Retrieves standard output stream object",
          "first_id": "persistence_stealth",
          "second_id": "user_interaction",
          "third_id": "interface_control"
        },
        {
          "api_name": "getpluginversioninfo",
          "id": "get_global_symbols",
          "description": "Retrieves global symbol table as dictionary",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "config.pluginmanager.list_plugin_distinfo",
          "id": "find_packages",
          "description": "Finds all packages in current directory",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "package_configuration"
        },
        {
          "api_name": "getattr",
          "id": "get_global_symbols",
          "description": "Retrieves global symbol table as dictionary",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        }
      ],
      "contextual_code": "def showversion(config: Config) -> None:\n    if config.option.version > 1:\n        sys.stdout.write(\n            f\"This is pytest version {pytest.__version__}, imported from {pytest.__file__}\\n\"\n        )\n        plugininfo = getpluginversioninfo(config)\n        if plugininfo:\n            for line in plugininfo:\n                sys.stdout.write(line + \"\\n\")\n    else:\n        sys.stdout.write(f\"pytest {pytest.__version__}\\n\")\n\ndef getpluginversioninfo(config: Config) -> list[str]:\n    lines = []\n    plugininfo = config.pluginmanager.list_plugin_distinfo()\n    if plugininfo:\n        lines.append(\"registered third-party plugins:\")\n        for plugin, dist in plugininfo:\n            loc = getattr(plugin, \"__file__\", repr(plugin))\n            content = f\"{dist.project_name}-{dist.version} at {loc}\"\n            lines.append(\"  \" + content)\n    return lines"
    }
  },
  {
    "pyfile": "test_cacheprovider.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pytest-8.3.5/pytest-8.3.5/testing/test_cacheprovider.py",
    "line_number": "327",
    "type_description": "B836:rmtree",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "326\t        if os.path.isdir(\".pytest_cache\"):\n327\t            shutil.rmtree(\".pytest_cache\")\n328\t        result = pytester.runpytest(\"--lf\", \"--cache-clear\")",
    "code_snippet": "def test_lastfailed_usecase(\n    self, pytester: Pytester, monkeypatch: MonkeyPatch\n) -> None:\n    monkeypatch.setattr(\"sys.dont_write_bytecode\", True)\n    p = pytester.makepyfile(\n        \"\"\"\n        def test_1(): assert 0\n        def test_2(): assert 0\n        def test_3(): assert 1\n        \"\"\"\n    )\n    result = pytester.runpytest(str(p))\n    result.stdout.fnmatch_lines([\"*2 failed*\"])\n    p = pytester.makepyfile(\n        \"\"\"\n        def test_1(): assert 1\n        def test_2(): assert 1\n        def test_3(): assert 0\n        \"\"\"\n    )\n    result = pytester.runpytest(str(p), \"--lf\")\n    result.stdout.fnmatch_lines(\n        [\n            \"collected 3 items / 1 deselected / 2 selected\",\n            \"run-last-failure: rerun previous 2 failures\",\n            \"*= 2 passed, 1 deselected in *\",\n        ]\n    )\n    result = pytester.runpytest(str(p), \"--lf\")\n    result.stdout.fnmatch_lines(\n        [\n            \"collected 3 items\",\n            \"run-last-failure: no previously failed tests, not deselecting items.\",\n            \"*1 failed*2 passed*\",\n        ]\n    )\n    pytester.path.joinpath(\".pytest_cache\", \".git\").mkdir(parents=True)\n    result = pytester.runpytest(str(p), \"--lf\", \"--cache-clear\")\n    result.stdout.fnmatch_lines([\"*1 failed*2 passed*\"])\n    assert pytester.path.joinpath(\".pytest_cache\", \"README.md\").is_file()\n    assert pytester.path.joinpath(\".pytest_cache\", \".git\").is_dir()\n\n    # Run this again to make sure clear-cache is robust\n    if os.path.isdir(\".pytest_cache\"):\n        shutil.rmtree(\".pytest_cache\")\n    result = pytester.runpytest(\"--lf\", \"--cache-clear\")\n    result.stdout.fnmatch_lines([\"*1 failed*2 passed*\"])\n",
    "pattern_analysis": {
      "api_sequence": [
        "monkeypatch.setattr",
        "pytester.makepyfile",
        "pytester.runpytest",
        "result.stdout.fnmatch_lines",
        "pytester.makepyfile",
        "pytester.runpytest",
        "result.stdout.fnmatch_lines",
        "pytester.runpytest",
        "result.stdout.fnmatch_lines",
        "pytester.path.joinpath",
        "pytester.path.joinpath.mkdir",
        "pytester.runpytest",
        "result.stdout.fnmatch_lines",
        "pytester.path.joinpath",
        "pytester.path.joinpath.is_file",
        "pytester.path.joinpath",
        "pytester.path.joinpath.is_dir",
        "os.path.isdir",
        "shutil.rmtree",
        "pytester.runpytest",
        "result.stdout.fnmatch_lines"
      ],
      "api_sequence_with_args": [
        "monkeypatch.setattr('sys.dont_write_bytecode', True)",
        "pytester.makepyfile('def test_1(): assert 0\\ndef test_2(): assert 0\\ndef test_3(): assert 1\\n')",
        "pytester.runpytest(str(p))",
        "result.stdout.fnmatch_lines(['*2 failed*'])",
        "pytester.makepyfile('def test_1(): assert 1\\ndef test_2(): assert 1\\ndef test_3(): assert 0\\n')",
        "pytester.runpytest(str(p), '--lf')",
        "result.stdout.fnmatch_lines(['collected 3 items / 1 deselected / 2 selected', 'run-last-failure: rerun previous 2 failures', '*= 2 passed, 1 deselected in *'])",
        "pytester.runpytest(str(p), '--lf')",
        "result.stdout.fnmatch_lines(['collected 3 items', 'run-last-failure: no previously failed tests, not deselecting items.', '*1 failed*2 passed*'])",
        "pytester.path.joinpath('.pytest_cache', '.git')",
        "pytester.path.joinpath('.pytest_cache', '.git').mkdir(parents=True)",
        "pytester.runpytest(str(p), '--lf', '--cache-clear')",
        "result.stdout.fnmatch_lines(['*1 failed*2 passed*'])",
        "pytester.path.joinpath('.pytest_cache', 'README.md')",
        "pytester.path.joinpath('.pytest_cache', 'README.md').is_file()",
        "pytester.path.joinpath('.pytest_cache', '.git')",
        "pytester.path.joinpath('.pytest_cache', '.git').is_dir()",
        "os.path.isdir('.pytest_cache')",
        "shutil.rmtree('.pytest_cache')",
        "pytester.runpytest('--lf', '--cache-clear')",
        "result.stdout.fnmatch_lines(['*1 failed*2 passed*'])"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.isdir",
          "id": "check_directory_exists",
          "description": "Checks if specified path exists and is a directory",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.rmtree",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        }
      ],
      "contextual_code": "import os\nimport shutil\n\n# ...\n\nif os.path.isdir('.pytest_cache'):\n    shutil.rmtree('.pytest_cache')"
    }
  },
  {
    "pyfile": "test_reports.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pytest-8.3.5/pytest-8.3.5/testing/test_reports.py",
    "line_number": "86",
    "type_description": "B842:runsource",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "85\n86\t        reprec = pytester.inline_runsource(\n87\t            \"\"\"\n88\t                            def test_repr_entry():\n89\t                                x = 0\n90\t                                assert x\n91\t                        \"\"\",\n92\t            \"--showlocals\",\n93\t        )",
    "code_snippet": "    def test_reprentries_serialization_170(self, pytester: Pytester) -> None:\n        \"\"\"Regarding issue pytest-xdist#170\n\n        This test came originally from test_remote.py in xdist (ca03269).\n        \"\"\"\n        from _pytest._code.code import ReprEntry\n\n        reprec = pytester.inline_runsource(\n            \"\"\"\n                            def test_repr_entry():\n                                x = 0\n                                assert x\n                        \"\"\",\n            \"--showlocals\",\n        )\n        reports = reprec.getreports(\"pytest_runtest_logreport\")\n        assert len(reports) == 3\n        rep = reports[1]\n        assert isinstance(rep.longrepr, ExceptionRepr)\n        d = rep._to_json()\n        a = TestReport._from_json(d)\n        assert isinstance(a.longrepr, ExceptionRepr)\n\n        rep_entries = rep.longrepr.reprtraceback.reprentries\n        a_entries = a.longrepr.reprtraceback.reprentries\n        assert len(rep_entries) == len(a_entries)  # python < 3.10 zip(strict=True)\n        for a_entry, rep_entry in zip(a_entries, rep_entries):\n            assert isinstance(rep_entry, ReprEntry)\n            assert rep_entry.reprfileloc is not None\n            assert rep_entry.reprfuncargs is not None\n            assert rep_entry.reprlocals is not None\n\n            assert isinstance(a_entry, ReprEntry)\n            assert a_entry.reprfileloc is not None\n            assert a_entry.reprfuncargs is not None\n            assert a_entry.reprlocals is not None\n\n            assert rep_entry.lines == a_entry.lines\n            assert rep_entry.reprfileloc.lineno == a_entry.reprfileloc.lineno\n            assert rep_entry.reprfileloc.message == a_entry.reprfileloc.message\n            assert rep_entry.reprfileloc.path == a_entry.reprfileloc.path\n            assert rep_entry.reprfuncargs.args == a_entry.reprfuncargs.args\n            assert rep_entry.reprlocals.lines == a_entry.reprlocals.lines\n            assert rep_entry.style == a_entry.style\n",
    "pattern_analysis": {
      "api_sequence": [
        "pytester.inline_runsource",
        "reprec.getreports",
        "isinstance",
        "rep._to_json",
        "TestReport._from_json",
        "isinstance",
        "zip"
      ],
      "api_sequence_with_args": [
        "pytester.inline_runsource(\"\"\"\n                            def test_repr_entry():\n                                x = 0\n                                assert x\n                        \"\"\", \"--showlocals\")",
        "reprec.getreports(\"pytest_runtest_logreport\")",
        "isinstance(rep.longrepr, ExceptionRepr)",
        "rep._to_json()",
        "TestReport._from_json(d)",
        "isinstance(a.longrepr, ExceptionRepr)",
        "zip(a_entries, rep_entries)"
      ],
      "mapped_sequence": [
        {
          "api_name": "pytester.inline_runsource",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "reprec.getreports",
          "id": "deserialize_from_json",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "isinstance",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "rep._to_json",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "TestReport._from_json",
          "id": "deserialize_from_json",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "isinstance",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "zip",
          "id": "apply_lambda_pairs",
          "description": "Applies lambda to pairs from two lists",
          "first_id": "data_transformation_processing",
          "second_id": "function_application",
          "third_id": "lambda_application"
        }
      ],
      "contextual_code": "reprec = pytester.inline_runsource(\n    \"\"\"\n                    def test_repr_entry():\n                        x = 0\n                        assert x\n                \"\"\",\n    \"--showlocals\",\n)\nreports = reprec.getreports(\"pytest_runtest_logreport\")\nassert len(reports) == 3\nrep = reports[1]\nassert isinstance(rep.longrepr, ExceptionRepr)\nd = rep._to_json()\na = TestReport._from_json(d)\nassert isinstance(a.longrepr, ExceptionRepr)\n\nrep_entries = rep.longrepr.reprtraceback.reprentries\na_entries = a.longrepr.reprtraceback.reprentries\nassert len(rep_entries) == len(a_entries)  # python < 3.10 zip(strict=True)\nfor a_entry, rep_entry in zip(a_entries, rep_entries):\n    assert isinstance(rep_entry, ReprEntry)\n    assert rep_entry.reprfileloc is not None\n    assert rep_entry.reprfuncargs is not None\n    assert rep_entry.reprlocals is not None\n\n    assert isinstance(a_entry, ReprEntry)\n    assert a_entry.reprfileloc is not None\n    assert a_entry.reprfuncargs is not None\n    assert a_entry.reprlocals is not None\n\n    assert rep_entry.lines == a_entry.lines\n    assert rep_entry.reprfileloc.lineno == a_entry.reprfileloc.lineno\n    assert rep_entry.reprfileloc.message == a_entry.reprfileloc.message\n    assert rep_entry.reprfileloc.path == a_entry.reprfileloc.path\n    assert rep_entry.reprfuncargs.args == a_entry.reprfuncargs.args\n    assert rep_entry.reprlocals.lines == a_entry.reprlocals.lines\n    assert rep_entry.style == a_entry.style"
    }
  },
  {
    "pyfile": "test_runner.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pytest-8.3.5/pytest-8.3.5/testing/test_runner.py",
    "line_number": "314",
    "type_description": "B842:runsource",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "313\t    def test_teardown_final_returncode(self, pytester: Pytester) -> None:\n314\t        rec = pytester.inline_runsource(\n315\t            \"\"\"\n316\t            def test_func():",
    "code_snippet": "def test_teardown_final_returncode(self, pytester: Pytester) -> None:\n    rec = pytester.inline_runsource(\n        \"\"\"\n        def test_func():\n            pass\n        def teardown_function(func):\n            raise ValueError(42)\n    \"\"\"\n    )\n    assert rec.ret == 1",
    "pattern_analysis": {
      "api_sequence": [],
      "api_sequence_with_args": [],
      "mapped_sequence": [],
      "contextual_code": "def test_teardown_final_returncode(self, pytester: Pytester) -> None:\n    rec = pytester.inline_runsource(\n        \"\"\"\n        def test_func():\n            pass\n        def teardown_function(func):\n            raise ValueError(42)\n    \"\"\"\n    )\n    assert rec.ret == 1"
    }
  },
  {
    "pyfile": "test_reports.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pytest-8.3.5/pytest-8.3.5/testing/test_reports.py",
    "line_number": "156",
    "type_description": "B842:runsource",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "155\t        # This test came originally from test_remote.py in xdist (ca03269).\n156\t        reprec = pytester.inline_runsource(\n157\t            \"\"\"\n158\t            import pytest",
    "code_snippet": "def test_xdist_report_longrepr_reprcrash_130(self, pytester: Pytester) -> None:\n    \"\"\"Regarding issue pytest-xdist#130\n\n    This test came originally from test_remote.py in xdist (ca03269).\n    \"\"\"\n    reprec = pytester.inline_runsource(\n        \"\"\"\n                def test_fail():\n                    assert False, 'Expected Message'\n            \"\"\"\n    )\n    reports = reprec.getreports(\"pytest_runtest_logreport\")\n    assert len(reports) == 3\n    rep = reports[1]\n    added_section = (\"Failure Metadata\", \"metadata metadata\", \"*\")\n    assert isinstance(rep.longrepr, ExceptionRepr)\n    rep.longrepr.sections.append(added_section)\n    d = rep._to_json()\n    a = TestReport._from_json(d)\n    assert isinstance(a.longrepr, ExceptionRepr)\n    # Check assembled == rep\n    assert a.__dict__.keys() == rep.__dict__.keys()\n    for key in rep.__dict__.keys():\n        if key != \"longrepr\":\n            assert getattr(a, key) == getattr(rep, key)\n    assert rep.longrepr.reprcrash is not None\n    assert a.longrepr.reprcrash is not None\n    assert rep.longrepr.reprcrash.lineno == a.longrepr.reprcrash.lineno\n    assert rep.longrepr.reprcrash.message == a.longrepr.reprcrash.message\n    assert rep.longrepr.reprcrash.path == a.longrepr.reprcrash.path\n    assert rep.longrepr.reprtraceback.entrysep == a.longrepr.reprtraceback.entrysep\n    assert (\n        rep.longrepr.reprtraceback.extraline == a.longrepr.reprtraceback.extraline\n    )\n    assert rep.longrepr.reprtraceback.style == a.longrepr.reprtraceback.style\n    assert rep.longrepr.sections == a.longrepr.sections\n    # Missing section attribute PR171\n    assert added_section in a.longrepr.sections",
    "pattern_analysis": {
      "api_sequence": [
        "pytester.inline_runsource",
        "reprec.getreports",
        "isinstance",
        "rep.longrepr.sections.append",
        "rep._to_json",
        "TestReport._from_json",
        "isinstance"
      ],
      "api_sequence_with_args": [
        "pytester.inline_runsource(\"\"\"\n                def test_fail():\n                    assert False, 'Expected Message'\n            \"\"\")",
        "reprec.getreports(\"pytest_runtest_logreport\")",
        "isinstance(rep.longrepr, ExceptionRepr)",
        "rep.longrepr.sections.append(added_section)",
        "rep._to_json()",
        "TestReport._from_json(d)",
        "isinstance(a.longrepr, ExceptionRepr)"
      ],
      "mapped_sequence": [
        {
          "api_name": "pytester.inline_runsource",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "reprec.getreports",
          "id": "deserialize_from_json",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "isinstance",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "rep.longrepr.sections.append",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "rep._to_json",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "TestReport._from_json",
          "id": "deserialize_from_json",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "isinstance",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        }
      ],
      "contextual_code": "def test_xdist_report_longrepr_reprcrash_130(self, pytester: Pytester) -> None:\n    reprec = pytester.inline_runsource(\n        \"\"\"\n                def test_fail():\n                    assert False, 'Expected Message'\n            \"\"\"\n    )\n    reports = reprec.getreports(\"pytest_runtest_logreport\")\n    rep = reports[1]\n    added_section = (\"Failure Metadata\", \"metadata metadata\", \"*\")\n    assert isinstance(rep.longrepr, ExceptionRepr)\n    rep.longrepr.sections.append(added_section)\n    d = rep._to_json()\n    a = TestReport._from_json(d)\n    assert isinstance(a.longrepr, ExceptionRepr)"
    }
  }
]