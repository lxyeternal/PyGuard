[
  {
    "metadata": {
      "package_name": "substrate_interface-1.8.0a0-py3-none-any",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "base.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/substrate_interface-1.8.0a0-py3-none-any/substrateinterface/base.py",
    "line_number": "709",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "708\t        self.reload_type_registry(\n709\t            use_remote_preset=self.config.get('use_remote_preset'),\n710\t            auto_discover=self.config.get('auto_discover')",
    "code_snippet": "def init_runtime(self, block_hash=None, block_id=None):\n    \"\"\"\n    This method is used by all other methods that deals with metadata and types defined in the type registry.\n    It optionally retrieves the block_hash when block_id is given and sets the applicable metadata for that\n    block_hash. Also it applies all the versioned types at the time of the block_hash.\n\n    Because parsing of metadata and type registry is quite heavy, the result will be cached per runtime id.\n    In the future there could be support for caching backends like Redis to make this cache more persistent.\n\n    Parameters\n    ----------\n    block_hash\n    block_id\n\n    Returns\n    -------\n\n    \"\"\"\n\n    if block_id and block_hash:\n        raise ValueError('Cannot provide block_hash and block_id at the same time')\n\n    # Check if runtime state already set to current block\n    if (block_hash and block_hash == self.block_hash) or (block_id and block_id == self.block_id):\n        return\n\n    if block_id is not None:\n        block_hash = self.get_block_hash(block_id)\n\n    if not block_hash:\n        block_hash = self.get_chain_head()\n\n    self.block_hash = block_hash\n    self.block_id = block_id\n\n    # In fact calls and storage functions are decoded against runtime of previous block, therefor retrieve\n    # metadata and apply type registry of runtime of parent block\n    block_header = self.rpc_request('chain_getHeader', [self.block_hash])\n\n    if block_header['result'] is None:\n        raise BlockNotFound(f'Block not found for \"{self.block_hash}\"')\n\n    parent_block_hash = block_header['result']['parentHash']\n\n    if parent_block_hash == '0x0000000000000000000000000000000000000000000000000000000000000000':\n        runtime_block_hash = self.block_hash\n    else:\n        runtime_block_hash = parent_block_hash\n\n    runtime_info = self.get_block_runtime_version(block_hash=runtime_block_hash)\n\n    if runtime_info is None:\n        raise SubstrateRequestException(f\"No runtime information for block '{block_hash}'\")\n\n    # Check if runtime state already set to current block\n    if runtime_info.get(\"specVersion\") == self.runtime_version:\n        return\n\n    self.runtime_version = runtime_info.get(\"specVersion\")\n    self.transaction_version = runtime_info.get(\"transactionVersion\")\n\n    if self.cache_region and self.runtime_version not in self.__metadata_cache:\n        # Try to retrieve metadata from Dogpile cache\n        cached_metadata = self.cache_region.get('METADATA_{}'.format(self.runtime_version))\n        if cached_metadata:\n            self.debug_message('Retrieved metadata for {} from Redis'.format(self.runtime_version))\n            self.__metadata_cache[self.runtime_version] = cached_metadata\n\n    if self.runtime_version in self.__metadata_cache:\n        # Get metadata from cache\n        self.debug_message('Retrieved metadata for {} from memory'.format(self.runtime_version))\n        self.metadata = self.__metadata_cache[self.runtime_version]\n    else:\n        self.metadata = self.get_block_metadata(block_hash=runtime_block_hash, decode=True)\n        self.debug_message('Retrieved metadata for {} from Substrate node'.format(self.runtime_version))\n\n        # Update metadata cache\n        self.__metadata_cache[self.runtime_version] = self.metadata\n\n        if self.cache_region:\n            self.debug_message('Stored metadata for {} in Redis'.format(self.runtime_version))\n            self.cache_region.set('METADATA_{}'.format(self.runtime_version), self.metadata)\n\n    # Update type registry\n    self.reload_type_registry(\n        use_remote_preset=self.config.get('use_remote_preset'),\n        auto_discover=self.config.get('auto_discover')\n    )\n\n    # Check if PortableRegistry is present in metadata (V14+), otherwise fall back on legacy type registry (<V14)\n    if self.implements_scaleinfo():\n        self.debug_message('Add PortableRegistry from metadata to type registry')\n        self.runtime_config.add_portable_registry(self.metadata)\n\n    # Set active runtime version\n    self.runtime_config.set_active_spec_version_id(self.runtime_version)\n\n    # Check and apply runtime constants\n    ss58_prefix_constant = self.get_constant(\"System\", \"SS58Prefix\", block_hash=block_hash)\n\n    if ss58_prefix_constant:\n        self.ss58_format = ss58_prefix_constant.value\n\n    # Set runtime compatibility flags\n    try:\n        _ = self.runtime_config.create_scale_object(\"sp_weights::weight_v2::Weight\")\n        self.config['is_weight_v2'] = True\n        self.runtime_config.update_type_registry_types({'Weight': 'sp_weights::weight_v2::Weight'})\n    except NotImplementedError:\n        self.config['is_weight_v2'] = False\n        self.runtime_config.update_type_registry_types({'Weight': 'WeightV1'})",
    "pattern_analysis": {
      "api_sequence": [
        "self.get_block_hash",
        "self.get_chain_head",
        "self.rpc_request",
        "self.get_block_runtime_version",
        "self.config.get",
        "self.config.get",
        "self.cache_region.get",
        "self.debug_message",
        "self.debug_message",
        "self.debug_message",
        "self.cache_region.set",
        "self.reload_type_registry",
        "self.implements_scaleinfo",
        "self.debug_message",
        "self.runtime_config.add_portable_registry",
        "self.runtime_config.set_active_spec_version_id",
        "self.get_constant",
        "self.runtime_config.create_scale_object",
        "self.runtime_config.update_type_registry_types",
        "self.runtime_config.update_type_registry_types"
      ],
      "api_sequence_with_args": [
        "self.get_block_hash(block_id)",
        "self.get_chain_head()",
        "self.rpc_request('chain_getHeader', [self.block_hash])",
        "self.get_block_runtime_version(block_hash=runtime_block_hash)",
        "self.config.get('use_remote_preset')",
        "self.config.get('auto_discover')",
        "self.cache_region.get('METADATA_{}'.format(self.runtime_version))",
        "self.debug_message('Retrieved metadata for {} from Redis'.format(self.runtime_version))",
        "self.debug_message('Retrieved metadata for {} from memory'.format(self.runtime_version))",
        "self.debug_message('Retrieved metadata for {} from Substrate node'.format(self.runtime_version))",
        "self.cache_region.set('METADATA_{}'.format(self.runtime_version), self.metadata)",
        "self.reload_type_registry(use_remote_preset=self.config.get('use_remote_preset'), auto_discover=self.config.get('auto_discover'))",
        "self.implements_scaleinfo()",
        "self.debug_message('Add PortableRegistry from metadata to type registry')",
        "self.runtime_config.add_portable_registry(self.metadata)",
        "self.runtime_config.set_active_spec_version_id(self.runtime_version)",
        "self.get_constant('System', 'SS58Prefix', block_hash=block_hash)",
        "self.runtime_config.create_scale_object('sp_weights::weight_v2::Weight')",
        "self.runtime_config.update_type_registry_types({'Weight': 'sp_weights::weight_v2::Weight'})",
        "self.runtime_config.update_type_registry_types({'Weight': 'WeightV1'})"
      ],
      "mapped_sequence": [
        {
          "api_name": "self.get_block_hash",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "self.get_chain_head",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "self.rpc_request",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "self.get_block_runtime_version",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "self.config.get",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "self.config.get",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "self.cache_region.get",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "self.debug_message",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "self.debug_message",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "self.debug_message",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "self.cache_region.set",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "self.reload_type_registry",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "self.implements_scaleinfo",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "self.debug_message",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "self.runtime_config.add_portable_registry",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "self.runtime_config.set_active_spec_version_id",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "self.get_constant",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "self.runtime_config.create_scale_object",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "self.runtime_config.update_type_registry_types",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "self.runtime_config.update_type_registry_types",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        }
      ],
      "contextual_code": "def init_runtime(self, block_hash=None, block_id=None):\n    if block_id and block_hash:\n        raise ValueError('Cannot provide block_hash and block_id at the same time')\n\n    if (block_hash and block_hash == self.block_hash) or (block_id and block_id == self.block_id):\n        return\n\n    if block_id is not None:\n        block_hash = self.get_block_hash(block_id)\n\n    if not block_hash:\n        block_hash = self.get_chain_head()\n\n    self.block_hash = block_hash\n    self.block_id = block_id\n\n    block_header = self.rpc_request('chain_getHeader', [self.block_hash])\n\n    if block_header['result'] is None:\n        raise BlockNotFound(f'Block not found for \"{self.block_hash}\"')\n\n    parent_block_hash = block_header['result']['parentHash']\n\n    if parent_block_hash == '0x0000000000000000000000000000000000000000000000000000000000000000':\n        runtime_block_hash = self.block_hash\n    else:\n        runtime_block_hash = parent_block_hash\n\n    runtime_info = self.get_block_runtime_version(block_hash=runtime_block_hash)\n\n    if runtime_info is None:\n        raise SubstrateRequestException(f\"No runtime information for block '{block_hash}'\")\n\n    if runtime_info.get(\"specVersion\") == self.runtime_version:\n        return\n\n    self.runtime_version = runtime_info.get(\"specVersion\")\n    self.transaction_version = runtime_info.get(\"transactionVersion\")\n\n    if self.cache_region and self.runtime_version not in self.__metadata_cache:\n        cached_metadata = self.cache_region.get('METADATA_{}'.format(self.runtime_version))\n        if cached_metadata:\n            self.debug_message('Retrieved metadata for {} from Redis'.format(self.runtime_version))\n            self.__metadata_cache[self.runtime_version] = cached_metadata\n\n    if self.runtime_version in self.__metadata_cache:\n        self.debug_message('Retrieved metadata for {} from memory'.format(self.runtime_version))\n        self.metadata = self.__metadata_cache[self.runtime_version]\n    else:\n        self.metadata = self.get_block_metadata(block_hash=runtime_block_hash, decode=True)\n        self.debug_message('Retrieved metadata for {} from Substrate node'.format(self.runtime_version))\n        self.__metadata_cache[self.runtime_version] = self.metadata\n        if self.cache_region:\n            self.debug_message('Stored metadata for {} in Redis'.format(self.runtime_version))\n            self.cache_region.set('METADATA_{}'.format(self.runtime_version), self.metadata)\n\n    self.reload_type_registry(\n        use_remote_preset=self.config.get('use_remote_preset'),\n        auto_discover=self.config.get('auto_discover')\n    )\n\n    if self.implements_scaleinfo():\n        self.debug_message('Add PortableRegistry from metadata to type registry')\n        self.runtime_config.add_portable_registry(self.metadata)\n\n    self.runtime_config.set_active_spec_version_id(self.runtime_version)\n\n    ss58_prefix_constant = self.get_constant(\"System\", \"SS58Prefix\", block_hash=block_hash)\n\n    if ss58_prefix_constant:\n        self.ss58_format = ss58_prefix_constant.value\n\n    try:\n        _ = self.runtime_config.create_scale_object(\"sp_weights::weight_v2::Weight\")\n        self.config['is_weight_v2'] = True\n        self.runtime_config.update_type_registry_types({'Weight': 'sp_weights::weight_v2::Weight'})\n    except NotImplementedError:\n        self.config['is_weight_v2'] = False\n        self.runtime_config.update_type_registry_types({'Weight': 'WeightV1'})"
    }
  }
]