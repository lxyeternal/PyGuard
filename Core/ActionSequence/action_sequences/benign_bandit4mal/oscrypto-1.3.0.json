[
  {
    "metadata": {
      "package_name": "oscrypto-1.3.0",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:40"
    }
  },
  {
    "pyfile": "tls.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/oscrypto-1.3.0/oscrypto-1.3.0/oscrypto/_win/tls.py",
    "line_number": "769",
    "type_description": "B809:recv",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "768\t                    fail_late = False\n769\t                    bytes_read = self._socket.recv(8192)\n770\t                    if bytes_read == b'':",
    "code_snippet": "def _handshake(self, renegotiate=False):\n    \"\"\"\n    Perform an initial TLS handshake, or a renegotiation\n\n    :param renegotiate:\n        If the handshake is for a renegotiation\n    \"\"\"\n\n    in_buffers = None\n    out_buffers = None\n    new_context_handle_pointer = None\n\n    try:\n        if renegotiate:\n            temp_context_handle_pointer = self._context_handle_pointer\n        else:\n            new_context_handle_pointer = new(secur32, 'CtxtHandle *')\n            temp_context_handle_pointer = new_context_handle_pointer\n\n        requested_flags = {\n            Secur32Const.ISC_REQ_REPLAY_DETECT: 'replay detection',\n            Secur32Const.ISC_REQ_SEQUENCE_DETECT: 'sequence detection',\n            Secur32Const.ISC_REQ_CONFIDENTIALITY: 'confidentiality',\n            Secur32Const.ISC_REQ_ALLOCATE_MEMORY: 'memory allocation',\n            Secur32Const.ISC_REQ_INTEGRITY: 'integrity',\n            Secur32Const.ISC_REQ_STREAM: 'stream orientation',\n            Secur32Const.ISC_REQ_USE_SUPPLIED_CREDS: 'disable automatic client auth',\n        }\n\n        self._context_flags = 0\n        for flag in requested_flags:\n            self._context_flags |= flag\n\n        in_sec_buffer_desc_pointer, in_buffers = self._create_buffers(2)\n        in_buffers[0].BufferType = Secur32Const.SECBUFFER_TOKEN\n\n        out_sec_buffer_desc_pointer, out_buffers = self._create_buffers(2)\n        out_buffers[0].BufferType = Secur32Const.SECBUFFER_TOKEN\n        out_buffers[1].BufferType = Secur32Const.SECBUFFER_ALERT\n\n        output_context_flags_pointer = new(secur32, 'ULONG *')\n\n        if renegotiate:\n            first_handle = temp_context_handle_pointer\n            second_handle = null()\n        else:\n            first_handle = null()\n            second_handle = temp_context_handle_pointer\n\n        result = secur32.InitializeSecurityContextW(\n            self._session._credentials_handle,\n            first_handle,\n            self._hostname,\n            self._context_flags,\n            0,\n            0,\n            null(),\n            0,\n            second_handle,\n            out_sec_buffer_desc_pointer,\n            output_context_flags_pointer,\n            null()\n        )\n        if result not in set([Secur32Const.SEC_E_OK, Secur32Const.SEC_I_CONTINUE_NEEDED]):\n            handle_error(result, TLSError)\n\n        if not renegotiate:\n            temp_context_handle_pointer = second_handle\n        else:\n            temp_context_handle_pointer = first_handle\n\n        handshake_server_bytes = b''\n        handshake_client_bytes = b''\n\n        if out_buffers[0].cbBuffer > 0:\n            token = bytes_from_buffer(out_buffers[0].pvBuffer, out_buffers[0].cbBuffer)\n            handshake_client_bytes += token\n            self._socket.send(token)\n            out_buffers[0].cbBuffer = 0\n            secur32.FreeContextBuffer(out_buffers[0].pvBuffer)\n            out_buffers[0].pvBuffer = null()\n\n        in_data_buffer = buffer_from_bytes(32768)\n        in_buffers[0].pvBuffer = cast(secur32, 'BYTE *', in_data_buffer)\n\n        bytes_read = b''\n        while result != Secur32Const.SEC_E_OK:\n            try:\n                fail_late = False\n                bytes_read = self._socket.recv(8192)\n                if bytes_read == b'':\n                    raise_disconnection()\n            except (socket_error_cls):\n                fail_late = True\n            handshake_server_bytes += bytes_read\n            self._received_bytes += bytes_read\n\n            in_buffers[0].cbBuffer = len(self._received_bytes)\n            write_to_buffer(in_data_buffer, self._received_bytes)\n\n            result = secur32.InitializeSecurityContextW(\n                self._session._credentials_handle,\n                temp_context_handle_pointer,\n                self._hostname,\n                self._context_flags,\n                0,\n                0,\n                in_sec_buffer_desc_pointer,\n                0,\n                null(),\n                out_sec_buffer_desc_pointer,\n                output_context_flags_pointer,\n                null()\n            )\n\n            if result == Secur32Const.SEC_E_INCOMPLETE_MESSAGE:\n                in_buffers[0].BufferType = Secur32Const.SECBUFFER_TOKEN\n                # Windows 10 seems to fill the second input buffer with\n                # a BufferType of SECBUFFER_MISSING (4), which if not\n                # cleared causes the handshake to fail.\n                if in_buffers[1].BufferType != Secur32Const.SECBUFFER_EMPTY:\n                    in_buffers[1].BufferType = Secur32Const.SECBUFFER_EMPTY\n                    in_buffers[1].cbBuffer = 0\n                    if not is_null(in_buffers[1].pvBuffer):\n                        secur32.FreeContextBuffer(in_buffers[1].pvBuffer)\n                        in_buffers[1].pvBuffer = null()\n\n                if fail_late:\n                    raise_disconnection()\n\n                continue\n\n            if result == Secur32Const.SEC_E_ILLEGAL_MESSAGE:\n                if detect_client_auth_request(handshake_server_bytes):\n                    raise_client_auth()\n                alert_info = parse_alert(handshake_server_bytes)\n                if alert_info and alert_info == (2, 70):\n                    raise_protocol_version()\n                raise_handshake()\n\n            if result == Secur32Const.SEC_E_WRONG_PRINCIPAL:\n                chain = extract_chain(handshake_server_bytes)\n                raise_hostname(chain[0], self._hostname)\n\n            if result == Secur32Const.SEC_E_CERT_EXPIRED:\n                chain = extract_chain(handshake_server_bytes)\n                raise_expired_not_yet_valid(chain[0])\n\n            if result == Secur32Const.SEC_E_UNTRUSTED_ROOT:\n                chain = extract_chain(handshake_server_bytes)\n                cert = chain[0]\n                oscrypto_cert = load_certificate(cert)\n                if not oscrypto_cert.self_signed:\n                    raise_no_issuer(cert)\n                raise_self_signed(cert)\n\n            if result == Secur32Const.SEC_E_INTERNAL_ERROR:\n                if get_dh_params_length(handshake_server_bytes) < 1024:\n                    raise_dh_params()\n\n            if result == Secur32Const.SEC_I_INCOMPLETE_CREDENTIALS:\n                raise_client_auth()\n\n            if result == Crypt32Const.TRUST_E_CERT_SIGNATURE:\n                raise_weak_signature(cert)\n\n            if result == Secur32Const.SEC_E_INVALID_TOKEN:\n                # If an alert it present, there may have been a handshake\n                # error due to the server using a certificate path with a\n                # trust root using MD2 or MD5 combined with TLS 1.2. To\n                # work around this, if the user allows anything other than\n                # TLS 1.2, we just remove it from the acceptable protocols\n                # and try again.\n                if out_buffers[1].cbBuffer > 0:\n                    alert_bytes = bytes_from_buffer(out_buffers[1].pvBuffer, out_buffers[1].cbBuffer)\n                    handshake_client_bytes += alert_bytes\n                    alert_number = alert_bytes[6:7]\n                    if alert_number == b'\\x28' or alert_number == b'\\x2b':\n                        if 'TLSv1.2' in self._session._protocols and len(self._session._protocols) > 1:\n                            chain = extract_chain(handshake_server_bytes)\n                            raise _TLSDowngradeError(\n                                'Server certificate verification failed - weak certificate signature algorithm',\n                                chain[0]\n                            )\n                if detect_client_auth_request(handshake_server_bytes):\n                    raise_client_auth()\n                if detect_other_protocol(handshake_server_bytes):\n                    raise_protocol_error(handshake_server_bytes)\n                raise_handshake()\n\n            # These are semi-common errors with TLSv1.2 on Windows 7 an 8\n            # that appears to be due to poor handling of the\n            # ServerKeyExchange for DHE_RSA cipher suites. The solution\n            # is to retry the handshake.\n            if result == Secur32Const.SEC_E_BUFFER_TOO_SMALL or result == Secur32Const.SEC_E_MESSAGE_ALTERED:\n                if 'TLSv1.2' in self._session._protocols:\n                    raise _TLSRetryError('TLS handshake failed')\n\n            if fail_late:\n                raise_disconnection()\n\n            if result == Secur32Const.SEC_E_INVALID_PARAMETER:\n                if get_dh_params_length(handshake_server_bytes) < 1024:\n                    raise_dh_params()\n\n            if result not in set([Secur32Const.SEC_E_OK, Secur32Const.SEC_I_CONTINUE_NEEDED]):\n                handle_error(result, TLSError)\n\n            if out_buffers[0].cbBuffer > 0:\n                token = bytes_from_buffer(out_buffers[0].pvBuffer, out_buffers[0].cbBuffer)\n                handshake_client_bytes += token\n                self._socket.send(token)\n                out_buffers[0].cbBuffer = 0\n                secur32.FreeContextBuffer(out_buffers[0].pvBuffer)\n                out_buffers[0].pvBuffer = null()\n\n            if in_buffers[1].BufferType == Secur32Const.SECBUFFER_EXTRA:\n                extra_amount = in_buffers[1].cbBuffer\n                self._received_bytes = self._received_bytes[-extra_amount:]\n                in_buffers[1].BufferType = Secur32Const.SECBUFFER_EMPTY\n                in_buffers[1].cbBuffer = 0\n                secur32.FreeContextBuffer(in_buffers[1].pvBuffer)\n                in_buffers[1].pvBuffer = null()\n\n                # The handshake is complete, so discard any extra bytes\n                if result == Secur32Const.SEC_E_OK:\n                    handshake_server_bytes = handshake_server_bytes[-extra_amount:]\n\n            else:\n                self._received_bytes = b''\n\n        connection_info_pointer = struct(secur32, 'SecPkgContext_ConnectionInfo')\n        result = secur32.QueryContextAttributesW(\n            temp_context_handle_pointer,\n            Secur32Const.SECPKG_ATTR_CONNECTION_INFO,\n            connection_info_pointer\n        )\n        handle_error(result, TLSError)\n\n        connection_info = unwrap(connection_info_pointer)\n\n        self._protocol = {\n            Secur32Const.SP_PROT_SSL2_CLIENT: 'SSLv2',\n            Secur32Const.SP_PROT_SSL3_CLIENT: 'SSLv3',\n            Secur32Const.SP_PROT_TLS1_CLIENT: 'TLSv1',\n            Secur32Const.SP_PROT_TLS1_1_CLIENT: 'TLSv1.1',\n            Secur32Const.SP_PROT_TLS1_2_CLIENT: 'TLSv1.2',\n        }.get(native(int, connection_info.dwProtocol), str_cls(connection_info.dwProtocol))\n\n        if self._protocol in set(['SSLv3', 'TLSv1', 'TLSv1.1', 'TLSv1.2']):\n            session_info = parse_session_info(handshake_server_bytes, handshake_client_bytes)\n            self._cipher_suite = session_info['cipher_suite']\n            self._compression = session_info['compression']\n            self._session_id = session_info['session_id']\n            self._session_ticket = session_info['session_ticket']\n\n        output_context_flags = deref(output_context_flags_pointer)\n\n        for flag in requested_flags:\n            if (flag | output_context_flags) == 0:\n                raise OSError(pretty_message(\n                    '''\n                    Unable to obtain a credential context with the property %s\n                    ''' ,\n                    requested_flags[flag]\n                ))\n\n        if not renegotiate:\n            self._context_handle_pointer = temp_context_handle_pointer\n            new_context_handle_pointer = None\n\n            stream_sizes_pointer = struct(secur32, 'SecPkgContext_StreamSizes')\n            result = secur32.QueryContextAttributesW(\n                self._context_handle_pointer,\n                Secur32Const.SECPKG_ATTR_STREAM_SIZES,\n                stream_sizes_pointer\n            )\n            handle_error(result)\n\n            stream_sizes = unwrap(stream_sizes_pointer)\n            self._header_size = native(int, stream_sizes.cbHeader)\n            self._message_size = native(int, stream_sizes.cbMaximumMessage)\n            self._trailer_size = native(int, stream_sizes.cbTrailer)\n            self._buffer_size = self._header_size + self._message_size + self._trailer_size\n\n        if self._session._extra_trust_roots:\n            self._extra_trust_root_validation()\n\n    except (OSError, socket_.error):\n        self.close()\n\n        raise\n\n    finally:\n        if out_buffers:\n            if not is_null(out_buffers[0].pvBuffer):\n                secur32.FreeContextBuffer(out_buffers[0].pvBuffer)\n            if not is_null(out_buffers[1].pvBuffer):\n                secur32.FreeContextBuffer(out_buffers[1].pvBuffer)\n        if new_context_handle_pointer:\n            secur32.DeleteSecurityContext(new_context_handle_pointer)",
    "pattern_analysis": {
      "api_sequence": [
        "new",
        "self._create_buffers",
        "self._create_buffers",
        "new",
        "null",
        "secur32.InitializeSecurityContextW",
        "handle_error",
        "bytes_from_buffer",
        "self._socket.send",
        "secur32.FreeContextBuffer",
        "null",
        "buffer_from_bytes",
        "cast",
        "self._socket.recv",
        "write_to_buffer",
        "secur32.InitializeSecurityContextW",
        "bytes_from_buffer",
        "self._socket.send",
        "secur32.FreeContextBuffer",
        "null",
        "secur32.FreeContextBuffer",
        "null",
        "secur32.FreeContextBuffer",
        "null",
        "struct",
        "secur32.QueryContextAttributesW",
        "handle_error",
        "unwrap",
        "native",
        "deref",
        "struct",
        "secur32.QueryContextAttributesW",
        "handle_error",
        "unwrap",
        "native",
        "native",
        "native",
        "is_null",
        "secur32.FreeContextBuffer",
        "is_null",
        "secur32.FreeContextBuffer",
        "secur32.DeleteSecurityContext"
      ],
      "api_sequence_with_args": [
        "new(secur32, 'CtxtHandle *')",
        "self._create_buffers(2)",
        "self._create_buffers(2)",
        "new(secur32, 'ULONG *')",
        "null()",
        "secur32.InitializeSecurityContextW(self._session._credentials_handle, first_handle, self._hostname, self._context_flags, 0, 0, null(), 0, second_handle, out_sec_buffer_desc_pointer, output_context_flags_pointer, null())",
        "handle_error(result, TLSError)",
        "bytes_from_buffer(out_buffers[0].pvBuffer, out_buffers[0].cbBuffer)",
        "self._socket.send(token)",
        "secur32.FreeContextBuffer(out_buffers[0].pvBuffer)",
        "null()",
        "buffer_from_bytes(32768)",
        "cast(secur32, 'BYTE *', in_data_buffer)",
        "self._socket.recv(8192)",
        "write_to_buffer(in_data_buffer, self._received_bytes)",
        "secur32.InitializeSecurityContextW(self._session._credentials_handle, temp_context_handle_pointer, self._hostname, self._context_flags, 0, 0, in_sec_buffer_desc_pointer, 0, null(), out_sec_buffer_desc_pointer, output_context_flags_pointer, null())",
        "bytes_from_buffer(out_buffers[0].pvBuffer, out_buffers[0].cbBuffer)",
        "self._socket.send(token)",
        "secur32.FreeContextBuffer(out_buffers[0].pvBuffer)",
        "null()",
        "secur32.FreeContextBuffer(in_buffers[1].pvBuffer)",
        "null()",
        "secur32.FreeContextBuffer(in_buffers[1].pvBuffer)",
        "null()",
        "struct(secur32, 'SecPkgContext_ConnectionInfo')",
        "secur32.QueryContextAttributesW(temp_context_handle_pointer, Secur32Const.SECPKG_ATTR_CONNECTION_INFO, connection_info_pointer)",
        "handle_error(result, TLSError)",
        "unwrap(connection_info_pointer)",
        "native(int, connection_info.dwProtocol)",
        "deref(output_context_flags_pointer)",
        "struct(secur32, 'SecPkgContext_StreamSizes')",
        "secur32.QueryContextAttributesW(self._context_handle_pointer, Secur32Const.SECPKG_ATTR_STREAM_SIZES, stream_sizes_pointer)",
        "handle_error(result)",
        "unwrap(stream_sizes_pointer)",
        "native(int, stream_sizes.cbHeader)",
        "native(int, stream_sizes.cbMaximumMessage)",
        "native(int, stream_sizes.cbTrailer)",
        "is_null(out_buffers[0].pvBuffer)",
        "secur32.FreeContextBuffer(out_buffers[0].pvBuffer)",
        "is_null(out_buffers[1].pvBuffer)",
        "secur32.FreeContextBuffer(out_buffers[1].pvBuffer)",
        "secur32.DeleteSecurityContext(new_context_handle_pointer)"
      ],
      "mapped_sequence": [
        {
          "api_name": "new",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "self._create_buffers",
          "id": "create_memory_bytes",
          "description": "Creates in-memory bytes buffer from encoded string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "self._create_buffers",
          "id": "create_memory_bytes",
          "description": "Creates in-memory bytes buffer from encoded string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "new",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "null",
          "id": "create_memory_bytes",
          "description": "Creates in-memory bytes buffer from encoded string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "secur32.InitializeSecurityContextW",
          "id": "wrap_socket_ssl",
          "description": "Wraps socket for SSL/TLS communication",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "handle_error",
          "id": "error_handling_operations",
          "description": "File opening operations with error handling (ignore errors, custom error handling, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "bytes_from_buffer",
          "id": "get_buffer_bytes",
          "description": "Retrieves bytes value from in-memory buffer",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "self._socket.send",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "secur32.FreeContextBuffer",
          "id": "free_local_memory",
          "description": "Frees memory allocated by LocalAlloc",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "null",
          "id": "create_memory_bytes",
          "description": "Creates in-memory bytes buffer from encoded string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "buffer_from_bytes",
          "id": "create_memory_bytes",
          "description": "Creates in-memory bytes buffer from encoded string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "cast",
          "id": "create_memory_bytes",
          "description": "Creates in-memory bytes buffer from encoded string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "self._socket.recv",
          "id": "receive_socket_data",
          "description": "Receives data from socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "write_to_buffer",
          "id": "copy_memory",
          "description": "Copies memory from source to destination buffer",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "secur32.InitializeSecurityContextW",
          "id": "wrap_socket_ssl",
          "description": "Wraps socket for SSL/TLS communication",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "bytes_from_buffer",
          "id": "get_buffer_bytes",
          "description": "Retrieves bytes value from in-memory buffer",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "self._socket.send",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "secur32.FreeContextBuffer",
          "id": "free_local_memory",
          "description": "Frees memory allocated by LocalAlloc",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "null",
          "id": "create_memory_bytes",
          "description": "Creates in-memory bytes buffer from encoded string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "secur32.FreeContextBuffer",
          "id": "free_local_memory",
          "description": "Frees memory allocated by LocalAlloc",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "null",
          "id": "create_memory_bytes",
          "description": "Creates in-memory bytes buffer from encoded string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "secur32.FreeContextBuffer",
          "id": "free_local_memory",
          "description": "Frees memory allocated by LocalAlloc",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "null",
          "id": "create_memory_bytes",
          "description": "Creates in-memory bytes buffer from encoded string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "struct",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "secur32.QueryContextAttributesW",
          "id": "wrap_socket_ssl",
          "description": "Wraps socket for SSL/TLS communication",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "handle_error",
          "id": "error_handling_operations",
          "description": "File opening operations with error handling (ignore errors, custom error handling, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "unwrap",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "native",
          "id": "convert_int_to_bytes",
          "description": "Converts integer to bytes with specified length and byte order",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "deref",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "struct",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "secur32.QueryContextAttributesW",
          "id": "wrap_socket_ssl",
          "description": "Wraps socket for SSL/TLS communication",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "handle_error",
          "id": "error_handling_operations",
          "description": "File opening operations with error handling (ignore errors, custom error handling, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "unwrap",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "native",
          "id": "convert_int_to_bytes",
          "description": "Converts integer to bytes with specified length and byte order",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "native",
          "id": "convert_int_to_bytes",
          "description": "Converts integer to bytes with specified length and byte order",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "native",
          "id": "convert_int_to_bytes",
          "description": "Converts integer to bytes with specified length and byte order",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "is_null",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "secur32.FreeContextBuffer",
          "id": "free_local_memory",
          "description": "Frees memory allocated by LocalAlloc",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "is_null",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "secur32.FreeContextBuffer",
          "id": "free_local_memory",
          "description": "Frees memory allocated by LocalAlloc",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "secur32.DeleteSecurityContext",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        }
      ],
      "contextual_code": "def _handshake(self, renegotiate=False):\n    in_buffers = None\n    out_buffers = None\n    new_context_handle_pointer = None\n    try:\n        if renegotiate:\n            temp_context_handle_pointer = self._context_handle_pointer\n        else:\n            new_context_handle_pointer = new(secur32, 'CtxtHandle *')\n            temp_context_handle_pointer = new_context_handle_pointer\n        self._context_flags = 0\n        for flag in requested_flags:\n            self._context_flags |= flag\n        in_sec_buffer_desc_pointer, in_buffers = self._create_buffers(2)\n        out_sec_buffer_desc_pointer, out_buffers = self._create_buffers(2)\n        output_context_flags_pointer = new(secur32, 'ULONG *')\n        if renegotiate:\n            first_handle = temp_context_handle_pointer\n            second_handle = null()\n        else:\n            first_handle = null()\n            second_handle = temp_context_handle_pointer\n        result = secur32.InitializeSecurityContextW(\n            self._session._credentials_handle,\n            first_handle,\n            self._hostname,\n            self._context_flags,\n            0,\n            0,\n            null(),\n            0,\n            second_handle,\n            out_sec_buffer_desc_pointer,\n            output_context_flags_pointer,\n            null()\n        )\n        handle_error(result, TLSError)\n        if out_buffers[0].cbBuffer > 0:\n            token = bytes_from_buffer(out_buffers[0].pvBuffer, out_buffers[0].cbBuffer)\n            self._socket.send(token)\n            out_buffers[0].cbBuffer = 0\n            secur32.FreeContextBuffer(out_buffers[0].pvBuffer)\n            out_buffers[0].pvBuffer = null()\n        in_data_buffer = buffer_from_bytes(32768)\n        in_buffers[0].pvBuffer = cast(secur32, 'BYTE *', in_data_buffer)\n        while result != Secur32Const.SEC_E_OK:\n            bytes_read = self._socket.recv(8192)\n            write_to_buffer(in_data_buffer, self._received_bytes)\n            result = secur32.InitializeSecurityContextW(\n                self._session._credentials_handle,\n                temp_context_handle_pointer,\n                self._hostname,\n                self._context_flags,\n                0,\n                0,\n                in_sec_buffer_desc_pointer,\n                0,\n                null(),\n                out_sec_buffer_desc_pointer,\n                output_context_flags_pointer,\n                null()\n            )\n            if out_buffers[0].cbBuffer > 0:\n                token = bytes_from_buffer(out_buffers[0].pvBuffer, out_buffers[0].cbBuffer)\n                self._socket.send(token)\n                out_buffers[0].cbBuffer = 0\n                secur32.FreeContextBuffer(out_buffers[0].pvBuffer)\n                out_buffers[0].pvBuffer = null()\n            if in_buffers[1].BufferType == Secur32Const.SECBUFFER_EXTRA:\n                secur32.FreeContextBuffer(in_buffers[1].pvBuffer)\n                in_buffers[1].pvBuffer = null()\n            else:\n                self._received_bytes = b''\n        connection_info_pointer = struct(secur32, 'SecPkgContext_ConnectionInfo')\n        result = secur32.QueryContextAttributesW(\n            temp_context_handle_pointer,\n            Secur32Const.SECPKG_ATTR_CONNECTION_INFO,\n            connection_info_pointer\n        )\n        handle_error(result, TLSError)\n        connection_info = unwrap(connection_info_pointer)\n        self._protocol = native(int, connection_info.dwProtocol)\n        output_context_flags = deref(output_context_flags_pointer)\n        if not renegotiate:\n            self._context_handle_pointer = temp_context_handle_pointer\n            new_context_handle_pointer = None\n            stream_sizes_pointer = struct(secur32, 'SecPkgContext_StreamSizes')\n            result = secur32.QueryContextAttributesW(\n                self._context_handle_pointer,\n                Secur32Const.SECPKG_ATTR_STREAM_SIZES,\n                stream_sizes_pointer\n            )\n            handle_error(result)\n            stream_sizes = unwrap(stream_sizes_pointer)\n            self._header_size = native(int, stream_sizes.cbHeader)\n            self._message_size = native(int, stream_sizes.cbMaximumMessage)\n            self._trailer_size = native(int, stream_sizes.cbTrailer)\n            self._buffer_size = self._header_size + self._message_size + self._trailer_size\n    finally:\n        if out_buffers:\n            if not is_null(out_buffers[0].pvBuffer):\n                secur32.FreeContextBuffer(out_buffers[0].pvBuffer)\n            if not is_null(out_buffers[1].pvBuffer):\n                secur32.FreeContextBuffer(out_buffers[1].pvBuffer)\n        if new_context_handle_pointer:\n            secur32.DeleteSecurityContext(new_context_handle_pointer)"
    }
  },
  {
    "pyfile": "_core_foundation_ctypes.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/oscrypto-1.3.0/oscrypto-1.3.0/oscrypto/_mac/_core_foundation_ctypes.py",
    "line_number": "19",
    "type_description": "B841:cdll",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "18\n19\tCoreFoundation = CDLL(core_foundation_path, use_errno=True)\n20",
    "code_snippet": "from ctypes import c_void_p, c_long, c_uint32, c_char_p, c_byte, c_ulong, c_bool\nfrom ctypes import CDLL, string_at, cast, POINTER, byref\nimport ctypes\n\nfrom .._ffi import FFIEngineError, buffer_from_bytes, byte_string_from_buffer\n\n__all__ = [\n    'CFHelpers',\n    'CoreFoundation',\n]\n\ncore_foundation_path = '/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation'\n\nCoreFoundation = CDLL(core_foundation_path, use_errno=True)\n\nCFIndex = c_long\nCFStringEncoding = c_uint32\nCFArray = c_void_p\nCFData = c_void_p\nCFString = c_void_p\nCFNumber = c_void_p\nCFDictionary = c_void_p\nCFError = c_void_p\nCFType = c_void_p\nCFTypeID = c_ulong\nCFBoolean = c_void_p\nCFNumberType = c_uint32\n\nCFTypeRef = POINTER(CFType)\nCFArrayRef = POINTER(CFArray)\nCFDataRef = POINTER(CFData)\nCFStringRef = POINTER(CFString)\nCFNumberRef = POINTER(CFNumber)\nCFBooleanRef = POINTER(CFBoolean)\nCFDictionaryRef = POINTER(CFDictionary)\nCFErrorRef = POINTER(CFError)\nCFAllocatorRef = c_void_p\nCFDictionaryKeyCallBacks = c_void_p\nCFDictionaryValueCallBacks = c_void_p\nCFArrayCallBacks = c_void_p\n\npointer_p = POINTER(c_void_p)\n",
    "pattern_analysis": {
      "api_sequence": [
        "ctypes.CDLL"
      ],
      "api_sequence_with_args": [
        "ctypes.CDLL(core_foundation_path, use_errno=True)"
      ],
      "mapped_sequence": [
        {
          "api_name": "ctypes.CDLL",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        }
      ],
      "contextual_code": "from ctypes import CDLL\n\ncore_foundation_path = '/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation'\n\nCoreFoundation = CDLL(core_foundation_path, use_errno=True)"
    }
  }
]