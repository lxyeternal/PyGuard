[
  {
    "metadata": {
      "package_name": "flaskfarm-4.1.37",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "sub_process.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/flaskfarm-4.1.37/FlaskFarm-4.1.37/flaskfarm/lib/support/base/sub_process.py",
    "line_number": "149",
    "type_description": "B812:system",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "148\t            logger.debug(f\"{self.command=}\")\n149\t            if platform.system() == 'Windows':\n150\t                self.process = subprocess.Popen(self.command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True, shell=self.shell, env=self.env, encoding='utf8', bufsize=0)",
    "code_snippet": "def __execute_thread_function(self):\n    try:\n        self.command = self.command_for_windows(self.command)\n        logger.debug(f\"{self.command=}\")\n        if platform.system() == 'Windows':\n            self.process = subprocess.Popen(self.command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True, shell=self.shell, env=self.env, encoding='utf8', bufsize=0)\n\n        else:\n            if self.uid == None:\n                self.process = subprocess.Popen(self.command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True, shell=self.shell, env=self.env, encoding='utf8', bufsize=0)\n            else:\n                self.process = subprocess.Popen(self.command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True, shell=self.shell, env=self.env, preexec_fn=demote(self.uid, self.gid), encoding='utf8', bufsize=0)\n        SupportSubprocess.__instance_list.append(self)\n        self.send_stdout_callback(self.call_id, 'START', None)\n        self.__start_communicate()\n        self.__start_send_callback()\n        if self.process is not None:\n            if self.timeout != None:\n                self.process.wait(timeout=self.timeout)\n                self.process_close()\n            else:\n                self.process.wait()\n        self.remove_instance(self)\n        logger.info(f\"{self.command} END\")\n    except Exception as e: \n        logger.error(f'Exception:{str(e)}')\n        logger.error(traceback.format_exc())\n        logger.warning(self.command)\n        self.send_stdout_callback(self.call_id, 'ERROR', str(e))\n        self.send_stdout_callback(self.call_id, 'ERROR', str(traceback.format_exc()))\n    finally:\n        if self.stdout_callback != None:\n            #self.stdout_callback(self.call_id, 'thread_end', None)\n            pass",
    "pattern_analysis": {
      "api_sequence": [
        "platform.system",
        "subprocess.Popen",
        "subprocess.Popen",
        "subprocess.Popen",
        "SupportSubprocess.__instance_list.append",
        "self.send_stdout_callback",
        "self.__start_communicate",
        "self.__start_send_callback",
        "self.process.wait",
        "self.process.wait",
        "self.process_close",
        "self.remove_instance",
        "logger.info",
        "logger.error",
        "logger.error",
        "logger.warning",
        "self.send_stdout_callback",
        "self.send_stdout_callback"
      ],
      "api_sequence_with_args": [
        "platform.system()",
        "subprocess.Popen(self.command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True, shell=self.shell, env=self.env, encoding='utf8', bufsize=0)",
        "subprocess.Popen(self.command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True, shell=self.shell, env=self.env, encoding='utf8', bufsize=0)",
        "subprocess.Popen(self.command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True, shell=self.shell, env=self.env, preexec_fn=demote(self.uid, self.gid), encoding='utf8', bufsize=0)",
        "SupportSubprocess.__instance_list.append(self)",
        "self.send_stdout_callback(self.call_id, 'START', None)",
        "self.__start_communicate()",
        "self.__start_send_callback()",
        "self.process.wait(timeout=self.timeout)",
        "self.process.wait()",
        "self.process_close()",
        "self.remove_instance(self)",
        "logger.info(f\"{self.command} END\")",
        "logger.error(f'Exception:{str(e)}')",
        "logger.error(traceback.format_exc())",
        "logger.warning(self.command)",
        "self.send_stdout_callback(self.call_id, 'ERROR', str(e))",
        "self.send_stdout_callback(self.call_id, 'ERROR', str(traceback.format_exc()))"
      ],
      "mapped_sequence": [
        {
          "api_name": "platform.system",
          "id": "get_os_id",
          "description": "Retrieves operating system identifier",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "subprocess.Popen",
          "id": "spawn_process_shell",
          "description": "Spawns new process to execute command with shell access",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_reception"
        },
        {
          "api_name": "subprocess.Popen",
          "id": "spawn_process_shell",
          "description": "Spawns new process to execute command with shell access",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_reception"
        },
        {
          "api_name": "subprocess.Popen",
          "id": "spawn_process_shell",
          "description": "Spawns new process to execute command with shell access",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_reception"
        },
        {
          "api_name": "SupportSubprocess.__instance_list.append",
          "id": "create_thread",
          "description": "Creates new thread to execute target function",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_creation"
        },
        {
          "api_name": "self.send_stdout_callback",
          "id": "send_discord_message",
          "description": "Sends message to Discord channel",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        },
        {
          "api_name": "self.__start_communicate",
          "id": "read_process_stdout",
          "description": "Reads all bytes from process standard output",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "self.__start_send_callback",
          "id": "send_discord_message",
          "description": "Sends message to Discord channel",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        },
        {
          "api_name": "self.process.wait",
          "id": "wait_process_completion",
          "description": "Waits for process to complete execution",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "self.process.wait",
          "id": "wait_process_completion",
          "description": "Waits for process to complete execution",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "self.process_close",
          "id": "terminate_process",
          "description": "Terminates the process",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "self.remove_instance",
          "id": "terminate_process",
          "description": "Terminates the process",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "logger.info",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "logger.error",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "logger.error",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "logger.warning",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "self.send_stdout_callback",
          "id": "send_discord_message",
          "description": "Sends message to Discord channel",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        },
        {
          "api_name": "self.send_stdout_callback",
          "id": "send_discord_message",
          "description": "Sends message to Discord channel",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        }
      ],
      "contextual_code": "def __execute_thread_function(self):\n    try:\n        self.command = self.command_for_windows(self.command)\n        logger.debug(f\"{self.command=}\")\n        if platform.system() == 'Windows':\n            self.process = subprocess.Popen(self.command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True, shell=self.shell, env=self.env, encoding='utf8', bufsize=0)\n        else:\n            if self.uid == None:\n                self.process = subprocess.Popen(self.command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True, shell=self.shell, env=self.env, encoding='utf8', bufsize=0)\n            else:\n                self.process = subprocess.Popen(self.command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True, shell=self.shell, env=self.env, preexec_fn=demote(self.uid, self.gid), encoding='utf8', bufsize=0)\n        SupportSubprocess.__instance_list.append(self)\n        self.send_stdout_callback(self.call_id, 'START', None)\n        self.__start_communicate()\n        self.__start_send_callback()\n        if self.process is not None:\n            if self.timeout != None:\n                self.process.wait(timeout=self.timeout)\n                self.process_close()\n            else:\n                self.process.wait()\n        self.remove_instance(self)\n        logger.info(f\"{self.command} END\")\n    except Exception as e: \n        logger.error(f'Exception:{str(e)}')\n        logger.error(traceback.format_exc())\n        logger.warning(self.command)\n        self.send_stdout_callback(self.call_id, 'ERROR', str(e))\n        self.send_stdout_callback(self.call_id, 'ERROR', str(traceback.format_exc()))"
    }
  }
]