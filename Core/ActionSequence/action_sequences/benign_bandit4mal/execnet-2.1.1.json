[
  {
    "metadata": {
      "package_name": "execnet-2.1.1",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "gateway_base.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/execnet-2.1.1/execnet-2.1.1/src/execnet/gateway_base.py",
    "line_number": "1761",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1760\t    def save_Channel(self, channel: Channel) -> None:\n1761\t        self._write(opcode.CHANNEL)\n1762\t        self._write_int4(channel.id)",
    "code_snippet": "class _Serializer:\n    _dispatch: dict[type, Callable[[_Serializer, object], None]] = {}\n\n    def __init__(self, write: Callable[[bytes], None] | None = None) -> None:\n        if write is None:\n            self._streamlist: list[bytes] = []\n            write = self._streamlist.append\n        self._write = write\n\n    def save(self, obj: object, versioned: bool = False) -> bytes | None:\n        # calling here is not re-entrant but multiple instances\n        # may write to the same stream because of the common platform\n        # atomic-write guarantee (concurrent writes each happen atomically)\n        if versioned:\n            self._write(DUMPFORMAT_VERSION)\n        self._save(obj)\n        self._write(opcode.STOP)\n        try:\n            streamlist = self._streamlist\n        except AttributeError:\n            return None\n        return b\"\".join(streamlist)\n\n    def _save(self, obj: object) -> None:\n        tp = type(obj)\n        try:\n            dispatch = self._dispatch[tp]\n        except KeyError:\n            methodname = \"save_\" + tp.__name__\n            meth: Callable[[_Serializer, object], None] | None = getattr(\n                self.__class__, methodname, None\n            )\n            if meth is None:\n                raise DumpError(f\"can't serialize {tp}\") from None\n            dispatch = self._dispatch[tp] = meth\n        dispatch(self, obj)\n\n    def save_NoneType(self, non: None) -> None:\n        self._write(opcode.NONE)\n\n    def save_bool(self, boolean: bool) -> None:\n        if boolean:\n            self._write(opcode.TRUE)\n        else:\n            self._write(opcode.FALSE)\n\n    def save_bytes(self, bytes_: bytes) -> None:\n        self._write(opcode.BYTES)\n        self._write_byte_sequence(bytes_)\n\n    def save_str(self, s: str) -> None:\n        self._write(opcode.PY3STRING)\n        self._write_unicode_string(s)\n\n    def _write_unicode_string(self, s: str) -> None:\n        try:\n            as_bytes = s.encode(\"utf-8\")\n        except UnicodeEncodeError as e:\n            raise DumpError(\"strings must be utf-8 encodable\") from e\n        self._write_byte_sequence(as_bytes)\n\n    def _write_byte_sequence(self, bytes_: bytes) -> None:\n        self._write_int4(len(bytes_), \"string is too long\")\n        self._write(bytes_)\n\n    def _save_integral(self, i: int, short_op: bytes, long_op: bytes) -> None:\n        if i <= FOUR_BYTE_INT_MAX:\n            self._write(short_op)\n            self._write_int4(i)\n        else:\n            self._write(long_op)\n            self._write_byte_sequence(str(i).rstrip(\"L\").encode(\"ascii\"))\n\n    def save_int(self, i: int) -> None:\n        self._save_integral(i, opcode.INT, opcode.LONGINT)\n\n    def save_long(self, l: int) -> None:\n        self._save_integral(l, opcode.LONG, opcode.LONGLONG)\n\n    def save_float(self, flt: float) -> None:\n        self._write(opcode.FLOAT)\n        self._write(struct.pack(FLOAT_FORMAT, flt))\n\n    def save_complex(self, cpx: complex) -> None:\n        self._write(opcode.COMPLEX)\n        self._write(struct.pack(COMPLEX_FORMAT, cpx.real, cpx.imag))\n\n    def _write_int4(\n        self, i: int, error: str = \"int must be less than %i\" % (FOUR_BYTE_INT_MAX,)\n    ) -> None:\n        if i > FOUR_BYTE_INT_MAX:\n            raise DumpError(error)\n        self._write(struct.pack(\"!i\", i))\n\n    def save_list(self, L: list[object]) -> None:\n        self._write(opcode.NEWLIST)\n        self._write_int4(len(L), \"list is too long\")\n        for i, item in enumerate(L):\n            self._write_setitem(i, item)\n\n    def _write_setitem(self, key: object, value: object) -> None:\n        self._save(key)\n        self._save(value)\n        self._write(opcode.SETITEM)\n\n    def save_dict(self, d: dict[object, object]) -> None:\n        self._write(opcode.NEWDICT)\n        for key, value in d.items():\n            self._write_setitem(key, value)\n\n    def save_tuple(self, tup: tuple[object, ...]) -> None:\n        for item in tup:\n            self._save(item)\n        self._write(opcode.BUILDTUPLE)\n        self._write_int4(len(tup), \"tuple is too long\")\n\n    def _write_set(self, s: set[object] | frozenset[object], op: bytes) -> None:\n        for item in s:\n            self._save(item)\n        self._write(op)\n        self._write_int4(len(s), \"set is too long\")\n\n    def save_set(self, s: set[object]) -> None:\n        self._write_set(s, opcode.SET)\n\n    def save_frozenset(self, s: frozenset[object]) -> None:\n        self._write_set(s, opcode.FROZENSET)\n\n    def save_Channel(self, channel: Channel) -> None:\n        self._write(opcode.CHANNEL)\n        self._write_int4(channel.id)",
    "pattern_analysis": {
      "api_sequence": [
        "struct.pack"
      ],
      "api_sequence_with_args": [
        "struct.pack(FLOAT_FORMAT, flt)",
        "struct.pack(COMPLEX_FORMAT, cpx.real, cpx.imag)",
        "struct.pack(\"!i\", i)"
      ],
      "mapped_sequence": [
        {
          "api_name": "struct.pack",
          "id": "pack_values",
          "description": "Packs values into bytes using specified format",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        }
      ],
      "contextual_code": "def save_float(self, flt: float) -> None:\n    self._write(opcode.FLOAT)\n    self._write(struct.pack(FLOAT_FORMAT, flt))\n\ndef save_complex(self, cpx: complex) -> None:\n    self._write(opcode.COMPLEX)\n    self._write(struct.pack(COMPLEX_FORMAT, cpx.real, cpx.imag))\n\ndef _write_int4(self, i: int, error: str = \"int must be less than %i\" % (FOUR_BYTE_INT_MAX,)) -> None:\n    if i > FOUR_BYTE_INT_MAX:\n        raise DumpError(error)\n    self._write(struct.pack(\"!i\", i))"
    }
  }
]