[
  {
    "metadata": {
      "package_name": "asyncio-3.4.3",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "test_unix_events.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/asyncio-3.4.3/asyncio-3.4.3/tests/test_unix_events.py",
    "line_number": "518",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "517\t        m_write.return_value = 4\n518\t        tr.write(b'data')\n519\t        m_write.assert_called_with(5, b'data')",
    "code_snippet": "@mock.patch('os.write')\n    def test_write(self, m_write):\n        tr = self.write_pipe_transport()\n        m_write.return_value = 4\n        tr.write(b'data')\n        m_write.assert_called_with(5, b'data')\n        self.assertFalse(self.loop.writers)\n        self.assertEqual([], tr._buffer)",
    "pattern_analysis": {
      "api_sequence": [
        "os.write"
      ],
      "api_sequence_with_args": [
        "os.write(5, b'data')"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        }
      ],
      "contextual_code": "@mock.patch('os.write')\ndef test_write(self, m_write):\n    tr = self.write_pipe_transport()\n    m_write.return_value = 4\n    tr.write(b'data')\n    m_write.assert_called_with(5, b'data')"
    }
  },
  {
    "pyfile": "proactor_events.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/asyncio-3.4.3/asyncio-3.4.3/asyncio/proactor_events.py",
    "line_number": "523",
    "type_description": "B807:close",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "522\t                    })\n523\t                    sock.close()\n524\t                elif self._debug:",
    "code_snippet": "def _start_serving(self, protocol_factory, sock,\n                   sslcontext=None, server=None):\n\n    def loop(f=None):\n        try:\n            if f is not None:\n                conn, addr = f.result()\n                if self._debug:\n                    logger.debug(\"%r got a new connection from %r: %r\",\n                                 server, addr, conn)\n                protocol = protocol_factory()\n                if sslcontext is not None:\n                    self._make_ssl_transport(\n                        conn, protocol, sslcontext, server_side=True,\n                        extra={'peername': addr}, server=server)\n                else:\n                    self._make_socket_transport(\n                        conn, protocol,\n                        extra={'peername': addr}, server=server)\n            if self.is_closed():\n                return\n            f = self._proactor.accept(sock)\n        except OSError as exc:\n            if sock.fileno() != -1:\n                self.call_exception_handler({\n                    'message': 'Accept failed on a socket',\n                    'exception': exc,\n                    'socket': sock,\n                })\n                sock.close()\n            elif self._debug:\n                logger.debug(\"Accept failed on socket %r\",\n                             sock, exc_info=True)\n        except futures.CancelledError:\n            sock.close()\n        else:\n            self._accept_futures[sock.fileno()] = f\n            f.add_done_callback(loop)\n\n    self.call_soon(loop)",
    "pattern_analysis": {
      "api_sequence": [
        "self._proactor.accept",
        "f.result",
        "self._make_ssl_transport",
        "self._make_socket_transport",
        "self.is_closed",
        "sock.fileno",
        "self.call_exception_handler",
        "sock.close",
        "logger.debug",
        "sock.close"
      ],
      "api_sequence_with_args": [
        "self._proactor.accept(sock)",
        "f.result()",
        "self._make_ssl_transport(conn, protocol, sslcontext, server_side=True, extra={'peername': addr}, server=server)",
        "self._make_socket_transport(conn, protocol, extra={'peername': addr}, server=server)",
        "self.is_closed()",
        "sock.fileno()",
        "self.call_exception_handler({'message': 'Accept failed on a socket', 'exception': exc, 'socket': sock})",
        "sock.close()",
        "logger.debug('Accept failed on socket %r', sock, exc_info=True)",
        "sock.close()"
      ],
      "mapped_sequence": [
        {
          "api_name": "self._proactor.accept",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "f.result",
          "id": "run_async_function",
          "description": "Runs asynchronous function until completion",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "self._make_ssl_transport",
          "id": "wrap_socket_ssl",
          "description": "Wraps socket for SSL/TLS communication",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "self._make_socket_transport",
          "id": "create_socket",
          "description": "Creates new socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_creation"
        },
        {
          "api_name": "self.is_closed",
          "id": "check_process_terminated",
          "description": "Checks if process has terminated",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "sock.fileno",
          "id": "get_socket_fd",
          "description": "Retrieves file descriptor for socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "self.call_exception_handler",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "sock.close",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "logger.debug",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "sock.close",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        }
      ],
      "contextual_code": "def _start_serving(self, protocol_factory, sock,\n                   sslcontext=None, server=None):\n\n    def loop(f=None):\n        try:\n            if f is not None:\n                conn, addr = f.result()\n                if self._debug:\n                    logger.debug(\"%r got a new connection from %r: %r\",\n                                 server, addr, conn)\n                protocol = protocol_factory()\n                if sslcontext is not None:\n                    self._make_ssl_transport(\n                        conn, protocol, sslcontext, server_side=True,\n                        extra={'peername': addr}, server=server)\n                else:\n                    self._make_socket_transport(\n                        conn, protocol,\n                        extra={'peername': addr}, server=server)\n            if self.is_closed():\n                return\n            f = self._proactor.accept(sock)\n        except OSError as exc:\n            if sock.fileno() != -1:\n                self.call_exception_handler({\n                    'message': 'Accept failed on a socket',\n                    'exception': exc,\n                    'socket': sock,\n                })\n                sock.close()\n            elif self._debug:\n                logger.debug(\"Accept failed on socket %r\",\n                             sock, exc_info=True)\n        except futures.CancelledError:\n            sock.close()\n        else:\n            self._accept_futures[sock.fileno()] = f\n            f.add_done_callback(loop)\n\n    self.call_soon(loop)"
    }
  }
]