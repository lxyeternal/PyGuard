[
  {
    "metadata": {
      "package_name": "cookiecutter-2.6.0",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "test_hooks.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cookiecutter-2.6.0/cookiecutter-2.6.0/tests/test_hooks.py",
    "line_number": "28",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "27\t        f.write(\"# -*- coding: utf-8 -*-\\n\")\n28\t        f.write(\"from __future__ import print_function\\n\")\n29\t        f.write(\"\\n\")",
    "code_snippet": "def make_test_repo(name, multiple_hooks=False):\n    \"\"\"Create test repository for test setup methods.\"\"\"\n    hook_dir = os.path.join(name, 'hooks')\n    template = os.path.join(name, 'input{{hooks}}')\n    os.mkdir(name)\n    os.mkdir(hook_dir)\n    os.mkdir(template)\n\n    Path(template, 'README.rst').write_text(\"foo\\n===\\n\\nbar\\n\")\n\n    with Path(hook_dir, 'pre_gen_project.py').open('w') as f:\n        f.write(\"#!/usr/bin/env python\\n\")\n        f.write(\"# -*- coding: utf-8 -*-\\n\")\n        f.write(\"from __future__ import print_function\\n\")\n        f.write(\"\\n\")\n        f.write(\"print('pre generation hook')\\n\")\n        f.write(\"f = open('python_pre.txt', 'w')\\n\")\n        f.write(\"f.close()\\n\")\n\n    if sys.platform.startswith('win'):\n        post = 'post_gen_project.bat'\n        with Path(hook_dir, post).open('w') as f:\n            f.write(\"@echo off\\n\")\n            f.write(\"\\n\")\n            f.write(\"echo post generation hook\\n\")\n            f.write(\"echo. >shell_post.txt\\n\")\n    else:\n        post = 'post_gen_project.sh'\n        filename = os.path.join(hook_dir, post)\n        with Path(filename).open('w') as f:\n            f.write(\"#!/bin/bash\\n\")\n            f.write(\"\\n\")\n            f.write(\"echo 'post generation hook';\\n\")\n            f.write(\"touch 'shell_post.txt'\\n\")\n        # Set the execute bit\n        os.chmod(filename, os.stat(filename).st_mode | stat.S_IXUSR)\n\n    # Adding an additional pre script\n    if multiple_hooks:\n        if sys.platform.startswith('win'):\n            pre = 'pre_gen_project.bat'\n            with Path(hook_dir, pre).open('w') as f:\n                f.write(\"@echo off\\n\")\n                f.write(\"\\n\")\n                f.write(\"echo post generation hook\\n\")\n                f.write(\"echo. >shell_pre.txt\\n\")\n        else:\n            pre = 'pre_gen_project.sh'\n            filename = os.path.join(hook_dir, pre)\n            with Path(filename).open('w') as f:\n                f.write(\"#!/bin/bash\\n\")\n                f.write(\"\\n\")\n                f.write(\"echo 'post generation hook';\\n\")\n                f.write(\"touch 'shell_pre.txt'\\n\")\n            # Set the execute bit\n            os.chmod(filename, os.stat(filename).st_mode | stat.S_IXUSR)\n\n    return post",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.join",
        "os.path.join",
        "os.mkdir",
        "os.mkdir",
        "os.mkdir",
        "Path.write_text",
        "Path.open",
        "Path.open",
        "Path.open",
        "sys.platform.startswith",
        "Path.open",
        "Path.open",
        "os.path.join",
        "Path.open",
        "os.chmod",
        "os.stat",
        "sys.platform.startswith",
        "Path.open",
        "Path.open",
        "os.path.join",
        "Path.open",
        "os.chmod",
        "os.stat"
      ],
      "api_sequence_with_args": [
        "os.path.join(name, 'hooks')",
        "os.path.join(name, 'input{{hooks}}')",
        "os.mkdir(name)",
        "os.mkdir(hook_dir)",
        "os.mkdir(template)",
        "Path(template, 'README.rst').write_text(\"foo\\n===\\n\\nbar\\n\")",
        "Path(hook_dir, 'pre_gen_project.py').open('w')",
        "Path(hook_dir, post).open('w')",
        "Path(filename).open('w')",
        "sys.platform.startswith('win')",
        "Path(hook_dir, post).open('w')",
        "Path(filename).open('w')",
        "os.path.join(hook_dir, post)",
        "Path(filename).open('w')",
        "os.chmod(filename, os.stat(filename).st_mode | stat.S_IXUSR)",
        "os.stat(filename)",
        "sys.platform.startswith('win')",
        "Path(hook_dir, pre).open('w')",
        "Path(filename).open('w')",
        "os.path.join(hook_dir, pre)",
        "Path(filename).open('w')",
        "os.chmod(filename, os.stat(filename).st_mode | stat.S_IXUSR)",
        "os.stat(filename)"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.mkdir",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.mkdir",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.mkdir",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "Path.write_text",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "Path.open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "Path.open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "Path.open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "sys.platform.startswith",
          "id": "get_platform_info",
          "description": "Retrieves platform information as string",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "Path.open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "Path.open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "Path.open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "os.chmod",
          "id": "change_file_mode_execute",
          "description": "Changes file mode to add execute permission",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_attribute_management"
        },
        {
          "api_name": "os.stat",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "sys.platform.startswith",
          "id": "get_platform_info",
          "description": "Retrieves platform information as string",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "Path.open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "Path.open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "Path.open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "os.chmod",
          "id": "change_file_mode_execute",
          "description": "Changes file mode to add execute permission",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_attribute_management"
        },
        {
          "api_name": "os.stat",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        }
      ],
      "contextual_code": "def make_test_repo(name, multiple_hooks=False):\n    hook_dir = os.path.join(name, 'hooks')\n    template = os.path.join(name, 'input{{hooks}}')\n    os.mkdir(name)\n    os.mkdir(hook_dir)\n    os.mkdir(template)\n\n    Path(template, 'README.rst').write_text(\"foo\\n===\\n\\nbar\\n\")\n\n    with Path(hook_dir, 'pre_gen_project.py').open('w') as f:\n        f.write(\"#!/usr/bin/env python\\n\")\n        f.write(\"# -*- coding: utf-8 -*-\\n\")\n        f.write(\"from __future__ import print_function\\n\")\n        f.write(\"\\n\")\n        f.write(\"print('pre generation hook')\\n\")\n        f.write(\"f = open('python_pre.txt', 'w')\\n\")\n        f.write(\"f.close()\\n\")\n\n    if sys.platform.startswith('win'):\n        post = 'post_gen_project.bat'\n        with Path(hook_dir, post).open('w') as f:\n            f.write(\"@echo off\\n\")\n            f.write(\"\\n\")\n            f.write(\"echo post generation hook\\n\")\n            f.write(\"echo. >shell_post.txt\\n\")\n    else:\n        post = 'post_gen_project.sh'\n        filename = os.path.join(hook_dir, post)\n        with Path(filename).open('w') as f:\n            f.write(\"#!/bin/bash\\n\")\n            f.write(\"\\n\")\n            f.write(\"echo 'post generation hook';\\n\")\n            f.write(\"touch 'shell_post.txt'\\n\")\n        os.chmod(filename, os.stat(filename).st_mode | stat.S_IXUSR)\n\n    if multiple_hooks:\n        if sys.platform.startswith('win'):\n            pre = 'pre_gen_project.bat'\n            with Path(hook_dir, pre).open('w') as f:\n                f.write(\"@echo off\\n\")\n                f.write(\"\\n\")\n                f.write(\"echo post generation hook\\n\")\n                f.write(\"echo. >shell_pre.txt\\n\")\n        else:\n            pre = 'pre_gen_project.sh'\n            filename = os.path.join(hook_dir, pre)\n            with Path(filename).open('w') as f:\n                f.write(\"#!/bin/bash\\n\")\n                f.write(\"\\n\")\n                f.write(\"echo 'post generation hook';\\n\")\n                f.write(\"touch 'shell_pre.txt'\\n\")\n            os.chmod(filename, os.stat(filename).st_mode | stat.S_IXUSR)\n\n    return post"
    }
  },
  {
    "pyfile": "generate.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cookiecutter-2.6.0/cookiecutter-2.6.0/cookiecutter/generate.py",
    "line_number": "391",
    "type_description": "B836:rmtree",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "390\t                    if delete_project_on_failure:\n391\t                        rmtree(project_dir)\n392\t                    _dir = os.path.relpath(unrendered_dir, output_dir)",
    "code_snippet": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n    keep_project_on_failure=False,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param skip_if_file_exists: Skip the files in the corresponding directories\n        if they already exist\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    :param keep_project_on_failure: If `True` keep generated project directory even when\n        generation fails\n    \"\"\"\n    context = context or OrderedDict([])\n\n    env = create_env_with_context(context)\n\n    template_dir = find_template(repo_dir, env)\n    logger.debug('Generating project from %s...', template_dir)\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = f\"Unable to create project directory '{unrendered_dir}'\"\n        raise UndefinedVariableInTemplate(msg, err, context) from err\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created and not keep_project_on_failure\n\n    if accept_hooks:\n        run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader(['.', '../templates'])\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    logger.debug('Found copy only path %s', d)\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n\n                # The outdir is not the root dir, it is the dir which marked as copy\n                # only in the config file. If the program hits this line, which means\n                # the overwrite_if_exists = True, and root dir exists\n                if os.path.isdir(outdir):\n                    shutil.rmtree(outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = f\"Unable to create directory '{_dir}'\"\n                    raise UndefinedVariableInTemplate(msg, err, context) from err\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = f\"Unable to create file '{infile}'\"\n                    raise UndefinedVariableInTemplate(msg, err, context) from err\n\n    if accept_hooks:\n        run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.split",
        "render_and_create_dir",
        "os.path.abspath",
        "run_hook_from_repo_dir",
        "FileSystemLoader",
        "os.walk",
        "os.path.normpath",
        "os.path.join",
        "is_copy_only_path",
        "os.path.normpath",
        "os.path.join",
        "env.from_string",
        "env.from_string.render",
        "os.path.isdir",
        "shutil.rmtree",
        "shutil.copytree",
        "os.path.join",
        "render_and_create_dir",
        "rmtree",
        "os.path.relpath",
        "os.path.normpath",
        "os.path.join",
        "is_copy_only_path",
        "env.from_string",
        "env.from_string.render",
        "os.path.join",
        "shutil.copyfile",
        "shutil.copymode",
        "generate_file",
        "rmtree",
        "run_hook_from_repo_dir"
      ],
      "api_sequence_with_args": [
        "os.path.split(template_dir)",
        "render_and_create_dir(unrendered_dir, context, output_dir, env, overwrite_if_exists)",
        "os.path.abspath(project_dir)",
        "run_hook_from_repo_dir(repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure)",
        "FileSystemLoader(['.', '../templates'])",
        "os.walk('.')",
        "os.path.normpath(os.path.join(root, d))",
        "os.path.join(root, d)",
        "is_copy_only_path(d_, context)",
        "os.path.normpath(os.path.join(root, copy_dir))",
        "os.path.join(root, copy_dir)",
        "env.from_string(outdir)",
        "env.from_string(outdir).render(**context)",
        "os.path.isdir(outdir)",
        "shutil.rmtree(outdir)",
        "shutil.copytree(indir, outdir)",
        "os.path.join(project_dir, root, d)",
        "render_and_create_dir(unrendered_dir, context, output_dir, env, overwrite_if_exists)",
        "rmtree(project_dir)",
        "os.path.relpath(unrendered_dir, output_dir)",
        "os.path.normpath(os.path.join(root, f))",
        "os.path.join(root, f)",
        "is_copy_only_path(infile, context)",
        "env.from_string(infile)",
        "env.from_string(infile).render(**context)",
        "os.path.join(project_dir, outfile_rendered)",
        "shutil.copyfile(infile, outfile)",
        "shutil.copymode(infile, outfile)",
        "generate_file(project_dir, infile, context, env, skip_if_file_exists)",
        "rmtree(project_dir)",
        "run_hook_from_repo_dir(repo_dir, 'post_gen_project', project_dir, context, delete_project_on_failure)"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.split",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "render_and_create_dir",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.abspath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "run_hook_from_repo_dir",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "FileSystemLoader",
          "id": "open_file_app",
          "description": "Opens file with associated application",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "os.walk",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.normpath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "is_copy_only_path",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.path.normpath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "env.from_string",
          "id": "compile_code_object",
          "description": "Compiles source code string into executable code object",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "env.from_string.render",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "os.path.isdir",
          "id": "check_directory_exists",
          "description": "Checks if specified path exists and is a directory",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.rmtree",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "shutil.copytree",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "render_and_create_dir",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "rmtree",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.relpath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.normpath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "is_copy_only_path",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "env.from_string",
          "id": "compile_code_object",
          "description": "Compiles source code string into executable code object",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "env.from_string.render",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "shutil.copyfile",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "shutil.copymode",
          "id": "set_file_attributes",
          "description": "Sets file attributes for specified file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_attribute_management"
        },
        {
          "api_name": "generate_file",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "rmtree",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "run_hook_from_repo_dir",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        }
      ],
      "contextual_code": "def generate_files(...):\n    ...\n    template_dir = find_template(repo_dir, env)\n    unrendered_dir = os.path.split(template_dir)[1]\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        ...\n    project_dir = os.path.abspath(project_dir)\n    ...\n    if accept_hooks:\n        run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n    with work_in(template_dir):\n        env.loader = FileSystemLoader(['.', '../templates'])\n        for root, dirs, files in os.walk('.'):\n            copy_dirs = []\n            render_dirs = []\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                if os.path.isdir(outdir):\n                    shutil.rmtree(outdir)\n                shutil.copytree(indir, outdir)\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    ...\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    ...\n    if accept_hooks:\n        run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )"
    }
  }
]