[
  {
    "metadata": {
      "package_name": "loky-3.5.1",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:40"
    }
  },
  {
    "pyfile": "process_executor.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/loky-3.5.1/loky-3.5.1/loky/process_executor.py",
    "line_number": "698",
    "type_description": "B839:pool",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "697\t            except BaseException as e:\n698\t                bpe = BrokenProcessPool(\n699\t                    \"A result has failed to un-serialize. Please ensure that \"\n700\t                    \"the objects returned by the function are always \"",
    "code_snippet": "def wait_result_broken_or_wakeup(self):\n    # Wait for a result to be ready in the result_queue while checking\n    # that all worker processes are still running, or for a wake up\n    # signal send. The wake up signals come either from new tasks being\n    # submitted, from the executor being shutdown/gc-ed, or from the\n    # shutdown of the python interpreter.\n    result_reader = self.result_queue._reader\n    wakeup_reader = self.thread_wakeup._reader\n    readers = [result_reader, wakeup_reader]\n    worker_sentinels = [p.sentinel for p in list(self.processes.values())]\n    ready = wait(readers + worker_sentinels)\n\n    bpe = None\n    is_broken = True\n    result_item = None\n    if result_reader in ready:\n        try:\n            result_item = result_reader.recv()\n            if isinstance(result_item, _RemoteTraceback):\n                bpe = BrokenProcessPool(\n                    \"A task has failed to un-serialize. Please ensure that\"\n                    \" the arguments of the function are all picklable.\"\n                )\n                bpe.__cause__ = result_item\n            else:\n                is_broken = False\n        except BaseException as e:\n            bpe = BrokenProcessPool(\n                \"A result has failed to un-serialize. Please ensure that \"\n                \"the objects returned by the function are always \"\n                \"picklable.\"\n            )\n            tb = traceback.format_exception(\n                type(e), e, getattr(e, \"__traceback__\", None)\n            )\n            bpe.__cause__ = _RemoteTraceback(\"\".join(tb))\n\n    elif wakeup_reader in ready:\n        # This is simply a wake-up event that might either trigger putting\n        # more tasks in the queue or trigger the clean up of resources.\n        is_broken = False\n    else:\n        # A worker has terminated and we don't know why, set the state of\n        # the executor as broken\n        exit_codes = \"\"\n        if sys.platform != \"win32\":\n            # In Windows, introspecting terminated workers exitcodes seems\n            # unstable, therefore they are not appended in the exception\n            # message.\n            exit_codes = (\n                \"\\nThe exit codes of the workers are \"\n                f\"{get_exitcodes_terminated_worker(self.processes)}\"\n            )\n        mp.util.debug(\n            \"A worker unexpectedly terminated. Workers that \"\n            \"might have caused the breakage: \"\n            + str(\n                {\n                    p.name: p.exitcode\n                    for p in list(self.processes.values())\n                    if p is not None and p.sentinel in ready\n                }\n            )\n        )\n        bpe = TerminatedWorkerError(\n            \"A worker process managed by the executor was unexpectedly \"\n            \"terminated. This could be caused by a segmentation fault \"\n            \"while calling the function or by an excessive memory usage \"\n            \"causing the Operating System to kill the worker.\\n\"\n            f\"{exit_codes}\\n\"\n            \"Detailed tracebacks of the workers should have been printed \"\n            \"to stderr in the executor process if faulthandler was not \"\n            \"disabled.\"\n        )\n\n    self.thread_wakeup.clear()\n\n    return result_item, is_broken, bpe",
    "pattern_analysis": {
      "api_sequence": [
        "self.result_queue._reader.recv",
        "isinstance",
        "traceback.format_exception",
        "getattr",
        "mp.util.debug",
        "self.thread_wakeup.clear"
      ],
      "api_sequence_with_args": [
        "self.result_queue._reader.recv()",
        "isinstance(result_item, _RemoteTraceback)",
        "traceback.format_exception(type(e), e, getattr(e, \"__traceback__\", None))",
        "getattr(e, \"__traceback__\", None)",
        "mp.util.debug(\"A worker unexpectedly terminated. Workers that might have caused the breakage: \" + str({p.name: p.exitcode for p in list(self.processes.values()) if p is not None and p.sentinel in ready}))",
        "self.thread_wakeup.clear()"
      ],
      "mapped_sequence": [
        {
          "api_name": "self.result_queue._reader.recv",
          "id": "receive_socket_data",
          "description": "Receives data from socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "isinstance",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "traceback.format_exception",
          "id": "get_exception_info",
          "description": "Retrieves exception information from current stack frame",
          "first_id": "data_transformation_processing",
          "second_id": "collection_operations",
          "third_id": "iterator_operations"
        },
        {
          "api_name": "getattr",
          "id": "get_global_symbols",
          "description": "Retrieves global symbol table as dictionary",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "mp.util.debug",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "self.thread_wakeup.clear",
          "id": "remove_keyboard_hooks",
          "description": "Removes all keyboard hooks",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "keyboard_monitoring"
        }
      ],
      "contextual_code": "def wait_result_broken_or_wakeup(self):\n    result_reader = self.result_queue._reader\n    wakeup_reader = self.thread_wakeup._reader\n    readers = [result_reader, wakeup_reader]\n    worker_sentinels = [p.sentinel for p in list(self.processes.values())]\n    ready = wait(readers + worker_sentinels)\n\n    bpe = None\n    is_broken = True\n    result_item = None\n    if result_reader in ready:\n        try:\n            result_item = result_reader.recv()\n            if isinstance(result_item, _RemoteTraceback):\n                bpe = BrokenProcessPool(\n                    \"A task has failed to un-serialize. Please ensure that\"\n                    \" the arguments of the function are all picklable.\"\n                )\n                bpe.__cause__ = result_item\n            else:\n                is_broken = False\n        except BaseException as e:\n            bpe = BrokenProcessPool(\n                \"A result has failed to un-serialize. Please ensure that \"\n                \"the objects returned by the function are always \"\n                \"picklable.\"\n            )\n            tb = traceback.format_exception(\n                type(e), e, getattr(e, \"__traceback__\", None)\n            )\n            bpe.__cause__ = _RemoteTraceback(\"\".join(tb))\n\n    elif wakeup_reader in ready:\n        is_broken = False\n    else:\n        exit_codes = \"\"\n        if sys.platform != \"win32\":\n            exit_codes = (\n                \"\\nThe exit codes of the workers are \"\n                f\"{get_exitcodes_terminated_worker(self.processes)}\"\n            )\n        mp.util.debug(\n            \"A worker unexpectedly terminated. Workers that \"\n            \"might have caused the breakage: \"\n            + str(\n                {\n                    p.name: p.exitcode\n                    for p in list(self.processes.values())\n                    if p is not None and p.sentinel in ready\n                }\n            )\n        )\n        bpe = TerminatedWorkerError(\n            \"A worker process managed by the executor was unexpectedly \"\n            \"terminated. This could be caused by a segmentation fault \"\n            \"while calling the function or by an excessive memory usage \"\n            \"causing the Operating System to kill the worker.\\n\"\n            f\"{exit_codes}\\n\"\n            \"Detailed tracebacks of the workers should have been printed \"\n            \"to stderr in the executor process if faulthandler was not \"\n            \"disabled.\"\n        )\n\n    self.thread_wakeup.clear()\n\n    return result_item, is_broken, bpe"
    }
  }
]