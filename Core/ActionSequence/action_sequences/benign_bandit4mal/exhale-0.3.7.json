[
  {
    "metadata": {
      "package_name": "exhale-0.3.7",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "graph.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/exhale-0.3.7/exhale-0.3.7/exhale/graph.py",
    "line_number": "4094",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "code_snippet": "def generateUnabridgedAPI(self):\n    '''\n    Generates the unabridged (full) API listing into ``self.unabridged_api_file``.\n    This is necessary as some items may not show up in either hierarchy view,\n    depending on:\n\n    1. The item.  For example, if a namespace has only one member which is a\n       variable, then neither the namespace nor the variable will be declared in the\n       class view hierarchy.  It will be present in the file page it was declared in\n       but not on the main library page.\n\n    2. The configurations of Doxygen.  For example, see the warning in\n       :func:`~exhale.graph.ExhaleRoot.fileRefDiscovery`.  Items whose parents cannot\n       be rediscovered without the programlisting will still be documented, their\n       link appearing in the unabridged API listing.\n\n    Currently, the API is generated in the following (somewhat arbitrary) order:\n\n    - Namespaces\n    - Classes and Structs\n    - Enums\n    - Unions\n    - Functions\n    - Variables\n    - Defines\n    - Typedefs\n    - Directories\n    - Files\n    '''\n    try:\n        from collections.abc import MutableMapping\n    except ImportError:\n        # TODO: remove when dropping python 2.7\n        from collections import MutableMapping\n    class UnabridgedDict(MutableMapping):\n        def __init__(self):\n            self.items = {}\n            for kind in utils.AVAILABLE_KINDS:\n                self.__setitem__(kind, [])\n\n        def _key(self, k):\n            # Just need to fold class and struct to same bucket.\n            if k == \"struct\":\n                return \"class\"\n            return k\n\n        def __getitem__(self, key):\n            k = self._key(key)\n            if k not in self.items:\n                sys.stderr.write(utils.critical(\n                    \"Unabridged API: unexpected kind '{}' (IGNORED)\\n\".format(key)\n                ))\n                self.items[k] = []\n            return self.items[k]\n\n        def __setitem__(self, key, value):\n            self.items[self._key(key)] = value\n\n        def __delitem__(self, key):\n            del self.items[self._key(key)]\n\n        def __iter__(self):\n            return iter(self.items)\n\n        def __len__(self):\n            return len(self.items)\n\n    try:\n        # Gather all nodes in an easy to index dictionary mapping node.kind to the\n        # node itself.  \"class\" and \"struct\" are stored together.\n        unabridged_specs = UnabridgedDict()\n        for node in self.all_nodes:\n            if node.kind == \"page\" and node.refid == \"indexpage\":\n                continue\n            unabridged_specs[node.kind].append(node)\n\n        # Create the buffers to write to and dump the page headings.\n        unabridged_api = StringIO()\n        orphan_api = StringIO()\n        for page, is_orphan in [(unabridged_api, False), (orphan_api, True)]:\n            if is_orphan:\n                page.write(\":orphan:\\n\\n\")\n            page.write(textwrap.dedent('''\n                {heading}\n                {heading_mark}\n            '''.format(\n                heading=configs.fullApiSubSectionTitle,\n                heading_mark=utils.heading_mark(\n                    configs.fullApiSubSectionTitle,\n                    configs.SECTION_HEADING_CHAR if is_orphan\n                    else configs.SUB_SECTION_HEADING_CHAR\n                )\n            )))\n\n        dump_order = [\n            (\"Namespaces\", \"namespace\"),\n            (\"Classes and Structs\", \"class\"),  # NOTE: class/struct stored together!\n            (\"Enums\", \"enum\"),\n            (\"Unions\", \"union\"),\n            (\"Functions\", \"function\"),\n            (\"Variables\", \"variable\"),\n            (\"Defines\", \"define\"),\n            (\"Typedefs\", \"typedef\"),\n            (\"Directories\", \"dir\"),\n            (\"Files\", \"file\"),\n            (\"Pages\", \"page\")\n        ]\n        for title, kind in dump_order:\n            node_list = unabridged_specs[kind]\n            # Write to orphan_api if this kind is to be ignored, or the kind is\n            # \"class\" and \"struct\" was ignored (stored together).\n            if kind in configs.unabridgedOrphanKinds or \\\n                    (kind == \"class\" and \"struct\" in configs.unabridgedOrphanKinds) or \\\n                    (kind == \"struct\" and \"class\" in configs.unabridgedOrphanKinds):\n                dest = orphan_api\n            else:\n                dest = unabridged_api\n            self.enumerateAll(title, node_list, dest)\n\n        # Write out the unabridged api file (gets included to root).\n        with codecs.open(self.unabridged_api_file, \"w\", \"utf-8\") as full_api_file:\n            full_api_file.write(unabridged_api.getvalue())\n\n        # If the orphan file has any .. toctree:: in there, then we want to make\n        # sure to write it.  For example, if files and directories are dumped here,\n        # we want Sphinx to be convinced that they show up in a toctree somewhere.\n        orphan_api_value = orphan_api.getvalue()\n        if \"toctree\" in orphan_api_value:\n            with codecs.open(self.unabridged_orphan_file, \"w\", \"utf-8\") as orphan_file:\n                orphan_file.write(orphan_api_value)\n    except:\n        utils.fancyError(\"Error writing the unabridged API.\")",
    "pattern_analysis": {
      "api_sequence": [
        "utils.critical",
        "sys.stderr.write",
        "textwrap.dedent",
        "utils.heading_mark",
        "self.enumerateAll",
        "codecs.open",
        "StringIO.getvalue",
        "codecs.open",
        "utils.fancyError"
      ],
      "api_sequence_with_args": [
        "utils.critical(\"Unabridged API: unexpected kind '{}' (IGNORED)\\n\".format(key))",
        "sys.stderr.write(utils.critical(...))",
        "textwrap.dedent('''...'''.format(heading=configs.fullApiSubSectionTitle, heading_mark=utils.heading_mark(configs.fullApiSubSectionTitle, ...)))",
        "utils.heading_mark(configs.fullApiSubSectionTitle, configs.SECTION_HEADING_CHAR if is_orphan else configs.SUB_SECTION_HEADING_CHAR)",
        "self.enumerateAll(title, node_list, dest)",
        "codecs.open(self.unabridged_api_file, \"w\", \"utf-8\")",
        "unabridged_api.getvalue()",
        "codecs.open(self.unabridged_orphan_file, \"w\", \"utf-8\")",
        "utils.fancyError(\"Error writing the unabridged API.\")"
      ],
      "mapped_sequence": [
        {
          "api_name": "utils.critical",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "sys.stderr.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "textwrap.dedent",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "utils.heading_mark",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "self.enumerateAll",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "codecs.open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "StringIO.getvalue",
          "id": "get_buffer_bytes",
          "description": "Retrieves bytes value from in-memory buffer",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "codecs.open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "utils.fancyError",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        }
      ],
      "contextual_code": "def generateUnabridgedAPI(self):\n    try:\n        from collections.abc import MutableMapping\n    except ImportError:\n        from collections import MutableMapping\n    class UnabridgedDict(MutableMapping):\n        def __getitem__(self, key):\n            k = self._key(key)\n            if k not in self.items:\n                sys.stderr.write(utils.critical(\n                    \"Unabridged API: unexpected kind '{}' (IGNORED)\\n\".format(key)\n                ))\n                self.items[k] = []\n            return self.items[k]\n    try:\n        unabridged_specs = UnabridgedDict()\n        for node in self.all_nodes:\n            if node.kind == \"page\" and node.refid == \"indexpage\":\n                continue\n            unabridged_specs[node.kind].append(node)\n        unabridged_api = StringIO()\n        orphan_api = StringIO()\n        for page, is_orphan in [(unabridged_api, False), (orphan_api, True)]:\n            if is_orphan:\n                page.write(\":orphan:\\n\\n\")\n            page.write(textwrap.dedent('''\n                {heading}\n                {heading_mark}\n            '''.format(\n                heading=configs.fullApiSubSectionTitle,\n                heading_mark=utils.heading_mark(\n                    configs.fullApiSubSectionTitle,\n                    configs.SECTION_HEADING_CHAR if is_orphan\n                    else configs.SUB_SECTION_HEADING_CHAR\n                )\n            )))\n        dump_order = [\n            (\"Namespaces\", \"namespace\"),\n            (\"Classes and Structs\", \"class\"),\n            (\"Enums\", \"enum\"),\n            (\"Unions\", \"union\"),\n            (\"Functions\", \"function\"),\n            (\"Variables\", \"variable\"),\n            (\"Defines\", \"define\"),\n            (\"Typedefs\", \"typedef\"),\n            (\"Directories\", \"dir\"),\n            (\"Files\", \"file\"),\n            (\"Pages\", \"page\")\n        ]\n        for title, kind in dump_order:\n            node_list = unabridged_specs[kind]\n            if kind in configs.unabridgedOrphanKinds or \\\n                    (kind == \"class\" and \"struct\" in configs.unabridgedOrphanKinds) or \\\n                    (kind == \"struct\" and \"class\" in configs.unabridgedOrphanKinds):\n                dest = orphan_api\n            else:\n                dest = unabridged_api\n            self.enumerateAll(title, node_list, dest)\n        with codecs.open(self.unabridged_api_file, \"w\", \"utf-8\") as full_api_file:\n            full_api_file.write(unabridged_api.getvalue())\n        orphan_api_value = orphan_api.getvalue()\n        if \"toctree\" in orphan_api_value:\n            with codecs.open(self.unabridged_orphan_file, \"w\", \"utf-8\") as orphan_file:\n                orphan_file.write(orphan_api_value)\n    except:\n        utils.fancyError(\"Error writing the unabridged API.\")"
    }
  },
  {
    "pyfile": "graph.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/exhale-0.3.7/exhale-0.3.7/exhale/graph.py",
    "line_number": "390",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "code_snippet": "def templateParametersStringAsRestList(self, nodeByRefid):\n    '''\n    .. todo::\n\n       document this, create another method for creating this without the need for\n       generating links, to be used in making the node titles and labels\n    '''\n    if not self.template_params:\n        return None\n    else:\n        param_stream = StringIO()\n        for param_t, decl_n, def_n in self.template_params:\n            refid, typeid = param_t\n            # Say you wanted a custom link text 'custom', and somewhere\n            # else you had an internal link '.. _some_link:'.  Then you do\n            #     `custom <some_link_>`_\n            # LOL. RST is confusing\n            if refid:\n                # Easy case: the refid is something Exhale is explicitly documenting\n                if refid in nodeByRefid:\n                    link = \"{0}_\".format(nodeByRefid[refid].link_name)\n                else:\n                    # It's going to get generated by Breathe down the line, we need\n                    # to reference the page the directive will appear on.\n                    parent_refid = \"\"\n                    for key in nodeByRefid:\n                        if len(key) > len(parent_refid) and key in refid:\n                            parent_refid = key\n                    parent = nodeByRefid[parent_refid]\n                    parent_page = os.path.basename(parent.file_name.replace(\".rst\", \".html\"))\n                    link = \"{page}#{refid}\".format(page=parent_page, refid=refid)\n                param_stream.write(\n                    \"#. `{typeid} <{link}>`_\".format(\n                        typeid=typeid,\n                        # Not necessarily an ExhaleNode link, should be a link by\n                        # the time Breathe is finished?\n                        link=link\n                    )\n                )\n                close_please = False\n            else:\n                param_stream.write(\"#. ``{typeid}\".format(typeid=typeid))\n                close_please = True\n\n            # The type is in there, but when parsed it may have given something like\n            # `class X` for the typeid (meaning nothing else to write).  For others,\n            # the decl_n is the declared name of the template parameter.  E.g. it\n            # was parsed as `typeid <- class` and `decl_n <- X`.\n            if decl_n:\n                param_stream.write(\" \")\n                if not close_please:\n                    param_stream.write(\"``\")\n                param_stream.write(\"{decl_n}\".format(decl_n=decl_n))\n                close_please = True\n\n            # When templates provide a default value, `def_n` is it.  When parsed,\n            # if the `decl_n` and `def_n` are the same, `def_n` is explicitly set\n            # to be None.\n            if def_n:\n                param_stream.write(\" \")\n                if not close_please:\n                    param_stream.write(\"``\")\n                param_stream.write(\"= {def_n}``\".format(def_n=def_n))\n                close_please = True\n\n            if close_please:\n                param_stream.write(\"``\")\n\n            param_stream.write(\"\\n\")\n\n        param_stream.write(\"\\n\")\n        param_value = param_stream.getvalue()\n        param_stream.close()\n        return param_value",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.basename",
        "StringIO",
        "StringIO.write",
        "StringIO.getvalue",
        "StringIO.close"
      ],
      "api_sequence_with_args": [
        "os.path.basename(parent.file_name.replace(\".rst\", \".html\"))",
        "StringIO()",
        "StringIO.write(...)",
        "StringIO.getvalue()",
        "StringIO.close()"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.basename",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "StringIO",
          "id": "create_memory_bytes",
          "description": "Creates in-memory bytes buffer from encoded string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "StringIO.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "StringIO.getvalue",
          "id": "get_buffer_bytes",
          "description": "Retrieves bytes value from in-memory buffer",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "StringIO.close",
          "id": "close_file",
          "description": "Closes the opened file",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_closing"
        }
      ],
      "contextual_code": "def templateParametersStringAsRestList(self, nodeByRefid):\n    if not self.template_params:\n        return None\n    else:\n        param_stream = StringIO()\n        for param_t, decl_n, def_n in self.template_params:\n            refid, typeid = param_t\n            if refid:\n                if refid in nodeByRefid:\n                    link = \"{0}_\".format(nodeByRefid[refid].link_name)\n                else:\n                    parent_refid = \"\"\n                    for key in nodeByRefid:\n                        if len(key) > len(parent_refid) and key in refid:\n                            parent_refid = key\n                    parent = nodeByRefid[parent_refid]\n                    parent_page = os.path.basename(parent.file_name.replace(\".rst\", \".html\"))\n                    link = \"{page}#{refid}\".format(page=parent_page, refid=refid)\n                param_stream.write(\n                    \"#. `{typeid} <{link}>`_\".format(\n                        typeid=typeid,\n                        link=link\n                    )\n                )\n                close_please = False\n            else:\n                param_stream.write(\"#. ``{typeid}\".format(typeid=typeid))\n                close_please = True\n            if decl_n:\n                param_stream.write(\" \")\n                if not close_please:\n                    param_stream.write(\"``\")\n                param_stream.write(\"{decl_n}\".format(decl_n=decl_n))\n                close_please = True\n            if def_n:\n                param_stream.write(\" \")\n                if not close_please:\n                    param_stream.write(\"``\")\n                param_stream.write(\"= {def_n}``\".format(def_n=def_n))\n                close_please = True\n            if close_please:\n                param_stream.write(\"``\")\n            param_stream.write(\"\\n\")\n        param_stream.write(\"\\n\")\n        param_value = param_stream.getvalue()\n        param_stream.close()\n        return param_value"
    }
  }
]