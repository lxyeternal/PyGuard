[
  {
    "metadata": {
      "package_name": "salt-3007.1",
      "total_matches": 5,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "ssh_py_shim.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/salt-3007.1/salt-3007.1/salt/client/ssh/ssh_py_shim.py",
    "line_number": "331",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "330\t    if not os.path.isfile(salt_call_path):\n331\t        sys.stderr.write('ERROR: thin is missing \"{0}\"\\n'.format(salt_call_path))\n332\t        need_deployment()",
    "code_snippet": "def main(argv):  # pylint: disable=W0613\n    \"\"\"\n    Main program body\n    \"\"\"\n    thin_path = os.path.join(OPTIONS.saltdir, THIN_ARCHIVE)\n    if os.path.isfile(thin_path):\n        if OPTIONS.checksum != get_hash(thin_path, OPTIONS.hashfunc):\n            need_deployment()\n        unpack_thin(thin_path)\n        # Salt thin now is available to use\n    else:\n        if not sys.platform.startswith(\"win\"):\n            scpstat = subprocess.Popen([\"/bin/sh\", \"-c\", \"command -v scp\"]).wait()\n            if scpstat != 0:\n                sys.exit(EX_SCP_NOT_FOUND)\n\n        if os.path.exists(OPTIONS.saltdir) and not os.path.isdir(OPTIONS.saltdir):\n            sys.stderr.write(\n                'ERROR: salt path \"{0}\" exists but is not a directory\\n'.format(\n                    OPTIONS.saltdir\n                )\n            )\n            sys.exit(EX_CANTCREAT)\n\n        if not os.path.exists(OPTIONS.saltdir):\n            need_deployment()\n\n        code_checksum_path = os.path.normpath(\n            os.path.join(OPTIONS.saltdir, \"code-checksum\")\n        )\n        if not os.path.exists(code_checksum_path) or not os.path.isfile(\n            code_checksum_path\n        ):\n            sys.stderr.write(\n                \"WARNING: Unable to locate current code checksum: {0}.\\n\".format(\n                    code_checksum_path\n                )\n            )\n            need_deployment()\n        with open(code_checksum_path, \"r\", encoding=\"utf-8\") as vpo:\n            cur_code_cs = vpo.readline().strip()\n        if cur_code_cs != OPTIONS.code_checksum:\n            sys.stderr.write(\n                \"WARNING: current code checksum {0} is different to {1}.\\n\".format(\n                    cur_code_cs, OPTIONS.code_checksum\n                )\n            )\n            need_deployment()\n        # Salt thin exists and is up-to-date - fall through and use it\n\n    salt_call_path = os.path.join(OPTIONS.saltdir, \"salt-call\")\n    if not os.path.isfile(salt_call_path):\n        sys.stderr.write('ERROR: thin is missing \"{0}\"\\n'.format(salt_call_path))\n        need_deployment()\n\n    with open(os.path.join(OPTIONS.saltdir, \"minion\"), \"w\", encoding=\"utf-8\") as config:\n        config.write(OPTIONS.config + \"\\n\")\n    if OPTIONS.ext_mods:\n        ext_path = os.path.join(OPTIONS.saltdir, EXT_ARCHIVE)\n        if os.path.exists(ext_path):\n            unpack_ext(ext_path)\n        else:\n            version_path = os.path.join(OPTIONS.saltdir, \"ext_version\")\n            if not os.path.exists(version_path) or not os.path.isfile(version_path):\n                need_ext()\n            with open(version_path, \"r\", encoding=\"utf-8\") as vpo:\n                cur_version = vpo.readline().strip()\n            if cur_version != OPTIONS.ext_mods:\n                need_ext()\n    # Fix parameter passing issue\n    if len(ARGS) == 1:\n        argv_prepared = ARGS[0].split()\n    else:\n        argv_prepared = ARGS\n\n    salt_argv = [\n        get_executable(),\n        salt_call_path,\n        \"--retcode-passthrough\",\n        \"--local\",\n        \"--metadata\",\n        \"--out\",\n        \"json\",\n        \"-l\",\n        \"quiet\",\n        \"-c\",\n        OPTIONS.saltdir,\n    ]\n\n    try:\n        if argv_prepared[-1].startswith(\"--no-parse=\"):\n            salt_argv.append(argv_prepared.pop(-1))\n    except (IndexError, TypeError):\n        pass\n\n    salt_argv.append(\"--\")\n    salt_argv.extend(argv_prepared)\n\n    sys.stderr.write(\"SALT_ARGV: {0}\\n\".format(salt_argv))\n\n    # Only emit the delimiter on *both* stdout and stderr when completely successful.\n    # Yes, the flush() is necessary.\n    sys.stdout.write(OPTIONS.delimiter + \"\\n\")\n    sys.stdout.flush()\n    if not OPTIONS.tty:\n        sys.stderr.write(OPTIONS.delimiter + \"\\n\")\n        sys.stderr.flush()\n    if OPTIONS.cmd_umask is not None:\n        old_umask = os.umask(OPTIONS.cmd_umask)  # pylint: disable=blacklisted-function\n    if OPTIONS.tty:\n        proc = subprocess.Popen(\n            salt_argv, stdout=subprocess.PIPE, stderr=subprocess.PIPE\n        )\n        # Returns bytes instead of string on python 3\n        stdout, _ = proc.communicate()\n        sys.stdout.write(\n            stdout.decode(encoding=get_system_encoding(), errors=\"replace\")\n        )\n        sys.stdout.flush()\n        retcode = proc.returncode\n        if OPTIONS.wipe:\n            shutil.rmtree(OPTIONS.saltdir)\n    elif OPTIONS.wipe:\n        retcode = subprocess.call(salt_argv)\n        shutil.rmtree(OPTIONS.saltdir)\n    else:\n        retcode = subprocess.call(salt_argv)\n    if OPTIONS.cmd_umask is not None:\n        os.umask(old_umask)  # pylint: disable=blacklisted-function\n    return retcode",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.join",
        "os.path.isfile",
        "get_hash",
        "need_deployment",
        "unpack_thin",
        "sys.platform.startswith",
        "subprocess.Popen",
        "subprocess.Popen.wait",
        "sys.exit",
        "os.path.exists",
        "os.path.isdir",
        "sys.stderr.write",
        "sys.exit",
        "os.path.exists",
        "need_deployment",
        "os.path.normpath",
        "os.path.join",
        "os.path.exists",
        "os.path.isfile",
        "sys.stderr.write",
        "need_deployment",
        "open",
        "vpo.readline",
        "str.strip",
        "sys.stderr.write",
        "need_deployment",
        "os.path.join",
        "os.path.isfile",
        "sys.stderr.write",
        "need_deployment",
        "open",
        "config.write",
        "os.path.join",
        "os.path.exists",
        "unpack_ext",
        "os.path.join",
        "os.path.exists",
        "os.path.isfile",
        "need_ext",
        "open",
        "vpo.readline",
        "str.strip",
        "need_ext",
        "get_executable",
        "sys.stderr.write",
        "sys.stdout.write",
        "sys.stdout.flush",
        "sys.stderr.write",
        "sys.stderr.flush",
        "os.umask",
        "subprocess.Popen",
        "subprocess.Popen.communicate",
        "sys.stdout.write",
        "get_system_encoding",
        "sys.stdout.flush",
        "shutil.rmtree",
        "subprocess.call",
        "shutil.rmtree",
        "subprocess.call",
        "os.umask"
      ],
      "api_sequence_with_args": [
        "os.path.join(OPTIONS.saltdir, THIN_ARCHIVE)",
        "os.path.isfile(thin_path)",
        "get_hash(thin_path, OPTIONS.hashfunc)",
        "need_deployment()",
        "unpack_thin(thin_path)",
        "sys.platform.startswith(\"win\")",
        "subprocess.Popen([\"/bin/sh\", \"-c\", \"command -v scp\"])",
        "subprocess.Popen([\"/bin/sh\", \"-c\", \"command -v scp\"]).wait()",
        "sys.exit(EX_SCP_NOT_FOUND)",
        "os.path.exists(OPTIONS.saltdir)",
        "os.path.isdir(OPTIONS.saltdir)",
        "sys.stderr.write('ERROR: salt path \"{0}\" exists but is not a directory\\n'.format(OPTIONS.saltdir))",
        "sys.exit(EX_CANTCREAT)",
        "os.path.exists(OPTIONS.saltdir)",
        "need_deployment()",
        "os.path.normpath(os.path.join(OPTIONS.saltdir, \"code-checksum\"))",
        "os.path.join(OPTIONS.saltdir, \"code-checksum\")",
        "os.path.exists(code_checksum_path)",
        "os.path.isfile(code_checksum_path)",
        "sys.stderr.write(\"WARNING: Unable to locate current code checksum: {0}.\\n\".format(code_checksum_path))",
        "need_deployment()",
        "open(code_checksum_path, \"r\", encoding=\"utf-8\")",
        "vpo.readline()",
        "vpo.readline().strip()",
        "sys.stderr.write(\"WARNING: current code checksum {0} is different to {1}.\\n\".format(cur_code_cs, OPTIONS.code_checksum))",
        "need_deployment()",
        "os.path.join(OPTIONS.saltdir, \"salt-call\")",
        "os.path.isfile(salt_call_path)",
        "sys.stderr.write('ERROR: thin is missing \"{0}\"\\n'.format(salt_call_path))",
        "need_deployment()",
        "open(os.path.join(OPTIONS.saltdir, \"minion\"), \"w\", encoding=\"utf-8\")",
        "config.write(OPTIONS.config + \"\\n\")",
        "os.path.join(OPTIONS.saltdir, EXT_ARCHIVE)",
        "os.path.exists(ext_path)",
        "unpack_ext(ext_path)",
        "os.path.join(OPTIONS.saltdir, \"ext_version\")",
        "os.path.exists(version_path)",
        "os.path.isfile(version_path)",
        "need_ext()",
        "open(version_path, \"r\", encoding=\"utf-8\")",
        "vpo.readline()",
        "vpo.readline().strip()",
        "need_ext()",
        "get_executable()",
        "sys.stderr.write(\"SALT_ARGV: {0}\\n\".format(salt_argv))",
        "sys.stdout.write(OPTIONS.delimiter + \"\\n\")",
        "sys.stdout.flush()",
        "sys.stderr.write(OPTIONS.delimiter + \"\\n\")",
        "sys.stderr.flush()",
        "os.umask(OPTIONS.cmd_umask)",
        "subprocess.Popen(salt_argv, stdout=subprocess.PIPE, stderr=subprocess.PIPE)",
        "proc.communicate()",
        "sys.stdout.write(stdout.decode(encoding=get_system_encoding(), errors=\"replace\"))",
        "get_system_encoding()",
        "sys.stdout.flush()",
        "shutil.rmtree(OPTIONS.saltdir)",
        "subprocess.call(salt_argv)",
        "shutil.rmtree(OPTIONS.saltdir)",
        "subprocess.call(salt_argv)",
        "os.umask(old_umask)"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.isfile",
          "id": "check_file_is_file",
          "description": "Checks if specified path exists and is a file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "get_hash",
          "id": "create_sha1_hash",
          "description": "Creates SHA-1 hash object from encoded string",
          "first_id": "encryption_hashing",
          "second_id": "hash_calculation",
          "third_id": "hash_object_creation"
        },
        {
          "api_name": "need_deployment",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "unpack_thin",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "sys.platform.startswith",
          "id": "get_os_id",
          "description": "Retrieves operating system identifier",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "subprocess.Popen",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "subprocess.Popen.wait",
          "id": "wait_process_completion",
          "description": "Waits for process to complete execution",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "sys.exit",
          "id": "exit_program",
          "description": "Exits program with specified status code",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.path.isdir",
          "id": "check_directory_exists",
          "description": "Checks if specified path exists and is a directory",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "sys.stderr.write",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "sys.exit",
          "id": "exit_program",
          "description": "Exits program with specified status code",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "need_deployment",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "os.path.normpath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.path.isfile",
          "id": "check_file_is_file",
          "description": "Checks if specified path exists and is a file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "sys.stderr.write",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "need_deployment",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "vpo.readline",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "str.strip",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "sys.stderr.write",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "need_deployment",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.isfile",
          "id": "check_file_is_file",
          "description": "Checks if specified path exists and is a file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "sys.stderr.write",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "need_deployment",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "config.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "unpack_ext",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.path.isfile",
          "id": "check_file_is_file",
          "description": "Checks if specified path exists and is a file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "need_ext",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "vpo.readline",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "str.strip",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "need_ext",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "get_executable",
          "id": "get_executable_path",
          "description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
          "first_id": "",
          "second_id": "",
          "third_id": ""
        },
        {
          "api_name": "sys.stderr.write",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "sys.stdout.write",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "sys.stdout.flush",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "sys.stderr.write",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "sys.stderr.flush",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "os.umask",
          "id": "set_file_attributes",
          "description": "Sets file attributes for specified file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_attribute_management"
        },
        {
          "api_name": "subprocess.Popen",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "subprocess.Popen.communicate",
          "id": "read_process_stdout",
          "description": "Reads all bytes from process standard output",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "sys.stdout.write",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "get_system_encoding",
          "id": "get_python_version",
          "description": "Retrieves Python interpreter version",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "sys.stdout.flush",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "shutil.rmtree",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "subprocess.call",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "shutil.rmtree",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "subprocess.call",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "os.umask",
          "id": "set_file_attributes",
          "description": "Sets file attributes for specified file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_attribute_management"
        }
      ],
      "contextual_code": "def main(argv):\n    thin_path = os.path.join(OPTIONS.saltdir, THIN_ARCHIVE)\n    if os.path.isfile(thin_path):\n        if OPTIONS.checksum != get_hash(thin_path, OPTIONS.hashfunc):\n            need_deployment()\n        unpack_thin(thin_path)\n    else:\n        if not sys.platform.startswith(\"win\"):\n            scpstat = subprocess.Popen([\"/bin/sh\", \"-c\", \"command -v scp\"]).wait()\n            if scpstat != 0:\n                sys.exit(EX_SCP_NOT_FOUND)\n        if os.path.exists(OPTIONS.saltdir) and not os.path.isdir(OPTIONS.saltdir):\n            sys.stderr.write('ERROR: salt path \"{0}\" exists but is not a directory\\n'.format(OPTIONS.saltdir))\n            sys.exit(EX_CANTCREAT)\n        if not os.path.exists(OPTIONS.saltdir):\n            need_deployment()\n        code_checksum_path = os.path.normpath(os.path.join(OPTIONS.saltdir, \"code-checksum\"))\n        if not os.path.exists(code_checksum_path) or not os.path.isfile(code_checksum_path):\n            sys.stderr.write(\"WARNING: Unable to locate current code checksum: {0}.\\n\".format(code_checksum_path))\n            need_deployment()\n        with open(code_checksum_path, \"r\", encoding=\"utf-8\") as vpo:\n            cur_code_cs = vpo.readline().strip()\n        if cur_code_cs != OPTIONS.code_checksum:\n            sys.stderr.write(\"WARNING: current code checksum {0} is different to {1}.\\n\".format(cur_code_cs, OPTIONS.code_checksum))\n            need_deployment()\n    salt_call_path = os.path.join(OPTIONS.saltdir, \"salt-call\")\n    if not os.path.isfile(salt_call_path):\n        sys.stderr.write('ERROR: thin is missing \"{0}\"\\n'.format(salt_call_path))\n        need_deployment()\n    with open(os.path.join(OPTIONS.saltdir, \"minion\"), \"w\", encoding=\"utf-8\") as config:\n        config.write(OPTIONS.config + \"\\n\")\n    if OPTIONS.ext_mods:\n        ext_path = os.path.join(OPTIONS.saltdir, EXT_ARCHIVE)\n        if os.path.exists(ext_path):\n            unpack_ext(ext_path)\n        else:\n            version_path = os.path.join(OPTIONS.saltdir, \"ext_version\")\n            if not os.path.exists(version_path) or not os.path.isfile(version_path):\n                need_ext()\n            with open(version_path, \"r\", encoding=\"utf-8\") as vpo:\n                cur_version = vpo.readline().strip()\n            if cur_version != OPTIONS.ext_mods:\n                need_ext()\n    salt_argv = [\n        get_executable(),\n        salt_call_path,\n        \"--retcode-passthrough\",\n        \"--local\",\n        \"--metadata\",\n        \"--out\",\n        \"json\",\n        \"-l\",\n        \"quiet\",\n        \"-c\",\n        OPTIONS.saltdir,\n    ]\n    sys.stderr.write(\"SALT_ARGV: {0}\\n\".format(salt_argv))\n    sys.stdout.write(OPTIONS.delimiter + \"\\n\")\n    sys.stdout.flush()\n    if not OPTIONS.tty:\n        sys.stderr.write(OPTIONS.delimiter + \"\\n\")\n        sys.stderr.flush()\n    if OPTIONS.cmd_umask is not None:\n        old_umask = os.umask(OPTIONS.cmd_umask)\n    if OPTIONS.tty:\n        proc = subprocess.Popen(salt_argv, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        stdout, _ = proc.communicate()\n        sys.stdout.write(stdout.decode(encoding=get_system_encoding(), errors=\"replace\"))\n        sys.stdout.flush()\n        retcode = proc.returncode\n        if OPTIONS.wipe:\n            shutil.rmtree(OPTIONS.saltdir)\n    elif OPTIONS.wipe:\n        retcode = subprocess.call(salt_argv)\n        shutil.rmtree(OPTIONS.saltdir)\n    else:\n        retcode = subprocess.call(salt_argv)\n    if OPTIONS.cmd_umask is not None:\n        os.umask(old_umask)\n    return retcode"
    }
  },
  {
    "pyfile": "test_file.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/salt-3007.1/salt-3007.1/tests/pytests/functional/states/test_file.py",
    "line_number": "77",
    "type_description": "B827:httpserver",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "76\t    handler = functools.partial(RequestHandler, directory=directory)\n77\t    s = http.server.HTTPServer((\"127.0.0.1\", port), handler)\n78\t    s.serve_forever()",
    "code_snippet": "def serve(port=8000, directory=None):\n    \"\"\"\n    Function to serve a directory via http.server\n    \"\"\"\n    handler = functools.partial(RequestHandler, directory=directory)\n    s = http.server.HTTPServer((\"127.0.0.1\", port), handler)\n    s.serve_forever()",
    "pattern_analysis": {
      "api_sequence": [],
      "api_sequence_with_args": [],
      "mapped_sequence": [],
      "contextual_code": "def serve(port=8000, directory=None):\n    \"\"\"\n    Function to serve a directory via http.server\n    \"\"\"\n    handler = functools.partial(RequestHandler, directory=directory)\n    s = http.server.HTTPServer((\"127.0.0.1\", port), handler)\n    s.serve_forever()"
    }
  },
  {
    "pyfile": "test_loader.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/salt-3007.1/salt-3007.1/tests/unit/test_loader.py",
    "line_number": "1591",
    "type_description": "B843:compile_file",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1590\t        compileall.compile_file(self.module_file, quiet=1, optimize=1)\n1591\t        compileall.compile_file(self.module_file, quiet=1, optimize=2)\n1592",
    "code_snippet": "def _byte_compile(self):\n    compileall.compile_file(self.module_file, quiet=1, optimize=0)\n    compileall.compile_file(self.module_file, quiet=1, optimize=1)\n    compileall.compile_file(self.module_file, quiet=1, optimize=2)",
    "pattern_analysis": {
      "api_sequence": [
        "compileall.compile_file",
        "compileall.compile_file",
        "compileall.compile_file"
      ],
      "api_sequence_with_args": [
        "compileall.compile_file(self.module_file, quiet=1, optimize=0)",
        "compileall.compile_file(self.module_file, quiet=1, optimize=1)",
        "compileall.compile_file(self.module_file, quiet=1, optimize=2)"
      ],
      "mapped_sequence": [
        {
          "api_name": "compileall.compile_file",
          "id": "compile_code_object",
          "description": "Compiles source code string into executable code object",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "compileall.compile_file",
          "id": "compile_code_object",
          "description": "Compiles source code string into executable code object",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "compileall.compile_file",
          "id": "compile_code_object",
          "description": "Compiles source code string into executable code object",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        }
      ],
      "contextual_code": "def _byte_compile(self):\n    compileall.compile_file(self.module_file, quiet=1, optimize=0)\n    compileall.compile_file(self.module_file, quiet=1, optimize=1)\n    compileall.compile_file(self.module_file, quiet=1, optimize=2)"
    }
  },
  {
    "pyfile": "websockets.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/salt-3007.1/salt-3007.1/salt/netapi/rest_cherrypy/tools/websockets.py",
    "line_number": "55",
    "type_description": "B805:send",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "54\t        if message.data.decode(\"utf-8\") == \"websocket client ready\":\n55\t            self.pipe.send(message)\n56\t        self.send(\"server received message\", False)",
    "code_snippet": "class SynchronizingWebsocket(WebSocket):\n    \"\"\"\n    Class to handle requests sent to this websocket connection.\n    Each instance of this class represents a Salt websocket connection.\n    Waits to receive a ``ready`` message from the client.\n    Calls send on its end of the pipe to signal to the sender on receipt\n    of ``ready``.\n\n    This class also kicks off initial information probing jobs when clients\n    initially connect. These jobs help gather information about minions, jobs,\n    and documentation.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        # This pipe needs to represent the parent end of a pipe.\n        # Clients need to ensure that the pipe assigned to ``self.pipe`` is\n        # the ``parent end`` of a\n        # `pipe <https://docs.python.org/2/library/multiprocessing.html#exchanging-objects-between-processes>`_.\n        self.pipe = None\n\n        # The token that we can use to make API calls.\n        # There are times when we would like to kick off jobs,\n        # examples include trying to obtain minions connected.\n        self.token = None\n\n        # Options represent ``salt`` options defined in the configs.\n        self.opts = None\n\n    def received_message(self, message):\n        \"\"\"\n        Checks if the client has sent a ready message.\n        A ready message causes ``send()`` to be called on the\n        ``parent end`` of the pipe.\n\n        Clients need to ensure that the pipe assigned to ``self.pipe`` is\n        the ``parent end`` of a pipe.\n\n        This ensures completion of the underlying websocket connection\n        and can be used to synchronize parallel senders.\n        \"\"\"\n        if message.data.decode(\"utf-8\") == \"websocket client ready\":\n            self.pipe.send(message)\n        self.send(\"server received message\", False)\n",
    "pattern_analysis": {
      "api_sequence": [
        "message.data.decode",
        "self.pipe.send",
        "self.send"
      ],
      "api_sequence_with_args": [
        "message.data.decode(\"utf-8\")",
        "self.pipe.send(message)",
        "self.send(\"server received message\", False)"
      ],
      "mapped_sequence": [
        {
          "api_name": "message.data.decode",
          "id": "decode_bytes_codec",
          "description": "Decodes bytes using specified codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "self.pipe.send",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "self.send",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        }
      ],
      "contextual_code": "def received_message(self, message):\n    if message.data.decode(\"utf-8\") == \"websocket client ready\":\n        self.pipe.send(message)\n    self.send(\"server received message\", False)"
    }
  },
  {
    "pyfile": "cloud.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/salt-3007.1/salt-3007.1/salt/utils/cloud.py",
    "line_number": "2091",
    "type_description": "B809:recv",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "2090\t        while proc.has_unread_data:\n2091\t            stdout, stderr = proc.recv()\n2092\t            if stdout and SSH_PASSWORD_PROMP_RE.search(stdout):",
    "code_snippet": "def _exec_ssh_cmd(cmd, error_msg=None, allow_failure=False, **kwargs):\n    if error_msg is None:\n        error_msg = \"A wrong password has been issued while establishing ssh session.\"\n    password_retries = kwargs.get(\"password_retries\", 3)\n    try:\n        stdout, stderr = None, None\n        proc = salt.utils.vt.Terminal(\n            cmd,\n            shell=True,\n            log_stdout=True,\n            log_stderr=True,\n            stream_stdout=kwargs.get(\"display_ssh_output\", True),\n            stream_stderr=kwargs.get(\"display_ssh_output\", True),\n        )\n        sent_password = 0\n        while proc.has_unread_data:\n            stdout, stderr = proc.recv()\n            if stdout and SSH_PASSWORD_PROMP_RE.search(stdout):\n                # if authenticating with an SSH key and 'sudo' is found\n                # in the password prompt\n                if (\n                    \"key_filename\" in kwargs\n                    and kwargs[\"key_filename\"]\n                    and SSH_PASSWORD_PROMP_SUDO_RE.search(stdout)\n                ):\n                    proc.sendline(kwargs[\"sudo_password\"])\n                # elif authenticating via password and haven't exhausted our\n                # password_retires\n                elif kwargs.get(\"password\", None) and (\n                    sent_password < password_retries\n                ):\n                    sent_password += 1\n                    proc.sendline(kwargs[\"password\"])\n                # else raise an error as we are not authenticating properly\n                #  * not authenticating with an SSH key\n                #  * not authenticating with a Password\n                else:\n                    raise SaltCloudPasswordError(error_msg)\n            # 0.0125 is really too fast on some systems\n            time.sleep(0.5)\n        if proc.exitstatus != 0 and allow_failure is False:\n            raise SaltCloudSystemExit(\n                f\"Command '{cmd}' failed. Exit code: {proc.exitstatus}\"\n            )\n        return proc.exitstatus\n    except salt.utils.vt.TerminalException as err:\n        trace = traceback.format_exc()\n        log.error(error_msg.format(cmd, err, trace))\n    finally:\n        proc.close(terminate=True, kill=True)\n    # Signal an error\n    return 1",
    "pattern_analysis": {
      "api_sequence": [
        "salt.utils.vt.Terminal",
        "salt.utils.vt.Terminal.has_unread_data",
        "salt.utils.vt.Terminal.recv",
        "SSH_PASSWORD_PROMP_RE.search",
        "SSH_PASSWORD_PROMP_SUDO_RE.search",
        "salt.utils.vt.Terminal.sendline",
        "salt.utils.vt.Terminal.sendline",
        "time.sleep",
        "salt.utils.vt.Terminal.exitstatus",
        "salt.utils.vt.Terminal.exitstatus",
        "traceback.format_exc",
        "log.error",
        "salt.utils.vt.Terminal.close"
      ],
      "api_sequence_with_args": [
        "salt.utils.vt.Terminal(cmd, shell=True, log_stdout=True, log_stderr=True, stream_stdout=kwargs.get(\"display_ssh_output\", True), stream_stderr=kwargs.get(\"display_ssh_output\", True))",
        "proc.has_unread_data",
        "proc.recv()",
        "SSH_PASSWORD_PROMP_RE.search(stdout)",
        "SSH_PASSWORD_PROMP_SUDO_RE.search(stdout)",
        "proc.sendline(kwargs[\"sudo_password\"])",
        "proc.sendline(kwargs[\"password\"])",
        "time.sleep(0.5)",
        "proc.exitstatus",
        "proc.exitstatus",
        "traceback.format_exc()",
        "log.error(error_msg.format(cmd, err, trace))",
        "proc.close(terminate=True, kill=True)"
      ],
      "mapped_sequence": [
        {
          "api_name": "salt.utils.vt.Terminal",
          "id": "spawn_process_shell",
          "description": "Spawns new process to execute command with shell access",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_reception"
        },
        {
          "api_name": "salt.utils.vt.Terminal.has_unread_data",
          "id": "read_process_stdout",
          "description": "Reads all bytes from process standard output",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "salt.utils.vt.Terminal.recv",
          "id": "read_process_stdout",
          "description": "Reads all bytes from process standard output",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "SSH_PASSWORD_PROMP_RE.search",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "SSH_PASSWORD_PROMP_SUDO_RE.search",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "salt.utils.vt.Terminal.sendline",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "salt.utils.vt.Terminal.sendline",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "time.sleep",
          "id": "suspend_execution",
          "description": "Suspends execution for specified seconds",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "salt.utils.vt.Terminal.exitstatus",
          "id": "wait_process_completion",
          "description": "Waits for process to complete execution",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "salt.utils.vt.Terminal.exitstatus",
          "id": "wait_process_completion",
          "description": "Waits for process to complete execution",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "traceback.format_exc",
          "id": "extract_call_stack",
          "description": "Extracts current call stack as FrameSummary objects",
          "first_id": "data_transformation_processing",
          "second_id": "collection_operations",
          "third_id": "iterator_operations"
        },
        {
          "api_name": "log.error",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "salt.utils.vt.Terminal.close",
          "id": "close_process",
          "description": "Closes the process (no direct category, closest match)",
          "first_id": "",
          "second_id": "",
          "third_id": ""
        }
      ],
      "contextual_code": "def _exec_ssh_cmd(cmd, error_msg=None, allow_failure=False, **kwargs):\n    if error_msg is None:\n        error_msg = \"A wrong password has been issued while establishing ssh session.\"\n    password_retries = kwargs.get(\"password_retries\", 3)\n    try:\n        stdout, stderr = None, None\n        proc = salt.utils.vt.Terminal(\n            cmd,\n            shell=True,\n            log_stdout=True,\n            log_stderr=True,\n            stream_stdout=kwargs.get(\"display_ssh_output\", True),\n            stream_stderr=kwargs.get(\"display_ssh_output\", True),\n        )\n        sent_password = 0\n        while proc.has_unread_data:\n            stdout, stderr = proc.recv()\n            if stdout and SSH_PASSWORD_PROMP_RE.search(stdout):\n                if (\n                    \"key_filename\" in kwargs\n                    and kwargs[\"key_filename\"]\n                    and SSH_PASSWORD_PROMP_SUDO_RE.search(stdout)\n                ):\n                    proc.sendline(kwargs[\"sudo_password\"])\n                elif kwargs.get(\"password\", None) and (\n                    sent_password < password_retries\n                ):\n                    sent_password += 1\n                    proc.sendline(kwargs[\"password\"])\n                else:\n                    raise SaltCloudPasswordError(error_msg)\n            time.sleep(0.5)\n        if proc.exitstatus != 0 and allow_failure is False:\n            raise SaltCloudSystemExit(\n                f\"Command '{cmd}' failed. Exit code: {proc.exitstatus}\"\n            )\n        return proc.exitstatus\n    except salt.utils.vt.TerminalException as err:\n        trace = traceback.format_exc()\n        log.error(error_msg.format(cmd, err, trace))\n    finally:\n        proc.close(terminate=True, kill=True)"
    }
  }
]