[
  {
    "metadata": {
      "package_name": "aws_sam_cli-1.137.0",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "container.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/aws_sam_cli-1.137.0/aws_sam_cli-1.137.0/samcli/local/docker/container.py",
    "line_number": "428",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "427\t        with CONCURRENT_CALL_MANAGER_LOCK:\n428\t            lock = CONCURRENT_CALL_MANAGER.get(lock_key)\n429\t            if not lock:",
    "code_snippet": "    @retry(exc=requests.exceptions.RequestException, exc_raise=ContainerResponseException)\n    def wait_for_http_response(self, name, event, stdout) -> Tuple[Union[str, bytes], bool]:\n        # TODO(sriram-mv): `aws-lambda-rie` is in a mode where the function_name is always \"function\"\n        # NOTE(sriram-mv): There is a connection timeout set on the http call to `aws-lambda-rie`, however there is not\n        # a read time out for the response received from the server.\n\n        # generate a lock key with host-port combination which is unique per function\n        lock_key = f\"{self._container_host}-{self.rapid_port_host}\"\n        LOG.debug(\"Getting lock for the key %s\", lock_key)\n        with CONCURRENT_CALL_MANAGER_LOCK:\n            lock = CONCURRENT_CALL_MANAGER.get(lock_key)\n            if not lock:\n                lock = threading.Lock()\n                CONCURRENT_CALL_MANAGER[lock_key] = lock\n        LOG.debug(\"Waiting to retrieve the lock (%s) to start invocation\", lock_key)\n        with lock:\n            resp = requests.post(\n                self.URL.format(host=self._container_host, port=self.rapid_port_host, function_name=\"function\"),\n                data=event.encode(\"utf-8\"),\n                timeout=(self.RAPID_CONNECTION_TIMEOUT, None),\n            )\n\n        try:\n            # if response is an image then json.loads/dumps will throw a UnicodeDecodeError so return raw content\n            if resp.headers.get(\"Content-Type\") and \"image\" in resp.headers[\"Content-Type\"]:\n                return resp.content, True\n            return json.dumps(json.loads(resp.content), ensure_ascii=False), False\n        except json.JSONDecodeError:\n            LOG.debug(\"Failed to deserialize response from RIE, returning the raw response as is\")\n            return resp.content, False",
    "pattern_analysis": {
      "api_sequence": [
        "requests.post",
        "event.encode",
        "resp.headers.get",
        "json.loads",
        "json.dumps"
      ],
      "api_sequence_with_args": [
        "requests.post(self.URL.format(host=self._container_host, port=self.rapid_port_host, function_name=\"function\"), data=event.encode(\"utf-8\"), timeout=(self.RAPID_CONNECTION_TIMEOUT, None))",
        "event.encode(\"utf-8\")",
        "resp.headers.get(\"Content-Type\")",
        "json.loads(resp.content)",
        "json.dumps(json.loads(resp.content), ensure_ascii=False)"
      ],
      "mapped_sequence": [
        {
          "api_name": "requests.post",
          "id": "send_http_post_timeout",
          "description": "Sends HTTP POST request with data and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "event.encode",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "resp.headers.get",
          "id": "get_response_body",
          "description": "Retrieves response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "json.dumps",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        }
      ],
      "contextual_code": "@retry(exc=requests.exceptions.RequestException, exc_raise=ContainerResponseException)\ndef wait_for_http_response(self, name, event, stdout) -> Tuple[Union[str, bytes], bool]:\n    lock_key = f\"{self._container_host}-{self.rapid_port_host}\"\n    with CONCURRENT_CALL_MANAGER_LOCK:\n        lock = CONCURRENT_CALL_MANAGER.get(lock_key)\n        if not lock:\n            lock = threading.Lock()\n            CONCURRENT_CALL_MANAGER[lock_key] = lock\n    with lock:\n        resp = requests.post(\n            self.URL.format(host=self._container_host, port=self.rapid_port_host, function_name=\"function\"),\n            data=event.encode(\"utf-8\"),\n            timeout=(self.RAPID_CONNECTION_TIMEOUT, None),\n        )\n    try:\n        if resp.headers.get(\"Content-Type\") and \"image\" in resp.headers[\"Content-Type\"]:\n            return resp.content, True\n        return json.dumps(json.loads(resp.content), ensure_ascii=False), False\n    except json.JSONDecodeError:\n        return resp.content, False"
    }
  }
]