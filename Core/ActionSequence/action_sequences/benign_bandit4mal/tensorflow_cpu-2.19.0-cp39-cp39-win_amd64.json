[
  {
    "metadata": {
      "package_name": "tensorflow_cpu-2.19.0-cp39-cp39-win_amd64",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "dumping_callback.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/tensorflow_cpu-2.19.0-cp39-cp39-win_amd64/tensorflow/python/debug/lib/dumping_callback.py",
    "line_number": "886",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "885\t    logging.info(\"Disabled dumping callback in thread %s (dump root: %s)\",\n886\t                 threading.current_thread().name, dump_root)",
    "code_snippet": "@tf_export(\"debugging.experimental.disable_dump_debug_info\")\ndef disable_dump_debug_info():\n  \"\"\"Disable the currently-enabled debugging dumping.\n\n  If the `enable_dump_debug_info()` method under the same Python namespace\n  has been invoked before, calling this method disables it. If no call to\n  `enable_dump_debug_info()` has been made, calling this method is a no-op.\n  Calling this method more than once is idempotent.\n  \"\"\"\n  if hasattr(_state, \"dumping_callback\"):\n    dump_root = _state.dumping_callback.dump_root\n    tfdbg_run_id = _state.dumping_callback.tfdbg_run_id\n    debug_events_writer.DebugEventsWriter(dump_root, tfdbg_run_id).Close()\n    op_callbacks.remove_op_callback(_state.dumping_callback.callback)\n    if (\n        _state.dumping_callback.function_callback\n        in function_lib.CONCRETE_FUNCTION_CALLBACKS\n    ):\n      function_lib.CONCRETE_FUNCTION_CALLBACKS.remove(\n          _state.dumping_callback.function_callback\n      )\n    delattr(_state, \"dumping_callback\")\n    logging.info(\"Disabled dumping callback in thread %s (dump root: %s)\",\n                 threading.current_thread().name, dump_root)\n",
    "pattern_analysis": {
      "api_sequence": [
        "hasattr",
        "debug_events_writer.DebugEventsWriter",
        "debug_events_writer.DebugEventsWriter.Close",
        "op_callbacks.remove_op_callback",
        "function_lib.CONCRETE_FUNCTION_CALLBACKS.remove",
        "delattr",
        "logging.info",
        "threading.current_thread",
        "threading.current_thread.name"
      ],
      "api_sequence_with_args": [
        "hasattr(_state, \"dumping_callback\")",
        "debug_events_writer.DebugEventsWriter(dump_root, tfdbg_run_id)",
        "debug_events_writer.DebugEventsWriter(dump_root, tfdbg_run_id).Close()",
        "op_callbacks.remove_op_callback(_state.dumping_callback.callback)",
        "function_lib.CONCRETE_FUNCTION_CALLBACKS.remove(_state.dumping_callback.function_callback)",
        "delattr(_state, \"dumping_callback\")",
        "logging.info(\"Disabled dumping callback in thread %s (dump root: %s)\", threading.current_thread().name, dump_root)",
        "threading.current_thread()",
        "threading.current_thread().name"
      ],
      "mapped_sequence": [
        {
          "api_name": "hasattr",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "debug_events_writer.DebugEventsWriter",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "debug_events_writer.DebugEventsWriter.Close",
          "id": "close_file",
          "description": "Closes the opened file",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_closing"
        },
        {
          "api_name": "op_callbacks.remove_op_callback",
          "id": "remove_keyboard_hooks",
          "description": "Removes all keyboard hooks",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "keyboard_monitoring"
        },
        {
          "api_name": "function_lib.CONCRETE_FUNCTION_CALLBACKS.remove",
          "id": "apply_lambda_pairs",
          "description": "Applies lambda to pairs from two lists",
          "first_id": "data_transformation_processing",
          "second_id": "function_application",
          "third_id": "lambda_application"
        },
        {
          "api_name": "delattr",
          "id": "set_builtin_attr",
          "description": "Sets attribute on builtins object",
          "first_id": "persistence_stealth",
          "second_id": "stealth_techniques",
          "third_id": "warning_disabling"
        },
        {
          "api_name": "logging.info",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "threading.current_thread",
          "id": "list_threads",
          "description": "Lists all currently alive threads",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "threading.current_thread.name",
          "id": "get_process_name",
          "description": "Retrieves process name as string",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        }
      ],
      "contextual_code": "def disable_dump_debug_info():\n  if hasattr(_state, \"dumping_callback\"):\n    dump_root = _state.dumping_callback.dump_root\n    tfdbg_run_id = _state.dumping_callback.tfdbg_run_id\n    debug_events_writer.DebugEventsWriter(dump_root, tfdbg_run_id).Close()\n    op_callbacks.remove_op_callback(_state.dumping_callback.callback)\n    if (\n        _state.dumping_callback.function_callback\n        in function_lib.CONCRETE_FUNCTION_CALLBACKS\n    ):\n      function_lib.CONCRETE_FUNCTION_CALLBACKS.remove(\n          _state.dumping_callback.function_callback\n      )\n    delattr(_state, \"dumping_callback\")\n    logging.info(\"Disabled dumping callback in thread %s (dump root: %s)\",\n                 threading.current_thread().name, dump_root)"
    }
  },
  {
    "pyfile": "resource_variable_ops.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/tensorflow_cpu-2.19.0-cp39-cp39-win_amd64/tensorflow/python/ops/resource_variable_ops.py",
    "line_number": "1489",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1488\t    \"\"\"\n1489\t    return self._lazy_read(\n1490\t        gen_state_ops.resource_scatter_nd_update(\n1491\t            self.handle,\n1492\t            indices,\n1493\t            ops.convert_to_tensor(updates, self.dtype),\n1494\t            name=name))\n1495",
    "code_snippet": "def scatter_nd_update(self, indices, updates, name=None):\n    \"\"\"Applies sparse assignment to individual values or slices in a Variable.\n\n    `ref` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.\n\n    `indices` must be integer tensor, containing indices into `ref`.\n    It must be shape `[d_0, ..., d_{Q-2}, K]` where `0 < K <= P`.\n\n    The innermost dimension of `indices` (with length `K`) corresponds to\n    indices into elements (if `K = P`) or slices (if `K < P`) along the `K`th\n    dimension of `ref`.\n\n    `updates` is `Tensor` of rank `Q-1+P-K` with shape:\n\n    ```\n    [d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].\n    ```\n\n    For example, say we want to add 4 scattered elements to a rank-1 tensor to\n    8 elements. In Python, that update would look like this:\n\n    ```python\n        ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])\n        indices = tf.constant([[4], [3], [1] ,[7]])\n        updates = tf.constant([9, 10, 11, 12])\n        op = ref.scatter_nd_update(indices, updates)\n        with tf.compat.v1.Session() as sess:\n          print sess.run(op)\n    ```\n\n    The resulting update to ref would look like this:\n\n        [1, 11, 3, 10, 9, 6, 7, 12]\n\n    See `tf.scatter_nd` for more details about how to make updates to\n    slices.\n\n    Args:\n      indices: The indices to be used in the operation.\n      updates: The values to be used in the operation.\n      name: the name of the operation.\n\n    Returns:\n      The updated variable.\n    \"\"\"\n    return self._lazy_read(\n        gen_state_ops.resource_scatter_nd_update(\n            self.handle,\n            indices,\n            ops.convert_to_tensor(updates, self.dtype),\n            name=name))",
    "pattern_analysis": {
      "api_sequence": [
        "gen_state_ops.resource_scatter_nd_update",
        "ops.convert_to_tensor",
        "self._lazy_read"
      ],
      "api_sequence_with_args": [
        "gen_state_ops.resource_scatter_nd_update(self.handle, indices, ops.convert_to_tensor(updates, self.dtype), name=name)",
        "ops.convert_to_tensor(updates, self.dtype)",
        "self._lazy_read(gen_state_ops.resource_scatter_nd_update(...))"
      ],
      "mapped_sequence": [
        {
          "api_name": "gen_state_ops.resource_scatter_nd_update",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "ops.convert_to_tensor",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "self._lazy_read",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        }
      ],
      "contextual_code": "def scatter_nd_update(self, indices, updates, name=None):\n    return self._lazy_read(\n        gen_state_ops.resource_scatter_nd_update(\n            self.handle,\n            indices,\n            ops.convert_to_tensor(updates, self.dtype),\n            name=name))"
    }
  }
]