[
  {
    "metadata": {
      "package_name": "ert-14.1.6-py3-none-any",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "everserver.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ert-14.1.6-py3-none-any/everest/detached/jobs/everserver.py",
    "line_number": "670",
    "type_description": "B802:b64encode",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "669\t    random_bytes = bytes(os.urandom(n_bytes))\n670\t    return b64encode(random_bytes).decode(\"utf-8\")",
    "code_snippet": "def _generate_authentication() -> str:\n    n_bytes = 128\n    random_bytes = bytes(os.urandom(n_bytes))\n    return b64encode(random_bytes).decode(\"utf-8\")",
    "pattern_analysis": {
      "api_sequence": [
        "os.urandom",
        "base64.b64encode",
        "bytes.decode"
      ],
      "api_sequence_with_args": [
        "os.urandom(n_bytes)",
        "base64.b64encode(random_bytes)",
        "bytes.decode(\"utf-8\")"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.urandom",
          "id": "generate_aes_cipher",
          "description": "Generates AES cipher object with provided key",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "encryption_object_creation"
        },
        {
          "api_name": "base64.b64encode",
          "id": "encode_bytes_to_base64",
          "description": "Encodes bytes to base64-encoded bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "bytes.decode",
          "id": "decode_bytes_codec",
          "description": "Decodes bytes using specified codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        }
      ],
      "contextual_code": "def _generate_authentication() -> str:\n    n_bytes = 128\n    random_bytes = bytes(os.urandom(n_bytes))\n    return b64encode(random_bytes).decode(\"utf-8\")"
    }
  },
  {
    "pyfile": "roff_io.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ert-14.1.6-py3-none-any/ert/field_utils/roff_io.py",
    "line_number": "48",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "47\t        warnings.filterwarnings(\"ignore\", r\"casting array\")\n48\t        roffio.write(filelike, file_contents, roff_format=roff_format)\n49",
    "code_snippet": "from collections import OrderedDict\nimport warnings\nimport numpy as np\nimport roffio  # type: ignore\n\nRMS_UNDEFINED_FLOAT = np.float32(-999.0)\n\ndef export_roff(\n    data: np.ma.MaskedArray[Any, np.dtype[np.float32]],\n    filelike: TextIO | BinaryIO | _PathLike,\n    parameter_name: str,\n    binary: bool,\n) -> None:\n    dimensions = data.shape\n    data = np.flip(data, -1).ravel()  # type: ignore\n    data = data.astype(np.float32).filled(RMS_UNDEFINED_FLOAT)  # type: ignore\n    if not np.isfinite(data).all():\n        raise ValueError(\n            f\"export of field {parameter_name!r} to {filelike}\"\n            \" contained infinity or nan values\"\n        )\n\n    file_contents = OrderedDict(\n        {\n            \"filedata\": {\"filetype\": \"parameter\"},\n            \"dimensions\": {\n                \"nX\": dimensions[0],\n                \"nY\": dimensions[1],\n                \"nZ\": dimensions[2],\n            },\n            \"parameter\": {\"name\": parameter_name, \"data\": data},\n        }\n    )\n    roff_format = roffio.Format.BINARY if binary else roffio.Format.ASCII\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", r\"casting array\")\n        roffio.write(filelike, file_contents, roff_format=roff_format)\n",
    "pattern_analysis": {
      "api_sequence": [
        "np.flip",
        "np.ravel",
        "np.astype",
        "np.ma.MaskedArray.filled",
        "np.isfinite",
        "warnings.catch_warnings",
        "warnings.filterwarnings",
        "roffio.write"
      ],
      "api_sequence_with_args": [
        "np.flip(data, -1)",
        "np.ravel(...)",
        "np.astype(np.float32)",
        "np.ma.MaskedArray.filled(RMS_UNDEFINED_FLOAT)",
        "np.isfinite(data)",
        "warnings.catch_warnings()",
        "warnings.filterwarnings(\"ignore\", r\"casting array\")",
        "roffio.write(filelike, file_contents, roff_format=roff_format)"
      ],
      "mapped_sequence": [
        {
          "api_name": "np.flip",
          "id": "apply_lambda_to_lists",
          "description": "Applies lambda function to elements of two lists",
          "first_id": "data_transformation_processing",
          "second_id": "function_application",
          "third_id": "lambda_application"
        },
        {
          "api_name": "np.ravel",
          "id": "apply_lambda_to_lists",
          "description": "Applies lambda function to elements of two lists",
          "first_id": "data_transformation_processing",
          "second_id": "function_application",
          "third_id": "lambda_application"
        },
        {
          "api_name": "np.astype",
          "id": "apply_lambda_to_lists",
          "description": "Applies lambda function to elements of two lists",
          "first_id": "data_transformation_processing",
          "second_id": "function_application",
          "third_id": "lambda_application"
        },
        {
          "api_name": "np.ma.MaskedArray.filled",
          "id": "apply_lambda_to_lists",
          "description": "Applies lambda function to elements of two lists",
          "first_id": "data_transformation_processing",
          "second_id": "function_application",
          "third_id": "lambda_application"
        },
        {
          "api_name": "np.isfinite",
          "id": "apply_lambda_to_lists",
          "description": "Applies lambda function to elements of two lists",
          "first_id": "data_transformation_processing",
          "second_id": "function_application",
          "third_id": "lambda_application"
        },
        {
          "api_name": "warnings.catch_warnings",
          "id": "error_handling_operations",
          "description": "File opening operations with error handling (ignore errors, custom error handling, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "warnings.filterwarnings",
          "id": "error_handling_operations",
          "description": "File opening operations with error handling (ignore errors, custom error handling, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "roffio.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        }
      ],
      "contextual_code": "def export_roff(\n    data: np.ma.MaskedArray[Any, np.dtype[np.float32]],\n    filelike: TextIO | BinaryIO | _PathLike,\n    parameter_name: str,\n    binary: bool,\n) -> None:\n    dimensions = data.shape\n    data = np.flip(data, -1).ravel()  # type: ignore\n    data = data.astype(np.float32).filled(RMS_UNDEFINED_FLOAT)  # type: ignore\n    if not np.isfinite(data).all():\n        raise ValueError(\n            f\"export of field {parameter_name!r} to {filelike}\"\n            \" contained infinity or nan values\"\n        )\n\n    file_contents = OrderedDict(\n        {\n            \"filedata\": {\"filetype\": \"parameter\"},\n            \"dimensions\": {\n                \"nX\": dimensions[0],\n                \"nY\": dimensions[1],\n                \"nZ\": dimensions[2],\n            },\n            \"parameter\": {\"name\": parameter_name, \"data\": data},\n        }\n    )\n    roff_format = roffio.Format.BINARY if binary else roffio.Format.ASCII\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", r\"casting array\")\n        roffio.write(filelike, file_contents, roff_format=roff_format)"
    }
  }
]