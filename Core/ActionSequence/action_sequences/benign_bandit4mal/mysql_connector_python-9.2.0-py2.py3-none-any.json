[
  {
    "metadata": {
      "package_name": "mysql_connector_python-9.2.0-py2.py3-none-any",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:40"
    }
  },
  {
    "pyfile": "connection.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/mysql_connector_python-9.2.0-py2.py3-none-any/mysql/connector/aio/connection.py",
    "line_number": "302",
    "type_description": "B829:getuser",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "301\t        ) and not self._user:\n302\t            self._user = getpass.getuser()\n303\t            logger.debug(",
    "code_snippet": "async def _do_auth(self) -> None:\n    \"\"\"Authenticate with the MySQL server.\n\n    Authentication happens in two parts. We first send a response to the\n    handshake. The MySQL server will then send either an AuthSwitchRequest\n    or an error packet.\n\n    Raises NotSupportedError when we get the old, insecure password\n    reply back. Raises any error coming from MySQL.\n    \"\"\"\n    if (  # pylint: disable=too-many-boolean-expressions\n        self._auth_plugin\n        and self._auth_plugin.startswith(\"authentication_oci\")\n        or (\n            self._auth_plugin\n            and self._auth_plugin.startswith(\"authentication_kerberos\")\n            and os.name == \"nt\"\n        )\n    ) and not self._user:\n        self._user = getpass.getuser()\n        logger.debug(\n            \"MySQL user is empty, OS user: %s will be used for %s\",\n            self._user,\n            self._auth_plugin,\n        )\n\n    password = (\n        self._password1\n        if self._password1 and self._password != self._password1\n        else self._password\n    )\n\n    self._ssl_active = False\n    if not self._ssl_disabled and (self._client_flags & ClientFlag.SSL):\n        ssl_context = self._socket.build_ssl_context(\n            ssl_ca=self._ssl_ca,\n            ssl_cert=self._ssl_cert,\n            ssl_key=self._ssl_key,\n            ssl_verify_cert=self._ssl_verify_cert,\n            ssl_verify_identity=self._ssl_verify_identity,\n            tls_versions=self._tls_versions,\n            tls_cipher_suites=self._tls_ciphersuites,\n        )\n        packet: bytes = self._protocol.make_auth_ssl(\n            charset=self._charset.charset_id, client_flags=self._client_flags\n        )\n        await self._socket.write(packet)\n        await self._socket.switch_to_ssl(ssl_context)\n        self._ssl_active = True\n\n    # Add the custom configurations required by specific auth plugins\n    self._authenticator.update_plugin_config(\n        config={\n            \"krb_service_principal\": self._krb_service_principal,\n            \"oci_config_file\": self._oci_config_file,\n            \"oci_config_profile\": self._oci_config_profile,\n            \"webauthn_callback\": self._webauthn_callback,\n            \"openid_token_file\": self._openid_token_file,\n        }\n    )\n\n    ok_pkt = await self._authenticator.authenticate(\n        sock=self._socket,\n        handshake=self._handshake,\n        username=self._user,\n        password1=password,\n        password2=self._password2,\n        password3=self._password3,\n        database=self._database,\n        charset=self._charset.charset_id,\n        client_flags=self._client_flags,\n        ssl_enabled=self._ssl_active,\n        auth_plugin=self._auth_plugin,\n        auth_plugin_class=self._auth_plugin_class,\n        conn_attrs=self._connection_attrs,\n    )\n    self._handle_ok(ok_pkt)\n\n    if not (self._client_flags & ClientFlag.CONNECT_WITH_DB) and self._database:\n        await self.cmd_init_db(self._database)\n",
    "pattern_analysis": {
      "api_sequence": [
        "os.name",
        "getpass.getuser",
        "logger.debug",
        "self._socket.build_ssl_context",
        "self._protocol.make_auth_ssl",
        "self._socket.write",
        "self._socket.switch_to_ssl",
        "self._authenticator.update_plugin_config",
        "self._authenticator.authenticate",
        "self._handle_ok",
        "self.cmd_init_db"
      ],
      "api_sequence_with_args": [
        "os.name",
        "getpass.getuser()",
        "logger.debug('MySQL user is empty, OS user: %s will be used for %s', self._user, self._auth_plugin)",
        "self._socket.build_ssl_context(ssl_ca=self._ssl_ca, ssl_cert=self._ssl_cert, ssl_key=self._ssl_key, ssl_verify_cert=self._ssl_verify_cert, ssl_verify_identity=self._ssl_verify_identity, tls_versions=self._tls_versions, tls_cipher_suites=self._tls_ciphersuites)",
        "self._protocol.make_auth_ssl(charset=self._charset.charset_id, client_flags=self._client_flags)",
        "self._socket.write(packet)",
        "self._socket.switch_to_ssl(ssl_context)",
        "self._authenticator.update_plugin_config(config={...})",
        "self._authenticator.authenticate(sock=self._socket, handshake=self._handshake, username=self._user, password1=password, password2=self._password2, password3=self._password3, database=self._database, charset=self._charset.charset_id, client_flags=self._client_flags, ssl_enabled=self._ssl_active, auth_plugin=self._auth_plugin, auth_plugin_class=self._auth_plugin_class, conn_attrs=self._connection_attrs)",
        "self._handle_ok(ok_pkt)",
        "self.cmd_init_db(self._database)"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.name",
          "id": "get_os_id",
          "description": "Retrieves operating system identifier",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "getpass.getuser",
          "id": "get_username",
          "description": "Retrieves current user's login name",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "logger.debug",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "self._socket.build_ssl_context",
          "id": "create_ssl_context",
          "description": "Creates SSL context with specified protocol",
          "first_id": "persistence_stealth",
          "second_id": "stealth_techniques",
          "third_id": "warning_disabling"
        },
        {
          "api_name": "self._protocol.make_auth_ssl",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "self._socket.write",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "self._socket.switch_to_ssl",
          "id": "wrap_socket_ssl",
          "description": "Wraps socket for SSL/TLS communication",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "self._authenticator.update_plugin_config",
          "id": "set_builtin_attr",
          "description": "Sets attribute on builtins object",
          "first_id": "persistence_stealth",
          "second_id": "stealth_techniques",
          "third_id": "warning_disabling"
        },
        {
          "api_name": "self._authenticator.authenticate",
          "id": "create_http_connection",
          "description": "Creates HTTP connection to specified host",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "self._handle_ok",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "self.cmd_init_db",
          "id": "open_sqlite_db",
          "description": "Opens SQLite database file",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        }
      ],
      "contextual_code": "if (\n    self._auth_plugin and self._auth_plugin.startswith(\"authentication_oci\")\n    or (\n        self._auth_plugin and self._auth_plugin.startswith(\"authentication_kerberos\")\n        and os.name == \"nt\"\n    )\n) and not self._user:\n    self._user = getpass.getuser()\n    logger.debug(\n        \"MySQL user is empty, OS user: %s will be used for %s\",\n        self._user,\n        self._auth_plugin,\n    )\n\nif not self._ssl_disabled and (self._client_flags & ClientFlag.SSL):\n    ssl_context = self._socket.build_ssl_context(\n        ssl_ca=self._ssl_ca,\n        ssl_cert=self._ssl_cert,\n        ssl_key=self._ssl_key,\n        ssl_verify_cert=self._ssl_verify_cert,\n        ssl_verify_identity=self._ssl_verify_identity,\n        tls_versions=self._tls_versions,\n        tls_cipher_suites=self._tls_ciphersuites,\n    )\n    packet: bytes = self._protocol.make_auth_ssl(\n        charset=self._charset.charset_id, client_flags=self._client_flags\n    )\n    await self._socket.write(packet)\n    await self._socket.switch_to_ssl(ssl_context)\n    self._ssl_active = True\n\nself._authenticator.update_plugin_config(\n    config={\n        \"krb_service_principal\": self._krb_service_principal,\n        \"oci_config_file\": self._oci_config_file,\n        \"oci_config_profile\": self._oci_config_profile,\n        \"webauthn_callback\": self._webauthn_callback,\n        \"openid_token_file\": self._openid_token_file,\n    }\n)\n\nok_pkt = await self._authenticator.authenticate(\n    sock=self._socket,\n    handshake=self._handshake,\n    username=self._user,\n    password1=password,\n    password2=self._password2,\n    password3=self._password3,\n    database=self._database,\n    charset=self._charset.charset_id,\n    client_flags=self._client_flags,\n    ssl_enabled=self._ssl_active,\n    auth_plugin=self._auth_plugin,\n    auth_plugin_class=self._auth_plugin_class,\n    conn_attrs=self._connection_attrs,\n)\nself._handle_ok(ok_pkt)\n\nif not (self._client_flags & ClientFlag.CONNECT_WITH_DB) and self._database:\n    await self.cmd_init_db(self._database)"
    }
  }
]