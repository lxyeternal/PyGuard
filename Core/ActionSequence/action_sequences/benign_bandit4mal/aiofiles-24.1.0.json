[
  {
    "metadata": {
      "package_name": "aiofiles-24.1.0",
      "total_matches": 3,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "test_text.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/aiofiles-24.1.0/aiofiles-24.1.0/tests/threadpool/test_text.py",
    "line_number": "120",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "119\t        while True:\n120\t            char = await file.read(1)\n121\t            if char:",
    "code_snippet": "@pytest.mark.parametrize(\"mode\", [\"r\", \"r+\", \"a+\"])\nasync def test_staggered_read(mode):\n    \"\"\"Read bytes repeatedly.\"\"\"\n    filename = join(dirname(__file__), \"..\", \"resources\", \"test_file1.txt\")\n    async with aioopen(filename, mode=mode) as file:\n        await file.seek(0)  # Needed for the append mode.\n\n        actual = []\n        while True:\n            char = await file.read(1)\n            if char:\n                actual.append(char)\n            else:\n                break\n\n        assert \"\" == (await file.read())\n\n    expected = []\n    with open(filename, mode=\"r\") as f:\n        while True:\n            char = f.read(1)\n            if char:\n                expected.append(char)\n            else:\n                break\n\n    assert actual == expected\n\n    assert file.closed",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.dirname",
        "os.path.join",
        "aioopen",
        "aioopen.seek",
        "aioopen.read",
        "aioopen.read",
        "open",
        "open.read",
        "open.read"
      ],
      "api_sequence_with_args": [
        "os.path.dirname(__file__)",
        "os.path.join(os.path.dirname(__file__), \"..\", \"resources\", \"test_file1.txt\")",
        "aioopen(filename, mode=mode)",
        "aioopen.seek(0)",
        "aioopen.read(1)",
        "aioopen.read()",
        "open(filename, mode=\"r\")",
        "open.read(1)",
        "open.read()"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.dirname",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "aioopen",
          "id": "combined_mode_operations",
          "description": "Combined mode file opening operations (read-write mode, append mode, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "aioopen.seek",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "aioopen.read",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "aioopen.read",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open.read",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "open.read",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        }
      ],
      "contextual_code": "@pytest.mark.parametrize(\"mode\", [\"r\", \"r+\", \"a+\"])\nasync def test_staggered_read(mode):\n    filename = os.path.join(os.path.dirname(__file__), \"..\", \"resources\", \"test_file1.txt\")\n    async with aioopen(filename, mode=mode) as file:\n        await file.seek(0)  # Needed for the append mode.\n\n        actual = []\n        while True:\n            char = await file.read(1)\n            if char:\n                actual.append(char)\n            else:\n                break\n\n        assert \"\" == (await file.read())\n\n    expected = []\n    with open(filename, mode=\"r\") as f:\n        while True:\n            char = f.read(1)\n            if char:\n                expected.append(char)\n            else:\n                break\n\n    assert actual == expected\n    assert file.closed"
    }
  },
  {
    "pyfile": "test_os.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/aiofiles-24.1.0/aiofiles-24.1.0/tests/test_os.py",
    "line_number": "146",
    "type_description": "B812:system",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "145\t@pytest.mark.skipif(\n146\t    platform.system() in (\"Windows\"), reason=\"sendfile() doesn't work on Win\"\n147\t)",
    "code_snippet": "@pytest.mark.skipif(\n    platform.system() in (\"Windows\"), reason=\"sendfile() doesn't work on Win\"\n)\nasync def test_sendfile_socket(unused_tcp_port):\n    \"\"\"Test the sendfile functionality, file-to-socket.\"\"\"\n    filename = join(dirname(__file__), \"resources\", \"test_file1.txt\")\n\n    with open(filename, mode=\"rb\") as f:\n        contents = f.read()\n\n    async def serve_file(_, writer):\n        out_fd = writer.transport.get_extra_info(\"socket\").fileno()\n        size = (await aiofiles.os.stat(filename)).st_size\n        in_file = await aiofiles.open(filename)\n        try:\n            in_fd = in_file.fileno()\n            await aiofiles.os.sendfile(out_fd, in_fd, 0, size)\n        finally:\n            await in_file.close()\n            await writer.drain()\n            writer.close()\n\n    server = await asyncio.start_server(serve_file, port=unused_tcp_port)\n\n    reader, writer = await asyncio.open_connection(\"127.0.0.1\", unused_tcp_port)\n    actual_contents = await reader.read()\n    writer.close()\n\n    assert contents == actual_contents\n    server.close()\n\n    await server.wait_closed()",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.dirname",
        "os.path.join",
        "open",
        "io.BufferedReader.read",
        "aiofiles.os.stat",
        "aiofiles.open",
        "aiofiles.threadpool.binary.AsyncBufferedIOBase.fileno",
        "aiofiles.os.sendfile",
        "aiofiles.threadpool.binary.AsyncBufferedIOBase.close",
        "asyncio.StreamWriter.drain",
        "asyncio.StreamWriter.close",
        "asyncio.start_server",
        "asyncio.open_connection",
        "asyncio.StreamReader.read",
        "asyncio.StreamWriter.close",
        "asyncio.Server.close",
        "asyncio.Server.wait_closed"
      ],
      "api_sequence_with_args": [
        "os.path.dirname(__file__)",
        "os.path.join(os.path.dirname(__file__), \"resources\", \"test_file1.txt\")",
        "open(filename, mode=\"rb\")",
        "f.read()",
        "aiofiles.os.stat(filename)",
        "aiofiles.open(filename)",
        "in_file.fileno()",
        "aiofiles.os.sendfile(out_fd, in_fd, 0, size)",
        "in_file.close()",
        "writer.drain()",
        "writer.close()",
        "asyncio.start_server(serve_file, port=unused_tcp_port)",
        "asyncio.open_connection(\"127.0.0.1\", unused_tcp_port)",
        "reader.read()",
        "writer.close()",
        "server.close()",
        "server.wait_closed()"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.dirname",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "io.BufferedReader.read",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "aiofiles.os.stat",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "aiofiles.open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "aiofiles.threadpool.binary.AsyncBufferedIOBase.fileno",
          "id": "get_socket_fd",
          "description": "Retrieves file descriptor for socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "aiofiles.os.sendfile",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "aiofiles.threadpool.binary.AsyncBufferedIOBase.close",
          "id": "close_file",
          "description": "Closes the opened file",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_closing"
        },
        {
          "api_name": "asyncio.StreamWriter.drain",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "asyncio.StreamWriter.close",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "asyncio.start_server",
          "id": "create_socket",
          "description": "Creates new socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_creation"
        },
        {
          "api_name": "asyncio.open_connection",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "asyncio.StreamReader.read",
          "id": "receive_socket_data",
          "description": "Receives data from socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "asyncio.StreamWriter.close",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "asyncio.Server.close",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "asyncio.Server.wait_closed",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        }
      ],
      "contextual_code": "@pytest.mark.skipif(\n    platform.system() in (\"Windows\"), reason=\"sendfile() doesn't work on Win\"\n)\nasync def test_sendfile_socket(unused_tcp_port):\n    filename = os.path.join(os.path.dirname(__file__), \"resources\", \"test_file1.txt\")\n\n    with open(filename, mode=\"rb\") as f:\n        contents = f.read()\n\n    async def serve_file(_, writer):\n        out_fd = writer.transport.get_extra_info(\"socket\").fileno()\n        size = (await aiofiles.os.stat(filename)).st_size\n        in_file = await aiofiles.open(filename)\n        try:\n            in_fd = in_file.fileno()\n            await aiofiles.os.sendfile(out_fd, in_fd, 0, size)\n        finally:\n            await in_file.close()\n            await writer.drain()\n            writer.close()\n\n    server = await asyncio.start_server(serve_file, port=unused_tcp_port)\n\n    reader, writer = await asyncio.open_connection(\"127.0.0.1\", unused_tcp_port)\n    actual_contents = await reader.read()\n    writer.close()\n\n    assert contents == actual_contents\n    server.close()\n\n    await server.wait_closed()"
    }
  },
  {
    "pyfile": "test_os.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/aiofiles-24.1.0/aiofiles-24.1.0/tests/test_os.py",
    "line_number": "417",
    "type_description": "B837:rmdir",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "416\t    assert other_dir_entity.name == \"other_dir\"\n417\t    await aiofiles.os.rmdir(other_dir)\n418\t    await aiofiles.os.rmdir(some_dir)",
    "code_snippet": "async def test_scandir_dir_with_only_one_dir():\n    \"\"\"Test the scandir call when the dir has one dir.\"\"\"\n    some_dir = join(dirname(__file__), \"resources\", \"some_dir\")\n    other_dir = join(some_dir, \"other_dir\")\n    await aiofiles.os.mkdir(some_dir)\n    await aiofiles.os.mkdir(other_dir)\n    dir_iterator = await aiofiles.os.scandir(some_dir)\n    other_dir_entity = next(dir_iterator)\n    assert other_dir_entity.name == \"other_dir\"\n    await aiofiles.os.rmdir(other_dir)\n    await aiofiles.os.rmdir(some_dir)",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.join",
        "os.path.dirname",
        "os.path.join",
        "aiofiles.os.mkdir",
        "aiofiles.os.mkdir",
        "aiofiles.os.scandir",
        "aiofiles.os.rmdir",
        "aiofiles.os.rmdir"
      ],
      "api_sequence_with_args": [
        "os.path.join(os.path.dirname(__file__), \"resources\", \"some_dir\")",
        "os.path.dirname(__file__)",
        "os.path.join(some_dir, \"other_dir\")",
        "aiofiles.os.mkdir(some_dir)",
        "aiofiles.os.mkdir(other_dir)",
        "aiofiles.os.scandir(some_dir)",
        "aiofiles.os.rmdir(other_dir)",
        "aiofiles.os.rmdir(some_dir)"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.dirname",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "aiofiles.os.mkdir",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "aiofiles.os.mkdir",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "aiofiles.os.scandir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "aiofiles.os.rmdir",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "aiofiles.os.rmdir",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        }
      ],
      "contextual_code": "async def test_scandir_dir_with_only_one_dir():\n    some_dir = os.path.join(os.path.dirname(__file__), \"resources\", \"some_dir\")\n    other_dir = os.path.join(some_dir, \"other_dir\")\n    await aiofiles.os.mkdir(some_dir)\n    await aiofiles.os.mkdir(other_dir)\n    dir_iterator = await aiofiles.os.scandir(some_dir)\n    other_dir_entity = next(dir_iterator)\n    assert other_dir_entity.name == \"other_dir\"\n    await aiofiles.os.rmdir(other_dir)\n    await aiofiles.os.rmdir(some_dir)"
    }
  }
]