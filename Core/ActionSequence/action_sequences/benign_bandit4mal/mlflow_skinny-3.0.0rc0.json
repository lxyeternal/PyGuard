[
  {
    "metadata": {
      "package_name": "mlflow_skinny-3.0.0rc0",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:40"
    }
  },
  {
    "pyfile": "file_utils.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/mlflow_skinny-3.0.0rc0/mlflow_skinny-3.0.0rc0/mlflow/utils/file_utils.py",
    "line_number": "505",
    "type_description": "B834:open",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "504\tdef append_to(filename, data):\n505\t    with open(filename, \"a\") as handle:\n506\t        handle.write(data)",
    "code_snippet": "def append_to(filename, data):\n    with open(filename, \"a\") as handle:\n        handle.write(data)",
    "pattern_analysis": {
      "api_sequence": [
        "open",
        "handle.write"
      ],
      "api_sequence_with_args": [
        "open(filename, \"a\")",
        "handle.write(data)"
      ],
      "mapped_sequence": [
        {
          "api_name": "open",
          "id": "combined_mode_operations",
          "description": "Combined mode file opening operations (read-write mode, append mode, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "handle.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        }
      ],
      "contextual_code": "def append_to(filename, data):\n    with open(filename, \"a\") as handle:\n        handle.write(data)"
    }
  },
  {
    "pyfile": "__init__.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/mlflow_skinny-3.0.0rc0/mlflow_skinny-3.0.0rc0/mlflow/pyspark/ml/__init__.py",
    "line_number": "88",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "87\t        )\n88\t        response = http_request(host_creds=host_creds, endpoint=path, method=\"GET\")\n89\t        augmented_raise_for_status(response)",
    "code_snippet": "def _read_log_model_allowlist_from_file(allowlist_file):\n    def _parse_allowlist_file(line_iter):\n        allowlist = set()\n        for line in line_iter:\n            stripped = line.strip()\n            is_blankline_or_comment = stripped == \"\" or stripped.startswith(\"#\")\n            if not is_blankline_or_comment:\n                allowlist.add(stripped)\n        return allowlist\n\n    url_parsed = urlparse(allowlist_file)\n    scheme = url_parsed.scheme\n    path = url_parsed.path\n    if is_windows() and not url_parsed.hostname:\n        path = scheme + \"://\" + path\n        scheme = \"\"\n    if scheme in (\"file\", \"\"):\n        if not os.path.exists(path):\n            raise MlflowException.invalid_parameter_value(f\"{allowlist_file} does not exist\")\n\n        with open(allowlist_file) as f:\n            return _parse_allowlist_file(f)\n    else:\n        host_creds = MlflowHostCreds(\n            host=scheme + \"://\" + (url_parsed.hostname or \"\"),\n            username=url_parsed.username,\n            password=url_parsed.password,\n        )\n        response = http_request(host_creds=host_creds, endpoint=path, method=\"GET\")\n        augmented_raise_for_status(response)\n        return _parse_allowlist_file(response.iter_lines(decode_unicode=True))",
    "pattern_analysis": {
      "api_sequence": [
        "urlparse",
        "is_windows",
        "os.path.exists",
        "open",
        "_parse_allowlist_file",
        "MlflowHostCreds",
        "http_request",
        "augmented_raise_for_status",
        "response.iter_lines",
        "_parse_allowlist_file"
      ],
      "api_sequence_with_args": [
        "urlparse(allowlist_file)",
        "is_windows()",
        "os.path.exists(path)",
        "open(allowlist_file)",
        "_parse_allowlist_file(f)",
        "MlflowHostCreds(host=scheme + '://' + (url_parsed.hostname or ''), username=url_parsed.username, password=url_parsed.password)",
        "http_request(host_creds=host_creds, endpoint=path, method='GET')",
        "augmented_raise_for_status(response)",
        "response.iter_lines(decode_unicode=True)",
        "_parse_allowlist_file(response.iter_lines(decode_unicode=True))"
      ],
      "mapped_sequence": [
        {
          "api_name": "urlparse",
          "id": "encode_url_query",
          "description": "Encodes mapping object to URL query string",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "is_windows",
          "id": "get_os_id",
          "description": "Retrieves operating system identifier",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "_parse_allowlist_file",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "MlflowHostCreds",
          "id": "init_config_class",
          "description": "Initializes Config class with provided arguments",
          "first_id": "code_execution",
          "second_id": "object_initialization",
          "third_id": "class_initialization"
        },
        {
          "api_name": "http_request",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "augmented_raise_for_status",
          "id": "raise_http_error",
          "description": "Raises HTTPError if response status code indicates error",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "response.iter_lines",
          "id": "read_response_body",
          "description": "Reads response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "_parse_allowlist_file",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        }
      ],
      "contextual_code": "def _read_log_model_allowlist_from_file(allowlist_file):\n    def _parse_allowlist_file(line_iter):\n        allowlist = set()\n        for line in line_iter:\n            stripped = line.strip()\n            is_blankline_or_comment = stripped == \"\" or stripped.startswith(\"#\")\n            if not is_blankline_or_comment:\n                allowlist.add(stripped)\n        return allowlist\n\n    url_parsed = urlparse(allowlist_file)\n    scheme = url_parsed.scheme\n    path = url_parsed.path\n    if is_windows() and not url_parsed.hostname:\n        path = scheme + \"://\" + path\n        scheme = \"\"\n    if scheme in (\"file\", \"\"):\n        if not os.path.exists(path):\n            raise MlflowException.invalid_parameter_value(f\"{allowlist_file} does not exist\")\n\n        with open(allowlist_file) as f:\n            return _parse_allowlist_file(f)\n    else:\n        host_creds = MlflowHostCreds(\n            host=scheme + \"://\" + (url_parsed.hostname or \"\"),\n            username=url_parsed.username,\n            password=url_parsed.password,\n        )\n        response = http_request(host_creds=host_creds, endpoint=path, method=\"GET\")\n        augmented_raise_for_status(response)\n        return _parse_allowlist_file(response.iter_lines(decode_unicode=True))"
    }
  }
]