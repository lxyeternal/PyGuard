[
  {
    "metadata": {
      "package_name": "pex-2.33.7",
      "total_matches": 3,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "easy_install.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pex-2.33.7/pex-2.33.7/pex/vendor/_vendored/setuptools/setuptools/command/easy_install.py",
    "line_number": "1389",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1388\t            with io.open(sitepy) as strm:\n1389\t                current = strm.read()\n1390",
    "code_snippet": "def install_site_py(self):\n    \"\"\"Make sure there's a site.py in the target dir, if needed\"\"\"\n\n    if self.sitepy_installed:\n        return  # already did it, or don't need to\n\n    sitepy = os.path.join(self.install_dir, \"site.py\")\n    source = resource_string(\"setuptools\", \"site-patch.py\")\n    source = source.decode('utf-8')\n    current = \"\"\n\n    if os.path.exists(sitepy):\n        log.debug(\"Checking existing site.py in %s\", self.install_dir)\n        with io.open(sitepy) as strm:\n            current = strm.read()\n\n        if not current.startswith('def __boot():'):\n            raise DistutilsError(\n                \"%s is not a setuptools-generated site.py; please\"\n                \" remove it.\" % sitepy\n            )\n\n    if current != source:\n        log.info(\"Creating %s\", sitepy)\n        if not self.dry_run:\n            ensure_directory(sitepy)\n            with io.open(sitepy, 'w', encoding='utf-8') as strm:\n                strm.write(source)\n        self.byte_compile([sitepy])\n\n    self.sitepy_installed = True",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.join",
        "resource_string",
        "os.path.exists",
        "io.open",
        "io.open.read",
        "log.debug",
        "log.info",
        "ensure_directory",
        "io.open",
        "io.open.write",
        "self.byte_compile"
      ],
      "api_sequence_with_args": [
        "os.path.join(self.install_dir, \"site.py\")",
        "resource_string(\"setuptools\", \"site-patch.py\")",
        "os.path.exists(sitepy)",
        "io.open(sitepy)",
        "strm.read()",
        "log.debug(\"Checking existing site.py in %s\", self.install_dir)",
        "log.info(\"Creating %s\", sitepy)",
        "ensure_directory(sitepy)",
        "io.open(sitepy, 'w', encoding='utf-8')",
        "strm.write(source)",
        "self.byte_compile([sitepy])"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "resource_string",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "io.open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "io.open.read",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "log.debug",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "log.info",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "ensure_directory",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "io.open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "io.open.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "self.byte_compile",
          "id": "compile_code_object",
          "description": "Compiles source code string into executable code object",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        }
      ],
      "contextual_code": "def install_site_py(self):\n    if self.sitepy_installed:\n        return\n\n    sitepy = os.path.join(self.install_dir, \"site.py\")\n    source = resource_string(\"setuptools\", \"site-patch.py\")\n    source = source.decode('utf-8')\n    current = \"\"\n\n    if os.path.exists(sitepy):\n        log.debug(\"Checking existing site.py in %s\", self.install_dir)\n        with io.open(sitepy) as strm:\n            current = strm.read()\n        if not current.startswith('def __boot():'):\n            raise DistutilsError(\n                \"%s is not a setuptools-generated site.py; please\"\n                \" remove it.\" % sitepy\n            )\n\n    if current != source:\n        log.info(\"Creating %s\", sitepy)\n        if not self.dry_run:\n            ensure_directory(sitepy)\n            with io.open(sitepy, 'w', encoding='utf-8') as strm:\n                strm.write(source)\n        self.byte_compile([sitepy])"
    }
  },
  {
    "pyfile": "test_pex_builder.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pex-2.33.7/pex-2.33.7/tests/test_pex_builder.py",
    "line_number": "65",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "64\t        with open(success_txt) as fp:\n65\t            assert fp.read() == \"success\"\n66",
    "code_snippet": "def test_pex_builder():\n    # type: () -> None\n    with temporary_dir() as td, make_bdist(\"p1\") as p1:\n        pb = write_pex(td, exe_main, dists=[p1])\n\n        success_txt = os.path.join(td, \"success.txt\")\n        PEX(td, interpreter=pb.interpreter).run(args=[success_txt])\n        assert os.path.exists(success_txt)\n        with open(success_txt) as fp:\n            assert fp.read() == \"success\"",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.join",
        "PEX.run",
        "os.path.exists",
        "open",
        "fp.read"
      ],
      "api_sequence_with_args": [
        "os.path.join(td, \"success.txt\")",
        "PEX(td, interpreter=pb.interpreter).run(args=[success_txt])",
        "os.path.exists(success_txt)",
        "open(success_txt)",
        "fp.read()"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "PEX.run",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "fp.read",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        }
      ],
      "contextual_code": "def test_pex_builder():\n    with temporary_dir() as td, make_bdist(\"p1\") as p1:\n        pb = write_pex(td, exe_main, dists=[p1])\n\n        success_txt = os.path.join(td, \"success.txt\")\n        PEX(td, interpreter=pb.interpreter).run(args=[success_txt])\n        assert os.path.exists(success_txt)\n        with open(success_txt) as fp:\n            assert fp.read() == \"success\""
    }
  },
  {
    "pyfile": "command.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pex-2.33.7/pex-2.33.7/pex/commands/command.py",
    "line_number": "390",
    "type_description": "B832:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "389\t            with ENV.patch(PEX_ROOT=pex_root, TMPDIR=tmpdir) as env, environment_as(**env):\n390\t                cache_access.read_write()\n391\t                yield env",
    "code_snippet": "@contextmanager\ndef global_environment(options):\n    # type: (Namespace) -> Iterator[Dict[str, str]]\n    \"\"\"Configures the Pex global environment.\n\n    This includes configuration of basic Pex infrastructure like logging, warnings and the\n    `PEX_ROOT` to use.\n\n    :param options: The global options registered by `register_global_arguments`.\n    :yields: The configured global environment.\n    :raises: :class:`GlobalConfigurationError` if invalid global option values were specified.\n    \"\"\"\n    if not hasattr(options, \"rc_file\"):\n        # We don't register the global args on the root command (but do on every subcommand).\n        # So if the user runs just `pex` with no subcommand we must not attempt to use those\n        # global args, including rc_file, which we check for here as a representative of the\n        # global args.\n        # Note that we can't use command_type here because the legacy command line parser in\n        # pex/bin/pex.py uses this function as well, and it doesn't set command_type.\n        with ENV.patch() as env:\n            yield env\n    with _configured_env(options):\n        verbosity = Variables.PEX_VERBOSE.strip_default(ENV)\n        if verbosity is None:\n            verbosity = getattr(options, \"verbosity\", 0)\n\n        emit_warnings = True\n        if not options.emit_warnings:\n            emit_warnings = False\n        if emit_warnings and ENV.PEX_EMIT_WARNINGS is not None:\n            emit_warnings = ENV.PEX_EMIT_WARNINGS\n\n        with ENV.patch(PEX_VERBOSE=str(verbosity), PEX_EMIT_WARNINGS=str(emit_warnings)):\n            pex_warnings.configure_warnings(env=ENV)\n\n            # Ensure the TMPDIR is an absolute path (So subprocesses that change CWD can find it)\n            # and that it exists.\n            tmpdir = os.path.realpath(options.tmpdir)\n            if not os.path.exists(tmpdir):\n                raise GlobalConfigurationError(\n                    \"The specified --tmpdir does not exist: {}\".format(tmpdir)\n                )\n            if not os.path.isdir(tmpdir):\n                raise GlobalConfigurationError(\n                    \"The specified --tmpdir is not a directory: {}\".format(tmpdir)\n                )\n            tempfile.tempdir = os.environ[\"TMPDIR\"] = tmpdir\n\n            if options.cache_dir:\n                pex_warnings.warn(\"The --cache-dir option is deprecated, use --pex-root instead.\")\n                if options.pex_root and options.cache_dir != options.pex_root:\n                    raise GlobalConfigurationError(\n                        \"Both --cache-dir and --pex-root were passed with conflicting values. \"\n                        \"Just set --pex-root.\"\n                    )\n\n            if options.disable_cache:\n\n                def warn_ignore_pex_root(set_via):\n                    pex_warnings.warn(\n                        \"The pex root has been set via {via} but --disable-cache is also set. \"\n                        \"Ignoring {via} and disabling caches.\".format(via=set_via)\n                    )\n\n                if options.cache_dir:\n                    warn_ignore_pex_root(\"--cache-dir\")\n                elif options.pex_root:\n                    warn_ignore_pex_root(\"--pex-root\")\n                elif os.environ.get(\"PEX_ROOT\"):\n                    warn_ignore_pex_root(\"PEX_ROOT\")\n\n                pex_root = safe_mkdtemp()\n            else:\n                pex_root = options.cache_dir or options.pex_root or ENV.PEX_ROOT\n\n            with ENV.patch(PEX_ROOT=pex_root, TMPDIR=tmpdir) as env, environment_as(**env):\n                cache_access.read_write()\n                yield env",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.realpath",
        "os.path.exists",
        "os.path.isdir",
        "os.environ",
        "os.environ.get",
        "tempfile.tempdir",
        "safe_mkdtemp"
      ],
      "api_sequence_with_args": [
        "os.path.realpath(options.tmpdir)",
        "os.path.exists(tmpdir)",
        "os.path.isdir(tmpdir)",
        "os.environ[\"TMPDIR\"] = tmpdir",
        "os.environ.get(\"PEX_ROOT\")",
        "tempfile.tempdir = tmpdir",
        "safe_mkdtemp()"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.realpath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.path.isdir",
          "id": "check_directory_exists",
          "description": "Checks if specified path exists and is a directory",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.environ",
          "id": "get_env_vars",
          "description": "Retrieves environment variables mapping",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.environ.get",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "tempfile.tempdir",
          "id": "create_temp_dir",
          "description": "Creates temporary directory and returns its path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "safe_mkdtemp",
          "id": "create_temp_dir",
          "description": "Creates temporary directory and returns its path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        }
      ],
      "contextual_code": "    tmpdir = os.path.realpath(options.tmpdir)\n    if not os.path.exists(tmpdir):\n        raise GlobalConfigurationError(\n            \"The specified --tmpdir does not exist: {}\".format(tmpdir)\n        )\n    if not os.path.isdir(tmpdir):\n        raise GlobalConfigurationError(\n            \"The specified --tmpdir is not a directory: {}\".format(tmpdir)\n        )\n    tempfile.tempdir = os.environ[\"TMPDIR\"] = tmpdir\n    ...\n    elif os.environ.get(\"PEX_ROOT\"):\n        warn_ignore_pex_root(\"PEX_ROOT\")\n    ...\n    pex_root = safe_mkdtemp()"
    }
  }
]