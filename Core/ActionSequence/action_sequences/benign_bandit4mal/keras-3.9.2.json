[
  {
    "metadata": {
      "package_name": "keras-3.9.2",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "remote_monitor.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/keras-3.9.2/keras-3.9.2/keras/src/callbacks/remote_monitor.py",
    "line_number": "74",
    "type_description": "B821:post",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "73\t            else:\n74\t                requests.post(\n75\t                    self.root + self.path,\n76\t                    {self.field: json.dumps(send)},\n77\t                    headers=self.headers,\n78\t                )",
    "code_snippet": "import json\nimport warnings\n\nimport numpy as np\n\nfrom keras.src.api_export import keras_export\nfrom keras.src.callbacks.callback import Callback\n\ntry:\n    import requests\nexcept ImportError:\n    requests = None\n\n\n@keras_export(\"keras.callbacks.RemoteMonitor\")\nclass RemoteMonitor(Callback):\n    \"\"\"Callback used to stream events to a server.\n\n    Requires the `requests` library.\n    Events are sent to `root + '/publish/epoch/end/'` by default. Calls are\n    HTTP POST, with a `data` argument which is a\n    JSON-encoded dictionary of event data.\n    If `send_as_json=True`, the content type of the request will be\n    `\"application/json\"`.\n    Otherwise the serialized JSON will be sent within a form.\n\n    Args:\n        root: String; root url of the target server.\n        path: String; path relative to `root` to which the events will be sent.\n        field: String; JSON field under which the data will be stored.\n            The field is used only if the payload is sent within a form\n            (i.e. when `send_as_json=False`).\n        headers: Dictionary; optional custom HTTP headers.\n        send_as_json: Boolean; whether the request should be\n            sent as `\"application/json\"`.\n    \"\"\"\n\n    def __init__(\n        self,\n        root=\"http://localhost:9000\",\n        path=\"/publish/epoch/end/\",\n        field=\"data\",\n        headers=None,\n        send_as_json=False,\n    ):\n        super().__init__()\n\n        self.root = root\n        self.path = path\n        self.field = field\n        self.headers = headers\n        self.send_as_json = send_as_json\n\n    def on_epoch_end(self, epoch, logs=None):\n        if requests is None:\n            raise ImportError(\"RemoteMonitor requires the `requests` library.\")\n        logs = logs or {}\n        send = {}\n        send[\"epoch\"] = epoch\n        for k, v in logs.items():\n            # np.ndarray and np.generic are not scalar types\n            # therefore we must unwrap their scalar values and\n            # pass to the json-serializable dict 'send'\n            if isinstance(v, (np.ndarray, np.generic)):\n                send[k] = v.item()\n            else:\n                send[k] = v\n        try:\n            if self.send_as_json:\n                requests.post(\n                    self.root + self.path, json=send, headers=self.headers\n                )\n            else:\n                requests.post(\n                    self.root + self.path,\n                    {self.field: json.dumps(send)},\n                    headers=self.headers,\n                )\n        except requests.exceptions.RequestException:\n            warnings.warn(\n                f\"Could not reach RemoteMonitor root server at {self.root}\",\n                stacklevel=2,\n            )",
    "pattern_analysis": {
      "api_sequence": [
        "isinstance",
        "np.ndarray",
        "np.generic",
        "v.item",
        "json.dumps",
        "requests.post",
        "requests.post",
        "requests.exceptions.RequestException",
        "warnings.warn"
      ],
      "api_sequence_with_args": [
        "isinstance(v, (np.ndarray, np.generic))",
        "np.ndarray",
        "np.generic",
        "v.item()",
        "json.dumps(send)",
        "requests.post(self.root + self.path, json=send, headers=self.headers)",
        "requests.post(self.root + self.path, {self.field: json.dumps(send)}, headers=self.headers)",
        "requests.exceptions.RequestException",
        "warnings.warn(f\"Could not reach RemoteMonitor root server at {self.root}\", stacklevel=2)"
      ],
      "mapped_sequence": [
        {
          "api_name": "isinstance",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "np.ndarray",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "np.generic",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "v.item",
          "id": "apply_lambda_elements",
          "description": "Applies lambda to elements of two lists",
          "first_id": "data_transformation_processing",
          "second_id": "function_application",
          "third_id": "lambda_application"
        },
        {
          "api_name": "json.dumps",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "requests.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "requests.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "requests.exceptions.RequestException",
          "id": "handle_socket_timeout",
          "description": "Handles socket timeout exception",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_configuration"
        },
        {
          "api_name": "warnings.warn",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        }
      ],
      "contextual_code": "def on_epoch_end(self, epoch, logs=None):\n    if requests is None:\n        raise ImportError(\"RemoteMonitor requires the `requests` library.\")\n    logs = logs or {}\n    send = {}\n    send[\"epoch\"] = epoch\n    for k, v in logs.items():\n        if isinstance(v, (np.ndarray, np.generic)):\n            send[k] = v.item()\n        else:\n            send[k] = v\n    try:\n        if self.send_as_json:\n            requests.post(\n                self.root + self.path, json=send, headers=self.headers\n            )\n        else:\n            requests.post(\n                self.root + self.path,\n                {self.field: json.dumps(send)},\n                headers=self.headers,\n            )\n    except requests.exceptions.RequestException:\n        warnings.warn(\n            f\"Could not reach RemoteMonitor root server at {self.root}\",\n            stacklevel=2,\n        )"
    }
  }
]