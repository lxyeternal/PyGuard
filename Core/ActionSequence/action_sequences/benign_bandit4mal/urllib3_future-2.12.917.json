[
  {
    "metadata": {
      "package_name": "urllib3_future-2.12.917",
      "total_matches": 5,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "test_response.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/urllib3_future-2.12.917/urllib3_future-2.12.917/test/test_response.py",
    "line_number": "210",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "209\t        assert r.read(2) == b\"oo\"\n210\t        assert r.read() == b\"\"\n211\t        assert r.read() == b\"\"",
    "code_snippet": "    def test_reference_read(self) -> None:\n        fp = BytesIO(b\"foo\")\n        r = HTTPResponse(fp, preload_content=False)\n\n        assert r.read(0) == b\"\"\n        assert r.read(1) == b\"f\"\n        assert r.read(2) == b\"oo\"\n        assert r.read() == b\"\"\n        assert r.read() == b\"\"",
    "pattern_analysis": {
      "api_sequence": [
        "io.BytesIO",
        "urllib3.response.HTTPResponse",
        "urllib3.response.HTTPResponse.read",
        "urllib3.response.HTTPResponse.read",
        "urllib3.response.HTTPResponse.read",
        "urllib3.response.HTTPResponse.read",
        "urllib3.response.HTTPResponse.read"
      ],
      "api_sequence_with_args": [
        "io.BytesIO(b\"foo\")",
        "urllib3.response.HTTPResponse(fp, preload_content=False)",
        "urllib3.response.HTTPResponse.read(0)",
        "urllib3.response.HTTPResponse.read(1)",
        "urllib3.response.HTTPResponse.read(2)",
        "urllib3.response.HTTPResponse.read()",
        "urllib3.response.HTTPResponse.read()"
      ],
      "mapped_sequence": [
        {
          "api_name": "io.BytesIO",
          "id": "create_memory_bytes",
          "description": "Creates in-memory bytes buffer from encoded string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "urllib3.response.HTTPResponse",
          "id": "deserialize_json_response",
          "description": "Deserializes JSON response body to Python object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "urllib3.response.HTTPResponse.read",
          "id": "read_response_body",
          "description": "Reads response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "urllib3.response.HTTPResponse.read",
          "id": "read_response_body",
          "description": "Reads response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "urllib3.response.HTTPResponse.read",
          "id": "read_response_body",
          "description": "Reads response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "urllib3.response.HTTPResponse.read",
          "id": "read_response_body",
          "description": "Reads response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "urllib3.response.HTTPResponse.read",
          "id": "read_response_body",
          "description": "Reads response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        }
      ],
      "contextual_code": "def test_reference_read(self) -> None:\n    fp = BytesIO(b\"foo\")\n    r = HTTPResponse(fp, preload_content=False)\n\n    assert r.read(0) == b\"\"\n    assert r.read(1) == b\"f\"\n    assert r.read(2) == b\"oo\"\n    assert r.read() == b\"\"\n    assert r.read() == b\"\""
    }
  },
  {
    "pyfile": "poolmanager.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/urllib3_future-2.12.917/urllib3_future-2.12.917/src/urllib3/poolmanager.py",
    "line_number": "864",
    "type_description": "B818:urlopen",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "863\t        if self._proxy_requires_url_absolute_form(u):\n864\t            response = conn.urlopen(method, url, **kw)\n865\t        else:",
    "code_snippet": "def urlopen(\n        self, method: str, url: str, redirect: bool = True, **kw: typing.Any\n    ) -> HTTPResponse | ResponsePromise:\n        \"\"\"\n        Same as :meth:`urllib3.HTTPConnectionPool.urlopen`\n        with custom cross-host redirect logic and only sends the request-uri\n        portion of the ``url``.\n\n        The given ``url`` parameter must be absolute, such that an appropriate\n        :class:`urllib3.connectionpool.ConnectionPool` can be chosen for it.\n        \"\"\"\n        u = parse_url(url)\n\n        if u.scheme is None:\n            warnings.warn(\n                \"URLs without a scheme (ie 'https://') are deprecated and will raise an error \"\n                \"in a future version of urllib3. To avoid this DeprecationWarning ensure all URLs \"\n                \"start with 'https://' or 'http://'. Read more in this issue: \"\n                \"https://github.com/urllib3/urllib3/issues/2920\",\n                category=DeprecationWarning,\n                stacklevel=2,\n            )\n\n        # if we passed manually an extension to urlopen, we want to manually\n        # disable svn if they are incompatible with said extension.\n        pool_kwargs = None\n\n        if \"extension\" in kw and kw[\"extension\"] is not None:\n            extension = kw[\"extension\"]\n            disabled_svn = set()\n\n            pool_kwargs = {}\n\n            if len(extension.supported_svn()) != 3:\n                if HttpVersion.h11 not in extension.supported_svn():\n                    disabled_svn.add(HttpVersion.h11)\n                if HttpVersion.h2 not in extension.supported_svn():\n                    disabled_svn.add(HttpVersion.h2)\n                if HttpVersion.h3 not in extension.supported_svn():\n                    disabled_svn.add(HttpVersion.h3)\n\n            pool_kwargs[\"disabled_svn\"] = disabled_svn\n\n        conn = self.connection_from_host(\n            u.host, port=u.port, scheme=u.scheme, pool_kwargs=pool_kwargs\n        )\n\n        if u.scheme is not None and u.scheme.lower() not in (\"http\", \"https\"):\n            extension = load_extension(*parse_extension(u.scheme))\n            kw[\"extension\"] = extension()\n            kw.update(kw[\"extension\"].urlopen_kwargs)\n\n        kw[\"assert_same_host\"] = False\n        kw[\"redirect\"] = False\n\n        if \"headers\" not in kw:\n            kw[\"headers\"] = self.headers\n\n        if self._proxy_requires_url_absolute_form(u):\n            response = conn.urlopen(method, url, **kw)\n        else:\n            response = conn.urlopen(method, u.request_uri, **kw)\n\n        self.pools.memorize(response, conn)\n        self.pools.release()\n\n        if \"multiplexed\" in kw and kw[\"multiplexed\"]:\n            if isinstance(response, ResponsePromise):\n                response.set_parameter(\"pm_redirect\", redirect)\n                response.set_parameter(\"pm_url\", url)\n                assert isinstance(response, ResponsePromise)\n\n                return response\n\n            # the established connection is not capable of doing multiplexed request\n            kw[\"multiplexed\"] = False\n\n        assert isinstance(response, HTTPResponse)\n        redirect_location = redirect and response.get_redirect_location()\n        if not redirect_location:\n            return response\n\n        # Support relative URLs for redirecting.\n        redirect_location = urljoin(url, redirect_location)\n\n        # RFC 7231, Section 6.4.4\n        if response.status == 303:\n            method = \"GET\"\n            kw[\"body\"] = None\n            kw[\"headers\"] = HTTPHeaderDict(kw[\"headers\"])\n\n            for should_be_removed_header in NOT_FORWARDABLE_HEADERS:\n                kw[\"headers\"].discard(should_be_removed_header)\n\n        retries = kw.get(\"retries\")\n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect)\n\n        # Strip headers marked as unsafe to forward to the redirected location.\n        # Check remove_headers_on_redirect to avoid a potential network call within\n        # conn.is_same_host() which may use socket.gethostbyname() in the future.\n        if retries.remove_headers_on_redirect and not conn.is_same_host(\n            redirect_location\n        ):\n            new_headers = kw[\"headers\"].copy()\n            for header in kw[\"headers\"]:\n                if header.lower() in retries.remove_headers_on_redirect:\n                    new_headers.pop(header, None)\n            kw[\"headers\"] = new_headers\n\n        try:\n            retries = retries.increment(method, url, response=response, _pool=conn)\n        except MaxRetryError:\n            if retries.raise_on_redirect:\n                response.drain_conn()\n                raise\n            return response\n\n        kw[\"retries\"] = retries\n        kw[\"redirect\"] = redirect\n\n        log.info(\"Redirecting %s -> %s\", url, redirect_location)\n\n        response.drain_conn()\n        return self.urlopen(method, redirect_location, **kw)  # type: ignore[no-any-return]\n",
    "pattern_analysis": {
      "api_sequence": [
        "parse_url",
        "warnings.warn",
        "self.connection_from_host",
        "load_extension",
        "parse_extension",
        "extension",
        "extension.urlopen_kwargs",
        "self._proxy_requires_url_absolute_form",
        "conn.urlopen",
        "conn.urlopen",
        "self.pools.memorize",
        "self.pools.release",
        "isinstance",
        "ResponsePromise.set_parameter",
        "ResponsePromise.set_parameter",
        "isinstance",
        "isinstance",
        "HTTPResponse.get_redirect_location",
        "urljoin",
        "HTTPHeaderDict",
        "kw['headers'].discard",
        "Retry.from_int",
        "conn.is_same_host",
        "kw['headers'].copy",
        "retries.increment",
        "response.drain_conn",
        "log.info",
        "response.drain_conn",
        "self.urlopen"
      ],
      "api_sequence_with_args": [
        "parse_url(url)",
        "warnings.warn(\"URLs without a scheme (ie 'https://') are deprecated and will raise an error ...\", category=DeprecationWarning, stacklevel=2)",
        "self.connection_from_host(u.host, port=u.port, scheme=u.scheme, pool_kwargs=pool_kwargs)",
        "load_extension(*parse_extension(u.scheme))",
        "parse_extension(u.scheme)",
        "extension()",
        "extension().urlopen_kwargs",
        "self._proxy_requires_url_absolute_form(u)",
        "conn.urlopen(method, url, **kw)",
        "conn.urlopen(method, u.request_uri, **kw)",
        "self.pools.memorize(response, conn)",
        "self.pools.release()",
        "isinstance(response, ResponsePromise)",
        "response.set_parameter(\"pm_redirect\", redirect)",
        "response.set_parameter(\"pm_url\", url)",
        "isinstance(response, ResponsePromise)",
        "isinstance(response, HTTPResponse)",
        "response.get_redirect_location()",
        "urljoin(url, redirect_location)",
        "HTTPHeaderDict(kw[\"headers\"])",
        "kw[\"headers\"].discard(should_be_removed_header)",
        "Retry.from_int(retries, redirect=redirect)",
        "conn.is_same_host(redirect_location)",
        "kw[\"headers\"].copy()",
        "retries.increment(method, url, response=response, _pool=conn)",
        "response.drain_conn()",
        "log.info(\"Redirecting %s -> %s\", url, redirect_location)",
        "response.drain_conn()",
        "self.urlopen(method, redirect_location, **kw)"
      ],
      "mapped_sequence": [
        {
          "api_name": "warnings.warn",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "self.connection_from_host",
          "id": "create_http_connection",
          "description": "Creates HTTP connection to specified host",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "conn.urlopen",
          "id": "open_url_get",
          "description": "Opens URL with GET parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "self.pools.memorize",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "self.pools.release",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "response.get_redirect_location",
          "id": "get_response_body",
          "description": "Retrieves response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "urljoin",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "HTTPHeaderDict",
          "id": "add_http_header",
          "description": "Adds HTTP header to request object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "Retry.from_int",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "conn.is_same_host",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "retries.increment",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "response.drain_conn",
          "id": "close_http_response",
          "description": "Closes the HTTP response object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "log.info",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "self.urlopen",
          "id": "open_url_get",
          "description": "Opens URL with GET parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        }
      ],
      "contextual_code": "def urlopen(self, method: str, url: str, redirect: bool = True, **kw: typing.Any) -> HTTPResponse | ResponsePromise:\n    u = parse_url(url)\n\n    if u.scheme is None:\n        warnings.warn(\n            \"URLs without a scheme (ie 'https://') are deprecated and will raise an error ...\",\n            category=DeprecationWarning,\n            stacklevel=2,\n        )\n\n    pool_kwargs = None\n    if \"extension\" in kw and kw[\"extension\"] is not None:\n        extension = kw[\"extension\"]\n        disabled_svn = set()\n        pool_kwargs = {}\n        if len(extension.supported_svn()) != 3:\n            if HttpVersion.h11 not in extension.supported_svn():\n                disabled_svn.add(HttpVersion.h11)\n            if HttpVersion.h2 not in extension.supported_svn():\n                disabled_svn.add(HttpVersion.h2)\n            if HttpVersion.h3 not in extension.supported_svn():\n                disabled_svn.add(HttpVersion.h3)\n        pool_kwargs[\"disabled_svn\"] = disabled_svn\n\n    conn = self.connection_from_host(u.host, port=u.port, scheme=u.scheme, pool_kwargs=pool_kwargs)\n\n    if u.scheme is not None and u.scheme.lower() not in (\"http\", \"https\"):\n        extension = load_extension(*parse_extension(u.scheme))\n        kw[\"extension\"] = extension()\n        kw.update(kw[\"extension\"].urlopen_kwargs)\n\n    kw[\"assert_same_host\"] = False\n    kw[\"redirect\"] = False\n    if \"headers\" not in kw:\n        kw[\"headers\"] = self.headers\n\n    if self._proxy_requires_url_absolute_form(u):\n        response = conn.urlopen(method, url, **kw)\n    else:\n        response = conn.urlopen(method, u.request_uri, **kw)\n\n    self.pools.memorize(response, conn)\n    self.pools.release()\n\n    if \"multiplexed\" in kw and kw[\"multiplexed\"]:\n        if isinstance(response, ResponsePromise):\n            response.set_parameter(\"pm_redirect\", redirect)\n            response.set_parameter(\"pm_url\", url)\n            assert isinstance(response, ResponsePromise)\n            return response\n        kw[\"multiplexed\"] = False\n\n    assert isinstance(response, HTTPResponse)\n    redirect_location = redirect and response.get_redirect_location()\n    if not redirect_location:\n        return response\n    redirect_location = urljoin(url, redirect_location)\n    if response.status == 303:\n        method = \"GET\"\n        kw[\"body\"] = None\n        kw[\"headers\"] = HTTPHeaderDict(kw[\"headers\"])\n        for should_be_removed_header in NOT_FORWARDABLE_HEADERS:\n            kw[\"headers\"].discard(should_be_removed_header)\n    retries = kw.get(\"retries\")\n    if not isinstance(retries, Retry):\n        retries = Retry.from_int(retries, redirect=redirect)\n    if retries.remove_headers_on_redirect and not conn.is_same_host(redirect_location):\n        new_headers = kw[\"headers\"].copy()\n        for header in kw[\"headers\"]:\n            if header.lower() in retries.remove_headers_on_redirect:\n                new_headers.pop(header, None)\n        kw[\"headers\"] = new_headers\n    try:\n        retries = retries.increment(method, url, response=response, _pool=conn)\n    except MaxRetryError:\n        if retries.raise_on_redirect:\n            response.drain_conn()\n            raise\n        return response\n    kw[\"retries\"] = retries\n    kw[\"redirect\"] = redirect\n    log.info(\"Redirecting %s -> %s\", url, redirect_location)\n    response.drain_conn()\n    return self.urlopen(method, redirect_location, **kw)"
    }
  },
  {
    "pyfile": "test_chunked_transfer.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/urllib3_future-2.12.917/urllib3_future-2.12.917/test/with_dummyserver/test_chunked_transfer.py",
    "line_number": "194",
    "type_description": "B818:urlopen",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "193\t            retries = Retry(total=1)\n194\t            pool.urlopen(\"GET\", \"/\", chunked=True, retries=retries)\n195\t            for sock in self.socks:",
    "code_snippet": "def test_preserve_chunked_on_retry_after(self) -> None:\n    self.chunked_requests = 0\n    self.socks: list[socket.socket] = []\n\n    def socket_handler(listener: socket.socket) -> None:\n        for _ in range(2):\n            sock = listener.accept()[0]\n            self.socks.append(sock)\n            request = consume_socket(sock)\n            if b\"Transfer-Encoding: chunked\" in request.split(b\"\\r\\n\"):\n                self.chunked_requests += 1\n\n            sock.send(\n                b\"HTTP/1.1 429 Too Many Requests\\r\\n\"\n                b\"Content-Type: text/plain\\r\\n\"\n                b\"Retry-After: 1\\r\\n\"\n                b\"Content-Length: 0\\r\\n\"\n                b\"Connection: close\\r\\n\"\n                b\"\\r\\n\"\n            )\n\n    self._start_server(socket_handler)\n    with HTTPConnectionPool(self.host, self.port) as pool:\n        retries = Retry(total=1)\n        pool.urlopen(\"GET\", \"/\", chunked=True, retries=retries)\n        for sock in self.socks:\n            sock.close()\n    assert self.chunked_requests == 2",
    "pattern_analysis": {
      "api_sequence": [
        "socket.socket.accept",
        "consume_socket",
        "socket.socket.send",
        "socket.socket.close",
        "HTTPConnectionPool.__enter__",
        "Retry",
        "HTTPConnectionPool.urlopen",
        "socket.socket.close"
      ],
      "api_sequence_with_args": [
        "socket.socket.accept()",
        "consume_socket(sock)",
        "socket.socket.send(b\"HTTP/1.1 429 Too Many Requests\\r\\nContent-Type: text/plain\\r\\nRetry-After: 1\\r\\nContent-Length: 0\\r\\nConnection: close\\r\\n\\r\\n\")",
        "socket.socket.close()",
        "HTTPConnectionPool(self.host, self.port).__enter__()",
        "Retry(total=1)",
        "HTTPConnectionPool.urlopen(\"GET\", \"/\", chunked=True, retries=retries)",
        "socket.socket.close()"
      ],
      "mapped_sequence": [
        {
          "api_name": "socket.socket.accept",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "consume_socket",
          "id": "receive_socket_data",
          "description": "Receives data from socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "socket.socket.send",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "socket.socket.close",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "HTTPConnectionPool.__enter__",
          "id": "create_http_connection",
          "description": "Creates HTTP connection to specified host",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "Retry",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "HTTPConnectionPool.urlopen",
          "id": "open_url_get",
          "description": "Opens URL with GET parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "socket.socket.close",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        }
      ],
      "contextual_code": "def test_preserve_chunked_on_retry_after(self) -> None:\n    self.chunked_requests = 0\n    self.socks: list[socket.socket] = []\n\n    def socket_handler(listener: socket.socket) -> None:\n        for _ in range(2):\n            sock = listener.accept()[0]\n            self.socks.append(sock)\n            request = consume_socket(sock)\n            if b\"Transfer-Encoding: chunked\" in request.split(b\"\\r\\n\"):\n                self.chunked_requests += 1\n\n            sock.send(\n                b\"HTTP/1.1 429 Too Many Requests\\r\\n\"\n                b\"Content-Type: text/plain\\r\\n\"\n                b\"Retry-After: 1\\r\\n\"\n                b\"Content-Length: 0\\r\\n\"\n                b\"Connection: close\\r\\n\"\n                b\"\\r\\n\"\n            )\n\n    self._start_server(socket_handler)\n    with HTTPConnectionPool(self.host, self.port) as pool:\n        retries = Retry(total=1)\n        pool.urlopen(\"GET\", \"/\", chunked=True, retries=retries)\n        for sock in self.socks:\n            sock.close()"
    }
  },
  {
    "pyfile": "test_resolver.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/urllib3_future-2.12.917/urllib3_future-2.12.917/test/contrib/test_resolver.py",
    "line_number": "486",
    "type_description": "B807:close",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "485\n486\t    resolver.close()\n487",
    "code_snippet": "@pytest.mark.parametrize(\n    \"url, expected_resolver_class\",\n    [\n        (\"dou://1.1.1.1\", PlainResolver),\n        (\"dox://ooooo.com\", None),\n        (\"doh://dns.google/resolve\", HTTPSResolver),\n        (\"doq://dns.nextdns.io/?timeout=5&cert_reqs=0\", QUICResolver),\n        (\"dns://dns.nextdns.io\", None),\n        (\"null://default\", NullResolver),\n        (\"default://null\", None),\n        (\"system://default\", SystemResolver),\n        (\"system://noop\", SystemResolver),\n        (\"in-memory://noop\", InMemoryResolver),\n        (\"in-memory://default\", InMemoryResolver),\n        (\"DoU://1.1.1.1\", PlainResolver),\n        (\"DOH+GOOGLE://default\", HTTPSResolver),\n        (\"doT://1.1.1.1\", TLSResolver),\n        (\"dot://1.1.1.1/?implementation=nonexistent\", None),\n        (\"system://\", SystemResolver),\n        (\"dot://\", None),\n        (\n            \"doq://dns.nextdns.io/?implementation=qh3&timeout=1&cert_reqs=0\",\n            QUICResolver,\n        ),\n    ],\n)\ndef test_url_resolver(\n    url: str, expected_resolver_class: type[BaseResolver] | None\n) -> None:\n    if expected_resolver_class is _MISSING_QUIC_SENTINEL:\n        pytest.skip(\"Test requires qh3 installed\")\n\n    if expected_resolver_class is None:\n        with pytest.raises(\n            (\n                NotImplementedError,\n                ValueError,\n                TypeError,\n            )\n        ):\n            ResolverDescription.from_url(url).new()\n        return\n\n    resolver = ResolverDescription.from_url(url).new()\n\n    assert isinstance(resolver, expected_resolver_class)\n    resolver.close()\n",
    "pattern_analysis": {
      "api_sequence": [
        "ResolverDescription.from_url",
        "ResolverDescription.new",
        "isinstance",
        "resolver.close"
      ],
      "api_sequence_with_args": [
        "ResolverDescription.from_url(url)",
        "ResolverDescription.from_url(url).new()",
        "isinstance(resolver, expected_resolver_class)",
        "resolver.close()"
      ],
      "mapped_sequence": [
        {
          "api_name": "ResolverDescription.from_url",
          "id": "create_dns_resolver",
          "description": "Creates DNS resolver object with custom configuration",
          "first_id": "basic_network_operations",
          "second_id": "network_information_gathering",
          "third_id": "domain_resolution"
        },
        {
          "api_name": "ResolverDescription.new",
          "id": "create_dns_resolver",
          "description": "Creates DNS resolver object with custom configuration",
          "first_id": "basic_network_operations",
          "second_id": "network_information_gathering",
          "third_id": "domain_resolution"
        },
        {
          "api_name": "isinstance",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "resolver.close",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        }
      ],
      "contextual_code": "def test_url_resolver(url: str, expected_resolver_class: type[BaseResolver] | None) -> None:\n    if expected_resolver_class is _MISSING_QUIC_SENTINEL:\n        pytest.skip(\"Test requires qh3 installed\")\n\n    if expected_resolver_class is None:\n        with pytest.raises((NotImplementedError, ValueError, TypeError)):\n            ResolverDescription.from_url(url).new()\n        return\n\n    resolver = ResolverDescription.from_url(url).new()\n    assert isinstance(resolver, expected_resolver_class)\n    resolver.close()"
    }
  },
  {
    "pyfile": "test_socketlevel.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/urllib3_future-2.12.917/urllib3_future-2.12.917/test/with_dummyserver/test_socketlevel.py",
    "line_number": "621",
    "type_description": "B805:send",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "620\t            timed_out.wait()\n621\t            sock.send(body.encode(\"utf-8\"))\n622\t            sock.close()",
    "code_snippet": "def socket_handler(listener: socket.socket) -> None:\n    sock = listener.accept()[0]\n    buf = b\"\"\n    body = \"Hi\"\n    while not buf.endswith(b\"\\r\\n\\r\\n\"):\n        buf = sock.recv(65536)\n    sock.send(\n        (\n            \"HTTP/1.1 200 OK\\r\\n\"\n            \"Content-Type: text/plain\\r\\n\"\n            \"Content-Length: %d\\r\\n\"\n            \"\\r\\n\" % len(body)\n        ).encode(\"utf-8\")\n    )\n\n    timed_out.wait()\n    sock.send(body.encode(\"utf-8\"))\n    sock.close()",
    "pattern_analysis": {
      "api_sequence": [
        "socket.socket.accept",
        "socket.socket.recv",
        "socket.socket.send",
        "threading.Event.wait",
        "socket.socket.send",
        "socket.socket.close"
      ],
      "api_sequence_with_args": [
        "socket.socket.accept()",
        "socket.socket.recv(65536)",
        "socket.socket.send((\"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nContent-Length: %d\\r\\n\\r\\n\" % len(body)).encode(\"utf-8\"))",
        "threading.Event.wait()",
        "socket.socket.send(body.encode(\"utf-8\"))",
        "socket.socket.close()"
      ],
      "mapped_sequence": [
        {
          "api_name": "socket.socket.accept",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "socket.socket.recv",
          "id": "receive_socket_data",
          "description": "Receives data from socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "socket.socket.send",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "threading.Event.wait",
          "id": "wait_thread",
          "description": "Waits for thread to finish execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "socket.socket.send",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "socket.socket.close",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        }
      ],
      "contextual_code": "def socket_handler(listener: socket.socket) -> None:\n    sock = listener.accept()[0]\n    buf = b\"\"\n    body = \"Hi\"\n    while not buf.endswith(b\"\\r\\n\\r\\n\"):\n        buf = sock.recv(65536)\n    sock.send(\n        (\n            \"HTTP/1.1 200 OK\\r\\n\"\n            \"Content-Type: text/plain\\r\\n\"\n            \"Content-Length: %d\\r\\n\"\n            \"\\r\\n\" % len(body)\n        ).encode(\"utf-8\")\n    )\n\n    timed_out.wait()\n    sock.send(body.encode(\"utf-8\"))\n    sock.close()"
    }
  }
]