[
  {
    "metadata": {
      "package_name": "backports_tarfile-1.2.0",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:40"
    }
  },
  {
    "pyfile": "test_tarfile.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/backports_tarfile-1.2.0/backports_tarfile-1.2.0/tests/test_tarfile.py",
    "line_number": "418",
    "type_description": "B834:open",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "417\t        # file object's current position\n418\t        with open(self.tarname, \"rb\") as fobj:\n419\t            tarfile.is_tarfile(fobj)",
    "code_snippet": "def test_is_tarfile_valid(self):\n    # is_tarfile works on filenames\n    self.assertTrue(tarfile.is_tarfile(self.tarname))\n\n    # is_tarfile works on path-like objects\n    self.assertTrue(tarfile.is_tarfile(os_helper.FakePath(self.tarname)))\n\n    # is_tarfile works on file objects\n    with open(self.tarname, \"rb\") as fobj:\n        self.assertTrue(tarfile.is_tarfile(fobj))\n\n    # is_tarfile works on file-like objects\n    with open(self.tarname, \"rb\") as fobj:\n        self.assertTrue(tarfile.is_tarfile(io.BytesIO(fobj.read())))",
    "pattern_analysis": {
      "api_sequence": [
        "tarfile.is_tarfile",
        "tarfile.is_tarfile",
        "open",
        "tarfile.is_tarfile",
        "open",
        "io.BytesIO",
        "fobj.read",
        "tarfile.is_tarfile"
      ],
      "api_sequence_with_args": [
        "tarfile.is_tarfile(self.tarname)",
        "tarfile.is_tarfile(os_helper.FakePath(self.tarname))",
        "open(self.tarname, \"rb\")",
        "tarfile.is_tarfile(fobj)",
        "open(self.tarname, \"rb\")",
        "io.BytesIO(fobj.read())",
        "fobj.read()",
        "tarfile.is_tarfile(io.BytesIO(fobj.read()))"
      ],
      "mapped_sequence": [
        {
          "api_name": "tarfile.is_tarfile",
          "id": "check_file_is_file",
          "description": "Checks if specified path exists and is a file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "tarfile.is_tarfile",
          "id": "check_file_is_file",
          "description": "Checks if specified path exists and is a file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "tarfile.is_tarfile",
          "id": "check_file_is_file",
          "description": "Checks if specified path exists and is a file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "io.BytesIO",
          "id": "create_memory_bytes",
          "description": "Creates in-memory bytes buffer from encoded string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "fobj.read",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "tarfile.is_tarfile",
          "id": "check_file_is_file",
          "description": "Checks if specified path exists and is a file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        }
      ],
      "contextual_code": "def test_is_tarfile_valid(self):\n    # is_tarfile works on filenames\n    self.assertTrue(tarfile.is_tarfile(self.tarname))\n\n    # is_tarfile works on path-like objects\n    self.assertTrue(tarfile.is_tarfile(os_helper.FakePath(self.tarname)))\n\n    # is_tarfile works on file objects\n    with open(self.tarname, \"rb\") as fobj:\n        self.assertTrue(tarfile.is_tarfile(fobj))\n\n    # is_tarfile works on file-like objects\n    with open(self.tarname, \"rb\") as fobj:\n        self.assertTrue(tarfile.is_tarfile(io.BytesIO(fobj.read())))"
    }
  },
  {
    "pyfile": "test_tarfile.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/backports_tarfile-1.2.0/backports_tarfile-1.2.0/tests/test_tarfile.py",
    "line_number": "765",
    "type_description": "B834:open",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "764\t        with os_helper.temp_dir(DIR), \\\n765\t             tarfile.open(tarname, encoding=\"iso8859-1\") as tar:\n766\t            directories = [t for t in tar if t.isdir()]",
    "code_snippet": "def test_extractall_pathlike_dir(self):\n    DIR = os.path.join(TEMPDIR, \"extractall\")\n    with os_helper.temp_dir(DIR), \\\n         tarfile.open(tarname, encoding=\"iso8859-1\") as tar:\n        directories = [t for t in tar if t.isdir()]\n        tar.extractall(os_helper.FakePath(DIR), directories, filter='fully_trusted')\n        for tarinfo in directories:\n            path = os.path.join(DIR, tarinfo.name)\n            self.assertEqual(os.path.getmtime(path), tarinfo.mtime)",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.join",
        "os_helper.temp_dir",
        "tarfile.open",
        "tarfile.TarFile.__iter__",
        "tarfile.TarInfo.isdir",
        "tarfile.TarFile.extractall",
        "os_helper.FakePath",
        "os.path.join",
        "os.path.getmtime"
      ],
      "api_sequence_with_args": [
        "os.path.join(TEMPDIR, \"extractall\")",
        "os_helper.temp_dir(DIR)",
        "tarfile.open(tarname, encoding=\"iso8859-1\")",
        "tar.__iter__()",
        "t.isdir()",
        "tar.extractall(os_helper.FakePath(DIR), directories, filter='fully_trusted')",
        "os_helper.FakePath(DIR)",
        "os.path.join(DIR, tarinfo.name)",
        "os.path.getmtime(path)"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os_helper.temp_dir",
          "id": "create_temp_dir",
          "description": "Creates temporary directory and returns its path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "tarfile.open",
          "id": "open_zip_read",
          "description": "Opens ZIP archive for reading",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "tarfile.TarFile.__iter__",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "tarfile.TarInfo.isdir",
          "id": "check_directory_exists",
          "description": "Checks if specified path exists and is a directory",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "tarfile.TarFile.extractall",
          "id": "extract_zip_files",
          "description": "Extracts all files from ZIP archive to specified directory",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "os_helper.FakePath",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.getmtime",
          "id": "get_current_time",
          "description": "Returns current time in seconds since epoch",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        }
      ],
      "contextual_code": "def test_extractall_pathlike_dir(self):\n    DIR = os.path.join(TEMPDIR, \"extractall\")\n    with os_helper.temp_dir(DIR), \\\n         tarfile.open(tarname, encoding=\"iso8859-1\") as tar:\n        directories = [t for t in tar if t.isdir()]\n        tar.extractall(os_helper.FakePath(DIR), directories, filter='fully_trusted')\n        for tarinfo in directories:\n            path = os.path.join(DIR, tarinfo.name)\n            self.assertEqual(os.path.getmtime(path), tarinfo.mtime)"
    }
  }
]