[
  {
    "metadata": {
      "package_name": "yt_dlp-2025.4.6.232826.dev0",
      "total_matches": 4,
      "processing_date": "2025-05-18 01:49:40"
    }
  },
  {
    "pyfile": "_urllib.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/yt_dlp-2025.4.6.232826.dev0/yt_dlp-2025.4.6.232826.dev0/yt_dlp/networking/_urllib.py",
    "line_number": "127",
    "type_description": "B816:decompress",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "126\t            return data\n127\t        return zlib.decompress(data, wbits=zlib.MAX_WBITS | 16)\n128",
    "code_snippet": "    @staticmethod\n    def gz(data):\n        # There may be junk added the end of the file\n        # We ignore it by only ever decoding a single gzip payload\n        if not data:\n            return data\n        return zlib.decompress(data, wbits=zlib.MAX_WBITS | 16)",
    "pattern_analysis": {
      "api_sequence": [
        "zlib.decompress"
      ],
      "api_sequence_with_args": [
        "zlib.decompress(data, wbits=zlib.MAX_WBITS | 16)"
      ],
      "mapped_sequence": [
        {
          "api_name": "zlib.decompress",
          "id": "decompress_data_zlib",
          "description": "Decompresses zlib-compressed data",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "compression_decompression"
        }
      ],
      "contextual_code": "@staticmethod\ndef gz(data):\n    # There may be junk added the end of the file\n    # We ignore it by only ever decoding a single gzip payload\n    if not data:\n        return data\n    return zlib.decompress(data, wbits=zlib.MAX_WBITS | 16)"
    }
  },
  {
    "pyfile": "test_websockets.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/yt_dlp-2025.4.6.232826.dev0/yt_dlp-2025.4.6.232826.dev0/test/test_websockets.py",
    "line_number": "156",
    "type_description": "B805:send",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "155\t            assert ws.status == 101\n156\t            ws.send('foo')\n157\t            assert ws.recv() == 'foo'",
    "code_snippet": "@pytest.mark.skipif(not websockets, reason='websockets must be installed to test websocket request handlers')\n@pytest.mark.parametrize('handler', ['Websockets'], indirect=True)\nclass TestWebsSocketRequestHandlerConformance:\n    @classmethod\n    def setup_class(cls):\n        cls.ws_thread, cls.ws_port = create_ws_websocket_server()\n        cls.ws_base_url = f'ws://127.0.0.1:{cls.ws_port}'\n\n        cls.wss_thread, cls.wss_port = create_wss_websocket_server()\n        cls.wss_base_url = f'wss://127.0.0.1:{cls.wss_port}'\n\n        cls.bad_wss_thread, cls.bad_wss_port = create_websocket_server(ssl=ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER))\n        cls.bad_wss_host = f'wss://127.0.0.1:{cls.bad_wss_port}'\n\n        cls.mtls_wss_thread, cls.mtls_wss_port = create_mtls_wss_websocket_server()\n        cls.mtls_wss_base_url = f'wss://127.0.0.1:{cls.mtls_wss_port}'\n\n        cls.legacy_wss_thread, cls.legacy_wss_port = create_legacy_wss_websocket_server()\n        cls.legacy_wss_host = f'wss://127.0.0.1:{cls.legacy_wss_port}'\n\n    def test_basic_websockets(self, handler):\n        with handler() as rh:\n            ws = ws_validate_and_send(rh, Request(self.ws_base_url))\n            assert 'upgrade' in ws.headers\n            assert ws.status == 101\n            ws.send('foo')\n            assert ws.recv() == 'foo'\n            ws.close()",
    "pattern_analysis": {
      "api_sequence": [
        "create_ws_websocket_server",
        "create_wss_websocket_server",
        "create_websocket_server",
        "ssl.SSLContext",
        "create_mtls_wss_websocket_server",
        "create_legacy_wss_websocket_server",
        "ws_validate_and_send",
        "Request",
        "ws.send",
        "ws.recv",
        "ws.close"
      ],
      "api_sequence_with_args": [
        "create_ws_websocket_server()",
        "create_wss_websocket_server()",
        "create_websocket_server(ssl=ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER))",
        "ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)",
        "create_mtls_wss_websocket_server()",
        "create_legacy_wss_websocket_server()",
        "ws_validate_and_send(rh, Request(self.ws_base_url))",
        "Request(self.ws_base_url)",
        "ws.send('foo')",
        "ws.recv()",
        "ws.close()"
      ],
      "mapped_sequence": [
        {
          "api_name": "create_ws_websocket_server",
          "id": "create_http_connection",
          "description": "Creates HTTP connection to specified host",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "create_wss_websocket_server",
          "id": "create_http_connection",
          "description": "Creates HTTP connection to specified host",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "create_websocket_server",
          "id": "create_http_connection",
          "description": "Creates HTTP connection to specified host",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "ssl.SSLContext",
          "id": "create_ssl_context",
          "description": "Creates SSL context with specified protocol",
          "first_id": "persistence_stealth",
          "second_id": "stealth_techniques",
          "third_id": "warning_disabling"
        },
        {
          "api_name": "create_mtls_wss_websocket_server",
          "id": "create_http_connection",
          "description": "Creates HTTP connection to specified host",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "create_legacy_wss_websocket_server",
          "id": "create_http_connection",
          "description": "Creates HTTP connection to specified host",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "ws_validate_and_send",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "Request",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "ws.send",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "ws.recv",
          "id": "receive_socket_data",
          "description": "Receives data from socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "ws.close",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        }
      ],
      "contextual_code": "@pytest.mark.skipif(not websockets, reason='websockets must be installed to test websocket request handlers')\n@pytest.mark.parametrize('handler', ['Websockets'], indirect=True)\nclass TestWebsSocketRequestHandlerConformance:\n    @classmethod\n    def setup_class(cls):\n        cls.ws_thread, cls.ws_port = create_ws_websocket_server()\n        cls.ws_base_url = f'ws://127.0.0.1:{cls.ws_port}'\n\n        cls.wss_thread, cls.wss_port = create_wss_websocket_server()\n        cls.wss_base_url = f'wss://127.0.0.1:{cls.wss_port}'\n\n        cls.bad_wss_thread, cls.bad_wss_port = create_websocket_server(ssl=ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER))\n        cls.bad_wss_host = f'wss://127.0.0.1:{cls.bad_wss_port}'\n\n        cls.mtls_wss_thread, cls.mtls_wss_port = create_mtls_wss_websocket_server()\n        cls.mtls_wss_base_url = f'wss://127.0.0.1:{cls.mtls_wss_port}'\n\n        cls.legacy_wss_thread, cls.legacy_wss_port = create_legacy_wss_websocket_server()\n        cls.legacy_wss_host = f'wss://127.0.0.1:{cls.legacy_wss_port}'\n\n    def test_basic_websockets(self, handler):\n        with handler() as rh:\n            ws = ws_validate_and_send(rh, Request(self.ws_base_url))\n            ws.send('foo')\n            ws.recv()\n            ws.close()"
    }
  },
  {
    "pyfile": "test_networking.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/yt_dlp-2025.4.6.232826.dev0/yt_dlp-2025.4.6.232826.dev0/test/test_networking.py",
    "line_number": "440",
    "type_description": "B831:send",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "439\t            res.close()\n440\t            res2 = validate_and_send(rh, Request(f'http://127.0.0.1:{self.http_port}/gen_200'))\n441\t            assert res2.url == f'http://127.0.0.1:{self.http_port}/gen_200'",
    "code_snippet": "def test_response_url(self, handler):\n    with handler() as rh:\n        # Response url should be that of the last url in redirect chain\n        res = validate_and_send(rh, Request(f'http://127.0.0.1:{self.http_port}/redirect_301'))\n        assert res.url == f'http://127.0.0.1:{self.http_port}/method'\n        res.close()\n        res2 = validate_and_send(rh, Request(f'http://127.0.0.1:{self.http_port}/gen_200'))\n        assert res2.url == f'http://127.0.0.1:{self.http_port}/gen_200'\n        res2.close()",
    "pattern_analysis": {
      "api_sequence": [
        "validate_and_send",
        "Request",
        "res.close",
        "validate_and_send",
        "Request",
        "res2.close"
      ],
      "api_sequence_with_args": [
        "validate_and_send(rh, Request(f'http://127.0.0.1:{self.http_port}/redirect_301'))",
        "Request(f'http://127.0.0.1:{self.http_port}/redirect_301')",
        "res.close()",
        "validate_and_send(rh, Request(f'http://127.0.0.1:{self.http_port}/gen_200'))",
        "Request(f'http://127.0.0.1:{self.http_port}/gen_200')",
        "res2.close()"
      ],
      "mapped_sequence": [
        {
          "api_name": "validate_and_send",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "Request",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "res.close",
          "id": "close_http_response",
          "description": "Closes the HTTP response object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "validate_and_send",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "Request",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "res2.close",
          "id": "close_http_response",
          "description": "Closes the HTTP response object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        }
      ],
      "contextual_code": "def test_response_url(self, handler):\n    with handler() as rh:\n        res = validate_and_send(rh, Request(f'http://127.0.0.1:{self.http_port}/redirect_301'))\n        assert res.url == f'http://127.0.0.1:{self.http_port}/method'\n        res.close()\n        res2 = validate_and_send(rh, Request(f'http://127.0.0.1:{self.http_port}/gen_200'))\n        assert res2.url == f'http://127.0.0.1:{self.http_port}/gen_200'\n        res2.close()"
    }
  },
  {
    "pyfile": "test_networking.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/yt_dlp-2025.4.6.232826.dev0/yt_dlp-2025.4.6.232826.dev0/test/test_networking.py",
    "line_number": "526",
    "type_description": "B831:send",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "525\t            with pytest.raises(IncompleteRead, match='13 bytes read, 234221 more expected'):\n526\t                validate_and_send(rh, Request(f'http://127.0.0.1:{self.http_port}/incompleteread')).read()\n527",
    "code_snippet": "def test_incompleteread(self, handler):\n    with handler(timeout=2) as rh:\n        with pytest.raises(IncompleteRead, match='13 bytes read, 234221 more expected'):\n            validate_and_send(rh, Request(f'http://127.0.0.1:{self.http_port}/incompleteread')).read()",
    "pattern_analysis": {
      "api_sequence": [
        "validate_and_send",
        "Request",
        "pytest.raises",
        "validate_and_send.read"
      ],
      "api_sequence_with_args": [
        "validate_and_send(rh, Request(f'http://127.0.0.1:{self.http_port}/incompleteread'))",
        "Request(f'http://127.0.0.1:{self.http_port}/incompleteread')",
        "pytest.raises(IncompleteRead, match='13 bytes read, 234221 more expected')",
        "validate_and_send(...).read()"
      ],
      "mapped_sequence": [
        {
          "api_name": "validate_and_send",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "Request",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "pytest.raises",
          "id": "error_handling_operations",
          "description": "File opening operations with error handling (ignore errors, custom error handling, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "validate_and_send.read",
          "id": "read_response_body",
          "description": "Reads response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        }
      ],
      "contextual_code": "def test_incompleteread(self, handler):\n    with handler(timeout=2) as rh:\n        with pytest.raises(IncompleteRead, match='13 bytes read, 234221 more expected'):\n            validate_and_send(rh, Request(f'http://127.0.0.1:{self.http_port}/incompleteread')).read()"
    }
  }
]