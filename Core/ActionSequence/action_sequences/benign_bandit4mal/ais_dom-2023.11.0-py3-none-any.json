[
  {
    "metadata": {
      "package_name": "ais_dom-2023.11.0-py3-none-any",
      "total_matches": 6,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "device_tracker.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ais_dom-2023.11.0-py3-none-any/homeassistant/components/ddwrt/device_tracker.py",
    "line_number": "109",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "108\n109\t        return self.mac2name.get(device)\n110",
    "code_snippet": "    def get_device_name(self, device):\n        \"\"\"Return the name of the given device or None if we don't know.\"\"\"\n        # If not initialised and not already scanned and not found.\n        if device not in self.mac2name:\n            url = f\"{self.protocol}://{self.host}/Status_Lan.live.asp\"\n\n            if not (data := self.get_ddwrt_data(url)):\n                return None\n\n            if not (dhcp_leases := data.get(\"dhcp_leases\")):\n                return None\n\n            # Remove leading and trailing quotes and spaces\n            cleaned_str = dhcp_leases.replace('\"', \"\").replace(\"'\", \"\").replace(\" \", \"\")\n            elements = cleaned_str.split(\",\")\n            num_clients = int(len(elements) / 5)\n            self.mac2name = {}\n            for idx in range(0, num_clients):\n                # The data is a single array\n                # every 5 elements represents one host, the MAC\n                # is the third element and the name is the first.\n                mac_index = (idx * 5) + 2\n                if mac_index < len(elements):\n                    mac = elements[mac_index]\n                    self.mac2name[mac] = elements[idx * 5]\n\n        return self.mac2name.get(device)",
    "pattern_analysis": {
      "api_sequence": [
        "self.get_ddwrt_data",
        "dict.get"
      ],
      "api_sequence_with_args": [
        "self.get_ddwrt_data(url)",
        "data.get(\"dhcp_leases\")"
      ],
      "mapped_sequence": [
        {
          "api_name": "self.get_ddwrt_data",
          "id": "open_url_get",
          "description": "Opens URL with GET parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "dict.get",
          "id": "deserialize_json_response",
          "description": "Deserializes JSON response body to Python object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        }
      ],
      "contextual_code": "def get_device_name(self, device):\n    # ...\n    if device not in self.mac2name:\n        url = f\"{self.protocol}://{self.host}/Status_Lan.live.asp\"\n\n        if not (data := self.get_ddwrt_data(url)):\n            return None\n\n        if not (dhcp_leases := data.get(\"dhcp_leases\")):\n            return None\n        # ...\n"
    }
  },
  {
    "pyfile": "sensor.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ais_dom-2023.11.0-py3-none-any/homeassistant/components/plex/sensor.py",
    "line_number": "194",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "193\n194\t        recent_libtype = LIBRARY_RECENT_LIBTYPE.get(\n195\t            self.library_type, self.library_type\n196\t        )",
    "code_snippet": "def _update_state_and_attrs(self):\n    \"\"\"Update library sensor state with sync calls.\"\"\"\n    primary_libtype = LIBRARY_PRIMARY_LIBTYPE.get(\n        self.library_type, self.library_type\n    )\n\n    self._attr_native_value = self.library_section.totalViewSize(\n        libtype=primary_libtype, includeCollections=False\n    )\n    for libtype in LIBRARY_ATTRIBUTE_TYPES.get(self.library_type, []):\n        self._attr_extra_state_attributes[\n            f\"{libtype}s\"\n        ] = self.library_section.totalViewSize(\n            libtype=libtype, includeCollections=False\n        )\n\n    recent_libtype = LIBRARY_RECENT_LIBTYPE.get(\n        self.library_type, self.library_type\n    )\n    recently_added = self.library_section.recentlyAdded(\n        maxresults=1, libtype=recent_libtype\n    )\n    if recently_added:\n        media = recently_added[0]\n        self._attr_extra_state_attributes[\"last_added_item\"] = pretty_title(media)\n        self._attr_extra_state_attributes[\"last_added_timestamp\"] = media.addedAt",
    "pattern_analysis": {
      "api_sequence": [],
      "api_sequence_with_args": [],
      "mapped_sequence": [],
      "contextual_code": "def _update_state_and_attrs(self):\n    \"\"\"Update library sensor state with sync calls.\"\"\"\n    primary_libtype = LIBRARY_PRIMARY_LIBTYPE.get(\n        self.library_type, self.library_type\n    )\n\n    self._attr_native_value = self.library_section.totalViewSize(\n        libtype=primary_libtype, includeCollections=False\n    )\n    for libtype in LIBRARY_ATTRIBUTE_TYPES.get(self.library_type, []):\n        self._attr_extra_state_attributes[\n            f\"{libtype}s\"\n        ] = self.library_section.totalViewSize(\n            libtype=libtype, includeCollections=False\n        )\n\n    recent_libtype = LIBRARY_RECENT_LIBTYPE.get(\n        self.library_type, self.library_type\n    )\n    recently_added = self.library_section.recentlyAdded(\n        maxresults=1, libtype=recent_libtype\n    )\n    if recently_added:\n        media = recently_added[0]\n        self._attr_extra_state_attributes[\"last_added_item\"] = pretty_title(media)\n        self._attr_extra_state_attributes[\"last_added_timestamp\"] = media.addedAt"
    }
  },
  {
    "pyfile": "__init__.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ais_dom-2023.11.0-py3-none-any/homeassistant/components/ais_ai_service/__init__.py",
    "line_number": "1374",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1373\t                prev_id = len(attr) - 1\n1374\t            track = attr.get(int(prev_id))\n1375\t            _say_it(hass, track[\"name\"])",
    "code_snippet": "def set_prev_position(hass):\n    global CURR_ENTITIE_POSITION\n    CURR_ENTITIE_POSITION = get_curent_position(hass)\n    state = hass.states.get(CURR_ENTITIE)\n    attr = state.attributes\n    if CURR_ENTITIE.startswith(\"input_select.\"):\n        options = attr.get(\"options\")\n        if len(options) < 2:\n            _say_it(hass, \"brak pozycji\")\n        else:\n            CURR_ENTITIE_POSITION = get_prev(options, CURR_ENTITIE_POSITION)\n            _say_it(hass, CURR_ENTITIE_POSITION)\n    elif CURR_ENTITIE.startswith(\"sensor.\") and CURR_ENTITIE.endswith(\"list\"):\n        if len(attr) == 0:\n            _say_it(hass, \"brak pozycji\")\n        else:\n            curr_id = int(state.state)\n            prev_id = curr_id - 1\n            if prev_id < 0:\n                prev_id = len(attr) - 1\n            track = attr.get(int(prev_id))\n            _say_it(hass, track[\"name\"])\n            # update list\n            hass.states.async_set(CURR_ENTITIE, prev_id, attr)\n    elif CURR_ENTITIE.startswith(\"input_number.\"):\n        _min = float(state.attributes.get(\"min\"))\n        _step = float(state.attributes.get(\"step\"))\n        _curr = float(CURR_ENTITIE_POSITION)\n        CURR_ENTITIE_POSITION = str(round(max(_curr - _step, _min), 2))\n        _say_it(hass, str(CURR_ENTITIE_POSITION))",
    "pattern_analysis": {
      "api_sequence": [
        "get_curent_position",
        "hass.states.get",
        "CURR_ENTITIE.startswith",
        "state.attributes.get",
        "_say_it",
        "get_prev",
        "_say_it",
        "CURR_ENTITIE.startswith",
        "CURR_ENTITIE.endswith",
        "len",
        "_say_it",
        "int",
        "int",
        "attr.get",
        "_say_it",
        "hass.states.async_set",
        "CURR_ENTITIE.startswith",
        "state.attributes.get",
        "state.attributes.get",
        "float",
        "float",
        "float",
        "max",
        "round",
        "_say_it"
      ],
      "api_sequence_with_args": [
        "get_curent_position(hass)",
        "hass.states.get(CURR_ENTITIE)",
        "CURR_ENTITIE.startswith(\"input_select.\")",
        "state.attributes.get(\"options\")",
        "_say_it(hass, \"brak pozycji\")",
        "get_prev(options, CURR_ENTITIE_POSITION)",
        "_say_it(hass, CURR_ENTITIE_POSITION)",
        "CURR_ENTITIE.startswith(\"sensor.\")",
        "CURR_ENTITIE.endswith(\"list\")",
        "len(attr)",
        "_say_it(hass, \"brak pozycji\")",
        "int(state.state)",
        "int(prev_id)",
        "attr.get(int(prev_id))",
        "_say_it(hass, track[\"name\"])",
        "hass.states.async_set(CURR_ENTITIE, prev_id, attr)",
        "CURR_ENTITIE.startswith(\"input_number.\")",
        "state.attributes.get(\"min\")",
        "state.attributes.get(\"step\")",
        "float(state.attributes.get(\"min\"))",
        "float(state.attributes.get(\"step\"))",
        "float(CURR_ENTITIE_POSITION)",
        "max(_curr - _step, _min)",
        "round(max(_curr - _step, _min), 2)",
        "_say_it(hass, str(CURR_ENTITIE_POSITION))"
      ],
      "mapped_sequence": [
        {
          "api_name": "hass.states.get",
          "id": "get_registry_value",
          "description": "Retrieves value and data type for specified registry value",
          "first_id": "system_operations",
          "second_id": "registry_operations",
          "third_id": "registry_modification"
        },
        {
          "api_name": "hass.states.async_set",
          "id": "set_registry_value",
          "description": "Sets value for specified registry key",
          "first_id": "system_operations",
          "second_id": "registry_operations",
          "third_id": "registry_modification"
        }
      ],
      "contextual_code": "def set_prev_position(hass):\n    global CURR_ENTITIE_POSITION\n    CURR_ENTITIE_POSITION = get_curent_position(hass)\n    state = hass.states.get(CURR_ENTITIE)\n    attr = state.attributes\n    if CURR_ENTITIE.startswith(\"input_select.\"):\n        options = attr.get(\"options\")\n        if len(options) < 2:\n            _say_it(hass, \"brak pozycji\")\n        else:\n            CURR_ENTITIE_POSITION = get_prev(options, CURR_ENTITIE_POSITION)\n            _say_it(hass, CURR_ENTITIE_POSITION)\n    elif CURR_ENTITIE.startswith(\"sensor.\") and CURR_ENTITIE.endswith(\"list\"):\n        if len(attr) == 0:\n            _say_it(hass, \"brak pozycji\")\n        else:\n            curr_id = int(state.state)\n            prev_id = curr_id - 1\n            if prev_id < 0:\n                prev_id = len(attr) - 1\n            track = attr.get(int(prev_id))\n            _say_it(hass, track[\"name\"])\n            # update list\n            hass.states.async_set(CURR_ENTITIE, prev_id, attr)\n    elif CURR_ENTITIE.startswith(\"input_number.\"):\n        _min = float(state.attributes.get(\"min\"))\n        _step = float(state.attributes.get(\"step\"))\n        _curr = float(CURR_ENTITIE_POSITION)\n        CURR_ENTITIE_POSITION = str(round(max(_curr - _step, _min), 2))\n        _say_it(hass, str(CURR_ENTITIE_POSITION))"
    }
  },
  {
    "pyfile": "__init__.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ais_dom-2023.11.0-py3-none-any/homeassistant/components/ais_ai_service/__init__.py",
    "line_number": "2285",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "2284\t    warnings.filterwarnings(\"ignore\", module=\"fuzzywuzzy\")\n2285\t    config = config.get(DOMAIN, {})\n2286\t    intents = hass.data.get(DOMAIN)",
    "code_snippet": "async def async_setup(hass, config):\n    \"\"\"Register the process service.\"\"\"\n    global aisCloudWS\n    aisCloudWS = ais_cloud.AisCloudWS(hass)\n    warnings.filterwarnings(\"ignore\", module=\"fuzzywuzzy\")\n    config = config.get(DOMAIN, {})\n    intents = hass.data.get(DOMAIN)\n    if intents is None:\n        intents = hass.data[DOMAIN] = {}\n\n    for intent_type, utterances in config.get(\"intents\", {}).items():\n        conf = intents.get(intent_type)\n        if conf is None:\n            conf = intents[intent_type] = []\n        conf.extend(_create_matcher(utterance) for utterance in utterances)\n\n    async def async_ais_setup_component(service):\n        # check and reload component if needed\n        domain = service.data[\"domain\"]\n        # for example satel_integra\n        # check if this domain is already setup\n        if domain in hass.config.components:\n            return True\n        ha_config = hass.config\n        result = await async_setup_component(hass, domain, ha_config)\n        _LOGGER.error(str(result))\n\n    async def process(service):\n        \"\"\"Parse text into commands.\"\"\"\n        text = service.data[ATTR_TEXT]\n        await _async_process(hass, text)\n\n    def process_code(service):\n        \"\"\"Parse remote code into action.\"\"\"\n        text = json.loads(service.data.get(ATTR_TEXT))\n        _process_code(hass, text)\n\n    def say_it(service):\n        \"\"\"Info to the user.\"\"\"\n        text = \"\"\n        pitch = None\n        rate = None\n        language = None\n        voice = None\n        path = None\n        if ATTR_TEXT in service.data:\n            text = service.data[ATTR_TEXT]\n        # TODO else:\n        #     # check message template\n        #     if \"template_text\" in service.data:\n        #         tpl = template.Template(service.data[\"template_text\"], hass)\n        #         message = tpl.async_render()\n        #     else:\n        #         return\n        if \"img\" in service.data:\n            img = service.data[\"img\"]\n            if img is not None:\n                if len(img) < 3:\n                    img = None\n        else:\n            img = None\n\n        if \"pitch\" in service.data:\n            pitch = service.data[\"pitch\"]\n        if \"rate\" in service.data:\n            rate = service.data[\"rate\"]\n        if \"language\" in service.data:\n            language = service.data[\"language\"]\n        if \"voice\" in service.data:\n            voice = service.data[\"voice\"]\n        if \"path\" in service.data:\n            path = service.data[\"path\"]\n\n        _say_it(\n            hass=hass,\n            message=text,\n            img=img,\n            pitch=pitch,\n            rate=rate,\n            language=language,\n            voice=voice,\n            path=path,\n        )\n\n    def say_in_browser(service):\n        \"\"\"Info to the via browser - this is handled by ais-tts in card\"\"\"\n\n    def welcome_home(service):\n        \"\"\"Welcome message.\"\"\"\n\n        # display favorites from Spotify only if Spotify is available\n        if hass.services.has_service(\"ais_spotify_service\", \"get_favorites\"):\n            hass.services.call(\n                \"ais_spotify_service\", \"get_favorites\", {\"type\": \"featured-playlists\"}\n            )\n\n        text = \"Witaj w Domu. Powiedz proszę w czym mogę Ci pomóc?\"\n        if ais_global.G_OFFLINE_MODE:\n            text = (\n                \"Uwaga, uruchomienie bez dostępu do sieci, część usług może nie działać poprawnie.\"\n                \"Sprawdź połączenie z Internetem.\"\n            )\n        _say_it(hass, text)\n\n        # immersive full mode for all apps\n        if ais_global.has_root():\n            hass.services.call(\n                \"ais_shell_command\",\n                \"execute_command\",\n                {\n                    \"command\": \"su -c 'settings put global policy_control \"\n                    \"immersive.full=*'\"\n                },\n            )\n        if hass.services.has_service(\"ais_tts\", \"play_item\"):\n            # ais_tts - remove all panels\n            if \"lovelace-dom\" in hass.data.get(\n                hass.components.frontend.DATA_PANELS, {}\n            ):\n                hass.components.frontend.async_remove_panel(\"lovelace-dom\")\n            if \"aisaudio\" in hass.data.get(hass.components.frontend.DATA_PANELS, {}):\n                hass.components.frontend.async_remove_panel(\"aisaudio\")\n            if \"map\" in hass.data.get(hass.components.frontend.DATA_PANELS, {}):\n                hass.components.frontend.async_remove_panel(\"map\")\n            if \"history\" in hass.data.get(hass.components.frontend.DATA_PANELS, {}):\n                hass.components.frontend.async_remove_panel(\"history\")\n            if \"logbook\" in hass.data.get(hass.components.frontend.DATA_PANELS, {}):\n                hass.components.frontend.async_remove_panel(\"logbook\")\n\n        # set the flag to info that the AIS start part is done - this is needed to don't say some info before this flag\n        ais_global.G_AIS_START_IS_DONE = True\n\n    async def async_set_context(service):\n        ...\n    # (rest of function omitted for brevity)\n",
    "pattern_analysis": {
      "api_sequence": [
        "ais_cloud.AisCloudWS",
        "warnings.filterwarnings",
        "json.loads",
        "_process_code",
        "_say_it",
        "hass.services.has_service",
        "hass.services.call",
        "ais_global.has_root",
        "hass.services.call",
        "hass.services.has_service",
        "hass.data.get",
        "hass.components.frontend.async_remove_panel",
        "hass.data.get",
        "hass.components.frontend.async_remove_panel",
        "hass.data.get",
        "hass.components.frontend.async_remove_panel",
        "hass.data.get",
        "hass.components.frontend.async_remove_panel",
        "hass.data.get",
        "hass.components.frontend.async_remove_panel"
      ],
      "api_sequence_with_args": [
        "ais_cloud.AisCloudWS(hass)",
        "warnings.filterwarnings(\"ignore\", module=\"fuzzywuzzy\")",
        "json.loads(service.data.get(ATTR_TEXT))",
        "_process_code(hass, text)",
        "_say_it(hass=hass, message=text, img=img, pitch=pitch, rate=rate, language=language, voice=voice, path=path)",
        "hass.services.has_service(\"ais_spotify_service\", \"get_favorites\")",
        "hass.services.call(\"ais_spotify_service\", \"get_favorites\", {\"type\": \"featured-playlists\"})",
        "ais_global.has_root()",
        "hass.services.call(\"ais_shell_command\", \"execute_command\", {\"command\": \"su -c 'settings put global policy_control immersive.full=*'\"})",
        "hass.services.has_service(\"ais_tts\", \"play_item\")",
        "hass.data.get(hass.components.frontend.DATA_PANELS, {})",
        "hass.components.frontend.async_remove_panel(\"lovelace-dom\")",
        "hass.data.get(hass.components.frontend.DATA_PANELS, {})",
        "hass.components.frontend.async_remove_panel(\"aisaudio\")",
        "hass.data.get(hass.components.frontend.DATA_PANELS, {})",
        "hass.components.frontend.async_remove_panel(\"map\")",
        "hass.data.get(hass.components.frontend.DATA_PANELS, {})",
        "hass.components.frontend.async_remove_panel(\"history\")",
        "hass.data.get(hass.components.frontend.DATA_PANELS, {})",
        "hass.components.frontend.async_remove_panel(\"logbook\")"
      ],
      "mapped_sequence": [
        {
          "api_name": "ais_cloud.AisCloudWS",
          "id": "init_grabber_class",
          "description": "Instantiates Grabber class",
          "first_id": "data_exfiltration",
          "second_id": "exfiltration_component_initialization",
          "third_id": "exfiltration_component_creation"
        },
        {
          "api_name": "warnings.filterwarnings",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "_process_code",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "_say_it",
          "id": "speak_text",
          "description": "Speaks provided text using system voice",
          "first_id": "persistence_stealth",
          "second_id": "user_interaction",
          "third_id": "speech_synthesis"
        },
        {
          "api_name": "hass.services.has_service",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "hass.services.call",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "ais_global.has_root",
          "id": "check_admin_privileges",
          "description": "Checks if process is running with administrator privileges",
          "first_id": "system_operations",
          "second_id": "system_privilege_operations",
          "third_id": "privilege_management"
        },
        {
          "api_name": "hass.services.call",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "hass.services.has_service",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "hass.data.get",
          "id": "get_global_symbols",
          "description": "Retrieves global symbol table as dictionary",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "hass.components.frontend.async_remove_panel",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "hass.data.get",
          "id": "get_global_symbols",
          "description": "Retrieves global symbol table as dictionary",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "hass.components.frontend.async_remove_panel",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "hass.data.get",
          "id": "get_global_symbols",
          "description": "Retrieves global symbol table as dictionary",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "hass.components.frontend.async_remove_panel",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "hass.data.get",
          "id": "get_global_symbols",
          "description": "Retrieves global symbol table as dictionary",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "hass.components.frontend.async_remove_panel",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "hass.data.get",
          "id": "get_global_symbols",
          "description": "Retrieves global symbol table as dictionary",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "hass.components.frontend.async_remove_panel",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        }
      ],
      "contextual_code": "async def async_setup(hass, config):\n    global aisCloudWS\n    aisCloudWS = ais_cloud.AisCloudWS(hass)\n    warnings.filterwarnings(\"ignore\", module=\"fuzzywuzzy\")\n    ...\n    def process_code(service):\n        text = json.loads(service.data.get(ATTR_TEXT))\n        _process_code(hass, text)\n    def say_it(service):\n        ...\n        _say_it(\n            hass=hass,\n            message=text,\n            img=img,\n            pitch=pitch,\n            rate=rate,\n            language=language,\n            voice=voice,\n            path=path,\n        )\n    def welcome_home(service):\n        if hass.services.has_service(\"ais_spotify_service\", \"get_favorites\"):\n            hass.services.call(\n                \"ais_spotify_service\", \"get_favorites\", {\"type\": \"featured-playlists\"}\n            )\n        ...\n        if ais_global.has_root():\n            hass.services.call(\n                \"ais_shell_command\",\n                \"execute_command\",\n                {\"command\": \"su -c 'settings put global policy_control immersive.full=*'\"},\n            )\n        if hass.services.has_service(\"ais_tts\", \"play_item\"):\n            if \"lovelace-dom\" in hass.data.get(hass.components.frontend.DATA_PANELS, {}):\n                hass.components.frontend.async_remove_panel(\"lovelace-dom\")\n            if \"aisaudio\" in hass.data.get(hass.components.frontend.DATA_PANELS, {}):\n                hass.components.frontend.async_remove_panel(\"aisaudio\")\n            if \"map\" in hass.data.get(hass.components.frontend.DATA_PANELS, {}):\n                hass.components.frontend.async_remove_panel(\"map\")\n            if \"history\" in hass.data.get(hass.components.frontend.DATA_PANELS, {}):\n                hass.components.frontend.async_remove_panel(\"history\")\n            if \"logbook\" in hass.data.get(hass.components.frontend.DATA_PANELS, {}):\n                hass.components.frontend.async_remove_panel(\"logbook\")"
    }
  },
  {
    "pyfile": "__init__.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ais_dom-2023.11.0-py3-none-any/homeassistant/components/ais_web_zwave2mqtt/__init__.py",
    "line_number": "78",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "77\t            # Request\n78\t            return await self._handle_request(request, token, path)\n79",
    "code_snippet": "    async def _handle(\n        self, request: web.Request, token: str, path: str\n    ) -> Union[web.Response, web.StreamResponse, web.WebSocketResponse]:\n        \"\"\"Route data to Hass.io ingress service.\"\"\"\n        # validate token\n        if token != self._valid_token:\n            try:\n                auth = self._hass.auth\n                refresh_token = await auth.async_validate_access_token(token)\n                if refresh_token is None:\n                    raise HTTPUnauthorized() from None\n                # remember the token as valid\n                self._valid_token = token\n            except Exception:\n                raise HTTPUnauthorized() from None\n\n        try:\n            # Websockettoken\n            if _is_websocket(request):\n                return await self._handle_websocket(request, token, path)\n\n            # Request\n            return await self._handle_request(request, token, path)\n\n        except aiohttp.ClientError as err:\n            _LOGGER.debug(\"Ingress error with %s / %s: %s\", token, path, err)\n\n        raise HTTPBadGateway() from None",
    "pattern_analysis": {
      "api_sequence": [
        "_is_websocket",
        "self._handle_websocket",
        "self._handle_request"
      ],
      "api_sequence_with_args": [
        "_is_websocket(request)",
        "self._handle_websocket(request, token, path)",
        "self._handle_request(request, token, path)"
      ],
      "mapped_sequence": [
        {
          "api_name": "_is_websocket",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "self._handle_websocket",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "self._handle_request",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        }
      ],
      "contextual_code": "async def _handle(self, request: web.Request, token: str, path: str):\n    # ...\n    try:\n        # Websockettoken\n        if _is_websocket(request):\n            return await self._handle_websocket(request, token, path)\n        # Request\n        return await self._handle_request(request, token, path)\n    except aiohttp.ClientError as err:\n        _LOGGER.debug(\"Ingress error with %s / %s: %s\", token, path, err)\n    raise HTTPBadGateway() from None"
    }
  },
  {
    "pyfile": "notify.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ais_dom-2023.11.0-py3-none-any/homeassistant/components/lannouncer/notify.py",
    "line_number": "80",
    "type_description": "B806:sendall",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "79\t            sock.sendall(cmd.encode())\n80\t            sock.sendall(b\"&@DONE@\\n\")\n81",
    "code_snippet": "def send_message(self, message=\"\", **kwargs):\n    \"\"\"Send a message to Lannouncer.\"\"\"\n    data = kwargs.get(ATTR_DATA)\n    if data is not None and ATTR_METHOD in data:\n        method = data.get(ATTR_METHOD)\n    else:\n        method = ATTR_METHOD_DEFAULT\n\n    if method not in ATTR_METHOD_ALLOWED:\n        _LOGGER.error(\"Unknown method %s\", method)\n        return\n\n    cmd = urlencode({method: message})\n\n    try:\n        # Open socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(10)\n        sock.connect((self._host, self._port))\n\n        # Send message\n        _LOGGER.debug(\"Sending message: %s\", cmd)\n        sock.sendall(cmd.encode())\n        sock.sendall(b\"&@DONE@\\n\")\n\n        # Check response\n        buffer = sock.recv(1024)\n        if buffer != b\"LANnouncer: OK\":\n            _LOGGER.error(\"Error sending data to Lannnouncer: %s\", buffer.decode())\n\n        # Close socket\n        sock.close()\n    except socket.gaierror:\n        _LOGGER.error(\"Unable to connect to host %s\", self._host)\n    except OSError:\n        _LOGGER.exception(\"Failed to send data to Lannnouncer\")",
    "pattern_analysis": {
      "api_sequence": [
        "urlencode",
        "socket.socket",
        "socket.socket.settimeout",
        "socket.socket.connect",
        "socket.socket.sendall",
        "socket.socket.sendall",
        "socket.socket.recv",
        "socket.socket.close"
      ],
      "api_sequence_with_args": [
        "urlencode({method: message})",
        "socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
        "socket.socket.settimeout(10)",
        "socket.socket.connect((self._host, self._port))",
        "socket.socket.sendall(cmd.encode())",
        "socket.socket.sendall(b\"&@DONE@\\n\")",
        "socket.socket.recv(1024)",
        "socket.socket.close()"
      ],
      "mapped_sequence": [
        {
          "api_name": "urlencode",
          "id": "encode_url_query",
          "description": "Encodes mapping object to URL query string",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "socket.socket",
          "id": "create_socket",
          "description": "Creates new socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_creation"
        },
        {
          "api_name": "socket.socket.settimeout",
          "id": "set_socket_timeout",
          "description": "Sets timeout for socket operations",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_configuration"
        },
        {
          "api_name": "socket.socket.connect",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "socket.socket.sendall",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "socket.socket.sendall",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "socket.socket.recv",
          "id": "receive_socket_data",
          "description": "Receives data from socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "socket.socket.close",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        }
      ],
      "contextual_code": "def send_message(self, message=\"\", **kwargs):\n    data = kwargs.get(ATTR_DATA)\n    if data is not None and ATTR_METHOD in data:\n        method = data.get(ATTR_METHOD)\n    else:\n        method = ATTR_METHOD_DEFAULT\n\n    if method not in ATTR_METHOD_ALLOWED:\n        _LOGGER.error(\"Unknown method %s\", method)\n        return\n\n    cmd = urlencode({method: message})\n\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(10)\n        sock.connect((self._host, self._port))\n        sock.sendall(cmd.encode())\n        sock.sendall(b\"&@DONE@\\n\")\n        buffer = sock.recv(1024)\n        if buffer != b\"LANnouncer: OK\":\n            _LOGGER.error(\"Error sending data to Lannnouncer: %s\", buffer.decode())\n        sock.close()\n    except socket.gaierror:\n        _LOGGER.error(\"Unable to connect to host %s\", self._host)\n    except OSError:\n        _LOGGER.exception(\"Failed to send data to Lannnouncer\")"
    }
  }
]