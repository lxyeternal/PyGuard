[
  {
    "metadata": {
      "package_name": "rapids_dependency_file_generator-1.18.1",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "test_examples.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/rapids_dependency_file_generator-1.18.1/rapids_dependency_file_generator-1.18.1/tests/test_examples.py",
    "line_number": "97",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "96\t        actual_file = open(actual_dir.joinpath(file)).read()\n97\t        expected_file = open(expected_dir.joinpath(file)).read()\n98\t        assert actual_file == expected_file",
    "code_snippet": "def test_examples(example_dir):\n    expected_dir = example_dir.joinpath(\"output\", \"expected\")\n    actual_dir = example_dir.joinpath(\"output\", \"actual\")\n    dep_file_path = example_dir.joinpath(\"dependencies.yaml\")\n\n    # Copy pyproject.toml files from expected to actual since they are modified in place\n    for dirpath, _, filenames in os.walk(expected_dir):\n        for filename in filenames:\n            if filename == \"pyproject.toml\":\n                full_path = pathlib.Path(dirpath) / filename\n                relative_path = full_path.relative_to(expected_dir)\n                new_path = actual_dir / relative_path\n                new_path.parent.mkdir(parents=True, exist_ok=True)\n                shutil.copyfile(full_path, new_path)\n\n    cli_args = [\n        \"--config\",\n        str(dep_file_path),\n        \"--clean\",\n        str(example_dir.joinpath(\"output\", \"actual\")),\n    ]\n\n    # Prepend channels for the prepend_channels tests\n    if example_dir.name in (\"prepend-channels\"):\n        cli_args = [\n            \"--prepend-channel\",\n            \"my_channel\",\n            \"--prepend-channel\",\n            \"my_other_channel\",\n        ] + cli_args\n\n    main(cli_args)\n\n    expected_file_set = make_file_set(expected_dir)\n    actual_file_set = make_file_set(actual_dir)\n\n    assert expected_file_set == actual_file_set\n\n    for file in actual_file_set:\n        actual_file = open(actual_dir.joinpath(file)).read()\n        expected_file = open(expected_dir.joinpath(file)).read()\n        assert actual_file == expected_file",
    "pattern_analysis": {
      "api_sequence": [
        "os.walk",
        "pathlib.Path",
        "pathlib.Path.relative_to",
        "pathlib.Path.mkdir",
        "shutil.copyfile",
        "open",
        "open",
        "open",
        "open"
      ],
      "api_sequence_with_args": [
        "os.walk(expected_dir)",
        "pathlib.Path(dirpath)",
        "pathlib.Path.relative_to(expected_dir)",
        "pathlib.Path.mkdir(parents=True, exist_ok=True)",
        "shutil.copyfile(full_path, new_path)",
        "open(actual_dir.joinpath(file))",
        "open(expected_dir.joinpath(file))",
        "open(actual_dir.joinpath(file))",
        "open(expected_dir.joinpath(file))"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.walk",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "pathlib.Path",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "pathlib.Path.relative_to",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "pathlib.Path.mkdir",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "shutil.copyfile",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        }
      ],
      "contextual_code": "for dirpath, _, filenames in os.walk(expected_dir):\n    for filename in filenames:\n        if filename == \"pyproject.toml\":\n            full_path = pathlib.Path(dirpath) / filename\n            relative_path = full_path.relative_to(expected_dir)\n            new_path = actual_dir / relative_path\n            new_path.parent.mkdir(parents=True, exist_ok=True)\n            shutil.copyfile(full_path, new_path)\n\nfor file in actual_file_set:\n    actual_file = open(actual_dir.joinpath(file)).read()\n    expected_file = open(expected_dir.joinpath(file)).read()\n    assert actual_file == expected_file"
    }
  }
]