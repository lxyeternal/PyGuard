[
  {
    "metadata": {
      "package_name": "localstack_core-4.3.1.dev45",
      "total_matches": 3,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "provider.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/localstack_core-4.3.1.dev45/localstack_core-4.3.1.dev45/localstack-core/localstack/services/dynamodb/provider.py",
    "line_number": "2091",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "2090\t    schema = SchemaExtractor.get_table_schema(table_name, account_id, region_name)\n2091\t    for index in schema[\"Table\"].get(\"GlobalSecondaryIndexes\", []):\n2092\t        if index[\"IndexName\"] == index_name:",
    "code_snippet": "def get_global_secondary_index(account_id: str, region_name: str, table_name: str, index_name: str):\n    schema = SchemaExtractor.get_table_schema(table_name, account_id, region_name)\n    for index in schema[\"Table\"].get(\"GlobalSecondaryIndexes\", []):\n        if index[\"IndexName\"] == index_name:\n            return index\n    raise ResourceNotFoundException(\"Index not found\")",
    "pattern_analysis": {
      "api_sequence": [
        "SchemaExtractor.get_table_schema"
      ],
      "api_sequence_with_args": [
        "SchemaExtractor.get_table_schema(table_name, account_id, region_name)"
      ],
      "mapped_sequence": [
        {
          "api_name": "SchemaExtractor.get_table_schema",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        }
      ],
      "contextual_code": "def get_global_secondary_index(account_id: str, region_name: str, table_name: str, index_name: str):\n    schema = SchemaExtractor.get_table_schema(table_name, account_id, region_name)\n    for index in schema[\"Table\"].get(\"GlobalSecondaryIndexes\", []):\n        if index[\"IndexName\"] == index_name:\n            return index\n    raise ResourceNotFoundException(\"Index not found\")"
    }
  },
  {
    "pyfile": "integration.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/localstack_core-4.3.1.dev45/localstack_core-4.3.1.dev45/localstack-core/localstack/services/apigateway/legacy/integration.py",
    "line_number": "359",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "358\t        uri = (\n359\t            invocation_context.integration.get(\"uri\")\n360\t            or invocation_context.integration.get(\"integrationUri\")",
    "code_snippet": "def invoke(self, invocation_context: ApiInvocationContext):\n    self.validate_integration_method(invocation_context)\n    uri = (\n        invocation_context.integration.get(\"uri\")\n        or invocation_context.integration.get(\"integrationUri\")\n        or \"\"\n    )\n    invocation_context.context = get_event_request_context(invocation_context)\n    relative_path, query_string_params = extract_query_string_params(\n        path=invocation_context.path_with_query_string\n    )\n    try:\n        path_params = extract_path_params(\n            path=relative_path, extracted_path=invocation_context.resource_path\n        )\n        invocation_context.path_params = path_params\n    except Exception:\n        pass\n\n    func_arn = uri\n    if \":lambda:path\" in uri:\n        func_arn = uri.split(\":lambda:path\")[1].split(\"functions/\")[1].split(\"/invocations\")[0]\n\n    if invocation_context.authorizer_type:\n        invocation_context.context[\"authorizer\"] = invocation_context.authorizer_result\n\n    payload = self.request_templates.render(invocation_context)\n\n    result = self.process_apigateway_invocation(\n        func_arn=func_arn,\n        path=relative_path,\n        payload=payload,\n        invocation_context=invocation_context,\n        query_string_params=query_string_params,\n    )\n\n    response = LambdaResponse()\n    response.headers.update({\"content-type\": \"application/json\"})\n    parsed_result = json.loads(str(result or \"{}\"))\n    parsed_result = common.json_safe(parsed_result)\n    parsed_result = {} if parsed_result is None else parsed_result\n\n    if set(parsed_result) - {\n        \"body\",\n        \"statusCode\",\n        \"headers\",\n        \"isBase64Encoded\",\n        \"multiValueHeaders\",\n    }:\n        LOG.warning(\n            'Lambda output should follow the next JSON format: { \"isBase64Encoded\": true|false, \"statusCode\": httpStatusCode, \"headers\": { \"headerName\": \"headerValue\", ... },\"body\": \"...\"}\\n Lambda output: %s',\n            parsed_result,\n        )\n        response.status_code = 502\n        response._content = json.dumps({\"message\": \"Internal server error\"})\n        return response\n\n    response.status_code = int(parsed_result.get(\"statusCode\", 200))\n    parsed_headers = parsed_result.get(\"headers\", {})\n    if parsed_headers is not None:\n        response.headers.update(parsed_headers)\n    try:\n        result_body = parsed_result.get(\"body\")\n        if isinstance(result_body, dict):\n            response._content = json.dumps(result_body)\n        else:\n            body_bytes = to_bytes(result_body or \"\")\n            if parsed_result.get(\"isBase64Encoded\", False):\n                body_bytes = base64.b64decode(body_bytes)\n            response._content = body_bytes\n    except Exception as e:\n        LOG.warning(\"Couldn't set Lambda response content: %s\", e)\n        response._content = \"{}\"\n    response.multi_value_headers = parsed_result.get(\"multiValueHeaders\") or {}\n\n    # apply custom response template\n    self.update_content_length(response)\n    invocation_context.response = response\n\n    return invocation_context.response",
    "pattern_analysis": {
      "api_sequence": [
        "get_event_request_context",
        "extract_query_string_params",
        "extract_path_params",
        "self.request_templates.render",
        "self.process_apigateway_invocation",
        "LambdaResponse",
        "response.headers.update",
        "json.loads",
        "common.json_safe",
        "LOG.warning",
        "json.dumps",
        "to_bytes",
        "base64.b64decode",
        "isinstance",
        "json.dumps",
        "LOG.warning",
        "self.update_content_length"
      ],
      "api_sequence_with_args": [
        "get_event_request_context(invocation_context)",
        "extract_query_string_params(path=invocation_context.path_with_query_string)",
        "extract_path_params(path=relative_path, extracted_path=invocation_context.resource_path)",
        "self.request_templates.render(invocation_context)",
        "self.process_apigateway_invocation(func_arn=func_arn, path=relative_path, payload=payload, invocation_context=invocation_context, query_string_params=query_string_params)",
        "LambdaResponse()",
        "response.headers.update({\"content-type\": \"application/json\"})",
        "json.loads(str(result or \"{}\"))",
        "common.json_safe(parsed_result)",
        "LOG.warning('Lambda output should follow the next JSON format: ...', parsed_result)",
        "json.dumps({\"message\": \"Internal server error\"})",
        "to_bytes(result_body or \"\")",
        "base64.b64decode(body_bytes)",
        "isinstance(result_body, dict)",
        "json.dumps(result_body)",
        "LOG.warning(\"Couldn't set Lambda response content: %s\", e)",
        "self.update_content_length(response)"
      ],
      "mapped_sequence": [
        {
          "api_name": "get_event_request_context",
          "id": "init_details_class",
          "description": "Instantiates Details class with configuration",
          "first_id": "data_exfiltration",
          "second_id": "exfiltration_component_initialization",
          "third_id": "exfiltration_component_creation"
        },
        {
          "api_name": "extract_query_string_params",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "extract_path_params",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "self.request_templates.render",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "self.process_apigateway_invocation",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "LambdaResponse",
          "id": "init_parent_class",
          "description": "Initializes parent class with provided arguments",
          "first_id": "code_execution",
          "second_id": "object_initialization",
          "third_id": "class_initialization"
        },
        {
          "api_name": "response.headers.update",
          "id": "add_http_header",
          "description": "Adds HTTP header to request object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "common.json_safe",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "LOG.warning",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "json.dumps",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "to_bytes",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "base64.b64decode",
          "id": "decode_base64_to_bytes",
          "description": "Decodes base64-encoded string to bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "isinstance",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "json.dumps",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "LOG.warning",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "self.update_content_length",
          "id": "add_http_header",
          "description": "Adds HTTP header to request object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        }
      ],
      "contextual_code": "def invoke(self, invocation_context: ApiInvocationContext):\n    self.validate_integration_method(invocation_context)\n    uri = (\n        invocation_context.integration.get(\"uri\")\n        or invocation_context.integration.get(\"integrationUri\")\n        or \"\"\n    )\n    invocation_context.context = get_event_request_context(invocation_context)\n    relative_path, query_string_params = extract_query_string_params(\n        path=invocation_context.path_with_query_string\n    )\n    try:\n        path_params = extract_path_params(\n            path=relative_path, extracted_path=invocation_context.resource_path\n        )\n        invocation_context.path_params = path_params\n    except Exception:\n        pass\n\n    func_arn = uri\n    if \":lambda:path\" in uri:\n        func_arn = uri.split(\":lambda:path\")[1].split(\"functions/\")[1].split(\"/invocations\")[0]\n\n    if invocation_context.authorizer_type:\n        invocation_context.context[\"authorizer\"] = invocation_context.authorizer_result\n\n    payload = self.request_templates.render(invocation_context)\n\n    result = self.process_apigateway_invocation(\n        func_arn=func_arn,\n        path=relative_path,\n        payload=payload,\n        invocation_context=invocation_context,\n        query_string_params=query_string_params,\n    )\n\n    response = LambdaResponse()\n    response.headers.update({\"content-type\": \"application/json\"})\n    parsed_result = json.loads(str(result or \"{}\"))\n    parsed_result = common.json_safe(parsed_result)\n    parsed_result = {} if parsed_result is None else parsed_result\n\n    if set(parsed_result) - {\n        \"body\",\n        \"statusCode\",\n        \"headers\",\n        \"isBase64Encoded\",\n        \"multiValueHeaders\",\n    }:\n        LOG.warning(\n            'Lambda output should follow the next JSON format: { \"isBase64Encoded\": true|false, \"statusCode\": httpStatusCode, \"headers\": { \"headerName\": \"headerValue\", ... },\"body\": \"...\"}\\n Lambda output: %s',\n            parsed_result,\n        )\n        response.status_code = 502\n        response._content = json.dumps({\"message\": \"Internal server error\"})\n        return response\n\n    response.status_code = int(parsed_result.get(\"statusCode\", 200))\n    parsed_headers = parsed_result.get(\"headers\", {})\n    if parsed_headers is not None:\n        response.headers.update(parsed_headers)\n    try:\n        result_body = parsed_result.get(\"body\")\n        if isinstance(result_body, dict):\n            response._content = json.dumps(result_body)\n        else:\n            body_bytes = to_bytes(result_body or \"\")\n            if parsed_result.get(\"isBase64Encoded\", False):\n                body_bytes = base64.b64decode(body_bytes)\n            response._content = body_bytes\n    except Exception as e:\n        LOG.warning(\"Couldn't set Lambda response content: %s\", e)\n        response._content = \"{}\"\n    response.multi_value_headers = parsed_result.get(\"multiValueHeaders\") or {}\n\n    # apply custom response template\n    self.update_content_length(response)\n    invocation_context.response = response\n\n    return invocation_context.response"
    }
  },
  {
    "pyfile": "tcp_proxy.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/localstack_core-4.3.1.dev45/localstack_core-4.3.1.dev45/localstack-core/localstack/utils/server/tcp_proxy.py",
    "line_number": "68",
    "type_description": "B806:sendall",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "67\t                        elif s == s_dst:\n68\t                            s_src.sendall(data)\n69\t        except Exception as e:",
    "code_snippet": "def _handle_request(self, s_src: socket.socket):\n    try:\n        s_dst = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        with s_src as s_src, s_dst as s_dst:\n            s_dst.connect((self._target_address, self._target_port))\n\n            sockets = [s_src, s_dst]\n            while not self._stopped.is_set():\n                s_read, _, _ = select.select(sockets, [], [], 1)\n\n                for s in s_read:\n                    data = s.recv(self._buffer_size)\n                    if not data:\n                        return\n\n                    if s == s_src:\n                        forward, response = data, None\n                        if self._handler:\n                            forward, response = self._handler(data)\n                        if forward is not None:\n                            s_dst.sendall(forward)\n                        elif response is not None:\n                            s_src.sendall(response)\n                            return\n                    elif s == s_dst:\n                        s_src.sendall(data)\n    except Exception as e:\n        LOG.error(\n            \"Error while handling request from %s to %s:%s: %s\",\n            s_src.getpeername(),\n            self._target_address,\n            self._target_port,\n            e,\n        )",
    "pattern_analysis": {
      "api_sequence": [
        "socket.socket",
        "socket.socket.connect",
        "select.select",
        "socket.socket.recv",
        "socket.socket.sendall",
        "socket.socket.sendall",
        "socket.socket.sendall",
        "LOG.error",
        "socket.socket.getpeername"
      ],
      "api_sequence_with_args": [
        "socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
        "socket.socket.connect((self._target_address, self._target_port))",
        "select.select(sockets, [], [], 1)",
        "socket.socket.recv(self._buffer_size)",
        "socket.socket.sendall(forward)",
        "socket.socket.sendall(response)",
        "socket.socket.sendall(data)",
        "LOG.error(\"Error while handling request from %s to %s:%s: %s\", s_src.getpeername(), self._target_address, self._target_port, e)",
        "socket.socket.getpeername()"
      ],
      "mapped_sequence": [
        {
          "api_name": "socket.socket",
          "id": "create_socket",
          "description": "Creates new socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_creation"
        },
        {
          "api_name": "socket.socket.connect",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "select.select",
          "id": "handle_socket_timeout",
          "description": "Handles socket timeout exception",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_configuration"
        },
        {
          "api_name": "socket.socket.recv",
          "id": "receive_socket_data",
          "description": "Receives data from socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "socket.socket.sendall",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "socket.socket.sendall",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "socket.socket.sendall",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "LOG.error",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "socket.socket.getpeername",
          "id": "get_socket_local_addr",
          "description": "Retrieves local address of the socket",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        }
      ],
      "contextual_code": "def _handle_request(self, s_src: socket.socket):\n    try:\n        s_dst = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        with s_src as s_src, s_dst as s_dst:\n            s_dst.connect((self._target_address, self._target_port))\n\n            sockets = [s_src, s_dst]\n            while not self._stopped.is_set():\n                s_read, _, _ = select.select(sockets, [], [], 1)\n\n                for s in s_read:\n                    data = s.recv(self._buffer_size)\n                    if not data:\n                        return\n\n                    if s == s_src:\n                        forward, response = data, None\n                        if self._handler:\n                            forward, response = self._handler(data)\n                        if forward is not None:\n                            s_dst.sendall(forward)\n                        elif response is not None:\n                            s_src.sendall(response)\n                            return\n                    elif s == s_dst:\n                        s_src.sendall(data)\n    except Exception as e:\n        LOG.error(\n            \"Error while handling request from %s to %s:%s: %s\",\n            s_src.getpeername(),\n            self._target_address,\n            self._target_port,\n            e,\n        )"
    }
  }
]