[
  {
    "metadata": {
      "package_name": "oneagent_sdk-1.5.1.20240104.95100-py2.py3-none-win_amd64",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:40"
    }
  },
  {
    "pyfile": "sdkctypesiface.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/oneagent_sdk-1.5.1.20240104.95100-py2.py3-none-win_amd64/oneagent/_impl/native/sdkctypesiface.py",
    "line_number": "176",
    "type_description": "B841:cdll",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "175\n176\t        self._dll = ctypes.WinDLL(libname) if WIN32 else ctypes.CDLL(libname)\n177",
    "code_snippet": "class SDKDllInterface(object):\n\n    _ONESDK_PREFIX = 'onesdk_'\n\n    @classmethod\n    def _fn_basename(cls, name):\n        assert name.startswith(cls._ONESDK_PREFIX), \\\n            name + ' does not start with onesdk-prefix'\n        name = name[len(cls._ONESDK_PREFIX):]\n        if name.endswith('_p'):\n            name = name[:-2]\n        return name\n\n    def _initfn(self, name, args, ret, public=True, check=False): #pylint:disable=too-many-arguments\n        fullname = self._ONESDK_PREFIX + name\n\n        if check and not hasattr(self._dll, fullname):\n            msg = 'Unable to find function '+ fullname + ' in the OneAgent SDK for C/C++'\n            raise SDKInitializationError(ErrorCode.INVALID_AGENT_BINARY, msg)\n\n        func = getattr(self._dll, fullname)\n        func.argtypes = args\n        func.restype = ret\n        name = self._fn_basename(fullname)\n        if not public:\n            name = '_' + name\n        setattr(self, name, func)\n        return func\n\n    #pylint:disable=too-many-statements\n    def __init__(self, libname):\n        self._log_cb = None\n        self._diag_cb = None\n        self._py_diag_cb = None\n\n        self._agent_found = False\n        self._agent_is_compatible = False\n        self._agent_sdk_version = None\n        self._agent_version = None\n\n        self._dll = ctypes.WinDLL(libname) if WIN32 else ctypes.CDLL(libname)\n\n        initfn = self._initfn\n\n        # Getting mandatory methods first and fail if they can't be found.\n        self._agent_sdk_version = '-'\n\n        try:\n            initfn(\n                'agent_get_current_state',\n                (),\n                ctypes.c_int32,\n                check=True) # avail since 1.0.0\n\n            initfn(\n                'agent_get_version_string',\n                (),\n                xchar_p,\n                public=False,\n                check=True) # avail since 1.0.0\n\n            initfn(\n                'stub_get_version',\n                (ctypes.POINTER(OnesdkStubVersion),),\n                None,\n                public=False,\n                check=True) # avail since 1.2.0\n\n            _stub_version = self._get_stub_version()\n            self._agent_sdk_version = str(_stub_version)\n\n            if not min_stub_version <= _stub_version < max_stub_version:\n                raise SDKInitializationError(ErrorCode.INVALID_AGENT_BINARY, \\\n                               'The version of the OneAgent SDK for C/C++ does not match the ' \\\n                               'prerequisites for this OneAgent SDK for Python: ' + \\\n                               str(min_stub_version) + ' <= ' + self._agent_sdk_version + ' < ' + \\\n                               str(max_stub_version))\n\n            initfn(\n                'stub_get_agent_load_info',\n                (ctypes.POINTER(bool_t), ctypes.POINTER(bool_t)),\n                None,\n                public=False,\n                check=True) # avail since 1.3.0\n\n            logger.info('Native SDK library \"%s\" version %s loaded.', \\\n                        libname, self._agent_sdk_version)\n        except SDKInitializationError as e:\n            if e.code == ErrorCode.INVALID_AGENT_BINARY:\n                e.agent_version = '-/' + self._agent_sdk_version\n            raise\n\n        # Args\n        initfn(\n            'stub_is_sdk_cmdline_arg',\n            (XStrPInArg,),\n            bool_t)\n        initfn(\n            'stub_process_cmdline_arg',\n            (XStrPInArg, bool_t),\n            result_t).__doc__ = '''(arg, replace_existing) -> result\n\n            This expects arg in the format \"--dt_<varname>=<value>\".\n            '''\n        initfn(\n            'stub_set_variable',\n            (XStrPInArg, bool_t),\n            result_t).__doc__ = '''(var_spec, replace_existing) -> result\n\n            This expects var_spec in the format \"<name>=<value>\"\n            '''\n\n        # Missing: stub_strip_sdk_cmdline_args: Adding a Python implementation\n        # of this would probably easier and more efficient than dealing with\n        # modifying a string array.\n\n        initfn(\n            'stub_set_logging_level',\n            (log_level_t,),\n            None)\n        initfn(\n            'stub_default_logging_function',\n            (log_level_t, XStrPInArg),\n            None)\n        initfn(\n            'stub_set_logging_callback',\n            (stub_logging_callback_t,),\n            None,\n            public=False)\n        initfn(\n            'stub_free_variables',\n            (),\n            None)\n\n        # Init/Shutdown\n        initfn(\n            'initialize_2',\n            (ctypes.c_uint32,),\n            result_t,\n            public=False)\n        initfn(\n            'shutdown',\n            (),\n            result_t)\n\n        initfn(\n            'agent_set_warning_callback',\n            (agent_logging_callback_t,),\n            result_t,\n            public=False)\n\n        initfn(\n            'agent_set_verbose_callback',\n            (agent_logging_callback_t,),\n            result_t,\n            public=False)\n\n        initfn(\n            'stub_xstrerror',\n            (result_t, xchar_p, ctypes.c_size_t),\n            xchar_p,\n            public=False)\n\n\n        initfn(\n            'agent_get_fork_state',\n            (),\n            ctypes.c_int32)\n\n        initfn(\n            'ex_api_enable_techtype',\n            (),\n            result_t,\n            public=False)\n        initfn(\n            'ex_agent_add_process_technology_p',\n            (ctypes.c_int32, CCStringPInArg, CCStringPInArg),\n            None).__doc__ = '''(tech_type, tech_edition, tech_version)'''\n\n        # Specific nodes\n\n        ## Database\n        initfn(\n            'databaseinfo_create_p',\n            (CCStringPInArg, CCStringPInArg, ctypes.c_int32, CCStringPInArg),\n            handle_t).__doc__ = \\\n                '(dbname, dbvendor, chan_ty, chan_ep) -> dbh'\n        initfn(\n            'databaserequesttracer_create_sql_p',\n            (handle_t, CCStringPInArg),\n            handle_t)\n        initfn(\n            'databaserequesttracer_set_returned_row_count',\n            (handle_t, ctypes.c_int32),\n            None)\n        initfn(\n            'databaserequesttracer_set_round_trip_count',\n            (handle_t, ctypes.c_int32),\n            None)\n        initfn(\n            'databaseinfo_delete',\n            (handle_t,),\n            None)\n\n        ## Outgoing remote call\n        initfn(\n            'outgoingremotecalltracer_create_p',\n            (CCStringPInArg, CCStringPInArg, CCStringPInArg,\n             ctypes.c_int32, CCStringPInArg),\n            handle_t).__doc__ = \\\n                '(svcmethod, svcname, svcendpoint, chan_ty, chan_ep) -> tracer'\n        initfn(\n            'outgoingremotecalltracer_set_protocol_name_p',\n            (handle_t, CCStringPInArg),\n            None)\n\n        ## Incoming remote call\n        initfn(\n            'incomingremotecalltracer_create_p',\n            (CCStringPInArg, CCStringPInArg, CCStringPInArg),\n            handle_t).__doc__ = \\\n                '(svc_method, svc_name, svc_endpoint) -> tracer'\n        initfn(\n            'incomingremotecalltracer_set_protocol_name_p',\n            (handle_t, CCStringPInArg),\n            handle_t)\n\n        ## Incoming Webrequest\n        initfn(\n            'webapplicationinfo_create_p',\n            (CCStringPInArg, CCStringPInArg, CCStringPInArg),\n            handle_t).__doc__ = \"(vhost, appid, ctxroot) -> wsh\"\n        initfn(\n            'webapplicationinfo_delete',\n            (handle_t,),\n            None)\n        initfn(\n            'incomingwebrequesttracer_create_p',\n            (handle_t, CCStringPInArg, CCStringPInArg),\n            handle_t).__doc__ = \"(wsh, uri, http_method) -> tracerh\"\n        headerlist_arg_ts = (\n            handle_t,\n            ctypes.POINTER(CCString),\n            ctypes.POINTER(CCString),\n            ctypes.c_size_t)\n        self._wrap_headerlist_fn(initfn(\n            'incomingwebrequesttracer_add_request_headers_p',\n            headerlist_arg_ts,\n            None,\n            public=False))\n        self._wrap_headerlist_fn(initfn(\n            'incomingwebrequesttracer_add_response_headers_p',\n            headerlist_arg_ts,\n            None,\n            public=False))\n        self._wrap_headerlist_fn(initfn(\n            'incomingwebrequesttracer_add_parameters_p',\n            headerlist_arg_ts,\n            None,\n            public=False))\n        initfn(\n            'incomingwebrequesttracer_set_remote_address_p',\n            (handle_t, CCStringPInArg),\n            None)\n        initfn(\n            'incomingwebrequesttracer_set_status_code',\n            (handle_t, ctypes.c_int32),\n            None)\n\n        # inprocess linking\n        initfn(\n            'inprocesslink_create',\n            (ctypes.c_char_p, ctypes.c_size_t, c_size_p),\n            ctypes.c_size_t,\n            public=False).__doc__ = \\\n                '(buffer, buffer_size, required_buffer_size) -> required_buffer_size'\n\n        initfn(\n            'inprocesslinktracer_create',\n            (ctypes.c_char_p, ctypes.c_size_t),\n            handle_t,\n            public=False).__doc__ = \\\n                '(in_process_link_bytes, in_process_link_size) -> tracer'\n\n        # outgoing web request\n        initfn(\n            'outgoingwebrequesttracer_create_p',\n            (CCStringPInArg, CCStringPInArg),\n            handle_t).__doc__ = \\\n                '(url, method) -> tracer'\n\n        self._wrap_headerlist_fn(initfn(\n            'outgoingwebrequesttracer_add_request_headers_p',\n            headerlist_arg_ts,\n            None,\n            public=False))\n\n        self._wrap_headerlist_fn(initfn(\n            'outgoingwebrequesttracer_add_response_headers_p',\n            headerlist_arg_ts,\n            None,\n            public=False))\n\n        initfn(\n            'outgoingwebrequesttracer_set_status_code',\n            (handle_t, ctypes.c_int32),\n            None)\n\n        # Generic nodes\n        initfn(\n            'tracer_start',\n            (handle_t,),\n            None)\n        initfn(\n            'tracer_end',\n            (handle_t,),\n            None)\n        initfn(\n            'tracer_error_p',\n            (handle_t, CCStringPInArg, CCStringPInArg),\n            None).__doc__ = \\\n                '''Mark tracer handle as failed with given error_class and\n                error_message.\n\n                tracer_end still needs to be called on the handle.'''\n        initfn(\n            'tracer_get_outgoing_dynatrace_string_tag',\n            (handle_t, ctypes.c_char_p, ctypes.c_size_t, c_size_p),\n            ctypes.c_size_t,\n            public=False)\n\n        # We just handle unsigned char* as char*\n        initfn(\n            'tracer_get_outgoing_dynatrace_byte_tag',\n            (handle_t, ctypes.c_char_p, ctypes.c_size_t, c_size_p),\n            ctypes.c_size_t,\n            public=False)\n\n        self.tracer_set_incoming_string_tag = initfn(\n            'tracer_set_incoming_dynatrace_string_tag_p',\n            (handle_t, CCStringPInArg),\n            None,\n            public=False)\n\n        initfn(\n            'tracer_set_incoming_dynatrace_byte_tag',\n            (handle_t, ctypes.c_char_p, ctypes.c_size_t),\n            None,\n            public=False)\n\n        # SCAV - custom request attributes\n        self._wrap_typed_headerlist_fn(initfn(\n            'customrequestattribute_add_integers_p',\n            (ctypes.POINTER(CCString), c_int64_p, ctypes.c_size_t),\n            None,\n            public=False), ctypes.c_int64)\n\n        self._wrap_typed_headerlist_fn(initfn(\n            'customrequestattribute_add_floats_p',\n            (ctypes.POINTER(CCString), c_double_p, ctypes.c_size_t),\n            None,\n            public=False), ctypes.c_double)\n\n        self._wrap_typed_headerlist_fn(initfn(\n            'customrequestattribute_add_strings_p',\n            (ctypes.POINTER(CCString), ctypes.POINTER(CCString), ctypes.c_size_t),\n            None,\n            public=False), CCString)\n\n        self._init_messaging()\n\n        self._init_custom_service()\n\n        self._init_trace_context()\n",
    "pattern_analysis": {
      "api_sequence": [
        "ctypes.WinDLL",
        "ctypes.CDLL",
        "getattr",
        "setattr"
      ],
      "api_sequence_with_args": [
        "ctypes.WinDLL(libname)",
        "ctypes.CDLL(libname)",
        "getattr(self._dll, fullname)",
        "setattr(self, name, func)"
      ],
      "mapped_sequence": [
        {
          "api_name": "ctypes.WinDLL",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "ctypes.CDLL",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "getattr",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "setattr",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        }
      ],
      "contextual_code": "class SDKDllInterface(object):\n    def _initfn(self, name, args, ret, public=True, check=False):\n        fullname = self._ONESDK_PREFIX + name\n        if check and not hasattr(self._dll, fullname):\n            msg = 'Unable to find function '+ fullname + ' in the OneAgent SDK for C/C++'\n            raise SDKInitializationError(ErrorCode.INVALID_AGENT_BINARY, msg)\n        func = getattr(self._dll, fullname)\n        func.argtypes = args\n        func.restype = ret\n        name = self._fn_basename(fullname)\n        if not public:\n            name = '_' + name\n        setattr(self, name, func)\n        return func\n\n    def __init__(self, libname):\n        self._dll = ctypes.WinDLL(libname) if WIN32 else ctypes.CDLL(libname)\n        initfn = self._initfn\n        # ... (calls to initfn, which uses getattr/setattr as above)"
    }
  }
]