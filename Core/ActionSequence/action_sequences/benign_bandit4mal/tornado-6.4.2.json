[
  {
    "metadata": {
      "package_name": "tornado-6.4.2",
      "total_matches": 3,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "httpclient_test.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/tornado-6.4.2/tornado-6.4.2/tornado/test/httpclient_test.py",
    "line_number": "53",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "52\t    def put(self):\n53\t        self.write(\"Put body: \")\n54\t        self.write(self.request.body)",
    "code_snippet": "class PutHandler(RequestHandler):\n    def put(self):\n        self.write(\"Put body: \")\n        self.write(self.request.body)",
    "pattern_analysis": {
      "api_sequence": [],
      "api_sequence_with_args": [],
      "mapped_sequence": [],
      "contextual_code": "class PutHandler(RequestHandler):\n    def put(self):\n        self.write(\"Put body: \")\n        self.write(self.request.body)"
    }
  },
  {
    "pyfile": "asyncio_test.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/tornado-6.4.2/tornado-6.4.2/tornado/test/asyncio_test.py",
    "line_number": "209",
    "type_description": "B840:executor",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "208\t        self.orig_policy = asyncio.get_event_loop_policy()\n209\t        self.executor = ThreadPoolExecutor(1)\n210",
    "code_snippet": "class AnyThreadEventLoopPolicyTest(unittest.TestCase):\n    def setUp(self):\n        self.orig_policy = asyncio.get_event_loop_policy()\n        self.executor = ThreadPoolExecutor(1)\n",
    "pattern_analysis": {
      "api_sequence": [
        "asyncio.get_event_loop_policy",
        "concurrent.futures.ThreadPoolExecutor"
      ],
      "api_sequence_with_args": [
        "asyncio.get_event_loop_policy()",
        "concurrent.futures.ThreadPoolExecutor(1)"
      ],
      "mapped_sequence": [
        {
          "api_name": "asyncio.get_event_loop_policy",
          "id": "run_async_function",
          "description": "Runs asynchronous function until completion",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "concurrent.futures.ThreadPoolExecutor",
          "id": "init_thread_pool",
          "description": "Initializes thread pool executor with specified worker count",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_pool_management"
        }
      ],
      "contextual_code": "class AnyThreadEventLoopPolicyTest(unittest.TestCase):\n    def setUp(self):\n        self.orig_policy = asyncio.get_event_loop_policy()\n        self.executor = ThreadPoolExecutor(1)"
    }
  },
  {
    "pyfile": "tcpclient_test.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/tornado-6.4.2/tornado-6.4.2/tornado/test/tcpclient_test.py",
    "line_number": "334",
    "type_description": "B804:connect",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "333\t        self.assert_pending((AF1, \"a\"), (AF2, \"d\"))\n334\t        self.resolve_connect(AF2, \"d\", False)\n335\t        # one queue is now empty",
    "code_snippet": "def test_all_fail(self):\n    conn, future = self.start_connect(self.addrinfo)\n    self.assert_pending((AF1, \"a\"))\n    conn.on_timeout()\n    self.assert_pending((AF1, \"a\"), (AF2, \"c\"))\n    self.resolve_connect(AF2, \"c\", False)\n    self.assert_pending((AF1, \"a\"), (AF2, \"d\"))\n    self.resolve_connect(AF2, \"d\", False)\n    # one queue is now empty\n    self.assert_pending((AF1, \"a\"))\n    self.resolve_connect(AF1, \"a\", False)\n    self.assert_pending((AF1, \"b\"))\n    self.assertFalse(future.done())\n    self.resolve_connect(AF1, \"b\", False)\n    self.assertRaises(IOError, future.result)",
    "pattern_analysis": {
      "api_sequence": [
        "self.start_connect",
        "self.assert_pending",
        "conn.on_timeout",
        "self.assert_pending",
        "self.resolve_connect",
        "self.assert_pending",
        "self.resolve_connect",
        "self.assert_pending",
        "self.resolve_connect",
        "self.assert_pending",
        "future.done",
        "self.resolve_connect",
        "self.assertRaises"
      ],
      "api_sequence_with_args": [
        "self.start_connect(self.addrinfo)",
        "self.assert_pending((AF1, \"a\"))",
        "conn.on_timeout()",
        "self.assert_pending((AF1, \"a\"), (AF2, \"c\"))",
        "self.resolve_connect(AF2, \"c\", False)",
        "self.assert_pending((AF1, \"a\"), (AF2, \"d\"))",
        "self.resolve_connect(AF2, \"d\", False)",
        "self.assert_pending((AF1, \"a\"))",
        "self.resolve_connect(AF1, \"a\", False)",
        "self.assert_pending((AF1, \"b\"))",
        "future.done()",
        "self.resolve_connect(AF1, \"b\", False)",
        "self.assertRaises(IOError, future.result)"
      ],
      "mapped_sequence": [
        {
          "api_name": "future.done",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "self.assertRaises",
          "id": "error_handling_operations",
          "description": "File opening operations with error handling (ignore errors, custom error handling, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        }
      ],
      "contextual_code": "def test_all_fail(self):\n    conn, future = self.start_connect(self.addrinfo)\n    self.assert_pending((AF1, \"a\"))\n    conn.on_timeout()\n    self.assert_pending((AF1, \"a\"), (AF2, \"c\"))\n    self.resolve_connect(AF2, \"c\", False)\n    self.assert_pending((AF1, \"a\"), (AF2, \"d\"))\n    self.resolve_connect(AF2, \"d\", False)\n    self.assert_pending((AF1, \"a\"))\n    self.resolve_connect(AF1, \"a\", False)\n    self.assert_pending((AF1, \"b\"))\n    self.assertFalse(future.done())\n    self.resolve_connect(AF1, \"b\", False)\n    self.assertRaises(IOError, future.result)"
    }
  }
]