[
  {
    "metadata": {
      "package_name": "ete3-3.1.3",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "ete_evol.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ete3-3.1.3/ete3-3.1.3/ete3/tools/ete_evol.py",
    "line_number": "655",
    "type_description": "B828:signal",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "654\t    proc = None\n655\t    signal(SIGINT, clean_exit)\n656",
    "code_snippet": "def local_run_model(tree, model_name, binary, ctrl_string='', **kwargs):\n    '''\n    local verison of model runner. Needed for multiprocessing pickling...\n    '''\n    def clean_exit(a, b):\n        if proc:\n            print(\"Killing process %s\" %proc)\n            proc.terminate()\n            proc.kill(-9)\n        exit(a, b)\n    proc = None\n    signal(SIGINT, clean_exit)\n\n    model_obj = Model(model_name, tree, **kwargs)\n    # dir_name = model_obj.name\n    fullpath = os.path.join (tree.workdir, name_model(tree, model_obj.name))\n    os.system(\"mkdir -p %s\" % fullpath)\n    # write tree file\n    tree._write_algn(fullpath + '/algn')\n    if model_obj.properties['exec'] == 'Slr':\n        tree.write(outfile=fullpath+'/tree', format=11)\n    else:\n        tree.write(outfile=fullpath+'/tree',\n                   format = (10 if model_obj.properties['allow_mark'] else 9))\n    # write algn file\n    if ctrl_string == '':\n        ctrl_string = model_obj.get_ctrl_string(fullpath+'/tmp.ctl')\n    else:\n        open(fullpath+'/tmp.ctl', 'w').write(ctrl_string)\n    hlddir = os.getcwd()\n    os.chdir(fullpath)\n\n    proc = Popen(\"%s tmp.ctl\" %binary, stdout=PIPE, stdin=PIPE, shell=True)\n    proc.stdin.write(b'\\n') # in case codeml/slr asks something\n    job, err = proc.communicate()\n    if err is not None or b'error' in job or b'Error' in job:\n        print((b\"ERROR: inside CodeML!!\\n\" + job).decode())\n        return (None, None)\n    os.chdir(hlddir)\n    return os.path.join(fullpath, 'out'), model_obj.name",
    "pattern_analysis": {
      "api_sequence": [
        "signal",
        "os.path.join",
        "os.system",
        "tree._write_algn",
        "open",
        "os.getcwd",
        "os.chdir",
        "Popen",
        "Popen.stdin.write",
        "Popen.communicate",
        "os.chdir",
        "os.path.join"
      ],
      "api_sequence_with_args": [
        "signal(SIGINT, clean_exit)",
        "os.path.join(tree.workdir, name_model(tree, model_obj.name))",
        "os.system(\"mkdir -p %s\" % fullpath)",
        "tree._write_algn(fullpath + '/algn')",
        "open(fullpath+'/tmp.ctl', 'w').write(ctrl_string)",
        "os.getcwd()",
        "os.chdir(fullpath)",
        "Popen(\"%s tmp.ctl\" %binary, stdout=PIPE, stdin=PIPE, shell=True)",
        "proc.stdin.write(b'\\n')",
        "proc.communicate()",
        "os.chdir(hlddir)",
        "os.path.join(fullpath, 'out')"
      ],
      "mapped_sequence": [
        {
          "api_name": "signal",
          "id": "register_exit_function",
          "description": "Registers function to be called at program exit",
          "first_id": "persistence_stealth",
          "second_id": "persistence_mechanisms",
          "third_id": "persistence_configuration"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.system",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "tree._write_algn",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "os.getcwd",
          "id": "get_working_dir",
          "description": "Returns current working directory",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.chdir",
          "id": "change_working_dir",
          "description": "Changes current working directory",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "Popen",
          "id": "spawn_process_shell",
          "description": "Spawns new process to execute command with shell access",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_reception"
        },
        {
          "api_name": "Popen.stdin.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "Popen.communicate",
          "id": "read_process_stdout",
          "description": "Reads all bytes from process standard output",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "os.chdir",
          "id": "change_working_dir",
          "description": "Changes current working directory",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        }
      ],
      "contextual_code": "def local_run_model(tree, model_name, binary, ctrl_string='', **kwargs):\n    def clean_exit(a, b):\n        if proc:\n            print(\"Killing process %s\" %proc)\n            proc.terminate()\n            proc.kill(-9)\n        exit(a, b)\n    proc = None\n    signal(SIGINT, clean_exit)\n\n    model_obj = Model(model_name, tree, **kwargs)\n    fullpath = os.path.join(tree.workdir, name_model(tree, model_obj.name))\n    os.system(\"mkdir -p %s\" % fullpath)\n    tree._write_algn(fullpath + '/algn')\n    if model_obj.properties['exec'] == 'Slr':\n        tree.write(outfile=fullpath+'/tree', format=11)\n    else:\n        tree.write(outfile=fullpath+'/tree',\n                   format = (10 if model_obj.properties['allow_mark'] else 9))\n    if ctrl_string == '':\n        ctrl_string = model_obj.get_ctrl_string(fullpath+'/tmp.ctl')\n    else:\n        open(fullpath+'/tmp.ctl', 'w').write(ctrl_string)\n    hlddir = os.getcwd()\n    os.chdir(fullpath)\n\n    proc = Popen(\"%s tmp.ctl\" %binary, stdout=PIPE, stdin=PIPE, shell=True)\n    proc.stdin.write(b'\\n')\n    job, err = proc.communicate()\n    if err is not None or b'error' in job or b'Error' in job:\n        print((b\"ERROR: inside CodeML!!\\n\" + job).decode())\n        return (None, None)\n    os.chdir(hlddir)\n    return os.path.join(fullpath, 'out'), model_obj.name"
    }
  },
  {
    "pyfile": "ete_build.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ete3-3.1.3/ete3-3.1.3/ete3/tools/ete_build.py",
    "line_number": "641",
    "type_description": "B812:system",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "640\t              GLOBALS[\"basedir\"]\n641\t            os.system(cmd)\n642\t        log.log(28, \"Deleting temporal data...\")",
    "code_snippet": "def main(args):\n    \"\"\" Read and parse all configuration and command line options,\n    setup global variables and data, and initialize the master task of\n    all workflows. \"\"\"\n\n    global log\n    log = logging.getLogger(\"main\")\n\n    base_dir = GLOBALS[\"basedir\"]\n    ...\n    if not thread_errors:\n        if GLOBALS.get('_background_scheduler', None):\n            GLOBALS['_background_scheduler'].terminate()\n\n        if args.compress:\n            log.log(28, \"Compressing intermediate data...\")\n            cmd = \"cd %s && tar --remove-files -cf etebuild_data.tar tasks/ && gzip -f etebuild_data.tar; if [ -e etebuild.log ]; then gzip -f etebuild.log; fi;\" %\\\n              GLOBALS[\"basedir\"]\n            os.system(cmd)\n        log.log(28, \"Deleting temporal data...\")\n        cmd = \"cd %s && rm -rf tmp/\" %GLOBALS[\"basedir\"]\n        os.system(cmd)\n        cmd = \"cd %s && rm -rf input/\" %GLOBALS[\"basedir\"]\n        os.system(cmd)\n        GLOBALS[\"citator\"].show()\n    else:\n        raise DataError(\"Errors found in some tasks\")",
    "pattern_analysis": {
      "api_sequence": [
        "logging.getLogger",
        "os.system",
        "os.system",
        "os.system"
      ],
      "api_sequence_with_args": [
        "logging.getLogger(\"main\")",
        "os.system(cmd)  # cmd = \"cd %s && tar --remove-files -cf etebuild_data.tar tasks/ && gzip -f etebuild_data.tar; if [ -e etebuild.log ]; then gzip -f etebuild.log; fi;\" % GLOBALS[\"basedir\"]",
        "os.system(cmd)  # cmd = \"cd %s && rm -rf tmp/\" % GLOBALS[\"basedir\"]",
        "os.system(cmd)  # cmd = \"cd %s && rm -rf input/\" % GLOBALS[\"basedir\"]"
      ],
      "mapped_sequence": [
        {
          "api_name": "logging.getLogger",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "os.system",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "os.system",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "os.system",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        }
      ],
      "contextual_code": "def main(args):\n    global log\n    log = logging.getLogger(\"main\")\n    base_dir = GLOBALS[\"basedir\"]\n    ...\n    if not thread_errors:\n        if GLOBALS.get('_background_scheduler', None):\n            GLOBALS['_background_scheduler'].terminate()\n\n        if args.compress:\n            log.log(28, \"Compressing intermediate data...\")\n            cmd = \"cd %s && tar --remove-files -cf etebuild_data.tar tasks/ && gzip -f etebuild_data.tar; if [ -e etebuild.log ]; then gzip -f etebuild.log; fi;\" % GLOBALS[\"basedir\"]\n            os.system(cmd)\n        log.log(28, \"Deleting temporal data...\")\n        cmd = \"cd %s && rm -rf tmp/\" % GLOBALS[\"basedir\"]\n        os.system(cmd)\n        cmd = \"cd %s && rm -rf input/\" % GLOBALS[\"basedir\"]\n        os.system(cmd)\n        GLOBALS[\"citator\"].show()\n    else:\n        raise DataError(\"Errors found in some tasks\")"
    }
  }
]