[
  {
    "metadata": {
      "package_name": "google_cloud_aiplatform-1.88.0",
      "total_matches": 15,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "test_model_service.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/tests/unit/gapic/aiplatform_v1beta1/test_model_service.py",
    "line_number": "18969",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "18968\t        field = subfield_to_delete.get(\"field\")\n18969\t        field_repeated = subfield_to_delete.get(\"is_repeated\")\n18970\t        subfield = subfield_to_delete.get(\"subfield\")",
    "code_snippet": "    for subfield_to_delete in subfields_not_in_runtime:  # pragma: NO COVER\n        field = subfield_to_delete.get(\"field\")\n        field_repeated = subfield_to_delete.get(\"is_repeated\")\n        subfield = subfield_to_delete.get(\"subfield\")\n        if subfield:\n            if field_repeated:\n                for i in range(0, len(request_init[\"model\"][field])):\n                    del request_init[\"model\"][field][i][subfield]\n            else:\n                del request_init[\"model\"][field][subfield]",
    "pattern_analysis": {
      "api_sequence": [],
      "api_sequence_with_args": [],
      "mapped_sequence": [],
      "contextual_code": "for subfield_to_delete in subfields_not_in_runtime:\n    field = subfield_to_delete.get(\"field\")\n    field_repeated = subfield_to_delete.get(\"is_repeated\")\n    subfield = subfield_to_delete.get(\"subfield\")\n    if subfield:\n        if field_repeated:\n            for i in range(0, len(request_init[\"model\"][field])):\n                del request_init[\"model\"][field][i][subfield]\n        else:\n            del request_init[\"model\"][field][subfield]"
    }
  },
  {
    "pyfile": "test_job_service.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/tests/unit/gapic/aiplatform_v1beta1/test_job_service.py",
    "line_number": "25286",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "25285\t        field = subfield_to_delete.get(\"field\")\n25286\t        field_repeated = subfield_to_delete.get(\"is_repeated\")\n25287\t        subfield = subfield_to_delete.get(\"subfield\")",
    "code_snippet": "    for subfield_to_delete in subfields_not_in_runtime:  # pragma: NO COVER\n        field = subfield_to_delete.get(\"field\")\n        field_repeated = subfield_to_delete.get(\"is_repeated\")\n        subfield = subfield_to_delete.get(\"subfield\")\n        if subfield:\n            if field_repeated:\n                for i in range(0, len(request_init[\"custom_job\"][field])):\n                    del request_init[\"custom_job\"][field][i][subfield]\n            else:\n                del request_init[\"custom_job\"][field][subfield]",
    "pattern_analysis": {
      "api_sequence": [],
      "api_sequence_with_args": [],
      "mapped_sequence": [],
      "contextual_code": "for subfield_to_delete in subfields_not_in_runtime:  # pragma: NO COVER\n    field = subfield_to_delete.get(\"field\")\n    field_repeated = subfield_to_delete.get(\"is_repeated\")\n    subfield = subfield_to_delete.get(\"subfield\")\n    if subfield:\n        if field_repeated:\n            for i in range(0, len(request_init[\"custom_job\"][field])):\n                del request_init[\"custom_job\"][field][i][subfield]\n        else:\n            del request_init[\"custom_job\"][field][subfield]"
    }
  },
  {
    "pyfile": "test_schedule_service.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/tests/unit/gapic/aiplatform_v1beta1/test_schedule_service.py",
    "line_number": "8571",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "8570\t        field = subfield_to_delete.get(\"field\")\n8571\t        field_repeated = subfield_to_delete.get(\"is_repeated\")\n8572\t        subfield = subfield_to_delete.get(\"subfield\")",
    "code_snippet": "    for subfield_to_delete in subfields_not_in_runtime:  # pragma: NO COVER\n        field = subfield_to_delete.get(\"field\")\n        field_repeated = subfield_to_delete.get(\"is_repeated\")\n        subfield = subfield_to_delete.get(\"subfield\")\n        if subfield:\n            if field_repeated:\n                for i in range(0, len(request_init[\"schedule\"][field])):\n                    del request_init[\"schedule\"][field][i][subfield]\n            else:\n                del request_init[\"schedule\"][field][subfield]",
    "pattern_analysis": {
      "api_sequence": [],
      "api_sequence_with_args": [],
      "mapped_sequence": [],
      "contextual_code": "for subfield_to_delete in subfields_not_in_runtime:\n    field = subfield_to_delete.get(\"field\")\n    field_repeated = subfield_to_delete.get(\"is_repeated\")\n    subfield = subfield_to_delete.get(\"subfield\")\n    if subfield:\n        if field_repeated:\n            for i in range(0, len(request_init[\"schedule\"][field])):\n                del request_init[\"schedule\"][field][i][subfield]\n        else:\n            del request_init[\"schedule\"][field][subfield]"
    }
  },
  {
    "pyfile": "rest.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/google/cloud/aiplatform_v1beta1/services/deployment_resource_pool_service/transports/rest.py",
    "line_number": "2933",
    "type_description": "B822:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "2932\t            )\n2933\t            transcoded_request = _BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_transcoded_request(\n2934\t                http_options, request\n2935\t            )",
    "code_snippet": "def __call__(\n    self,\n    request: deployment_resource_pool_service.CreateDeploymentResourcePoolRequest,\n    *,\n    retry: OptionalRetry = gapic_v1.method.DEFAULT,\n    timeout: Optional[float] = None,\n    metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n) -> operations_pb2.Operation:\n    r\"\"\"Call the create deployment\n    resource pool method over HTTP.\n\n        Args:\n            request (~.deployment_resource_pool_service.CreateDeploymentResourcePoolRequest):\n                The request object. Request message for\n            CreateDeploymentResourcePool method.\n            retry (google.api_core.retry.Retry): Designation of what errors, if any,\n                should be retried.\n            timeout (float): The timeout for this request.\n            metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n                sent along with the request as metadata. Normally, each value must be of type `str`,\n                but for metadata keys ending with the suffix `-bin`, the corresponding values must\n                be of type `bytes`.\n\n        Returns:\n            ~.operations_pb2.Operation:\n                This resource represents a\n            long-running operation that is the\n            result of a network API call.\n\n    \"\"\"\n\n    http_options = (\n        _BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_http_options()\n    )\n\n    request, metadata = self._interceptor.pre_create_deployment_resource_pool(\n        request, metadata\n    )\n    transcoded_request = _BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_transcoded_request(\n        http_options, request\n    )\n\n    body = _BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_request_body_json(\n        transcoded_request\n    )\n\n    # Jsonify the query params\n    query_params = _BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_query_params_json(\n        transcoded_request\n    )\n\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        request_url = \"{host}{uri}\".format(\n            host=self._host, uri=transcoded_request[\"uri\"]\n        )\n        method = transcoded_request[\"method\"]\n        try:\n            request_payload = json_format.MessageToJson(request)\n        except:\n            request_payload = None\n        http_request = {\n            \"payload\": request_payload,\n            \"requestMethod\": method,\n            \"requestUrl\": request_url,\n            \"headers\": dict(metadata),\n        }\n        _LOGGER.debug(\n            f\"Sending request for google.cloud.aiplatform_v1beta1.DeploymentResourcePoolServiceClient.CreateDeploymentResourcePool\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1beta1.DeploymentResourcePoolService\",\n                \"rpcName\": \"CreateDeploymentResourcePool\",\n                \"httpRequest\": http_request,\n                \"metadata\": http_request[\"headers\"],\n            },\n        )\n\n    # Send the request\n    response = DeploymentResourcePoolServiceRestTransport._CreateDeploymentResourcePool._get_response(\n        self._host,\n        metadata,\n        query_params,\n        self._session,\n        timeout,\n        transcoded_request,\n        body,\n    )\n\n    # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n    # subclass.\n    if response.status_code >= 400:\n        raise core_exceptions.from_http_response(response)\n\n    # Return the response\n    resp = operations_pb2.Operation()\n    json_format.Parse(response.content, resp, ignore_unknown_fields=True)\n\n    resp = self._interceptor.post_create_deployment_resource_pool(resp)\n    response_metadata = [(k, str(v)) for k, v in response.headers.items()]\n    (\n        resp,\n        _,\n    ) = self._interceptor.post_create_deployment_resource_pool_with_metadata(\n        resp, response_metadata\n    )\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        try:\n            response_payload = json_format.MessageToJson(resp)\n        except:\n            response_payload = None\n        http_response = {\n            \"payload\": response_payload,\n            \"headers\": dict(response.headers),\n            \"status\": response.status_code,\n        }\n        _LOGGER.debug(\n            \"Received response for google.cloud.aiplatform_v1beta1.DeploymentResourcePoolServiceClient.create_deployment_resource_pool\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1beta1.DeploymentResourcePoolService\",\n                \"rpcName\": \"CreateDeploymentResourcePool\",\n                \"metadata\": http_response[\"headers\"],\n                \"httpResponse\": http_response,\n            },\n        )\n    return resp",
    "pattern_analysis": {
      "api_sequence": [
        "_BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_http_options",
        "self._interceptor.pre_create_deployment_resource_pool",
        "_BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_transcoded_request",
        "_BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_request_body_json",
        "_BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_query_params_json",
        "_LOGGER.isEnabledFor",
        "json_format.MessageToJson",
        "_LOGGER.debug",
        "DeploymentResourcePoolServiceRestTransport._CreateDeploymentResourcePool._get_response",
        "core_exceptions.from_http_response",
        "json_format.Parse",
        "self._interceptor.post_create_deployment_resource_pool",
        "response.headers.items",
        "self._interceptor.post_create_deployment_resource_pool_with_metadata",
        "_LOGGER.isEnabledFor",
        "json_format.MessageToJson",
        "_LOGGER.debug"
      ],
      "api_sequence_with_args": [
        "_BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_http_options()",
        "self._interceptor.pre_create_deployment_resource_pool(request, metadata)",
        "_BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_transcoded_request(http_options, request)",
        "_BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_request_body_json(transcoded_request)",
        "_BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_query_params_json(transcoded_request)",
        "_LOGGER.isEnabledFor(logging.DEBUG)",
        "json_format.MessageToJson(request)",
        "_LOGGER.debug(f\"Sending request for google.cloud.aiplatform_v1beta1.DeploymentResourcePoolServiceClient.CreateDeploymentResourcePool\", extra={...})",
        "DeploymentResourcePoolServiceRestTransport._CreateDeploymentResourcePool._get_response(self._host, metadata, query_params, self._session, timeout, transcoded_request, body)",
        "core_exceptions.from_http_response(response)",
        "json_format.Parse(response.content, resp, ignore_unknown_fields=True)",
        "self._interceptor.post_create_deployment_resource_pool(resp)",
        "response.headers.items()",
        "self._interceptor.post_create_deployment_resource_pool_with_metadata(resp, response_metadata)",
        "_LOGGER.isEnabledFor(logging.DEBUG)",
        "json_format.MessageToJson(resp)",
        "_LOGGER.debug(\"Received response for google.cloud.aiplatform_v1beta1.DeploymentResourcePoolServiceClient.create_deployment_resource_pool\", extra={...})"
      ],
      "mapped_sequence": [
        {
          "api_name": "_BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_http_options",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "self._interceptor.pre_create_deployment_resource_pool",
          "id": "init_parent_class",
          "description": "Initializes parent class with provided arguments",
          "first_id": "code_execution",
          "second_id": "object_initialization",
          "third_id": "class_initialization"
        },
        {
          "api_name": "_BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_transcoded_request",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "_BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_request_body_json",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "_BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_query_params_json",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "_LOGGER.isEnabledFor",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "json_format.MessageToJson",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "_LOGGER.debug",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "DeploymentResourcePoolServiceRestTransport._CreateDeploymentResourcePool._get_response",
          "id": "open_url_post",
          "description": "Opens URL with POST data",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "core_exceptions.from_http_response",
          "id": "raise_http_error",
          "description": "Raises HTTPError if response status code indicates error",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "json_format.Parse",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "self._interceptor.post_create_deployment_resource_pool",
          "id": "init_parent_class",
          "description": "Initializes parent class with provided arguments",
          "first_id": "code_execution",
          "second_id": "object_initialization",
          "third_id": "class_initialization"
        },
        {
          "api_name": "response.headers.items",
          "id": "get_response_body",
          "description": "Retrieves response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "self._interceptor.post_create_deployment_resource_pool_with_metadata",
          "id": "init_parent_class",
          "description": "Initializes parent class with provided arguments",
          "first_id": "code_execution",
          "second_id": "object_initialization",
          "third_id": "class_initialization"
        },
        {
          "api_name": "_LOGGER.isEnabledFor",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "json_format.MessageToJson",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "_LOGGER.debug",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        }
      ],
      "contextual_code": "def __call__(self, request, *, retry=gapic_v1.method.DEFAULT, timeout=None, metadata=()):\n    http_options = _BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_http_options()\n    request, metadata = self._interceptor.pre_create_deployment_resource_pool(request, metadata)\n    transcoded_request = _BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_transcoded_request(http_options, request)\n    body = _BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_request_body_json(transcoded_request)\n    query_params = _BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_query_params_json(transcoded_request)\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(logging.DEBUG):\n        try:\n            request_payload = json_format.MessageToJson(request)\n        except:\n            request_payload = None\n        http_request = {\n            \"payload\": request_payload,\n            \"requestMethod\": transcoded_request[\"method\"],\n            \"requestUrl\": f\"{self._host}{transcoded_request['uri']}\",\n            \"headers\": dict(metadata),\n        }\n        _LOGGER.debug(f\"Sending request for google.cloud.aiplatform_v1beta1.DeploymentResourcePoolServiceClient.CreateDeploymentResourcePool\", extra={...})\n    response = DeploymentResourcePoolServiceRestTransport._CreateDeploymentResourcePool._get_response(self._host, metadata, query_params, self._session, timeout, transcoded_request, body)\n    if response.status_code >= 400:\n        raise core_exceptions.from_http_response(response)\n    resp = operations_pb2.Operation()\n    json_format.Parse(response.content, resp, ignore_unknown_fields=True)\n    resp = self._interceptor.post_create_deployment_resource_pool(resp)\n    response_metadata = [(k, str(v)) for k, v in response.headers.items()]\n    resp, _ = self._interceptor.post_create_deployment_resource_pool_with_metadata(resp, response_metadata)\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(logging.DEBUG):\n        try:\n            response_payload = json_format.MessageToJson(resp)\n        except:\n            response_payload = None\n        http_response = {\n            \"payload\": response_payload,\n            \"headers\": dict(response.headers),\n            \"status\": response.status_code,\n        }\n        _LOGGER.debug(\"Received response for google.cloud.aiplatform_v1beta1.DeploymentResourcePoolServiceClient.create_deployment_resource_pool\", extra={...})\n    return resp"
    }
  },
  {
    "pyfile": "rest.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/google/cloud/aiplatform_v1beta1/services/tensorboard_service/transports/rest.py",
    "line_number": "5342",
    "type_description": "B822:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "5341\t            )\n5342\t            transcoded_request = _BaseTensorboardServiceRestTransport._BaseCreateTensorboardTimeSeries._get_transcoded_request(\n5343\t                http_options, request\n5344\t            )",
    "code_snippet": "def __call__(\n    self,\n    request: tensorboard_service.BatchCreateTensorboardTimeSeriesRequest,\n    *,\n    retry: OptionalRetry = gapic_v1.method.DEFAULT,\n    timeout: Optional[float] = None,\n    metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n) -> tensorboard_service.BatchCreateTensorboardTimeSeriesResponse:\n    r\"\"\"Call the batch create tensorboard\n    time series method over HTTP.\n\n        Args:\n            request (~.tensorboard_service.BatchCreateTensorboardTimeSeriesRequest):\n                The request object. Request message for\n            [TensorboardService.BatchCreateTensorboardTimeSeries][google.cloud.aiplatform.v1beta1.TensorboardService.BatchCreateTensorboardTimeSeries].\n            retry (google.api_core.retry.Retry): Designation of what errors, if any,\n                should be retried.\n            timeout (float): The timeout for this request.\n            metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n                sent along with the request as metadata. Normally, each value must be of type `str`,\n                but for metadata keys ending with the suffix `-bin`, the corresponding values must\n                be of type `bytes`.\n\n        Returns:\n            ~.tensorboard_service.BatchCreateTensorboardTimeSeriesResponse:\n                Response message for\n            [TensorboardService.BatchCreateTensorboardTimeSeries][google.cloud.aiplatform.v1beta1.TensorboardService.BatchCreateTensorboardTimeSeries].\n\n    \"\"\"\n\n    http_options = (\n        _BaseTensorboardServiceRestTransport._BaseBatchCreateTensorboardTimeSeries._get_http_options()\n    )\n\n    (\n        request,\n        metadata,\n    ) = self._interceptor.pre_batch_create_tensorboard_time_series(\n        request, metadata\n    )\n    transcoded_request = _BaseTensorboardServiceRestTransport._BaseCreateTensorboardTimeSeries._get_transcoded_request(\n        http_options, request\n    )\n\n    body = _BaseTensorboardServiceRestTransport._BaseBatchCreateTensorboardTimeSeries._get_request_body_json(\n        transcoded_request\n    )\n\n    # Jsonify the query params\n    query_params = _BaseTensorboardServiceRestTransport._BaseBatchCreateTensorboardTimeSeries._get_query_params_json(\n        transcoded_request\n    )\n\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        request_url = \"{host}{uri}\".format(\n            host=self._host, uri=transcoded_request[\"uri\"]\n        )\n        method = transcoded_request[\"method\"]\n        try:\n            request_payload = type(request).to_json(request)\n        except:\n            request_payload = None\n        http_request = {\n            \"payload\": request_payload,\n            \"requestMethod\": method,\n            \"requestUrl\": request_url,\n            \"headers\": dict(metadata),\n        }\n        _LOGGER.debug(\n            f\"Sending request for google.cloud.aiplatform_v1beta1.TensorboardServiceClient.BatchCreateTensorboardTimeSeries\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1beta1.TensorboardService\",\n                \"rpcName\": \"BatchCreateTensorboardTimeSeries\",\n                \"httpRequest\": http_request,\n                \"metadata\": http_request[\"headers\"],\n            },\n        )\n\n    # Send the request\n    response = TensorboardServiceRestTransport._BatchCreateTensorboardTimeSeries._get_response(\n        self._host,\n        metadata,\n        query_params,\n        self._session,\n        timeout,\n        transcoded_request,\n        body,\n    )\n\n    # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n    # subclass.\n    if response.status_code >= 400:\n        raise core_exceptions.from_http_response(response)\n\n    # Return the response\n    resp = tensorboard_service.BatchCreateTensorboardTimeSeriesResponse()\n    pb_resp = tensorboard_service.BatchCreateTensorboardTimeSeriesResponse.pb(\n        resp\n    )\n\n    json_format.Parse(response.content, pb_resp, ignore_unknown_fields=True)\n\n    resp = self._interceptor.post_batch_create_tensorboard_time_series(resp)\n    response_metadata = [(k, str(v)) for k, v in response.headers.items()]\n    (\n        resp,\n        _,\n    ) = self._interceptor.post_batch_create_tensorboard_time_series_with_metadata(\n        resp, response_metadata\n    )\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        try:\n            response_payload = tensorboard_service.BatchCreateTensorboardTimeSeriesResponse.to_json(\n                response\n            )\n        except:\n            response_payload = None\n        http_response = {\n            \"payload\": response_payload,\n            \"headers\": dict(response.headers),\n            \"status\": response.status_code,\n        }\n        _LOGGER.debug(\n            \"Received response for google.cloud.aiplatform_v1beta1.TensorboardServiceClient.batch_create_tensorboard_time_series\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1beta1.TensorboardService\",\n                \"rpcName\": \"BatchCreateTensorboardTimeSeries\",\n                \"metadata\": http_response[\"headers\"],\n                \"httpResponse\": http_response,\n            },\n        )\n    return resp",
    "pattern_analysis": {
      "api_sequence": [
        "_BaseTensorboardServiceRestTransport._BaseBatchCreateTensorboardTimeSeries._get_http_options",
        "self._interceptor.pre_batch_create_tensorboard_time_series",
        "_BaseTensorboardServiceRestTransport._BaseCreateTensorboardTimeSeries._get_transcoded_request",
        "_BaseTensorboardServiceRestTransport._BaseBatchCreateTensorboardTimeSeries._get_request_body_json",
        "_BaseTensorboardServiceRestTransport._BaseBatchCreateTensorboardTimeSeries._get_query_params_json",
        "_LOGGER.isEnabledFor",
        "type.to_json",
        "_LOGGER.debug",
        "TensorboardServiceRestTransport._BatchCreateTensorboardTimeSeries._get_response",
        "core_exceptions.from_http_response",
        "tensorboard_service.BatchCreateTensorboardTimeSeriesResponse",
        "tensorboard_service.BatchCreateTensorboardTimeSeriesResponse.pb",
        "json_format.Parse",
        "self._interceptor.post_batch_create_tensorboard_time_series",
        "response.headers.items",
        "self._interceptor.post_batch_create_tensorboard_time_series_with_metadata",
        "tensorboard_service.BatchCreateTensorboardTimeSeriesResponse.to_json",
        "_LOGGER.debug"
      ],
      "api_sequence_with_args": [
        "_BaseTensorboardServiceRestTransport._BaseBatchCreateTensorboardTimeSeries._get_http_options()",
        "self._interceptor.pre_batch_create_tensorboard_time_series(request, metadata)",
        "_BaseTensorboardServiceRestTransport._BaseCreateTensorboardTimeSeries._get_transcoded_request(http_options, request)",
        "_BaseTensorboardServiceRestTransport._BaseBatchCreateTensorboardTimeSeries._get_request_body_json(transcoded_request)",
        "_BaseTensorboardServiceRestTransport._BaseBatchCreateTensorboardTimeSeries._get_query_params_json(transcoded_request)",
        "_LOGGER.isEnabledFor(logging.DEBUG)",
        "type(request).to_json(request)",
        "_LOGGER.debug(f\"Sending request for google.cloud.aiplatform_v1beta1.TensorboardServiceClient.BatchCreateTensorboardTimeSeries\", extra={...})",
        "TensorboardServiceRestTransport._BatchCreateTensorboardTimeSeries._get_response(self._host, metadata, query_params, self._session, timeout, transcoded_request, body)",
        "core_exceptions.from_http_response(response)",
        "tensorboard_service.BatchCreateTensorboardTimeSeriesResponse()",
        "tensorboard_service.BatchCreateTensorboardTimeSeriesResponse.pb(resp)",
        "json_format.Parse(response.content, pb_resp, ignore_unknown_fields=True)",
        "self._interceptor.post_batch_create_tensorboard_time_series(resp)",
        "response.headers.items()",
        "self._interceptor.post_batch_create_tensorboard_time_series_with_metadata(resp, response_metadata)",
        "tensorboard_service.BatchCreateTensorboardTimeSeriesResponse.to_json(response)",
        "_LOGGER.debug(\"Received response for google.cloud.aiplatform_v1beta1.TensorboardServiceClient.batch_create_tensorboard_time_series\", extra={...})"
      ],
      "mapped_sequence": [
        {
          "api_name": "_BaseTensorboardServiceRestTransport._BaseBatchCreateTensorboardTimeSeries._get_http_options",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "self._interceptor.pre_batch_create_tensorboard_time_series",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "_BaseTensorboardServiceRestTransport._BaseCreateTensorboardTimeSeries._get_transcoded_request",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "_BaseTensorboardServiceRestTransport._BaseBatchCreateTensorboardTimeSeries._get_request_body_json",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "_BaseTensorboardServiceRestTransport._BaseBatchCreateTensorboardTimeSeries._get_query_params_json",
          "id": "encode_url_query",
          "description": "Encodes mapping object to URL query string",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "_LOGGER.isEnabledFor",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "type.to_json",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "_LOGGER.debug",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "TensorboardServiceRestTransport._BatchCreateTensorboardTimeSeries._get_response",
          "id": "open_url_post",
          "description": "Opens URL with POST data",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "core_exceptions.from_http_response",
          "id": "raise_http_error",
          "description": "Raises HTTPError if response status code indicates error",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "tensorboard_service.BatchCreateTensorboardTimeSeriesResponse",
          "id": "deserialize_json_response",
          "description": "Deserializes JSON response body to Python object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "tensorboard_service.BatchCreateTensorboardTimeSeriesResponse.pb",
          "id": "deserialize_json_response",
          "description": "Deserializes JSON response body to Python object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "json_format.Parse",
          "id": "deserialize_json_response",
          "description": "Deserializes JSON response body to Python object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "self._interceptor.post_batch_create_tensorboard_time_series",
          "id": "deserialize_json_response",
          "description": "Deserializes JSON response body to Python object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "response.headers.items",
          "id": "get_response_body",
          "description": "Retrieves response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "self._interceptor.post_batch_create_tensorboard_time_series_with_metadata",
          "id": "deserialize_json_response",
          "description": "Deserializes JSON response body to Python object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "tensorboard_service.BatchCreateTensorboardTimeSeriesResponse.to_json",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "_LOGGER.debug",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        }
      ],
      "contextual_code": "def __call__(self, request, *, retry=gapic_v1.method.DEFAULT, timeout=None, metadata=()):\n    http_options = _BaseTensorboardServiceRestTransport._BaseBatchCreateTensorboardTimeSeries._get_http_options()\n    (request, metadata) = self._interceptor.pre_batch_create_tensorboard_time_series(request, metadata)\n    transcoded_request = _BaseTensorboardServiceRestTransport._BaseCreateTensorboardTimeSeries._get_transcoded_request(http_options, request)\n    body = _BaseTensorboardServiceRestTransport._BaseBatchCreateTensorboardTimeSeries._get_request_body_json(transcoded_request)\n    query_params = _BaseTensorboardServiceRestTransport._BaseBatchCreateTensorboardTimeSeries._get_query_params_json(transcoded_request)\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(logging.DEBUG):\n        request_url = \"{host}{uri}\".format(host=self._host, uri=transcoded_request[\"uri\"])\n        method = transcoded_request[\"method\"]\n        try:\n            request_payload = type(request).to_json(request)\n        except:\n            request_payload = None\n        http_request = {\n            \"payload\": request_payload,\n            \"requestMethod\": method,\n            \"requestUrl\": request_url,\n            \"headers\": dict(metadata),\n        }\n        _LOGGER.debug(f\"Sending request for google.cloud.aiplatform_v1beta1.TensorboardServiceClient.BatchCreateTensorboardTimeSeries\", extra={...})\n    response = TensorboardServiceRestTransport._BatchCreateTensorboardTimeSeries._get_response(self._host, metadata, query_params, self._session, timeout, transcoded_request, body)\n    if response.status_code >= 400:\n        raise core_exceptions.from_http_response(response)\n    resp = tensorboard_service.BatchCreateTensorboardTimeSeriesResponse()\n    pb_resp = tensorboard_service.BatchCreateTensorboardTimeSeriesResponse.pb(resp)\n    json_format.Parse(response.content, pb_resp, ignore_unknown_fields=True)\n    resp = self._interceptor.post_batch_create_tensorboard_time_series(resp)\n    response_metadata = [(k, str(v)) for k, v in response.headers.items()]\n    (resp, _) = self._interceptor.post_batch_create_tensorboard_time_series_with_metadata(resp, response_metadata)\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(logging.DEBUG):\n        try:\n            response_payload = tensorboard_service.BatchCreateTensorboardTimeSeriesResponse.to_json(response)\n        except:\n            response_payload = None\n        http_response = {\n            \"payload\": response_payload,\n            \"headers\": dict(response.headers),\n            \"status\": response.status_code,\n        }\n        _LOGGER.debug(\"Received response for google.cloud.aiplatform_v1beta1.TensorboardServiceClient.batch_create_tensorboard_time_series\", extra={...})\n    return resp"
    }
  },
  {
    "pyfile": "rest.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/google/cloud/aiplatform_v1beta1/services/metadata_service/transports/rest.py",
    "line_number": "5809",
    "type_description": "B822:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "5808\t            request, metadata = self._interceptor.pre_delete_context(request, metadata)\n5809\t            transcoded_request = _BaseMetadataServiceRestTransport._BaseDeleteContext._get_transcoded_request(\n5810\t                http_options, request\n5811\t            )",
    "code_snippet": "class _DeleteContext(\n    _BaseMetadataServiceRestTransport._BaseDeleteContext, MetadataServiceRestStub\n):\n    def __hash__(self):\n        return hash(\"MetadataServiceRestTransport.DeleteContext\")\n\n    @staticmethod\n    def _get_response(\n        host,\n        metadata,\n        query_params,\n        session,\n        timeout,\n        transcoded_request,\n        body=None,\n    ):\n\n        uri = transcoded_request[\"uri\"]\n        method = transcoded_request[\"method\"]\n        headers = dict(metadata)\n        headers[\"Content-Type\"] = \"application/json\"\n        response = getattr(session, method)(\n            \"{host}{uri}\".format(host=host, uri=uri),\n            timeout=timeout,\n            headers=headers,\n            params=rest_helpers.flatten_query_params(query_params, strict=True),\n        )\n        return response\n\n    def __call__(\n        self,\n        request: metadata_service.DeleteContextRequest,\n        *,\n        retry: OptionalRetry = gapic_v1.method.DEFAULT,\n        timeout: Optional[float] = None,\n        metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n    ) -> operations_pb2.Operation:\n        r\"\"\"Call the delete context method over HTTP.\n\n        Args:\n            request (~.metadata_service.DeleteContextRequest):\n                The request object. Request message for\n            [MetadataService.DeleteContext][google.cloud.aiplatform.v1beta1.MetadataService.DeleteContext].\n            retry (google.api_core.retry.Retry): Designation of what errors, if any,\n                should be retried.\n            timeout (float): The timeout for this request.\n            metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n                sent along with the request as metadata. Normally, each value must be of type `str`,\n                but for metadata keys ending with the suffix `-bin`, the corresponding values must\n                be of type `bytes`.\n\n        Returns:\n            ~.operations_pb2.Operation:\n                This resource represents a\n            long-running operation that is the\n            result of a network API call.\n\n        \"\"\"\n\n        http_options = (\n            _BaseMetadataServiceRestTransport._BaseDeleteContext._get_http_options()\n        )\n\n        request, metadata = self._interceptor.pre_delete_context(request, metadata)\n        transcoded_request = _BaseMetadataServiceRestTransport._BaseDeleteContext._get_transcoded_request(\n            http_options, request\n        )\n\n        # Jsonify the query params\n        query_params = _BaseMetadataServiceRestTransport._BaseDeleteContext._get_query_params_json(\n            transcoded_request\n        )\n\n        if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n            logging.DEBUG\n        ):  # pragma: NO COVER\n            request_url = \"{host}{uri}\".format(\n                host=self._host, uri=transcoded_request[\"uri\"]\n            )\n            method = transcoded_request[\"method\"]\n            try:\n                request_payload = json_format.MessageToJson(request)\n            except:\n                request_payload = None\n            http_request = {\n                \"payload\": request_payload,\n                \"requestMethod\": method,\n                \"requestUrl\": request_url,\n                \"headers\": dict(metadata),\n            }\n            _LOGGER.debug(\n                f\"Sending request for google.cloud.aiplatform_v1beta1.MetadataServiceClient.DeleteContext\",\n                extra={\n                    \"serviceName\": \"google.cloud.aiplatform.v1beta1.MetadataService\",\n                    \"rpcName\": \"DeleteContext\",\n                    \"httpRequest\": http_request,\n                    \"metadata\": http_request[\"headers\"],\n                },\n            )\n\n        # Send the request\n        response = MetadataServiceRestTransport._DeleteContext._get_response(\n            self._host,\n            metadata,\n            query_params,\n            self._session,\n            timeout,\n            transcoded_request,\n        )\n\n        # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n        # subclass.\n        if response.status_code >= 400:\n            raise core_exceptions.from_http_response(response)\n\n        # Return the response\n        resp = operations_pb2.Operation()\n        json_format.Parse(response.content, resp, ignore_unknown_fields=True)\n\n        resp = self._interceptor.post_delete_context(resp)\n        response_metadata = [(k, str(v)) for k, v in response.headers.items()]\n        resp, _ = self._interceptor.post_delete_context_with_metadata(\n            resp, response_metadata\n        )\n        if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n            logging.DEBUG\n        ):  # pragma: NO COVER\n            try:\n                response_payload = json_format.MessageToJson(resp)\n            except:\n                response_payload = None\n            http_response = {\n                \"payload\": response_payload,\n                \"headers\": dict(response.headers),\n                \"status\": response.status_code,\n            }\n            _LOGGER.debug(\n                \"Received response for google.cloud.aiplatform_v1beta1.MetadataServiceClient.delete_context\",\n                extra={\n                    \"serviceName\": \"google.cloud.aiplatform.v1beta1.MetadataService\",\n                    \"rpcName\": \"DeleteContext\",\n                    \"metadata\": http_response[\"headers\"],\n                    \"httpResponse\": http_response,\n                },\n            )\n        return resp\n",
    "pattern_analysis": {
      "api_sequence": [
        "rest_helpers.flatten_query_params",
        "json_format.MessageToJson",
        "_LOGGER.debug",
        "MetadataServiceRestTransport._DeleteContext._get_response",
        "core_exceptions.from_http_response",
        "json_format.Parse",
        "self._interceptor.post_delete_context",
        "response.headers.items",
        "self._interceptor.post_delete_context_with_metadata",
        "json_format.MessageToJson",
        "_LOGGER.debug"
      ],
      "api_sequence_with_args": [
        "rest_helpers.flatten_query_params(query_params, strict=True)",
        "json_format.MessageToJson(request)",
        "_LOGGER.debug(f\"Sending request for google.cloud.aiplatform_v1beta1.MetadataServiceClient.DeleteContext\", extra={...})",
        "MetadataServiceRestTransport._DeleteContext._get_response(self._host, metadata, query_params, self._session, timeout, transcoded_request)",
        "core_exceptions.from_http_response(response)",
        "json_format.Parse(response.content, resp, ignore_unknown_fields=True)",
        "self._interceptor.post_delete_context(resp)",
        "response.headers.items()",
        "self._interceptor.post_delete_context_with_metadata(resp, response_metadata)",
        "json_format.MessageToJson(resp)",
        "_LOGGER.debug(\"Received response for google.cloud.aiplatform_v1beta1.MetadataServiceClient.delete_context\", extra={...})"
      ],
      "mapped_sequence": [
        {
          "api_name": "rest_helpers.flatten_query_params",
          "id": "encode_url_query",
          "description": "Encodes mapping object to URL query string",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "json_format.MessageToJson",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "_LOGGER.debug",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "MetadataServiceRestTransport._DeleteContext._get_response",
          "id": "send_http_delete",
          "description": "Sends HTTP DELETE request with parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "core_exceptions.from_http_response",
          "id": "raise_http_error",
          "description": "Raises HTTPError if response status code indicates error",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "json_format.Parse",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "self._interceptor.post_delete_context",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "response.headers.items",
          "id": "get_response_body",
          "description": "Retrieves response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "self._interceptor.post_delete_context_with_metadata",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "json_format.MessageToJson",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "_LOGGER.debug",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        }
      ],
      "contextual_code": "def _get_response(host, metadata, query_params, session, timeout, transcoded_request, body=None):\n    uri = transcoded_request[\"uri\"]\n    method = transcoded_request[\"method\"]\n    headers = dict(metadata)\n    headers[\"Content-Type\"] = \"application/json\"\n    response = getattr(session, method)(\n        \"{host}{uri}\".format(host=host, uri=uri),\n        timeout=timeout,\n        headers=headers,\n        params=rest_helpers.flatten_query_params(query_params, strict=True),\n    )\n    return response\n\n# ...\n\nif CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(logging.DEBUG):\n    try:\n        request_payload = json_format.MessageToJson(request)\n    except:\n        request_payload = None\n    http_request = {\n        \"payload\": request_payload,\n        \"requestMethod\": method,\n        \"requestUrl\": request_url,\n        \"headers\": dict(metadata),\n    }\n    _LOGGER.debug(\n        f\"Sending request for google.cloud.aiplatform_v1beta1.MetadataServiceClient.DeleteContext\",\n        extra={\n            \"serviceName\": \"google.cloud.aiplatform.v1beta1.MetadataService\",\n            \"rpcName\": \"DeleteContext\",\n            \"httpRequest\": http_request,\n            \"metadata\": http_request[\"headers\"],\n        },\n    )\n\nresponse = MetadataServiceRestTransport._DeleteContext._get_response(\n    self._host,\n    metadata,\n    query_params,\n    self._session,\n    timeout,\n    transcoded_request,\n)\n\nif response.status_code >= 400:\n    raise core_exceptions.from_http_response(response)\n\nresp = operations_pb2.Operation()\njson_format.Parse(response.content, resp, ignore_unknown_fields=True)\n\nresp = self._interceptor.post_delete_context(resp)\nresponse_metadata = [(k, str(v)) for k, v in response.headers.items()]\nresp, _ = self._interceptor.post_delete_context_with_metadata(resp, response_metadata)\n\nif CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(logging.DEBUG):\n    try:\n        response_payload = json_format.MessageToJson(resp)\n    except:\n        response_payload = None\n    http_response = {\n        \"payload\": response_payload,\n        \"headers\": dict(response.headers),\n        \"status\": response.status_code,\n    }\n    _LOGGER.debug(\n        \"Received response for google.cloud.aiplatform_v1beta1.MetadataServiceClient.delete_context\",\n        extra={\n            \"serviceName\": \"google.cloud.aiplatform.v1beta1.MetadataService\",\n            \"rpcName\": \"DeleteContext\",\n            \"metadata\": http_response[\"headers\"],\n            \"httpResponse\": http_response,\n        },\n    )"
    }
  },
  {
    "pyfile": "rest.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/google/cloud/aiplatform_v1beta1/services/evaluation_service/transports/rest.py",
    "line_number": "2845",
    "type_description": "B822:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "2844\t            )\n2845\t            transcoded_request = _BaseEvaluationServiceRestTransport._BaseEvaluateInstances._get_transcoded_request(\n2846\t                http_options, request\n2847\t            )",
    "code_snippet": "def __call__(\n    self,\n    request: evaluation_service.EvaluateInstancesRequest,\n    *,\n    retry: OptionalRetry = gapic_v1.method.DEFAULT,\n    timeout: Optional[float] = None,\n    metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n) -> evaluation_service.EvaluateInstancesResponse:\n    r\"\"\"Call the evaluate instances method over HTTP.\n\n    Args:\n        request (~.evaluation_service.EvaluateInstancesRequest):\n            The request object. Request message for\n        EvaluationService.EvaluateInstances.\n        retry (google.api_core.retry.Retry): Designation of what errors, if any,\n            should be retried.\n        timeout (float): The timeout for this request.\n        metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n            sent along with the request as metadata. Normally, each value must be of type `str`,\n            but for metadata keys ending with the suffix `-bin`, the corresponding values must\n            be of type `bytes`.\n\n    Returns:\n        ~.evaluation_service.EvaluateInstancesResponse:\n            Response message for\n        EvaluationService.EvaluateInstances.\n\n    \"\"\"\n\n    http_options = (\n        _BaseEvaluationServiceRestTransport._BaseEvaluateInstances._get_http_options()\n    )\n\n    request, metadata = self._interceptor.pre_evaluate_instances(\n        request, metadata\n    )\n    transcoded_request = _BaseEvaluationServiceRestTransport._BaseEvaluateInstances._get_transcoded_request(\n        http_options, request\n    )\n\n    body = _BaseEvaluationServiceRestTransport._BaseEvaluateInstances._get_request_body_json(\n        transcoded_request\n    )\n\n    # Jsonify the query params\n    query_params = _BaseEvaluationServiceRestTransport._BaseEvaluateInstances._get_query_params_json(\n        transcoded_request\n    )\n\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        request_url = \"{host}{uri}\".format(\n            host=self._host, uri=transcoded_request[\"uri\"]\n        )\n        method = transcoded_request[\"method\"]\n        try:\n            request_payload = type(request).to_json(request)\n        except:\n            request_payload = None\n        http_request = {\n            \"payload\": request_payload,\n            \"requestMethod\": method,\n            \"requestUrl\": request_url,\n            \"headers\": dict(metadata),\n        }\n        _LOGGER.debug(\n            f\"Sending request for google.cloud.aiplatform_v1beta1.EvaluationServiceClient.EvaluateInstances\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1beta1.EvaluationService\",\n                \"rpcName\": \"EvaluateInstances\",\n                \"httpRequest\": http_request,\n                \"metadata\": http_request[\"headers\"],\n            },\n        )\n\n    # Send the request\n    response = EvaluationServiceRestTransport._EvaluateInstances._get_response(\n        self._host,\n        metadata,\n        query_params,\n        self._session,\n        timeout,\n        transcoded_request,\n        body,\n    )\n\n    # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n    # subclass.\n    if response.status_code >= 400:\n        raise core_exceptions.from_http_response(response)\n\n    # Return the response\n    resp = evaluation_service.EvaluateInstancesResponse()\n    pb_resp = evaluation_service.EvaluateInstancesResponse.pb(resp)\n\n    json_format.Parse(response.content, pb_resp, ignore_unknown_fields=True)\n\n    resp = self._interceptor.post_evaluate_instances(resp)\n    response_metadata = [(k, str(v)) for k, v in response.headers.items()]\n    resp, _ = self._interceptor.post_evaluate_instances_with_metadata(\n        resp, response_metadata\n    )\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        try:\n            response_payload = (\n                evaluation_service.EvaluateInstancesResponse.to_json(response)\n            )\n        except:\n            response_payload = None\n        http_response = {\n            \"payload\": response_payload,\n            \"headers\": dict(response.headers),\n            \"status\": response.status_code,\n        }\n        _LOGGER.debug(\n            \"Received response for google.cloud.aiplatform_v1beta1.EvaluationServiceClient.evaluate_instances\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1beta1.EvaluationService\",\n                \"rpcName\": \"EvaluateInstances\",\n                \"metadata\": http_response[\"headers\"],\n                \"httpResponse\": http_response,\n            },\n        )\n    return resp",
    "pattern_analysis": {
      "api_sequence": [
        "evaluation_service.EvaluateInstancesResponse",
        "evaluation_service.EvaluateInstancesResponse.pb",
        "json_format.Parse",
        "response.headers.items"
      ],
      "api_sequence_with_args": [
        "evaluation_service.EvaluateInstancesResponse()",
        "evaluation_service.EvaluateInstancesResponse.pb(resp)",
        "json_format.Parse(response.content, pb_resp, ignore_unknown_fields=True)",
        "response.headers.items()"
      ],
      "mapped_sequence": [
        {
          "api_name": "evaluation_service.EvaluateInstancesResponse",
          "id": "init_parent_class",
          "description": "Initializes parent class with provided arguments",
          "first_id": "code_execution",
          "second_id": "object_initialization",
          "third_id": "class_initialization"
        },
        {
          "api_name": "evaluation_service.EvaluateInstancesResponse.pb",
          "id": "init_parent_class",
          "description": "Initializes parent class with provided arguments",
          "first_id": "code_execution",
          "second_id": "object_initialization",
          "third_id": "class_initialization"
        },
        {
          "api_name": "json_format.Parse",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "response.headers.items",
          "id": "get_env_vars",
          "description": "Retrieves environment variables mapping",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        }
      ],
      "contextual_code": "resp = evaluation_service.EvaluateInstancesResponse()\npb_resp = evaluation_service.EvaluateInstancesResponse.pb(resp)\njson_format.Parse(response.content, pb_resp, ignore_unknown_fields=True)\nresponse_metadata = [(k, str(v)) for k, v in response.headers.items()]"
    }
  },
  {
    "pyfile": "rest_asyncio.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/google/cloud/aiplatform_v1beta1/services/metadata_service/transports/rest_asyncio.py",
    "line_number": "7097",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "7096\t            )\n7097\t            transcoded_request = _BaseMetadataServiceRestTransport._BaseRemoveContextChildren._get_transcoded_request(\n7098\t                http_options, request\n7099\t            )",
    "code_snippet": "        async def __call__(\n            self,\n            request: metadata_service.RemoveContextChildrenRequest,\n            *,\n            retry: OptionalRetry = gapic_v1.method.DEFAULT,\n            timeout: Optional[float] = None,\n            metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n        ) -> metadata_service.RemoveContextChildrenResponse:\n            r\"\"\"Call the remove context children method over HTTP.\n\n            Args:\n                request (~.metadata_service.RemoveContextChildrenRequest):\n                    The request object. Request message for\n                [MetadataService.DeleteContextChildrenRequest][].\n                retry (google.api_core.retry_async.AsyncRetry): Designation of what errors, if any,\n                    should be retried.\n                timeout (float): The timeout for this request.\n                metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n                    sent along with the request as metadata. Normally, each value must be of type `str`,\n                    but for metadata keys ending with the suffix `-bin`, the corresponding values must\n                    be of type `bytes`.\n\n            Returns:\n                ~.metadata_service.RemoveContextChildrenResponse:\n                    Response message for\n                [MetadataService.RemoveContextChildren][google.cloud.aiplatform.v1beta1.MetadataService.RemoveContextChildren].\n\n            \"\"\"\n\n            http_options = (\n                _BaseMetadataServiceRestTransport._BaseRemoveContextChildren._get_http_options()\n            )\n\n            request, metadata = await self._interceptor.pre_remove_context_children(\n                request, metadata\n            )\n            transcoded_request = _BaseMetadataServiceRestTransport._BaseRemoveContextChildren._get_transcoded_request(\n                http_options, request\n            )\n\n            body = _BaseMetadataServiceRestTransport._BaseRemoveContextChildren._get_request_body_json(\n                transcoded_request\n            )\n\n            # Jsonify the query params\n            query_params = _BaseMetadataServiceRestTransport._BaseRemoveContextChildren._get_query_params_json(\n                transcoded_request\n            )\n\n            if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n                logging.DEBUG\n            ):  # pragma: NO COVER\n                request_url = \"{host}{uri}\".format(\n                    host=self._host, uri=transcoded_request[\"uri\"]\n                )\n                method = transcoded_request[\"method\"]\n                try:\n                    request_payload = type(request).to_json(request)\n                except:\n                    request_payload = None\n                http_request = {\n                    \"payload\": request_payload,\n                    \"requestMethod\": method,\n                    \"requestUrl\": request_url,\n                    \"headers\": dict(metadata),\n                }\n                _LOGGER.debug(\n                    f\"Sending request for google.cloud.aiplatform_v1beta1.MetadataServiceClient.RemoveContextChildren\",\n                    extra={\n                        \"serviceName\": \"google.cloud.aiplatform.v1beta1.MetadataService\",\n                        \"rpcName\": \"RemoveContextChildren\",\n                        \"httpRequest\": http_request,\n                        \"metadata\": http_request[\"headers\"],\n                    },\n                )\n\n            # Send the request\n            response = await AsyncMetadataServiceRestTransport._RemoveContextChildren._get_response(\n                self._host,\n                metadata,\n                query_params,\n                self._session,\n                timeout,\n                transcoded_request,\n                body,\n            )\n\n            # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n            # subclass.\n            if response.status_code >= 400:\n                content = await response.read()\n                payload = json.loads(content.decode(\"utf-8\"))\n                request_url = \"{host}{uri}\".format(\n                    host=self._host, uri=transcoded_request[\"uri\"]\n                )\n                method = transcoded_request[\"method\"]\n                raise core_exceptions.format_http_response_error(response, method, request_url, payload)  # type: ignore\n\n            # Return the response\n            resp = metadata_service.RemoveContextChildrenResponse()\n            pb_resp = metadata_service.RemoveContextChildrenResponse.pb(resp)\n            content = await response.read()\n            json_format.Parse(content, pb_resp, ignore_unknown_fields=True)\n            resp = await self._interceptor.post_remove_context_children(resp)\n            response_metadata = [(k, str(v)) for k, v in response.headers.items()]\n            (\n                resp,\n                _,\n            ) = await self._interceptor.post_remove_context_children_with_metadata(\n                resp, response_metadata\n            )\n            if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n                logging.DEBUG\n            ):  # pragma: NO COVER\n                try:\n                    response_payload = (\n                        metadata_service.RemoveContextChildrenResponse.to_json(response)\n                    )\n                except:\n                    response_payload = None\n                http_response = {\n                    \"payload\": response_payload,\n                    \"headers\": dict(response.headers),\n                    \"status\": \"OK\",  # need to obtain this properly\n                }\n                _LOGGER.debug(\n                    \"Received response for google.cloud.aiplatform_v1beta1.MetadataServiceAsyncClient.remove_context_children\",\n                    extra={\n                        \"serviceName\": \"google.cloud.aiplatform.v1beta1.MetadataService\",\n                        \"rpcName\": \"RemoveContextChildren\",\n                        \"metadata\": http_response[\"headers\"],\n                        \"httpResponse\": http_response,\n                    },\n                )\n\n            return resp",
    "pattern_analysis": {
      "api_sequence": [
        "_BaseMetadataServiceRestTransport._BaseRemoveContextChildren._get_http_options",
        "_interceptor.pre_remove_context_children",
        "_BaseMetadataServiceRestTransport._BaseRemoveContextChildren._get_transcoded_request",
        "_BaseMetadataServiceRestTransport._BaseRemoveContextChildren._get_request_body_json",
        "_BaseMetadataServiceRestTransport._BaseRemoveContextChildren._get_query_params_json",
        "_LOGGER.isEnabledFor",
        "type.to_json",
        "_LOGGER.debug",
        "AsyncMetadataServiceRestTransport._RemoveContextChildren._get_response",
        "response.read",
        "json.loads",
        "content.decode",
        "core_exceptions.format_http_response_error",
        "metadata_service.RemoveContextChildrenResponse",
        "metadata_service.RemoveContextChildrenResponse.pb",
        "response.read",
        "json_format.Parse",
        "_interceptor.post_remove_context_children",
        "response.headers.items",
        "_interceptor.post_remove_context_children_with_metadata",
        "_LOGGER.isEnabledFor",
        "metadata_service.RemoveContextChildrenResponse.to_json",
        "_LOGGER.debug"
      ],
      "api_sequence_with_args": [
        "_BaseMetadataServiceRestTransport._BaseRemoveContextChildren._get_http_options()",
        "self._interceptor.pre_remove_context_children(request, metadata)",
        "_BaseMetadataServiceRestTransport._BaseRemoveContextChildren._get_transcoded_request(http_options, request)",
        "_BaseMetadataServiceRestTransport._BaseRemoveContextChildren._get_request_body_json(transcoded_request)",
        "_BaseMetadataServiceRestTransport._BaseRemoveContextChildren._get_query_params_json(transcoded_request)",
        "_LOGGER.isEnabledFor(logging.DEBUG)",
        "type(request).to_json(request)",
        "_LOGGER.debug(f\"Sending request for google.cloud.aiplatform_v1beta1.MetadataServiceClient.RemoveContextChildren\", extra={...})",
        "AsyncMetadataServiceRestTransport._RemoveContextChildren._get_response(self._host, metadata, query_params, self._session, timeout, transcoded_request, body)",
        "response.read()",
        "json.loads(content.decode(\"utf-8\"))",
        "content.decode(\"utf-8\")",
        "core_exceptions.format_http_response_error(response, method, request_url, payload)",
        "metadata_service.RemoveContextChildrenResponse()",
        "metadata_service.RemoveContextChildrenResponse.pb(resp)",
        "response.read()",
        "json_format.Parse(content, pb_resp, ignore_unknown_fields=True)",
        "self._interceptor.post_remove_context_children(resp)",
        "response.headers.items()",
        "self._interceptor.post_remove_context_children_with_metadata(resp, response_metadata)",
        "_LOGGER.isEnabledFor(logging.DEBUG)",
        "metadata_service.RemoveContextChildrenResponse.to_json(response)",
        "_LOGGER.debug(\"Received response for google.cloud.aiplatform_v1beta1.MetadataServiceAsyncClient.remove_context_children\", extra={...})"
      ],
      "mapped_sequence": [
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "content.decode",
          "id": "decode_bytes_codec",
          "description": "Decodes bytes using specified codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        }
      ],
      "contextual_code": "if response.status_code >= 400:\n    content = await response.read()\n    payload = json.loads(content.decode(\"utf-8\"))\n    request_url = \"{host}{uri}\".format(\n        host=self._host, uri=transcoded_request[\"uri\"]\n    )\n    method = transcoded_request[\"method\"]\n    raise core_exceptions.format_http_response_error(response, method, request_url, payload)  # type: ignore"
    }
  },
  {
    "pyfile": "rest_asyncio.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/google/cloud/aiplatform_v1/services/metadata_service/transports/rest_asyncio.py",
    "line_number": "4505",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "4504\t            )\n4505\t            transcoded_request = _BaseMetadataServiceRestTransport._BaseGetArtifact._get_transcoded_request(\n4506\t                http_options, request\n4507\t            )",
    "code_snippet": "async def __call__(\n    self,\n    request: metadata_service.GetArtifactRequest,\n    *,\n    retry: OptionalRetry = gapic_v1.method.DEFAULT,\n    timeout: Optional[float] = None,\n    metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n) -> artifact.Artifact:\n    r\"\"\"Call the get artifact method over HTTP.\n\n    Args:\n        request (~.metadata_service.GetArtifactRequest):\n            The request object. Request message for\n        [MetadataService.GetArtifact][google.cloud.aiplatform.v1.MetadataService.GetArtifact].\n        retry (google.api_core.retry_async.AsyncRetry): Designation of what errors, if any,\n            should be retried.\n        timeout (float): The timeout for this request.\n        metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n            sent along with the request as metadata. Normally, each value must be of type `str`,\n            but for metadata keys ending with the suffix `-bin`, the corresponding values must\n            be of type `bytes`.\n\n    Returns:\n        ~.artifact.Artifact:\n            Instance of a general artifact.\n    \"\"\"\n\n    http_options = (\n        _BaseMetadataServiceRestTransport._BaseGetArtifact._get_http_options()\n    )\n\n    request, metadata = await self._interceptor.pre_get_artifact(\n        request, metadata\n    )\n    transcoded_request = _BaseMetadataServiceRestTransport._BaseGetArtifact._get_transcoded_request(\n        http_options, request\n    )\n\n    # Jsonify the query params\n    query_params = _BaseMetadataServiceRestTransport._BaseGetArtifact._get_query_params_json(\n        transcoded_request\n    )\n\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        request_url = \"{host}{uri}\".format(\n            host=self._host, uri=transcoded_request[\"uri\"]\n        )\n        method = transcoded_request[\"method\"]\n        try:\n            request_payload = type(request).to_json(request)\n        except:\n            request_payload = None\n        http_request = {\n            \"payload\": request_payload,\n            \"requestMethod\": method,\n            \"requestUrl\": request_url,\n            \"headers\": dict(metadata),\n        }\n        _LOGGER.debug(\n            f\"Sending request for google.cloud.aiplatform_v1.MetadataServiceClient.GetArtifact\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1.MetadataService\",\n                \"rpcName\": \"GetArtifact\",\n                \"httpRequest\": http_request,\n                \"metadata\": http_request[\"headers\"],\n            },\n        )\n\n    # Send the request\n    response = (\n        await AsyncMetadataServiceRestTransport._GetArtifact._get_response(\n            self._host,\n            metadata,\n            query_params,\n            self._session,\n            timeout,\n            transcoded_request,\n        )\n    )\n\n    # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n    # subclass.\n    if response.status_code >= 400:\n        content = await response.read()\n        payload = json.loads(content.decode(\"utf-8\"))\n        request_url = \"{host}{uri}\".format(\n            host=self._host, uri=transcoded_request[\"uri\"]\n        )\n        method = transcoded_request[\"method\"]\n        raise core_exceptions.format_http_response_error(response, method, request_url, payload)  # type: ignore\n\n    # Return the response\n    resp = artifact.Artifact()\n    pb_resp = artifact.Artifact.pb(resp)\n    content = await response.read()\n    json_format.Parse(content, pb_resp, ignore_unknown_fields=True)\n    resp = await self._interceptor.post_get_artifact(resp)\n    response_metadata = [(k, str(v)) for k, v in response.headers.items()]\n    resp, _ = await self._interceptor.post_get_artifact_with_metadata(\n        resp, response_metadata\n    )\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        try:\n            response_payload = artifact.Artifact.to_json(response)\n        except:\n            response_payload = None\n        http_response = {\n            \"payload\": response_payload,\n            \"headers\": dict(response.headers),\n            \"status\": \"OK\",  # need to obtain this properly\n        }\n        _LOGGER.debug(\n            \"Received response for google.cloud.aiplatform_v1.MetadataServiceAsyncClient.get_artifact\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1.MetadataService\",\n                \"rpcName\": \"GetArtifact\",\n                \"metadata\": http_response[\"headers\"],\n                \"httpResponse\": http_response,\n            },\n        )\n\n    return resp",
    "pattern_analysis": {
      "api_sequence": [
        "_BaseMetadataServiceRestTransport._BaseGetArtifact._get_http_options",
        "self._interceptor.pre_get_artifact",
        "_BaseMetadataServiceRestTransport._BaseGetArtifact._get_transcoded_request",
        "_BaseMetadataServiceRestTransport._BaseGetArtifact._get_query_params_json",
        "_LOGGER.isEnabledFor",
        "type.to_json",
        "_LOGGER.debug",
        "AsyncMetadataServiceRestTransport._GetArtifact._get_response",
        "response.read",
        "json.loads",
        "content.decode",
        "core_exceptions.format_http_response_error",
        "artifact.Artifact",
        "artifact.Artifact.pb",
        "response.read",
        "json_format.Parse",
        "self._interceptor.post_get_artifact",
        "response.headers.items",
        "self._interceptor.post_get_artifact_with_metadata",
        "_LOGGER.isEnabledFor",
        "artifact.Artifact.to_json",
        "_LOGGER.debug"
      ],
      "api_sequence_with_args": [
        "_BaseMetadataServiceRestTransport._BaseGetArtifact._get_http_options()",
        "self._interceptor.pre_get_artifact(request, metadata)",
        "_BaseMetadataServiceRestTransport._BaseGetArtifact._get_transcoded_request(http_options, request)",
        "_BaseMetadataServiceRestTransport._BaseGetArtifact._get_query_params_json(transcoded_request)",
        "_LOGGER.isEnabledFor(logging.DEBUG)",
        "type(request).to_json(request)",
        "_LOGGER.debug(f\"Sending request for google.cloud.aiplatform_v1.MetadataServiceClient.GetArtifact\", extra={...})",
        "AsyncMetadataServiceRestTransport._GetArtifact._get_response(self._host, metadata, query_params, self._session, timeout, transcoded_request)",
        "response.read()",
        "json.loads(content.decode(\"utf-8\"))",
        "content.decode(\"utf-8\")",
        "core_exceptions.format_http_response_error(response, method, request_url, payload)",
        "artifact.Artifact()",
        "artifact.Artifact.pb(resp)",
        "response.read()",
        "json_format.Parse(content, pb_resp, ignore_unknown_fields=True)",
        "self._interceptor.post_get_artifact(resp)",
        "response.headers.items()",
        "self._interceptor.post_get_artifact_with_metadata(resp, response_metadata)",
        "_LOGGER.isEnabledFor(logging.DEBUG)",
        "artifact.Artifact.to_json(response)",
        "_LOGGER.debug(\"Received response for google.cloud.aiplatform_v1.MetadataServiceAsyncClient.get_artifact\", extra={...})"
      ],
      "mapped_sequence": [
        {
          "api_name": "_BaseMetadataServiceRestTransport._BaseGetArtifact._get_http_options",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "self._interceptor.pre_get_artifact",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "_BaseMetadataServiceRestTransport._BaseGetArtifact._get_transcoded_request",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "_BaseMetadataServiceRestTransport._BaseGetArtifact._get_query_params_json",
          "id": "encode_url_query",
          "description": "Encodes mapping object to URL query string",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "_LOGGER.isEnabledFor",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "type.to_json",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "_LOGGER.debug",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "AsyncMetadataServiceRestTransport._GetArtifact._get_response",
          "id": "open_url_get",
          "description": "Opens URL with GET parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "response.read",
          "id": "read_response_body",
          "description": "Reads response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "content.decode",
          "id": "decode_bytes_codec",
          "description": "Decodes bytes using specified codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "core_exceptions.format_http_response_error",
          "id": "raise_http_error",
          "description": "Raises HTTPError if response status code indicates error",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "artifact.Artifact",
          "id": "deserialize_json_response",
          "description": "Deserializes JSON response body to Python object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "artifact.Artifact.pb",
          "id": "deserialize_json_response",
          "description": "Deserializes JSON response body to Python object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "response.read",
          "id": "read_response_body",
          "description": "Reads response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "json_format.Parse",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "self._interceptor.post_get_artifact",
          "id": "deserialize_json_response",
          "description": "Deserializes JSON response body to Python object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "response.headers.items",
          "id": "get_response_body",
          "description": "Retrieves response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "self._interceptor.post_get_artifact_with_metadata",
          "id": "deserialize_json_response",
          "description": "Deserializes JSON response body to Python object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "_LOGGER.isEnabledFor",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "artifact.Artifact.to_json",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "_LOGGER.debug",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        }
      ],
      "contextual_code": "http_options = (\n    _BaseMetadataServiceRestTransport._BaseGetArtifact._get_http_options()\n)\n\nrequest, metadata = await self._interceptor.pre_get_artifact(\n    request, metadata\n)\ntranscoded_request = _BaseMetadataServiceRestTransport._BaseGetArtifact._get_transcoded_request(\n    http_options, request\n)\n\n# Jsonify the query params\nquery_params = _BaseMetadataServiceRestTransport._BaseGetArtifact._get_query_params_json(\n    transcoded_request\n)\n\nif CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n    logging.DEBUG\n):\n    request_url = \"{host}{uri}\".format(\n        host=self._host, uri=transcoded_request[\"uri\"]\n    )\n    method = transcoded_request[\"method\"]\n    try:\n        request_payload = type(request).to_json(request)\n    except:\n        request_payload = None\n    http_request = {\n        \"payload\": request_payload,\n        \"requestMethod\": method,\n        \"requestUrl\": request_url,\n        \"headers\": dict(metadata),\n    }\n    _LOGGER.debug(\n        f\"Sending request for google.cloud.aiplatform_v1.MetadataServiceClient.GetArtifact\",\n        extra={\n            \"serviceName\": \"google.cloud.aiplatform.v1.MetadataService\",\n            \"rpcName\": \"GetArtifact\",\n            \"httpRequest\": http_request,\n            \"metadata\": http_request[\"headers\"],\n        },\n    )\n\n# Send the request\nresponse = (\n    await AsyncMetadataServiceRestTransport._GetArtifact._get_response(\n        self._host,\n        metadata,\n        query_params,\n        self._session,\n        timeout,\n        transcoded_request,\n    )\n)\n\n# In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n# subclass.\nif response.status_code >= 400:\n    content = await response.read()\n    payload = json.loads(content.decode(\"utf-8\"))\n    request_url = \"{host}{uri}\".format(\n        host=self._host, uri=transcoded_request[\"uri\"]\n    )\n    method = transcoded_request[\"method\"]\n    raise core_exceptions.format_http_response_error(response, method, request_url, payload)  # type: ignore\n\n# Return the response\nresp = artifact.Artifact()\npb_resp = artifact.Artifact.pb(resp)\ncontent = await response.read()\njson_format.Parse(content, pb_resp, ignore_unknown_fields=True)\nresp = await self._interceptor.post_get_artifact(resp)\nresponse_metadata = [(k, str(v)) for k, v in response.headers.items()]\nresp, _ = await self._interceptor.post_get_artifact_with_metadata(\n    resp, response_metadata\n)\nif CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n    logging.DEBUG\n):\n    try:\n        response_payload = artifact.Artifact.to_json(response)\n    except:\n        response_payload = None\n    http_response = {\n        \"payload\": response_payload,\n        \"headers\": dict(response.headers),\n        \"status\": \"OK\",  # need to obtain this properly\n    }\n    _LOGGER.debug(\n        \"Received response for google.cloud.aiplatform_v1.MetadataServiceAsyncClient.get_artifact\",\n        extra={\n            \"serviceName\": \"google.cloud.aiplatform.v1.MetadataService\",\n            \"rpcName\": \"GetArtifact\",\n            \"metadata\": http_response[\"headers\"],\n            \"httpResponse\": http_response,\n        },\n    )"
    }
  },
  {
    "pyfile": "rest_asyncio.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/google/cloud/aiplatform_v1beta1/services/gen_ai_tuning_service/transports/rest_asyncio.py",
    "line_number": "3866",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "3865\t            )\n3866\t            transcoded_request = _BaseGenAiTuningServiceRestTransport._BaseListLocations._get_transcoded_request(\n3867\t                http_options, request\n3868\t            )",
    "code_snippet": "async def __call__(\n    self,\n    request: locations_pb2.ListLocationsRequest,\n    *,\n    retry: OptionalRetry = gapic_v1.method.DEFAULT,\n    timeout: Optional[float] = None,\n    metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n) -> locations_pb2.ListLocationsResponse:\n\n    r\"\"\"Call the list locations method over HTTP.\n\n    Args:\n        request (locations_pb2.ListLocationsRequest):\n            The request object for ListLocations method.\n        retry (google.api_core.retry_async.AsyncRetry): Designation of what errors, if any,\n            should be retried.\n        timeout (float): The timeout for this request.\n        metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n            sent along with the request as metadata. Normally, each value must be of type `str`,\n            but for metadata keys ending with the suffix `-bin`, the corresponding values must\n            be of type `bytes`.\n\n    Returns:\n        locations_pb2.ListLocationsResponse: Response from ListLocations method.\n    \"\"\"\n\n    http_options = (\n        _BaseGenAiTuningServiceRestTransport._BaseListLocations._get_http_options()\n    )\n\n    request, metadata = await self._interceptor.pre_list_locations(\n        request, metadata\n    )\n    transcoded_request = _BaseGenAiTuningServiceRestTransport._BaseListLocations._get_transcoded_request(\n        http_options, request\n    )\n\n    # Jsonify the query params\n    query_params = _BaseGenAiTuningServiceRestTransport._BaseListLocations._get_query_params_json(\n        transcoded_request\n    )\n\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        request_url = \"{host}{uri}\".format(\n            host=self._host, uri=transcoded_request[\"uri\"]\n        )\n        method = transcoded_request[\"method\"]\n        try:\n            request_payload = json_format.MessageToJson(request)\n        except:\n            request_payload = None\n        http_request = {\n            \"payload\": request_payload,\n            \"requestMethod\": method,\n            \"requestUrl\": request_url,\n            \"headers\": dict(metadata),\n        }\n        _LOGGER.debug(\n            f\"Sending request for google.cloud.aiplatform_v1beta1.GenAiTuningServiceClient.ListLocations\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1beta1.GenAiTuningService\",\n                \"rpcName\": \"ListLocations\",\n                \"httpRequest\": http_request,\n                \"metadata\": http_request[\"headers\"],\n            },\n        )\n\n    # Send the request\n    response = (\n        await AsyncGenAiTuningServiceRestTransport._ListLocations._get_response(\n            self._host,\n            metadata,\n            query_params,\n            self._session,\n            timeout,\n            transcoded_request,\n        )\n    )\n\n    # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n    # subclass.\n    if response.status_code >= 400:\n        content = await response.read()\n        payload = json.loads(content.decode(\"utf-8\"))\n        request_url = \"{host}{uri}\".format(\n            host=self._host, uri=transcoded_request[\"uri\"]\n        )\n        method = transcoded_request[\"method\"]\n        raise core_exceptions.format_http_response_error(response, method, request_url, payload)  # type: ignore\n\n    content = await response.read()\n    resp = locations_pb2.ListLocationsResponse()\n    resp = json_format.Parse(content, resp)\n    resp = await self._interceptor.post_list_locations(resp)\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        try:\n            response_payload = json_format.MessageToJson(resp)\n        except:\n            response_payload = None\n        http_response = {\n            \"payload\": response_payload,\n            \"headers\": dict(response.headers),\n            \"status\": response.status_code,\n        }\n        _LOGGER.debug(\n            \"Received response for google.cloud.aiplatform_v1beta1.GenAiTuningServiceAsyncClient.ListLocations\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1beta1.GenAiTuningService\",\n                \"rpcName\": \"ListLocations\",\n                \"httpResponse\": http_response,\n                \"metadata\": http_response[\"headers\"],\n            },\n        )\n    return resp",
    "pattern_analysis": {
      "api_sequence": [
        "json_format.MessageToJson",
        "AsyncGenAiTuningServiceRestTransport._ListLocations._get_response",
        "response.read",
        "json.loads",
        "core_exceptions.format_http_response_error",
        "response.read",
        "json_format.Parse"
      ],
      "api_sequence_with_args": [
        "json_format.MessageToJson(request)",
        "AsyncGenAiTuningServiceRestTransport._ListLocations._get_response(self._host, metadata, query_params, self._session, timeout, transcoded_request)",
        "response.read()",
        "json.loads(content.decode(\"utf-8\"))",
        "core_exceptions.format_http_response_error(response, method, request_url, payload)",
        "response.read()",
        "json_format.Parse(content, resp)"
      ],
      "mapped_sequence": [
        {
          "api_name": "json_format.MessageToJson",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "AsyncGenAiTuningServiceRestTransport._ListLocations._get_response",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "response.read",
          "id": "read_response_body",
          "description": "Reads response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "core_exceptions.format_http_response_error",
          "id": "raise_http_error",
          "description": "Raises HTTPError if response status code indicates error",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "response.read",
          "id": "read_response_body",
          "description": "Reads response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "json_format.Parse",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        }
      ],
      "contextual_code": "try:\n    request_payload = json_format.MessageToJson(request)\nexcept:\n    request_payload = None\nresponse = (\n    await AsyncGenAiTuningServiceRestTransport._ListLocations._get_response(\n        self._host,\n        metadata,\n        query_params,\n        self._session,\n        timeout,\n        transcoded_request,\n    )\n)\nif response.status_code >= 400:\n    content = await response.read()\n    payload = json.loads(content.decode(\"utf-8\"))\n    request_url = \"{host}{uri}\".format(\n        host=self._host, uri=transcoded_request[\"uri\"]\n    )\n    method = transcoded_request[\"method\"]\n    raise core_exceptions.format_http_response_error(response, method, request_url, payload)\ncontent = await response.read()\nresp = locations_pb2.ListLocationsResponse()\nresp = json_format.Parse(content, resp)"
    }
  },
  {
    "pyfile": "rest_asyncio.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/google/cloud/aiplatform_v1/services/model_garden_service/transports/rest_asyncio.py",
    "line_number": "1226",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1225\t            )\n1226\t            transcoded_request = _BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_transcoded_request(\n1227\t                http_options, request\n1228\t            )",
    "code_snippet": "async def __call__(\n    self,\n    request: iam_policy_pb2.SetIamPolicyRequest,\n    *,\n    retry: OptionalRetry = gapic_v1.method.DEFAULT,\n    timeout: Optional[float] = None,\n    metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n) -> policy_pb2.Policy:\n\n    r\"\"\"Call the set iam policy method over HTTP.\n\n    Args:\n        request (iam_policy_pb2.SetIamPolicyRequest):\n            The request object for SetIamPolicy method.\n        retry (google.api_core.retry_async.AsyncRetry): Designation of what errors, if any,\n            should be retried.\n        timeout (float): The timeout for this request.\n        metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n            sent along with the request as metadata. Normally, each value must be of type `str`,\n            but for metadata keys ending with the suffix `-bin`, the corresponding values must\n            be of type `bytes`.\n\n    Returns:\n        policy_pb2.Policy: Response from SetIamPolicy method.\n    \"\"\"\n\n    http_options = (\n        _BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_http_options()\n    )\n\n    request, metadata = await self._interceptor.pre_set_iam_policy(\n        request, metadata\n    )\n    transcoded_request = _BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_transcoded_request(\n        http_options, request\n    )\n\n    body = _BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_request_body_json(\n        transcoded_request\n    )\n\n    # Jsonify the query params\n    query_params = _BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_query_params_json(\n        transcoded_request\n    )\n\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        request_url = \"{host}{uri}\".format(\n            host=self._host, uri=transcoded_request[\"uri\"]\n        )\n        method = transcoded_request[\"method\"]\n        try:\n            request_payload = json_format.MessageToJson(request)\n        except:\n            request_payload = None\n        http_request = {\n            \"payload\": request_payload,\n            \"requestMethod\": method,\n            \"requestUrl\": request_url,\n            \"headers\": dict(metadata),\n        }\n        _LOGGER.debug(\n            f\"Sending request for google.cloud.aiplatform_v1.ModelGardenServiceClient.SetIamPolicy\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1.ModelGardenService\",\n                \"rpcName\": \"SetIamPolicy\",\n                \"httpRequest\": http_request,\n                \"metadata\": http_request[\"headers\"],\n            },\n        )\n\n    # Send the request\n    response = (\n        await AsyncModelGardenServiceRestTransport._SetIamPolicy._get_response(\n            self._host,\n            metadata,\n            query_params,\n            self._session,\n            timeout,\n            transcoded_request,\n            body,\n        )\n    )\n\n    # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n    # subclass.\n    if response.status_code >= 400:\n        content = await response.read()\n        payload = json.loads(content.decode(\"utf-8\"))\n        request_url = \"{host}{uri}\".format(\n            host=self._host, uri=transcoded_request[\"uri\"]\n        )\n        method = transcoded_request[\"method\"]\n        raise core_exceptions.format_http_response_error(response, method, request_url, payload)  # type: ignore\n\n    content = await response.read()\n    resp = policy_pb2.Policy()\n    resp = json_format.Parse(content, resp)\n    resp = await self._interceptor.post_set_iam_policy(resp)\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        try:\n            response_payload = json_format.MessageToJson(resp)\n        except:\n            response_payload = None\n        http_response = {\n            \"payload\": response_payload,\n            \"headers\": dict(response.headers),\n            \"status\": response.status_code,\n        }\n        _LOGGER.debug(\n            \"Received response for google.cloud.aiplatform_v1.ModelGardenServiceAsyncClient.SetIamPolicy\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1.ModelGardenService\",\n                \"rpcName\": \"SetIamPolicy\",\n                \"httpResponse\": http_response,\n                \"metadata\": http_response[\"headers\"],\n            },\n        )\n    return resp",
    "pattern_analysis": {
      "api_sequence": [
        "_BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_http_options",
        "self._interceptor.pre_set_iam_policy",
        "_BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_transcoded_request",
        "_BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_request_body_json",
        "_BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_query_params_json",
        "_LOGGER.isEnabledFor",
        "json_format.MessageToJson",
        "_LOGGER.debug",
        "AsyncModelGardenServiceRestTransport._SetIamPolicy._get_response",
        "response.read",
        "json.loads",
        "content.decode",
        "_LOGGER.isEnabledFor",
        "json_format.MessageToJson",
        "_LOGGER.debug",
        "json_format.Parse",
        "self._interceptor.post_set_iam_policy"
      ],
      "api_sequence_with_args": [
        "_BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_http_options()",
        "self._interceptor.pre_set_iam_policy(request, metadata)",
        "_BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_transcoded_request(http_options, request)",
        "_BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_request_body_json(transcoded_request)",
        "_BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_query_params_json(transcoded_request)",
        "_LOGGER.isEnabledFor(logging.DEBUG)",
        "json_format.MessageToJson(request)",
        "_LOGGER.debug(f\"Sending request for google.cloud.aiplatform_v1.ModelGardenServiceClient.SetIamPolicy\", extra={...})",
        "AsyncModelGardenServiceRestTransport._SetIamPolicy._get_response(self._host, metadata, query_params, self._session, timeout, transcoded_request, body)",
        "response.read()",
        "json.loads(content.decode(\"utf-8\"))",
        "content.decode(\"utf-8\")",
        "_LOGGER.isEnabledFor(logging.DEBUG)",
        "json_format.MessageToJson(resp)",
        "_LOGGER.debug(\"Received response for google.cloud.aiplatform_v1.ModelGardenServiceAsyncClient.SetIamPolicy\", extra={...})",
        "json_format.Parse(content, resp)",
        "self._interceptor.post_set_iam_policy(resp)"
      ],
      "mapped_sequence": [
        {
          "api_name": "_BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_http_options",
          "id": "find_packages",
          "description": "Finds all packages in current directory",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "package_configuration"
        },
        {
          "api_name": "self._interceptor.pre_set_iam_policy",
          "id": "run_async_function",
          "description": "Runs asynchronous function until completion",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "_BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_transcoded_request",
          "id": "encode_url_query",
          "description": "Encodes mapping object to URL query string",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "_BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_request_body_json",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "_BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_query_params_json",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "_LOGGER.isEnabledFor",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "json_format.MessageToJson",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "_LOGGER.debug",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "AsyncModelGardenServiceRestTransport._SetIamPolicy._get_response",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "response.read",
          "id": "read_response_bytes",
          "description": "Reads response body as bytes",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "content.decode",
          "id": "decode_bytes_codec",
          "description": "Decodes bytes using specified codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "_LOGGER.isEnabledFor",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "json_format.MessageToJson",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "_LOGGER.debug",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "json_format.Parse",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "self._interceptor.post_set_iam_policy",
          "id": "run_async_function",
          "description": "Runs asynchronous function until completion",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        }
      ],
      "contextual_code": "async def __call__(self, request, *, retry=gapic_v1.method.DEFAULT, timeout=None, metadata=()):\n    http_options = _BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_http_options()\n    request, metadata = await self._interceptor.pre_set_iam_policy(request, metadata)\n    transcoded_request = _BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_transcoded_request(http_options, request)\n    body = _BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_request_body_json(transcoded_request)\n    query_params = _BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_query_params_json(transcoded_request)\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(logging.DEBUG):\n        try:\n            request_payload = json_format.MessageToJson(request)\n        except:\n            request_payload = None\n        http_request = {\n            \"payload\": request_payload,\n            \"requestMethod\": transcoded_request[\"method\"],\n            \"requestUrl\": f\"{self._host}{transcoded_request['uri']}\",\n            \"headers\": dict(metadata),\n        }\n        _LOGGER.debug(\n            f\"Sending request for google.cloud.aiplatform_v1.ModelGardenServiceClient.SetIamPolicy\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1.ModelGardenService\",\n                \"rpcName\": \"SetIamPolicy\",\n                \"httpRequest\": http_request,\n                \"metadata\": http_request[\"headers\"],\n            },\n        )\n    response = await AsyncModelGardenServiceRestTransport._SetIamPolicy._get_response(\n        self._host, metadata, query_params, self._session, timeout, transcoded_request, body\n    )\n    if response.status_code >= 400:\n        content = await response.read()\n        payload = json.loads(content.decode(\"utf-8\"))\n        request_url = f\"{self._host}{transcoded_request['uri']}\"\n        method = transcoded_request[\"method\"]\n        raise core_exceptions.format_http_response_error(response, method, request_url, payload)\n    content = await response.read()\n    resp = policy_pb2.Policy()\n    resp = json_format.Parse(content, resp)\n    resp = await self._interceptor.post_set_iam_policy(resp)\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(logging.DEBUG):\n        try:\n            response_payload = json_format.MessageToJson(resp)\n        except:\n            response_payload = None\n        http_response = {\n            \"payload\": response_payload,\n            \"headers\": dict(response.headers),\n            \"status\": response.status_code,\n        }\n        _LOGGER.debug(\n            \"Received response for google.cloud.aiplatform_v1.ModelGardenServiceAsyncClient.SetIamPolicy\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1.ModelGardenService\",\n                \"rpcName\": \"SetIamPolicy\",\n                \"httpResponse\": http_response,\n                \"metadata\": http_response[\"headers\"],\n            },\n        )\n    return resp"
    }
  },
  {
    "pyfile": "rest_asyncio.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/google/cloud/aiplatform_v1/services/job_service/transports/rest_asyncio.py",
    "line_number": "4813",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "4812\t            )\n4813\t            transcoded_request = _BaseJobServiceRestTransport._BaseDeleteModelDeploymentMonitoringJob._get_transcoded_request(\n4814\t                http_options, request\n4815\t            )",
    "code_snippet": "        async def __call__(\n            self,\n            request: job_service.DeleteModelDeploymentMonitoringJobRequest,\n            *,\n            retry: OptionalRetry = gapic_v1.method.DEFAULT,\n            timeout: Optional[float] = None,\n            metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n        ) -> operations_pb2.Operation:\n            r\"\"\"Call the delete model deployment\n            monitoring job method over HTTP.\n\n                Args:\n                    request (~.job_service.DeleteModelDeploymentMonitoringJobRequest):\n                        The request object. Request message for\n                    [JobService.DeleteModelDeploymentMonitoringJob][google.cloud.aiplatform.v1.JobService.DeleteModelDeploymentMonitoringJob].\n                    retry (google.api_core.retry_async.AsyncRetry): Designation of what errors, if any,\n                        should be retried.\n                    timeout (float): The timeout for this request.\n                    metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n                        sent along with the request as metadata. Normally, each value must be of type `str`,\n                        but for metadata keys ending with the suffix `-bin`, the corresponding values must\n                        be of type `bytes`.\n\n                Returns:\n                    ~.operations_pb2.Operation:\n                        This resource represents a\n                    long-running operation that is the\n                    result of a network API call.\n\n            \"\"\"\n\n            http_options = (\n                _BaseJobServiceRestTransport._BaseDeleteModelDeploymentMonitoringJob._get_http_options()\n            )\n\n            (\n                request,\n                metadata,\n            ) = await self._interceptor.pre_delete_model_deployment_monitoring_job(\n                request, metadata\n            )\n            transcoded_request = _BaseJobServiceRestTransport._BaseDeleteModelDeploymentMonitoringJob._get_transcoded_request(\n                http_options, request\n            )\n\n            # Jsonify the query params\n            query_params = _BaseJobServiceRestTransport._BaseDeleteModelDeploymentMonitoringJob._get_query_params_json(\n                transcoded_request\n            )\n\n            if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n                logging.DEBUG\n            ):  # pragma: NO COVER\n                request_url = \"{host}{uri}\".format(\n                    host=self._host, uri=transcoded_request[\"uri\"]\n                )\n                method = transcoded_request[\"method\"]\n                try:\n                    request_payload = json_format.MessageToJson(request)\n                except:\n                    request_payload = None\n                http_request = {\n                    \"payload\": request_payload,\n                    \"requestMethod\": method,\n                    \"requestUrl\": request_url,\n                    \"headers\": dict(metadata),\n                }\n                _LOGGER.debug(\n                    f\"Sending request for google.cloud.aiplatform_v1.JobServiceClient.DeleteModelDeploymentMonitoringJob\",\n                    extra={\n                        \"serviceName\": \"google.cloud.aiplatform.v1.JobService\",\n                        \"rpcName\": \"DeleteModelDeploymentMonitoringJob\",\n                        \"httpRequest\": http_request,\n                        \"metadata\": http_request[\"headers\"],\n                    },\n                )\n\n            # Send the request\n            response = await AsyncJobServiceRestTransport._DeleteModelDeploymentMonitoringJob._get_response(\n                self._host,\n                metadata,\n                query_params,\n                self._session,\n                timeout,\n                transcoded_request,\n            )\n\n            # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n            # subclass.\n            if response.status_code >= 400:\n                content = await response.read()\n                payload = json.loads(content.decode(\"utf-8\"))\n                request_url = \"{host}{uri}\".format(\n                    host=self._host, uri=transcoded_request[\"uri\"]\n                )\n                method = transcoded_request[\"method\"]\n                raise core_exceptions.format_http_response_error(response, method, request_url, payload)  # type: ignore\n\n            # Return the response\n            resp = operations_pb2.Operation()\n            pb_resp = resp\n            content = await response.read()\n            json_format.Parse(content, pb_resp, ignore_unknown_fields=True)\n            resp = await self._interceptor.post_delete_model_deployment_monitoring_job(\n                resp\n            )\n            response_metadata = [(k, str(v)) for k, v in response.headers.items()]\n            (\n                resp,\n                _,\n            ) = await self._interceptor.post_delete_model_deployment_monitoring_job_with_metadata(\n                resp, response_metadata\n            )\n            if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n                logging.DEBUG\n            ):  # pragma: NO COVER\n                try:\n                    response_payload = json_format.MessageToJson(resp)\n                except:\n                    response_payload = None\n                http_response = {\n                    \"payload\": response_payload,\n                    \"headers\": dict(response.headers),\n                    \"status\": \"OK\",  # need to obtain this properly\n                }\n                _LOGGER.debug(\n                    \"Received response for google.cloud.aiplatform_v1.JobServiceAsyncClient.delete_model_deployment_monitoring_job\",\n                    extra={\n                        \"serviceName\": \"google.cloud.aiplatform.v1.JobService\",\n                        \"rpcName\": \"DeleteModelDeploymentMonitoringJob\",\n                        \"metadata\": http_response[\"headers\"],\n                        \"httpResponse\": http_response,\n                    },\n                )\n\n            return resp",
    "pattern_analysis": {
      "api_sequence": [
        "self._interceptor.pre_delete_model_deployment_monitoring_job",
        "_BaseJobServiceRestTransport._BaseDeleteModelDeploymentMonitoringJob._get_http_options",
        "_BaseJobServiceRestTransport._BaseDeleteModelDeploymentMonitoringJob._get_transcoded_request",
        "_BaseJobServiceRestTransport._BaseDeleteModelDeploymentMonitoringJob._get_query_params_json",
        "json_format.MessageToJson",
        "_LOGGER.debug",
        "AsyncJobServiceRestTransport._DeleteModelDeploymentMonitoringJob._get_response",
        "response.read",
        "json.loads",
        "core_exceptions.format_http_response_error",
        "response.read",
        "json_format.Parse",
        "self._interceptor.post_delete_model_deployment_monitoring_job",
        "response.headers.items",
        "self._interceptor.post_delete_model_deployment_monitoring_job_with_metadata",
        "json_format.MessageToJson",
        "_LOGGER.debug"
      ],
      "api_sequence_with_args": [
        "self._interceptor.pre_delete_model_deployment_monitoring_job(request, metadata)",
        "_BaseJobServiceRestTransport._BaseDeleteModelDeploymentMonitoringJob._get_http_options()",
        "_BaseJobServiceRestTransport._BaseDeleteModelDeploymentMonitoringJob._get_transcoded_request(http_options, request)",
        "_BaseJobServiceRestTransport._BaseDeleteModelDeploymentMonitoringJob._get_query_params_json(transcoded_request)",
        "json_format.MessageToJson(request)",
        "_LOGGER.debug(f\"Sending request for google.cloud.aiplatform_v1.JobServiceClient.DeleteModelDeploymentMonitoringJob\", extra={...})",
        "AsyncJobServiceRestTransport._DeleteModelDeploymentMonitoringJob._get_response(self._host, metadata, query_params, self._session, timeout, transcoded_request)",
        "response.read()",
        "json.loads(content.decode(\"utf-8\"))",
        "core_exceptions.format_http_response_error(response, method, request_url, payload)",
        "response.read()",
        "json_format.Parse(content, pb_resp, ignore_unknown_fields=True)",
        "self._interceptor.post_delete_model_deployment_monitoring_job(resp)",
        "response.headers.items()",
        "self._interceptor.post_delete_model_deployment_monitoring_job_with_metadata(resp, response_metadata)",
        "json_format.MessageToJson(resp)",
        "_LOGGER.debug(\"Received response for google.cloud.aiplatform_v1.JobServiceAsyncClient.delete_model_deployment_monitoring_job\", extra={...})"
      ],
      "mapped_sequence": [
        {
          "api_name": "self._interceptor.pre_delete_model_deployment_monitoring_job",
          "id": "run_async_function",
          "description": "Runs asynchronous function until completion",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "_BaseJobServiceRestTransport._BaseDeleteModelDeploymentMonitoringJob._get_http_options",
          "id": "get_global_symbols",
          "description": "Retrieves global symbol table as dictionary",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "_BaseJobServiceRestTransport._BaseDeleteModelDeploymentMonitoringJob._get_transcoded_request",
          "id": "get_global_symbols",
          "description": "Retrieves global symbol table as dictionary",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "_BaseJobServiceRestTransport._BaseDeleteModelDeploymentMonitoringJob._get_query_params_json",
          "id": "get_global_symbols",
          "description": "Retrieves global symbol table as dictionary",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "json_format.MessageToJson",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "_LOGGER.debug",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "AsyncJobServiceRestTransport._DeleteModelDeploymentMonitoringJob._get_response",
          "id": "send_http_delete",
          "description": "Sends HTTP DELETE request with parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "response.read",
          "id": "read_response_bytes",
          "description": "Reads response body as bytes",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "core_exceptions.format_http_response_error",
          "id": "raise_http_error",
          "description": "Raises HTTPError if response status code indicates error",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "response.read",
          "id": "read_response_bytes",
          "description": "Reads response body as bytes",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "json_format.Parse",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "self._interceptor.post_delete_model_deployment_monitoring_job",
          "id": "run_async_function",
          "description": "Runs asynchronous function until completion",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "response.headers.items",
          "id": "get_global_symbols",
          "description": "Retrieves global symbol table as dictionary",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "self._interceptor.post_delete_model_deployment_monitoring_job_with_metadata",
          "id": "run_async_function",
          "description": "Runs asynchronous function until completion",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "json_format.MessageToJson",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "_LOGGER.debug",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        }
      ],
      "contextual_code": "async def __call__(self, request, *, retry=gapic_v1.method.DEFAULT, timeout=None, metadata=()):\n    http_options = _BaseJobServiceRestTransport._BaseDeleteModelDeploymentMonitoringJob._get_http_options()\n    (request, metadata) = await self._interceptor.pre_delete_model_deployment_monitoring_job(request, metadata)\n    transcoded_request = _BaseJobServiceRestTransport._BaseDeleteModelDeploymentMonitoringJob._get_transcoded_request(http_options, request)\n    query_params = _BaseJobServiceRestTransport._BaseDeleteModelDeploymentMonitoringJob._get_query_params_json(transcoded_request)\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(logging.DEBUG):\n        request_url = \"{host}{uri}\".format(host=self._host, uri=transcoded_request[\"uri\"])\n        method = transcoded_request[\"method\"]\n        try:\n            request_payload = json_format.MessageToJson(request)\n        except:\n            request_payload = None\n        http_request = {\n            \"payload\": request_payload,\n            \"requestMethod\": method,\n            \"requestUrl\": request_url,\n            \"headers\": dict(metadata),\n        }\n        _LOGGER.debug(f\"Sending request for google.cloud.aiplatform_v1.JobServiceClient.DeleteModelDeploymentMonitoringJob\", extra={\"serviceName\": \"google.cloud.aiplatform.v1.JobService\", \"rpcName\": \"DeleteModelDeploymentMonitoringJob\", \"httpRequest\": http_request, \"metadata\": http_request[\"headers\"]})\n    response = await AsyncJobServiceRestTransport._DeleteModelDeploymentMonitoringJob._get_response(self._host, metadata, query_params, self._session, timeout, transcoded_request)\n    if response.status_code >= 400:\n        content = await response.read()\n        payload = json.loads(content.decode(\"utf-8\"))\n        request_url = \"{host}{uri}\".format(host=self._host, uri=transcoded_request[\"uri\"])\n        method = transcoded_request[\"method\"]\n        raise core_exceptions.format_http_response_error(response, method, request_url, payload)\n    resp = operations_pb2.Operation()\n    pb_resp = resp\n    content = await response.read()\n    json_format.Parse(content, pb_resp, ignore_unknown_fields=True)\n    resp = await self._interceptor.post_delete_model_deployment_monitoring_job(resp)\n    response_metadata = [(k, str(v)) for k, v in response.headers.items()]\n    (resp, _) = await self._interceptor.post_delete_model_deployment_monitoring_job_with_metadata(resp, response_metadata)\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(logging.DEBUG):\n        try:\n            response_payload = json_format.MessageToJson(resp)\n        except:\n            response_payload = None\n        http_response = {\n            \"payload\": response_payload,\n            \"headers\": dict(response.headers),\n            \"status\": \"OK\",\n        }\n        _LOGGER.debug(\"Received response for google.cloud.aiplatform_v1.JobServiceAsyncClient.delete_model_deployment_monitoring_job\", extra={\"serviceName\": \"google.cloud.aiplatform.v1.JobService\", \"rpcName\": \"DeleteModelDeploymentMonitoringJob\", \"metadata\": http_response[\"headers\"], \"httpResponse\": http_response})"
    }
  },
  {
    "pyfile": "rest_asyncio.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/google/cloud/aiplatform_v1beta1/services/model_service/transports/rest_asyncio.py",
    "line_number": "7105",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "7104\t            transcoded_request = (\n7105\t                _BaseModelServiceRestTransport._BaseGetLocation._get_transcoded_request(\n7106\t                    http_options, request\n7107\t                )",
    "code_snippet": "        async def __call__(\n            self,\n            request: locations_pb2.GetLocationRequest,\n            *,\n            retry: OptionalRetry = gapic_v1.method.DEFAULT,\n            timeout: Optional[float] = None,\n            metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n        ) -> locations_pb2.Location:\n\n            r\"\"\"Call the get location method over HTTP.\n\n            Args:\n                request (locations_pb2.GetLocationRequest):\n                    The request object for GetLocation method.\n                retry (google.api_core.retry_async.AsyncRetry): Designation of what errors, if any,\n                    should be retried.\n                timeout (float): The timeout for this request.\n                metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n                    sent along with the request as metadata. Normally, each value must be of type `str`,\n                    but for metadata keys ending with the suffix `-bin`, the corresponding values must\n                    be of type `bytes`.\n\n            Returns:\n                locations_pb2.Location: Response from GetLocation method.\n            \"\"\"\n\n            http_options = (\n                _BaseModelServiceRestTransport._BaseGetLocation._get_http_options()\n            )\n\n            request, metadata = await self._interceptor.pre_get_location(\n                request, metadata\n            )\n            transcoded_request = (\n                _BaseModelServiceRestTransport._BaseGetLocation._get_transcoded_request(\n                    http_options, request\n                )\n            )\n\n            # Jsonify the query params\n            query_params = (\n                _BaseModelServiceRestTransport._BaseGetLocation._get_query_params_json(\n                    transcoded_request\n                )\n            )\n\n            if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n                logging.DEBUG\n            ):  # pragma: NO COVER\n                request_url = \"{host}{uri}\".format(\n                    host=self._host, uri=transcoded_request[\"uri\"]\n                )\n                method = transcoded_request[\"method\"]\n                try:\n                    request_payload = json_format.MessageToJson(request)\n                except:\n                    request_payload = None\n                http_request = {\n                    \"payload\": request_payload,\n                    \"requestMethod\": method,\n                    \"requestUrl\": request_url,\n                    \"headers\": dict(metadata),\n                }\n                _LOGGER.debug(\n                    f\"Sending request for google.cloud.aiplatform_v1beta1.ModelServiceClient.GetLocation\",\n                    extra={\n                        \"serviceName\": \"google.cloud.aiplatform.v1beta1.ModelService\",\n                        \"rpcName\": \"GetLocation\",\n                        \"httpRequest\": http_request,\n                        \"metadata\": http_request[\"headers\"],\n                    },\n                )\n\n            # Send the request\n            response = await AsyncModelServiceRestTransport._GetLocation._get_response(\n                self._host,\n                metadata,\n                query_params,\n                self._session,\n                timeout,\n                transcoded_request,\n            )\n\n            # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n            # subclass.\n            if response.status_code >= 400:\n                content = await response.read()\n                payload = json.loads(content.decode(\"utf-8\"))\n                request_url = \"{host}{uri}\".format(\n                    host=self._host, uri=transcoded_request[\"uri\"]\n                )\n                method = transcoded_request[\"method\"]\n                raise core_exceptions.format_http_response_error(response, method, request_url, payload)  # type: ignore\n\n            content = await response.read()\n            resp = locations_pb2.Location()\n            resp = json_format.Parse(content, resp)\n            resp = await self._interceptor.post_get_location(resp)\n            if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n                logging.DEBUG\n            ):  # pragma: NO COVER\n                try:\n                    response_payload = json_format.MessageToJson(resp)\n                except:\n                    response_payload = None\n                http_response = {\n                    \"payload\": response_payload,\n                    \"headers\": dict(response.headers),\n                    \"status\": response.status_code,\n                }\n                _LOGGER.debug(\n                    \"Received response for google.cloud.aiplatform_v1beta1.ModelServiceAsyncClient.GetLocation\",\n                    extra={\n                        \"serviceName\": \"google.cloud.aiplatform.v1beta1.ModelService\",\n                        \"rpcName\": \"GetLocation\",\n                        \"httpResponse\": http_response,\n                        \"metadata\": http_response[\"headers\"],\n                    },\n                )\n            return resp",
    "pattern_analysis": {
      "api_sequence": [
        "AsyncModelServiceRestTransport._GetLocation._get_response",
        "response.read",
        "json.loads",
        "core_exceptions.format_http_response_error",
        "response.read",
        "json_format.Parse",
        "self._interceptor.post_get_location"
      ],
      "api_sequence_with_args": [
        "AsyncModelServiceRestTransport._GetLocation._get_response(self._host, metadata, query_params, self._session, timeout, transcoded_request)",
        "response.read()",
        "json.loads(content.decode(\"utf-8\"))",
        "core_exceptions.format_http_response_error(response, method, request_url, payload)",
        "response.read()",
        "json_format.Parse(content, resp)",
        "self._interceptor.post_get_location(resp)"
      ],
      "mapped_sequence": [
        {
          "api_name": "AsyncModelServiceRestTransport._GetLocation._get_response",
          "id": "open_url_get_timeout",
          "description": "Opens URL with GET parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "response.read",
          "id": "read_response_bytes",
          "description": "Reads response body as bytes",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "core_exceptions.format_http_response_error",
          "id": "raise_http_error",
          "description": "Raises HTTPError if response status code indicates error",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "response.read",
          "id": "read_response_bytes",
          "description": "Reads response body as bytes",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "json_format.Parse",
          "id": "deserialize_json_response",
          "description": "Deserializes JSON response body to Python object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "self._interceptor.post_get_location",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        }
      ],
      "contextual_code": "response = await AsyncModelServiceRestTransport._GetLocation._get_response(\n    self._host,\n    metadata,\n    query_params,\n    self._session,\n    timeout,\n    transcoded_request,\n)\n\nif response.status_code >= 400:\n    content = await response.read()\n    payload = json.loads(content.decode(\"utf-8\"))\n    request_url = \"{host}{uri}\".format(\n        host=self._host, uri=transcoded_request[\"uri\"]\n    )\n    method = transcoded_request[\"method\"]\n    raise core_exceptions.format_http_response_error(response, method, request_url, payload)\n\ncontent = await response.read()\nresp = locations_pb2.Location()\nresp = json_format.Parse(content, resp)\nresp = await self._interceptor.post_get_location(resp)"
    }
  },
  {
    "pyfile": "rest_asyncio.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/google/cloud/aiplatform_v1/services/index_service/transports/rest_asyncio.py",
    "line_number": "1625",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1624\t            )\n1625\t            transcoded_request = _BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_transcoded_request(\n1626\t                http_options, request\n1627\t            )",
    "code_snippet": "async def __call__(\n    self,\n    request: index_service.RemoveDatapointsRequest,\n    *,\n    retry: OptionalRetry = gapic_v1.method.DEFAULT,\n    timeout: Optional[float] = None,\n    metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n) -> index_service.RemoveDatapointsResponse:\n    r\"\"\"Call the remove datapoints method over HTTP.\n\n    Args:\n        request (~.index_service.RemoveDatapointsRequest):\n            The request object. Request message for\n        [IndexService.RemoveDatapoints][google.cloud.aiplatform.v1.IndexService.RemoveDatapoints]\n        retry (google.api_core.retry_async.AsyncRetry): Designation of what errors, if any,\n            should be retried.\n        timeout (float): The timeout for this request.\n        metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n            sent along with the request as metadata. Normally, each value must be of type `str`,\n            but for metadata keys ending with the suffix `-bin`, the corresponding values must\n            be of type `bytes`.\n\n    Returns:\n        ~.index_service.RemoveDatapointsResponse:\n            Response message for\n        [IndexService.RemoveDatapoints][google.cloud.aiplatform.v1.IndexService.RemoveDatapoints]\n\n    \"\"\"\n\n    http_options = (\n        _BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_http_options()\n    )\n\n    request, metadata = await self._interceptor.pre_remove_datapoints(\n        request, metadata\n    )\n    transcoded_request = _BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_transcoded_request(\n        http_options, request\n    )\n\n    body = _BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_request_body_json(\n        transcoded_request\n    )\n\n    # Jsonify the query params\n    query_params = _BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_query_params_json(\n        transcoded_request\n    )\n\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        request_url = \"{host}{uri}\".format(\n            host=self._host, uri=transcoded_request[\"uri\"]\n        )\n        method = transcoded_request[\"method\"]\n        try:\n            request_payload = type(request).to_json(request)\n        except:\n            request_payload = None\n        http_request = {\n            \"payload\": request_payload,\n            \"requestMethod\": method,\n            \"requestUrl\": request_url,\n            \"headers\": dict(metadata),\n        }\n        _LOGGER.debug(\n            f\"Sending request for google.cloud.aiplatform_v1.IndexServiceClient.RemoveDatapoints\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1.IndexService\",\n                \"rpcName\": \"RemoveDatapoints\",\n                \"httpRequest\": http_request,\n                \"metadata\": http_request[\"headers\"],\n            },\n        )\n\n    # Send the request\n    response = (\n        await AsyncIndexServiceRestTransport._RemoveDatapoints._get_response(\n            self._host,\n            metadata,\n            query_params,\n            self._session,\n            timeout,\n            transcoded_request,\n            body,\n        )\n    )\n\n    # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n    # subclass.\n    if response.status_code >= 400:\n        content = await response.read()\n        payload = json.loads(content.decode(\"utf-8\"))\n        request_url = \"{host}{uri}\".format(\n            host=self._host, uri=transcoded_request[\"uri\"]\n        )\n        method = transcoded_request[\"method\"]\n        raise core_exceptions.format_http_response_error(response, method, request_url, payload)  # type: ignore\n\n    # Return the response\n    resp = index_service.RemoveDatapointsResponse()\n    pb_resp = index_service.RemoveDatapointsResponse.pb(resp)\n    content = await response.read()\n    json_format.Parse(content, pb_resp, ignore_unknown_fields=True)\n    resp = await self._interceptor.post_remove_datapoints(resp)\n    response_metadata = [(k, str(v)) for k, v in response.headers.items()]\n    resp, _ = await self._interceptor.post_remove_datapoints_with_metadata(\n        resp, response_metadata\n    )\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        try:\n            response_payload = index_service.RemoveDatapointsResponse.to_json(\n                response\n            )\n        except:\n            response_payload = None\n        http_response = {\n            \"payload\": response_payload,\n            \"headers\": dict(response.headers),\n            \"status\": \"OK\",  # need to obtain this properly\n        }\n        _LOGGER.debug(\n            \"Received response for google.cloud.aiplatform_v1.IndexServiceAsyncClient.remove_datapoints\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1.IndexService\",\n                \"rpcName\": \"RemoveDatapoints\",\n                \"metadata\": http_response[\"headers\"],\n                \"httpResponse\": http_response,\n            },\n        )\n\n    return resp",
    "pattern_analysis": {
      "api_sequence": [
        "_BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_http_options",
        "self._interceptor.pre_remove_datapoints",
        "_BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_transcoded_request",
        "_BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_request_body_json",
        "_BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_query_params_json",
        "_LOGGER.isEnabledFor",
        "type.to_json",
        "_LOGGER.debug",
        "AsyncIndexServiceRestTransport._RemoveDatapoints._get_response",
        "response.read",
        "json.loads",
        "core_exceptions.format_http_response_error",
        "index_service.RemoveDatapointsResponse",
        "index_service.RemoveDatapointsResponse.pb",
        "response.read",
        "json_format.Parse",
        "self._interceptor.post_remove_datapoints",
        "response.headers.items",
        "self._interceptor.post_remove_datapoints_with_metadata",
        "_LOGGER.isEnabledFor",
        "index_service.RemoveDatapointsResponse.to_json",
        "_LOGGER.debug"
      ],
      "api_sequence_with_args": [
        "_BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_http_options()",
        "self._interceptor.pre_remove_datapoints(request, metadata)",
        "_BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_transcoded_request(http_options, request)",
        "_BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_request_body_json(transcoded_request)",
        "_BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_query_params_json(transcoded_request)",
        "_LOGGER.isEnabledFor(logging.DEBUG)",
        "type(request).to_json(request)",
        "_LOGGER.debug(f\"Sending request for google.cloud.aiplatform_v1.IndexServiceClient.RemoveDatapoints\", extra={...})",
        "AsyncIndexServiceRestTransport._RemoveDatapoints._get_response(self._host, metadata, query_params, self._session, timeout, transcoded_request, body)",
        "response.read()",
        "json.loads(content.decode(\"utf-8\"))",
        "core_exceptions.format_http_response_error(response, method, request_url, payload)",
        "index_service.RemoveDatapointsResponse()",
        "index_service.RemoveDatapointsResponse.pb(resp)",
        "response.read()",
        "json_format.Parse(content, pb_resp, ignore_unknown_fields=True)",
        "self._interceptor.post_remove_datapoints(resp)",
        "response.headers.items()",
        "self._interceptor.post_remove_datapoints_with_metadata(resp, response_metadata)",
        "_LOGGER.isEnabledFor(logging.DEBUG)",
        "index_service.RemoveDatapointsResponse.to_json(response)",
        "_LOGGER.debug(\"Received response for google.cloud.aiplatform_v1.IndexServiceAsyncClient.remove_datapoints\", extra={...})"
      ],
      "mapped_sequence": [
        {
          "api_name": "_BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_http_options",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "self._interceptor.pre_remove_datapoints",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "_BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_transcoded_request",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "_BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_request_body_json",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "_BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_query_params_json",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "_LOGGER.isEnabledFor",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "type.to_json",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "_LOGGER.debug",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "AsyncIndexServiceRestTransport._RemoveDatapoints._get_response",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "response.read",
          "id": "read_response_bytes",
          "description": "Reads response body as bytes",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "core_exceptions.format_http_response_error",
          "id": "raise_http_error",
          "description": "Raises HTTPError if response status code indicates error",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "index_service.RemoveDatapointsResponse",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "index_service.RemoveDatapointsResponse.pb",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "response.read",
          "id": "read_response_bytes",
          "description": "Reads response body as bytes",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "json_format.Parse",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "self._interceptor.post_remove_datapoints",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "response.headers.items",
          "id": "get_env_vars",
          "description": "Retrieves environment variables mapping",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "self._interceptor.post_remove_datapoints_with_metadata",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "_LOGGER.isEnabledFor",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "index_service.RemoveDatapointsResponse.to_json",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "_LOGGER.debug",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        }
      ],
      "contextual_code": "async def __call__(self, request, *, retry=gapic_v1.method.DEFAULT, timeout=None, metadata=()):\n    http_options = _BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_http_options()\n    request, metadata = await self._interceptor.pre_remove_datapoints(request, metadata)\n    transcoded_request = _BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_transcoded_request(http_options, request)\n    body = _BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_request_body_json(transcoded_request)\n    query_params = _BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_query_params_json(transcoded_request)\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(logging.DEBUG):\n        request_url = \"{host}{uri}\".format(host=self._host, uri=transcoded_request[\"uri\"])\n        method = transcoded_request[\"method\"]\n        try:\n            request_payload = type(request).to_json(request)\n        except:\n            request_payload = None\n        http_request = {\n            \"payload\": request_payload,\n            \"requestMethod\": method,\n            \"requestUrl\": request_url,\n            \"headers\": dict(metadata),\n        }\n        _LOGGER.debug(f\"Sending request for google.cloud.aiplatform_v1.IndexServiceClient.RemoveDatapoints\", extra={...})\n    response = await AsyncIndexServiceRestTransport._RemoveDatapoints._get_response(self._host, metadata, query_params, self._session, timeout, transcoded_request, body)\n    if response.status_code >= 400:\n        content = await response.read()\n        payload = json.loads(content.decode(\"utf-8\"))\n        request_url = \"{host}{uri}\".format(host=self._host, uri=transcoded_request[\"uri\"])\n        method = transcoded_request[\"method\"]\n        raise core_exceptions.format_http_response_error(response, method, request_url, payload)\n    resp = index_service.RemoveDatapointsResponse()\n    pb_resp = index_service.RemoveDatapointsResponse.pb(resp)\n    content = await response.read()\n    json_format.Parse(content, pb_resp, ignore_unknown_fields=True)\n    resp = await self._interceptor.post_remove_datapoints(resp)\n    response_metadata = [(k, str(v)) for k, v in response.headers.items()]\n    resp, _ = await self._interceptor.post_remove_datapoints_with_metadata(resp, response_metadata)\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(logging.DEBUG):\n        try:\n            response_payload = index_service.RemoveDatapointsResponse.to_json(response)\n        except:\n            response_payload = None\n        http_response = {\n            \"payload\": response_payload,\n            \"headers\": dict(response.headers),\n            \"status\": \"OK\",\n        }\n        _LOGGER.debug(\"Received response for google.cloud.aiplatform_v1.IndexServiceAsyncClient.remove_datapoints\", extra={...})\n    return resp"
    }
  },
  {
    "pyfile": "rest.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/google/cloud/aiplatform_v1/services/prediction_service/transports/rest.py",
    "line_number": "3397",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "3396\t            )\n3397\t            transcoded_request = _BasePredictionServiceRestTransport._BaseCancelOperation._get_transcoded_request(\n3398\t                http_options, request\n3399\t            )",
    "code_snippet": "def __call__(\n    self,\n    request: operations_pb2.CancelOperationRequest,\n    *,\n    retry: OptionalRetry = gapic_v1.method.DEFAULT,\n    timeout: Optional[float] = None,\n    metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n) -> None:\n\n    r\"\"\"Call the cancel operation method over HTTP.\n\n    Args:\n        request (operations_pb2.CancelOperationRequest):\n            The request object for CancelOperation method.\n        retry (google.api_core.retry.Retry): Designation of what errors, if any,\n            should be retried.\n        timeout (float): The timeout for this request.\n        metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n            sent along with the request as metadata. Normally, each value must be of type `str`,\n            but for metadata keys ending with the suffix `-bin`, the corresponding values must\n            be of type `bytes`.\n    \"\"\"\n\n    http_options = (\n        _BasePredictionServiceRestTransport._BaseCancelOperation._get_http_options()\n    )\n\n    request, metadata = self._interceptor.pre_cancel_operation(\n        request, metadata\n    )\n    transcoded_request = _BasePredictionServiceRestTransport._BaseCancelOperation._get_transcoded_request(\n        http_options, request\n    )\n\n    # Jsonify the query params\n    query_params = _BasePredictionServiceRestTransport._BaseCancelOperation._get_query_params_json(\n        transcoded_request\n    )\n\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        request_url = \"{host}{uri}\".format(\n            host=self._host, uri=transcoded_request[\"uri\"]\n        )\n        method = transcoded_request[\"method\"]\n        try:\n            request_payload = json_format.MessageToJson(request)\n        except:\n            request_payload = None\n        http_request = {\n            \"payload\": request_payload,\n            \"requestMethod\": method,\n            \"requestUrl\": request_url,\n            \"headers\": dict(metadata),\n        }\n        _LOGGER.debug(\n            f\"Sending request for google.cloud.aiplatform_v1.PredictionServiceClient.CancelOperation\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1.PredictionService\",\n                \"rpcName\": \"CancelOperation\",\n                \"httpRequest\": http_request,\n                \"metadata\": http_request[\"headers\"],\n            },\n        )\n\n    # Send the request\n    response = PredictionServiceRestTransport._CancelOperation._get_response(\n        self._host,\n        metadata,\n        query_params,\n        self._session,\n        timeout,\n        transcoded_request,\n    )\n\n    # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n    # subclass.\n    if response.status_code >= 400:\n        raise core_exceptions.from_http_response(response)\n\n    return self._interceptor.post_cancel_operation(None)\n",
    "pattern_analysis": {
      "api_sequence": [
        "_BasePredictionServiceRestTransport._BaseCancelOperation._get_http_options",
        "self._interceptor.pre_cancel_operation",
        "_BasePredictionServiceRestTransport._BaseCancelOperation._get_transcoded_request",
        "_BasePredictionServiceRestTransport._BaseCancelOperation._get_query_params_json",
        "json_format.MessageToJson",
        "_LOGGER.debug",
        "PredictionServiceRestTransport._CancelOperation._get_response",
        "core_exceptions.from_http_response",
        "self._interceptor.post_cancel_operation"
      ],
      "api_sequence_with_args": [
        "_BasePredictionServiceRestTransport._BaseCancelOperation._get_http_options()",
        "self._interceptor.pre_cancel_operation(request, metadata)",
        "_BasePredictionServiceRestTransport._BaseCancelOperation._get_transcoded_request(http_options, request)",
        "_BasePredictionServiceRestTransport._BaseCancelOperation._get_query_params_json(transcoded_request)",
        "json_format.MessageToJson(request)",
        "_LOGGER.debug(f\"Sending request for google.cloud.aiplatform_v1.PredictionServiceClient.CancelOperation\", extra={...})",
        "PredictionServiceRestTransport._CancelOperation._get_response(self._host, metadata, query_params, self._session, timeout, transcoded_request)",
        "core_exceptions.from_http_response(response)",
        "self._interceptor.post_cancel_operation(None)"
      ],
      "mapped_sequence": [
        {
          "api_name": "_BasePredictionServiceRestTransport._BaseCancelOperation._get_http_options",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "self._interceptor.pre_cancel_operation",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "_BasePredictionServiceRestTransport._BaseCancelOperation._get_transcoded_request",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "_BasePredictionServiceRestTransport._BaseCancelOperation._get_query_params_json",
          "id": "encode_url_query",
          "description": "Encodes mapping object to URL query string",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "json_format.MessageToJson",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "_LOGGER.debug",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "PredictionServiceRestTransport._CancelOperation._get_response",
          "id": "open_url_post",
          "description": "Opens URL with POST data",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "core_exceptions.from_http_response",
          "id": "raise_http_error",
          "description": "Raises HTTPError if response status code indicates error",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "self._interceptor.post_cancel_operation",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        }
      ],
      "contextual_code": "def __call__(self, request, *, retry=gapic_v1.method.DEFAULT, timeout=None, metadata=()):\n    http_options = _BasePredictionServiceRestTransport._BaseCancelOperation._get_http_options()\n    request, metadata = self._interceptor.pre_cancel_operation(request, metadata)\n    transcoded_request = _BasePredictionServiceRestTransport._BaseCancelOperation._get_transcoded_request(http_options, request)\n    query_params = _BasePredictionServiceRestTransport._BaseCancelOperation._get_query_params_json(transcoded_request)\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(logging.DEBUG):\n        try:\n            request_payload = json_format.MessageToJson(request)\n        except:\n            request_payload = None\n        http_request = {\n            \"payload\": request_payload,\n            \"requestMethod\": transcoded_request[\"method\"],\n            \"requestUrl\": f\"{self._host}{transcoded_request['uri']}\",\n            \"headers\": dict(metadata),\n        }\n        _LOGGER.debug(\n            f\"Sending request for google.cloud.aiplatform_v1.PredictionServiceClient.CancelOperation\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1.PredictionService\",\n                \"rpcName\": \"CancelOperation\",\n                \"httpRequest\": http_request,\n                \"metadata\": http_request[\"headers\"],\n            },\n        )\n    response = PredictionServiceRestTransport._CancelOperation._get_response(\n        self._host, metadata, query_params, self._session, timeout, transcoded_request\n    )\n    if response.status_code >= 400:\n        raise core_exceptions.from_http_response(response)\n    return self._interceptor.post_cancel_operation(None)"
    }
  }
]