[
  {
    "metadata": {
      "package_name": "azure_storage_blob-12.25.1",
      "total_matches": 3,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "test_container.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/azure_storage_blob-12.25.1/azure_storage_blob-12.25.1/tests/test_container.py",
    "line_number": "765",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "764\t        assert 'testid' == acl.get('signed_identifiers')[0].id\n765\t        assert acl.get('public_access') is None\n766",
    "code_snippet": "@BlobPreparer()\n@recorded_by_proxy\ndef test_set_container_acl_with_signed_identifiers(self, **kwargs):\n    storage_account_name = kwargs.pop(\"storage_account_name\")\n    storage_account_key = kwargs.pop(\"storage_account_key\")\n    variables = kwargs.pop(\"variables\", {})\n\n    bsc = BlobServiceClient(self.account_url(storage_account_name, \"blob\"), storage_account_key)\n    container = self._create_container(bsc)\n\n    # Act\n    expiry_time = self.get_datetime_variable(variables, 'expiry_time', datetime.utcnow() + timedelta(hours=1))\n    start_time = self.get_datetime_variable(variables, 'start_time', datetime.utcnow() - timedelta(minutes=1))\n    access_policy = AccessPolicy(permission=ContainerSasPermissions(read=True),\n                                 expiry=expiry_time,\n                                 start=start_time)\n    identifiers = {'testid': access_policy}\n    container.set_container_access_policy(identifiers)\n\n    # Assert\n    acl = container.get_container_access_policy()\n    assert acl is not None\n    assert 'testid' == acl.get('signed_identifiers')[0].id\n    assert acl.get('public_access') is None\n\n    return variables",
    "pattern_analysis": {
      "api_sequence": [
        "self.account_url",
        "BlobServiceClient",
        "self._create_container",
        "self.get_datetime_variable",
        "self.get_datetime_variable",
        "AccessPolicy",
        "ContainerSasPermissions",
        "container.set_container_access_policy",
        "container.get_container_access_policy",
        "acl.get",
        "acl.get"
      ],
      "api_sequence_with_args": [
        "self.account_url(storage_account_name, \"blob\")",
        "BlobServiceClient(self.account_url(storage_account_name, \"blob\"), storage_account_key)",
        "self._create_container(bsc)",
        "self.get_datetime_variable(variables, 'expiry_time', datetime.utcnow() + timedelta(hours=1))",
        "self.get_datetime_variable(variables, 'start_time', datetime.utcnow() - timedelta(minutes=1))",
        "AccessPolicy(permission=ContainerSasPermissions(read=True), expiry=expiry_time, start=start_time)",
        "ContainerSasPermissions(read=True)",
        "container.set_container_access_policy(identifiers)",
        "container.get_container_access_policy()",
        "acl.get('signed_identifiers')",
        "acl.get('public_access')"
      ],
      "mapped_sequence": [
        {
          "api_name": "self.account_url",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "BlobServiceClient",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "self._create_container",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "self.get_datetime_variable",
          "id": "parse_datetime",
          "description": "Parses string into datetime object using format",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "self.get_datetime_variable",
          "id": "parse_datetime",
          "description": "Parses string into datetime object using format",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "AccessPolicy",
          "id": "set_file_attributes",
          "description": "Sets file attributes for specified file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_attribute_management"
        },
        {
          "api_name": "ContainerSasPermissions",
          "id": "set_file_attributes",
          "description": "Sets file attributes for specified file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_attribute_management"
        },
        {
          "api_name": "container.set_container_access_policy",
          "id": "set_file_attributes",
          "description": "Sets file attributes for specified file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_attribute_management"
        },
        {
          "api_name": "container.get_container_access_policy",
          "id": "get_registry_value",
          "description": "Retrieves value and data type for specified registry value",
          "first_id": "system_operations",
          "second_id": "registry_operations",
          "third_id": "registry_modification"
        },
        {
          "api_name": "acl.get",
          "id": "get_registry_value",
          "description": "Retrieves value and data type for specified registry value",
          "first_id": "system_operations",
          "second_id": "registry_operations",
          "third_id": "registry_modification"
        },
        {
          "api_name": "acl.get",
          "id": "get_registry_value",
          "description": "Retrieves value and data type for specified registry value",
          "first_id": "system_operations",
          "second_id": "registry_operations",
          "third_id": "registry_modification"
        }
      ],
      "contextual_code": "@BlobPreparer()\n@recorded_by_proxy\ndef test_set_container_acl_with_signed_identifiers(self, **kwargs):\n    storage_account_name = kwargs.pop(\"storage_account_name\")\n    storage_account_key = kwargs.pop(\"storage_account_key\")\n    variables = kwargs.pop(\"variables\", {})\n\n    bsc = BlobServiceClient(self.account_url(storage_account_name, \"blob\"), storage_account_key)\n    container = self._create_container(bsc)\n\n    expiry_time = self.get_datetime_variable(variables, 'expiry_time', datetime.utcnow() + timedelta(hours=1))\n    start_time = self.get_datetime_variable(variables, 'start_time', datetime.utcnow() - timedelta(minutes=1))\n    access_policy = AccessPolicy(permission=ContainerSasPermissions(read=True),\n                                 expiry=expiry_time,\n                                 start=start_time)\n    identifiers = {'testid': access_policy}\n    container.set_container_access_policy(identifiers)\n\n    acl = container.get_container_access_policy()\n    assert acl is not None\n    assert 'testid' == acl.get('signed_identifiers')[0].id\n    assert acl.get('public_access') is None"
    }
  },
  {
    "pyfile": "test_container_async.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/azure_storage_blob-12.25.1/azure_storage_blob-12.25.1/tests/test_container_async.py",
    "line_number": "723",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "722\t        assert response.get('etag') is not None\n723\t        assert response.get('last_modified') is not None\n724",
    "code_snippet": "@BlobPreparer()\n@recorded_by_proxy_async\nasync def test_set_container_acl(self, **kwargs):\n    storage_account_name = kwargs.pop(\"storage_account_name\")\n    storage_account_key = kwargs.pop(\"storage_account_key\")\n    variables = kwargs.pop('variables', {})\n\n    bsc = BlobServiceClient(self.account_url(storage_account_name, \"blob\"), storage_account_key)\n    container = await self._create_container(bsc)\n\n    # Act\n    expiry_time = self.get_datetime_variable(variables, 'expiry_time', datetime.utcnow() + timedelta(hours=1))\n    start_time = self.get_datetime_variable(variables, 'start_time', datetime.utcnow())\n    access_policy = AccessPolicy(permission=ContainerSasPermissions(read=True),\n                                 expiry=expiry_time,\n                                 start=start_time)\n    signed_identifier = {'testid': access_policy}\n    response = await container.set_container_access_policy(signed_identifier)\n\n    assert response.get('etag') is not None\n    assert response.get('last_modified') is not None\n\n    # Assert\n    acl = await container.get_container_access_policy()\n    assert acl is not None\n    assert len(acl.get('signed_identifiers')) == 1\n    assert acl.get('public_access') is None\n\n    return variables",
    "pattern_analysis": {
      "api_sequence": [
        "self.account_url",
        "BlobServiceClient",
        "self._create_container",
        "self.get_datetime_variable",
        "self.get_datetime_variable",
        "AccessPolicy",
        "ContainerSasPermissions",
        "container.set_container_access_policy",
        "response.get",
        "response.get",
        "container.get_container_access_policy",
        "acl.get",
        "acl.get",
        "acl.get"
      ],
      "api_sequence_with_args": [
        "self.account_url(storage_account_name, \"blob\")",
        "BlobServiceClient(self.account_url(storage_account_name, \"blob\"), storage_account_key)",
        "self._create_container(bsc)",
        "self.get_datetime_variable(variables, 'expiry_time', datetime.utcnow() + timedelta(hours=1))",
        "self.get_datetime_variable(variables, 'start_time', datetime.utcnow())",
        "AccessPolicy(permission=ContainerSasPermissions(read=True), expiry=expiry_time, start=start_time)",
        "ContainerSasPermissions(read=True)",
        "container.set_container_access_policy(signed_identifier)",
        "response.get('etag')",
        "response.get('last_modified')",
        "container.get_container_access_policy()",
        "acl.get('signed_identifiers')",
        "acl.get('public_access')",
        "acl.get('public_access')"
      ],
      "mapped_sequence": [
        {
          "api_name": "self.account_url",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "BlobServiceClient",
          "id": "create_http_connection",
          "description": "Creates HTTP connection to specified host",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "self._create_container",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "self.get_datetime_variable",
          "id": "parse_datetime",
          "description": "Parses string into datetime object using format",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "self.get_datetime_variable",
          "id": "parse_datetime",
          "description": "Parses string into datetime object using format",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "AccessPolicy",
          "id": "set_file_attributes",
          "description": "Sets file attributes for specified file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_attribute_management"
        },
        {
          "api_name": "ContainerSasPermissions",
          "id": "set_file_attributes",
          "description": "Sets file attributes for specified file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_attribute_management"
        },
        {
          "api_name": "container.set_container_access_policy",
          "id": "set_file_attributes",
          "description": "Sets file attributes for specified file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_attribute_management"
        },
        {
          "api_name": "response.get",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "response.get",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "container.get_container_access_policy",
          "id": "get_env_vars",
          "description": "Retrieves environment variables mapping",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "acl.get",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "acl.get",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "acl.get",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        }
      ],
      "contextual_code": "@BlobPreparer()\n@recorded_by_proxy_async\nasync def test_set_container_acl(self, **kwargs):\n    storage_account_name = kwargs.pop(\"storage_account_name\")\n    storage_account_key = kwargs.pop(\"storage_account_key\")\n    variables = kwargs.pop('variables', {})\n\n    bsc = BlobServiceClient(self.account_url(storage_account_name, \"blob\"), storage_account_key)\n    container = await self._create_container(bsc)\n\n    expiry_time = self.get_datetime_variable(variables, 'expiry_time', datetime.utcnow() + timedelta(hours=1))\n    start_time = self.get_datetime_variable(variables, 'start_time', datetime.utcnow())\n    access_policy = AccessPolicy(permission=ContainerSasPermissions(read=True),\n                                 expiry=expiry_time,\n                                 start=start_time)\n    signed_identifier = {'testid': access_policy}\n    response = await container.set_container_access_policy(signed_identifier)\n\n    assert response.get('etag') is not None\n    assert response.get('last_modified') is not None\n\n    acl = await container.get_container_access_policy()\n    assert acl is not None\n    assert len(acl.get('signed_identifiers')) == 1\n    assert acl.get('public_access') is None"
    }
  },
  {
    "pyfile": "test_blob_encryption.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/azure_storage_blob-12.25.1/azure_storage_blob-12.25.1/tests/test_blob_encryption.py",
    "line_number": "607",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "606\t            with tempfile.TemporaryFile() as temp_file:\n607\t                temp_file.write(content)\n608\t                temp_file.seek(0)",
    "code_snippet": "@BlobPreparer()\n@recorded_by_proxy\ndef test_put_blob_strict_mode(self, **kwargs):\n    storage_account_name = kwargs.pop(\"storage_account_name\")\n    storage_account_key = kwargs.pop(\"storage_account_key\")\n\n    self._setup(storage_account_name, storage_account_key)\n    self.bsc.require_encryption = True\n    content = b'Hello world'\n\n    # Assert\n    for service in self.blob_types:\n        blob_name = self._get_blob_reference(service)\n        blob = self.bsc.get_blob_client(self.container_name, blob_name)\n\n        with pytest.raises(ValueError):\n            blob.upload_blob(content, blob_type=service)\n\n        stream = BytesIO(content)\n        with pytest.raises(ValueError):\n            blob.upload_blob(stream, length=512, blob_type=service)\n\n        with tempfile.TemporaryFile() as temp_file:\n            temp_file.write(content)\n            temp_file.seek(0)\n            with pytest.raises(ValueError):\n                blob.upload_blob(temp_file, blob_type=service)\n\n            with pytest.raises(ValueError):\n                blob.upload_blob('To encrypt', blob_type=service)\n",
    "pattern_analysis": {
      "api_sequence": [
        "self._setup",
        "self.bsc.get_blob_client",
        "pytest.raises",
        "blob.upload_blob",
        "BytesIO",
        "pytest.raises",
        "blob.upload_blob",
        "tempfile.TemporaryFile",
        "temp_file.write",
        "temp_file.seek",
        "pytest.raises",
        "blob.upload_blob",
        "pytest.raises",
        "blob.upload_blob"
      ],
      "api_sequence_with_args": [
        "self._setup(storage_account_name, storage_account_key)",
        "self.bsc.get_blob_client(self.container_name, blob_name)",
        "pytest.raises(ValueError)",
        "blob.upload_blob(content, blob_type=service)",
        "BytesIO(content)",
        "pytest.raises(ValueError)",
        "blob.upload_blob(stream, length=512, blob_type=service)",
        "tempfile.TemporaryFile()",
        "temp_file.write(content)",
        "temp_file.seek(0)",
        "pytest.raises(ValueError)",
        "blob.upload_blob(temp_file, blob_type=service)",
        "pytest.raises(ValueError)",
        "blob.upload_blob('To encrypt', blob_type=service)"
      ],
      "mapped_sequence": [
        {
          "api_name": "self._setup",
          "id": "init_setup_class",
          "description": "Instantiates Setup class",
          "first_id": "data_exfiltration",
          "second_id": "data_transmission_channels",
          "third_id": "exfiltration_channel_establishment"
        },
        {
          "api_name": "self.bsc.get_blob_client",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "pytest.raises",
          "id": "error_handling_operations",
          "description": "File opening operations with error handling (ignore errors, custom error handling, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "blob.upload_blob",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "BytesIO",
          "id": "create_memory_bytes",
          "description": "Creates in-memory bytes buffer from encoded string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "pytest.raises",
          "id": "error_handling_operations",
          "description": "File opening operations with error handling (ignore errors, custom error handling, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "blob.upload_blob",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "tempfile.TemporaryFile",
          "id": "create_temp_file",
          "description": "Creates temporary file that is not deleted on close",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "temp_file.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "temp_file.seek",
          "id": "move_buffer_pointer",
          "description": "Moves buffer pointer to start",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "pytest.raises",
          "id": "error_handling_operations",
          "description": "File opening operations with error handling (ignore errors, custom error handling, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "blob.upload_blob",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "pytest.raises",
          "id": "error_handling_operations",
          "description": "File opening operations with error handling (ignore errors, custom error handling, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "blob.upload_blob",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        }
      ],
      "contextual_code": "@BlobPreparer()\n@recorded_by_proxy\ndef test_put_blob_strict_mode(self, **kwargs):\n    storage_account_name = kwargs.pop(\"storage_account_name\")\n    storage_account_key = kwargs.pop(\"storage_account_key\")\n\n    self._setup(storage_account_name, storage_account_key)\n    self.bsc.require_encryption = True\n    content = b'Hello world'\n\n    for service in self.blob_types:\n        blob_name = self._get_blob_reference(service)\n        blob = self.bsc.get_blob_client(self.container_name, blob_name)\n\n        with pytest.raises(ValueError):\n            blob.upload_blob(content, blob_type=service)\n\n        stream = BytesIO(content)\n        with pytest.raises(ValueError):\n            blob.upload_blob(stream, length=512, blob_type=service)\n\n        with tempfile.TemporaryFile() as temp_file:\n            temp_file.write(content)\n            temp_file.seek(0)\n            with pytest.raises(ValueError):\n                blob.upload_blob(temp_file, blob_type=service)\n\n            with pytest.raises(ValueError):\n                blob.upload_blob('To encrypt', blob_type=service)"
    }
  }
]