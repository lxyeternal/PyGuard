[
  {
    "metadata": {
      "package_name": "baize-0.22.2",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "requests.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/baize-0.22.2/baize-0.22.2/baize/wsgi/requests.py",
    "line_number": "188",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "187\t            body = self.body.decode(\n188\t                encoding=self.content_type.options.get(\"charset\", \"latin-1\")\n189\t            )",
    "code_snippet": "    @cached_property\n    def form(self) -> FormData:\n        \"\"\"\n        Parse the data in the form format and return it as a multi-value mapping.\n\n        If `content_type` is equal to `multipart/form-data`, it will directly\n        perform streaming analysis, and subsequent calls to `self.body`\n        or `self.json` will raise errors.\n\n        If `content_type` is not equal to `multipart/form-data` or\n        `application/x-www-form-urlencoded`, an HTTPExcption exception will be thrown.\n        \"\"\"\n        if self.content_type == \"multipart/form-data\":\n            charset = self.content_type.options.get(\"charset\", \"utf8\")\n            if \"boundary\" not in self.content_type.options:\n                raise MalformedMultipart(\"Missing boundary in header content-type\")\n            boundary = self.content_type.options[\"boundary\"].encode(\"latin-1\")\n            return self._parse_multipart(boundary, charset)\n        if self.content_type == \"application/x-www-form-urlencoded\":\n            body = self.body.decode(\n                encoding=self.content_type.options.get(\"charset\", \"latin-1\")\n            )\n            return FormData(parse_qsl(body, keep_blank_values=True))\n\n        raise UnsupportedMediaType(\n            \"multipart/form-data, application/x-www-form-urlencoded\"\n        )",
    "pattern_analysis": {
      "api_sequence": [
        "self.content_type.options.get",
        "self.content_type.options.get",
        "self.content_type.options.__contains__",
        "self.content_type.options.__getitem__",
        "str.encode",
        "self._parse_multipart",
        "self.body.decode",
        "FormData",
        "parse_qsl"
      ],
      "api_sequence_with_args": [
        "self.content_type.options.get('charset', 'utf8')",
        "self.content_type.options.get('charset', 'latin-1')",
        "'boundary' not in self.content_type.options",
        "self.content_type.options['boundary']",
        "self.content_type.options['boundary'].encode('latin-1')",
        "self._parse_multipart(boundary, charset)",
        "self.body.decode(encoding=self.content_type.options.get('charset', 'latin-1'))",
        "FormData(parse_qsl(body, keep_blank_values=True))",
        "parse_qsl(body, keep_blank_values=True)"
      ],
      "mapped_sequence": [
        {
          "api_name": "self.content_type.options.get",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "self.content_type.options.get",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "self.content_type.options.__contains__",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "self.content_type.options.__getitem__",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "str.encode",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "self._parse_multipart",
          "id": "create_multipart_writer",
          "description": "Creates multipart writer for HTTP requests",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "self.body.decode",
          "id": "decode_bytes_codec",
          "description": "Decodes bytes using specified codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "FormData",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "parse_qsl",
          "id": "encode_url_query",
          "description": "Encodes mapping object to URL query string",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        }
      ],
      "contextual_code": "@cached_property\ndef form(self) -> FormData:\n    if self.content_type == \"multipart/form-data\":\n        charset = self.content_type.options.get(\"charset\", \"utf8\")\n        if \"boundary\" not in self.content_type.options:\n            raise MalformedMultipart(\"Missing boundary in header content-type\")\n        boundary = self.content_type.options[\"boundary\"].encode(\"latin-1\")\n        return self._parse_multipart(boundary, charset)\n    if self.content_type == \"application/x-www-form-urlencoded\":\n        body = self.body.decode(encoding=self.content_type.options.get(\"charset\", \"latin-1\"))\n        return FormData(parse_qsl(body, keep_blank_values=True))"
    }
  }
]