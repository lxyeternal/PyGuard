[
  {
    "metadata": {
      "package_name": "ops-2.20.0",
      "total_matches": 3,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "test_model.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ops-2.20.0/ops-2.20.0/test/test_model.py",
    "line_number": "4185",
    "type_description": "B832:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "4184\t        # Two open ports, leave one alone and open another one.\n4185\t        fake_script.write('open-port', 'exit 0')\n4186\t        fake_script.write('close-port', 'exit 0')",
    "code_snippet": "def test_set_ports_mixed(self, fake_script: FakeScript, unit: ops.Unit):\n    # Two open ports, leave one alone and open another one.\n    fake_script.write('open-port', 'exit 0')\n    fake_script.write('close-port', 'exit 0')\n    fake_script.write('opened-ports', 'echo 8025/tcp; echo 8028/tcp')\n    unit.set_ports(ops.Port('udp', 8022), 8028)\n    assert fake_script.calls(clear=True) == [\n        ['opened-ports', ''],\n        ['close-port', '8025/tcp'],\n        ['open-port', '8022/udp'],\n    ]",
    "pattern_analysis": {
      "api_sequence": [
        "fake_script.write",
        "fake_script.write",
        "fake_script.write",
        "ops.Unit.set_ports",
        "fake_script.calls"
      ],
      "api_sequence_with_args": [
        "fake_script.write('open-port', 'exit 0')",
        "fake_script.write('close-port', 'exit 0')",
        "fake_script.write('opened-ports', 'echo 8025/tcp; echo 8028/tcp')",
        "ops.Unit.set_ports(ops.Port('udp', 8022), 8028)",
        "fake_script.calls(clear=True)"
      ],
      "mapped_sequence": [
        {
          "api_name": "fake_script.write",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "fake_script.write",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "fake_script.write",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "ops.Unit.set_ports",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "fake_script.calls",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        }
      ],
      "contextual_code": "def test_set_ports_mixed(self, fake_script: FakeScript, unit: ops.Unit):\n    fake_script.write('open-port', 'exit 0')\n    fake_script.write('close-port', 'exit 0')\n    fake_script.write('opened-ports', 'echo 8025/tcp; echo 8028/tcp')\n    unit.set_ports(ops.Port('udp', 8022), 8028)\n    assert fake_script.calls(clear=True) == [\n        ['opened-ports', ''],\n        ['close-port', '8025/tcp'],\n        ['open-port', '8022/udp'],\n    ]"
    }
  },
  {
    "pyfile": "model.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ops-2.20.0/ops-2.20.0/test/charms/test_main/lib/ops/model.py",
    "line_number": "3573",
    "type_description": "B836:rmtree",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "3572\t        finally:\n3573\t            shutil.rmtree(str(tmpdir))\n3574",
    "code_snippet": "def pod_spec_set(\n    self, spec: Mapping[str, Any], k8s_resources: Optional[Mapping[str, Any]] = None\n):\n    tmpdir = Path(tempfile.mkdtemp('-pod-spec-set'))\n    try:\n        spec_path = tmpdir / 'spec.yaml'\n        with spec_path.open('wt', encoding='utf8') as f:\n            yaml.safe_dump(spec, stream=f)\n        args = ['--file', str(spec_path)]\n        if k8s_resources:\n            k8s_res_path = tmpdir / 'k8s-resources.yaml'\n            with k8s_res_path.open('wt', encoding='utf8') as f:\n                yaml.safe_dump(k8s_resources, stream=f)\n            args.extend(['--k8s-resources', str(k8s_res_path)])\n        self._run('pod-spec-set', *args)\n    finally:\n        shutil.rmtree(str(tmpdir))",
    "pattern_analysis": {
      "api_sequence": [
        "tempfile.mkdtemp",
        "pathlib.Path",
        "pathlib.Path.__truediv__",
        "pathlib.Path.open",
        "yaml.safe_dump",
        "pathlib.Path.__truediv__",
        "pathlib.Path.open",
        "yaml.safe_dump",
        "self._run",
        "shutil.rmtree"
      ],
      "api_sequence_with_args": [
        "tempfile.mkdtemp('-pod-spec-set')",
        "pathlib.Path(tempfile.mkdtemp('-pod-spec-set'))",
        "tmpdir / 'spec.yaml'",
        "spec_path.open('wt', encoding='utf8')",
        "yaml.safe_dump(spec, stream=f)",
        "tmpdir / 'k8s-resources.yaml'",
        "k8s_res_path.open('wt', encoding='utf8')",
        "yaml.safe_dump(k8s_resources, stream=f)",
        "self._run('pod-spec-set', *args)",
        "shutil.rmtree(str(tmpdir))"
      ],
      "mapped_sequence": [
        {
          "api_name": "tempfile.mkdtemp",
          "id": "create_temp_dir",
          "description": "Creates temporary directory and returns its path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "pathlib.Path",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "pathlib.Path.__truediv__",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "pathlib.Path.open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "yaml.safe_dump",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "pathlib.Path.__truediv__",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "pathlib.Path.open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "yaml.safe_dump",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "self._run",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "shutil.rmtree",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        }
      ],
      "contextual_code": "def pod_spec_set(self, spec: Mapping[str, Any], k8s_resources: Optional[Mapping[str, Any]] = None):\n    tmpdir = Path(tempfile.mkdtemp('-pod-spec-set'))\n    try:\n        spec_path = tmpdir / 'spec.yaml'\n        with spec_path.open('wt', encoding='utf8') as f:\n            yaml.safe_dump(spec, stream=f)\n        args = ['--file', str(spec_path)]\n        if k8s_resources:\n            k8s_res_path = tmpdir / 'k8s-resources.yaml'\n            with k8s_res_path.open('wt', encoding='utf8') as f:\n                yaml.safe_dump(k8s_resources, stream=f)\n            args.extend(['--k8s-resources', str(k8s_res_path)])\n        self._run('pod-spec-set', *args)\n    finally:\n        shutil.rmtree(str(tmpdir))"
    }
  },
  {
    "pyfile": "fake_pebble.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ops-2.20.0/ops-2.20.0/test/fake_pebble.py",
    "line_number": "112",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "111\t    def do_GET(self):  # noqa: N802 (\"should be lowercase\")\n112\t        self.do_request('GET')\n113",
    "code_snippet": "class Handler(http.server.BaseHTTPRequestHandler):\n    _route = typing.List[\n        typing.Tuple[typing.Literal['GET', 'POST'], typing.Any, typing.Callable[..., None]]\n    ]\n\n    def __init__(\n        self,\n        request: socket.socket,\n        client_address: typing.Tuple[str, int],\n        server: socketserver.BaseServer,\n    ):\n        self.routes: Handler._route = [\n            ('GET', re.compile(r'^/system-info$'), self.get_system_info),\n            ('POST', re.compile(r'^/services$'), self.services_action),\n        ]\n        self._services = ['foo']\n        super().__init__(request, ('unix-socket', 80), server)\n\n    def log_message(self, format: str, *args: typing.Any):\n        # Disable logging for tests\n        pass\n\n    def respond(self, d: _Response, status: int = 200):\n        self.send_response(status)\n        self.send_header('Content-Type', 'application/json')\n        self.end_headers()\n        d_json = json.dumps(d, indent=4, sort_keys=True)\n        self.wfile.write(d_json.encode('utf-8'))\n\n    def bad_request(self, message: str):\n        d: _Response = {\n            'result': {\n                'message': message,\n            },\n            'status': 'Bad Request',\n            'status-code': 400,\n            'type': 'error',\n        }\n        self.respond(d, 400)\n\n    def not_found(self):\n        d: _Response = {\n            'result': {'message': 'invalid API endpoint requested'},\n            'status': 'Not Found',\n            'status-code': 404,\n            'type': 'error',\n        }\n        self.respond(d, 404)\n\n    def method_not_allowed(self):\n        d: _Response = {\n            'result': {'message': 'method \"PUT\" not allowed'},\n            'status': 'Method Not Allowed',\n            'status-code': 405,\n            'type': 'error',\n        }\n        self.respond(d, 405)\n\n    def internal_server_error(self, msg: Exception):\n        d: _Response = {\n            'result': {\n                'message': f'internal server error: {msg}',\n            },\n            'status': 'Internal Server Error',\n            'status-code': 500,\n            'type': 'error',\n        }\n        self.respond(d, 500)\n\n    def do_GET(self):  # noqa: N802 (\"should be lowercase\")\n        self.do_request('GET')\n\n    def do_POST(self):  # noqa: N802 (\"should be lowercase\")\n        self.do_request('POST')\n\n    def do_request(self, request_method: typing.Literal['GET', 'POST']):\n        path, _, query = self.path.partition('?')\n        path = urllib.parse.unquote(path)\n        query = dict(urllib.parse.parse_qsl(query))\n\n        if not path.startswith('/v1/'):\n            self.not_found()\n            return\n        path = path[3:]\n\n        allowed: typing.List[str] = []\n        for method, regex, func in self.routes:\n            match = regex.match(path)\n            if match:\n                if request_method == method:\n                    data = self.read_body_json()\n                    try:\n                        func(match, query, data)\n                    except Exception as e:\n                        self.internal_server_error(e)\n                        raise\n                    return\n                allowed.append(method)\n\n        if allowed:\n            self.method_not_allowed()\n            return\n\n        self.not_found()\n\n    def read_body_json(self) -> typing.Dict[str, str]:\n        try:\n            content_len = int(self.headers.get('Content-Length', ''))\n        except ValueError:\n            content_len = 0\n        if not content_len:\n            return {}\n        body = self.rfile.read(content_len)\n        if isinstance(body, bytes):\n            body = body.decode('utf-8')\n        return json.loads(body)\n\n    def get_system_info(\n        self, match: typing.Any, query: typing.Dict[str, str], data: typing.Dict[str, str]\n    ):\n        self.respond({\n            'result': {'version': '3.14.159'},\n            'status': 'OK',\n            'status-code': 200,\n            'type': 'sync',\n        })\n\n    def services_action(\n        self, match: typing.Any, query: typing.Dict[str, str], data: typing.Dict[str, str]\n    ):\n        action = data['action']\n        services = data['services']\n        if action == 'start':\n            for service in services:\n                if service not in self._services:\n                    self.bad_request(f'service \"{service}\" does not exist')\n                    return\n            self.respond({\n                'change': '1234',\n                'result': None,\n                'status': 'Accepted',\n                'status-code': 202,\n                'type': 'async',\n            })\n        else:\n            self.bad_request(f'action \"{action}\" not implemented')",
    "pattern_analysis": {
      "api_sequence": [
        "urllib.parse.unquote",
        "urllib.parse.parse_qsl",
        "json.dumps",
        "self.wfile.write",
        "self.rfile.read",
        "json.loads"
      ],
      "api_sequence_with_args": [
        "urllib.parse.unquote(path)",
        "urllib.parse.parse_qsl(query)",
        "json.dumps(d, indent=4, sort_keys=True)",
        "self.wfile.write(d_json.encode('utf-8'))",
        "self.rfile.read(content_len)",
        "json.loads(body)"
      ],
      "mapped_sequence": [
        {
          "api_name": "urllib.parse.unquote",
          "id": "percent_encode_url",
          "description": "Percent-encodes bytes for use in URL",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "urllib.parse.parse_qsl",
          "id": "encode_url_query",
          "description": "Encodes mapping object to URL query string",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "json.dumps",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "self.wfile.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "self.rfile.read",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        }
      ],
      "contextual_code": "def respond(self, d: _Response, status: int = 200):\n    self.send_response(status)\n    self.send_header('Content-Type', 'application/json')\n    self.end_headers()\n    d_json = json.dumps(d, indent=4, sort_keys=True)\n    self.wfile.write(d_json.encode('utf-8'))\n\ndef read_body_json(self) -> typing.Dict[str, str]:\n    try:\n        content_len = int(self.headers.get('Content-Length', ''))\n    except ValueError:\n        content_len = 0\n    if not content_len:\n        return {}\n    body = self.rfile.read(content_len)\n    if isinstance(body, bytes):\n        body = body.decode('utf-8')\n    return json.loads(body)\n\ndef do_request(self, request_method: typing.Literal['GET', 'POST']):\n    path, _, query = self.path.partition('?')\n    path = urllib.parse.unquote(path)\n    query = dict(urllib.parse.parse_qsl(query))"
    }
  }
]