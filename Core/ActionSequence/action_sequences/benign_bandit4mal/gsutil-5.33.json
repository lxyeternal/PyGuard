[
  {
    "metadata": {
      "package_name": "gsutil-5.33",
      "total_matches": 4,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "test_writer.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gsutil-5.33/gsutil-5.33/gslib/vendored/boto/tests/unit/glacier/test_writer.py",
    "line_number": "103",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "102\t        for write_data in write_list:\n103\t            self.writer.write(write_data)\n104\t        self.writer.close()",
    "code_snippet": "class TestWriter(unittest.TestCase):\n    def setUp(self):\n        super(TestWriter, self).setUp()\n        self.vault = create_mock_vault()\n        self.chunk_size = 2 # power of 2\n        self.part_size = 4 # power of 2\n        upload_id = sentinel.upload_id\n        self.writer = Writer(\n            self.vault, upload_id, self.part_size, self.chunk_size)\n\n    def check_write(self, write_list):\n        for write_data in write_list:\n            self.writer.write(write_data)\n        self.writer.close()\n\n        data = b''.join(write_list)\n        upload_part_calls, data_tree_hashes = calculate_mock_vault_calls(\n            data, self.part_size, self.chunk_size)\n        check_mock_vault_calls(\n            self.vault, upload_part_calls, data_tree_hashes, len(data))",
    "pattern_analysis": {
      "api_sequence": [
        "Writer.write",
        "Writer.close"
      ],
      "api_sequence_with_args": [
        "Writer.write(write_data)",
        "Writer.close()"
      ],
      "mapped_sequence": [
        {
          "api_name": "Writer.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "Writer.close",
          "id": "close_file",
          "description": "Closes the opened file",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_closing"
        }
      ],
      "contextual_code": "class TestWriter(unittest.TestCase):\n    def check_write(self, write_list):\n        for write_data in write_list:\n            self.writer.write(write_data)\n        self.writer.close()"
    }
  },
  {
    "pyfile": "test_resumable_downloads.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gsutil-5.33/gsutil-5.33/gslib/vendored/boto/tests/integration/gs/test_resumable_downloads.py",
    "line_number": "345",
    "type_description": "B810:chmod",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "344\t        try:\n345\t            os.chmod(tmp_dir, 0)\n346\t            res_download_handler = ResumableDownloadHandler(",
    "code_snippet": "    def test_download_with_unwritable_tracker_file(self):\n        \"\"\"\n        Tests resumable download with an unwritable tracker file\n        \"\"\"\n        # Make dir where tracker_file lives temporarily unwritable.\n        tmp_dir = self._MakeTempDir()\n        tracker_file_name = os.path.join(tmp_dir, 'tracker')\n        save_mod = os.stat(tmp_dir).st_mode\n        try:\n            os.chmod(tmp_dir, 0)\n            res_download_handler = ResumableDownloadHandler(\n                tracker_file_name=tracker_file_name)\n        except ResumableDownloadException as e:\n            self.assertEqual(e.disposition, ResumableTransferDisposition.ABORT)\n            self.assertNotEqual(\n                e.message.find('Couldn\\'t write URI tracker file'), -1)\n        finally:\n            # Restore original protection of dir where tracker_file lives.\n            os.chmod(tmp_dir, save_mod)\n",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.join",
        "os.stat",
        "os.chmod",
        "os.chmod"
      ],
      "api_sequence_with_args": [
        "os.path.join(tmp_dir, 'tracker')",
        "os.stat(tmp_dir)",
        "os.chmod(tmp_dir, 0)",
        "os.chmod(tmp_dir, save_mod)"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.stat",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.chmod",
          "id": "set_file_attributes",
          "description": "Sets file attributes for specified file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_attribute_management"
        },
        {
          "api_name": "os.chmod",
          "id": "set_file_attributes",
          "description": "Sets file attributes for specified file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_attribute_management"
        }
      ],
      "contextual_code": "tmp_dir = self._MakeTempDir()\ntracker_file_name = os.path.join(tmp_dir, 'tracker')\nsave_mod = os.stat(tmp_dir).st_mode\ntry:\n    os.chmod(tmp_dir, 0)\n    res_download_handler = ResumableDownloadHandler(tracker_file_name=tracker_file_name)\nexcept ResumableDownloadException as e:\n    self.assertEqual(e.disposition, ResumableTransferDisposition.ABORT)\n    self.assertNotEqual(e.message.find('Couldn\\'t write URI tracker file'), -1)\nfinally:\n    os.chmod(tmp_dir, save_mod)"
    }
  },
  {
    "pyfile": "posix_util.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gsutil-5.33/gsutil-5.33/gslib/utils/posix_util.py",
    "line_number": "537",
    "type_description": "B811:getuid",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "536\t    return\n537\t  user_id = os.getuid()\n538\t  user_name = pwd.getpwuid(user_id).pw_name",
    "code_snippet": "def InitializeUserGroups():\n  \"\"\"Initializes the set of groups that the user is in.\n\n  Should only be called if the flag for preserving POSIX attributes is set.\n  \"\"\"\n  global USER_GROUPS\n  if IS_WINDOWS:\n    return\n  user_id = os.getuid()\n  user_name = pwd.getpwuid(user_id).pw_name\n  USER_GROUPS = set(\n      # Primary group\n      [pwd.getpwuid(user_id).pw_gid] +\n      # Secondary groups\n      [g.gr_gid for g in grp.getgrall() if user_name in g.gr_mem])",
    "pattern_analysis": {
      "api_sequence": [
        "os.getuid",
        "pwd.getpwuid",
        "pwd.getpwuid",
        "grp.getgrall"
      ],
      "api_sequence_with_args": [
        "os.getuid()",
        "pwd.getpwuid(user_id)",
        "pwd.getpwuid(user_id).pw_gid",
        "grp.getgrall()"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.getuid",
          "id": "get_username",
          "description": "Retrieves current user's login name",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "pwd.getpwuid",
          "id": "get_username",
          "description": "Retrieves current user's login name",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "pwd.getpwuid",
          "id": "get_username",
          "description": "Retrieves current user's login name",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "grp.getgrall",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        }
      ],
      "contextual_code": "def InitializeUserGroups():\n  global USER_GROUPS\n  if IS_WINDOWS:\n    return\n  user_id = os.getuid()\n  user_name = pwd.getpwuid(user_id).pw_name\n  USER_GROUPS = set(\n      [pwd.getpwuid(user_id).pw_gid] +\n      [g.gr_gid for g in grp.getgrall() if user_name in g.gr_mem])"
    }
  },
  {
    "pyfile": "connection.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gsutil-5.33/gsutil-5.33/gslib/vendored/boto/boto/connection.py",
    "line_number": "1267",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1266\t    def make_request(self, action, params=None, path='/', verb='GET'):\n1267\t        http_request = self.build_base_http_request(verb, path, None,\n1268\t                                                    params, {}, '',\n1269\t                                                    self.host)\n1270\t        if action:",
    "code_snippet": "def make_request(self, action, params=None, path='/', verb='GET'):\n    http_request = self.build_base_http_request(verb, path, None,\n                                                params, {}, '',\n                                                self.host)\n    if action:\n        http_request.params['Action'] = action\n    if self.APIVersion:\n        http_request.params['Version'] = self.APIVersion\n    return self._mexe(http_request)",
    "pattern_analysis": {
      "api_sequence": [
        "self.build_base_http_request",
        "self._mexe"
      ],
      "api_sequence_with_args": [
        "self.build_base_http_request(verb, path, None, params, {}, '', self.host)",
        "self._mexe(http_request)"
      ],
      "mapped_sequence": [
        {
          "api_name": "self.build_base_http_request",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "self._mexe",
          "id": "send_http_custom",
          "description": "Sends HTTP request with specified method and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        }
      ],
      "contextual_code": "def make_request(self, action, params=None, path='/', verb='GET'):\n    http_request = self.build_base_http_request(verb, path, None,\n                                                params, {}, '',\n                                                self.host)\n    if action:\n        http_request.params['Action'] = action\n    if self.APIVersion:\n        http_request.params['Version'] = self.APIVersion\n    return self._mexe(http_request)"
    }
  }
]