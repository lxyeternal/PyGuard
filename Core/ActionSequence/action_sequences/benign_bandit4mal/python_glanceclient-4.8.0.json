[
  {
    "metadata": {
      "package_name": "python_glanceclient-4.8.0",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:40"
    }
  },
  {
    "pyfile": "https.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/python_glanceclient-4.8.0/python_glanceclient-4.8.0/glanceclient/common/https.py",
    "line_number": "250",
    "type_description": "B804:connect",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "249\t        self.sock = OpenSSLConnectionDelegator(self.context, sock)\n250\t        self.sock.connect((self.host, self.port))",
    "code_snippet": "def connect(self):\n    \"\"\"Connect to an SSL port using the OpenSSL library.\n\n    This method also applies per-connection parameters to the connection.\n    \"\"\"\n    result = socket.getaddrinfo(self.host, self.port, 0,\n                                socket.SOCK_STREAM)\n    if result:\n        socket_family = result[0][0]\n        if socket_family == socket.AF_INET6:\n            sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)\n        else:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    else:\n        # If due to some reason the address lookup fails - we still connect\n        # to IPv4 socket. This retains the older behavior.\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    if self.timeout is not None:\n        # '0' microseconds\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVTIMEO,\n                        struct.pack('LL', self.timeout, 0))\n    self.sock = OpenSSLConnectionDelegator(self.context, sock)\n    self.sock.connect((self.host, self.port))",
    "pattern_analysis": {
      "api_sequence": [
        "socket.getaddrinfo",
        "socket.socket",
        "socket.socket",
        "socket.socket",
        "socket.socket.setsockopt",
        "OpenSSLConnectionDelegator",
        "OpenSSLConnectionDelegator.connect"
      ],
      "api_sequence_with_args": [
        "socket.getaddrinfo(self.host, self.port, 0, socket.SOCK_STREAM)",
        "socket.socket(socket.AF_INET6, socket.SOCK_STREAM)",
        "socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
        "socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
        "socket.socket.setsockopt(socket.SOL_SOCKET, socket.SO_RCVTIMEO, struct.pack('LL', self.timeout, 0))",
        "OpenSSLConnectionDelegator(self.context, sock)",
        "OpenSSLConnectionDelegator.connect((self.host, self.port))"
      ],
      "mapped_sequence": [
        {
          "api_name": "socket.getaddrinfo",
          "id": "resolve_hostname",
          "description": "Resolves host name to IPv4 address",
          "first_id": "basic_network_operations",
          "second_id": "network_information_gathering",
          "third_id": "domain_resolution"
        },
        {
          "api_name": "socket.socket",
          "id": "create_socket",
          "description": "Creates new socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_creation"
        },
        {
          "api_name": "socket.socket",
          "id": "create_socket",
          "description": "Creates new socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_creation"
        },
        {
          "api_name": "socket.socket",
          "id": "create_socket",
          "description": "Creates new socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_creation"
        },
        {
          "api_name": "socket.socket.setsockopt",
          "id": "set_socket_timeout",
          "description": "Sets timeout for socket operations",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_configuration"
        },
        {
          "api_name": "OpenSSLConnectionDelegator",
          "id": "wrap_socket_ssl",
          "description": "Wraps socket for SSL/TLS communication",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "OpenSSLConnectionDelegator.connect",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        }
      ],
      "contextual_code": "def connect(self):\n    result = socket.getaddrinfo(self.host, self.port, 0, socket.SOCK_STREAM)\n    if result:\n        socket_family = result[0][0]\n        if socket_family == socket.AF_INET6:\n            sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)\n        else:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    else:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    if self.timeout is not None:\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVTIMEO, struct.pack('LL', self.timeout, 0))\n    self.sock = OpenSSLConnectionDelegator(self.context, sock)\n    self.sock.connect((self.host, self.port))"
    }
  }
]