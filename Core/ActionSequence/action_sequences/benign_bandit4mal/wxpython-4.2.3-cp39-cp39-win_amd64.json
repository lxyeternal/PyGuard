[
  {
    "metadata": {
      "package_name": "wxpython-4.2.3-cp39-cp39-win_amd64",
      "total_matches": 3,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "pydocview.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/wxpython-4.2.3-cp39-cp39-win_amd64/wx/lib/pydocview.py",
    "line_number": "1750",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1749\t        if self._sharedMemory.read_byte() == '+':  # available data\n1750\t            data = self._sharedMemory.read(1024-1)\n1751\t            self._sharedMemory.seek(0)",
    "code_snippet": "    def DoBackgroundListenAndLoad(self):\n        \"\"\"\n        Open any files specified in the given command line argument passed in via shared memory\n        \"\"\"\n        self._timer.Stop()\n\n        self._sharedMemory.seek(0)\n        if self._sharedMemory.read_byte() == '+':  # available data\n            data = self._sharedMemory.read(1024-1)\n            self._sharedMemory.seek(0)\n            self._sharedMemory.write_byte(\"*\")     # finished reading, set buffer free marker\n            self._sharedMemory.flush()\n            args = pickle.loads(data)\n            for arg in args:\n                if (wx.Platform != \"__WXMSW__\" or arg[0] != \"/\") and arg[0] != '-' and os.path.exists(arg):\n                    self.GetDocumentManager().CreateDocument(os.path.normpath(arg), wx.lib.docview.DOC_SILENT)\n\n            # force display of running app\n            topWindow = wx.GetApp().GetTopWindow()\n            if topWindow.IsIconized():\n                topWindow.Iconize(False)\n            else:\n                topWindow.Raise()\n\n\n        self._timer.Start(1000) # 1 second interval\n",
    "pattern_analysis": {
      "api_sequence": [
        "self._timer.Stop",
        "self._sharedMemory.seek",
        "self._sharedMemory.read_byte",
        "self._sharedMemory.read",
        "self._sharedMemory.seek",
        "self._sharedMemory.write_byte",
        "self._sharedMemory.flush",
        "pickle.loads",
        "os.path.exists",
        "os.path.normpath",
        "self.GetDocumentManager.CreateDocument",
        "wx.GetApp.GetTopWindow",
        "topWindow.IsIconized",
        "topWindow.Iconize",
        "topWindow.Raise",
        "self._timer.Start"
      ],
      "api_sequence_with_args": [
        "self._timer.Stop()",
        "self._sharedMemory.seek(0)",
        "self._sharedMemory.read_byte()",
        "self._sharedMemory.read(1024-1)",
        "self._sharedMemory.seek(0)",
        "self._sharedMemory.write_byte(\"*\")",
        "self._sharedMemory.flush()",
        "pickle.loads(data)",
        "os.path.exists(arg)",
        "os.path.normpath(arg)",
        "self.GetDocumentManager().CreateDocument(os.path.normpath(arg), wx.lib.docview.DOC_SILENT)",
        "wx.GetApp().GetTopWindow()",
        "topWindow.IsIconized()",
        "topWindow.Iconize(False)",
        "topWindow.Raise()",
        "self._timer.Start(1000)"
      ],
      "mapped_sequence": [
        {
          "api_name": "self._timer.Stop",
          "id": "wait_thread",
          "description": "Waits for thread to finish execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "self._sharedMemory.seek",
          "id": "move_buffer_pointer",
          "description": "Moves buffer pointer to start",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "self._sharedMemory.read_byte",
          "id": "get_buffer_bytes",
          "description": "Retrieves bytes value from in-memory buffer",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "self._sharedMemory.read",
          "id": "get_buffer_bytes",
          "description": "Retrieves bytes value from in-memory buffer",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "self._sharedMemory.seek",
          "id": "move_buffer_pointer",
          "description": "Moves buffer pointer to start",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "self._sharedMemory.write_byte",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "self._sharedMemory.flush",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "pickle.loads",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.path.normpath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "self.GetDocumentManager.CreateDocument",
          "id": "open_file_app",
          "description": "Opens file with associated application",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "wx.GetApp.GetTopWindow",
          "id": "get_window_title",
          "description": "Retrieves window title text",
          "first_id": "system_operations",
          "second_id": "window_management",
          "third_id": "window_finding"
        },
        {
          "api_name": "topWindow.IsIconized",
          "id": "check_window_visible",
          "description": "Checks if window is visible",
          "first_id": "system_operations",
          "second_id": "window_management",
          "third_id": "window_status_checking"
        },
        {
          "api_name": "topWindow.Iconize",
          "id": "minimize_window",
          "description": "Minimizes specified window",
          "first_id": "system_operations",
          "second_id": "window_management",
          "third_id": "window_control"
        },
        {
          "api_name": "topWindow.Raise",
          "id": "change_window_position",
          "description": "Changes window position and Z-order",
          "first_id": "system_operations",
          "second_id": "window_management",
          "third_id": "window_control"
        },
        {
          "api_name": "self._timer.Start",
          "id": "start_thread",
          "description": "Starts thread execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        }
      ],
      "contextual_code": "def DoBackgroundListenAndLoad(self):\n    self._timer.Stop()\n    self._sharedMemory.seek(0)\n    if self._sharedMemory.read_byte() == '+':\n        data = self._sharedMemory.read(1024-1)\n        self._sharedMemory.seek(0)\n        self._sharedMemory.write_byte(\"*\")\n        self._sharedMemory.flush()\n        args = pickle.loads(data)\n        for arg in args:\n            if (wx.Platform != \"__WXMSW__\" or arg[0] != \"/\") and arg[0] != '-' and os.path.exists(arg):\n                self.GetDocumentManager().CreateDocument(os.path.normpath(arg), wx.lib.docview.DOC_SILENT)\n        topWindow = wx.GetApp().GetTopWindow()\n        if topWindow.IsIconized():\n            topWindow.Iconize(False)\n        else:\n            topWindow.Raise()\n    self._timer.Start(1000)"
    }
  },
  {
    "pyfile": "core.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/wxpython-4.2.3-cp39-cp39-win_amd64/wx/core.py",
    "line_number": "2203",
    "type_description": "B828:signal",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "2202\t                import signal\n2203\t                signal.signal(signal.SIGINT, signal.SIG_DFL)\n2204\t            except:",
    "code_snippet": "class App(PyApp):\n    \"\"\"\n    The ``wx.App`` class represents the application and is used to:\n    \n      * bootstrap the wxPython system and initialize the underlying\n        gui toolkit\n      * set and get application-wide properties\n      * implement the native windowing system main message or event loop,\n        and to dispatch events to window instances\n      * etc.\n    \n    Every wx application must have a single ``wx.App`` instance, and all\n    creation of UI objects should be delayed until after the ``wx.App`` object\n    has been created in order to ensure that the gui platform and wxWidgets\n    have been fully initialized.\n    \n    Normally you would derive from this class and implement an ``OnInit``\n    method that creates a frame and then calls ``self.SetTopWindow(frame)``,\n    however ``wx.App`` is also usable on its own without derivation.\n    \n    :note: In Python the wrapper for the C++ class ``wxApp`` has been renamed tp\n        :class:`wx.PyApp`. This ``wx.App`` class derives from ``wx.PyApp``, and is\n        responsible for handling the Python-specific needs for bootstrapping the\n        wxWidgets library and other Python integration related requirements.\n    \"\"\"\n    outputWindowClass = PyOnDemandOutputWindow\n    def __init__(self, redirect=False, filename=None, useBestVisual=False, clearSigInt=True):\n        \"\"\"\n        Construct a ``wx.App`` object.\n        \n        :param redirect: Should ``sys.stdout`` and ``sys.stderr`` be\n            redirected?  Defaults to False. If ``filename`` is None\n            then output will be redirected to a window that pops up\n            as needed.  (You can control what kind of window is created\n            for the output by resetting the class variable\n            ``outputWindowClass`` to a class of your choosing.)\n        \n        :param filename: The name of a file to redirect output to, if\n            redirect is True.\n        \n        :param useBestVisual: Should the app try to use the best\n            available visual provided by the system (only relevant on\n            systems that have more than one visual.)  This parameter\n            must be used instead of calling `SetUseBestVisual` later\n            on because it must be set before the underlying GUI\n            toolkit is initialized.\n        \n        :param clearSigInt: Should SIGINT be cleared?  This allows the\n            app to terminate upon a Ctrl-C in the console like other\n            GUI apps will.\n        \n        :note: You should override OnInit to do application\n            initialization to ensure that the system, toolkit and\n            wxWidgets are fully initialized.\n        \"\"\"\n        PyApp.__init__(self)\n        \n        # make sure we can create a GUI\n        if not self.IsDisplayAvailable():\n        \n            if wx.Port == \"__WXMAC__\":\n                msg = \"This program needs access to the screen. Please run with a\\n\" \\\n                      \"Framework build of python, and only when you are logged in\\n\" \\\n                      \"on the main display of your Mac.\"\n        \n            elif wx.Port == \"__WXGTK__\":\n                msg =\"Unable to access the X Display, is $DISPLAY set properly?\"\n        \n            else:\n                msg = \"Unable to create GUI\"\n                # TODO: more description is needed for wxMSW...\n        \n            raise SystemExit(msg)\n        \n        # This has to be done before OnInit\n        self.SetUseBestVisual(useBestVisual)\n        \n        # Set the default handler for SIGINT.  This fixes a problem\n        # where if Ctrl-C is pressed in the console that started this\n        # app then it will not appear to do anything, (not even send\n        # KeyboardInterrupt???)  but will later segfault on exit.  By\n        # setting the default handler then the app will exit, as\n        # expected (depending on platform.)\n        if clearSigInt:\n            try:\n                import signal\n                signal.signal(signal.SIGINT, signal.SIG_DFL)\n            except:\n                pass\n        \n        # Save and redirect the stdio to a window?\n        self.stdioWin = None\n        self.saveStdio = (_sys.stdout, _sys.stderr)\n        if redirect:\n            self.RedirectStdio(filename)\n        \n        # Use Python's install prefix as the default\n        prefix = _sys.prefix\n        if isinstance(prefix, (bytes, bytearray)):\n            prefix = prefix.decode(_sys.getfilesystemencoding())\n        wx.StandardPaths.Get().SetInstallPrefix(prefix)\n        \n        # Until the new native control for wxMac is up to par, still use the generic one.\n        wx.SystemOptions.SetOption(\"mac.listctrl.always_use_generic\", 1)\n        \n        # This finishes the initialization of wxWindows and then calls\n        # the OnInit that should be present in the derived class\n        self._BootstrapApp()",
    "pattern_analysis": {
      "api_sequence": [
        "self.IsDisplayAvailable",
        "wx.Port",
        "SystemExit",
        "self.SetUseBestVisual",
        "signal.signal",
        "self.RedirectStdio",
        "_sys.prefix",
        "isinstance",
        "prefix.decode",
        "_sys.getfilesystemencoding",
        "wx.StandardPaths.Get",
        "wx.StandardPaths.Get.SetInstallPrefix",
        "wx.SystemOptions.SetOption",
        "self._BootstrapApp"
      ],
      "api_sequence_with_args": [
        "self.IsDisplayAvailable()",
        "wx.Port",
        "SystemExit(msg)",
        "self.SetUseBestVisual(useBestVisual)",
        "signal.signal(signal.SIGINT, signal.SIG_DFL)",
        "self.RedirectStdio(filename)",
        "_sys.prefix",
        "isinstance(prefix, (bytes, bytearray))",
        "prefix.decode(_sys.getfilesystemencoding())",
        "_sys.getfilesystemencoding()",
        "wx.StandardPaths.Get()",
        "wx.StandardPaths.Get().SetInstallPrefix(prefix)",
        "wx.SystemOptions.SetOption(\"mac.listctrl.always_use_generic\", 1)",
        "self._BootstrapApp()"
      ],
      "mapped_sequence": [
        {
          "api_name": "self.IsDisplayAvailable",
          "id": "check_directory_exists",
          "description": "Checks if specified path exists and is a directory",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "wx.Port",
          "id": "get_platform_info",
          "description": "Retrieves platform information as string",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "SystemExit",
          "id": "exit_program",
          "description": "Exits program with specified status code",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "self.SetUseBestVisual",
          "id": "set_file_attributes",
          "description": "Sets file attributes for specified file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_attribute_management"
        },
        {
          "api_name": "signal.signal",
          "id": "register_exit_function",
          "description": "Registers function to be called at program exit",
          "first_id": "persistence_stealth",
          "second_id": "persistence_mechanisms",
          "third_id": "persistence_configuration"
        },
        {
          "api_name": "self.RedirectStdio",
          "id": "set_builtin_attr",
          "description": "Sets attribute on builtins object",
          "first_id": "persistence_stealth",
          "second_id": "stealth_techniques",
          "third_id": "warning_disabling"
        },
        {
          "api_name": "_sys.prefix",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "isinstance",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "prefix.decode",
          "id": "decode_bytes_codec",
          "description": "Decodes bytes using specified codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "_sys.getfilesystemencoding",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "wx.StandardPaths.Get",
          "id": "path_special_operations",
          "description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "wx.StandardPaths.Get.SetInstallPrefix",
          "id": "set_file_attributes",
          "description": "Sets file attributes for specified file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_attribute_management"
        },
        {
          "api_name": "wx.SystemOptions.SetOption",
          "id": "set_file_attributes",
          "description": "Sets file attributes for specified file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_attribute_management"
        },
        {
          "api_name": "self._BootstrapApp",
          "id": "init_setup_class",
          "description": "Instantiates Setup class",
          "first_id": "data_exfiltration",
          "second_id": "data_transmission_channels",
          "third_id": "exfiltration_channel_establishment"
        }
      ],
      "contextual_code": "def __init__(self, redirect=False, filename=None, useBestVisual=False, clearSigInt=True):\n    PyApp.__init__(self)\n    if not self.IsDisplayAvailable():\n        if wx.Port == \"__WXMAC__\":\n            msg = \"This program needs access to the screen. Please run with a\\n\" \\\n                  \"Framework build of python, and only when you are logged in\\n\" \\\n                  \"on the main display of your Mac.\"\n        elif wx.Port == \"__WXGTK__\":\n            msg =\"Unable to access the X Display, is $DISPLAY set properly?\"\n        else:\n            msg = \"Unable to create GUI\"\n        raise SystemExit(msg)\n    self.SetUseBestVisual(useBestVisual)\n    if clearSigInt:\n        try:\n            import signal\n            signal.signal(signal.SIGINT, signal.SIG_DFL)\n        except:\n            pass\n    self.stdioWin = None\n    self.saveStdio = (_sys.stdout, _sys.stderr)\n    if redirect:\n        self.RedirectStdio(filename)\n    prefix = _sys.prefix\n    if isinstance(prefix, (bytes, bytearray)):\n        prefix = prefix.decode(_sys.getfilesystemencoding())\n    wx.StandardPaths.Get().SetInstallPrefix(prefix)\n    wx.SystemOptions.SetOption(\"mac.listctrl.always_use_generic\", 1)\n    self._BootstrapApp()"
    }
  },
  {
    "pyfile": "interpreter.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/wxpython-4.2.3-cp39-cp39-win_amd64/wx/py/interpreter.py",
    "line_number": "71",
    "type_description": "B842:runsource",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "70\t        else:\n71\t            more = self.more = self.runsource(source)\n72\t        dispatcher.send(signal='Interpreter.push', sender=self,",
    "code_snippet": "def push(self, command, astMod=None):\n    \"\"\"Send command to the interpreter to be executed.\n\n    Because this may be called recursively, we append a new list\n    onto the commandBuffer list and then append commands into\n    that.  If the passed in command is part of a multi-line\n    command we keep appending the pieces to the last list in\n    commandBuffer until we have a complete command. If not, we\n    delete that last list.\"\"\"\n\n    if not self.more:\n        try: del self.commandBuffer[-1]\n        except IndexError: pass\n    if not self.more: self.commandBuffer.append([])\n    self.commandBuffer[-1].append(command)\n    source = '\\n'.join(self.commandBuffer[-1])\n\n    # If an ast code module is passed, pass it to runModule instead\n    more=False\n    if astMod is not None:\n        self.runModule(astMod)\n        self.more=False\n    else:\n        more = self.more = self.runsource(source)\n    dispatcher.send(signal='Interpreter.push', sender=self,\n                    command=command, more=more, source=source)\n    return more",
    "pattern_analysis": {
      "api_sequence": [
        "self.runModule",
        "self.runsource",
        "dispatcher.send"
      ],
      "api_sequence_with_args": [
        "self.runModule(astMod)",
        "self.runsource(source)",
        "dispatcher.send(signal='Interpreter.push', sender=self, command=command, more=more, source=source)"
      ],
      "mapped_sequence": [
        {
          "api_name": "self.runModule",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "self.runsource",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "dispatcher.send",
          "id": "send_http_custom",
          "description": "Sends HTTP request with specified method and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        }
      ],
      "contextual_code": "def push(self, command, astMod=None):\n    if not self.more:\n        try: del self.commandBuffer[-1]\n        except IndexError: pass\n    if not self.more: self.commandBuffer.append([])\n    self.commandBuffer[-1].append(command)\n    source = '\\n'.join(self.commandBuffer[-1])\n    more=False\n    if astMod is not None:\n        self.runModule(astMod)\n        self.more=False\n    else:\n        more = self.more = self.runsource(source)\n    dispatcher.send(signal='Interpreter.push', sender=self,\n                    command=command, more=more, source=source)\n    return more"
    }
  }
]