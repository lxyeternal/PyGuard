[
  {
    "metadata": {
      "package_name": "mistralai-1.6.0",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:40"
    }
  },
  {
    "pyfile": "basesdk.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/mistralai-1.6.0/mistralai-1.6.0/packages/mistralai_gcp/src/mistralai_gcp/basesdk.py",
    "line_number": "199",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "198\n199\t        return client.build_request(\n200\t            method,\n201\t            url,\n202\t            params=query_params,\n203\t            content=serialized_request_body.content,\n204\t            data=serialized_request_body.data,\n205\t            files=serialized_request_body.files,\n206\t            headers=headers,\n207\t            timeout=timeout,\n208\t        )",
    "code_snippet": "def _build_request_with_client(\n    self,\n    client,\n    method,\n    path,\n    base_url,\n    url_variables,\n    request,\n    request_body_required,\n    request_has_path_params,\n    request_has_query_params,\n    user_agent_header,\n    accept_header_value,\n    _globals=None,\n    security=None,\n    timeout_ms: Optional[int] = None,\n    get_serialized_body: Optional[\n        Callable[[], Optional[SerializedRequestBody]]\n    ] = None,\n    url_override: Optional[str] = None,\n    http_headers: Optional[Mapping[str, str]] = None,\n) -> httpx.Request:\n    query_params = {}\n\n    url = url_override\n    if url is None:\n        url = utils.generate_url(\n            self._get_url(base_url, url_variables),\n            path,\n            request if request_has_path_params else None,\n            _globals if request_has_path_params else None,\n        )\n\n        query_params = utils.get_query_params(\n            request if request_has_query_params else None,\n            _globals if request_has_query_params else None,\n        )\n    else:\n        # Pick up the query parameter from the override so they can be\n        # preserved when building the request later on (necessary as of\n        # httpx 0.28).\n        parsed_override = urlparse(str(url_override))\n        query_params = parse_qs(parsed_override.query, keep_blank_values=True)\n\n    headers = utils.get_headers(request, _globals)\n    headers[\"Accept\"] = accept_header_value\n    headers[user_agent_header] = self.sdk_configuration.user_agent\n\n    if security is not None:\n        if callable(security):\n            security = security()\n\n    if security is not None:\n        security_headers, security_query_params = utils.get_security(security)\n        headers = {**headers, **security_headers}\n        query_params = {**query_params, **security_query_params}\n\n    serialized_request_body = SerializedRequestBody()\n    if get_serialized_body is not None:\n        rb = get_serialized_body()\n        if request_body_required and rb is None:\n            raise ValueError(\"request body is required\")\n\n        if rb is not None:\n            serialized_request_body = rb\n\n    if (\n        serialized_request_body.media_type is not None\n        and serialized_request_body.media_type\n        not in (\n            \"multipart/form-data\",\n            \"multipart/mixed\",\n        )\n    ):\n        headers[\"content-type\"] = serialized_request_body.media_type\n\n    if http_headers is not None:\n        for header, value in http_headers.items():\n            headers[header] = value\n\n    timeout = timeout_ms / 1000 if timeout_ms is not None else None\n\n    return client.build_request(\n        method,\n        url,\n        params=query_params,\n        content=serialized_request_body.content,\n        data=serialized_request_body.data,\n        files=serialized_request_body.files,\n        headers=headers,\n        timeout=timeout,\n    )",
    "pattern_analysis": {
      "api_sequence": [
        "utils.generate_url",
        "self._get_url",
        "utils.get_query_params",
        "urlparse",
        "parse_qs",
        "utils.get_headers",
        "self.sdk_configuration.user_agent",
        "callable",
        "utils.get_security",
        "SerializedRequestBody",
        "get_serialized_body",
        "client.build_request"
      ],
      "api_sequence_with_args": [
        "utils.generate_url(self._get_url(base_url, url_variables), path, request if request_has_path_params else None, _globals if request_has_path_params else None)",
        "self._get_url(base_url, url_variables)",
        "utils.get_query_params(request if request_has_query_params else None, _globals if request_has_query_params else None)",
        "urlparse(str(url_override))",
        "parse_qs(parsed_override.query, keep_blank_values=True)",
        "utils.get_headers(request, _globals)",
        "self.sdk_configuration.user_agent",
        "callable(security)",
        "utils.get_security(security)",
        "SerializedRequestBody()",
        "get_serialized_body()",
        "client.build_request(method, url, params=query_params, content=serialized_request_body.content, data=serialized_request_body.data, files=serialized_request_body.files, headers=headers, timeout=timeout)"
      ],
      "mapped_sequence": [
        {
          "api_name": "utils.generate_url",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "self._get_url",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "utils.get_query_params",
          "id": "encode_url_query",
          "description": "Encodes mapping object to URL query string",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "urlparse",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "parse_qs",
          "id": "encode_url_query",
          "description": "Encodes mapping object to URL query string",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "utils.get_headers",
          "id": "add_http_header",
          "description": "Adds HTTP header to request object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "self.sdk_configuration.user_agent",
          "id": "add_http_header",
          "description": "Adds HTTP header to request object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "callable",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "utils.get_security",
          "id": "add_http_header",
          "description": "Adds HTTP header to request object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "SerializedRequestBody",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "get_serialized_body",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "client.build_request",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        }
      ],
      "contextual_code": "def _build_request_with_client(\n    self,\n    client,\n    method,\n    path,\n    base_url,\n    url_variables,\n    request,\n    request_body_required,\n    request_has_path_params,\n    request_has_query_params,\n    user_agent_header,\n    accept_header_value,\n    _globals=None,\n    security=None,\n    timeout_ms: Optional[int] = None,\n    get_serialized_body: Optional[\n        Callable[[], Optional[SerializedRequestBody]]\n    ] = None,\n    url_override: Optional[str] = None,\n    http_headers: Optional[Mapping[str, str]] = None,\n) -> httpx.Request:\n    query_params = {}\n\n    url = url_override\n    if url is None:\n        url = utils.generate_url(\n            self._get_url(base_url, url_variables),\n            path,\n            request if request_has_path_params else None,\n            _globals if request_has_path_params else None,\n        )\n\n        query_params = utils.get_query_params(\n            request if request_has_query_params else None,\n            _globals if request_has_query_params else None,\n        )\n    else:\n        parsed_override = urlparse(str(url_override))\n        query_params = parse_qs(parsed_override.query, keep_blank_values=True)\n\n    headers = utils.get_headers(request, _globals)\n    headers[\"Accept\"] = accept_header_value\n    headers[user_agent_header] = self.sdk_configuration.user_agent\n\n    if security is not None:\n        if callable(security):\n            security = security()\n\n    if security is not None:\n        security_headers, security_query_params = utils.get_security(security)\n        headers = {**headers, **security_headers}\n        query_params = {**query_params, **security_query_params}\n\n    serialized_request_body = SerializedRequestBody()\n    if get_serialized_body is not None:\n        rb = get_serialized_body()\n        if request_body_required and rb is None:\n            raise ValueError(\"request body is required\")\n\n        if rb is not None:\n            serialized_request_body = rb\n\n    if (\n        serialized_request_body.media_type is not None\n        and serialized_request_body.media_type\n        not in (\n            \"multipart/form-data\",\n            \"multipart/mixed\",\n        )\n    ):\n        headers[\"content-type\"] = serialized_request_body.media_type\n\n    if http_headers is not None:\n        for header, value in http_headers.items():\n            headers[header] = value\n\n    timeout = timeout_ms / 1000 if timeout_ms is not None else None\n\n    return client.build_request(\n        method,\n        url,\n        params=query_params,\n        content=serialized_request_body.content,\n        data=serialized_request_body.data,\n        files=serialized_request_body.files,\n        headers=headers,\n        timeout=timeout,\n    )"
    }
  }
]