[
  {
    "metadata": {
      "package_name": "azure_mgmt_cosmosdb-10.0.0b5",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "setup.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/azure_mgmt_cosmosdb-10.0.0b5/azure_mgmt_cosmosdb-10.0.0b5/setup.py",
    "line_number": "36",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "35\twith open(\"README.md\", encoding=\"utf-8\") as f:\n36\t    readme = f.read()\n37\twith open(\"CHANGELOG.md\", encoding=\"utf-8\") as f:",
    "code_snippet": "import re\nimport os.path\nfrom io import open\nfrom setuptools import find_packages, setup\n\n# Change the PACKAGE_NAME only to change folder and different name\nPACKAGE_NAME = \"azure-mgmt-cosmosdb\"\nPACKAGE_PPRINT_NAME = \"Cosmos DB Management\"\n\n# a-b-c => a/b/c\npackage_folder_path = PACKAGE_NAME.replace(\"-\", \"/\")\n# a-b-c => a.b.c\nnamespace_name = PACKAGE_NAME.replace(\"-\", \".\")\n\n# Version extraction inspired from 'requests'\nwith open(\n    os.path.join(package_folder_path, \"version.py\")\n    if os.path.exists(os.path.join(package_folder_path, \"version.py\"))\n    else os.path.join(package_folder_path, \"_version.py\"),\n    \"r\",\n) as fd:\n    version = re.search(r'^VERSION\\s*=\\s*[\\'\"]([^\\'\"]*)[\\'\"]', fd.read(), re.MULTILINE).group(1)\n\nif not version:\n    raise RuntimeError(\"Cannot find version information\")\n\nwith open(\"README.md\", encoding=\"utf-8\") as f:\n    readme = f.read()\nwith open(\"CHANGELOG.md\", encoding=\"utf-8\") as f:\n    changelog = f.read()\n\nsetup(\n    name=PACKAGE_NAME,\n    version=version,\n    description=\"Microsoft Azure {} Client Library for Python\".format(PACKAGE_PPRINT_NAME),\n    long_description=readme + \"\\n\\n\" + changelog,\n    long_description_content_type=\"text/markdown\",\n    license=\"MIT License\",\n    author=\"Microsoft Corporation\",\n    author_email=\"azpysdkhelp@microsoft.com\",\n    url=\"https://github.com/Azure/azure-sdk-for-python\",\n    keywords=\"azure, azure sdk\",  # update with search keywords relevant to the azure service / product\n    classifiers=[\n        \"Development Status :: 4 - Beta\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3 :: Only\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.12\",\n        \"License :: OSI Approved :: MIT License\",\n    ],\n    zip_safe=False,\n    packages=find_packages(\n        exclude=[\n            \"tests\",\n            # Exclude packages that will be covered by PEP420 or nspkg\n            \"azure\",\n            \"azure.mgmt\",\n        ]\n    ),\n    include_package_data=True,\n    package_data={\n        \"pytyped\": [\"py.typed\"],\n    },\n    install_requires=[\n        \"isodate>=0.6.1\",\n        \"typing-extensions>=4.6.0\",\n        \"azure-common>=1.1\",\n        \"azure-mgmt-core>=1.3.2\",\n    ],\n    python_requires=\">=3.8\",\n)\n",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.join",
        "os.path.exists",
        "os.path.join",
        "open",
        "re.search",
        "fd.read",
        "re.Match.group",
        "open",
        "f.read",
        "open",
        "f.read",
        "setuptools.find_packages",
        "setuptools.setup"
      ],
      "api_sequence_with_args": [
        "os.path.join(package_folder_path, \"version.py\")",
        "os.path.exists(os.path.join(package_folder_path, \"version.py\"))",
        "os.path.join(package_folder_path, \"_version.py\")",
        "open(<path>, \"r\")",
        "re.search(r'^VERSION\\s*=\\s*[\\'\\\"]([^\\'\\\"]*)[\\'\\\"]', fd.read(), re.MULTILINE)",
        "fd.read()",
        "re.Match.group(1)",
        "open(\"README.md\", encoding=\"utf-8\")",
        "f.read()",
        "open(\"CHANGELOG.md\", encoding=\"utf-8\")",
        "f.read()",
        "setuptools.find_packages(exclude=[...])",
        "setuptools.setup(name=..., version=..., ...)"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "re.search",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "fd.read",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "re.Match.group",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "f.read",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "f.read",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "setuptools.find_packages",
          "id": "find_packages",
          "description": "Finds all packages in current directory",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "package_configuration"
        },
        {
          "api_name": "setuptools.setup",
          "id": "configure_package_install",
          "description": "Configures and initiates Python package installation",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "package_configuration"
        }
      ],
      "contextual_code": "import re\nimport os.path\nfrom io import open\nfrom setuptools import find_packages, setup\n\n# Version extraction\nwith open(\n    os.path.join(package_folder_path, \"version.py\")\n    if os.path.exists(os.path.join(package_folder_path, \"version.py\"))\n    else os.path.join(package_folder_path, \"_version.py\"),\n    \"r\",\n) as fd:\n    version = re.search(r'^VERSION\\s*=\\s*[\\'\\\"]([^\\'\\\"]*)[\\'\\\"]', fd.read(), re.MULTILINE).group(1)\n\nwith open(\"README.md\", encoding=\"utf-8\") as f:\n    readme = f.read()\nwith open(\"CHANGELOG.md\", encoding=\"utf-8\") as f:\n    changelog = f.read()\n\nsetup(\n    name=PACKAGE_NAME,\n    version=version,\n    description=\"Microsoft Azure {} Client Library for Python\".format(PACKAGE_PPRINT_NAME),\n    long_description=readme + \"\\n\\n\" + changelog,\n    long_description_content_type=\"text/markdown\",\n    license=\"MIT License\",\n    author=\"Microsoft Corporation\",\n    author_email=\"azpysdkhelp@microsoft.com\",\n    url=\"https://github.com/Azure/azure-sdk-for-python\",\n    keywords=\"azure, azure sdk\",\n    classifiers=[...],\n    zip_safe=False,\n    packages=find_packages(\n        exclude=[\n            \"tests\",\n            \"azure\",\n            \"azure.mgmt\",\n        ]\n    ),\n    include_package_data=True,\n    package_data={\n        \"pytyped\": [\"py.typed\"],\n    },\n    install_requires=[...],\n    python_requires=\">=3.8\",\n)"
    }
  },
  {
    "pyfile": "_mongo_db_resources_operations.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/azure_mgmt_cosmosdb-10.0.0b5/azure_mgmt_cosmosdb-10.0.0b5/azure/mgmt/cosmosdb/operations/_mongo_db_resources_operations.py",
    "line_number": "4782",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "4781\t            try:\n4782\t                response.read()  # Load the body in memory and close the socket\n4783\t            except (StreamConsumedError, StreamClosedError):",
    "code_snippet": "def _create_update_mongo_db_database_initial(\n    self,\n    resource_group_name: str,\n    account_name: str,\n    database_name: str,\n    create_update_mongo_db_database_parameters: Union[_models.MongoDBDatabaseCreateUpdateParameters, IO[bytes]],\n    **kwargs: Any\n) -> Iterator[bytes]:\n    error_map: MutableMapping = {\n        401: ClientAuthenticationError,\n        404: ResourceNotFoundError,\n        409: ResourceExistsError,\n        304: ResourceNotModifiedError,\n    }\n    error_map.update(kwargs.pop(\"error_map\", {}) or {})\n\n    _headers = case_insensitive_dict(kwargs.pop(\"headers\", {}) or {})\n    _params = case_insensitive_dict(kwargs.pop(\"params\", {}) or {})\n\n    api_version: str = kwargs.pop(\"api_version\", _params.pop(\"api-version\", self._config.api_version))\n    content_type: Optional[str] = kwargs.pop(\"content_type\", _headers.pop(\"Content-Type\", None))\n    cls: ClsType[Iterator[bytes]] = kwargs.pop(\"cls\", None)\n\n    content_type = content_type or \"application/json\"\n    _json = None\n    _content = None\n    if isinstance(create_update_mongo_db_database_parameters, (IOBase, bytes)):\n        _content = create_update_mongo_db_database_parameters\n    else:\n        _json = self._serialize.body(\n            create_update_mongo_db_database_parameters, \"MongoDBDatabaseCreateUpdateParameters\"\n        )\n\n    _request = build_create_update_mongo_db_database_request(\n        resource_group_name=resource_group_name,\n        account_name=account_name,\n        database_name=database_name,\n        subscription_id=self._config.subscription_id,\n        api_version=api_version,\n        content_type=content_type,\n        json=_json,\n        content=_content,\n        headers=_headers,\n        params=_params,\n    )\n    _request.url = self._client.format_url(_request.url)\n\n    _decompress = kwargs.pop(\"decompress\", True)\n    _stream = True\n    pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access\n        _request, stream=_stream, **kwargs\n    )\n\n    response = pipeline_response.http_response\n\n    if response.status_code not in [200, 202]:\n        try:\n            response.read()  # Load the body in memory and close the socket\n        except (StreamConsumedError, StreamClosedError):\n            pass\n        map_error(status_code=response.status_code, response=response, error_map=error_map)\n        raise HttpResponseError(response=response, error_format=ARMErrorFormat)\n\n    response_headers = {}\n    if response.status_code == 202:\n        response_headers[\"azure-AsyncOperation\"] = self._deserialize(\n            \"str\", response.headers.get(\"azure-AsyncOperation\")\n        )\n        response_headers[\"location\"] = self._deserialize(\"str\", response.headers.get(\"location\"))\n\n    deserialized = response.stream_download(self._client._pipeline, decompress=_decompress)\n\n    if cls:\n        return cls(pipeline_response, deserialized, response_headers)  # type: ignore\n\n    return deserialized  # type: ignore",
    "pattern_analysis": {
      "api_sequence": [
        "self._serialize.body",
        "build_create_update_mongo_db_database_request",
        "self._client.format_url",
        "self._client._pipeline.run",
        "pipeline_response.http_response.read",
        "map_error",
        "response.stream_download"
      ],
      "api_sequence_with_args": [
        "self._serialize.body(create_update_mongo_db_database_parameters, \"MongoDBDatabaseCreateUpdateParameters\")",
        "build_create_update_mongo_db_database_request(resource_group_name=resource_group_name, account_name=account_name, database_name=database_name, subscription_id=self._config.subscription_id, api_version=api_version, content_type=content_type, json=_json, content=_content, headers=_headers, params=_params)",
        "self._client.format_url(_request.url)",
        "self._client._pipeline.run(_request, stream=_stream, **kwargs)",
        "pipeline_response.http_response.read()",
        "map_error(status_code=response.status_code, response=response, error_map=error_map)",
        "response.stream_download(self._client._pipeline, decompress=_decompress)"
      ],
      "mapped_sequence": [
        {
          "api_name": "self._serialize.body",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "build_create_update_mongo_db_database_request",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "self._client.format_url",
          "id": "percent_encode_url",
          "description": "Percent-encodes bytes for use in URL",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "self._client._pipeline.run",
          "id": "send_http_put",
          "description": "Sends HTTP PUT request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "pipeline_response.http_response.read",
          "id": "read_response_body",
          "description": "Reads response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "map_error",
          "id": "raise_http_error",
          "description": "Raises HTTPError if response status code indicates error",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "response.stream_download",
          "id": "read_response_bytes",
          "description": "Reads response body as bytes",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        }
      ],
      "contextual_code": "def _create_update_mongo_db_database_initial(\n    self,\n    resource_group_name: str,\n    account_name: str,\n    database_name: str,\n    create_update_mongo_db_database_parameters: Union[_models.MongoDBDatabaseCreateUpdateParameters, IO[bytes]],\n    **kwargs: Any\n) -> Iterator[bytes]:\n    ...\n    if isinstance(create_update_mongo_db_database_parameters, (IOBase, bytes)):\n        _content = create_update_mongo_db_database_parameters\n    else:\n        _json = self._serialize.body(\n            create_update_mongo_db_database_parameters, \"MongoDBDatabaseCreateUpdateParameters\"\n        )\n\n    _request = build_create_update_mongo_db_database_request(\n        resource_group_name=resource_group_name,\n        account_name=account_name,\n        database_name=database_name,\n        subscription_id=self._config.subscription_id,\n        api_version=api_version,\n        content_type=content_type,\n        json=_json,\n        content=_content,\n        headers=_headers,\n        params=_params,\n    )\n    _request.url = self._client.format_url(_request.url)\n\n    pipeline_response: PipelineResponse = self._client._pipeline.run(\n        _request, stream=_stream, **kwargs\n    )\n\n    response = pipeline_response.http_response\n\n    if response.status_code not in [200, 202]:\n        try:\n            response.read()\n        except (StreamConsumedError, StreamClosedError):\n            pass\n        map_error(status_code=response.status_code, response=response, error_map=error_map)\n        raise HttpResponseError(response=response, error_format=ARMErrorFormat)\n\n    deserialized = response.stream_download(self._client._pipeline, decompress=_decompress)\n    ..."
    }
  }
]