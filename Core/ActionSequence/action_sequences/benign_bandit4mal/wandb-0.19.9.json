[
  {
    "metadata": {
      "package_name": "wandb-0.19.9",
      "total_matches": 3,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "sender.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/wandb-0.19.9/wandb-0.19.9/wandb/sdk/internal/sender.py",
    "line_number": "1602",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1601\t        server_info = self.get_server_info()\n1602\t        max_cli_version = server_info.get(\"cliVersionInfo\", {}).get(\n1603\t            \"max_cli_version\", None",
    "code_snippet": "def _max_cli_version(self) -> Optional[str]:\n    server_info = self.get_server_info()\n    max_cli_version = server_info.get(\"cliVersionInfo\", {}).get(\n        \"max_cli_version\", None\n    )\n    if not isinstance(max_cli_version, str):\n        return None\n    return max_cli_version",
    "pattern_analysis": {
      "api_sequence": [
        "self.get_server_info",
        "dict.get",
        "dict.get",
        "isinstance"
      ],
      "api_sequence_with_args": [
        "self.get_server_info()",
        "server_info.get(\"cliVersionInfo\", {})",
        "server_info.get(\"cliVersionInfo\", {}).get(\"max_cli_version\", None)",
        "isinstance(max_cli_version, str)"
      ],
      "mapped_sequence": [
        {
          "api_name": "isinstance",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        }
      ],
      "contextual_code": "def _max_cli_version(self) -> Optional[str]:\n    server_info = self.get_server_info()\n    max_cli_version = server_info.get(\"cliVersionInfo\", {}).get(\n        \"max_cli_version\", None\n    )\n    if not isinstance(max_cli_version, str):\n        return None\n    return max_cli_version"
    }
  },
  {
    "pyfile": "audio.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/wandb-0.19.9/wandb-0.19.9/wandb/sdk/data_types/audio.py",
    "line_number": "51",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "50\t            tmp_path = os.path.join(MEDIA_TMP.name, runid.generate_id() + \".wav\")\n51\t            soundfile.write(tmp_path, data_or_path, sample_rate)\n52\t            self._duration = len(data_or_path) / float(sample_rate)",
    "code_snippet": "def __init__(self, data_or_path, sample_rate=None, caption=None):\n    \"\"\"Accept a path to an audio file or a numpy array of audio data.\"\"\"\n    super().__init__(caption=caption)\n    self._duration = None\n    self._sample_rate = sample_rate\n\n    if isinstance(data_or_path, str):\n        if self.path_is_reference(data_or_path):\n            self._path = data_or_path\n            self._sha256 = hashlib.sha256(data_or_path.encode(\"utf-8\")).hexdigest()\n            self._is_tmp = False\n        else:\n            self._set_file(data_or_path, is_tmp=False)\n    else:\n        if sample_rate is None:\n            raise ValueError(\n                'Argument \"sample_rate\" is required when instantiating wandb.Audio with raw data.'\n            )\n\n        soundfile = util.get_module(\n            \"soundfile\",\n            required='Raw audio requires the soundfile package. To get it, run \"pip install soundfile\"',\n        )\n\n        tmp_path = os.path.join(MEDIA_TMP.name, runid.generate_id() + \".wav\")\n        soundfile.write(tmp_path, data_or_path, sample_rate)\n        self._duration = len(data_or_path) / float(sample_rate)\n\n        self._set_file(tmp_path, is_tmp=True)",
    "pattern_analysis": {
      "api_sequence": [
        "isinstance",
        "self.path_is_reference",
        "hashlib.sha256",
        "str.encode",
        "hashlib.sha256.hexdigest",
        "self._set_file",
        "util.get_module",
        "os.path.join",
        "MEDIA_TMP.name",
        "runid.generate_id",
        "soundfile.write",
        "len",
        "self._set_file"
      ],
      "api_sequence_with_args": [
        "isinstance(data_or_path, str)",
        "self.path_is_reference(data_or_path)",
        "hashlib.sha256(data_or_path.encode(\"utf-8\"))",
        "data_or_path.encode(\"utf-8\")",
        "hashlib.sha256(data_or_path.encode(\"utf-8\")).hexdigest()",
        "self._set_file(data_or_path, is_tmp=False)",
        "util.get_module(\"soundfile\", required='Raw audio requires the soundfile package. To get it, run \"pip install soundfile\"')",
        "os.path.join(MEDIA_TMP.name, runid.generate_id() + \".wav\")",
        "MEDIA_TMP.name",
        "runid.generate_id()",
        "soundfile.write(tmp_path, data_or_path, sample_rate)",
        "len(data_or_path)",
        "self._set_file(tmp_path, is_tmp=True)"
      ],
      "mapped_sequence": [
        {
          "api_name": "isinstance",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "self.path_is_reference",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "hashlib.sha256",
          "id": "create_sha256_hash",
          "description": "Creates SHA-256 hash object from encoded string",
          "first_id": "encryption_hashing",
          "second_id": "hash_calculation",
          "third_id": "hash_object_creation"
        },
        {
          "api_name": "str.encode",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "hashlib.sha256.hexdigest",
          "id": "get_sha256_digest",
          "description": "Returns hexadecimal digest of SHA-256 hash",
          "first_id": "encryption_hashing",
          "second_id": "hash_calculation",
          "third_id": "hash_value_retrieval"
        },
        {
          "api_name": "self._set_file",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "util.get_module",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "MEDIA_TMP.name",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "runid.generate_id",
          "id": "get_global_symbols",
          "description": "Retrieves global symbol table as dictionary",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "soundfile.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "len",
          "id": "get_global_symbols",
          "description": "Retrieves global symbol table as dictionary",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "self._set_file",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        }
      ],
      "contextual_code": "def __init__(self, data_or_path, sample_rate=None, caption=None):\n    super().__init__(caption=caption)\n    self._duration = None\n    self._sample_rate = sample_rate\n\n    if isinstance(data_or_path, str):\n        if self.path_is_reference(data_or_path):\n            self._path = data_or_path\n            self._sha256 = hashlib.sha256(data_or_path.encode(\"utf-8\")).hexdigest()\n            self._is_tmp = False\n        else:\n            self._set_file(data_or_path, is_tmp=False)\n    else:\n        if sample_rate is None:\n            raise ValueError(\n                'Argument \"sample_rate\" is required when instantiating wandb.Audio with raw data.'\n            )\n\n        soundfile = util.get_module(\n            \"soundfile\",\n            required='Raw audio requires the soundfile package. To get it, run \"pip install soundfile\"',\n        )\n\n        tmp_path = os.path.join(MEDIA_TMP.name, runid.generate_id() + \".wav\")\n        soundfile.write(tmp_path, data_or_path, sample_rate)\n        self._duration = len(data_or_path) / float(sample_rate)\n\n        self._set_file(tmp_path, is_tmp=True)"
    }
  },
  {
    "pyfile": "__init__.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/wandb-0.19.9/wandb-0.19.9/wandb/vendor/pygments/formatters/__init__.py",
    "line_number": "101",
    "type_description": "B800:exec_used",
    "severity": "Medium",
    "confidence": "High",
    "original_snippet": "100\t        custom_namespace = {}\n101\t        exec(open(filename, 'rb').read(), custom_namespace)\n102\t        # Retrieve the class `formattername` from that namespace",
    "code_snippet": "def load_formatter_from_file(filename, formattername=\"CustomFormatter\",\n                             **options):\n    \"\"\"Load a formatter from a file.\n\n    This method expects a file located relative to the current working\n    directory, which contains a class named CustomFormatter. By default,\n    it expects the Formatter to be named CustomFormatter; you can specify\n    your own class name as the second argument to this function.\n\n    Users should be very careful with the input, because this method\n    is equivalent to running eval on the input file.\n\n    Raises ClassNotFound if there are any problems importing the Formatter.\n\n    .. versionadded:: 2.2\n    \"\"\"\n    try:\n        # This empty dict will contain the namespace for the exec'd file\n        custom_namespace = {}\n        exec(open(filename, 'rb').read(), custom_namespace)\n        # Retrieve the class `formattername` from that namespace\n        if formattername not in custom_namespace:\n            raise ClassNotFound('no valid %s class found in %s' %\n                                (formattername, filename))\n        formatter_class = custom_namespace[formattername]\n        # And finally instantiate it with the options\n        return formatter_class(**options)\n    except IOError as err:\n        raise ClassNotFound('cannot read %s' % filename)\n    except ClassNotFound as err:\n        raise\n    except Exception as err:\n        raise ClassNotFound('error when loading custom formatter: %s' % err)\n",
    "pattern_analysis": {
      "api_sequence": [
        "open",
        "exec",
        "formatter_class"
      ],
      "api_sequence_with_args": [
        "open(filename, 'rb')",
        "exec(open(filename, 'rb').read(), custom_namespace)",
        "formatter_class(**options)"
      ],
      "mapped_sequence": [
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "exec",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        }
      ],
      "contextual_code": "def load_formatter_from_file(filename, formattername=\"CustomFormatter\", **options):\n    try:\n        custom_namespace = {}\n        exec(open(filename, 'rb').read(), custom_namespace)\n        if formattername not in custom_namespace:\n            raise ClassNotFound('no valid %s class found in %s' % (formattername, filename))\n        formatter_class = custom_namespace[formattername]\n        return formatter_class(**options)\n    except IOError as err:\n        raise ClassNotFound('cannot read %s' % filename)\n    except ClassNotFound as err:\n        raise\n    except Exception as err:\n        raise ClassNotFound('error when loading custom formatter: %s' % err)"
    }
  }
]