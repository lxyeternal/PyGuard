[
  {
    "metadata": {
      "package_name": "pikepdf-9.7.0",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "test_io.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pikepdf-9.7.0/pikepdf-9.7.0/tests/test_io.py",
    "line_number": "224",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "223\t    with atomic_overwrite(existing_file) as f:\n224\t        f.write(b'new')\n225\t    assert existing_file.read_bytes() == b'new'",
    "code_snippet": "def test_atomic_overwrite_existing(tmp_path):\n    existing_file = tmp_path / 'existing.pdf'\n    existing_file.write_bytes(b'existing')\n\n    with atomic_overwrite(existing_file) as f:\n        f.write(b'new')\n    assert existing_file.read_bytes() == b'new'\n\n    with pytest.raises(ValueError, match='oops'), atomic_overwrite(existing_file) as f:\n        f.write(b'a failed update should not corrupt the file')\n        raise ValueError('oops')\n    assert existing_file.read_bytes() == b'new'\n\n    assert list(tmp_path.glob('*.pikepdf')) == [], \"Temporary files were not cleaned up\"",
    "pattern_analysis": {
      "api_sequence": [
        "pathlib.Path.write_bytes",
        "atomic_overwrite",
        "io.BufferedWriter.write",
        "pathlib.Path.read_bytes",
        "pytest.raises",
        "atomic_overwrite",
        "io.BufferedWriter.write",
        "pathlib.Path.read_bytes",
        "pathlib.Path.glob"
      ],
      "api_sequence_with_args": [
        "pathlib.Path.write_bytes(b'existing')",
        "atomic_overwrite(existing_file)",
        "io.BufferedWriter.write(b'new')",
        "pathlib.Path.read_bytes()",
        "pytest.raises(ValueError, match='oops')",
        "atomic_overwrite(existing_file)",
        "io.BufferedWriter.write(b'a failed update should not corrupt the file')",
        "pathlib.Path.read_bytes()",
        "pathlib.Path.glob('*.pikepdf')"
      ],
      "mapped_sequence": [
        {
          "api_name": "pathlib.Path.write_bytes",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "atomic_overwrite",
          "id": "combined_mode_operations",
          "description": "Combined mode file opening operations (read-write mode, append mode, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "io.BufferedWriter.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "pathlib.Path.read_bytes",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "pytest.raises",
          "id": "error_handling_operations",
          "description": "File opening operations with error handling (ignore errors, custom error handling, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "atomic_overwrite",
          "id": "combined_mode_operations",
          "description": "Combined mode file opening operations (read-write mode, append mode, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "io.BufferedWriter.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "pathlib.Path.read_bytes",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "pathlib.Path.glob",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        }
      ],
      "contextual_code": "def test_atomic_overwrite_existing(tmp_path):\n    existing_file = tmp_path / 'existing.pdf'\n    existing_file.write_bytes(b'existing')\n\n    with atomic_overwrite(existing_file) as f:\n        f.write(b'new')\n    assert existing_file.read_bytes() == b'new'\n\n    with pytest.raises(ValueError, match='oops'), atomic_overwrite(existing_file) as f:\n        f.write(b'a failed update should not corrupt the file')\n        raise ValueError('oops')\n    assert existing_file.read_bytes() == b'new'\n\n    assert list(tmp_path.glob('*.pikepdf')) == [], \"Temporary files were not cleaned up\""
    }
  },
  {
    "pyfile": "test_io.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pikepdf-9.7.0/pikepdf-9.7.0/tests/test_io.py",
    "line_number": "34",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "33\t        amt = min(len(b), 100)\n34\t        return super().write(b[:amt])\n35",
    "code_snippet": "class LimitedBytesIO(BytesIO):\n    \"\"\"Version of BytesIO that only accepts small reads/writes.\"\"\"\n\n    def write(self, b):\n        amt = min(len(b), 100)\n        return super().write(b[:amt])",
    "pattern_analysis": {
      "api_sequence": [],
      "api_sequence_with_args": [],
      "mapped_sequence": [],
      "contextual_code": "class LimitedBytesIO(BytesIO):\n    \"\"\"Version of BytesIO that only accepts small reads/writes.\"\"\"\n\n    def write(self, b):\n        amt = min(len(b), 100)\n        return super().write(b[:amt])"
    }
  }
]