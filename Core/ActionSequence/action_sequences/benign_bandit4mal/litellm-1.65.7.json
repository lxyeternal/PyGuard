[
  {
    "metadata": {
      "package_name": "litellm-1.65.7",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "main.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/litellm-1.65.7/litellm-1.65.7/litellm/secret_managers/main.py",
    "line_number": "259",
    "type_description": "B801:b64decode",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "258\t                    # Decode the base64 encoded ciphertext\n259\t                    ciphertext_blob = base64.b64decode(encrypted_value)\n260",
    "code_snippet": "def get_secret(  # noqa: PLR0915\n    secret_name: str,\n    default_value: Optional[Union[str, bool]] = None,\n):\n    key_management_system = litellm._key_management_system\n    key_management_settings = litellm._key_management_settings\n    secret = None\n\n    if secret_name.startswith(\"os.environ/\"):\n        secret_name = secret_name.replace(\"os.environ/\", \"\")\n\n    # Example: oidc/google/https://bedrock-runtime.us-east-1.amazonaws.com/model/stability.stable-diffusion-xl-v1/invoke\n    if secret_name.startswith(\"oidc/\"):\n        secret_name_split = secret_name.replace(\"oidc/\", \"\")\n        oidc_provider, oidc_aud = secret_name_split.split(\"/\", 1)\n        # TODO: Add caching for HTTP requests\n        if oidc_provider == \"google\":\n            oidc_token = oidc_cache.get_cache(key=secret_name)\n            if oidc_token is not None:\n                return oidc_token\n\n            oidc_client = HTTPHandler(timeout=httpx.Timeout(timeout=600.0, connect=5.0))\n            # https://cloud.google.com/compute/docs/instances/verifying-instance-identity#request_signature\n            response = oidc_client.get(\n                \"http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/identity\",\n                params={\"audience\": oidc_aud},\n                headers={\"Metadata-Flavor\": \"Google\"},\n            )\n            if response.status_code == 200:\n                oidc_token = response.text\n                oidc_cache.set_cache(key=secret_name, value=oidc_token, ttl=3600 - 60)\n                return oidc_token\n            else:\n                raise ValueError(\"Google OIDC provider failed\")\n        elif oidc_provider == \"circleci\":\n            # https://circleci.com/docs/openid-connect-tokens/\n            env_secret = os.getenv(\"CIRCLE_OIDC_TOKEN\")\n            if env_secret is None:\n                raise ValueError(\"CIRCLE_OIDC_TOKEN not found in environment\")\n            return env_secret\n        elif oidc_provider == \"circleci_v2\":\n            # https://circleci.com/docs/openid-connect-tokens/\n            env_secret = os.getenv(\"CIRCLE_OIDC_TOKEN_V2\")\n            if env_secret is None:\n                raise ValueError(\"CIRCLE_OIDC_TOKEN_V2 not found in environment\")\n            return env_secret\n        elif oidc_provider == \"github\":\n            # https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers#using-custom-actions\n            actions_id_token_request_url = os.getenv(\"ACTIONS_ID_TOKEN_REQUEST_URL\")\n            actions_id_token_request_token = os.getenv(\"ACTIONS_ID_TOKEN_REQUEST_TOKEN\")\n            if (\n                actions_id_token_request_url is None\n                or actions_id_token_request_token is None\n            ):\n                raise ValueError(\n                    \"ACTIONS_ID_TOKEN_REQUEST_URL or ACTIONS_ID_TOKEN_REQUEST_TOKEN not found in environment\"\n                )\n\n            oidc_token = oidc_cache.get_cache(key=secret_name)\n            if oidc_token is not None:\n                return oidc_token\n\n            oidc_client = HTTPHandler(timeout=httpx.Timeout(timeout=600.0, connect=5.0))\n            response = oidc_client.get(\n                actions_id_token_request_url,\n                params={\"audience\": oidc_aud},\n                headers={\n                    \"Authorization\": f\"Bearer {actions_id_token_request_token}\",\n                    \"Accept\": \"application/json; api-version=2.0\",\n                },\n            )\n            if response.status_code == 200:\n                oidc_token = response.json().get(\"value\", None)\n                oidc_cache.set_cache(key=secret_name, value=oidc_token, ttl=300 - 5)\n                return oidc_token\n            else:\n                raise ValueError(\"Github OIDC provider failed\")\n        elif oidc_provider == \"azure\":\n            # https://azure.github.io/azure-workload-identity/docs/quick-start.html\n            azure_federated_token_file = os.getenv(\"AZURE_FEDERATED_TOKEN_FILE\")\n            if azure_federated_token_file is None:\n                raise ValueError(\"AZURE_FEDERATED_TOKEN_FILE not found in environment\")\n            with open(azure_federated_token_file, \"r\") as f:\n                oidc_token = f.read()\n                return oidc_token\n        elif oidc_provider == \"file\":\n            # Load token from a file\n            with open(oidc_aud, \"r\") as f:\n                oidc_token = f.read()\n                return oidc_token\n        elif oidc_provider == \"env\":\n            # Load token directly from an environment variable\n            oidc_token = os.getenv(oidc_aud)\n            if oidc_token is None:\n                raise ValueError(f\"Environment variable {oidc_aud} not found\")\n            return oidc_token\n        elif oidc_provider == \"env_path\":\n            # Load token from a file path specified in an environment variable\n            token_file_path = os.getenv(oidc_aud)\n            if token_file_path is None:\n                raise ValueError(f\"Environment variable {oidc_aud} not found\")\n            with open(token_file_path, \"r\") as f:\n                oidc_token = f.read()\n                return oidc_token\n        else:\n            raise ValueError(\"Unsupported OIDC provider\")\n\n    try:\n        if (\n            _should_read_secret_from_secret_manager()\n            and litellm.secret_manager_client is not None\n        ):\n            try:\n                client = litellm.secret_manager_client\n                key_manager = \"local\"\n                if key_management_system is not None:\n                    key_manager = key_management_system.value\n\n                if key_management_settings is not None:\n                    if (\n                        key_management_settings.hosted_keys is not None\n                        and secret_name not in key_management_settings.hosted_keys\n                    ):  # allow user to specify which keys to check in hosted key manager\n                        key_manager = \"local\"\n\n                if (\n                    key_manager == KeyManagementSystem.AZURE_KEY_VAULT.value\n                    or type(client).__module__ + \".\" + type(client).__name__\n                    == \"azure.keyvault.secrets._client.SecretClient\"\n                ):  # support Azure Secret Client - from azure.keyvault.secrets import SecretClient\n                    secret = client.get_secret(secret_name).value\n                elif (\n                    key_manager == KeyManagementSystem.GOOGLE_KMS.value\n                    or client.__class__.__name__ == \"KeyManagementServiceClient\"\n                ):\n                    encrypted_secret: Any = os.getenv(secret_name)\n                    if encrypted_secret is None:\n                        raise ValueError(\n                            \"Google KMS requires the encrypted secret to be in the environment!\"\n                        )\n                    b64_flag = _is_base64(encrypted_secret)\n                    if b64_flag is True:  # if passed in as encoded b64 string\n                        encrypted_secret = base64.b64decode(encrypted_secret)\n                        ciphertext = encrypted_secret\n                    else:\n                        raise ValueError(\n                            \"Google KMS requires the encrypted secret to be encoded in base64\"\n                        )  # fix for this vulnerability https://huntr.com/bounties/ae623c2f-b64b-4245-9ed4-f13a0a5824ce\n                    response = client.decrypt(\n                        request={\n                            \"name\": litellm._google_kms_resource_name,\n                            \"ciphertext\": ciphertext,\n                        }\n                    )\n                    secret = response.plaintext.decode(\n                        \"utf-8\"\n                    )  # assumes the original value was encoded with utf-8\n                elif key_manager == KeyManagementSystem.AWS_KMS.value:\n                    \"\"\"\n                    Only check the tokens which start with 'aws_kms/'. This prevents latency impact caused by checking all keys.\n                    \"\"\"\n                    encrypted_value = os.getenv(secret_name, None)\n                    if encrypted_value is None:\n                        raise Exception(\n                            \"AWS KMS - Encrypted Value of Key={} is None\".format(\n                                secret_name\n                            )\n                        )\n                    # Decode the base64 encoded ciphertext\n                    ciphertext_blob = base64.b64decode(encrypted_value)\n\n                    # Set up the parameters for the decrypt call\n                    params = {\"CiphertextBlob\": ciphertext_blob}\n                    # Perform the decryption\n                    response = client.decrypt(**params)\n\n                    # Extract and decode the plaintext\n                    plaintext = response[\"Plaintext\"]\n                    secret = plaintext.decode(\"utf-8\")\n                    if isinstance(secret, str):\n                        secret = secret.strip()\n                elif key_manager == KeyManagementSystem.AWS_SECRET_MANAGER.value:\n                    from litellm.secret_managers.aws_secret_manager_v2 import (\n                        AWSSecretsManagerV2,\n                    )\n\n                    if isinstance(client, AWSSecretsManagerV2):\n                        secret = client.sync_read_secret(\n                            secret_name=secret_name,\n                            primary_secret_name=key_management_settings.primary_secret_name,\n                        )\n                        print_verbose(f\"get_secret_value_response: {secret}\")\n                elif key_manager == KeyManagementSystem.GOOGLE_SECRET_MANAGER.value:\n                    try:\n                        secret = client.get_secret_from_google_secret_manager(\n                            secret_name\n                        )\n                        print_verbose(f\"secret from google secret manager:  {secret}\")\n                        if secret is None:\n                            raise ValueError(\n                                f\"No secret found in Google Secret Manager for {secret_name}\"\n                            )\n                    except Exception as e:\n                        print_verbose(f\"An error occurred - {str(e)}\")\n                        raise e\n                elif key_manager == KeyManagementSystem.HASHICORP_VAULT.value:\n                    try:\n                        secret = client.sync_read_secret(secret_name=secret_name)\n                        if secret is None:\n                            raise ValueError(\n                                f\"No secret found in Hashicorp Secret Manager for {secret_name}\"\n                            )\n                    except Exception as e:\n                        print_verbose(f\"An error occurred - {str(e)}\")\n                        raise e\n                elif key_manager == \"local\":\n                    secret = os.getenv(secret_name)\n                else:  # assume the default is infisicial client\n                    secret = client.get_secret(secret_name).secret_value\n            except Exception as e:  # check if it's in os.environ\n                verbose_logger.error(\n                    f\"Defaulting to os.environ value for key={secret_name}. An exception occurred - {str(e)}.\\n\\n{traceback.format_exc()}\"\n                )\n                secret = os.getenv(secret_name)\n            try:\n                if isinstance(secret, str):\n                    secret_value_as_bool = ast.literal_eval(secret)\n                    if isinstance(secret_value_as_bool, bool):\n                        return secret_value_as_bool\n                    else:\n                        return secret\n            except Exception:\n                return secret\n        else:\n            secret = os.environ.get(secret_name)\n            secret_value_as_bool = str_to_bool(secret) if secret is not None else None\n            if secret_value_as_bool is not None and isinstance(\n                secret_value_as_bool, bool\n            ):\n                return secret_value_as_bool\n            else:\n                return secret\n    except Exception as e:\n        if default_value is not None:\n            return default_value\n        else:\n            raise e\n",
    "pattern_analysis": {
      "api_sequence": [
        "str.startswith",
        "str.replace",
        "str.startswith",
        "str.replace",
        "str.split",
        "oidc_cache.get_cache",
        "HTTPHandler",
        "httpx.Timeout",
        "HTTPHandler.get",
        "response.status_code",
        "oidc_cache.set_cache",
        "os.getenv",
        "os.getenv",
        "os.getenv",
        "os.getenv",
        "os.getenv",
        "oidc_cache.get_cache",
        "HTTPHandler",
        "httpx.Timeout",
        "HTTPHandler.get",
        "response.status_code",
        "response.json",
        "oidc_cache.set_cache",
        "os.getenv",
        "open",
        "io.TextIOWrapper.read",
        "open",
        "io.TextIOWrapper.read",
        "os.getenv",
        "os.getenv",
        "open",
        "io.TextIOWrapper.read",
        "_should_read_secret_from_secret_manager",
        "litellm.secret_manager_client.get_secret",
        "os.getenv",
        "_is_base64",
        "base64.b64decode",
        "litellm.secret_manager_client.decrypt",
        "bytes.decode",
        "os.getenv",
        "base64.b64decode",
        "litellm.secret_manager_client.decrypt",
        "bytes.decode",
        "AWSSecretsManagerV2.sync_read_secret",
        "litellm.secret_manager_client.get_secret_from_google_secret_manager",
        "litellm.secret_manager_client.sync_read_secret",
        "os.getenv",
        "litellm.secret_manager_client.get_secret",
        "verbose_logger.error",
        "os.getenv",
        "ast.literal_eval",
        "os.environ.get",
        "str_to_bool"
      ],
      "api_sequence_with_args": [
        "secret_name.startswith(\"os.environ/\")",
        "secret_name.replace(\"os.environ/\", \"\")",
        "secret_name.startswith(\"oidc/\")",
        "secret_name.replace(\"oidc/\", \"\")",
        "secret_name_split.split(\"/\", 1)",
        "oidc_cache.get_cache(key=secret_name)",
        "HTTPHandler(timeout=httpx.Timeout(timeout=600.0, connect=5.0))",
        "httpx.Timeout(timeout=600.0, connect=5.0)",
        "oidc_client.get(\"http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/identity\", params={\"audience\": oidc_aud}, headers={\"Metadata-Flavor\": \"Google\"})",
        "response.status_code",
        "oidc_cache.set_cache(key=secret_name, value=oidc_token, ttl=3600 - 60)",
        "os.getenv(\"CIRCLE_OIDC_TOKEN\")",
        "os.getenv(\"CIRCLE_OIDC_TOKEN_V2\")",
        "os.getenv(\"ACTIONS_ID_TOKEN_REQUEST_URL\")",
        "os.getenv(\"ACTIONS_ID_TOKEN_REQUEST_TOKEN\")",
        "oidc_cache.get_cache(key=secret_name)",
        "HTTPHandler(timeout=httpx.Timeout(timeout=600.0, connect=5.0))",
        "httpx.Timeout(timeout=600.0, connect=5.0)",
        "oidc_client.get(actions_id_token_request_url, params={\"audience\": oidc_aud}, headers={\"Authorization\": f\"Bearer {actions_id_token_request_token}\", \"Accept\": \"application/json; api-version=2.0\"})",
        "response.status_code",
        "response.json()",
        "oidc_cache.set_cache(key=secret_name, value=oidc_token, ttl=300 - 5)",
        "os.getenv(\"AZURE_FEDERATED_TOKEN_FILE\")",
        "open(azure_federated_token_file, \"r\")",
        "f.read()",
        "open(oidc_aud, \"r\")",
        "f.read()",
        "os.getenv(oidc_aud)",
        "os.getenv(oidc_aud)",
        "open(token_file_path, \"r\")",
        "f.read()",
        "_should_read_secret_from_secret_manager()",
        "client.get_secret(secret_name)",
        "os.getenv(secret_name)",
        "_is_base64(encrypted_secret)",
        "base64.b64decode(encrypted_secret)",
        "client.decrypt(request={\"name\": litellm._google_kms_resource_name, \"ciphertext\": ciphertext})",
        "response.plaintext.decode(\"utf-8\")",
        "os.getenv(secret_name, None)",
        "base64.b64decode(encrypted_value)",
        "client.decrypt(**params)",
        "plaintext.decode(\"utf-8\")",
        "client.sync_read_secret(secret_name=secret_name, primary_secret_name=key_management_settings.primary_secret_name)",
        "client.get_secret_from_google_secret_manager(secret_name)",
        "client.sync_read_secret(secret_name=secret_name)",
        "os.getenv(secret_name)",
        "client.get_secret(secret_name).secret_value",
        "verbose_logger.error(f\"Defaulting to os.environ value for key={secret_name}. An exception occurred - {str(e)}.\\n\\n{traceback.format_exc()}\")",
        "os.getenv(secret_name)",
        "ast.literal_eval(secret)",
        "os.environ.get(secret_name)",
        "str_to_bool(secret)"
      ],
      "mapped_sequence": [
        {
          "api_name": "str.startswith",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "str.replace",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "str.startswith",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "str.replace",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "str.split",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "oidc_cache.get_cache",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "HTTPHandler",
          "id": "create_http_session",
          "description": "Creates HTTP session for making asynchronous requests",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "httpx.Timeout",
          "id": "create_http_session",
          "description": "Creates HTTP session for making asynchronous requests",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "HTTPHandler.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "response.status_code",
          "id": "get_http_status",
          "description": "Retrieves HTTP response status code",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "oidc_cache.set_cache",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "oidc_cache.get_cache",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "HTTPHandler",
          "id": "create_http_session",
          "description": "Creates HTTP session for making asynchronous requests",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "httpx.Timeout",
          "id": "create_http_session",
          "description": "Creates HTTP session for making asynchronous requests",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "HTTPHandler.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "response.status_code",
          "id": "get_http_status",
          "description": "Retrieves HTTP response status code",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "response.json",
          "id": "deserialize_json_response",
          "description": "Deserializes JSON response body to Python object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "oidc_cache.set_cache",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "io.TextIOWrapper.read",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "io.TextIOWrapper.read",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "io.TextIOWrapper.read",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "_should_read_secret_from_secret_manager",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "litellm.secret_manager_client.get_secret",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "_is_base64",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        },
        {
          "api_name": "base64.b64decode",
          "id": "decode_base64_to_bytes",
          "description": "Decodes base64-encoded string to bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "litellm.secret_manager_client.decrypt",
          "id": "decrypt_aes_data",
          "description": "Decrypts data using initialized AES cipher",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "bytes.decode",
          "id": "decode_bytes_codec",
          "description": "Decodes bytes using specified codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "base64.b64decode",
          "id": "decode_base64_to_bytes",
          "description": "Decodes base64-encoded string to bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "litellm.secret_manager_client.decrypt",
          "id": "decrypt_aes_data",
          "description": "Decrypts data using initialized AES cipher",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "bytes.decode",
          "id": "decode_bytes_codec",
          "description": "Decodes bytes using specified codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "AWSSecretsManagerV2.sync_read_secret",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "litellm.secret_manager_client.get_secret_from_google_secret_manager",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "litellm.secret_manager_client.sync_read_secret",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "litellm.secret_manager_client.get_secret",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "verbose_logger.error",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "ast.literal_eval",
          "id": "eval_python_expr",
          "description": "Evaluates string as Python expression",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "os.environ.get",
          "id": "get_env_vars",
          "description": "Retrieves environment variables mapping",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "str_to_bool",
          "id": "check_instance_type",
          "description": "Checks if object is instance of specified type",
          "first_id": "utility_functions",
          "second_id": "logging_exception_handling",
          "third_id": "exception_checking"
        }
      ],
      "contextual_code": "def get_secret(secret_name: str, default_value: Optional[Union[str, bool]] = None):\n    key_management_system = litellm._key_management_system\n    key_management_settings = litellm._key_management_settings\n    secret = None\n\n    if secret_name.startswith(\"os.environ/\"):\n        secret_name = secret_name.replace(\"os.environ/\", \"\")\n\n    if secret_name.startswith(\"oidc/\"):\n        secret_name_split = secret_name.replace(\"oidc/\", \"\")\n        oidc_provider, oidc_aud = secret_name_split.split(\"/\", 1)\n        if oidc_provider == \"google\":\n            oidc_token = oidc_cache.get_cache(key=secret_name)\n            if oidc_token is not None:\n                return oidc_token\n            oidc_client = HTTPHandler(timeout=httpx.Timeout(timeout=600.0, connect=5.0))\n            response = oidc_client.get(\n                \"http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/identity\",\n                params={\"audience\": oidc_aud},\n                headers={\"Metadata-Flavor\": \"Google\"},\n            )\n            if response.status_code == 200:\n                oidc_token = response.text\n                oidc_cache.set_cache(key=secret_name, value=oidc_token, ttl=3600 - 60)\n                return oidc_token\n            else:\n                raise ValueError(\"Google OIDC provider failed\")\n        elif oidc_provider == \"circleci\":\n            env_secret = os.getenv(\"CIRCLE_OIDC_TOKEN\")\n            if env_secret is None:\n                raise ValueError(\"CIRCLE_OIDC_TOKEN not found in environment\")\n            return env_secret\n        elif oidc_provider == \"circleci_v2\":\n            env_secret = os.getenv(\"CIRCLE_OIDC_TOKEN_V2\")\n            if env_secret is None:\n                raise ValueError(\"CIRCLE_OIDC_TOKEN_V2 not found in environment\")\n            return env_secret\n        elif oidc_provider == \"github\":\n            actions_id_token_request_url = os.getenv(\"ACTIONS_ID_TOKEN_REQUEST_URL\")\n            actions_id_token_request_token = os.getenv(\"ACTIONS_ID_TOKEN_REQUEST_TOKEN\")\n            if (\n                actions_id_token_request_url is None\n                or actions_id_token_request_token is None\n            ):\n                raise ValueError(\n                    \"ACTIONS_ID_TOKEN_REQUEST_URL or ACTIONS_ID_TOKEN_REQUEST_TOKEN not found in environment\"\n                )\n            oidc_token = oidc_cache.get_cache(key=secret_name)\n            if oidc_token is not None:\n                return oidc_token\n            oidc_client = HTTPHandler(timeout=httpx.Timeout(timeout=600.0, connect=5.0))\n            response = oidc_client.get(\n                actions_id_token_request_url,\n                params={\"audience\": oidc_aud},\n                headers={\n                    \"Authorization\": f\"Bearer {actions_id_token_request_token}\",\n                    \"Accept\": \"application/json; api-version=2.0\",\n                },\n            )\n            if response.status_code == 200:\n                oidc_token = response.json().get(\"value\", None)\n                oidc_cache.set_cache(key=secret_name, value=oidc_token, ttl=300 - 5)\n                return oidc_token\n            else:\n                raise ValueError(\"Github OIDC provider failed\")\n        elif oidc_provider == \"azure\":\n            azure_federated_token_file = os.getenv(\"AZURE_FEDERATED_TOKEN_FILE\")\n            if azure_federated_token_file is None:\n                raise ValueError(\"AZURE_FEDERATED_TOKEN_FILE not found in environment\")\n            with open(azure_federated_token_file, \"r\") as f:\n                oidc_token = f.read()\n                return oidc_token\n        elif oidc_provider == \"file\":\n            with open(oidc_aud, \"r\") as f:\n                oidc_token = f.read()\n                return oidc_token\n        elif oidc_provider == \"env\":\n            oidc_token = os.getenv(oidc_aud)\n            if oidc_token is None:\n                raise ValueError(f\"Environment variable {oidc_aud} not found\")\n            return oidc_token\n        elif oidc_provider == \"env_path\":\n            token_file_path = os.getenv(oidc_aud)\n            if token_file_path is None:\n                raise ValueError(f\"Environment variable {oidc_aud} not found\")\n            with open(token_file_path, \"r\") as f:\n                oidc_token = f.read()\n                return oidc_token\n        else:\n            raise ValueError(\"Unsupported OIDC provider\")\n\n    try:\n        if (\n            _should_read_secret_from_secret_manager()\n            and litellm.secret_manager_client is not None\n        ):\n            try:\n                client = litellm.secret_manager_client\n                key_manager = \"local\"\n                if key_management_system is not None:\n                    key_manager = key_management_system.value\n                if key_management_settings is not None:\n                    if (\n                        key_management_settings.hosted_keys is not None\n                        and secret_name not in key_management_settings.hosted_keys\n                    ):\n                        key_manager = \"local\"\n                if (\n                    key_manager == KeyManagementSystem.AZURE_KEY_VAULT.value\n                    or type(client).__module__ + \".\" + type(client).__name__\n                    == \"azure.keyvault.secrets._client.SecretClient\"\n                ):\n                    secret = client.get_secret(secret_name).value\n                elif (\n                    key_manager == KeyManagementSystem.GOOGLE_KMS.value\n                    or client.__class__.__name__ == \"KeyManagementServiceClient\"\n                ):\n                    encrypted_secret: Any = os.getenv(secret_name)\n                    if encrypted_secret is None:\n                        raise ValueError(\n                            \"Google KMS requires the encrypted secret to be in the environment!\"\n                        )\n                    b64_flag = _is_base64(encrypted_secret)\n                    if b64_flag is True:\n                        encrypted_secret = base64.b64decode(encrypted_secret)\n                        ciphertext = encrypted_secret\n                    else:\n                        raise ValueError(\n                            \"Google KMS requires the encrypted secret to be encoded in base64\"\n                        )\n                    response = client.decrypt(\n                        request={\n                            \"name\": litellm._google_kms_resource_name,\n                            \"ciphertext\": ciphertext,\n                        }\n                    )\n                    secret = response.plaintext.decode(\"utf-8\")\n                elif key_manager == KeyManagementSystem.AWS_KMS.value:\n                    encrypted_value = os.getenv(secret_name, None)\n                    if encrypted_value is None:\n                        raise Exception(\n                            \"AWS KMS - Encrypted Value of Key={} is None\".format(\n                                secret_name\n                            )\n                        )\n                    ciphertext_blob = base64.b64decode(encrypted_value)\n                    params = {\"CiphertextBlob\": ciphertext_blob}\n                    response = client.decrypt(**params)\n                    plaintext = response[\"Plaintext\"]\n                    secret = plaintext.decode(\"utf-8\")\n                    if isinstance(secret, str):\n                        secret = secret.strip()\n                elif key_manager == KeyManagementSystem.AWS_SECRET_MANAGER.value:\n                    from litellm.secret_managers.aws_secret_manager_v2 import (\n                        AWSSecretsManagerV2,\n                    )\n                    if isinstance(client, AWSSecretsManagerV2):\n                        secret = client.sync_read_secret(\n                            secret_name=secret_name,\n                            primary_secret_name=key_management_settings.primary_secret_name,\n                        )\n                        print_verbose(f\"get_secret_value_response: {secret}\")\n                elif key_manager == KeyManagementSystem.GOOGLE_SECRET_MANAGER.value:\n                    try:\n                        secret = client.get_secret_from_google_secret_manager(\n                            secret_name\n                        )\n                        print_verbose(f\"secret from google secret manager:  {secret}\")\n                        if secret is None:\n                            raise ValueError(\n                                f\"No secret found in Google Secret Manager for {secret_name}\"\n                            )\n                    except Exception as e:\n                        print_verbose(f\"An error occurred - {str(e)}\")\n                        raise e\n                elif key_manager == KeyManagementSystem.HASHICORP_VAULT.value:\n                    try:\n                        secret = client.sync_read_secret(secret_name=secret_name)\n                        if secret is None:\n                            raise ValueError(\n                                f\"No secret found in Hashicorp Secret Manager for {secret_name}\"\n                            )\n                    except Exception as e:\n                        print_verbose(f\"An error occurred - {str(e)}\")\n                        raise e\n                elif key_manager == \"local\":\n                    secret = os.getenv(secret_name)\n                else:\n                    secret = client.get_secret(secret_name).secret_value\n            except Exception as e:\n                verbose_logger.error(\n                    f\"Defaulting to os.environ value for key={secret_name}. An exception occurred - {str(e)}.\\n\\n{traceback.format_exc()}\"\n                )\n                secret = os.getenv(secret_name)\n            try:\n                if isinstance(secret, str):\n                    secret_value_as_bool = ast.literal_eval(secret)\n                    if isinstance(secret_value_as_bool, bool):\n                        return secret_value_as_bool\n                    else:\n                        return secret\n            except Exception:\n                return secret\n        else:\n            secret = os.environ.get(secret_name)\n            secret_value_as_bool = str_to_bool(secret) if secret is not None else None\n            if secret_value_as_bool is not None and isinstance(\n                secret_value_as_bool, bool\n            ):\n                return secret_value_as_bool\n            else:\n                return secret\n    except Exception as e:\n        if default_value is not None:\n            return default_value\n        else:\n            raise e"
    }
  }
]