[
  {
    "metadata": {
      "package_name": "google_cloud_translate-3.20.2",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:40"
    }
  },
  {
    "pyfile": "rest.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_translate-3.20.2/google_cloud_translate-3.20.2/google/cloud/translate_v3/services/translation_service/transports/rest.py",
    "line_number": "9366",
    "type_description": "B822:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "9365\t            request, metadata = self._interceptor.pre_wait_operation(request, metadata)\n9366\t            transcoded_request = _BaseTranslationServiceRestTransport._BaseWaitOperation._get_transcoded_request(\n9367\t                http_options, request\n9368\t            )",
    "code_snippet": "class _WaitOperation(\n    _BaseTranslationServiceRestTransport._BaseWaitOperation,\n    TranslationServiceRestStub,\n):\n    def __hash__(self):\n        return hash(\"TranslationServiceRestTransport.WaitOperation\")\n\n    @staticmethod\n    def _get_response(\n        host,\n        metadata,\n        query_params,\n        session,\n        timeout,\n        transcoded_request,\n        body=None,\n    ):\n        uri = transcoded_request[\"uri\"]\n        method = transcoded_request[\"method\"]\n        headers = dict(metadata)\n        headers[\"Content-Type\"] = \"application/json\"\n        response = getattr(session, method)(\n            \"{host}{uri}\".format(host=host, uri=uri),\n            timeout=timeout,\n            headers=headers,\n            params=rest_helpers.flatten_query_params(query_params, strict=True),\n            data=body,\n        )\n        return response\n\n    def __call__(\n        self,\n        request: operations_pb2.WaitOperationRequest,\n        *,\n        retry: OptionalRetry = gapic_v1.method.DEFAULT,\n        timeout: Optional[float] = None,\n        metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n    ) -> operations_pb2.Operation:\n        r\"\"\"Call the wait operation method over HTTP.\n\n        Args:\n            request (operations_pb2.WaitOperationRequest):\n                The request object for WaitOperation method.\n            retry (google.api_core.retry.Retry): Designation of what errors, if any,\n                should be retried.\n            timeout (float): The timeout for this request.\n            metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n                sent along with the request as metadata. Normally, each value must be of type `str`,\n                but for metadata keys ending with the suffix `-bin`, the corresponding values must\n                be of type `bytes`.\n\n        Returns:\n            operations_pb2.Operation: Response from WaitOperation method.\n        \"\"\"\n\n        http_options = (\n            _BaseTranslationServiceRestTransport._BaseWaitOperation._get_http_options()\n        )\n\n        request, metadata = self._interceptor.pre_wait_operation(request, metadata)\n        transcoded_request = _BaseTranslationServiceRestTransport._BaseWaitOperation._get_transcoded_request(\n            http_options, request\n        )\n\n        body = _BaseTranslationServiceRestTransport._BaseWaitOperation._get_request_body_json(\n            transcoded_request\n        )\n\n        # Jsonify the query params\n        query_params = _BaseTranslationServiceRestTransport._BaseWaitOperation._get_query_params_json(\n            transcoded_request\n        )\n\n        if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n            logging.DEBUG\n        ):  # pragma: NO COVER\n            request_url = \"{host}{uri}\".format(\n                host=self._host, uri=transcoded_request[\"uri\"]\n            )\n            method = transcoded_request[\"method\"]\n            try:\n                request_payload = json_format.MessageToJson(request)\n            except:\n                request_payload = None\n            http_request = {\n                \"payload\": request_payload,\n                \"requestMethod\": method,\n                \"requestUrl\": request_url,\n                \"headers\": dict(metadata),\n            }\n            _LOGGER.debug(\n                f\"Sending request for google.cloud.translation_v3.TranslationServiceClient.WaitOperation\",\n                extra={\n                    \"serviceName\": \"google.cloud.translation.v3.TranslationService\",\n                    \"rpcName\": \"WaitOperation\",\n                    \"httpRequest\": http_request,\n                    \"metadata\": http_request[\"headers\"],\n                },\n            )\n\n        # Send the request\n        response = TranslationServiceRestTransport._WaitOperation._get_response(\n            self._host,\n            metadata,\n            query_params,\n            self._session,\n            timeout,\n            transcoded_request,\n            body,\n        )\n\n        # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n        # subclass.\n        if response.status_code >= 400:\n            raise core_exceptions.from_http_response(response)\n\n        content = response.content.decode(\"utf-8\")\n        resp = operations_pb2.Operation()\n        resp = json_format.Parse(content, resp)\n        resp = self._interceptor.post_wait_operation(resp)\n        if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n            logging.DEBUG\n        ):  # pragma: NO COVER\n            try:\n                response_payload = json_format.MessageToJson(resp)\n            except:\n                response_payload = None\n            http_response = {\n                \"payload\": response_payload,\n                \"headers\": dict(response.headers),\n                \"status\": response.status_code,\n            }\n            _LOGGER.debug(\n                \"Received response for google.cloud.translation_v3.TranslationServiceAsyncClient.WaitOperation\",\n                extra={\n                    \"serviceName\": \"google.cloud.translation.v3.TranslationService\",\n                    \"rpcName\": \"WaitOperation\",\n                    \"httpResponse\": http_response,\n                    \"metadata\": http_response[\"headers\"],\n                },\n            )\n        return resp",
    "pattern_analysis": {
      "api_sequence": [
        "getattr",
        "rest_helpers.flatten_query_params",
        "TranslationServiceRestTransport._WaitOperation._get_response",
        "response.status_code",
        "core_exceptions.from_http_response",
        "response.content.decode",
        "json_format.Parse",
        "self._interceptor.post_wait_operation"
      ],
      "api_sequence_with_args": [
        "getattr(session, method)",
        "rest_helpers.flatten_query_params(query_params, strict=True)",
        "TranslationServiceRestTransport._WaitOperation._get_response(self._host, metadata, query_params, self._session, timeout, transcoded_request, body)",
        "response.status_code",
        "core_exceptions.from_http_response(response)",
        "response.content.decode(\"utf-8\")",
        "json_format.Parse(content, resp)",
        "self._interceptor.post_wait_operation(resp)"
      ],
      "mapped_sequence": [
        {
          "api_name": "getattr",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "rest_helpers.flatten_query_params",
          "id": "encode_url_query",
          "description": "Encodes mapping object to URL query string",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "TranslationServiceRestTransport._WaitOperation._get_response",
          "id": "send_http_custom",
          "description": "Sends HTTP request with specified method and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "response.status_code",
          "id": "get_http_status",
          "description": "Retrieves HTTP response status code",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "core_exceptions.from_http_response",
          "id": "raise_http_error",
          "description": "Raises HTTPError if response status code indicates error",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "response.content.decode",
          "id": "decode_bytes_codec",
          "description": "Decodes bytes using specified codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "json_format.Parse",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "self._interceptor.post_wait_operation",
          "id": "run_async_function",
          "description": "Runs asynchronous function until completion",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        }
      ],
      "contextual_code": "def _get_response(host, metadata, query_params, session, timeout, transcoded_request, body=None):\n    uri = transcoded_request[\"uri\"]\n    method = transcoded_request[\"method\"]\n    headers = dict(metadata)\n    headers[\"Content-Type\"] = \"application/json\"\n    response = getattr(session, method)(\n        \"{host}{uri}\".format(host=host, uri=uri),\n        timeout=timeout,\n        headers=headers,\n        params=rest_helpers.flatten_query_params(query_params, strict=True),\n        data=body,\n    )\n    return response\n\n# ...\n\nresponse = TranslationServiceRestTransport._WaitOperation._get_response(\n    self._host,\n    metadata,\n    query_params,\n    self._session,\n    timeout,\n    transcoded_request,\n    body,\n)\n\nif response.status_code >= 400:\n    raise core_exceptions.from_http_response(response)\n\ncontent = response.content.decode(\"utf-8\")\nresp = operations_pb2.Operation()\nresp = json_format.Parse(content, resp)\nresp = self._interceptor.post_wait_operation(resp)"
    }
  }
]