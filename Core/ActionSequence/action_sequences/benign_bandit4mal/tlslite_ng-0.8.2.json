[
  {
    "metadata": {
      "package_name": "tlslite_ng-0.8.2",
      "total_matches": 3,
      "processing_date": "2025-05-18 01:49:40"
    }
  },
  {
    "pyfile": "tlstest.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/tlslite_ng-0.8.2/tlslite_ng-0.8.2/tests/tlstest.py",
    "line_number": "949",
    "type_description": "B807:close",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "948\t    testConnClient(connection)\n949\t    connection.close()\n950",
    "code_snippet": "def clientTestCmd(argv):\n\n    address = argv[0]\n    dir = argv[1]\n\n    #Split address into hostname/port tuple\n    address = address.split(\":\")\n    address = ( address[0], int(address[1]) )\n\n    #open synchronisation FIFO\n    synchro = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    synchro.settimeout(60)\n    synchro.connect((address[0], address[1]-1))\n\n    def connect():\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(15)\n        sock.connect(address)\n        c = TLSConnection(sock)\n        return c\n\n    test_no = 0\n\n    badFault = False\n\n    print(\"Test {0} - anonymous handshake\".format(test_no))\n    synchro.recv(1)\n    connection = connect()\n    settings = HandshakeSettings()\n    settings.maxVersion = (3, 3)\n    connection.handshakeClientAnonymous(settings=settings)\n    testConnClient(connection)\n    connection.close()\n\n    # ... (function continues for hundreds of lines, with repeated usage of connection.close())\n",
    "pattern_analysis": {
      "api_sequence": [
        "socket.socket",
        "socket.socket.settimeout",
        "socket.socket.connect",
        "socket.socket",
        "socket.socket.settimeout",
        "socket.socket.connect",
        "TLSConnection",
        "TLSConnection.handshakeClientAnonymous",
        "testConnClient",
        "TLSConnection.close"
      ],
      "api_sequence_with_args": [
        "socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
        "socket.socket.settimeout(60)",
        "socket.socket.connect((address[0], address[1]-1))",
        "socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
        "socket.socket.settimeout(15)",
        "socket.socket.connect(address)",
        "TLSConnection(sock)",
        "TLSConnection.handshakeClientAnonymous(settings=settings)",
        "testConnClient(connection)",
        "TLSConnection.close()"
      ],
      "mapped_sequence": [
        {
          "api_name": "socket.socket",
          "id": "create_socket",
          "description": "Creates new socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_creation"
        },
        {
          "api_name": "socket.socket.settimeout",
          "id": "set_socket_timeout",
          "description": "Sets timeout for socket operations",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_configuration"
        },
        {
          "api_name": "socket.socket.connect",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "socket.socket",
          "id": "create_socket",
          "description": "Creates new socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_creation"
        },
        {
          "api_name": "socket.socket.settimeout",
          "id": "set_socket_timeout",
          "description": "Sets timeout for socket operations",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_configuration"
        },
        {
          "api_name": "socket.socket.connect",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "TLSConnection",
          "id": "wrap_socket_ssl",
          "description": "Wraps socket for SSL/TLS communication",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "TLSConnection.handshakeClientAnonymous",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "testConnClient",
          "id": "run_async_function",
          "description": "Runs asynchronous function until completion",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "TLSConnection.close",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        }
      ],
      "contextual_code": "def clientTestCmd(argv):\n    address = argv[0]\n    dir = argv[1]\n    address = address.split(\":\")\n    address = (address[0], int(address[1]))\n    synchro = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    synchro.settimeout(60)\n    synchro.connect((address[0], address[1]-1))\n    def connect():\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(15)\n        sock.connect(address)\n        c = TLSConnection(sock)\n        return c\n    print(\"Test {0} - anonymous handshake\".format(0))\n    synchro.recv(1)\n    connection = connect()\n    settings = HandshakeSettings()\n    settings.maxVersion = (3, 3)\n    connection.handshakeClientAnonymous(settings=settings)\n    testConnClient(connection)\n    connection.close()"
    }
  },
  {
    "pyfile": "tlstest.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/tlslite_ng-0.8.2/tlslite_ng-0.8.2/tests/tlstest.py",
    "line_number": "3483",
    "type_description": "B831:send",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "3482\t          \"with expired ticket\".format(test_no))\n3483\t    synchro.send(b'R')\n3484\t    connection = connect()",
    "code_snippet": "def serverTestCmd(argv):\n\n    address = argv[0]\n    dir = argv[1]\n\n    #Split address into hostname/port tuple\n    address = address.split(\":\")\n    address = ( address[0], int(address[1]) )\n\n    #Create synchronisation FIFO\n    synchroSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    synchroSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    synchroSocket.bind((address[0], address[1]-1))\n    synchroSocket.listen(2)\n\n    #Connect to server\n    lsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    lsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    lsock.bind(address)\n    lsock.listen(5)\n\n    # following is blocking until the other side doesn't open\n    synchro = synchroSocket.accept()[0]\n\n    def connect():\n        s = lsock.accept()[0]\n        s.settimeout(15)\n        return TLSConnection(s)\n\n    with open(os.path.join(dir, \"serverX509Cert.pem\")) as f:\n        x509Cert = X509().parse(f.read())\n    x509Chain = X509CertChain([x509Cert])\n    with open(os.path.join(dir, \"serverX509Key.pem\")) as f:\n        x509Key = parsePEMKey(f.read(), private=True)\n\n    ...\n\n    test_no += 1\n\n    print(\"Test {0} - session_ticket resumption in TLSv1.2 \"\n          \"with expired ticket\".format(test_no))\n    synchro.send(b'R')\n    connection = connect()\n    settings = HandshakeSettings()\n    settings.ticketLifetime = 1\n    settings.maxVersion = (3, 3)\n    settings.ticketKeys = [getRandomBytes(32)]\n    connection.handshakeServer(certChain=x509Chain, privateKey=x509Key,\n                               settings=settings)\n    testConnServer(connection)\n    connection.close()\n\n    time.sleep(2)\n\n    # resume\n    synchro.send(b'R')\n    connection = connect()\n    connection.handshakeServer(certChain=x509Chain, privateKey=x509Key,\n                               settings=settings)\n    testConnServer(connection)\n    connection.close()\n\n    ...\n",
    "pattern_analysis": {
      "api_sequence": [
        "socket.socket",
        "socket.socket.setsockopt",
        "socket.socket.bind",
        "socket.socket.listen",
        "socket.socket",
        "socket.socket.setsockopt",
        "socket.socket.bind",
        "socket.socket.listen",
        "socket.socket.accept",
        "open",
        "os.path.join",
        "X509.parse",
        "open",
        "os.path.join",
        "parsePEMKey",
        "synchro.send",
        "connect",
        "TLSConnection.handshakeServer",
        "testConnServer",
        "TLSConnection.close",
        "time.sleep",
        "synchro.send",
        "connect",
        "TLSConnection.handshakeServer",
        "testConnServer",
        "TLSConnection.close"
      ],
      "api_sequence_with_args": [
        "socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
        "socket.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)",
        "socket.socket.bind((address[0], address[1]-1))",
        "socket.socket.listen(2)",
        "socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
        "socket.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)",
        "socket.socket.bind(address)",
        "socket.socket.listen(5)",
        "socket.socket.accept()",
        "open(os.path.join(dir, \"serverX509Cert.pem\"))",
        "os.path.join(dir, \"serverX509Cert.pem\")",
        "X509().parse(f.read())",
        "open(os.path.join(dir, \"serverX509Key.pem\"))",
        "os.path.join(dir, \"serverX509Key.pem\")",
        "parsePEMKey(f.read(), private=True)",
        "synchro.send(b'R')",
        "connect()",
        "TLSConnection.handshakeServer(certChain=x509Chain, privateKey=x509Key, settings=settings)",
        "testConnServer(connection)",
        "TLSConnection.close()",
        "time.sleep(2)",
        "synchro.send(b'R')",
        "connect()",
        "TLSConnection.handshakeServer(certChain=x509Chain, privateKey=x509Key, settings=settings)",
        "testConnServer(connection)",
        "TLSConnection.close()"
      ],
      "mapped_sequence": [
        {
          "api_name": "socket.socket",
          "id": "create_socket",
          "description": "Creates new socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_creation"
        },
        {
          "api_name": "socket.socket.setsockopt",
          "id": "create_socket",
          "description": "Creates new socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_creation"
        },
        {
          "api_name": "socket.socket.bind",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "socket.socket.listen",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "socket.socket",
          "id": "create_socket",
          "description": "Creates new socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_creation"
        },
        {
          "api_name": "socket.socket.setsockopt",
          "id": "create_socket",
          "description": "Creates new socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_creation"
        },
        {
          "api_name": "socket.socket.bind",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "socket.socket.listen",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "socket.socket.accept",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "X509.parse",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "parsePEMKey",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "synchro.send",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "connect",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "TLSConnection.handshakeServer",
          "id": "wrap_socket_ssl",
          "description": "Wraps socket for SSL/TLS communication",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "testConnServer",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "TLSConnection.close",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "time.sleep",
          "id": "suspend_execution",
          "description": "Suspends execution for specified seconds",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "synchro.send",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "connect",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "TLSConnection.handshakeServer",
          "id": "wrap_socket_ssl",
          "description": "Wraps socket for SSL/TLS communication",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "testConnServer",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "TLSConnection.close",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        }
      ],
      "contextual_code": "def serverTestCmd(argv):\n    address = argv[0]\n    dir = argv[1]\n    address = address.split(\":\")\n    address = ( address[0], int(address[1]) )\n    synchroSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    synchroSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    synchroSocket.bind((address[0], address[1]-1))\n    synchroSocket.listen(2)\n    lsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    lsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    lsock.bind(address)\n    lsock.listen(5)\n    synchro = synchroSocket.accept()[0]\n    def connect():\n        s = lsock.accept()[0]\n        s.settimeout(15)\n        return TLSConnection(s)\n    with open(os.path.join(dir, \"serverX509Cert.pem\")) as f:\n        x509Cert = X509().parse(f.read())\n    x509Chain = X509CertChain([x509Cert])\n    with open(os.path.join(dir, \"serverX509Key.pem\")) as f:\n        x509Key = parsePEMKey(f.read(), private=True)\n    synchro.send(b'R')\n    connection = connect()\n    settings = HandshakeSettings()\n    settings.ticketLifetime = 1\n    settings.maxVersion = (3, 3)\n    settings.ticketKeys = [getRandomBytes(32)]\n    connection.handshakeServer(certChain=x509Chain, privateKey=x509Key, settings=settings)\n    testConnServer(connection)\n    connection.close()\n    time.sleep(2)\n    synchro.send(b'R')\n    connection = connect()\n    connection.handshakeServer(certChain=x509Chain, privateKey=x509Key, settings=settings)\n    testConnServer(connection)\n    connection.close()"
    }
  },
  {
    "pyfile": "tlstest.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/tlslite_ng-0.8.2/tlslite_ng-0.8.2/tests/tlstest.py",
    "line_number": "3118",
    "type_description": "B831:send",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "3117\t    print(\"Test {0} - good mutual X.509, SSLv3\".format(test_no))\n3118\t    synchro.send(b'R')\n3119\t    connection = connect()",
    "code_snippet": "def serverTestCmd(argv):\n\n    address = argv[0]\n    dir = argv[1]\n\n    #Split address into hostname/port tuple\n    address = address.split(\":\")\n    address = ( address[0], int(address[1]) )\n\n    #Create synchronisation FIFO\n    synchroSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    synchroSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    synchroSocket.bind((address[0], address[1]-1))\n    synchroSocket.listen(2)\n\n    #Connect to server\n    lsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    lsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    lsock.bind(address)\n    lsock.listen(5)\n\n    # following is blocking until the other side doesn't open\n    synchro = synchroSocket.accept()[0]\n\n    def connect():\n        s = lsock.accept()[0]\n        s.settimeout(15)\n        return TLSConnection(s)\n\n    ...\n\n    test_no = 0\n\n    print(\"Test {0} - Anonymous server handshake\".format(test_no))\n    synchro.send(b'R')\n    connection = connect()\n    connection.handshakeServer(anon=True)\n    testConnServer(connection)\n    connection.close()\n\n    test_no += 1\n\n    print(\"Test {0} - good X.509 (plus SNI)\".format(test_no))\n    synchro.send(b'R')\n    connection = connect()\n    connection.handshakeServer(certChain=x509Chain, privateKey=x509Key)\n    assert connection.session.serverName == address[0]\n    assert connection.extendedMasterSecret\n    assert connection.session.appProto is None\n    assert connection.server_cert_compression_algo == \"zlib\"\n    assert connection.client_cert_compression_algo is None\n    testConnServer(connection)\n    connection.close()\n\n    ...\n\n    print(\"Test {0} - good X.509, SSLv3\".format(test_no))\n    synchro.send(b'R')\n    connection = connect()\n    settings = HandshakeSettings()\n    settings.minVersion = (3,0)\n    settings.maxVersion = (3,0)\n    connection.handshakeServer(certChain=x509Chain, privateKey=x509Key, settings=settings)\n    assert(not connection.extendedMasterSecret)\n    testConnServer(connection)\n    connection.close()\n\n    test_no += 1\n",
    "pattern_analysis": {
      "api_sequence": [
        "socket.socket",
        "socket.socket.setsockopt",
        "socket.socket.bind",
        "socket.socket.listen",
        "socket.socket",
        "socket.socket.setsockopt",
        "socket.socket.bind",
        "socket.socket.listen",
        "socket.socket.accept",
        "socket.socket.accept",
        "socket.socket.settimeout",
        "TLSConnection",
        "socket.socket.send",
        "TLSConnection.handshakeServer",
        "testConnServer",
        "TLSConnection.close",
        "socket.socket.send",
        "socket.socket.accept",
        "socket.socket.settimeout",
        "TLSConnection",
        "TLSConnection.handshakeServer",
        "testConnServer",
        "TLSConnection.close",
        "socket.socket.send",
        "socket.socket.accept",
        "socket.socket.settimeout",
        "TLSConnection",
        "HandshakeSettings",
        "TLSConnection.handshakeServer",
        "testConnServer",
        "TLSConnection.close"
      ],
      "api_sequence_with_args": [
        "socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
        "socket.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)",
        "socket.socket.bind((address[0], address[1]-1))",
        "socket.socket.listen(2)",
        "socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
        "socket.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)",
        "socket.socket.bind(address)",
        "socket.socket.listen(5)",
        "socket.socket.accept()",
        "socket.socket.accept()",
        "socket.socket.settimeout(15)",
        "TLSConnection(s)",
        "socket.socket.send(b'R')",
        "TLSConnection.handshakeServer(anon=True)",
        "testConnServer(connection)",
        "TLSConnection.close()",
        "socket.socket.send(b'R')",
        "socket.socket.accept()",
        "socket.socket.settimeout(15)",
        "TLSConnection(s)",
        "TLSConnection.handshakeServer(certChain=x509Chain, privateKey=x509Key)",
        "testConnServer(connection)",
        "TLSConnection.close()",
        "socket.socket.send(b'R')",
        "socket.socket.accept()",
        "socket.socket.settimeout(15)",
        "TLSConnection(s)",
        "HandshakeSettings()",
        "TLSConnection.handshakeServer(certChain=x509Chain, privateKey=x509Key, settings=settings)",
        "testConnServer(connection)",
        "TLSConnection.close()"
      ],
      "mapped_sequence": [
        {
          "api_name": "socket.socket",
          "id": "create_socket",
          "description": "Creates new socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_creation"
        },
        {
          "api_name": "socket.socket.setsockopt",
          "id": "create_socket",
          "description": "Creates new socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_creation"
        },
        {
          "api_name": "socket.socket.bind",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "socket.socket.listen",
          "id": "create_socket",
          "description": "Creates new socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_creation"
        },
        {
          "api_name": "socket.socket",
          "id": "create_socket",
          "description": "Creates new socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_creation"
        },
        {
          "api_name": "socket.socket.setsockopt",
          "id": "create_socket",
          "description": "Creates new socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_creation"
        },
        {
          "api_name": "socket.socket.bind",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "socket.socket.listen",
          "id": "create_socket",
          "description": "Creates new socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_creation"
        },
        {
          "api_name": "socket.socket.accept",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "socket.socket.accept",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "socket.socket.settimeout",
          "id": "set_socket_timeout",
          "description": "Sets timeout for socket operations",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_configuration"
        },
        {
          "api_name": "TLSConnection",
          "id": "wrap_socket_ssl",
          "description": "Wraps socket for SSL/TLS communication",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "socket.socket.send",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "TLSConnection.handshakeServer",
          "id": "wrap_socket_ssl",
          "description": "Wraps socket for SSL/TLS communication",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "testConnServer",
          "id": "wrap_socket_ssl",
          "description": "Wraps socket for SSL/TLS communication",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "TLSConnection.close",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "socket.socket.send",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "socket.socket.accept",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "socket.socket.settimeout",
          "id": "set_socket_timeout",
          "description": "Sets timeout for socket operations",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_configuration"
        },
        {
          "api_name": "TLSConnection",
          "id": "wrap_socket_ssl",
          "description": "Wraps socket for SSL/TLS communication",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "TLSConnection.handshakeServer",
          "id": "wrap_socket_ssl",
          "description": "Wraps socket for SSL/TLS communication",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "testConnServer",
          "id": "wrap_socket_ssl",
          "description": "Wraps socket for SSL/TLS communication",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "TLSConnection.close",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "socket.socket.send",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "socket.socket.accept",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "socket.socket.settimeout",
          "id": "set_socket_timeout",
          "description": "Sets timeout for socket operations",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_configuration"
        },
        {
          "api_name": "TLSConnection",
          "id": "wrap_socket_ssl",
          "description": "Wraps socket for SSL/TLS communication",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "HandshakeSettings",
          "id": "wrap_socket_ssl",
          "description": "Wraps socket for SSL/TLS communication",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "TLSConnection.handshakeServer",
          "id": "wrap_socket_ssl",
          "description": "Wraps socket for SSL/TLS communication",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "testConnServer",
          "id": "wrap_socket_ssl",
          "description": "Wraps socket for SSL/TLS communication",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "TLSConnection.close",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        }
      ],
      "contextual_code": "def serverTestCmd(argv):\n    address = argv[0]\n    dir = argv[1]\n    address = address.split(\":\")\n    address = ( address[0], int(address[1]) )\n    synchroSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    synchroSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    synchroSocket.bind((address[0], address[1]-1))\n    synchroSocket.listen(2)\n    lsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    lsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    lsock.bind(address)\n    lsock.listen(5)\n    synchro = synchroSocket.accept()[0]\n    def connect():\n        s = lsock.accept()[0]\n        s.settimeout(15)\n        return TLSConnection(s)\n    test_no = 0\n    print(\"Test {0} - Anonymous server handshake\".format(test_no))\n    synchro.send(b'R')\n    connection = connect()\n    connection.handshakeServer(anon=True)\n    testConnServer(connection)\n    connection.close()\n    test_no += 1\n    print(\"Test {0} - good X.509 (plus SNI)\".format(test_no))\n    synchro.send(b'R')\n    connection = connect()\n    connection.handshakeServer(certChain=x509Chain, privateKey=x509Key)\n    assert connection.session.serverName == address[0]\n    assert connection.extendedMasterSecret\n    assert connection.session.appProto is None\n    assert connection.server_cert_compression_algo == \"zlib\"\n    assert connection.client_cert_compression_algo is None\n    testConnServer(connection)\n    connection.close()\n    print(\"Test {0} - good X.509, SSLv3\".format(test_no))\n    synchro.send(b'R')\n    connection = connect()\n    settings = HandshakeSettings()\n    settings.minVersion = (3,0)\n    settings.maxVersion = (3,0)\n    connection.handshakeServer(certChain=x509Chain, privateKey=x509Key, settings=settings)\n    assert(not connection.extendedMasterSecret)\n    testConnServer(connection)\n    connection.close()"
    }
  }
]