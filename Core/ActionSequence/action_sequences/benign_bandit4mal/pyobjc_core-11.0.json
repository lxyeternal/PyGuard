[
  {
    "metadata": {
      "package_name": "pyobjc_core-11.0",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "test_archiving_secure_interop.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyobjc_core-11.0/pyobjc_core-11.0/PyObjCTest/test_archiving_secure_interop.py",
    "line_number": "84",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "83\t            with tempfile.NamedTemporaryFile() as fp:\n84\t                fp.write(data.bytes())\n85\t                fp.flush()",
    "code_snippet": "def test_interop_date(self):\n    testval = datetime.date.today()\n\n    v = NSArray.arrayWithObject_(testval)\n    (\n        data,\n        error,\n    ) = NSKeyedArchiver.archivedDataWithRootObject_requiringSecureCoding_error_(\n        v, True, None\n    )\n\n    if data is None:\n        self.fail(f\"Cannot create archive: {error}\")\n\n    with tempfile.NamedTemporaryFile() as fp:\n        fp.write(data.bytes())\n        fp.flush()\n\n        converted = subprocess.check_output([self.progpath, fp.name])\n\n    converted = loads(converted)\n    value = converted[0]\n    self.assertIsInstance(value, datetime.datetime)\n    # XXX: Checking the value itself is problematic because\n    #      the datetime parser in plistlib is not timezone aware.\n    # self.assertEqual(value.year, testval.year)\n    # self.assertEqual(value.month, testval.month)\n    # self.assertEqual(value.day, testval.day)",
    "pattern_analysis": {
      "api_sequence": [
        "datetime.date.today",
        "NSArray.arrayWithObject_",
        "NSKeyedArchiver.archivedDataWithRootObject_requiringSecureCoding_error_",
        "tempfile.NamedTemporaryFile",
        "fp.write",
        "fp.flush",
        "subprocess.check_output",
        "loads"
      ],
      "api_sequence_with_args": [
        "datetime.date.today()",
        "NSArray.arrayWithObject_(testval)",
        "NSKeyedArchiver.archivedDataWithRootObject_requiringSecureCoding_error_(v, True, None)",
        "tempfile.NamedTemporaryFile()",
        "fp.write(data.bytes())",
        "fp.flush()",
        "subprocess.check_output([self.progpath, fp.name])",
        "loads(converted)"
      ],
      "mapped_sequence": [
        {
          "api_name": "datetime.date.today",
          "id": "parse_datetime",
          "description": "Parses string into datetime object using format",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "NSArray.arrayWithObject_",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "NSKeyedArchiver.archivedDataWithRootObject_requiringSecureCoding_error_",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "tempfile.NamedTemporaryFile",
          "id": "create_temp_file",
          "description": "Creates temporary file that is not deleted on close",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "fp.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "fp.flush",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "subprocess.check_output",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        }
      ],
      "contextual_code": "def test_interop_date(self):\n    testval = datetime.date.today()\n\n    v = NSArray.arrayWithObject_(testval)\n    (\n        data,\n        error,\n    ) = NSKeyedArchiver.archivedDataWithRootObject_requiringSecureCoding_error_(\n        v, True, None\n    )\n\n    if data is None:\n        self.fail(f\"Cannot create archive: {error}\")\n\n    with tempfile.NamedTemporaryFile() as fp:\n        fp.write(data.bytes())\n        fp.flush()\n\n        converted = subprocess.check_output([self.progpath, fp.name])\n\n    converted = loads(converted)\n    value = converted[0]\n    self.assertIsInstance(value, datetime.datetime)"
    }
  }
]