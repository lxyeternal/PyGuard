[
  {
    "metadata": {
      "package_name": "azure_keyvault_administration-4.6.0b1",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "_model_base.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/azure_keyvault_administration-4.6.0b1/azure_keyvault_administration-4.6.0b1/azure/keyvault/administration/_generated/_model_base.py",
    "line_number": "102",
    "type_description": "B802:b64encode",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "101\tdef _serialize_bytes(o, format: typing.Optional[str] = None) -> str:\n102\t    encoded = base64.b64encode(o).decode()\n103\t    if format == \"base64url\":",
    "code_snippet": "import base64\nimport typing\n\ndef _serialize_bytes(o, format: typing.Optional[str] = None) -> str:\n    encoded = base64.b64encode(o).decode()\n    if format == \"base64url\":\n        return encoded.strip(\"=\").replace(\"+\", \"-\").replace(\"/\", \"_\")\n    return encoded",
    "pattern_analysis": {
      "api_sequence": [
        "base64.b64encode",
        "str.decode"
      ],
      "api_sequence_with_args": [
        "base64.b64encode(o)",
        "str.decode()"
      ],
      "mapped_sequence": [
        {
          "api_name": "base64.b64encode",
          "id": "encode_bytes_to_base64",
          "description": "Encodes bytes to base64-encoded bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "str.decode",
          "id": "decode_bytes_default",
          "description": "Decodes bytes using default codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        }
      ],
      "contextual_code": "import base64\nimport typing\n\ndef _serialize_bytes(o, format: typing.Optional[str] = None) -> str:\n    encoded = base64.b64encode(o).decode()\n    if format == \"base64url\":\n        return encoded.strip(\"=\").replace(\"+\", \"-\").replace(\"/\", \"_\")\n    return encoded"
    }
  },
  {
    "pyfile": "_operations.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/azure_keyvault_administration-4.6.0b1/azure_keyvault_administration-4.6.0b1/azure/keyvault/administration/_generated/operations/_operations.py",
    "line_number": "2074",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "2073\t            )\n2074\t            raw_result.http_response.read()  # type: ignore\n2075\t        kwargs.pop(\"error_map\", None)",
    "code_snippet": "@distributed_trace\n    def begin_full_backup(\n        self, azure_storage_blob_container_uri: Union[_models.SASTokenParameter, JSON, IO[bytes]], **kwargs: Any\n    ) -> LROPoller[_models.FullBackupOperation]:\n        \"\"\"Creates a full backup using a user-provided SAS token to an Azure blob storage container.\n\n        :param azure_storage_blob_container_uri: Azure blob shared access signature token pointing to a\n         valid Azure blob container where full backup needs to be stored. This token needs to be valid\n         for at least next 24 hours from the time of making this call. Is one of the following types:\n         SASTokenParameter, JSON, IO[bytes] Required.\n        :type azure_storage_blob_container_uri: ~azure.keyvault.administration._generated.models.SASTokenParameter\n         or JSON or IO[bytes]\n        :return: An instance of LROPoller that returns FullBackupOperation. The FullBackupOperation is\n         compatible with MutableMapping\n        :rtype:\n         ~azure.core.polling.LROPoller[~azure.keyvault.administration._generated.models.FullBackupOperation]\n        :raises ~azure.core.exceptions.HttpResponseError:\n        \"\"\"\n        _headers = case_insensitive_dict(kwargs.pop(\"headers\", {}) or {})\n        _params = kwargs.pop(\"params\", {}) or {}\n\n        content_type: Optional[str] = kwargs.pop(\"content_type\", _headers.pop(\"Content-Type\", None))\n        cls: ClsType[_models.FullBackupOperation] = kwargs.pop(\"cls\", None)\n        polling: Union[bool, PollingMethod] = kwargs.pop(\"polling\", True)\n        lro_delay = kwargs.pop(\"polling_interval\", self._config.polling_interval)\n        cont_token: Optional[str] = kwargs.pop(\"continuation_token\", None)\n        if cont_token is None:\n            raw_result = self._full_backup_initial(\n                azure_storage_blob_container_uri=azure_storage_blob_container_uri,\n                content_type=content_type,\n                cls=lambda x, y, z: x,\n                headers=_headers,\n                params=_params,\n                **kwargs\n            )\n            raw_result.http_response.read()  # type: ignore\n        kwargs.pop(\"error_map\", None)\n\n        def get_long_running_output(pipeline_response):\n            response_headers = {}\n            response = pipeline_response.http_response\n            response_headers[\"Azure-AsyncOperation\"] = self._deserialize(\n                \"str\", response.headers.get(\"Azure-AsyncOperation\")\n            )\n            response_headers[\"Retry-After\"] = self._deserialize(\"int\", response.headers.get(\"Retry-After\"))\n\n            deserialized = _deserialize(_models.FullBackupOperation, response.json())\n            if cls:\n                return cls(pipeline_response, deserialized, response_headers)  # type: ignore\n            return deserialized\n\n        path_format_arguments = {\n            \"vaultBaseUrl\": self._serialize.url(\n                \"self._config.vault_base_url\", self._config.vault_base_url, \"str\", skip_quote=True\n            ),\n        }\n\n        if polling is True:\n            polling_method: PollingMethod = cast(\n                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)\n            )\n        elif polling is False:\n            polling_method = cast(PollingMethod, NoPolling())\n        else:\n            polling_method = polling\n        if cont_token:\n            return LROPoller[_models.FullBackupOperation].from_continuation_token(\n                polling_method=polling_method,\n                continuation_token=cont_token,\n                client=self._client,\n                deserialization_callback=get_long_running_output,\n            )\n        return LROPoller[_models.FullBackupOperation](\n            self._client, raw_result, get_long_running_output, polling_method  # type: ignore\n        )",
    "pattern_analysis": {
      "api_sequence": [
        "self._full_backup_initial",
        "raw_result.http_response.read",
        "self._deserialize",
        "_deserialize",
        "response.json",
        "self._serialize.url",
        "LROBasePolling",
        "LROPoller.from_continuation_token",
        "LROPoller"
      ],
      "api_sequence_with_args": [
        "self._full_backup_initial(azure_storage_blob_container_uri=azure_storage_blob_container_uri, content_type=content_type, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs)",
        "raw_result.http_response.read()",
        "self._deserialize('str', response.headers.get('Azure-AsyncOperation'))",
        "_deserialize(_models.FullBackupOperation, response.json())",
        "response.json()",
        "self._serialize.url('self._config.vault_base_url', self._config.vault_base_url, 'str', skip_quote=True)",
        "LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)",
        "LROPoller.from_continuation_token(polling_method=polling_method, continuation_token=cont_token, client=self._client, deserialization_callback=get_long_running_output)",
        "LROPoller(self._client, raw_result, get_long_running_output, polling_method)"
      ],
      "mapped_sequence": [
        {
          "api_name": "self._full_backup_initial",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "raw_result.http_response.read",
          "id": "read_response_bytes",
          "description": "Reads response body as bytes",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "self._deserialize",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "_deserialize",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "response.json",
          "id": "deserialize_json_response",
          "description": "Deserializes JSON response body to Python object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "self._serialize.url",
          "id": "encode_url_query",
          "description": "Encodes mapping object to URL query string",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "LROBasePolling",
          "id": "create_http_session",
          "description": "Creates HTTP session for making asynchronous requests",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "LROPoller.from_continuation_token",
          "id": "create_http_session",
          "description": "Creates HTTP session for making asynchronous requests",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "LROPoller",
          "id": "create_http_session",
          "description": "Creates HTTP session for making asynchronous requests",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        }
      ],
      "contextual_code": "def begin_full_backup(self, azure_storage_blob_container_uri, **kwargs):\n    _headers = case_insensitive_dict(kwargs.pop(\"headers\", {}) or {})\n    _params = kwargs.pop(\"params\", {}) or {}\n    content_type = kwargs.pop(\"content_type\", _headers.pop(\"Content-Type\", None))\n    cls = kwargs.pop(\"cls\", None)\n    polling = kwargs.pop(\"polling\", True)\n    lro_delay = kwargs.pop(\"polling_interval\", self._config.polling_interval)\n    cont_token = kwargs.pop(\"continuation_token\", None)\n    if cont_token is None:\n        raw_result = self._full_backup_initial(\n            azure_storage_blob_container_uri=azure_storage_blob_container_uri,\n            content_type=content_type,\n            cls=lambda x, y, z: x,\n            headers=_headers,\n            params=_params,\n            **kwargs\n        )\n        raw_result.http_response.read()\n    kwargs.pop(\"error_map\", None)\n    def get_long_running_output(pipeline_response):\n        response_headers = {}\n        response = pipeline_response.http_response\n        response_headers[\"Azure-AsyncOperation\"] = self._deserialize(\n            \"str\", response.headers.get(\"Azure-AsyncOperation\")\n        )\n        response_headers[\"Retry-After\"] = self._deserialize(\"int\", response.headers.get(\"Retry-After\"))\n        deserialized = _deserialize(_models.FullBackupOperation, response.json())\n        if cls:\n            return cls(pipeline_response, deserialized, response_headers)\n        return deserialized\n    path_format_arguments = {\n        \"vaultBaseUrl\": self._serialize.url(\n            \"self._config.vault_base_url\", self._config.vault_base_url, \"str\", skip_quote=True\n        ),\n    }\n    if polling is True:\n        polling_method = LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)\n    elif polling is False:\n        polling_method = NoPolling()\n    else:\n        polling_method = polling\n    if cont_token:\n        return LROPoller.from_continuation_token(\n            polling_method=polling_method,\n            continuation_token=cont_token,\n            client=self._client,\n            deserialization_callback=get_long_running_output,\n        )\n    return LROPoller(\n        self._client, raw_result, get_long_running_output, polling_method\n    )"
    }
  }
]