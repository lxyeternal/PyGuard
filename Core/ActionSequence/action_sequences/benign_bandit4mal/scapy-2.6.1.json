[
  {
    "metadata": {
      "package_name": "scapy-2.6.1",
      "total_matches": 3,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "automaton.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/scapy-2.6.1/scapy-2.6.1/scapy/automaton.py",
    "line_number": "226",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "225\t            return None\n226\t        os.read(self.__rd, 1)\n227\t        elt = self.__queue.popleft()",
    "code_snippet": "def recv(self, n=0, options=socket.MsgFlag(0)):\n    # type: (Optional[int], socket.MsgFlag) -> Optional[_T]\n    if self.closed:\n        raise EOFError\n    if options & socket.MSG_PEEK:\n        if self.__queue:\n            return self.__queue[0]\n        return None\n    os.read(self.__rd, 1)\n    elt = self.__queue.popleft()\n    if WINDOWS and not self.__queue:\n        self._winreset()\n    return elt",
    "pattern_analysis": {
      "api_sequence": [
        "os.read"
      ],
      "api_sequence_with_args": [
        "os.read(self.__rd, 1)"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.read",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        }
      ],
      "contextual_code": "def recv(self, n=0, options=socket.MsgFlag(0)):\n    if self.closed:\n        raise EOFError\n    if options & socket.MSG_PEEK:\n        if self.__queue:\n            return self.__queue[0]\n        return None\n    os.read(self.__rd, 1)\n    elt = self.__queue.popleft()\n    if WINDOWS and not self.__queue:\n        self._winreset()\n    return elt"
    }
  },
  {
    "pyfile": "utils.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/scapy-2.6.1/scapy-2.6.1/scapy/utils.py",
    "line_number": "2895",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "2894\t        self.f.write(struct.pack(\"<Q\", t))\n2895\t        self.f.write(struct.pack(\">BBHHHH\", 2, 0, rlen, 0, wirelen, 0))\n2896\t        self.f.write(bytes(pkt))",
    "code_snippet": "class ERFEthernetWriter(PcapWriter):\n    \"\"\"A stream ERF Ethernet writer with more control than wrerf()\"\"\"\n\n    def __init__(self,\n                 filename,  # type: Union[IO[bytes], str]\n                 gz=False,  # type: bool\n                 append=False,  # type: bool\n                 sync=False,  # type: bool\n                 ):\n        # type: (...) -> None\n        \"\"\"\n        :param filename: the name of the file to write packets to, or an open,\n            writable file-like object.\n        :param gz: compress the capture on the fly\n        :param append: append packets to the capture file instead of\n            truncating it\n        :param sync: do not bufferize writes to the capture file\n        \"\"\"\n        super(ERFEthernetWriter, self).__init__(filename,\n                                                gz=gz,\n                                                append=append,\n                                                sync=sync)\n\n    def write(self, pkt):  # type: ignore\n        # type: (_PacketIterable) -> None\n        \"\"\"\n        Writes a Packet, a SndRcvList object, or bytes to a ERF file.\n\n        :param pkt: Packet(s) to write (one record for each Packet)\n        :type pkt: iterable[scapy.packet.Packet], scapy.packet.Packet\n        \"\"\"\n        # Import here to avoid circular dependency\n        from scapy.supersocket import IterSocket\n        for p in IterSocket(pkt).iter:\n            self.write_packet(p)\n\n    def write_packet(self, pkt):  # type: ignore\n        # type: (Packet) -> None\n\n        if hasattr(pkt, \"time\"):\n            sec = int(pkt.time)\n            usec = int((int(round((pkt.time - sec) * 10**9)) << 32) / 10**9)\n            t = (sec << 32) + usec\n        else:\n            t = int(time.time()) << 32\n\n        # There are 16 bytes of headers + 2 bytes of padding before the packets\n        # payload.\n        rlen = len(pkt) + 18\n\n        if hasattr(pkt, \"wirelen\"):\n            wirelen = pkt.wirelen\n        if wirelen is None:\n            wirelen = rlen\n\n        self.f.write(struct.pack(\"<Q\", t))\n        self.f.write(struct.pack(\">BBHHHH\", 2, 0, rlen, 0, wirelen, 0))\n        self.f.write(bytes(pkt))\n        self.f.flush()\n\n    def close(self):\n        # type: () -> Optional[Any]\n        return self.f.close()",
    "pattern_analysis": {
      "api_sequence": [
        "time.time",
        "struct.pack",
        "struct.pack",
        "bytes",
        "io.IOBase.write",
        "io.IOBase.write",
        "io.IOBase.write",
        "io.IOBase.flush",
        "io.IOBase.close"
      ],
      "api_sequence_with_args": [
        "time.time()",
        "struct.pack('<Q', t)",
        "struct.pack('>BBHHHH', 2, 0, rlen, 0, wirelen, 0)",
        "bytes(pkt)",
        "self.f.write(struct.pack('<Q', t))",
        "self.f.write(struct.pack('>BBHHHH', 2, 0, rlen, 0, wirelen, 0))",
        "self.f.write(bytes(pkt))",
        "self.f.flush()",
        "self.f.close()"
      ],
      "mapped_sequence": [
        {
          "api_name": "time.time",
          "id": "get_current_time",
          "description": "Returns current time in seconds since epoch",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "struct.pack",
          "id": "pack_values",
          "description": "Packs values into bytes using specified format",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "struct.pack",
          "id": "pack_values",
          "description": "Packs values into bytes using specified format",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "bytes",
          "id": "create_bytes_encoded",
          "description": "Creates bytes object from encoded string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "io.IOBase.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "io.IOBase.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "io.IOBase.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "io.IOBase.flush",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "io.IOBase.close",
          "id": "close_file",
          "description": "Closes the opened file",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_closing"
        }
      ],
      "contextual_code": "def write_packet(self, pkt):\n    if hasattr(pkt, \"time\"):\n        sec = int(pkt.time)\n        usec = int((int(round((pkt.time - sec) * 10**9)) << 32) / 10**9)\n        t = (sec << 32) + usec\n    else:\n        t = int(time.time()) << 32\n    rlen = len(pkt) + 18\n    if hasattr(pkt, \"wirelen\"):\n        wirelen = pkt.wirelen\n    if wirelen is None:\n        wirelen = rlen\n    self.f.write(struct.pack(\"<Q\", t))\n    self.f.write(struct.pack(\">BBHHHH\", 2, 0, rlen, 0, wirelen, 0))\n    self.f.write(bytes(pkt))\n    self.f.flush()\n\ndef close(self):\n    return self.f.close()"
    }
  },
  {
    "pyfile": "scapypipes.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/scapy-2.6.1/scapy-2.6.1/scapy/scapypipes.py",
    "line_number": "451",
    "type_description": "B807:close",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "450\t            self._high_send(frm)\n451\t            self.fd.close()\n452\t            self.fd = fd",
    "code_snippet": "def deliver(self):\n    # type: () -> None\n    if self.connected:\n        try:\n            msg = self.fd.recv(65536)\n        except socket.error:\n            self.stop()\n            raise\n        if msg:\n            self._send(msg)\n    else:\n        fd, frm = self.fd.accept()\n        self._high_send(frm)\n        self.fd.close()\n        self.fd = fd\n        self.connected = True\n        self._trigger(frm)\n        while True:\n            try:\n                self.fd.send(self.q.get(block=False))\n            except Empty:\n                break",
    "pattern_analysis": {
      "api_sequence": [
        "socket.socket.recv",
        "self.stop",
        "self.fd.accept",
        "self._high_send",
        "socket.socket.close",
        "self._trigger",
        "queue.Queue.get",
        "socket.socket.send"
      ],
      "api_sequence_with_args": [
        "socket.socket.recv(65536)",
        "self.stop()",
        "socket.socket.accept()",
        "self._high_send(frm)",
        "socket.socket.close()",
        "self._trigger(frm)",
        "queue.Queue.get(block=False)",
        "socket.socket.send(self.q.get(block=False))"
      ],
      "mapped_sequence": [
        {
          "api_name": "socket.socket.recv",
          "id": "receive_socket_data",
          "description": "Receives data from socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "self.stop",
          "id": "terminate_process",
          "description": "Terminates the process",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "socket.socket.accept",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "self._high_send",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "socket.socket.close",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "self._trigger",
          "id": "create_thread",
          "description": "Creates new thread to execute target function",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_creation"
        },
        {
          "api_name": "queue.Queue.get",
          "id": "read_user_input",
          "description": "Reads user input from standard input",
          "first_id": "persistence_stealth",
          "second_id": "user_interaction",
          "third_id": "interface_control"
        },
        {
          "api_name": "socket.socket.send",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        }
      ],
      "contextual_code": "def deliver(self):\n    if self.connected:\n        try:\n            msg = self.fd.recv(65536)\n        except socket.error:\n            self.stop()\n            raise\n        if msg:\n            self._send(msg)\n    else:\n        fd, frm = self.fd.accept()\n        self._high_send(frm)\n        self.fd.close()\n        self.fd = fd\n        self.connected = True\n        self._trigger(frm)\n        while True:\n            try:\n                self.fd.send(self.q.get(block=False))\n            except Empty:\n                break"
    }
  }
]