[
  {
    "metadata": {
      "package_name": "latch-2.58.2",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:40"
    }
  },
  {
    "pyfile": "ctx.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/latch-2.58.2/latch-2.58.2/src/latch_cli/centromere/ctx.py",
    "line_number": "316",
    "type_description": "B817:system",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "315\n316\t                            system = platform.system()\n317\t                            if system in {",
    "code_snippet": "if metadata_root is None:\n    metadata_root = pkg_root / \"latch_metadata\"\nself.metadata_root = metadata_root\n\nmeta_file = load_snakemake_metadata(pkg_root, metadata_root)\nif meta_file is not None:\n    click.echo(\n        f\"Using metadata file {click.style(meta_file, italic=True)}\"\n    )\nelse:\n    new_meta = pkg_root / \"latch_metadata\" / \"__init__.py\"\n    click.echo(\"Trying to extract metadata from the Snakefile\")\n    try:\n        snakemake_workflow_extractor(pkg_root, metadata_root, snakefile)\n    except (ImportError, FileNotFoundError):\n        traceback.print_exc()\n        click.secho(\n            \"\\n\\n\\n\"\n            + \"The above error occured when reading \"\n            + \"the Snakefile to extract workflow metadata.\",\n            bold=True,\n            fg=\"red\",\n        )\n        click.secho(\n            \"\\nIt is possible to avoid including the Snakefile\"\n            \" prior to registration by providing a\"\n            \" `latch_metadata.py` file in the workflow root.\\nThis\"\n            \" way it is not necessary to install dependencies or\"\n            \" ensure that Snakemake inputs locally.\",\n            fg=\"red\",\n        )\n        click.secho(\"\\nExample \", fg=\"red\", nl=False)\n\n        snakemake_metadata_example = get_snakemake_metadata_example(\n            pkg_root.name\n        )\n        click.secho(f\"`{new_meta}`\", bold=True, fg=\"red\", nl=False)\n        click.secho(\n            f\" file:\\n```\\n{snakemake_metadata_example}```\", fg=\"red\"\n        )\n        if click.confirm(\n            click.style(\n                \"Generate example metadata file now?\",\n                bold=True,\n                fg=\"red\",\n            ),\n            default=True,\n        ):\n            new_meta.write_text(snakemake_metadata_example)\n\n            import platform\n\n            system = platform.system()\n            if system in {\n                \"Windows\",\n                \"Linux\",\n                \"Darwin\",\n            } and click.confirm(\n                click.style(\n                    \"Open the generated file?\", bold=True, fg=\"red\"\n                ),\n                default=True,\n            ):\n                import subprocess\n\n                if system == \"Linux\":\n                    res = subprocess.run([\n                        \"xdg-open\",\n                        new_meta,\n                    ]).returncode\n                elif system == \"Darwin\":\n                    res = subprocess.run([\"open\", new_meta]).returncode\n                elif system == \"Windows\":\n                    import os\n\n                    res = os.system(str(new_meta.resolve()))\n                else:\n                    res = None\n\n                if res is not None and res != 0:\n                    click.secho(\"Failed to open file\", fg=\"red\")\n        sys.exit(1)",
    "pattern_analysis": {
      "api_sequence": [
        "load_snakemake_metadata",
        "click.echo",
        "click.style",
        "click.echo",
        "snakemake_workflow_extractor",
        "traceback.print_exc",
        "click.secho",
        "click.secho",
        "click.secho",
        "get_snakemake_metadata_example",
        "click.secho",
        "click.secho",
        "click.confirm",
        "new_meta.write_text",
        "platform.system",
        "click.style",
        "click.confirm",
        "subprocess.run",
        "subprocess.run",
        "os.system",
        "new_meta.resolve",
        "click.secho",
        "sys.exit"
      ],
      "api_sequence_with_args": [
        "load_snakemake_metadata(pkg_root, metadata_root)",
        "click.echo(f\"Using metadata file {click.style(meta_file, italic=True)}\")",
        "click.style(meta_file, italic=True)",
        "click.echo(\"Trying to extract metadata from the Snakefile\")",
        "snakemake_workflow_extractor(pkg_root, metadata_root, snakefile)",
        "traceback.print_exc()",
        "click.secho(\"\\n\\n\\n\" + \"The above error occured when reading \" + \"the Snakefile to extract workflow metadata.\", bold=True, fg=\"red\")",
        "click.secho(\"\\nIt is possible to avoid including the Snakefile\" \" prior to registration by providing a\" \" `latch_metadata.py` file in the workflow root.\\nThis\" \" way it is not necessary to install dependencies or\" \" ensure that Snakemake inputs locally.\", fg=\"red\")",
        "click.secho(\"\\nExample \", fg=\"red\", nl=False)",
        "get_snakemake_metadata_example(pkg_root.name)",
        "click.secho(f\"`{new_meta}`\", bold=True, fg=\"red\", nl=False)",
        "click.secho(f\" file:\\n```\\n{snakemake_metadata_example}```\", fg=\"red\")",
        "click.confirm(click.style(\"Generate example metadata file now?\", bold=True, fg=\"red\"), default=True)",
        "new_meta.write_text(snakemake_metadata_example)",
        "platform.system()",
        "click.style(\"Open the generated file?\", bold=True, fg=\"red\")",
        "click.confirm(click.style(\"Open the generated file?\", bold=True, fg=\"red\"), default=True)",
        "subprocess.run([\"xdg-open\", new_meta])",
        "subprocess.run([\"open\", new_meta])",
        "os.system(str(new_meta.resolve()))",
        "new_meta.resolve()",
        "click.secho(\"Failed to open file\", fg=\"red\")",
        "sys.exit(1)"
      ],
      "mapped_sequence": [
        {
          "api_name": "load_snakemake_metadata",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "click.echo",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "click.style",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "click.echo",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "snakemake_workflow_extractor",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "traceback.print_exc",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "click.secho",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "click.secho",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "click.secho",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "get_snakemake_metadata_example",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "click.secho",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "click.secho",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "click.confirm",
          "id": "read_user_input",
          "description": "Reads user input from standard input",
          "first_id": "persistence_stealth",
          "second_id": "user_interaction",
          "third_id": "interface_control"
        },
        {
          "api_name": "new_meta.write_text",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "platform.system",
          "id": "get_os_id",
          "description": "Retrieves operating system identifier",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "click.style",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "click.confirm",
          "id": "read_user_input",
          "description": "Reads user input from standard input",
          "first_id": "persistence_stealth",
          "second_id": "user_interaction",
          "third_id": "interface_control"
        },
        {
          "api_name": "subprocess.run",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "subprocess.run",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "os.system",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "new_meta.resolve",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "click.secho",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "sys.exit",
          "id": "exit_program",
          "description": "Exits program with specified status code",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        }
      ],
      "contextual_code": "meta_file = load_snakemake_metadata(pkg_root, metadata_root)\nif meta_file is not None:\n    click.echo(f\"Using metadata file {click.style(meta_file, italic=True)}\")\nelse:\n    new_meta = pkg_root / \"latch_metadata\" / \"__init__.py\"\n    click.echo(\"Trying to extract metadata from the Snakefile\")\n    try:\n        snakemake_workflow_extractor(pkg_root, metadata_root, snakefile)\n    except (ImportError, FileNotFoundError):\n        traceback.print_exc()\n        click.secho(\"\\n\\n\\n\" + \"The above error occured when reading \" + \"the Snakefile to extract workflow metadata.\", bold=True, fg=\"red\")\n        click.secho(\"\\nIt is possible to avoid including the Snakefile\" \" prior to registration by providing a\" \" `latch_metadata.py` file in the workflow root.\\nThis\" \" way it is not necessary to install dependencies or\" \" ensure that Snakemake inputs locally.\", fg=\"red\")\n        click.secho(\"\\nExample \", fg=\"red\", nl=False)\n        snakemake_metadata_example = get_snakemake_metadata_example(pkg_root.name)\n        click.secho(f\"`{new_meta}`\", bold=True, fg=\"red\", nl=False)\n        click.secho(f\" file:\\n```\\n{snakemake_metadata_example}```\", fg=\"red\")\n        if click.confirm(click.style(\"Generate example metadata file now?\", bold=True, fg=\"red\"), default=True):\n            new_meta.write_text(snakemake_metadata_example)\n            import platform\n            system = platform.system()\n            if system in {\"Windows\", \"Linux\", \"Darwin\"} and click.confirm(click.style(\"Open the generated file?\", bold=True, fg=\"red\"), default=True):\n                import subprocess\n                if system == \"Linux\":\n                    res = subprocess.run([\"xdg-open\", new_meta]).returncode\n                elif system == \"Darwin\":\n                    res = subprocess.run([\"open\", new_meta]).returncode\n                elif system == \"Windows\":\n                    import os\n                    res = os.system(str(new_meta.resolve()))\n                else:\n                    res = None\n                if res is not None and res != 0:\n                    click.secho(\"Failed to open file\", fg=\"red\")\n        sys.exit(1)"
    }
  }
]