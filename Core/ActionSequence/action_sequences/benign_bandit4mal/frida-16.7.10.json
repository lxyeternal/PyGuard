[
  {
    "metadata": {
      "package_name": "frida-16.7.10",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "deps.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/frida-16.7.10/frida-16.7.10/releng/deps.py",
    "line_number": "243",
    "type_description": "B818:urlopen",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "242\t    try:\n243\t        with urllib.request.urlopen(request) as r:\n244\t            return",
    "code_snippet": "def roll(bundle: Bundle,\n         build_machine: MachineSpec,\n         host_machine: MachineSpec,\n         activate: bool,\n         post: Optional[Path]):\n    params = load_dependency_parameters()\n    version = params.deps_version\n\n    if activate and bundle == Bundle.SDK:\n        configure_bootstrap_version(version)\n\n    (public_url, filename) = compute_bundle_parameters(bundle, host_machine, version)\n\n    # First do a quick check to avoid hitting S3 in most cases.\n    request = urllib.request.Request(public_url)\n    request.get_method = lambda: \"HEAD\"\n    try:\n        with urllib.request.urlopen(request) as r:\n            return\n    except urllib.request.HTTPError as e:\n        if e.code != 404:\n            raise CommandError(\"network error\") from e\n\n    s3_url = \"s3://build.frida.re/deps/{version}/{filename}\".format(version=version, filename=filename)\n\n    # We will most likely need to build, but let's check S3 to be certain.\n    r = subprocess.run([\"aws\", \"s3\", \"ls\", s3_url], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=\"utf-8\")\n    if r.returncode == 0:\n        return\n    if r.returncode != 1:\n        raise CommandError(f\"unable to access S3: {r.stdout.strip()}\")\n\n    artifact = build(bundle, build_machine, host_machine)\n\n    if post is not None:\n        post_script = RELENG_DIR / post\n        if not post_script.exists():\n            raise CommandError(\"post-processing script not found\")\n\n        subprocess.run([\n                           sys.executable, post_script,\n                           \"--bundle=\" + bundle.name.lower(),\n                           \"--host=\" + host_machine.identifier,\n                           \"--artifact=\" + str(artifact),\n                           \"--version=\" + version,\n                       ],\n                       check=True)\n\n    subprocess.run([\"aws\", \"s3\", \"cp\", artifact, s3_url], check=True)\n\n    # Use the shell for Windows compatibility, where npm generates a .bat script.\n    subprocess.run(\"cfcli purge \" + public_url, shell=True, check=True)\n\n    if activate and bundle == Bundle.TOOLCHAIN:\n        configure_bootstrap_version(version)",
    "pattern_analysis": {
      "api_sequence": [
        "load_dependency_parameters",
        "urllib.request.Request",
        "urllib.request.Request.get_method",
        "urllib.request.urlopen",
        "subprocess.run",
        "subprocess.run",
        "build",
        "Path.exists",
        "subprocess.run",
        "subprocess.run",
        "subprocess.run"
      ],
      "api_sequence_with_args": [
        "load_dependency_parameters()",
        "urllib.request.Request(public_url)",
        "urllib.request.Request.get_method = lambda: \"HEAD\"",
        "urllib.request.urlopen(request)",
        "subprocess.run([\"aws\", \"s3\", \"ls\", s3_url], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=\"utf-8\")",
        "subprocess.run([sys.executable, post_script, \"--bundle=\" + bundle.name.lower(), \"--host=\" + host_machine.identifier, \"--artifact=\" + str(artifact), \"--version=\" + version], check=True)",
        "build(bundle, build_machine, host_machine)",
        "Path.exists()",
        "subprocess.run([\"aws\", \"s3\", \"cp\", artifact, s3_url], check=True)",
        "subprocess.run(\"cfcli purge \" + public_url, shell=True, check=True)",
        "subprocess.run"
      ],
      "mapped_sequence": [
        {
          "api_name": "load_dependency_parameters",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "urllib.request.Request",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "urllib.request.Request.get_method",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "urllib.request.urlopen",
          "id": "open_url_get",
          "description": "Opens URL with GET parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "subprocess.run",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "subprocess.run",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "build",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "Path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "subprocess.run",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "subprocess.run",
          "id": "spawn_process_shell",
          "description": "Spawns new process to execute command with shell access",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_reception"
        },
        {
          "api_name": "subprocess.run",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        }
      ],
      "contextual_code": "def roll(bundle: Bundle,\n         build_machine: MachineSpec,\n         host_machine: MachineSpec,\n         activate: bool,\n         post: Optional[Path]):\n    params = load_dependency_parameters()\n    version = params.deps_version\n\n    if activate and bundle == Bundle.SDK:\n        configure_bootstrap_version(version)\n\n    (public_url, filename) = compute_bundle_parameters(bundle, host_machine, version)\n\n    request = urllib.request.Request(public_url)\n    request.get_method = lambda: \"HEAD\"\n    try:\n        with urllib.request.urlopen(request) as r:\n            return\n    except urllib.request.HTTPError as e:\n        if e.code != 404:\n            raise CommandError(\"network error\") from e\n\n    s3_url = \"s3://build.frida.re/deps/{version}/{filename}\".format(version=version, filename=filename)\n\n    r = subprocess.run([\"aws\", \"s3\", \"ls\", s3_url], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, encoding=\"utf-8\")\n    if r.returncode == 0:\n        return\n    if r.returncode != 1:\n        raise CommandError(f\"unable to access S3: {r.stdout.strip()}\")\n\n    artifact = build(bundle, build_machine, host_machine)\n\n    if post is not None:\n        post_script = RELENG_DIR / post\n        if not post_script.exists():\n            raise CommandError(\"post-processing script not found\")\n\n        subprocess.run([\n                           sys.executable, post_script,\n                           \"--bundle=\" + bundle.name.lower(),\n                           \"--host=\" + host_machine.identifier,\n                           \"--artifact=\" + str(artifact),\n                           \"--version=\" + version,\n                       ],\n                       check=True)\n\n    subprocess.run([\"aws\", \"s3\", \"cp\", artifact, s3_url], check=True)\n\n    subprocess.run(\"cfcli purge \" + public_url, shell=True, check=True)\n\n    if activate and bundle == Bundle.TOOLCHAIN:\n        configure_bootstrap_version(version)"
    }
  },
  {
    "pyfile": "pycompile.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/frida-16.7.10/frida-16.7.10/releng/meson/mesonbuild/scripts/pycompile.py",
    "line_number": "35",
    "type_description": "B843:compile_file",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "34\t                        fullpath = os.path.join(root, dirf)\n35\t                        compile_file(fullpath, ddir, force=True, quiet=quiet)\n36\t        else:",
    "code_snippet": "import json, os, subprocess, sys\nfrom compileall import compile_file\n\nquiet = int(os.environ.get('MESON_INSTALL_QUIET', 0))\n\ndef compileall(files):\n    for f in files:\n        # f is prefixed by {py_xxxxlib}, both variants are 12 chars\n        # the key is the middle 10 chars of the prefix\n        key = f[1:11].upper()\n        f = f[12:]\n\n        ddir = None\n        fullpath = absf = os.environ['MESON_INSTALL_DESTDIR_'+key] + f\n        f = os.environ['MESON_INSTALL_'+key] + f\n\n        if absf != f:\n            ddir = os.path.dirname(f)\n\n        if os.path.isdir(absf):\n            for root, _, files in os.walk(absf):\n                if ddir is not None:\n                    ddir = root.replace(absf, f, 1)\n                for dirf in files:\n                    if dirf.endswith('.py'):\n                        fullpath = os.path.join(root, dirf)\n                        compile_file(fullpath, ddir, force=True, quiet=quiet)\n        else:\n            compile_file(fullpath, ddir, force=True, quiet=quiet)",
    "pattern_analysis": {
      "api_sequence": [
        "os.environ.get",
        "os.environ.__getitem__",
        "os.path.dirname",
        "os.path.isdir",
        "os.walk",
        "os.path.join",
        "compileall.compile_file",
        "compileall.compile_file"
      ],
      "api_sequence_with_args": [
        "os.environ.get('MESON_INSTALL_QUIET', 0)",
        "os.environ.__getitem__('MESON_INSTALL_DESTDIR_'+key)",
        "os.path.dirname(f)",
        "os.path.isdir(absf)",
        "os.walk(absf)",
        "os.path.join(root, dirf)",
        "compileall.compile_file(fullpath, ddir, force=True, quiet=quiet)",
        "compileall.compile_file(fullpath, ddir, force=True, quiet=quiet)"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.environ.get",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.environ.__getitem__",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.path.dirname",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.isdir",
          "id": "check_directory_exists",
          "description": "Checks if specified path exists and is a directory",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.walk",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "compileall.compile_file",
          "id": "compile_code_object",
          "description": "Compiles source code string into executable code object",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "compileall.compile_file",
          "id": "compile_code_object",
          "description": "Compiles source code string into executable code object",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        }
      ],
      "contextual_code": "import os\nfrom compileall import compile_file\n\nquiet = int(os.environ.get('MESON_INSTALL_QUIET', 0))\n\ndef compileall(files):\n    for f in files:\n        key = f[1:11].upper()\n        f = f[12:]\n\n        ddir = None\n        fullpath = absf = os.environ['MESON_INSTALL_DESTDIR_'+key] + f\n        f = os.environ['MESON_INSTALL_'+key] + f\n\n        if absf != f:\n            ddir = os.path.dirname(f)\n\n        if os.path.isdir(absf):\n            for root, _, files in os.walk(absf):\n                if ddir is not None:\n                    ddir = root.replace(absf, f, 1)\n                for dirf in files:\n                    if dirf.endswith('.py'):\n                        fullpath = os.path.join(root, dirf)\n                        compile_file(fullpath, ddir, force=True, quiet=quiet)\n        else:\n            compile_file(fullpath, ddir, force=True, quiet=quiet)"
    }
  }
]