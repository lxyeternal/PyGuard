[
  {
    "metadata": {
      "package_name": "diskcache-5.6.3",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:40"
    }
  },
  {
    "pyfile": "test_fanout.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/diskcache-5.6.3/diskcache-5.6.3/tests/test_fanout.py",
    "line_number": "173",
    "type_description": "B836:rmtree",
    "severity": "High",
    "confidence": "Medium",
    "code_snippet": "@pytest.fixture\ndef cache():\n    with dc.FanoutCache() as cache:\n        yield cache\n    shutil.rmtree(cache.directory, ignore_errors=True)",
    "pattern_analysis": {
      "api_sequence": [
        "dc.FanoutCache",
        "shutil.rmtree"
      ],
      "api_sequence_with_args": [
        "dc.FanoutCache()",
        "shutil.rmtree(cache.directory, ignore_errors=True)"
      ],
      "mapped_sequence": [
        {
          "api_name": "dc.FanoutCache",
          "id": "init_cache_class",
          "description": "Instantiates FanoutCache class (no direct match in taxonomy; closest is class instantiation, but not present. This is a cache object, not a sensitive API per taxonomy. If required, can be omitted.)",
          "first_id": "",
          "second_id": "",
          "third_id": ""
        },
        {
          "api_name": "shutil.rmtree",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        }
      ],
      "contextual_code": "def cache():\n    with dc.FanoutCache() as cache:\n        yield cache\n    shutil.rmtree(cache.directory, ignore_errors=True)"
    }
  },
  {
    "pyfile": "test_djangocache.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/diskcache-5.6.3/diskcache-5.6.3/tests/test_djangocache.py",
    "line_number": "361",
    "type_description": "B816:decompress",
    "severity": "High",
    "confidence": "Medium",
    "code_snippet": "def test_binary_string(self):\n    # Binary strings should be cacheable\n    from zlib import compress, decompress\n\n    value = 'value_to_be_compressed'\n    compressed_value = compress(value.encode())\n\n    # Test set\n    cache.set('binary1', compressed_value)\n    compressed_result = cache.get('binary1')\n    self.assertEqual(compressed_value, compressed_result)\n    self.assertEqual(value, decompress(compressed_result).decode())\n\n    # Test add\n    self.assertIs(cache.add('binary1-add', compressed_value), True)\n    compressed_result = cache.get('binary1-add')\n    self.assertEqual(compressed_value, compressed_result)\n    self.assertEqual(value, decompress(compressed_result).decode())\n\n    # Test set_many\n    cache.set_many({'binary1-set_many': compressed_value})\n    compressed_result = cache.get('binary1-set_many')\n    self.assertEqual(compressed_value, compressed_result)\n    self.assertEqual(value, decompress(compressed_result).decode())",
    "pattern_analysis": {
      "api_sequence": [
        "zlib.compress",
        "str.encode",
        "cache.set",
        "cache.get",
        "zlib.decompress",
        "bytes.decode",
        "cache.add",
        "cache.get",
        "zlib.decompress",
        "bytes.decode",
        "cache.set_many",
        "cache.get",
        "zlib.decompress",
        "bytes.decode"
      ],
      "api_sequence_with_args": [
        "zlib.compress(value.encode())",
        "value.encode()",
        "cache.set('binary1', compressed_value)",
        "cache.get('binary1')",
        "zlib.decompress(compressed_result)",
        "decompress(compressed_result).decode()",
        "cache.add('binary1-add', compressed_value)",
        "cache.get('binary1-add')",
        "zlib.decompress(compressed_result)",
        "decompress(compressed_result).decode()",
        "cache.set_many({'binary1-set_many': compressed_value})",
        "cache.get('binary1-set_many')",
        "zlib.decompress(compressed_result)",
        "decompress(compressed_result).decode()"
      ],
      "mapped_sequence": [
        {
          "api_name": "zlib.compress",
          "id": "compress_data_zlib",
          "description": "Compresses data using zlib compression",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "compression_decompression"
        },
        {
          "api_name": "str.encode",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "cache.set",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "cache.get",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "zlib.decompress",
          "id": "decompress_data_zlib",
          "description": "Decompresses zlib-compressed data",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "compression_decompression"
        },
        {
          "api_name": "bytes.decode",
          "id": "decode_bytes_default",
          "description": "Decodes bytes using default codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "cache.add",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "cache.get",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "zlib.decompress",
          "id": "decompress_data_zlib",
          "description": "Decompresses zlib-compressed data",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "compression_decompression"
        },
        {
          "api_name": "bytes.decode",
          "id": "decode_bytes_default",
          "description": "Decodes bytes using default codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "cache.set_many",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "cache.get",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "zlib.decompress",
          "id": "decompress_data_zlib",
          "description": "Decompresses zlib-compressed data",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "compression_decompression"
        },
        {
          "api_name": "bytes.decode",
          "id": "decode_bytes_default",
          "description": "Decodes bytes using default codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        }
      ],
      "contextual_code": "from zlib import compress, decompress\n\nvalue = 'value_to_be_compressed'\ncompressed_value = compress(value.encode())\n\n# Test set\ncache.set('binary1', compressed_value)\ncompressed_result = cache.get('binary1')\nself.assertEqual(compressed_value, compressed_result)\nself.assertEqual(value, decompress(compressed_result).decode())\n\n# Test add\nself.assertIs(cache.add('binary1-add', compressed_value), True)\ncompressed_result = cache.get('binary1-add')\nself.assertEqual(compressed_value, compressed_result)\nself.assertEqual(value, decompress(compressed_result).decode())\n\n# Test set_many\ncache.set_many({'binary1-set_many': compressed_value})\ncompressed_result = cache.get('binary1-set_many')\nself.assertEqual(compressed_value, compressed_result)\nself.assertEqual(value, decompress(compressed_result).decode())"
    }
  }
]