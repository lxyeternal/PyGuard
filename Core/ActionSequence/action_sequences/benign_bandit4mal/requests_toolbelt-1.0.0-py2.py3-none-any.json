[
  {
    "metadata": {
      "package_name": "requests_toolbelt-1.0.0-py2.py3-none-any",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "decoder.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/requests_toolbelt-1.0.0-py2.py3-none-any/requests_toolbelt/multipart/decoder.py",
    "line_number": "155",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "154\t        content = response.content\n155\t        content_type = response.headers.get('content-type', None)\n156\t        return cls(content, content_type, encoding)",
    "code_snippet": "class MultipartDecoder(object):\n    \"\"\"\n\n    The ``MultipartDecoder`` object parses the multipart payload of\n    a bytestring into a tuple of ``Response``-like ``BodyPart`` objects.\n\n    The basic usage is::\n\n        import requests\n        from requests_toolbelt import MultipartDecoder\n\n        response = requests.get(url)\n        decoder = MultipartDecoder.from_response(response)\n        for part in decoder.parts:\n            print(part.headers['content-type'])\n\n    If the multipart content is not from a response, basic usage is::\n\n        from requests_toolbelt import MultipartDecoder\n\n        decoder = MultipartDecoder(content, content_type)\n        for part in decoder.parts:\n            print(part.headers['content-type'])\n\n    For both these usages, there is an optional ``encoding`` parameter. This is\n    a string, which is the name of the unicode codec to use (default is\n    ``'utf-8'``).\n\n    \"\"\"\n    def __init__(self, content, content_type, encoding='utf-8'):\n        #: Original Content-Type header\n        self.content_type = content_type\n        #: Response body encoding\n        self.encoding = encoding\n        #: Parsed parts of the multipart response body\n        self.parts = tuple()\n        self._find_boundary()\n        self._parse_body(content)\n\n    def _find_boundary(self):\n        ct_info = tuple(x.strip() for x in self.content_type.split(';'))\n        mimetype = ct_info[0]\n        if mimetype.split('/')[0].lower() != 'multipart':\n            raise NonMultipartContentTypeException(\n                \"Unexpected mimetype in content-type: '{}'\".format(mimetype)\n            )\n        for item in ct_info[1:]:\n            attr, value = _split_on_find(\n                item,\n                '='\n            )\n            if attr.lower() == 'boundary':\n                self.boundary = encode_with(value.strip('\"'), self.encoding)\n\n    @staticmethod\n    def _fix_first_part(part, boundary_marker):\n        bm_len = len(boundary_marker)\n        if boundary_marker == part[:bm_len]:\n            return part[bm_len:]\n        else:\n            return part\n\n    def _parse_body(self, content):\n        boundary = b''.join((b'--', self.boundary))\n\n        def body_part(part):\n            fixed = MultipartDecoder._fix_first_part(part, boundary)\n            return BodyPart(fixed, self.encoding)\n\n        def test_part(part):\n            return (part != b'' and\n                    part != b'\\r\\n' and\n                    part[:4] != b'--\\r\\n' and\n                    part != b'--')\n\n        parts = content.split(b''.join((b'\\r\\n', boundary)))\n        self.parts = tuple(body_part(x) for x in parts if test_part(x))\n\n    @classmethod\n    def from_response(cls, response, encoding='utf-8'):\n        content = response.content\n        content_type = response.headers.get('content-type', None)\n        return cls(content, content_type, encoding)",
    "pattern_analysis": {
      "api_sequence": [
        "str.split",
        "str.strip",
        "str.split",
        "encode_with",
        "bytes.split",
        "MultipartDecoder._fix_first_part",
        "BodyPart"
      ],
      "api_sequence_with_args": [
        "self.content_type.split(';')",
        "x.strip()",
        "mimetype.split('/')",
        "encode_with(value.strip('\"'), self.encoding)",
        "content.split(b''.join((b'\\r\\n', boundary)))",
        "MultipartDecoder._fix_first_part(part, boundary)",
        "BodyPart(fixed, self.encoding)"
      ],
      "mapped_sequence": [
        {
          "api_name": "str.split",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "str.strip",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "str.split",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "encode_with",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "bytes.split",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "MultipartDecoder._fix_first_part",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "BodyPart",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        }
      ],
      "contextual_code": "def _find_boundary(self):\n    ct_info = tuple(x.strip() for x in self.content_type.split(';'))\n    mimetype = ct_info[0]\n    if mimetype.split('/')[0].lower() != 'multipart':\n        raise NonMultipartContentTypeException(\n            \"Unexpected mimetype in content-type: '{}'\".format(mimetype)\n        )\n    for item in ct_info[1:]:\n        attr, value = _split_on_find(\n            item,\n            '='\n        )\n        if attr.lower() == 'boundary':\n            self.boundary = encode_with(value.strip('\"'), self.encoding)\n\ndef _parse_body(self, content):\n    boundary = b''.join((b'--', self.boundary))\n\n    def body_part(part):\n        fixed = MultipartDecoder._fix_first_part(part, boundary)\n        return BodyPart(fixed, self.encoding)\n\n    def test_part(part):\n        return (part != b'' and\n                part != b'\\r\\n' and\n                part[:4] != b'--\\r\\n' and\n                part != b'--')\n\n    parts = content.split(b''.join((b'\\r\\n', boundary)))\n    self.parts = tuple(body_part(x) for x in parts if test_part(x))"
    }
  }
]