[
  {
    "metadata": {
      "package_name": "gdal-3.10.3",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "batch_creator.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gdal-3.10.3/gdal-3.10.3/gdal-utils/osgeo_utils/auxiliary/batch_creator.py",
    "line_number": "43",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "42\t                with open(batch_name, \"w\") as file:\n43\t                    file.write(batch_content)\n44\t        return 0",
    "code_snippet": "def batch_creator(\n    filename_list: Sequence[PathLikeOrStr],\n    batch_content: str = r'@python \"%~dp0\\%~n0.py\" %*',\n):\n    \"\"\"\n    :param filename_list: list of file names (full path)\n    :param batch_content: contents of the wrapper batch file\n    :return: 0 if succeeded, 1 otherwise\n    The function create a wrapper batch file for each existing python file for invoking as a script\n    It is useful on Windows if the file association of *.py files is not python.exe (but some IDE for instance)\n    \"\"\"\n    try:\n        for script_name in filename_list:\n            py_name = Path(script_name).with_suffix(\".py\")\n            if os.path.exists(py_name):\n                batch_name = py_name.with_suffix(\".bat\")\n                print(f\"Creating: {batch_name}...\")\n                with open(batch_name, \"w\") as file:\n                    file.write(batch_content)\n        return 0\n    except Exception:\n        return 1",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.exists",
        "open",
        "file.write"
      ],
      "api_sequence_with_args": [
        "os.path.exists(py_name)",
        "open(batch_name, \"w\")",
        "file.write(batch_content)"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "file.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        }
      ],
      "contextual_code": "for script_name in filename_list:\n    py_name = Path(script_name).with_suffix(\".py\")\n    if os.path.exists(py_name):\n        batch_name = py_name.with_suffix(\".bat\")\n        with open(batch_name, \"w\") as file:\n            file.write(batch_content)"
    }
  },
  {
    "pyfile": "build_jp2_from_xml.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gdal-3.10.3/gdal-3.10.3/gdal-utils/osgeo_utils/samples/build_jp2_from_xml.py",
    "line_number": "311",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "310\t        out_f.write(jp2box_name.encode(\"ascii\"))\n311\t        out_f.write(text_content.encode(\"latin1\"))\n312",
    "code_snippet": "def parse_jp2_box(xml_tree, out_f, src_jp2file):\n    if not (\n        xml_tree[XML_TYPE_IDX] == gdal.CXT_Element\n        and xml_tree[XML_VALUE_IDX] == \"JP2Box\"\n    ):\n        print(\"Not a JP2Box element\")\n        return False\n    jp2box_name = get_attribute_val(xml_tree, \"name\")\n    if jp2box_name is None:\n        print(\"Cannot find JP2Box.name attribute\")\n        return False\n    if len(jp2box_name) != 4:\n        print(\"Invalid JP2Box.name : %s\" % jp2box_name)\n        return False\n    hex_binary_content = get_node_content(\n        find_xml_node(xml_tree, \"BinaryContent\", immediate_child=True)\n    )\n    decoded_content = find_xml_node(xml_tree, \"DecodedContent\", immediate_child=True)\n    decoded_geotiff = find_xml_node(xml_tree, \"DecodedGeoTIFF\", immediate_child=True)\n    text_content = get_node_content(\n        find_xml_node(xml_tree, \"TextContent\", immediate_child=True)\n    )\n    xml_content = find_xml_node(xml_tree, \"XMLContent\", immediate_child=True)\n    jp2box = find_xml_node(xml_tree, \"JP2Box\", immediate_child=True)\n    jp2codestream = find_xml_node(xml_tree, \"JP2KCodeStream\", immediate_child=True)\n\n    if hex_binary_content:\n        if decoded_content or decoded_geotiff or text_content or xml_content or jp2box:\n            print(\n                \"BinaryContent found, and one of DecodedContent/DecodedGeoTIFF/TextContent/XMLContent/JP2Box. The latter will be ignored\"\n            )\n        if jp2box_name == \"uuid\":\n            uuid = get_node_content(\n                find_xml_node(xml_tree, \"UUID\", immediate_child=True)\n            )\n            if uuid is None:\n                print(\"Cannot find JP2Box.UUID element\")\n                return False\n        else:\n            uuid = \"\"\n        out_f.write(\n            struct.pack(\n                \">I\" * 1, 8 + int(len(hex_binary_content) / 2) + int(len(uuid) / 2)\n            )\n        )\n        out_f.write(jp2box_name.encode(\"ascii\"))\n        write_hexstring_as_binary(uuid, out_f)\n        write_hexstring_as_binary(hex_binary_content, out_f)\n\n    elif decoded_content:\n        if decoded_geotiff or text_content or xml_content or jp2box:\n            print(\n                \"DecodedContent found, and one of DecodedGeoTIFF/TextContent/XMLContent/JP2Box. The latter will be ignored\"\n            )\n        pos = out_f.tell()\n        out_f.write(struct.pack(\">I\" * 1, 0))\n        out_f.write(jp2box_name.encode(\"ascii\"))\n        for child_idx in range(XML_FIRST_CHILD_IDX, len(decoded_content)):\n            child = decoded_content[child_idx]\n            if (\n                child[XML_TYPE_IDX] == gdal.CXT_Element\n                and child[XML_VALUE_IDX] == \"Field\"\n            ):\n                if not parse_field(child, out_f, src_jp2file):\n                    return False\n        new_pos = out_f.tell()\n        out_f.seek(pos, 0)\n        out_f.write(struct.pack(\">I\" * 1, new_pos - pos))\n        out_f.seek(new_pos, 0)\n\n    elif text_content:\n        if decoded_geotiff or xml_content or jp2box:\n            print(\n                \"TextContent found, and one of DecodedGeoTIFF/XMLContent/JP2Box. The latter will be ignored\"\n            )\n        out_f.write(struct.pack(\">I\" * 1, 8 + len(text_content)))\n        out_f.write(jp2box_name.encode(\"ascii\"))\n        out_f.write(text_content.encode(\"latin1\"))\n\n    elif xml_content:\n        if decoded_geotiff or jp2box:\n            print(\n                \"XMLContent found, and one of DecodedGeoTIFF/JP2Box. The latter will be ignored\"\n            )\n        serialized_xml_content = gdal.SerializeXMLTree(xml_content[XML_FIRST_CHILD_IDX])\n        out_f.write(struct.pack(\">I\" * 1, 8 + len(serialized_xml_content)))\n        out_f.write(jp2box_name.encode(\"ascii\"))\n        out_f.write(serialized_xml_content.encode(\"latin1\"))\n\n    elif jp2box:\n        if decoded_geotiff:\n            print(\"JP2Box found, and one of DecodedGeoTIFF. The latter will be ignored\")\n        pos = out_f.tell()\n        out_f.write(struct.pack(\">I\" * 1, 0))\n        out_f.write(jp2box_name.encode(\"ascii\"))\n        for child_idx in range(XML_FIRST_CHILD_IDX, len(xml_tree)):\n            child = xml_tree[child_idx]\n            if (\n                child[XML_TYPE_IDX] == gdal.CXT_Element\n                and child[XML_VALUE_IDX] == \"JP2Box\"\n            ):\n                if not parse_jp2_box(child, out_f, src_jp2file):\n                    return False\n        new_pos = out_f.tell()\n        out_f.seek(pos, 0)\n        out_f.write(struct.pack(\">I\" * 1, new_pos - pos))\n        out_f.seek(new_pos, 0)\n\n    elif decoded_geotiff:\n        serialized_xml_content = gdal.SerializeXMLTree(\n            decoded_geotiff[XML_FIRST_CHILD_IDX]\n        )\n\n        vrt_ds = gdal.Open(serialized_xml_content)\n        if vrt_ds is None:\n            print(\"Cannot decode VRTDataset. Outputting empty content\")\n            binary_content = \"\"\n        else:\n            tmpfilename = \"/vsimem/build_jp2_from_xml_tmp.tif\"\n            gdal.GetDriverByName(\"GTiff\").CreateCopy(tmpfilename, vrt_ds)\n            tif_f = gdal.VSIFOpenL(tmpfilename, \"rb\")\n            binary_content = gdal.VSIFReadL(1, 10000, tif_f)\n            gdal.VSIFCloseL(tif_f)\n            gdal.Unlink(tmpfilename)\n\n        uuid = get_node_content(find_xml_node(xml_tree, \"UUID\", immediate_child=True))\n        if uuid is None:\n            uuid = \"B14BF8BD083D4B43A5AE8CD7D5A6CE03\"\n\n        out_f.write(struct.pack(\">I\" * 1, 8 + len(binary_content) + int(len(uuid) / 2)))\n        out_f.write(jp2box_name.encode(\"ascii\"))\n        write_hexstring_as_binary(uuid, out_f)\n        out_f.write(binary_content)\n\n    elif jp2codestream:\n        pos = out_f.tell()\n        out_f.write(struct.pack(\">I\" * 1, 0))\n        out_f.write(jp2box_name.encode(\"ascii\"))\n        if not parse_jp2codestream(None, jp2codestream, out_f, src_jp2file):\n            return False\n        new_pos = out_f.tell()\n        out_f.seek(pos, 0)\n        out_f.write(struct.pack(\">I\" * 1, new_pos - pos))\n        out_f.seek(new_pos, 0)\n\n    else:\n        data_offset = get_attribute_val(xml_tree, \"data_offset\")\n        if data_offset is None:\n            print(\"Cannot find JP2Box.data_offset attribute\")\n            return False\n        data_offset = int(data_offset)\n\n        data_length = get_attribute_val(xml_tree, \"data_length\")\n        if data_length is None:\n            print(\"Cannot find JP2Box.data_length attribute\")\n            return False\n        data_length = int(data_length)\n\n        src_jp2file.seek(data_offset, 0)\n        data = src_jp2file.read(data_length)\n\n        out_f.write(struct.pack(\">I\" * 1, 8 + data_length))\n        out_f.write(jp2box_name.encode(\"ascii\"))\n        out_f.write(data)\n\n    return True",
    "pattern_analysis": {
      "api_sequence": [
        "struct.pack",
        "out_f.write",
        "jp2box_name.encode",
        "write_hexstring_as_binary",
        "write_hexstring_as_binary",
        "out_f.tell",
        "struct.pack",
        "out_f.write",
        "jp2box_name.encode",
        "parse_field",
        "out_f.tell",
        "out_f.seek",
        "struct.pack",
        "out_f.write",
        "out_f.seek",
        "struct.pack",
        "out_f.write",
        "jp2box_name.encode",
        "text_content.encode",
        "gdal.SerializeXMLTree",
        "struct.pack",
        "out_f.write",
        "jp2box_name.encode",
        "serialized_xml_content.encode",
        "out_f.tell",
        "struct.pack",
        "out_f.write",
        "jp2box_name.encode",
        "parse_jp2_box",
        "out_f.tell",
        "out_f.seek",
        "struct.pack",
        "out_f.write",
        "out_f.seek",
        "gdal.SerializeXMLTree",
        "gdal.Open",
        "gdal.GetDriverByName",
        "gdal.GetDriverByName.CreateCopy",
        "gdal.VSIFOpenL",
        "gdal.VSIFReadL",
        "gdal.VSIFCloseL",
        "gdal.Unlink",
        "struct.pack",
        "out_f.write",
        "jp2box_name.encode",
        "write_hexstring_as_binary",
        "out_f.write",
        "out_f.tell",
        "struct.pack",
        "out_f.write",
        "jp2box_name.encode",
        "parse_jp2codestream",
        "out_f.tell",
        "out_f.seek",
        "struct.pack",
        "out_f.write",
        "out_f.seek",
        "src_jp2file.seek",
        "src_jp2file.read",
        "struct.pack",
        "out_f.write",
        "jp2box_name.encode",
        "out_f.write"
      ],
      "api_sequence_with_args": [
        "struct.pack(\">I\" * 1, 8 + int(len(hex_binary_content) / 2) + int(len(uuid) / 2))",
        "out_f.write(struct.pack(...))",
        "jp2box_name.encode(\"ascii\")",
        "write_hexstring_as_binary(uuid, out_f)",
        "write_hexstring_as_binary(hex_binary_content, out_f)",
        "out_f.tell()",
        "struct.pack(\">I\" * 1, 0)",
        "out_f.write(struct.pack(...))",
        "jp2box_name.encode(\"ascii\")",
        "parse_field(child, out_f, src_jp2file)",
        "out_f.tell()",
        "out_f.seek(pos, 0)",
        "struct.pack(\">I\" * 1, new_pos - pos)",
        "out_f.write(struct.pack(...))",
        "out_f.seek(new_pos, 0)",
        "struct.pack(\">I\" * 1, 8 + len(text_content))",
        "out_f.write(struct.pack(...))",
        "jp2box_name.encode(\"ascii\")",
        "text_content.encode(\"latin1\")",
        "gdal.SerializeXMLTree(xml_content[XML_FIRST_CHILD_IDX])",
        "struct.pack(\">I\" * 1, 8 + len(serialized_xml_content))",
        "out_f.write(struct.pack(...))",
        "jp2box_name.encode(\"ascii\")",
        "serialized_xml_content.encode(\"latin1\")",
        "out_f.tell()",
        "struct.pack(\">I\" * 1, 0)",
        "out_f.write(struct.pack(...))",
        "jp2box_name.encode(\"ascii\")",
        "parse_jp2_box(child, out_f, src_jp2file)",
        "out_f.tell()",
        "out_f.seek(pos, 0)",
        "struct.pack(\">I\" * 1, new_pos - pos)",
        "out_f.write(struct.pack(...))",
        "out_f.seek(new_pos, 0)",
        "gdal.SerializeXMLTree(decoded_geotiff[XML_FIRST_CHILD_IDX])",
        "gdal.Open(serialized_xml_content)",
        "gdal.GetDriverByName(\"GTiff\")",
        "gdal.GetDriverByName(\"GTiff\").CreateCopy(tmpfilename, vrt_ds)",
        "gdal.VSIFOpenL(tmpfilename, \"rb\")",
        "gdal.VSIFReadL(1, 10000, tif_f)",
        "gdal.VSIFCloseL(tif_f)",
        "gdal.Unlink(tmpfilename)",
        "struct.pack(\">I\" * 1, 8 + len(binary_content) + int(len(uuid) / 2))",
        "out_f.write(struct.pack(...))",
        "jp2box_name.encode(\"ascii\")",
        "write_hexstring_as_binary(uuid, out_f)",
        "out_f.write(binary_content)",
        "out_f.tell()",
        "struct.pack(\">I\" * 1, 0)",
        "out_f.write(struct.pack(...))",
        "jp2box_name.encode(\"ascii\")",
        "parse_jp2codestream(None, jp2codestream, out_f, src_jp2file)",
        "out_f.tell()",
        "out_f.seek(pos, 0)",
        "struct.pack(\">I\" * 1, new_pos - pos)",
        "out_f.write(struct.pack(...))",
        "out_f.seek(new_pos, 0)",
        "src_jp2file.seek(data_offset, 0)",
        "src_jp2file.read(data_length)",
        "struct.pack(\">I\" * 1, 8 + data_length)",
        "out_f.write(struct.pack(...))",
        "jp2box_name.encode(\"ascii\")",
        "out_f.write(data)"
      ],
      "mapped_sequence": [
        {
          "api_name": "struct.pack",
          "id": "pack_values",
          "description": "Packs values into bytes using specified format",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "out_f.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "str.encode",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "write_hexstring_as_binary",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "write_hexstring_as_binary",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "out_f.tell",
          "id": "get_buffer_bytes",
          "description": "Retrieves bytes value from in-memory buffer",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "struct.pack",
          "id": "pack_values",
          "description": "Packs values into bytes using specified format",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "out_f.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "str.encode",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "parse_field",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "out_f.tell",
          "id": "get_buffer_bytes",
          "description": "Retrieves bytes value from in-memory buffer",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "out_f.seek",
          "id": "move_buffer_pointer",
          "description": "Moves buffer pointer to start",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "struct.pack",
          "id": "pack_values",
          "description": "Packs values into bytes using specified format",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "out_f.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "out_f.seek",
          "id": "move_buffer_pointer",
          "description": "Moves buffer pointer to start",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "struct.pack",
          "id": "pack_values",
          "description": "Packs values into bytes using specified format",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "out_f.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "str.encode",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "gdal.SerializeXMLTree",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "struct.pack",
          "id": "pack_values",
          "description": "Packs values into bytes using specified format",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "out_f.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "str.encode",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "out_f.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "out_f.tell",
          "id": "get_buffer_bytes",
          "description": "Retrieves bytes value from in-memory buffer",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "struct.pack",
          "id": "pack_values",
          "description": "Packs values into bytes using specified format",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "out_f.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "str.encode",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "parse_jp2_box",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "out_f.tell",
          "id": "get_buffer_bytes",
          "description": "Retrieves bytes value from in-memory buffer",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "out_f.seek",
          "id": "move_buffer_pointer",
          "description": "Moves buffer pointer to start",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "struct.pack",
          "id": "pack_values",
          "description": "Packs values into bytes using specified format",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "out_f.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "out_f.seek",
          "id": "move_buffer_pointer",
          "description": "Moves buffer pointer to start",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "gdal.SerializeXMLTree",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "gdal.Open",
          "id": "open_file_app",
          "description": "Opens file with associated application",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "gdal.GetDriverByName",
          "id": "import_dynamic",
          "description": "Dynamically imports specified module",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "gdal.GetDriverByName.CreateCopy",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "gdal.VSIFOpenL",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "gdal.VSIFReadL",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "gdal.VSIFCloseL",
          "id": "close_file",
          "description": "Closes the opened file",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_closing"
        },
        {
          "api_name": "gdal.Unlink",
          "id": "delete_file",
          "description": "Deletes specified file from filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "struct.pack",
          "id": "pack_values",
          "description": "Packs values into bytes using specified format",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "out_f.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "str.encode",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "write_hexstring_as_binary",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "out_f.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "out_f.tell",
          "id": "get_buffer_bytes",
          "description": "Retrieves bytes value from in-memory buffer",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "struct.pack",
          "id": "pack_values",
          "description": "Packs values into bytes using specified format",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "out_f.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "str.encode",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "parse_jp2codestream",
          "id": "deserialize_from_bytes",
          "description": "Deserializes Python object from bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "out_f.tell",
          "id": "get_buffer_bytes",
          "description": "Retrieves bytes value from in-memory buffer",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "out_f.seek",
          "id": "move_buffer_pointer",
          "description": "Moves buffer pointer to start",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "struct.pack",
          "id": "pack_values",
          "description": "Packs values into bytes using specified format",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "out_f.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "out_f.seek",
          "id": "move_buffer_pointer",
          "description": "Moves buffer pointer to start",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "src_jp2file.seek",
          "id": "move_buffer_pointer",
          "description": "Moves buffer pointer to start",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "src_jp2file.read",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "struct.pack",
          "id": "pack_values",
          "description": "Packs values into bytes using specified format",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "out_f.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "str.encode",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "out_f.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        }
      ],
      "contextual_code": "def parse_jp2_box(xml_tree, out_f, src_jp2file):\n    # ...\n    if hex_binary_content:\n        out_f.write(struct.pack(\">I\" * 1, 8 + int(len(hex_binary_content) / 2) + int(len(uuid) / 2)))\n        out_f.write(jp2box_name.encode(\"ascii\"))\n        write_hexstring_as_binary(uuid, out_f)\n        write_hexstring_as_binary(hex_binary_content, out_f)\n    elif decoded_content:\n        pos = out_f.tell()\n        out_f.write(struct.pack(\">I\" * 1, 0))\n        out_f.write(jp2box_name.encode(\"ascii\"))\n        for child_idx in range(XML_FIRST_CHILD_IDX, len(decoded_content)):\n            child = decoded_content[child_idx]\n            if (\n                child[XML_TYPE_IDX] == gdal.CXT_Element\n                and child[XML_VALUE_IDX] == \"Field\"\n            ):\n                if not parse_field(child, out_f, src_jp2file):\n                    return False\n        new_pos = out_f.tell()\n        out_f.seek(pos, 0)\n        out_f.write(struct.pack(\">I\" * 1, new_pos - pos))\n        out_f.seek(new_pos, 0)\n    elif text_content:\n        out_f.write(struct.pack(\">I\" * 1, 8 + len(text_content)))\n        out_f.write(jp2box_name.encode(\"ascii\"))\n        out_f.write(text_content.encode(\"latin1\"))\n    elif xml_content:\n        serialized_xml_content = gdal.SerializeXMLTree(xml_content[XML_FIRST_CHILD_IDX])\n        out_f.write(struct.pack(\">I\" * 1, 8 + len(serialized_xml_content)))\n        out_f.write(jp2box_name.encode(\"ascii\"))\n        out_f.write(serialized_xml_content.encode(\"latin1\"))\n    elif jp2box:\n        pos = out_f.tell()\n        out_f.write(struct.pack(\">I\" * 1, 0))\n        out_f.write(jp2box_name.encode(\"ascii\"))\n        for child_idx in range(XML_FIRST_CHILD_IDX, len(xml_tree)):\n            child = xml_tree[child_idx]\n            if (\n                child[XML_TYPE_IDX] == gdal.CXT_Element\n                and child[XML_VALUE_IDX] == \"JP2Box\"\n            ):\n                if not parse_jp2_box(child, out_f, src_jp2file):\n                    return False\n        new_pos = out_f.tell()\n        out_f.seek(pos, 0)\n        out_f.write(struct.pack(\">I\" * 1, new_pos - pos))\n        out_f.seek(new_pos, 0)\n    elif decoded_geotiff:\n        serialized_xml_content = gdal.SerializeXMLTree(\n            decoded_geotiff[XML_FIRST_CHILD_IDX]\n        )\n        vrt_ds = gdal.Open(serialized_xml_content)\n        if vrt_ds is None:\n            binary_content = \"\"\n        else:\n            tmpfilename = \"/vsimem/build_jp2_from_xml_tmp.tif\"\n            gdal.GetDriverByName(\"GTiff\").CreateCopy(tmpfilename, vrt_ds)\n            tif_f = gdal.VSIFOpenL(tmpfilename, \"rb\")\n            binary_content = gdal.VSIFReadL(1, 10000, tif_f)\n            gdal.VSIFCloseL(tif_f)\n            gdal.Unlink(tmpfilename)\n        out_f.write(struct.pack(\">I\" * 1, 8 + len(binary_content) + int(len(uuid) / 2)))\n        out_f.write(jp2box_name.encode(\"ascii\"))\n        write_hexstring_as_binary(uuid, out_f)\n        out_f.write(binary_content)\n    elif jp2codestream:\n        pos = out_f.tell()\n        out_f.write(struct.pack(\">I\" * 1, 0))\n        out_f.write(jp2box_name.encode(\"ascii\"))\n        if not parse_jp2codestream(None, jp2codestream, out_f, src_jp2file):\n            return False\n        new_pos = out_f.tell()\n        out_f.seek(pos, 0)\n        out_f.write(struct.pack(\">I\" * 1, new_pos - pos))\n        out_f.seek(new_pos, 0)\n    else:\n        src_jp2file.seek(data_offset, 0)\n        data = src_jp2file.read(data_length)\n        out_f.write(struct.pack(\">I\" * 1, 8 + data_length))\n        out_f.write(jp2box_name.encode(\"ascii\"))\n        out_f.write(data)"
    }
  }
]