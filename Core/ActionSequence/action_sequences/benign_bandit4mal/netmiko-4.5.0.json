[
  {
    "metadata": {
      "package_name": "netmiko-4.5.0",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:40"
    }
  },
  {
    "pyfile": "zte_zxros.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/netmiko-4.5.0/netmiko-4.5.0/netmiko/zte/zte_zxros.py",
    "line_number": "62",
    "type_description": "B806:sendall",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "61\t                # reply DO ECHO / DO SGA\n62\t                telnet_sock.sendall(IAC + DO + opt)\n63\t            else:",
    "code_snippet": "    @staticmethod\n    def _process_option(telnet_sock: socket, cmd: bytes, opt: bytes) -> None:\n        \"\"\"\n        ZTE need manually reply DO ECHO to enable echo command.\n        enable ECHO, SGA, set window size to [500, 50]\n        \"\"\"\n        if cmd == WILL:\n            if opt in [ECHO, SGA]:\n                # reply DO ECHO / DO SGA\n                telnet_sock.sendall(IAC + DO + opt)\n            else:\n                telnet_sock.sendall(IAC + DONT + opt)\n        elif cmd == DO:\n            if opt == NAWS:\n                # negotiate about window size\n                telnet_sock.sendall(IAC + WILL + opt)\n                # Width:500, Height:50\n                telnet_sock.sendall(IAC + SB + NAWS + b\"\\x01\\xf4\\x00\\x32\" + IAC + SE)\n            else:\n                telnet_sock.sendall(IAC + WONT + opt)",
    "pattern_analysis": {
      "api_sequence": [
        "socket.sendall",
        "socket.sendall",
        "socket.sendall",
        "socket.sendall"
      ],
      "api_sequence_with_args": [
        "socket.sendall(IAC + DO + opt)",
        "socket.sendall(IAC + DONT + opt)",
        "socket.sendall(IAC + WILL + opt)",
        "socket.sendall(IAC + SB + NAWS + b\"\\x01\\xf4\\x00\\x32\" + IAC + SE)"
      ],
      "mapped_sequence": [
        {
          "api_name": "socket.sendall",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "socket.sendall",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "socket.sendall",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "socket.sendall",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        }
      ],
      "contextual_code": "@staticmethod\ndef _process_option(telnet_sock: socket, cmd: bytes, opt: bytes) -> None:\n    if cmd == WILL:\n        if opt in [ECHO, SGA]:\n            telnet_sock.sendall(IAC + DO + opt)\n        else:\n            telnet_sock.sendall(IAC + DONT + opt)\n    elif cmd == DO:\n        if opt == NAWS:\n            telnet_sock.sendall(IAC + WILL + opt)\n            telnet_sock.sendall(IAC + SB + NAWS + b\"\\x01\\xf4\\x00\\x32\" + IAC + SE)\n        else:\n            telnet_sock.sendall(IAC + WONT + opt)"
    }
  },
  {
    "pyfile": "base_connection.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/netmiko-4.5.0/netmiko-4.5.0/netmiko/base_connection.py",
    "line_number": "1205",
    "type_description": "B808:settimeout",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1204\n1205\t            self.remote_conn.settimeout(self.blocking_timeout)\n1206\t            if self.keepalive:",
    "code_snippet": "def establish_connection(self, width: int = 511, height: int = 1000) -> None:\n    \"\"\"Establish SSH connection to the network device\n\n    Timeout will generate a NetmikoTimeoutException\n    Authentication failure will generate a NetmikoAuthenticationException\n\n    :param width: Specified width of the VT100 terminal window (default: 511)\n    :type width: int\n\n    :param height: Specified height of the VT100 terminal window (default: 1000)\n    :type height: int\n    \"\"\"\n    self.channel: Channel\n    if self.protocol == \"telnet\":\n        if self.sock_telnet:\n            self.remote_conn = telnet_proxy.Telnet(\n                self.host,\n                port=self.port,\n                timeout=self.timeout,\n                proxy_dict=self.sock_telnet,\n            )\n        else:\n            self.remote_conn = telnetlib.Telnet(  # type: ignore\n                self.host, port=self.port, timeout=self.timeout\n            )\n        # Migrating communication to channel class\n        self.channel = TelnetChannel(conn=self.remote_conn, encoding=self.encoding)\n        self.telnet_login()\n    elif self.protocol == \"serial\":\n        self.remote_conn = serial.Serial(**self.serial_settings)\n        self.channel = SerialChannel(conn=self.remote_conn, encoding=self.encoding)\n        self.serial_login()\n    elif self.protocol == \"ssh\":\n        ssh_connect_params = self._connect_params_dict()\n        self.remote_conn_pre: Optional[paramiko.SSHClient]\n        self.remote_conn_pre = self._build_ssh_client()\n\n        # initiate SSH connection\n        try:\n            self.remote_conn_pre.connect(**ssh_connect_params)\n        except socket.error as conn_error:\n            self.paramiko_cleanup()\n            msg = f\"\"\"TCP connection to device failed.\n\nCommon causes of this problem are:\n1. Incorrect hostname or IP address.\n2. Wrong TCP port.\n3. Intermediate firewall blocking access.\n\nDevice settings: {self.device_type} {self.host}:{self.port}\n\n\"\"\"\n\n            # Handle DNS failures separately\n            if \"Name or service not known\" in str(conn_error):\n                msg = (\n                    f\"DNS failure--the hostname you provided was not resolvable \"\n                    f\"in DNS: {self.host}:{self.port}\"\n                )\n\n            msg = msg.lstrip()\n            raise NetmikoTimeoutException(msg)\n        except paramiko.ssh_exception.AuthenticationException as auth_err:\n            self.paramiko_cleanup()\n            msg = f\"\"\"Authentication to device failed.\n\nCommon causes of this problem are:\n1. Invalid username and password\n2. Incorrect SSH-key file\n3. Connecting to the wrong device\n\nDevice settings: {self.device_type} {self.host}:{self.port}\n\n\"\"\"\n\n            msg += self.RETURN + str(auth_err)\n            raise NetmikoAuthenticationException(msg)\n        except paramiko.ssh_exception.SSHException as e:\n            self.paramiko_cleanup()\n            if \"No existing session\" in str(e):\n                msg = (\n                    \"Paramiko: 'No existing session' error: \"\n                    \"try increasing 'conn_timeout' to 15 seconds or larger.\"\n                )\n                raise NetmikoTimeoutException(msg)\n            else:\n                msg = f\"\"\"\nA paramiko SSHException occurred during connection creation:\n\n{str(e)}\n\n\"\"\"\n                raise NetmikoTimeoutException(msg)\n\n        if self.verbose:\n            print(f\"SSH connection established to {self.host}:{self.port}\")\n\n        # Use invoke_shell to establish an 'interactive session'\n        self.remote_conn = self.remote_conn_pre.invoke_shell(\n            term=\"vt100\", width=width, height=height\n        )\n\n        self.remote_conn.settimeout(self.blocking_timeout)\n        if self.keepalive:\n            assert isinstance(self.remote_conn.transport, paramiko.Transport)\n            self.remote_conn.transport.set_keepalive(self.keepalive)\n\n        # Migrating communication to channel class\n        self.channel = SSHChannel(conn=self.remote_conn, encoding=self.encoding)\n\n        self.special_login_handler()\n        if self.verbose:\n            print(\"Interactive SSH session established\")\n\n    return None",
    "pattern_analysis": {
      "api_sequence": [
        "telnet_proxy.Telnet",
        "telnetlib.Telnet",
        "serial.Serial",
        "paramiko.SSHClient.connect",
        "socket.error",
        "paramiko.ssh_exception.AuthenticationException",
        "paramiko.ssh_exception.SSHException",
        "paramiko.SSHClient.invoke_shell",
        "paramiko.SSHClient.settimeout",
        "paramiko.Transport.set_keepalive"
      ],
      "api_sequence_with_args": [
        "telnet_proxy.Telnet(self.host, port=self.port, timeout=self.timeout, proxy_dict=self.sock_telnet)",
        "telnetlib.Telnet(self.host, port=self.port, timeout=self.timeout)",
        "serial.Serial(**self.serial_settings)",
        "paramiko.SSHClient.connect(**ssh_connect_params)",
        "socket.error as conn_error",
        "paramiko.ssh_exception.AuthenticationException as auth_err",
        "paramiko.ssh_exception.SSHException as e",
        "paramiko.SSHClient.invoke_shell(term=\"vt100\", width=width, height=height)",
        "paramiko.SSHClient.settimeout(self.blocking_timeout)",
        "paramiko.Transport.set_keepalive(self.keepalive)"
      ],
      "mapped_sequence": [
        {
          "api_name": "telnet_proxy.Telnet",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "telnetlib.Telnet",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "serial.Serial",
          "id": "create_child_process",
          "description": "Creates child process by duplicating current process",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "paramiko.SSHClient.connect",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "socket.error",
          "id": "handle_socket_timeout",
          "description": "Handles socket timeout exception",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_configuration"
        },
        {
          "api_name": "paramiko.ssh_exception.AuthenticationException",
          "id": "raise_http_error",
          "description": "Raises HTTPError if response status code indicates error",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "paramiko.ssh_exception.SSHException",
          "id": "raise_http_error",
          "description": "Raises HTTPError if response status code indicates error",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "paramiko.SSHClient.invoke_shell",
          "id": "spawn_process_shell",
          "description": "Spawns new process to execute command with shell access",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_reception"
        },
        {
          "api_name": "paramiko.SSHClient.settimeout",
          "id": "set_socket_timeout",
          "description": "Sets timeout for socket operations",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_configuration"
        },
        {
          "api_name": "paramiko.Transport.set_keepalive",
          "id": "set_socket_timeout",
          "description": "Sets timeout for socket operations",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_configuration"
        }
      ],
      "contextual_code": "if self.protocol == \"telnet\":\n    if self.sock_telnet:\n        self.remote_conn = telnet_proxy.Telnet(\n            self.host,\n            port=self.port,\n            timeout=self.timeout,\n            proxy_dict=self.sock_telnet,\n        )\n    else:\n        self.remote_conn = telnetlib.Telnet(\n            self.host, port=self.port, timeout=self.timeout\n        )\n    self.channel = TelnetChannel(conn=self.remote_conn, encoding=self.encoding)\n    self.telnet_login()\nelif self.protocol == \"serial\":\n    self.remote_conn = serial.Serial(**self.serial_settings)\n    self.channel = SerialChannel(conn=self.remote_conn, encoding=self.encoding)\n    self.serial_login()\nelif self.protocol == \"ssh\":\n    ssh_connect_params = self._connect_params_dict()\n    self.remote_conn_pre = self._build_ssh_client()\n    try:\n        self.remote_conn_pre.connect(**ssh_connect_params)\n    except socket.error as conn_error:\n        self.paramiko_cleanup()\n        # ... error handling ...\n        raise NetmikoTimeoutException(msg)\n    except paramiko.ssh_exception.AuthenticationException as auth_err:\n        self.paramiko_cleanup()\n        # ... error handling ...\n        raise NetmikoAuthenticationException(msg)\n    except paramiko.ssh_exception.SSHException as e:\n        self.paramiko_cleanup()\n        # ... error handling ...\n        raise NetmikoTimeoutException(msg)\n    self.remote_conn = self.remote_conn_pre.invoke_shell(\n        term=\"vt100\", width=width, height=height\n    )\n    self.remote_conn.settimeout(self.blocking_timeout)\n    if self.keepalive:\n        assert isinstance(self.remote_conn.transport, paramiko.Transport)\n        self.remote_conn.transport.set_keepalive(self.keepalive)\n    self.channel = SSHChannel(conn=self.remote_conn, encoding=self.encoding)\n    self.special_login_handler()"
    }
  }
]