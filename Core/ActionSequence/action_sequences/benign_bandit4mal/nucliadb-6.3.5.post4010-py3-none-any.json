[
  {
    "metadata": {
      "package_name": "nucliadb-6.3.5.post4010-py3-none-any",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "audit.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/nucliadb-6.3.5.post4010-py3-none-any/nucliadb/writer/resource/audit.py",
    "line_number": "32",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "31\n32\t    agents = request.headers.get(\"USER-AGENT\", \"\").lower()\n33\t    if \"dashboard\" in agents:",
    "code_snippet": "from datetime import datetime\n\nfrom starlette.requests import Request\n\nfrom nucliadb_protos.writer_pb2 import Audit\n\n\ndef parse_audit(audit: Audit, request: Request):\n    audit.user = request.headers.get(\"X-NUCLIADB-USER\", \"\")\n\n    audit.when.FromDatetime(datetime.now())\n\n    agents = request.headers.get(\"USER-AGENT\", \"\").lower()\n    if \"dashboard\" in agents:\n        audit.source = Audit.Source.HTTP\n    elif \"desktop\" in agents:\n        audit.source = Audit.Source.DESKTOP\n    else:\n        audit.source = Audit.Source.HTTP\n\n    audit.origin = request.headers.get(\"X-FORWARDED-FOR\", \"\")\n",
    "pattern_analysis": {
      "api_sequence": [
        "request.headers.get",
        "datetime.now",
        "audit.when.FromDatetime",
        "request.headers.get",
        "request.headers.get"
      ],
      "api_sequence_with_args": [
        "request.headers.get(\"X-NUCLIADB-USER\", \"\")",
        "datetime.now()",
        "audit.when.FromDatetime(datetime.now())",
        "request.headers.get(\"USER-AGENT\", \"\")",
        "request.headers.get(\"X-FORWARDED-FOR\", \"\")"
      ],
      "mapped_sequence": [
        {
          "api_name": "request.headers.get",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "datetime.now",
          "id": "get_current_time",
          "description": "Returns current time in seconds since epoch",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "audit.when.FromDatetime",
          "id": "parse_datetime",
          "description": "Parses string into datetime object using format",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "request.headers.get",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "request.headers.get",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        }
      ],
      "contextual_code": "def parse_audit(audit: Audit, request: Request):\n    audit.user = request.headers.get(\"X-NUCLIADB-USER\", \"\")\n\n    audit.when.FromDatetime(datetime.now())\n\n    agents = request.headers.get(\"USER-AGENT\", \"\").lower()\n    if \"dashboard\" in agents:\n        audit.source = Audit.Source.HTTP\n    elif \"desktop\" in agents:\n        audit.source = Audit.Source.DESKTOP\n    else:\n        audit.source = Audit.Source.HTTP\n\n    audit.origin = request.headers.get(\"X-FORWARDED-FOR\", \"\")"
    }
  },
  {
    "pyfile": "gcs.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/nucliadb-6.3.5.post4010-py3-none-any/nucliadb/writer/tus/gcs.py",
    "line_number": "375",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "374\t                    raise GoogleCloudException(f\"{call.status}: {text}\")\n375\t        path = dm.get(\"path\")\n376\t        await dm.finish()",
    "code_snippet": "@backoff.on_exception(backoff.expo, RETRIABLE_EXCEPTIONS, jitter=backoff.random_jitter, max_tries=4)\nasync def finish(self, dm: FileDataManager):\n    if dm.size == 0:\n        if self.storage.session is None:\n            raise AttributeError()\n        # In case of empty file, we need to send a PUT request with empty body\n        # and Content-Range header set to \"bytes */0\"\n        headers = {\n            \"Content-Length\": \"0\",\n            \"Content-Range\": \"bytes */0\",\n        }\n        resumable_uri = dm.get(\"resumable_uri\")\n        async with self.storage.session.put(\n            resumable_uri,\n            headers=headers,\n            data=\"\",\n        ) as call:\n            if call.status not in [200, 201, 308]:\n                try:\n                    text = await call.text()\n                except Exception:\n                    text = \"\"\n                raise GoogleCloudException(f\"{call.status}: {text}\")\n    path = dm.get(\"path\")\n    await dm.finish()\n    return path",
    "pattern_analysis": {
      "api_sequence": [
        "FileDataManager.get",
        "aiohttp.ClientSession.put",
        "aiohttp.ClientResponse.text",
        "FileDataManager.get",
        "FileDataManager.finish"
      ],
      "api_sequence_with_args": [
        "FileDataManager.get(\"resumable_uri\")",
        "aiohttp.ClientSession.put(resumable_uri, headers=headers, data=\"\")",
        "aiohttp.ClientResponse.text()",
        "FileDataManager.get(\"path\")",
        "FileDataManager.finish()"
      ],
      "mapped_sequence": [
        {
          "api_name": "FileDataManager.get",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "aiohttp.ClientSession.put",
          "id": "send_http_put",
          "description": "Sends HTTP PUT request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "aiohttp.ClientResponse.text",
          "id": "get_response_unicode",
          "description": "Retrieves response body as Unicode string",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "FileDataManager.get",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "FileDataManager.finish",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        }
      ],
      "contextual_code": "@backoff.on_exception(backoff.expo, RETRIABLE_EXCEPTIONS, jitter=backoff.random_jitter, max_tries=4)\nasync def finish(self, dm: FileDataManager):\n    if dm.size == 0:\n        if self.storage.session is None:\n            raise AttributeError()\n        headers = {\n            \"Content-Length\": \"0\",\n            \"Content-Range\": \"bytes */0\",\n        }\n        resumable_uri = dm.get(\"resumable_uri\")\n        async with self.storage.session.put(\n            resumable_uri,\n            headers=headers,\n            data=\"\",\n        ) as call:\n            if call.status not in [200, 201, 308]:\n                try:\n                    text = await call.text()\n                except Exception:\n                    text = \"\"\n                raise GoogleCloudException(f\"{call.status}: {text}\")\n    path = dm.get(\"path\")\n    await dm.finish()\n    return path"
    }
  }
]