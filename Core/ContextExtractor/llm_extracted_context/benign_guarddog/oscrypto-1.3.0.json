[
  {
    "metadata": {
      "package_name": "oscrypto-1.3.0",
      "report_path": "/home2/blue/Documents/PyPIAgent/Codes/tool_detect/detect_output/study/guarddog/benign/oscrypto-1.3.0.txt",
      "total_matches": 1
    }
  },
  {
    "pyfile": "setup.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/oscrypto-1.3.0/oscrypto-1.3.0/setup.py",
    "line_number": "102",
    "type_description": "cmd-overwrite",
    "original_snippet": "setup(\nname=PACKAGE_NAME,\nversion=PACKAGE_VERSION,",
    "context_snippet": "import codecs\nimport os\nimport shutil\nimport sys\nimport warnings\n\nimport setuptools\nfrom setuptools import find_packages, setup, Command\nfrom setuptools.command.egg_info import egg_info\n\n\nPACKAGE_NAME = 'oscrypto'\nPACKAGE_VERSION = '1.3.0'\nPACKAGE_ROOT = os.path.dirname(os.path.abspath(__file__))\n\n\n# setuptools 38.6.0 and newer know about long_description_content_type, but\n# distutils still complains about it, so silence the warning\nsv = setuptools.__version__\nsvi = tuple(int(o) if o.isdigit() else o for o in sv.split('.'))\nif svi >= (38, 6):\n    warnings.filterwarnings(\n        'ignore',\n        \"Unknown distribution option: 'long_description_content_type'\",\n        module='distutils.dist'\n    )\n\n\n# Try to load the tests first from the source repository layout. If that\n# doesn't work, we assume this file is in the release package, and the tests\n# are part of the package {PACKAGE_NAME}_tests.\nif os.path.exists(os.path.join(PACKAGE_ROOT, 'tests')):\n    tests_require = []\n    test_suite = 'tests.make_suite'\nelse:\n    tests_require = ['%s_tests' % PACKAGE_NAME]\n    test_suite = '%s_tests.make_suite' % PACKAGE_NAME\n\n\n# This allows us to send the LICENSE and docs when creating a sdist. Wheels\n# automatically include the LICENSE, and don't need the docs. For these\n# to be included, the command must be \"python setup.py sdist\".\npackage_data = {}\nif sys.argv[1:] == ['sdist'] or sorted(sys.argv[1:]) == ['-q', 'sdist']:\n    package_data[PACKAGE_NAME] = [\n        '../LICENSE',\n        '../*.md',\n        '../docs/*.md',\n    ]\n\n\n# Ensures a copy of the LICENSE is included with the egg-info for\n# install and bdist_egg commands\nclass EggInfoCommand(egg_info):\n    def run(self):\n        egg_info_path = os.path.join(\n            PACKAGE_ROOT,\n            '%s.egg-info' % PACKAGE_NAME\n        )\n        if not os.path.exists(egg_info_path):\n            os.mkdir(egg_info_path)\n        shutil.copy2(\n            os.path.join(PACKAGE_ROOT, 'LICENSE'),\n            os.path.join(egg_info_path, 'LICENSE')\n        )\n        egg_info.run(self)\n\n\nclass CleanCommand(Command):\n    user_options = [\n        ('all', 'a', '(Compatibility with original clean command)'),\n    ]\n\n    def initialize_options(self):\n        self.all = False\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        sub_folders = ['build', 'temp', '%s.egg-info' % PACKAGE_NAME]\n        if self.all:\n            sub_folders.append('dist')\n        for sub_folder in sub_folders:\n            full_path = os.path.join(PACKAGE_ROOT, sub_folder)\n            if os.path.exists(full_path):\n                shutil.rmtree(full_path)\n        for root, dirs, files in os.walk(os.path.join(PACKAGE_ROOT, PACKAGE_NAME)):\n            for filename in files:\n                if filename[-4:] == '.pyc':\n                    os.unlink(os.path.join(root, filename))\n            for dirname in list(dirs):\n                if dirname == '__pycache__':\n                    shutil.rmtree(os.path.join(root, dirname))\n\n\nreadme = ''\nwith codecs.open(os.path.join(PACKAGE_ROOT, 'readme.md'), 'r', 'utf-8') as f:\n    readme = f.read()\n\n\nsetup(\n    name=PACKAGE_NAME,\n    version=PACKAGE_VERSION,\n\n    description=(\n        'TLS (SSL) sockets, key generation, encryption, decryption, signing, '\n        'verification and KDFs using the OS crypto libraries. Does not require '\n        'a compiler, and relies on the OS for patching. Works on Windows, OS X '\n        'and Linux/BSD.'\n    ),\n    long_description=readme,\n    long_description_content_type='text/markdown',\n\n    url='https://github.com/wbond/oscrypto',\n\n    author='wbond',\n    author_email='will@wbond.net',\n\n    license='MIT',\n\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n\n        'Intended Audience :: Developers',\n\n        'License :: OSI Approved :: MIT License',\n\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 2.6',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.2',\n        'Programming Language :: Python :: 3.3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: Implementation :: PyPy',\n\n        'Topic :: Security :: Cryptography',\n    ],\n\n    keywords='crypto pki tls ssl x509 certificate encrypt decrypt sign verify rsa dsa ec dh',\n\n    install_requires=['asn1crypto>=1.5.1'],\n\n    packages=find_packages(exclude=['tests*', 'dev*']),\n    package_data=package_data,\n\n    tests_require=tests_require,\n    test_suite=test_suite,\n\n    cmdclass={\n        'clean': CleanCommand,\n        'egg_info': EggInfoCommand,\n    }\n)\n",
    "hash_value": "b980cd6984f76cc8080505861bccf5c8",
    "detection_index": 1
  }
]