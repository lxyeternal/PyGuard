[
  {
    "metadata": {
      "package_name": "rpyc-6.0.1",
      "report_path": "/home2/blue/Documents/PyPIAgent/Codes/tool_detect/detect_output/study/guarddog/benign/rpyc-6.0.1.txt",
      "total_matches": 1
    }
  },
  {
    "pyfile": "vinegar.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/rpyc-6.0.1/rpyc-6.0.1/rpyc/core/vinegar.py",
    "line_number": "126",
    "type_description": "obfuscation",
    "original_snippet": "cls = getattr(exceptions_module, clsname, None)",
    "context_snippet": "def load(val, import_custom_exceptions, instantiate_custom_exceptions, instantiate_oldstyle_exceptions):\n    \"\"\"\n    Loads a dumped exception (the tuple returned by :func:`dump`) info a\n    throwable exception object. If the exception cannot be instantiated for any\n    reason (i.e., the security parameters do not allow it, or the exception\n    class simply doesn't exist on the local machine), a :class:`GenericException`\n    instance will be returned instead, containing all of the original exception's\n    details.\n\n    :param val: the dumped exception\n    :param import_custom_exceptions: whether to allow this function to import custom modules\n                                     (imposes a security risk)\n    :param instantiate_custom_exceptions: whether to allow this function to instantiate \"custom\n                                          exceptions\" (i.e., not one of the built-in exceptions,\n                                          such as ``ValueError``, ``OSError``, etc.)\n    :param instantiate_oldstyle_exceptions: whether to allow this function to instantiate exception\n                                            classes that do not derive from ``BaseException``.\n                                            This is required to support old-style exceptions.\n                                            Not applicable for Python 3 and above.\n\n    :returns: A throwable exception object\n    \"\"\"\n    if val == consts.EXC_STOP_ITERATION:\n        return StopIteration  # optimization\n    if type(val) is str:\n        return val  # deprecated string exceptions\n\n    (modname, clsname), args, attrs, tbtext = val\n\n    if import_custom_exceptions and modname not in sys.modules:\n        try:\n            __import__(modname, None, None, \"*\")\n        except Exception:\n            pass\n\n    if instantiate_custom_exceptions:\n        if modname in sys.modules:\n            cls = getattr(sys.modules[modname], clsname, None)\n        else:\n            cls = None\n    elif modname == exceptions_module.__name__:\n        cls = getattr(exceptions_module, clsname, None)\n    else:\n        cls = None\n\n    if not isinstance(cls, type) or not issubclass(cls, BaseException):\n        cls = None\n\n    if cls is None:\n        fullname = f\"{modname}.{clsname}\"\n        # py2: `type()` expects `str` not `unicode`!\n        fullname = str(fullname)\n        if fullname not in _generic_exceptions_cache:\n            fakemodule = {\"__module__\": f\"{__name__}/{modname}\"}\n            if isinstance(GenericException, ClassType):\n                _generic_exceptions_cache[fullname] = ClassType(fullname, (GenericException,), fakemodule)\n            else:\n                _generic_exceptions_cache[fullname] = type(fullname, (GenericException,), fakemodule)\n        cls = _generic_exceptions_cache[fullname]\n\n    cls = _get_exception_class(cls)\n\n    # support old-style exception classes\n    if ClassType is not type and isinstance(cls, ClassType):\n        exc = InstanceType(cls)\n    else:\n        exc = cls.__new__(cls)\n\n    exc.args = args\n    for name, attrval in attrs:\n        try:\n            setattr(exc, name, attrval)\n        except AttributeError:      # handle immutable attrs (@property)\n            pass\n\n    # When possible and relevant, warn the user about mismatch in major versions between remote and local\n    remote_ver = getattr(exc, \"_remote_version\", \"<version denied>\")\n    if remote_ver != \"<version denied>\" and remote_ver.split('.')[0] != str(version.version[0]):\n        _warn = '\\nWARNING: Remote is on RPyC {} and local is on RPyC {}.\\n\\n'\n        tbtext += _warn.format(remote_ver, version.__version__)\n\n    exc._remote_tb = tbtext\n    return exc\n\n# Data dependencies:\n# - exceptions_module: imported at top of file (either 'exceptions' or 'builtins')\n# - clsname: unpacked from val, which is a tuple argument to load()\n# - cls: local variable, set by getattr(exceptions_module, clsname, None)\n# - The function uses sys, version, _generic_exceptions_cache, ClassType, GenericException, _get_exception_class, InstanceType, etc., all defined or imported in the file.",
    "hash_value": "85d5dc02c332aec97f84d76f693b20cd",
    "detection_index": 1
  }
]