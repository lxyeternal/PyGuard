[
  {
    "metadata": {
      "package_name": "singlestoredb-1.12.4",
      "report_path": "/home2/blue/Documents/PyPIAgent/Codes/tool_detect/detect_output/study/guarddog/benign/singlestoredb-1.12.4.txt",
      "total_matches": 2
    }
  },
  {
    "pyfile": "graphql.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/singlestoredb-1.12.4/singlestoredb-1.12.4/singlestoredb/fusion/graphql.py",
    "line_number": "173",
    "type_description": "exfiltrate-sensitive-data",
    "original_snippet": "res = requests.post(\nself.api_url,\nheaders={\n'Content-Type': 'application/json',\n'Authorization': f'Bearer {api_token}',\n},\njson={\n'quer...        )",
    "context_snippet": "import os\nimport requests\nfrom .result import FusionSQLResult\n\nAPI_URL = 'https://backend.singlestore.com/public'\n\nclass GraphQuery(object):\n    def __init__(\n        self,\n        api_token: str = '',\n        api_url: str = API_URL,\n    ) -> None:\n        self.api_token = api_token\n        self.api_url = api_url\n\n    def run(\n        self,\n        variables: Optional[Dict[str, Any]] = None,\n        *,\n        filter_expr: str = '',\n    ) -> FusionSQLResult:\n        api_token = self.api_token or os.environ.get('SINGLESTOREDB_BACKEND_TOKEN')\n        res = requests.post(\n            self.api_url,\n            headers={\n                'Content-Type': 'application/json',\n                'Authorization': f'Bearer {api_token}',\n            },\n            json={\n                'query': type(self).get_query(),\n                'variables': variables or {},\n            },\n        )\n        if res.status_code != 200:\n            raise ValueError(f'an error occurred: {res.text}')\n        json = res.json()\n        if json['data']:\n            data = json['data'].popitem()[-1]\n            if isinstance(data, Dict):\n                data = [data]\n        else:\n            data = []\n        fres = FusionSQLResult()\n        rows = []\n        fields = type(self).get_fields()\n        for i, obj in enumerate(data):\n            row = []\n            for name, field in fields:\n                found, value = field.get_path(obj)\n                if found:\n                    if i == 0:\n                        fres.add_field(name, field.dtype)\n                    row.append(value)\n            rows.append(tuple(row))\n        fres.set_rows(rows)\n        return fres",
    "hash_value": "f4397f6add80e404858ab6ba6fb7de43",
    "detection_index": 1
  },
  {
    "pyfile": "auth.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/singlestoredb-1.12.4/singlestoredb-1.12.4/singlestoredb/auth.py",
    "line_number": "193",
    "type_description": "shady-links",
    "original_snippet": "returnTo=f'http://{host}:{server.server_address[1]}',",
    "context_snippet": "def get_jwt(\n    email: str, url: str = SSO_URL,\n    clusters: Optional[Union[str, List[str]]] = None,\n    databases: Optional[Union[str, List[str]]] = None,\n    timeout: int = 60, browser: Optional[Union[str, List[str]]] = None,\n) -> JSONWebToken:\n    \"\"\"\n    Retrieve a JWT token from the SingleStoreDB single-sign-on URL.\n\n    Parameters\n    ----------\n    email : str\n        EMail of the database user\n    url : str, optional\n        The URL of the single-sign-on token generator\n    clusters : str or list[str], optional\n        The name of the cluster being connected to\n    databases : str or list[str], optional\n        The name of the database being connected to\n    timeout : int, optional\n        Number of seconds to wait before timing out the authentication request\n    browser : str or list[str], optional\n        Browser to use instead of the default. This value can be any of the\n        names specified in Python's `webbrowser` module. This includes\n        'google-chrome', 'chrome', 'chromium', 'chromium-browser', 'firefox',\n        etc. Note that at the time of this writing, Safari was not\n        compatible. If a list of names is specified, each one tried until\n        a working browser is located.\n\n    Returns\n    -------\n    JSONWebToken\n\n    \"\"\"\n    import platform\n    import webbrowser\n    import time\n    import threading\n    import urllib\n    from http.server import BaseHTTPRequestHandler, HTTPServer\n\n    from .config import get_option\n\n    token = []\n    error = []\n\n    class AuthServer(BaseHTTPRequestHandler):\n\n        def log_message(self, format: str, *args: Any) -> None:\n            return\n\n        def do_POST(self) -> None:\n            content_len = int(self.headers.get('Content-Length', 0))\n            post_body = self.rfile.read(content_len)\n\n            try:\n                out = JSONWebToken.from_token(post_body)\n            except Exception as exc:\n                self.send_response(400, exc.args[0])\n                self.send_header('Content-Type', 'text/plain')\n                self.end_headers()\n                error.append(exc)\n                return\n\n            token.append(out)\n\n            self.send_response(204)\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.send_header('Content-Type', 'text/plain')\n            self.end_headers()\n\n    server = None\n\n    try:\n        server = HTTPServer(('127.0.0.1', 0), AuthServer)\n        threading.Thread(target=server.serve_forever).start()\n\n        host = server.server_address[0]\n        if isinstance(host, bytes):\n            host = host.decode('utf-8')\n\n        query = urllib.parse.urlencode({\n            k: v for k, v in dict(\n                email=email,\n                returnTo=f'http://{host}:{server.server_address[1]}',\n                db=_listify(databases),\n                cluster=_listify(clusters),\n            ).items() if v is not None\n        })\n\n        if browser is None:\n            browser = get_option('sso_browser')\n\n        # On Mac, always specify a list of browsers to check because Safari\n        # is not compatible.\n        if browser is None and platform.platform().lower().startswith('mac'):\n            browser = [\n                'chrome', 'google-chrome', 'chromium',\n                'chromium-browser', 'firefox',\n            ]\n\n        if browser and isinstance(browser, str):\n            browser = [browser]\n\n        if browser:\n            exc: Optional[Exception] = None\n            for item in browser:\n                try:\n                    webbrowser.get(item).open(f'{url}?{query}')\n                    break\n                except webbrowser.Error as wexc:\n                    exc = wexc\n                    pass\n            if exc is not None:\n                raise RuntimeError(\n                    'Could not find compatible web browser for accessing JWT',\n                )\n        else:\n            webbrowser.open(f'{url}?{query}')\n\n        for i in range(timeout * 2):\n            if error:\n                raise error[0]\n            if token:\n                out = token[0]\n                out.url = url\n                out.clusters = clusters\n                out.databases = databases\n                out.timeout = timeout\n                return out\n            time.sleep(0.5)\n\n    finally:\n        if server is not None:\n            server.shutdown()\n\n    raise RuntimeError('Timeout waiting for token')\n\n# Data dependencies:\n# - host: assigned as server.server_address[0] (host part of HTTPServer binding)\n# - server: created as HTTPServer(('127.0.0.1', 0), AuthServer)\n# - server.server_address[1]: port assigned by OS\n# - returnTo: used as a query parameter in the SSO URL\n# - _listify: helper function defined above\n# - email, clusters, databases: function arguments\n# - urllib: imported in function\n# - SSO_URL: global constant\n# - get_option: imported from .config\n# - JSONWebToken: class defined above\n",
    "hash_value": "8980a94f00449d6ba477eff9ee52533e",
    "detection_index": 1
  }
]