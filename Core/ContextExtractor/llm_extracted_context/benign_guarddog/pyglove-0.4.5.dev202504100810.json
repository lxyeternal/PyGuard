[
  {
    "metadata": {
      "package_name": "pyglove-0.4.5.dev202504100810",
      "report_path": "/home2/blue/Documents/PyPIAgent/Codes/tool_detect/detect_output/study/guarddog/benign/pyglove-0.4.5.dev202504100810.txt",
      "total_matches": 1
    }
  },
  {
    "pyfile": "annotation_conversion.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyglove-0.4.5.dev202504100810/pyglove-0.4.5.dev202504100810/pyglove/core/typing/annotation_conversion.py",
    "line_number": "208",
    "type_description": "obfuscation",
    "original_snippet": "return getattr(builtins, name), True",
    "context_snippet": "def _resolve(type_id: str):\n\n    def _as_forward_ref() -> typing.ForwardRef:\n      return typing.ForwardRef(type_id, False, parent_module)  # pytype: disable=not-callable\n\n    def _resolve_name(name: str, parent_obj: typing.Any):\n      if name == 'None':\n        return None, True\n      if parent_obj is not None and hasattr(parent_obj, name):\n        return getattr(parent_obj, name), False\n      if hasattr(builtins, name):\n        return getattr(builtins, name), True\n      if type_id == '...':\n        return ..., True\n      return utils.MISSING_VALUE, False\n\n    names = type_id.split('.')\n    if len(names) == 1:\n      reference, is_builtin = _resolve_name(names[0], parent_module)\n      if is_builtin:\n        return reference\n      if not is_builtin and (\n          # When reference is not found, we should treat it as a forward\n          # reference.\n          reference == utils.MISSING_VALUE\n          # When module is being reloaded, we should treat all non-builtin\n          # references as forward references.\n          or getattr(parent_module, '__reloading__', False)\n      ):\n        return _as_forward_ref()\n      return reference\n\n    root_obj, _ = _resolve_name(names[0], parent_module)\n    # When root object is not found, we should treat it as a forward reference.\n    if root_obj == utils.MISSING_VALUE:\n      return _as_forward_ref()\n\n    parent_obj = root_obj\n    # When root object is a module, we should treat reference to its children\n    # as non-forward references.\n    if inspect.ismodule(root_obj):\n      for name in names[1:]:\n        parent_obj, _ = _resolve_name(name, parent_obj)\n        if parent_obj == utils.MISSING_VALUE:\n          raise TypeError(f'{type_id!r} does not exist.')\n      return parent_obj\n    # When root object is non-module variable of current module, and when the\n    # module is being reloaded, we should treat reference to its children as\n    # forward references.\n    elif getattr(parent_module, '__reloading__', False):\n      return _as_forward_ref()\n    # When root object is non-module variable of current module, we should treat\n    # unresolved reference to its children as forward references.\n    else:\n      for name in names[1:]:\n        parent_obj, _ = _resolve_name(name, parent_obj)\n        if parent_obj == utils.MISSING_VALUE:\n          return _as_forward_ref()\n      return parent_obj",
    "hash_value": "e347d6dd44147b8fce2345c554a05f17",
    "detection_index": 1
  }
]