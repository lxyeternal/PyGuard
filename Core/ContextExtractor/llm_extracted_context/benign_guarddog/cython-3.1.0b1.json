[
  {
    "metadata": {
      "package_name": "cython-3.1.0b1",
      "report_path": "/home2/blue/Documents/PyPIAgent/Codes/tool_detect/detect_output/study/guarddog/benign/cython-3.1.0b1.txt",
      "total_matches": 8
    }
  },
  {
    "pyfile": "setup.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cython-3.1.0b1/cython-3.1.0b1/Demos/libraries/setup.py",
    "line_number": "14",
    "type_description": "code-execution",
    "original_snippet": "assert os.system(\"gcc -shared -fPIC -c mymath.c -o mymath.o\") == 0",
    "context_snippet": "from __future__ import absolute_import, print_function\n\nimport os\nimport sys\n\nfrom distutils.core import setup\nfrom distutils.extension import Extension\nfrom Cython.Build import cythonize\n\n\n# For demo purposes, we build our own tiny library.\ntry:\n    print(\"building libmymath.a\")\n    assert os.system(\"gcc -shared -fPIC -c mymath.c -o mymath.o\") == 0\n    assert os.system(\"ar rcs libmymath.a mymath.o\") == 0\nexcept:\n    if not os.path.exists(\"libmymath.a\"):\n        print(\"Error building external library, please create libmymath.a manually.\")\n        sys.exit(1)",
    "hash_value": "d227d5496c3a71ca2d3f9be748030ad9",
    "detection_index": 1
  },
  {
    "pyfile": "setup.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cython-3.1.0b1/cython-3.1.0b1/setup.py",
    "line_number": "128",
    "type_description": "code-execution",
    "original_snippet": "subprocess.check_call([\npgen,\nos.path.join(grammar),\nos.path.join(parser_dir, 'graminit.h'),\nos.path.join(parser_dir, 'graminit.c'),\n])",
    "context_snippet": "def compile_cython_modules(profile=False, coverage=False, compile_minimal=False, compile_more=False, cython_with_refnanny=False,\n                           cython_limited_api=False):\n    source_root = os.path.abspath(os.path.dirname(__file__))\n    compiled_modules = [\n        \"Cython.Plex.Actions\",\n        \"Cython.Plex.Scanners\",\n        \"Cython.Compiler.FlowControl\",\n        \"Cython.Compiler.LineTable\",\n        \"Cython.Compiler.Scanning\",\n        \"Cython.Compiler.Visitor\",\n        \"Cython.Runtime.refnanny\",\n    ]\n    if not compile_minimal:\n        compiled_modules.extend([\n            \"Cython.Plex.Machines\",\n            \"Cython.Plex.Transitions\",\n            \"Cython.Plex.DFA\",\n            \"Cython.Compiler.Code\",\n            \"Cython.Compiler.FusedNode\",\n            \"Cython.Compiler.Parsing\",\n            \"Cython.Tempita._tempita\",\n            \"Cython.StringIOTree\",\n            \"Cython.Utils\",\n        ])\n    if compile_more and not compile_minimal:\n        compiled_modules.extend([\n            \"Cython.Compiler.Lexicon\",\n            \"Cython.Compiler.Pythran\",\n            \"Cython.Build.Dependencies\",\n            \"Cython.Compiler.ParseTreeTransforms\",\n            \"Cython.Compiler.Nodes\",\n            \"Cython.Compiler.ExprNodes\",\n            \"Cython.Compiler.ModuleNode\",\n            \"Cython.Compiler.Optimize\",\n            ])\n\n    from shutil import which\n    from sysconfig import get_path\n    pgen = which(\n        'pgen', path=os.pathsep.join([os.environ['PATH'], os.path.join(get_path('include'), '..', 'Parser')]))\n    if not pgen:\n        sys.stderr.write(\"Unable to find pgen, not compiling formal grammar.\\n\")\n    else:\n        parser_dir = os.path.join(os.path.dirname(__file__), 'Cython', 'Parser')\n        grammar = os.path.join(parser_dir, 'Grammar')\n        subprocess.check_call([\n            pgen,\n            os.path.join(grammar),\n            os.path.join(parser_dir, 'graminit.h'),\n            os.path.join(parser_dir, 'graminit.c'),\n            ])\n        cst_pyx = os.path.join(parser_dir, 'ConcreteSyntaxTree.pyx')\n        if os.stat(grammar)[stat.ST_MTIME] > os.stat(cst_pyx)[stat.ST_MTIME]:\n            mtime = os.stat(grammar)[stat.ST_MTIME]\n            os.utime(cst_pyx, (mtime, mtime))\n        compiled_modules.extend([\n                \"Cython.Parser.ConcreteSyntaxTree\",\n            ])\n\n    defines = []\n    extra_extension_args = {}\n    if cython_limited_api:\n        defines += [\n            ('Py_LIMITED_API', '0x03080000'),\n        ]\n        extra_extension_args['py_limited_api'] = True\n\n    if sysconfig.get_config_var('Py_GIL_DISABLED') and platform.system() == \"Windows\":\n        defines.append(('Py_GIL_DISABLED', 1))\n\n    extra_defines = []\n    if cython_with_refnanny:\n        extra_defines.append(('CYTHON_REFNANNY', '1'))\n    if coverage:\n        extra_defines.append(('CYTHON_TRACE', '1'))\n\n    extensions = []\n    for module in compiled_modules:\n        source_file = os.path.join(source_root, *module.split('.'))\n        pyx_source_file = source_file + \".py\"\n        if not os.path.exists(pyx_source_file):\n            pyx_source_file += \"x\"  # .py -> .pyx\n\n        dep_files = []\n        if os.path.exists(source_file + '.pxd'):\n            dep_files.append(source_file + '.pxd')\n\n        extensions.append(Extension(\n            module, sources=[pyx_source_file],\n            define_macros=(defines + (extra_defines if '.refnanny' not in module else [])),\n            depends=dep_files,\n            **extra_extension_args))\n        # XXX hack around setuptools quirk for '*.pyx' sources\n        extensions[-1].sources[0] = pyx_source_file\n\n    # optimise build parallelism by starting with the largest modules\n    extensions.sort(key=lambda ext: os.path.getsize(ext.sources[0]), reverse=True)\n\n    from Cython.Distutils.build_ext import build_ext as cy_build_ext\n    build_ext = None\n    try:\n        # Use the setuptools build_ext in preference, because it\n        # gets limited api filenames right, and should inherit itself from\n        # Cython's own build_ext. But failing that, use the Cython build_ext\n        # directly.\n        from setuptools.command.build_ext import build_ext\n        if cy_build_ext not in build_ext.__mro__:\n            build_ext = cy_build_ext\n    except ImportError:\n        build_ext = cy_build_ext\n\n    from Cython.Compiler.Options import get_directive_defaults\n    get_directive_defaults().update(\n        language_level=3,\n        auto_pickle=False,\n        binding=False,\n        always_allow_keywords=False,\n        autotestdict=False,\n    )\n    if profile:\n        get_directive_defaults()['profile'] = True\n        sys.stderr.write(\"Enabled profiling for the Cython binary modules\\n\")\n    if coverage:\n        get_directive_defaults()['linetrace'] = True\n        sys.stderr.write(\"Enabled line tracing and profiling for the Cython binary modules\\n\")\n\n    # not using cythonize() directly to let distutils decide whether building extensions was requested\n    add_command_class(\"build_ext\", build_ext)\n    setup_args['ext_modules'] = extensions",
    "hash_value": "9bdab9e9ce613d6642551b07249afc8a",
    "detection_index": 1
  },
  {
    "pyfile": "Scanning.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cython-3.1.0b1/cython-3.1.0b1/Cython/Compiler/Scanning.py",
    "line_number": "107",
    "type_description": "obfuscation",
    "original_snippet": "benv.declare(name, getattr(builtins, name))",
    "context_snippet": "def initial_compile_time_env():\n    benv = CompileTimeScope()\n    names = ('UNAME_SYSNAME', 'UNAME_NODENAME', 'UNAME_RELEASE', 'UNAME_VERSION', 'UNAME_MACHINE')\n    for name, value in zip(names, platform.uname()):\n        benv.declare(name, value)\n    import builtins\n\n    names = (\n        'False', 'True',\n        'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes',\n        'chr', 'cmp', 'complex', 'dict', 'divmod', 'enumerate', 'filter',\n        'float', 'format', 'frozenset', 'hash', 'hex', 'int', 'len',\n        'list', 'map', 'max', 'min', 'oct', 'ord', 'pow', 'range',\n        'repr', 'reversed', 'round', 'set', 'slice', 'sorted', 'str',\n        'sum', 'tuple', 'zip',\n        ### defined below in a platform independent way\n        # 'long', 'unicode', 'reduce', 'xrange'\n    )\n\n    for name in names:\n        try:\n            benv.declare(name, getattr(builtins, name))\n        except AttributeError:\n            # ignore, likely Py3\n            pass\n\n    # Py2/3 adaptations\n    from functools import reduce\n    benv.declare('reduce', reduce)\n    benv.declare('unicode', str)\n    benv.declare('long', getattr(builtins, 'long', getattr(builtins, 'int')))\n    benv.declare('xrange', getattr(builtins, 'xrange', getattr(builtins, 'range')))\n\n    denv = CompileTimeScope(benv)\n    return denv",
    "hash_value": "678af818cf17bd441061494c6920e652",
    "detection_index": 1
  },
  {
    "pyfile": "TestBuiltin.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cython-3.1.0b1/cython-3.1.0b1/Cython/Compiler/Tests/TestBuiltin.py",
    "line_number": "21",
    "type_description": "obfuscation",
    "original_snippet": "py_type = getattr(builtins, type_name if type_name != 'unicode' else 'str')",
    "context_snippet": "import builtins\nimport sys\nimport unittest\n\nfrom ..Builtin import (\n    inferred_method_return_types, find_return_type_of_builtin_method,\n    unsafe_compile_time_methods, is_safe_compile_time_method,\n    builtin_scope,\n)\n\nfrom ..Code import (\n    KNOWN_PYTHON_BUILTINS_VERSION, KNOWN_PYTHON_BUILTINS,\n)\n\nclass TestBuiltinReturnTypes(unittest.TestCase):\n    def test_find_return_type_of_builtin_method(self):\n        # It's enough to test the method existence in a recent Python that likely has them.\n        look_up_methods = sys.version_info >= (3,10)\n\n        for type_name, methods in inferred_method_return_types.items():\n            py_type = getattr(builtins, type_name if type_name != 'unicode' else 'str')\n\n            for method_name, return_type_name in methods.items():\n                builtin_type = builtin_scope.lookup(type_name).type\n                return_type = find_return_type_of_builtin_method(builtin_type, method_name)\n\n                if return_type.is_builtin_type:\n                    if '[' in return_type_name:\n                        return_type_name = return_type_name.partition('[')[0]\n                    if return_type_name == 'T':\n                        return_type_name = type_name\n                    self.assertEqual(return_type.name, return_type_name)\n                    if look_up_methods:\n                        self.assertTrue(hasattr(py_type, method_name), f\"{type_name}.{method_name}\")\n                else:\n                    self.assertEqual(return_type.empty_declaration_code(pyrex=True), return_type_name)",
    "hash_value": "f5f206a6621a5ee6e0594054650e9d95",
    "detection_index": 1
  }
]