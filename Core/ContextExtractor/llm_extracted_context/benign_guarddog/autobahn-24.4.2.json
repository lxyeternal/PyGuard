[
  {
    "metadata": {
      "package_name": "autobahn-24.4.2",
      "report_path": "/home2/blue/Documents/PyPIAgent/Codes/tool_detect/detect_output/study/guarddog/benign/autobahn-24.4.2.txt",
      "total_matches": 9
    }
  },
  {
    "pyfile": "protocol.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/autobahn-24.4.2/autobahn-24.4.2/autobahn/wamp/protocol.py",
    "line_number": "1140",
    "type_description": "obfuscation",
    "original_snippet": "reply.kwargs,",
    "context_snippet": "def success(res):\n    del self._invocations[msg.request]\n\n    encoded_payload = None\n    if msg.enc_algo:\n        if not self._payload_codec:\n            log_msg = \"trying to send encrypted payload, but no keyring active\"\n            self.log.warn(log_msg)\n        else:\n            try:\n                if isinstance(res, types.CallResult):\n                    encoded_payload = self._payload_codec.encode(False, proc, res.results, res.kwresults)\n                else:\n                    encoded_payload = self._payload_codec.encode(False, proc, [res])\n            except Exception as e:\n                self.log.warn(\n                    \"failed to encrypt application payload: {err}\",\n                    err=e,\n                )\n\n    if encoded_payload:\n        if isinstance(res, types.CallResult):\n            reply = message.Yield(msg.request,\n                                  payload=encoded_payload.payload,\n                                  enc_algo=encoded_payload.enc_algo,\n                                  enc_key=encoded_payload.enc_key,\n                                  enc_serializer=encoded_payload.enc_serializer,\n                                  callee=res.callee,\n                                  callee_authid=res.callee_authid,\n                                  callee_authrole=res.callee_authrole,\n                                  forward_for=res.forward_for)\n        else:\n            reply = message.Yield(msg.request,\n                                  payload=encoded_payload.payload,\n                                  enc_algo=encoded_payload.enc_algo,\n                                  enc_key=encoded_payload.enc_key,\n                                  enc_serializer=encoded_payload.enc_serializer)\n    else:\n        if isinstance(res, types.CallResult):\n            reply = message.Yield(msg.request,\n                                  args=res.results,\n                                  kwargs=res.kwresults,\n                                  callee=res.callee,\n                                  callee_authid=res.callee_authid,\n                                  callee_authrole=res.callee_authrole,\n                                  forward_for=res.forward_for)\n        else:\n            reply = message.Yield(msg.request,\n                                  args=[res])\n\n    if self._transport is None:\n        self.log.debug('Skipping result of \"{}\", request {} because transport disconnected.'.format(registration.procedure, msg.request))\n        return\n\n    try:\n        self._transport.send(reply)\n    except SerializationError as e:\n        # the application-level payload returned from the invoked procedure can't be serialized\n        error_reply = message.Error(message.Invocation.MESSAGE_TYPE, msg.request, ApplicationError.INVALID_PAYLOAD,\n                                    args=['success return value (args={}, kwargs={}) from invoked procedure \"{}\" could not be serialized: {}'.format(reply.args,\n                                                                                                                                                         reply.kwargs,\n                                                                                                                                                         registration.procedure,\n                                                                                                                                                         e)])\n        self._transport.send(error_reply)\n    except PayloadExceededError as e:\n        # the application-level payload returned from the invoked procedure, when serialized and framed\n        # for the transport, exceeds the transport message/frame size limit\n        error_reply = message.Error(message.Invocation.MESSAGE_TYPE, msg.request, ApplicationError.PAYLOAD_SIZE_EXCEEDED,\n                                    args=['success return value (args={}, kwargs={}) from invoked procedure \"{}\" exceeds transport size limit: {}'.format(reply.args,\n                                                                                                                                                                  reply.kwargs,\n                                                                                                                                                                  registration.procedure,\n                                                                                                                                                                  e)])\n        self._transport.send(error_reply)",
    "hash_value": "8c1a8bc37423a87c550a6594e9a33177",
    "detection_index": 1
  }
]