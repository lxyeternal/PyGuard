[
  {
    "metadata": {
      "package_name": "serial-0.0.97",
      "report_path": "/home2/blue/Documents/PyPIAgent/Codes/tool_detect/detect_output/study/guarddog/benign/serial-0.0.97.txt",
      "total_matches": 1
    }
  },
  {
    "pyfile": "__init__.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/serial-0.0.97/serial-0.0.97/serial/utilities/__init__.py",
    "line_number": "179",
    "type_description": "obfuscation",
    "original_snippet": "(getattr(builtins, argument_value_type.__name__) is not argument_value_type)",
    "context_snippet": "def calling_function_qualified_name(depth=1):\n    # type: (int) -> Optional[str]\n    \"\"\"\n    >>> def my_function(): return calling_function_qualified_name()\n    >>> print(my_function())\n    \"\"\"\n\n    if not isinstance(depth, int):\n\n        depth_representation = repr(depth)\n\n        raise TypeError(\n            'The parameter `depth` for `serial.utilities.calling_function_qualified_name` must be an `int`, not' +\n            (\n                (':\\n%s' if '\\n' in depth_representation else ' %s.') %\n                depth_representation\n            )\n        )\n    try:\n        stack = inspect.stack()\n    except IndexError:\n        return None\n\n    if len(stack) < (depth + 1):\n        return None\n\n    name_list = []\n    frame_info = stack[depth]  # type: inspect.FrameInfo\n\n    try:\n        frame_function = frame_info.function\n    except AttributeError:\n        frame_function = frame_info[3]\n\n    if frame_function != '<module>':\n\n        try:\n            frame = frame_info.frame\n        except AttributeError:\n            frame = frame_info[0]\n\n        name_list.append(frame_function)\n        arguments, _, _, frame_locals = inspect.getargvalues(frame)\n\n        if arguments:\n\n            argument = arguments[0]\n            argument_value = frame_locals[argument]\n            argument_value_type = type(argument_value)\n\n            if (\n                hasattr(argument_value_type, '__name__') and\n                hasattr(argument_value_type, '__module__') and\n                (\n                    (argument_value_type.__name__ not in dir(builtins)) or\n                    (getattr(builtins, argument_value_type.__name__) is not argument_value_type)\n                )\n            ):\n                name_list.append(qualified_name(argument_value_type))\n\n    if len(name_list) < 2:\n\n        try:\n            file_name = frame_info.filename\n        except AttributeError:\n            file_name = frame_info[1]\n\n        module_name = inspect.getmodulename(file_name)\n\n        if (module_name is not None) and (module_name not in sys.modules):\n\n            path_parts = list(os.path.split(file_name))\n            path_parts.pop()\n\n            while path_parts:\n\n                parent = path_parts.pop()\n                module_name = parent + '.' + module_name\n\n                if module_name in sys.modules:\n                    break\n\n        if module_name is None:\n            raise ValueError('The path \"%s\" is not a python module' % file_name)\n        else:\n            if module_name in sys.modules:\n                qualified_module_name = qualified_name(sys.modules[module_name])\n                name_list.append(qualified_module_name)\n\n    return '.'.join(reversed(name_list))\n\n# Data dependencies:\n# - 'builtins' is imported at the top: import builtins\n# - 'argument_value_type' is set as type(argument_value) in this function\n# - 'qualified_name' is a helper function defined above\n# - 'inspect' is imported at the top\n# - 'os', 'sys' are imported at the top\n",
    "hash_value": "435c316d7c00213c209be573d29c208d",
    "detection_index": 1
  }
]