[
  {
    "metadata": {
      "package_name": "hypothesis-6.131.0",
      "report_path": "/home2/blue/Documents/PyPIAgent/Codes/tool_detect/detect_output/study/guarddog/benign/hypothesis-6.131.0.txt",
      "total_matches": 4
    }
  },
  {
    "pyfile": "ghostwriter.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/hypothesis-6.131.0/hypothesis-6.131.0/src/hypothesis/extra/ghostwriter.py",
    "line_number": "224",
    "type_description": "obfuscation",
    "original_snippet": "exc_type = getattr(builtins, excname, None)",
    "context_snippet": "def _exceptions_from_docstring(doc: str) -> tuple[type[Exception], ...]:\n    \"\"\"Return a tuple of exceptions that the docstring says may be raised.\n\n    Note that we ignore non-builtin exception types for simplicity, as this is\n    used directly in _write_call() and passing import sets around would be really\n    really annoying.\n    \"\"\"\n    # TODO: it would be great to handle Google- and Numpy-style docstrings\n    #       (e.g. by using the Napoleon Sphinx extension)\n    assert isinstance(doc, str), doc\n    raises = []\n    for excname in re.compile(r\"\\:raises\\s+(\\w+)\\:\", re.MULTILINE).findall(doc):\n        exc_type = getattr(builtins, excname, None)\n        if isinstance(exc_type, type) and issubclass(exc_type, Exception):\n            raises.append(exc_type)\n    return tuple(_dedupe_exceptions(tuple(raises)))",
    "hash_value": "6d6bc3ad98eff25ff287187a852fc2a9",
    "detection_index": 1
  },
  {
    "pyfile": "types.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/hypothesis-6.131.0/hypothesis-6.131.0/src/hypothesis/strategies/_internal/types.py",
    "line_number": "557",
    "type_description": "obfuscation",
    "original_snippet": "return st.from_type(getattr(builtins, thing.__forward_arg__))",
    "context_snippet": "def from_typing_type(thing):\n    # We start with Final, Literal, and Annotated since they don't support `isinstance`.\n    #\n    # We then explicitly error on non-Generic types, which don't carry enough\n    # information to sensibly resolve to strategies at runtime.\n    # Finally, we run a variation of the subclass lookup in `st.from_type`\n    # among generic types in the lookup.\n    if get_origin(thing) == typing.Final:\n        return st.one_of([st.from_type(t) for t in thing.__args__])\n    if is_typing_literal(thing):\n        args_dfs_stack = list(thing.__args__)\n        literals = []\n        while args_dfs_stack:\n            arg = args_dfs_stack.pop()\n            if is_typing_literal(arg):  # pragma: no cover\n                # Python 3.10+ flattens for us when constructing Literal objects\n                args_dfs_stack.extend(reversed(arg.__args__))\n            else:\n                literals.append(arg)\n        return st.sampled_from(literals)\n    if is_annotated_type(thing):\n        return find_annotated_strategy(thing)\n\n    # Some \"generic\" classes are not generic *in* anything - for example both\n    # Hashable and Sized have `__args__ == ()`\n    origin = get_origin(thing) or thing\n    if (\n        origin in vars(collections.abc).values()\n        and len(getattr(thing, \"__args__\", None) or []) == 0\n    ):\n        return st.from_type(origin)\n\n    # Parametrised generic types have their __origin__ attribute set to the\n    # un-parametrised version, which we need to use in the subclass checks.\n    # i.e.:     typing.List[int].__origin__ == list\n    mapping = {\n        k: v\n        for k, v in _global_type_lookup.items()\n        if is_generic_type(k) and try_issubclass(k, thing)\n    }\n\n    # Discard any type which is not it's own origin, where the origin is also in the\n    # mapping.  On old Python versions this could be due to redefinition of types\n    # between collections.abc and typing, but the logic seems reasonable to keep in\n    # case of similar situations now that's been fixed.\n    for t in sorted(mapping, key=type_sorting_key):\n        origin = get_origin(t)\n        if origin is not t and origin in mapping:\n            mapping.pop(t)\n\n    # Drop some unusual cases for simplicity, including tuples or its\n    # subclasses (e.g. namedtuple)\n    if len(mapping) > 1:\n        _Environ = getattr(os, \"_Environ\", None)\n        mapping.pop(_Environ, None)\n    tuple_types = [\n        t\n        for t in mapping\n        if (isinstance(t, type) and issubclass(t, tuple)) or get_origin(t) is tuple\n    ]\n    if len(mapping) > len(tuple_types):\n        for tuple_type in tuple_types:\n            mapping.pop(tuple_type)\n\n    if {dict, set}.intersection(mapping):\n        # ItemsView can cause test_lookup.py::test_specialised_collection_types\n        # to fail, due to weird isinstance behaviour around the elements.\n        mapping.pop(collections.abc.ItemsView, None)\n        mapping.pop(typing.ItemsView, None)\n    if {collections.deque}.intersection(mapping) and len(mapping) > 1:\n        # Resolving generic sequences to include a deque is more trouble for e.g.\n        # the ghostwriter than it's worth, via undefined names in the repr.\n        mapping.pop(collections.deque, None)\n\n    if len(mapping) > 1:\n        # issubclass treats bytestring as a kind of sequence, which it is,\n        # but treating it as such breaks everything else when it is presumed\n        # to be a generic sequence or container that could hold any item.\n        # Except for sequences of integers, or unions which include integer!\n        # See https://github.com/HypothesisWorks/hypothesis/issues/2257\n        #\n        # This block drops bytes from the types that can be generated\n        # if there is more than one allowed type, and the element type is\n        # not either `int` or a Union with `int` as one of its elements.\n        elem_type = (getattr(thing, \"__args__\", None) or [\"not int\"])[0]\n        if is_a_union(elem_type):\n            union_elems = elem_type.__args__\n        else:\n            union_elems = ()\n        if not any(\n            # see https://github.com/HypothesisWorks/hypothesis/issues/4194 for\n            # try_issubclass.\n            isinstance(T, type) and try_issubclass(int, get_origin(T) or T)\n            for T in [*union_elems, elem_type]\n        ):\n            mapping.pop(bytes, None)\n            if sys.version_info[:2] <= (3, 13):\n                mapping.pop(collections.abc.ByteString, None)\n    elif (\n        (not mapping)\n        and isinstance(thing, typing.ForwardRef)\n        and thing.__forward_arg__ in vars(builtins)\n    ):\n        return st.from_type(getattr(builtins, thing.__forward_arg__))\n    # Sort strategies according to our type-sorting heuristic for stable output\n    strategies = [\n        s\n        for s in (\n            v if isinstance(v, st.SearchStrategy) else v(thing)\n            for k, v in sorted(mapping.items(), key=lambda kv: type_sorting_key(kv[0]))\n            if sum(try_issubclass(k, T) for T in mapping) == 1\n        )\n        if s != NotImplemented\n    ]\n    empty = \", \".join(repr(s) for s in strategies if s.is_empty)\n    if empty or not strategies:\n        raise ResolutionFailed(\n            f\"Could not resolve {empty or thing} to a strategy; \"\n            \"consider using register_type_strategy\"\n        )\n    return st.one_of(strategies)\n",
    "hash_value": "6a44c9b436f5af7f0db6d8d088ebcb89",
    "detection_index": 1
  }
]