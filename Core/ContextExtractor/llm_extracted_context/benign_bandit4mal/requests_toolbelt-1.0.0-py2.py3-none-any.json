[
  {
    "metadata": {
      "package_name": "requests_toolbelt-1.0.0-py2.py3-none-any",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "decoder.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/requests_toolbelt-1.0.0-py2.py3-none-any/requests_toolbelt/multipart/decoder.py",
    "line_number": "155",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "154\t        content = response.content\n155\t        content_type = response.headers.get('content-type', None)\n156\t        return cls(content, content_type, encoding)",
    "context_snippet": "class MultipartDecoder(object):\n    \"\"\"\n\n    The ``MultipartDecoder`` object parses the multipart payload of\n    a bytestring into a tuple of ``Response``-like ``BodyPart`` objects.\n\n    The basic usage is::\n\n        import requests\n        from requests_toolbelt import MultipartDecoder\n\n        response = requests.get(url)\n        decoder = MultipartDecoder.from_response(response)\n        for part in decoder.parts:\n            print(part.headers['content-type'])\n\n    If the multipart content is not from a response, basic usage is::\n\n        from requests_toolbelt import MultipartDecoder\n\n        decoder = MultipartDecoder(content, content_type)\n        for part in decoder.parts:\n            print(part.headers['content-type'])\n\n    For both these usages, there is an optional ``encoding`` parameter. This is\n    a string, which is the name of the unicode codec to use (default is\n    ``'utf-8'``).\n\n    \"\"\"\n    def __init__(self, content, content_type, encoding='utf-8'):\n        #: Original Content-Type header\n        self.content_type = content_type\n        #: Response body encoding\n        self.encoding = encoding\n        #: Parsed parts of the multipart response body\n        self.parts = tuple()\n        self._find_boundary()\n        self._parse_body(content)\n\n    def _find_boundary(self):\n        ct_info = tuple(x.strip() for x in self.content_type.split(';'))\n        mimetype = ct_info[0]\n        if mimetype.split('/')[0].lower() != 'multipart':\n            raise NonMultipartContentTypeException(\n                \"Unexpected mimetype in content-type: '{}'\".format(mimetype)\n            )\n        for item in ct_info[1:]:\n            attr, value = _split_on_find(\n                item,\n                '='\n            )\n            if attr.lower() == 'boundary':\n                self.boundary = encode_with(value.strip('\"'), self.encoding)\n\n    @staticmethod\n    def _fix_first_part(part, boundary_marker):\n        bm_len = len(boundary_marker)\n        if boundary_marker == part[:bm_len]:\n            return part[bm_len:]\n        else:\n            return part\n\n    def _parse_body(self, content):\n        boundary = b''.join((b'--', self.boundary))\n\n        def body_part(part):\n            fixed = MultipartDecoder._fix_first_part(part, boundary)\n            return BodyPart(fixed, self.encoding)\n\n        def test_part(part):\n            return (part != b'' and\n                    part != b'\\r\\n' and\n                    part[:4] != b'--\\r\\n' and\n                    part != b'--')\n\n        parts = content.split(b''.join((b'\\r\\n', boundary)))\n        self.parts = tuple(body_part(x) for x in parts if test_part(x))\n\n    @classmethod\n    def from_response(cls, response, encoding='utf-8'):\n        content = response.content\n        content_type = response.headers.get('content-type', None)\n        return cls(content, content_type, encoding)",
    "hash_value": "9d24d6abb7de2655690cadbe907ac054"
  }
]