[
  {
    "metadata": {
      "package_name": "asyncssh-2.20.0",
      "total_matches": 6,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "process.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/asyncssh-2.20.0/asyncssh-2.20.0/asyncssh/process.py",
    "line_number": "202",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "201\t        while not self._paused:\n202\t            data = self._file.read(self._bufsize)\n203",
    "context_snippet": "class _FileReader(_UnicodeReader[AnyStr]):\n    \"\"\"Forward data from a file\"\"\"\n\n    def __init__(self, process: 'SSHProcess[AnyStr]', file: IO[bytes],\n                 bufsize: int, datatype: DataType,\n                 encoding: Optional[str], errors: str):\n        super().__init__(encoding, errors, hasattr(file, 'encoding'))\n\n        self._process: 'SSHProcess[AnyStr]' = process\n        self._file = file\n        self._bufsize = bufsize\n        self._datatype = datatype\n        self._paused = False\n\n    def feed(self) -> None:\n        \"\"\"Feed file data\"\"\"\n\n        while not self._paused:\n            data = self._file.read(self._bufsize)\n\n            if data:\n                self._process.feed_data(self.decode(data), self._datatype)\n            else:\n                self.check_partial()\n                self._process.feed_eof(self._datatype)\n                break\n\n    def pause_reading(self) -> None:\n        \"\"\"Pause reading from the file\"\"\"\n\n        self._paused = True\n\n    def resume_reading(self) -> None:\n        \"\"\"Resume reading from the file\"\"\"\n\n        self._paused = False\n        self.feed()\n\n    def close(self) -> None:\n        \"\"\"Stop forwarding data from the file\"\"\"\n\n        self._file.close()",
    "hash_value": "bc6b9c9ffc0e67d1704b8fa7e41e93d3"
  },
  {
    "pyfile": "test_process.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/asyncssh-2.20.0/asyncssh-2.20.0/tests/test_process.py",
    "line_number": "426",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "425\t        with open('stdin', 'w', encoding='utf-8') as file:\n426\t            file.write(data)\n427",
    "context_snippet": "@asynctest\n    async def test_split_unicode(self):\n        \"\"\"Test Unicode split across blocks\"\"\"\n\n        data = '\\u2000test\\u2000'\n\n        with open('stdin', 'w', encoding='utf-8') as file:\n            file.write(data)\n\n        async with self.connect() as conn:\n            result = await conn.run('echo', stdin='stdin', bufsize=2)\n\n        self.assertEqual(result.stdout, data)",
    "hash_value": "9cb6111ed0b8b4379addd04d3cfc39eb"
  },
  {
    "pyfile": "connection.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/asyncssh-2.20.0/asyncssh-2.20.0/asyncssh/connection.py",
    "line_number": "5843",
    "type_description": "B807:close",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "5842\t        if self._agent_listener:\n5843\t            self._agent_listener.close()\n5844\t            self._agent_listener = None",
    "context_snippet": "def _cleanup(self, exc: Optional[Exception]) -> None:\n    \"\"\"Clean up this server connection\"\"\"\n\n    if self._agent_listener:\n        self._agent_listener.close()\n        self._agent_listener = None\n\n    super()._cleanup(exc)",
    "hash_value": "b9f629b494314d9db91d5c8eb448da96"
  },
  {
    "pyfile": "listener.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/asyncssh-2.20.0/asyncssh-2.20.0/asyncssh/listener.py",
    "line_number": "64",
    "type_description": "B807:close",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "63\t                        _traceback: Optional[TracebackType]) -> bool:\n64\t        self.close()\n65\t        await self.wait_closed()",
    "context_snippet": "    async def __aexit__(self, _exc_type: Optional[Type[BaseException]],\n                        _exc_value: Optional[BaseException],\n                        _traceback: Optional[TracebackType]) -> bool:\n        self.close()\n        await self.wait_closed()\n        return False",
    "hash_value": "e28f393dba0206c0cd861f2f873ae1ee"
  },
  {
    "pyfile": "sftp.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/asyncssh-2.20.0/asyncssh-2.20.0/asyncssh/sftp.py",
    "line_number": "4572",
    "type_description": "B837:rmdir",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "4571\t            try:\n4572\t                await self.rmdir(path)\n4573\t            except SFTPError:",
    "context_snippet": "    async def rmtree(self, path: _SFTPPath, ignore_errors: bool = False,\n                     onerror: _SFTPOnErrorHandler = None) -> None:\n        \"\"\"Recursively delete a directory tree\n\n           This method removes all the files in a directory tree.\n\n           If ignore_errors is set, errors are ignored. Otherwise,\n           if onerror is set, it will be called with arguments of\n           the function which failed, the path it failed on, and\n           exception information returns by :func:`sys.exc_info()`.\n\n           If follow_symlinks is set, files or directories pointed at by\n           symlinks (and their subdirectories, if any) will be removed\n           in addition to the links pointing at them.\n\n           :param path:\n               The path of the parent directory to remove\n           :param ignore_errors: (optional)\n               Whether or not to ignore errors during the remove\n           :param onerror: (optional)\n               A function to call when errors occur\n           :type path: :class:`PurePath <pathlib.PurePath>`, `str`, or `bytes`\n           :type ignore_errors: `bool`\n           :type onerror: `callable`\n\n           :raises: :exc:`SFTPError` if the server returns an error\n\n        \"\"\"\n\n        async def _unlink(path: bytes) -> None:\n            \"\"\"Internal helper for unlinking non-directories\"\"\"\n\n            assert onerror is not None\n\n            try:\n                await self.unlink(path)\n            except SFTPError:\n                onerror(self.unlink, path, sys.exc_info())\n\n        async def _rmtree(path: bytes) -> None:\n            \"\"\"Internal helper for rmtree recursion\"\"\"\n\n            assert onerror is not None\n\n            tasks = []\n\n            try:\n                async with sem:\n                    async for entry in self.scandir(path):\n                        filename = cast(bytes, entry.filename)\n\n                        if filename in (b'.', b'..'):\n                            continue\n\n                        filename = posixpath.join(path, filename)\n\n                        if entry.attrs.type == FILEXFER_TYPE_DIRECTORY:\n                            task = _rmtree(filename)\n                        else:\n                            task = _unlink(filename)\n\n                        tasks.append(asyncio.ensure_future(task))\n            except SFTPError:\n                onerror(self.scandir, path, sys.exc_info())\n\n            results = await asyncio.gather(*tasks, return_exceptions=True)\n            exc = next((result for result in results\n                        if isinstance(result, Exception)), None)\n\n            if exc:\n                raise exc\n\n            try:\n                await self.rmdir(path)\n            except SFTPError:\n                onerror(self.rmdir, path, sys.exc_info())\n\n        # pylint: disable=function-redefined\n        if ignore_errors:\n            def onerror(*_args: object) -> None:\n                pass\n        elif onerror is None:\n            def onerror(*_args: object) -> None:\n                raise # pylint: disable=misplaced-bare-raise\n        # pylint: enable=function-redefined\n\n        assert onerror is not None\n\n        path = self.encode(path)\n        sem = asyncio.Semaphore(_MAX_SFTP_REQUESTS)\n\n        try:\n            if await self.islink(path):\n                raise SFTPNoSuchFile(path.decode('utf-8', 'backslashreplace') +\n                                     ' must not be a symlink')\n        except SFTPError:\n            onerror(self.islink, path, sys.exc_info())\n            return\n\n        await _rmtree(path)\n",
    "hash_value": "f47021bae4909a4c2384060a10b27b63"
  },
  {
    "pyfile": "config.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/asyncssh-2.20.0/asyncssh-2.20.0/asyncssh/config.py",
    "line_number": "565",
    "type_description": "B803:gethostname",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "564\n565\t        local_host = socket.gethostname()\n566",
    "context_snippet": "def _set_tokens(self) -> None:\n    \"\"\"Set the tokens available for percent expansion\"\"\"\n\n    local_host = socket.gethostname()\n\n    idx = local_host.find('.')\n    short_local_host = local_host if idx < 0 else local_host[:idx]\n\n    host = cast(str, self._options.get('Hostname', self._orig_host))\n    port = str(self._options.get('Port', DEFAULT_PORT))\n    user = cast(str, self._options.get('User') or self._local_user)\n    home = os.path.expanduser('~')\n\n    conn_info = ''.join((local_host, host, port, user))\n    conn_hash = sha1(conn_info.encode('utf-8')).hexdigest()\n\n    self._tokens.update({'C': conn_hash,\n                         'h': host,\n                         'L': short_local_host,\n                         'l': local_host,\n                         'n': self._orig_host,\n                         'p': port,\n                         'r': user,\n                         'u': self._local_user})\n\n    if home != '~':\n        self._tokens['d'] = home\n\n    if hasattr(os, 'getuid'):\n        self._tokens['i'] = str(os.getuid())",
    "hash_value": "2a02e474860a9dda5d253c1f7f883ecb"
  }
]