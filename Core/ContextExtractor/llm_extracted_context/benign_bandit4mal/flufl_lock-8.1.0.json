[
  {
    "metadata": {
      "package_name": "flufl_lock-8.1.0",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:40"
    }
  },
  {
    "pyfile": "test_lock.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/flufl_lock-8.1.0/flufl_lock-8.1.0/test/test_lock.py",
    "line_number": "321",
    "type_description": "B838:process",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "320\t    queue = Queue()\n321\t    Process(target=child_locker, args=(lock.lockfile, queue)).start()\n322\t    # Wait for the child process to acquire the lock.",
    "context_snippet": "def test_lock_with_explicit_timeout(lock):\n    queue = Queue()\n    Process(target=child_locker, args=(lock.lockfile, queue)).start()\n    # Wait for the child process to acquire the lock.\n    queue.get()\n    with pytest.raises(TimeOutError):\n        lock.lock(timeout=1)\n\ndef child_locker(filename, queue, *, sleep=3, lifetime=15, keep=False):\n    with suppress(NotLockedError):\n        with Lock(filename, lifetime=lifetime):\n            queue.put(True)\n            time.sleep(sleep)\n            queue.put(True)\n            # The test wants us to keep the lock a little bit longer.\n            if keep:\n                queue.get()\n\nfrom multiprocessing import Process, Queue\nfrom flufl.lock import Lock, NotLockedError, TimeOutError\nfrom contextlib import suppress",
    "hash_value": "f43296a5a93b2ea9e33b81bff61a1870"
  }
]