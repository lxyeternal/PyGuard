[
  {
    "metadata": {
      "package_name": "jina-3.34.0",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:40"
    }
  },
  {
    "pyfile": "asyncio.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/jina-3.34.0/jina-3.34.0/jina/serve/runtimes/asyncio.py",
    "line_number": "215",
    "type_description": "B827:httpserver",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "214\n215\t            return AzureHTTPServer(\n216\t                name=self.args.name,\n217\t                runtime_args=self.args,\n218\t                req_handler_cls=self.req_handler_cls,\n219\t                proxy=getattr(self.args, 'proxy', None),\n220\t                uvicorn_kwargs=getattr(self.args, 'uvicorn_kwargs', None),\n221\t                ssl_keyfile=getattr(self.args, 'ssl_keyfile', None),\n222\t                ssl_certfile=getattr(self.args, 'ssl_certfile', None),\n223\t                cors=getattr(self.args, 'cors', None),\n224\t                is_cancel=self.is_cancel,\n225\t            )",
    "context_snippet": "def _get_server(self):\n    # construct server type based on protocol (and potentially req handler class to keep backwards compatibility)\n    from jina.enums import ProtocolType, ProviderType\n\n    if self.req_handler_cls.__name__ == 'GatewayRequestHandler':\n        self.timeout_send = self.args.timeout_send\n        if self.timeout_send:\n            self.timeout_send /= 1e3  # convert ms to seconds\n        if not self.args.port:\n            self.args.port = random_ports(len(self.args.protocol))\n        _set_gateway_uses(\n            self.args, gateway_load_balancer=self.gateway_load_balancer\n        )\n        uses_with = self.args.uses_with or {}\n        non_defaults = ArgNamespace.get_non_defaults_args(\n            self.args, set_gateway_parser()\n        )\n        if 'title' not in non_defaults:\n            uses_with['title'] = self.args.title\n        if 'description' not in non_defaults:\n            uses_with['description'] = self.args.description\n        if 'no_debug_endpoints' not in non_defaults:\n            uses_with['no_debug_endpoints'] = self.args.no_debug_endpoints\n        if 'no_crud_endpoints' not in non_defaults:\n            uses_with['no_crud_endpoints'] = self.args.no_crud_endpoints\n        if 'expose_endpoints' not in non_defaults:\n            uses_with['expose_endpoints'] = self.args.expose_endpoints\n        if 'expose_graphql_endpoint' not in non_defaults:\n            uses_with['expose_graphql_endpoint'] = self.args.expose_graphql_endpoint\n        if 'cors' not in non_defaults:\n            uses_with['cors'] = self.args.cors\n        server = BaseGateway.load_config(\n            self.args.uses,\n            uses_with=dict(\n                **non_defaults,\n                **uses_with,\n            ),\n            uses_metas={},\n            runtime_args={  # these are not parsed to the yaml config file but are pass directly during init\n                **vars(self.args),\n                'default_port': getattr(self.args, 'default_port', False),\n                'gateway_load_balancer': self.gateway_load_balancer,\n                'timeout_send': self.timeout_send,\n            },\n            py_modules=self.args.py_modules,\n            extra_search_paths=self.args.extra_search_paths,\n        )\n        if isinstance(server, BaseServer):\n            server.is_cancel = self.is_cancel\n        return server\n    elif (\n        hasattr(self.args, 'provider')\n        and self.args.provider == ProviderType.SAGEMAKER\n    ):\n        from jina.serve.runtimes.servers.http import SagemakerHTTPServer\n\n        return SagemakerHTTPServer(\n            name=self.args.name,\n            runtime_args=self.args,\n            req_handler_cls=self.req_handler_cls,\n            proxy=getattr(self.args, 'proxy', None),\n            uvicorn_kwargs=getattr(self.args, 'uvicorn_kwargs', None),\n            ssl_keyfile=getattr(self.args, 'ssl_keyfile', None),\n            ssl_certfile=getattr(self.args, 'ssl_certfile', None),\n            cors=getattr(self.args, 'cors', None),\n            is_cancel=self.is_cancel,\n        )\n    elif (\n        hasattr(self.args, 'provider')\n        and self.args.provider == ProviderType.AZURE\n    ):\n        from jina.serve.runtimes.servers.http import AzureHTTPServer\n\n        return AzureHTTPServer(\n            name=self.args.name,\n            runtime_args=self.args,\n            req_handler_cls=self.req_handler_cls,\n            proxy=getattr(self.args, 'proxy', None),\n            uvicorn_kwargs=getattr(self.args, 'uvicorn_kwargs', None),\n            ssl_keyfile=getattr(self.args, 'ssl_keyfile', None),\n            ssl_certfile=getattr(self.args, 'ssl_certfile', None),\n            cors=getattr(self.args, 'cors', None),\n            is_cancel=self.is_cancel,\n        )\n    elif not hasattr(self.args, 'protocol') or (\n        len(self.args.protocol) == 1 and self.args.protocol[0] == ProtocolType.GRPC\n    ):\n        from jina.serve.runtimes.servers.grpc import GRPCServer\n\n        return GRPCServer(\n            name=self.args.name,\n            runtime_args=self.args,\n            req_handler_cls=self.req_handler_cls,\n            grpc_server_options=self.args.grpc_server_options,\n            ssl_keyfile=getattr(self.args, 'ssl_keyfile', None),\n            ssl_certfile=getattr(self.args, 'ssl_certfile', None),\n            proxy=getattr(self.args, 'proxy', None),\n        )\n\n    elif (\n        len(self.args.protocol) == 1 and self.args.protocol[0] == ProtocolType.HTTP\n    ):\n        from jina.serve.runtimes.servers.http import (\n            HTTPServer,  # we need a concrete implementation of this\n        )\n\n        return HTTPServer(\n            name=self.args.name,\n            runtime_args=self.args,\n            req_handler_cls=self.req_handler_cls,\n            proxy=getattr(self.args, 'proxy', None),\n            uvicorn_kwargs=getattr(self.args, 'uvicorn_kwargs', None),\n            ssl_keyfile=getattr(self.args, 'ssl_keyfile', None),\n            ssl_certfile=getattr(self.args, 'ssl_certfile', None),\n            cors=getattr(self.args, 'cors', None),\n            is_cancel=self.is_cancel,\n        )\n    elif (\n        len(self.args.protocol) == 1\n        and self.args.protocol[0] == ProtocolType.WEBSOCKET\n    ):\n        from jina.serve.runtimes.servers.websocket import (\n            WebSocketServer,  # we need a concrete implementation of this\n        )\n\n        return WebSocketServer(\n            name=self.args.name,\n            runtime_args=self.args,\n            req_handler_cls=self.req_handler_cls,\n            proxy=getattr(self.args, 'proxy', None),\n            uvicorn_kwargs=getattr(self.args, 'uvicorn_kwargs', None),\n            ssl_keyfile=getattr(self.args, 'ssl_keyfile', None),\n            ssl_certfile=getattr(self.args, 'ssl_certfile', None),\n            is_cancel=self.is_cancel,\n        )\n    elif len(self.args.protocol) > 1:\n        from jina.serve.runtimes.servers.composite import (\n            CompositeServer,  # we need a concrete implementation of this\n        )\n\n        return CompositeServer(\n            name=self.args.name,\n            runtime_args=self.args,\n            req_handler_cls=self.req_handler_cls,\n            ssl_keyfile=getattr(self.args, 'ssl_keyfile', None),\n            ssl_certfile=getattr(self.args, 'ssl_certfile', None),\n            is_cancel=self.is_cancel,\n        )",
    "hash_value": "9801a054435a91dd2e1bd035c67eb81c"
  }
]