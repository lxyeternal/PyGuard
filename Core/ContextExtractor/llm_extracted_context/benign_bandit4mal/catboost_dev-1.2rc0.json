[
  {
    "metadata": {
      "package_name": "catboost_dev-1.2rc0",
      "total_matches": 11,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "stata.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/catboost_dev-1.2rc0/catboost_dev-1.2rc0/catboost_all_src/contrib/python/pandas/py3/pandas/io/stata.py",
    "line_number": "1334",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1333\n1334\t        return [self._decode(self.path_or_buf.read(b)) for _ in range(self.nvar)]\n1335",
    "context_snippet": "def _get_varlist(self) -> list[str]:\n    # 33 in order formats, 129 in formats 118 and 119\n    b = 33 if self.format_version < 118 else 129\n    return [self._decode(self.path_or_buf.read(b)) for _ in range(self.nvar)]",
    "hash_value": "5adce8ee966b0996880e21c2e6f7a900"
  },
  {
    "pyfile": "test_io.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/catboost_dev-1.2rc0/catboost_dev-1.2rc0/catboost_all_src/contrib/python/numpy/py3/numpy/lib/tests/test_io.py",
    "line_number": "259",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "258\t        errors = []\n259\t        threads = [threading.Thread(target=writer, args=(errors,))\n260\t                   for j in range(3)]",
    "context_snippet": "def test_savez_filename_clashes(self):\n    # Test that issue #852 is fixed\n    # and savez functions in multithreaded environment\n\n    def writer(error_list):\n        with temppath(suffix='.npz') as tmp:\n            arr = np.random.randn(500, 500)\n            try:\n                np.savez(tmp, arr=arr)\n            except OSError as err:\n                error_list.append(err)\n\n    errors = []\n    threads = [threading.Thread(target=writer, args=(errors,))\n               for j in range(3)]\n    for t in threads:\n        t.start()\n    for t in threads:\n        t.join()\n\n    if errors:\n        raise AssertionError(errors)",
    "hash_value": "1cd085a1c7b7f7b0e8ec90ab991f500d"
  },
  {
    "pyfile": "stata.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/catboost_dev-1.2rc0/catboost_dev-1.2rc0/catboost_all_src/contrib/python/pandas/py3/pandas/io/stata.py",
    "line_number": "1254",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1253\n1254\t        self.path_or_buf.read(8)  # <characteristics>\n1255\t        self.data_location = (",
    "context_snippet": "def _read_new_header(self) -> None:\n    # The first part of the header is common to 117 - 119.\n    self.path_or_buf.read(27)  # stata_dta><header><release>\n    self.format_version = int(self.path_or_buf.read(3))\n    if self.format_version not in [117, 118, 119]:\n        raise ValueError(_version_error.format(version=self.format_version))\n    self._set_encoding()\n    self.path_or_buf.read(21)  # </release><byteorder>\n    self.byteorder = self.path_or_buf.read(3) == b\"MSF\" and \">\" or \"<\"\n    self.path_or_buf.read(15)  # </byteorder><K>\n    nvar_type = \"H\" if self.format_version <= 118 else \"I\"\n    nvar_size = 2 if self.format_version <= 118 else 4\n    self.nvar = struct.unpack(\n        self.byteorder + nvar_type, self.path_or_buf.read(nvar_size)\n    )[0]\n    self.path_or_buf.read(7)  # </K><N>\n\n    self.nobs = self._get_nobs()\n    self.path_or_buf.read(11)  # </N><label>\n    self._data_label = self._get_data_label()\n    self.path_or_buf.read(19)  # </label><timestamp>\n    self.time_stamp = self._get_time_stamp()\n    self.path_or_buf.read(26)  # </timestamp></header><map>\n    self.path_or_buf.read(8)  # 0x0000000000000000\n    self.path_or_buf.read(8)  # position of <map>\n\n    self._seek_vartypes = (\n        struct.unpack(self.byteorder + \"q\", self.path_or_buf.read(8))[0] + 16\n    )\n    self._seek_varnames = (\n        struct.unpack(self.byteorder + \"q\", self.path_or_buf.read(8))[0] + 10\n    )\n    self._seek_sortlist = (\n        struct.unpack(self.byteorder + \"q\", self.path_or_buf.read(8))[0] + 10\n    )\n    self._seek_formats = (\n        struct.unpack(self.byteorder + \"q\", self.path_or_buf.read(8))[0] + 9\n    )\n    self._seek_value_label_names = (\n        struct.unpack(self.byteorder + \"q\", self.path_or_buf.read(8))[0] + 19\n    )\n\n    # Requires version-specific treatment\n    self._seek_variable_labels = self._get_seek_variable_labels()\n\n    self.path_or_buf.read(8)  # <characteristics>\n    self.data_location = (\n        struct.unpack(self.byteorder + \"q\", self.path_or_buf.read(8))[0] + 6\n    )\n    self.seek_strls = (\n        struct.unpack(self.byteorder + \"q\", self.path_or_buf.read(8))[0] + 7\n    )\n    self.seek_value_labels = (\n        struct.unpack(self.byteorder + \"q\", self.path_or_buf.read(8))[0] + 14\n    )\n\n    self.typlist, self.dtyplist = self._get_dtypes(self._seek_vartypes)\n\n    self.path_or_buf.seek(self._seek_varnames)\n    self.varlist = self._get_varlist()\n\n    self.path_or_buf.seek(self._seek_sortlist)\n    self.srtlist = struct.unpack(\n        self.byteorder + (\"h\" * (self.nvar + 1)),\n        self.path_or_buf.read(2 * (self.nvar + 1)),\n    )[:-1]\n\n    self.path_or_buf.seek(self._seek_formats)\n    self.fmtlist = self._get_fmtlist()\n\n    self.path_or_buf.seek(self._seek_value_label_names)\n    self.lbllist = self._get_lbllist()\n\n    self.path_or_buf.seek(self._seek_variable_labels)\n    self._variable_labels = self._get_variable_labels()",
    "hash_value": "5a57be1024dcb8b1b4a036559eabc3a2"
  },
  {
    "pyfile": "script.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/catboost_dev-1.2rc0/catboost_dev-1.2rc0/catboost_all_src/contrib/python/ipython/py2/IPython/core/magics/script.py",
    "line_number": "237",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "236\t        \"\"\"callback for running the script in the background\"\"\"\n237\t        p.stdin.write(cell)\n238\t        p.stdin.close()",
    "context_snippet": "def _run_script(self, p, cell):\n    \"\"\"callback for running the script in the background\"\"\"\n    p.stdin.write(cell)\n    p.stdin.close()\n    p.wait()",
    "hash_value": "f4eb3ddd0c1bec75b4d452e43b814f61"
  },
  {
    "pyfile": "forkedfunc.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/catboost_dev-1.2rc0/catboost_dev-1.2rc0/catboost_all_src/contrib/python/py/py/_process/forkedfunc.py",
    "line_number": "20",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "19\t        def write(self, data):\n20\t            f.write(data)\n21\t            f.flush()",
    "context_snippet": "def get_unbuffered_io(fd, filename):\n    f = open(str(filename), \"w\")\n    if fd != f.fileno():\n        os.dup2(f.fileno(), fd)\n    class AutoFlush:\n        def write(self, data):\n            f.write(data)\n            f.flush()\n        def __getattr__(self, name):\n            return getattr(f, name)\n    return AutoFlush()",
    "hash_value": "5668c03e07a900bde7c5831fa1f03153"
  },
  {
    "pyfile": "libpython.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/catboost_dev-1.2rc0/catboost_dev-1.2rc0/catboost_all_src/contrib/tools/cython/Cython/Debugger/libpython.py",
    "line_number": "1666",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1665\t            else:\n1666\t                sys.stdout.write('#%i\\n' % self.get_index())\n1667",
    "context_snippet": "def print_summary(self):\n    if self.is_evalframe():\n        pyop = self.get_pyop()\n        if pyop:\n            line = pyop.get_truncated_repr(MAX_OUTPUT_LEN)\n            write_unicode(sys.stdout, '#%i %s\\n' % (self.get_index(), line))\n            if not pyop.is_optimized_out():\n                line = pyop.current_line()\n                if line is not None:\n                    sys.stdout.write('    %s\\n' % line.strip())\n        else:\n            sys.stdout.write('#%i (unable to read python frame information)\\n' % self.get_index())\n    else:\n        info = self.is_other_python_frame()\n        if info:\n            sys.stdout.write('#%i %s\\n' % (self.get_index(), info))\n        else:\n            sys.stdout.write('#%i\\n' % self.get_index())",
    "hash_value": "7871e7c9c30d67951d9c67adfff4b0d7"
  },
  {
    "pyfile": "stata.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/catboost_dev-1.2rc0/catboost_dev-1.2rc0/catboost_all_src/contrib/python/pandas/py2/pandas/io/stata.py",
    "line_number": "706",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "705\t        for offset in self.off:\n706\t            bio.write(struct.pack(byteorder + 'i', offset))\n707",
    "context_snippet": "def generate_value_label(self, byteorder, encoding):\n    \"\"\"\n    Parameters\n    ----------\n    byteorder : str\n        Byte order of the output\n    encoding : str\n        File encoding\n\n    Returns\n    -------\n    value_label : bytes\n        Bytes containing the formatted value label\n    \"\"\"\n\n    self._encoding = encoding\n    bio = BytesIO()\n    null_string = '\\x00'\n    null_byte = b'\\x00'\n\n    # len\n    bio.write(struct.pack(byteorder + 'i', self.len))\n\n    # labname\n    labname = self._encode(_pad_bytes(self.labname[:32], 33))\n    bio.write(labname)\n\n    # padding - 3 bytes\n    for i in range(3):\n        bio.write(struct.pack('c', null_byte))\n\n    # value_label_table\n    # n - int32\n    bio.write(struct.pack(byteorder + 'i', self.n))\n\n    # textlen  - int32\n    bio.write(struct.pack(byteorder + 'i', self.text_len))\n\n    # off - int32 array (n elements)\n    for offset in self.off:\n        bio.write(struct.pack(byteorder + 'i', offset))\n\n    # val - int32 array (n elements)\n    for value in self.val:\n        bio.write(struct.pack(byteorder + 'i', value))\n\n    # txt - Text labels, null terminated\n    for text in self.txt:\n        bio.write(self._encode(text + null_string))\n\n    bio.seek(0)\n    return bio.read()",
    "hash_value": "3eea40dc30df729db8a1f91bbc1e907d"
  },
  {
    "pyfile": "misc_util.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/catboost_dev-1.2rc0/catboost_dev-1.2rc0/catboost_all_src/contrib/python/numpy/py2/numpy/distutils/misc_util.py",
    "line_number": "2039",
    "type_description": "B832:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "2038\t                    f = open(target, 'w')\n2039\t                    f.write('version = %r\\n' % (version))\n2040\t                    f.close()",
    "context_snippet": "def make_svn_version_py(self, delete=True):\n    \"\"\"Appends a data function to the data_files list that will generate\n    __svn_version__.py file to the current package directory.\n\n    Generate package __svn_version__.py file from SVN revision number,\n    it will be removed after python exits but will be available\n    when sdist, etc commands are executed.\n\n    Notes\n    -----\n    If __svn_version__.py existed before, nothing is done.\n\n    This is\n    intended for working with source directories that are in an SVN\n    repository.\n    \"\"\"\n    target = njoin(self.local_path, '__svn_version__.py')\n    revision = self._get_svn_revision(self.local_path)\n    if os.path.isfile(target) or revision is None:\n        return\n    else:\n        def generate_svn_version_py():\n            if not os.path.isfile(target):\n                version = str(revision)\n                self.info('Creating %s (version=%r)' % (target, version))\n                f = open(target, 'w')\n                f.write('version = %r\\n' % (version))\n                f.close()\n\n            def rm_file(f=target,p=self.info):\n                if delete:\n                    try: os.remove(f); p('removed '+f)\n                    except OSError: pass\n                    try: os.remove(f+'c'); p('removed '+f+'c')\n                    except OSError: pass\n\n            atexit.register(rm_file)\n\n            return target\n\n        self.add_data_files(('', generate_svn_version_py()))",
    "hash_value": "4e77a2e1b2caf76987ed9a264851ee51"
  },
  {
    "pyfile": "TestCyCache.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/catboost_dev-1.2rc0/catboost_dev-1.2rc0/catboost_all_src/contrib/tools/cython/Cython/Build/Tests/TestCyCache.py",
    "line_number": "66",
    "type_description": "B832:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "65\t        a_cache = os.path.join(self.cache_dir, os.listdir(self.cache_dir)[0])\n66\t        gzip.GzipFile(a_cache, 'wb').write('fake stuff'.encode('ascii'))\n67\t        os.unlink(a_c)",
    "context_snippet": "def test_cycache_uses_cache(self):\n    a_pyx = os.path.join(self.src_dir, 'a.pyx')\n    a_c = a_pyx[:-4] + '.c'\n    open(a_pyx, 'w').write('pass')\n    self.fresh_cythonize(a_pyx, cache=self.cache_dir)\n    a_cache = os.path.join(self.cache_dir, os.listdir(self.cache_dir)[0])\n    gzip.GzipFile(a_cache, 'wb').write('fake stuff'.encode('ascii'))\n    os.unlink(a_c)\n    self.fresh_cythonize(a_pyx, cache=self.cache_dir)\n    a_contents = open(a_c).read()\n    self.assertEqual(a_contents, 'fake stuff',\n                     'Unexpected contents: %s...' % a_contents[:100])",
    "hash_value": "297d85ceea07cdf262424b12274a55dc"
  },
  {
    "pyfile": "ssltransport.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/catboost_dev-1.2rc0/catboost_dev-1.2rc0/catboost_all_src/contrib/python/urllib3/urllib3/util/ssltransport.py",
    "line_number": "73",
    "type_description": "B830:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "72\t    def read(self, len=1024, buffer=None):\n73\t        return self._wrap_ssl_read(len, buffer)\n74",
    "context_snippet": "def read(self, len=1024, buffer=None):\n    return self._wrap_ssl_read(len, buffer)\n\ndef _wrap_ssl_read(self, len, buffer=None):\n    try:\n        return self._ssl_io_loop(self.sslobj.read, len, buffer)\n    except ssl.SSLError as e:\n        if e.errno == ssl.SSL_ERROR_EOF and self.suppress_ragged_eofs:\n            return 0  # eof, return 0.\n        else:\n            raise\n\ndef _ssl_io_loop(self, func, *args):\n    \"\"\"Performs an I/O loop between incoming/outgoing and the socket.\"\"\"\n    should_loop = True\n    ret = None\n\n    while should_loop:\n        errno = None\n        try:\n            ret = func(*args)\n        except ssl.SSLError as e:\n            if e.errno not in (ssl.SSL_ERROR_WANT_READ, ssl.SSL_ERROR_WANT_WRITE):\n                # WANT_READ, and WANT_WRITE are expected, others are not.\n                raise e\n            errno = e.errno\n\n        buf = self.outgoing.read()\n        self.socket.sendall(buf)\n\n        if errno is None:\n            should_loop = False\n        elif errno == ssl.SSL_ERROR_WANT_READ:\n            buf = self.socket.recv(SSL_BLOCKSIZE)\n            if buf:\n                self.incoming.write(buf)\n            else:\n                self.incoming.write_eof()\n    return ret",
    "hash_value": "079d26f62802e816edd4b85ac495e57c"
  },
  {
    "pyfile": "bccache.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/catboost_dev-1.2rc0/catboost_dev-1.2rc0/catboost_all_src/contrib/python/Jinja2/py3/jinja2/bccache.py",
    "line_number": "251",
    "type_description": "B811:getuid",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "250\t        if (\n251\t            actual_dir_stat.st_uid != os.getuid()\n252\t            or not stat.S_ISDIR(actual_dir_stat.st_mode)",
    "context_snippet": "def _get_default_cache_dir(self) -> str:\n    def _unsafe_dir() -> \"te.NoReturn\":\n        raise RuntimeError(\n            \"Cannot determine safe temp directory.  You \"\n            \"need to explicitly provide one.\"\n        )\n\n    tmpdir = tempfile.gettempdir()\n\n    # On windows the temporary directory is used specific unless\n    # explicitly forced otherwise.  We can just use that.\n    if os.name == \"nt\":\n        return tmpdir\n    if not hasattr(os, \"getuid\"):\n        _unsafe_dir()\n\n    dirname = f\"_jinja2-cache-{os.getuid()}\"\n    actual_dir = os.path.join(tmpdir, dirname)\n\n    try:\n        os.mkdir(actual_dir, stat.S_IRWXU)\n    except OSError as e:\n        if e.errno != errno.EEXIST:\n            raise\n    try:\n        os.chmod(actual_dir, stat.S_IRWXU)\n        actual_dir_stat = os.lstat(actual_dir)\n        if (\n            actual_dir_stat.st_uid != os.getuid()\n            or not stat.S_ISDIR(actual_dir_stat.st_mode)\n            or stat.S_IMODE(actual_dir_stat.st_mode) != stat.S_IRWXU\n        ):\n            _unsafe_dir()\n    except OSError as e:\n        if e.errno != errno.EEXIST:\n            raise\n\n    actual_dir_stat = os.lstat(actual_dir)\n    if (\n        actual_dir_stat.st_uid != os.getuid()\n        or not stat.S_ISDIR(actual_dir_stat.st_mode)\n        or stat.S_IMODE(actual_dir_stat.st_mode) != stat.S_IRWXU\n    ):\n        _unsafe_dir()\n\n    return actual_dir",
    "hash_value": "21fdf1180444c3af7b80000605abba97"
  }
]