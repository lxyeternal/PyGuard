[
  {
    "metadata": {
      "package_name": "aiohttp-4.0.0a1",
      "total_matches": 4,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "test_helpers.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/aiohttp-4.0.0a1/aiohttp-4.0.0a1/tests/test_helpers.py",
    "line_number": "127",
    "type_description": "B802:b64encode",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "126\t    with pytest.raises(ValueError, match='Invalid credentials.'):\n127\t        header = 'Basic {}'.format(base64.b64encode(b'username').decode())\n128\t        helpers.BasicAuth.decode(header)",
    "context_snippet": "def test_basic_auth_decode_invalid_credentials() -> None:\n    with pytest.raises(ValueError, match='Invalid credentials.'):\n        header = 'Basic {}'.format(base64.b64encode(b'username').decode())\n        helpers.BasicAuth.decode(header)",
    "hash_value": "8698e949db0837bdd6ae66bfca657395"
  },
  {
    "pyfile": "srv.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/aiohttp-4.0.0a1/aiohttp-4.0.0a1/examples/legacy/srv.py",
    "line_number": "92",
    "type_description": "B830:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "91\t                        response.write(chunk)\n92\t                        chunk = fp.read(8192)\n93\t            except OSError:",
    "context_snippet": "class HttpRequestHandler(aiohttp.server.ServerHttpProtocol):\n\n    async def handle_request(self, message, payload):\n        print('method = {!r}; path = {!r}; version = {!r}'.format(\n            message.method, message.path, message.version))\n\n        path = message.path\n\n        if (not (path.isprintable() and path.startswith('/')) or '/.' in path):\n            print('bad path', repr(path))\n            path = None\n        else:\n            path = '.' + path\n            if not os.path.exists(path):\n                print('no file', repr(path))\n                path = None\n            else:\n                isdir = os.path.isdir(path)\n\n        if not path:\n            raise aiohttp.HttpProcessingError(code=404)\n\n        for hdr, val in message.headers.items():\n            print(hdr, val)\n\n        if isdir and not path.endswith('/'):\n            path = path + '/'\n            raise aiohttp.HttpProcessingError(\n                code=302, headers=(('URI', path), ('Location', path)))\n\n        response = aiohttp.Response(\n            self.writer, 200, http_version=message.version)\n        response.add_header('Transfer-Encoding', 'chunked')\n\n        # content encoding\n        accept_encoding = message.headers.get('accept-encoding', '').lower()\n        if 'deflate' in accept_encoding:\n            response.add_header('Content-Encoding', 'deflate')\n            response.add_compression_filter('deflate')\n        elif 'gzip' in accept_encoding:\n            response.add_header('Content-Encoding', 'gzip')\n            response.add_compression_filter('gzip')\n\n        response.add_chunking_filter(1025)\n\n        if isdir:\n            response.add_header('Content-type', 'text/html')\n            response.send_headers()\n\n            response.write(b'<ul>\\r\\n')\n            for name in sorted(os.listdir(path)):\n                if name.isprintable() and not name.startswith('.'):\n                    try:\n                        bname = name.encode('ascii')\n                    except UnicodeError:\n                        pass\n                    else:\n                        if os.path.isdir(os.path.join(path, name)):\n                            response.write(b'<li><a href=\"' + bname +\n                                           b'/\">' + bname + b'/</a></li>\\r\\n')\n                        else:\n                            response.write(b'<li><a href=\"' + bname +\n                                           b'\">' + bname + b'</a></li>\\r\\n')\n            response.write(b'</ul>')\n        else:\n            response.add_header('Content-type', 'text/plain')\n            response.send_headers()\n\n            try:\n                with open(path, 'rb') as fp:\n                    chunk = fp.read(8192)\n                    while chunk:\n                        response.write(chunk)\n                        chunk = fp.read(8192)\n            except OSError:\n                response.write(b'Cannot open')\n\n        await response.write_eof()\n        if response.keep_alive():\n            self.keep_alive(True)",
    "hash_value": "8719e97789d708603c8191cecd6b8bd2"
  },
  {
    "pyfile": "test_proxy.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/aiohttp-4.0.0a1/aiohttp-4.0.0a1/tests/test_proxy.py",
    "line_number": "513",
    "type_description": "B807:close",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "512\t        self.loop.run_until_complete(proxy_req.close())\n513\t        proxy_resp.close()\n514\t        self.loop.run_until_complete(req.close())",
    "context_snippet": "@mock.patch('aiohttp.connector.ClientRequest')\ndef test_https_connect(self, ClientRequestMock) -> None:\n    proxy_req = ClientRequest('GET', URL('http://proxy.example.com'),\n                              loop=self.loop)\n    ClientRequestMock.return_value = proxy_req\n\n    proxy_resp = ClientResponse('get', URL('http://proxy.example.com'),\n                                request_info=mock.Mock(),\n                                writer=mock.Mock(),\n                                continue100=None,\n                                timer=TimerNoop(),\n                                traces=[],\n                                loop=self.loop,\n                                session=mock.Mock())\n    proxy_req.send = make_mocked_coro(proxy_resp)\n    proxy_resp.start = make_mocked_coro(mock.Mock(status=200))\n\n    async def make_conn():\n        return aiohttp.TCPConnector()\n    connector = self.loop.run_until_complete(make_conn())\n    connector._resolve_host = make_mocked_coro(\n        [{'hostname': 'hostname', 'host': '127.0.0.1', 'port': 80,\n          'family': socket.AF_INET, 'proto': 0, 'flags': 0}])\n\n    tr, proto = mock.Mock(), mock.Mock()\n    self.loop.create_connection = make_mocked_coro((tr, proto))\n\n    req = ClientRequest(\n        'GET', URL('https://www.python.org'),\n        proxy=URL('http://proxy.example.com'),\n        loop=self.loop,\n    )\n    self.loop.run_until_complete(\n        connector._create_connection(req, None, aiohttp.ClientTimeout()))\n\n    self.assertEqual(req.url.path, '/')\n    self.assertEqual(proxy_req.method, 'CONNECT')\n    self.assertEqual(proxy_req.url, URL('https://www.python.org'))\n    tr.close.assert_called_once_with()\n    tr.get_extra_info.assert_called_with('socket', default=None)\n\n    self.loop.run_until_complete(proxy_req.close())\n    proxy_resp.close()\n    self.loop.run_until_complete(req.close())",
    "hash_value": "48481d2d838bd0abddfc5068663b8d8d"
  },
  {
    "pyfile": "test_connector.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/aiohttp-4.0.0a1/aiohttp-4.0.0a1/tests/test_connector.py",
    "line_number": "1932",
    "type_description": "B804:connect",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1931\t    t1 = loop.create_task(conn.connect(req, None, ClientTimeout()))\n1932\t    t2 = loop.create_task(conn.connect(req, None, ClientTimeout()))\n1933\t    t3 = loop.create_task(conn.connect(req, None, ClientTimeout()))",
    "context_snippet": "async def test_error_on_connection_with_cancelled_waiter(\n        loop, key) -> None:\n\n    conn = aiohttp.BaseConnector(limit=1)\n\n    req = mock.Mock()\n    req.connection_key = key\n    proto = create_mocked_conn()\n    i = 0\n\n    fut1 = loop.create_future()\n    fut2 = loop.create_future()\n    exc = OSError()\n\n    async def create_connection(req, traces, timeout):\n        nonlocal i\n        i += 1\n        if i == 1:\n            await fut1\n            raise exc\n        if i == 2:\n            await fut2\n        elif i == 3:\n            return proto\n\n    conn._create_connection = create_connection\n\n    t1 = loop.create_task(conn.connect(req, None, ClientTimeout()))\n    t2 = loop.create_task(conn.connect(req, None, ClientTimeout()))\n    t3 = loop.create_task(conn.connect(req, None, ClientTimeout()))\n    await asyncio.sleep(0)\n    assert not t1.done()\n    assert not t2.done()\n    assert len(conn._acquired_per_host[key]) == 1\n\n    fut1.set_result(None)\n    fut2.cancel()\n    with pytest.raises(OSError):\n        await t1\n\n    with pytest.raises(asyncio.CancelledError):\n        await t2\n\n    ret = await t3\n    assert len(conn._acquired_per_host[key]) == 1\n\n    assert ret._key == key\n    assert ret.protocol == proto\n    assert proto in conn._acquired\n    ret.release()\n",
    "hash_value": "bff12a30ed64dbb567fac17f1ebfdca2"
  }
]