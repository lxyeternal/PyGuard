[
  {
    "metadata": {
      "package_name": "python_telegram_bot-22.0",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "encryptedpassportelement.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/python_telegram_bot-22.0/python_telegram_bot-22.0/telegram/_passport/encryptedpassportelement.py",
    "line_number": "244",
    "type_description": "B801:b64decode",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "243\t                        b64decode(secure_data.data.hash),\n244\t                        b64decode(data[\"data\"]),\n245\t                    )",
    "context_snippet": "from base64 import b64decode\nfrom telegram._passport.credentials import decrypt_json\nfrom telegram._passport.data import IdDocumentData, PersonalDetails, ResidentialAddress\nfrom telegram._passport.passportfile import PassportFile\nfrom telegram._utils.argumentparsing import (\n    de_json_decrypted_optional,\n    de_json_optional,\n    de_list_decrypted_optional,\n    de_list_optional,\n    parse_sequence_arg,\n)\n\n@classmethod\ndef de_json_decrypted(\n    cls, data: JSONDict, bot: Optional[\"Bot\"], credentials: \"Credentials\"\n) -> \"EncryptedPassportElement\":\n    \"\"\"Variant of :meth:`telegram.TelegramObject.de_json` that also takes into account\n    passport credentials.\n\n    Args:\n        data (dict[:obj:`str`, ...]): The JSON data.\n        bot (:class:`telegram.Bot` | :obj:`None`): The bot associated with these object.\n            May be :obj:`None`, in which case shortcut methods will not be available.\n\n            .. versionchanged:: 21.4\n               :paramref:`bot` is now optional and defaults to :obj:`None`\n\n            .. deprecated:: 21.4\n               This argument will be converted to an optional argument in future versions.\n        credentials (:class:`telegram.FileCredentials`): The credentials\n\n    Returns:\n        :class:`telegram.EncryptedPassportElement`:\n\n    \"\"\"\n\n    if data[\"type\"] not in (\"phone_number\", \"email\"):\n        secure_data = getattr(credentials.secure_data, data[\"type\"])\n\n        if secure_data.data is not None:\n            # If not already decrypted\n            if not isinstance(data[\"data\"], dict):\n                data[\"data\"] = decrypt_json(\n                    b64decode(secure_data.data.secret),\n                    b64decode(secure_data.data.hash),\n                    b64decode(data[\"data\"]),\n                )\n            if data[\"type\"] == \"personal_details\":\n                data[\"data\"] = PersonalDetails.de_json(data[\"data\"], bot=bot)\n            elif data[\"type\"] in (\n                \"passport\",\n                \"internal_passport\",\n                \"driver_license\",\n                \"identity_card\",\n            ):\n                data[\"data\"] = IdDocumentData.de_json(data[\"data\"], bot=bot)\n            elif data[\"type\"] == \"address\":\n                data[\"data\"] = ResidentialAddress.de_json(data[\"data\"], bot=bot)\n\n        data[\"files\"] = (\n            de_list_decrypted_optional(data.get(\"files\"), PassportFile, bot, secure_data.files)\n            or None\n        )\n        data[\"front_side\"] = de_json_decrypted_optional(\n            data.get(\"front_side\"), PassportFile, bot, secure_data.front_side\n        )\n        data[\"reverse_side\"] = de_json_decrypted_optional(\n            data.get(\"reverse_side\"), PassportFile, bot, secure_data.reverse_side\n        )\n        data[\"selfie\"] = de_json_decrypted_optional(\n            data.get(\"selfie\"), PassportFile, bot, secure_data.selfie\n        )\n        data[\"translation\"] = (\n            de_list_decrypted_optional(\n                data.get(\"translation\"), PassportFile, bot, secure_data.translation\n            )\n            or None\n        )\n\n    return super().de_json(data=data, bot=bot)\n",
    "hash_value": "d6d947cbd02445b28e1c249bbab8b35d"
  }
]