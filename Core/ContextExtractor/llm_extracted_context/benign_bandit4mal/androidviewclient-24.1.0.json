[
  {
    "metadata": {
      "package_name": "androidviewclient-24.1.0",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "culebron.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/androidviewclient-24.1.0/androidviewclient-24.1.0/src/com/dtmilano/android/culebron.py",
    "line_number": "399",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "398\t                    print(f\"ERROR: e={e} type={type(e)}\", file=sys.stderr)\n399\t            stream = io.BytesIO(received.read())\n400\t            if TIMING:",
    "context_snippet": "def takeScreenshotAndShowItOnWindow(self):\n    \"\"\"\n    Takes the current screenshot and shows it on the main window.\n    It also:\n     - sizes the window\n     - create the canvas\n     - set the focus\n     - enable the events\n     - create widgets\n     - finds the targets (as explained in L{findTargets})\n     - hides the vignette (that could have been showed before)\n    \"\"\"\n\n    if PROFILE:\n        print(\"PROFILING: takeScreenshotAndShowItOnWindow()\", file=sys.stderr)\n        profileStart()\n\n    if DEBUG:\n        print(\"takeScreenshotAndShowItOnWindow()\", file=sys.stderr)\n    t0 = None\n    if self.vc and self.vc.uiAutomatorHelper:\n        if self.vc.uiAutomatorHelper:\n            if TIMING:\n                t0 = time.time()\n            try:\n                self.vc.uiAutomatorHelper.ui_device.wait_for_window_update()\n            except RuntimeError as e:\n                if DEBUG:\n                    print(f\"ERROR: {e} waiting for windows update\", file=sys.stderr)\n            if TIMING:\n                print(f\"# takeScreenshotAndShowItOnWindow: waiting for window update: {time.time() - t0:.2f}s\")\n                t0 = time.time()\n            self.vc.uiAutomatorHelper.ui_device.wait_for_idle()\n            if TIMING:\n                print(f\"# takeScreenshotAndShowItOnWindow: waiting for idle: {time.time() - t0:.2f}s\")\n        if TIMING:\n            t0 = time.time()\n        received = None\n        try:\n            received = self.vc.uiAutomatorHelper.ui_device.take_screenshot()\n        except Exception as e:\n            if \"Cannot get screenshot\" in str(e):\n                try:\n                    activity = self.vc.uiAutomatorHelper.device.get_top_activity_name()\n                except Exception:\n                    activity = \"Unknown\"\n                print(f\"⛔️ ERROR: Cannot get screenshot for {activity}\", file=sys.stderr)\n                return\n            else:\n                print(f\"ERROR: e={e} type={type(e)}\", file=sys.stderr)\n        stream = io.BytesIO(received.read())\n        if TIMING:\n            print(f\"# takeScreenshotAndShowItOnWindow: screenshot: {time.time() - t0:.2f}s\")\n        try:\n            self.unscaledScreenshot = Image.open(stream)\n        except IOError as ex:\n            print(ex, file=sys.stderr)\n            print(repr(stream))\n            sys.exit(1)\n    else:\n        self.unscaledScreenshot = self.device.takeSnapshot(reconnect=True)\n    self.image = self.unscaledScreenshot\n    (width, height) = self.image.size\n    if self.scale != 1:\n        scaledWidth = int(width * self.scale)\n        scaledHeight = int(height * self.scale)\n        self.image = self.image.resize((scaledWidth, scaledHeight), PIL.Image.LANCZOS)\n        (width, height) = self.image.size\n        if self.isDarwin and 14 < self.sdkVersion < 23:\n            if sys.version_info[0] < 3:\n                stream = io.StringIO()\n            else:\n                stream = io.BytesIO()\n            self.image.save(stream, 'GIF')\n            import base64\n            gif = base64.b64encode(stream.getvalue())\n            stream.close()\n    if self.canvas is None:\n        if DEBUG:\n            print(\"⬜️ Creating canvas\", width, 'x', height, file=sys.stderr)\n        self.placeholder.grid_forget()\n        self.canvas = tkinter.Canvas(self.mainFrame, width=width, height=height)\n        if DEBUG:\n            print(\"⬜️ canvas\", self.canvas, file=sys.stderr)\n        self.canvas.focus_set()\n        self.enableEvents()\n        self.createMessageArea(width, height)\n        self.createVignette(width, height)\n    if self.isDarwin and self.scale != 1 and 14 < self.sdkVersion < 23:\n        # Extremely weird Tkinter bug, I guess\n        # If the image was rotated and then resized if ImageTk.PhotoImage(self.image)\n        # is used as usual then the result is a completely transparent image and only\n        # the \"Please wait...\" is seen.\n        # Converting it to GIF seems to solve the problem\n        self.screenshot = tkinter.PhotoImage(data=gif)\n    else:\n        self.screenshot = ImageTk.PhotoImage(self.image)\n    if self.imageId is not None:\n        self.canvas.delete(self.imageId)\n    self.imageId = self.canvas.create_image(0, 0, anchor=tkinter.NW, image=self.screenshot, tag=\"screenshot\")\n    if DEBUG:\n        try:\n            print(\"⬜️ Grid info\", self.canvas.grid_info(), file=sys.stderr)\n        except:\n            print(\"⬜️ Exception getting grid info\", file=sys.stderr)\n    gridInfo = None\n    try:\n        gridInfo = self.canvas.grid_info()\n    except:\n        if DEBUG:\n            print(\"⬜️ Adding canvas to grid (1,1)\", file=sys.stderr)\n        self.canvas.grid(row=1, column=1, rowspan=4)\n    if not gridInfo:\n        self.canvas.grid(row=1, column=1, rowspan=4)\n    try:\n        self.findTargets()\n        self.hideVignette()\n        if self.autoScreenshots:\n            print(f'Taking screenshot {self.device.screenshot_number}', file=sys.stderr)\n            self.saveSnapshot(showDialog=False)\n\n    except Exception as ex:\n        print(\"⛔️ %s\" % ex, file=sys.stderr)\n    if DEBUG:\n        try:\n            self.printGridInfo()\n        except:\n            pass\n    if PROFILE:\n        profileEnd()",
    "hash_value": "2fa14848f65b79886462a3eb45842133"
  }
]