[
  {
    "metadata": {
      "package_name": "crytic_compile-0.3.8",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "etherscan.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/crytic_compile-0.3.8/crytic_compile-0.3.8/crytic_compile/platform/etherscan.py",
    "line_number": "342",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "341\t            with urllib.request.urlopen(new_etherscan_url) as response:\n342\t                html = response.read()\n343",
    "context_snippet": "def compile(self, crytic_compile: \"CryticCompile\", **kwargs: str) -> None:\n    \"\"\"Run the compilation\n\n    Args:\n        crytic_compile (CryticCompile): Associated CryticCompile object\n        **kwargs: optional arguments. Used \"solc\", \"etherscan_only_source_code\", \"etherscan_only_bytecode\",\n            \"etherscan_api_key\", \"export_dir\"\n\n    Raises:\n        InvalidCompilation: if etherscan returned an error, or its results were not correctly parsed\n    \"\"\"\n\n    target = self._target\n\n    api_key_required = None\n\n    if target.startswith(tuple(SUPPORTED_NETWORK_V2)):\n        api_key_required = 2\n        prefix, addr = target.split(\":\", 2)\n        chainid, prefix_bytecode = SUPPORTED_NETWORK_V2[prefix]\n        etherscan_url = ETHERSCAN_BASE_V2 % (chainid, addr)\n        etherscan_bytecode_url = ETHERSCAN_BASE_BYTECODE % (prefix_bytecode, addr)\n    elif target.startswith(tuple(SUPPORTED_NETWORK_V1)):\n        api_key_required = 1\n        prefix = SUPPORTED_NETWORK_V1[target[: target.find(\":\") + 1]][0]\n        prefix_bytecode = SUPPORTED_NETWORK_V1[target[: target.find(\":\") + 1]][1]\n        addr = target[target.find(\":\") + 1 :]\n        etherscan_url = ETHERSCAN_BASE_V1 % (prefix, addr)\n        etherscan_bytecode_url = ETHERSCAN_BASE_BYTECODE % (prefix_bytecode, addr)\n    else:\n        api_key_required = 2\n        etherscan_url = ETHERSCAN_BASE_V2 % (\"1\", target)\n        etherscan_bytecode_url = ETHERSCAN_BASE_BYTECODE % (\"etherscan.io\", target)\n        addr = target\n        prefix = None\n\n    only_source = kwargs.get(\"etherscan_only_source_code\", False)\n    only_bytecode = kwargs.get(\"etherscan_only_bytecode\", False)\n\n    etherscan_api_key = kwargs.get(\"etherscan_api_key\", None)\n    if etherscan_api_key is None:\n        etherscan_api_key = os.getenv(\"ETHERSCAN_API_KEY\")\n\n    export_dir = kwargs.get(\"export_dir\", \"crytic-export\")\n    export_dir = os.path.join(\n        export_dir, kwargs.get(\"etherscan_export_dir\", \"etherscan-contracts\")\n    )\n\n    if api_key_required == 2 and etherscan_api_key:\n        etherscan_url += f\"&apikey={etherscan_api_key}\"\n        etherscan_bytecode_url += f\"&apikey={etherscan_api_key}\"\n    # API key handling for external tracers would be here e.g.\n    # elif api_key_required == 1 and avax_api_key and \"snowtrace\" in etherscan_url:\n    #    etherscan_url += f\"&apikey={avax_api_key}\"\n    #    etherscan_bytecode_url += f\"&apikey={avax_api_key}\"\n\n    source_code: str = \"\"\n    result: Dict[str, Union[bool, str, int]] = {}\n    contract_name: str = \"\"\n\n    if not only_bytecode:\n        # build object with headers, then send request\n        new_etherscan_url = urllib.request.Request(\n            etherscan_url,\n            headers={\n                \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.80 Safari/537.36 crytic-compile/0\"\n            },\n        )\n        with urllib.request.urlopen(new_etherscan_url) as response:\n            html = response.read()\n\n        info = json.loads(html)\n\n        if (\n            \"result\" in info\n            and \"rate limit reached\" in info[\"result\"]\n            and \"message\" in info\n            and info[\"message\"] == \"NOTOK\"\n        ):\n            LOGGER.error(\"Etherscan API rate limit exceeded\")\n            raise InvalidCompilation(\"Etherscan API rate limit exceeded\")\n\n        if \"message\" not in info:\n            LOGGER.error(\"Incorrect etherscan request\")\n            raise InvalidCompilation(\"Incorrect etherscan request \" + etherscan_url)\n\n        if not info[\"message\"].startswith(\"OK\") and \"Invalid API Key\" in info[\"result\"]:\n            LOGGER.error(\"Invalid etherscan API Key\")\n            raise InvalidCompilation(\"Invalid etherscan API Key: \" + etherscan_url)\n\n        if not info[\"message\"].startswith(\"OK\"):\n            LOGGER.error(\"Contract has no public source code\")\n            raise InvalidCompilation(\"Contract has no public source code: \" + etherscan_url)\n\n        if \"result\" not in info:\n            LOGGER.error(\"Contract has no public source code\")\n            raise InvalidCompilation(\"Contract has no public source code: \" + etherscan_url)\n\n        result = info[\"result\"][0]\n        # Assert to help mypy\n        assert isinstance(result[\"SourceCode\"], str)\n        assert isinstance(result[\"ContractName\"], str)\n        source_code = result[\"SourceCode\"]\n        contract_name = result[\"ContractName\"]\n\n    if source_code == \"\" and not only_source:\n        LOGGER.info(\"Source code not available, try to fetch the bytecode only\")\n\n        req = urllib.request.Request(\n            etherscan_bytecode_url, headers={\"User-Agent\": \"Mozilla/5.0\"}\n        )\n        with urllib.request.urlopen(req) as response:\n            html = response.read()\n\n        _handle_bytecode(crytic_compile, target, html)\n        return\n\n    if source_code == \"\":\n        LOGGER.error(\"Contract has no public source code\")\n        raise InvalidCompilation(\"Contract has no public source code: \" + etherscan_url)\n\n    if not os.path.exists(export_dir):\n        os.makedirs(export_dir)\n\n    # Assert to help mypy\n    assert isinstance(result[\"CompilerVersion\"], str)\n\n    compiler_version = re.findall(\n        r\"\\d+\\.\\d+\\.\\d+\", _convert_version(result[\"CompilerVersion\"])\n    )[0]\n\n    # etherscan can report \"default\" which is not a valid EVM version\n    evm_version: Optional[str] = None\n    if \"EVMVersion\" in result:\n        assert isinstance(result[\"EVMVersion\"], str)\n        evm_version = result[\"EVMVersion\"] if result[\"EVMVersion\"] != \"Default\" else None\n\n    optimization_used: bool = result[\"OptimizationUsed\"] == \"1\"\n\n    optimize_runs = None\n    if optimization_used:\n        optimize_runs = int(result[\"Runs\"])\n\n    working_dir: Optional[str] = None\n    remappings: Optional[List[str]] = None\n\n    dict_source_code: Optional[Dict] = None\n    try:\n        # etherscan might return an object with two curly braces, {{ content }}\n        dict_source_code = json.loads(source_code[1:-1])\n        assert isinstance(dict_source_code, dict)\n        filenames, working_dir, remappings = _handle_multiple_files(\n            dict_source_code, addr, prefix, contract_name, export_dir\n        )\n    except JSONDecodeError:\n        try:\n            # or etherscan might return an object with single curly braces, { content }\n            dict_source_code = json.loads(source_code)\n            assert isinstance(dict_source_code, dict)\n            filenames, working_dir, remappings = _handle_multiple_files(\n                dict_source_code, addr, prefix, contract_name, export_dir\n            )\n        except JSONDecodeError:\n            filenames = [\n                _handle_single_file(source_code, addr, prefix, contract_name, export_dir)\n            ]\n\n    # viaIR is not exposed on the top level JSON offered by etherscan, so we need to inspect the settings\n    via_ir_enabled: Optional[bool] = None\n    if isinstance(dict_source_code, dict):\n        via_ir_enabled = dict_source_code.get(\"settings\", {}).get(\"viaIR\", None)\n\n    compilation_unit = CompilationUnit(crytic_compile, contract_name)\n\n    compilation_unit.compiler_version = CompilerVersion(\n        compiler=kwargs.get(\"solc\", \"solc\"),\n        version=compiler_version,\n        optimized=optimization_used,\n        optimize_runs=optimize_runs,\n    )\n    compilation_unit.compiler_version.look_for_installed_version()\n\n    if \"Proxy\" in result and result[\"Proxy\"] == \"1\":\n        assert \"Implementation\" in result\n        implementation = str(result[\"Implementation\"])\n        if target.startswith(tuple(SUPPORTED_NETWORK)):\n            implementation = f\"{target[:target.find(':')]}:{implementation}\"\n        compilation_unit.implementation_address = implementation\n\n    solc_standard_json.standalone_compile(\n        filenames,\n        compilation_unit,\n        working_dir=working_dir,\n        remappings=remappings,\n        evm_version=evm_version,\n        via_ir=via_ir_enabled,\n    )\n\n    metadata_config = {\n        \"solc_remaps\": remappings if remappings else {},\n        \"solc_solcs_select\": compiler_version,\n        \"solc_args\": \" \".join(\n            filter(\n                None,\n                [\n                    \"--via-ir\" if via_ir_enabled else \"\",\n                    \"--optimize --optimize-runs \" + str(optimize_runs) if optimize_runs else \"\",\n                    \"--evm-version \" + evm_version if evm_version else \"\",\n                ],\n            )\n        ),\n    }\n\n    with open(\n        os.path.join(working_dir if working_dir else export_dir, \"crytic_compile.config.json\"),\n        \"w\",\n        encoding=\"utf-8\",\n    ) as f:\n        json.dump(metadata_config, f)\n",
    "hash_value": "ff37f8a871fed54c83230793d8c5b3db"
  }
]