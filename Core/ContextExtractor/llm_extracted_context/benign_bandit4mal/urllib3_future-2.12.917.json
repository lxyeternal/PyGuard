[
  {
    "metadata": {
      "package_name": "urllib3_future-2.12.917",
      "total_matches": 5,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "test_response.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/urllib3_future-2.12.917/urllib3_future-2.12.917/test/test_response.py",
    "line_number": "210",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "209\t        assert r.read(2) == b\"oo\"\n210\t        assert r.read() == b\"\"\n211\t        assert r.read() == b\"\"",
    "context_snippet": "    def test_reference_read(self) -> None:\n        fp = BytesIO(b\"foo\")\n        r = HTTPResponse(fp, preload_content=False)\n\n        assert r.read(0) == b\"\"\n        assert r.read(1) == b\"f\"\n        assert r.read(2) == b\"oo\"\n        assert r.read() == b\"\"\n        assert r.read() == b\"\"",
    "hash_value": "39e9ffd71fc3cd61a004d9238e484314"
  },
  {
    "pyfile": "poolmanager.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/urllib3_future-2.12.917/urllib3_future-2.12.917/src/urllib3/poolmanager.py",
    "line_number": "864",
    "type_description": "B818:urlopen",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "863\t        if self._proxy_requires_url_absolute_form(u):\n864\t            response = conn.urlopen(method, url, **kw)\n865\t        else:",
    "context_snippet": "def urlopen(\n        self, method: str, url: str, redirect: bool = True, **kw: typing.Any\n    ) -> HTTPResponse | ResponsePromise:\n        \"\"\"\n        Same as :meth:`urllib3.HTTPConnectionPool.urlopen`\n        with custom cross-host redirect logic and only sends the request-uri\n        portion of the ``url``.\n\n        The given ``url`` parameter must be absolute, such that an appropriate\n        :class:`urllib3.connectionpool.ConnectionPool` can be chosen for it.\n        \"\"\"\n        u = parse_url(url)\n\n        if u.scheme is None:\n            warnings.warn(\n                \"URLs without a scheme (ie 'https://') are deprecated and will raise an error \"\n                \"in a future version of urllib3. To avoid this DeprecationWarning ensure all URLs \"\n                \"start with 'https://' or 'http://'. Read more in this issue: \"\n                \"https://github.com/urllib3/urllib3/issues/2920\",\n                category=DeprecationWarning,\n                stacklevel=2,\n            )\n\n        # if we passed manually an extension to urlopen, we want to manually\n        # disable svn if they are incompatible with said extension.\n        pool_kwargs = None\n\n        if \"extension\" in kw and kw[\"extension\"] is not None:\n            extension = kw[\"extension\"]\n            disabled_svn = set()\n\n            pool_kwargs = {}\n\n            if len(extension.supported_svn()) != 3:\n                if HttpVersion.h11 not in extension.supported_svn():\n                    disabled_svn.add(HttpVersion.h11)\n                if HttpVersion.h2 not in extension.supported_svn():\n                    disabled_svn.add(HttpVersion.h2)\n                if HttpVersion.h3 not in extension.supported_svn():\n                    disabled_svn.add(HttpVersion.h3)\n\n            pool_kwargs[\"disabled_svn\"] = disabled_svn\n\n        conn = self.connection_from_host(\n            u.host, port=u.port, scheme=u.scheme, pool_kwargs=pool_kwargs\n        )\n\n        if u.scheme is not None and u.scheme.lower() not in (\"http\", \"https\"):\n            extension = load_extension(*parse_extension(u.scheme))\n            kw[\"extension\"] = extension()\n            kw.update(kw[\"extension\"].urlopen_kwargs)\n\n        kw[\"assert_same_host\"] = False\n        kw[\"redirect\"] = False\n\n        if \"headers\" not in kw:\n            kw[\"headers\"] = self.headers\n\n        if self._proxy_requires_url_absolute_form(u):\n            response = conn.urlopen(method, url, **kw)\n        else:\n            response = conn.urlopen(method, u.request_uri, **kw)\n\n        self.pools.memorize(response, conn)\n        self.pools.release()\n\n        if \"multiplexed\" in kw and kw[\"multiplexed\"]:\n            if isinstance(response, ResponsePromise):\n                response.set_parameter(\"pm_redirect\", redirect)\n                response.set_parameter(\"pm_url\", url)\n                assert isinstance(response, ResponsePromise)\n\n                return response\n\n            # the established connection is not capable of doing multiplexed request\n            kw[\"multiplexed\"] = False\n\n        assert isinstance(response, HTTPResponse)\n        redirect_location = redirect and response.get_redirect_location()\n        if not redirect_location:\n            return response\n\n        # Support relative URLs for redirecting.\n        redirect_location = urljoin(url, redirect_location)\n\n        # RFC 7231, Section 6.4.4\n        if response.status == 303:\n            method = \"GET\"\n            kw[\"body\"] = None\n            kw[\"headers\"] = HTTPHeaderDict(kw[\"headers\"])\n\n            for should_be_removed_header in NOT_FORWARDABLE_HEADERS:\n                kw[\"headers\"].discard(should_be_removed_header)\n\n        retries = kw.get(\"retries\")\n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect)\n\n        # Strip headers marked as unsafe to forward to the redirected location.\n        # Check remove_headers_on_redirect to avoid a potential network call within\n        # conn.is_same_host() which may use socket.gethostbyname() in the future.\n        if retries.remove_headers_on_redirect and not conn.is_same_host(\n            redirect_location\n        ):\n            new_headers = kw[\"headers\"].copy()\n            for header in kw[\"headers\"]:\n                if header.lower() in retries.remove_headers_on_redirect:\n                    new_headers.pop(header, None)\n            kw[\"headers\"] = new_headers\n\n        try:\n            retries = retries.increment(method, url, response=response, _pool=conn)\n        except MaxRetryError:\n            if retries.raise_on_redirect:\n                response.drain_conn()\n                raise\n            return response\n\n        kw[\"retries\"] = retries\n        kw[\"redirect\"] = redirect\n\n        log.info(\"Redirecting %s -> %s\", url, redirect_location)\n\n        response.drain_conn()\n        return self.urlopen(method, redirect_location, **kw)  # type: ignore[no-any-return]\n",
    "hash_value": "d9064336badc5e10530126d01654a6f7"
  },
  {
    "pyfile": "test_chunked_transfer.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/urllib3_future-2.12.917/urllib3_future-2.12.917/test/with_dummyserver/test_chunked_transfer.py",
    "line_number": "194",
    "type_description": "B818:urlopen",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "193\t            retries = Retry(total=1)\n194\t            pool.urlopen(\"GET\", \"/\", chunked=True, retries=retries)\n195\t            for sock in self.socks:",
    "context_snippet": "def test_preserve_chunked_on_retry_after(self) -> None:\n    self.chunked_requests = 0\n    self.socks: list[socket.socket] = []\n\n    def socket_handler(listener: socket.socket) -> None:\n        for _ in range(2):\n            sock = listener.accept()[0]\n            self.socks.append(sock)\n            request = consume_socket(sock)\n            if b\"Transfer-Encoding: chunked\" in request.split(b\"\\r\\n\"):\n                self.chunked_requests += 1\n\n            sock.send(\n                b\"HTTP/1.1 429 Too Many Requests\\r\\n\"\n                b\"Content-Type: text/plain\\r\\n\"\n                b\"Retry-After: 1\\r\\n\"\n                b\"Content-Length: 0\\r\\n\"\n                b\"Connection: close\\r\\n\"\n                b\"\\r\\n\"\n            )\n\n    self._start_server(socket_handler)\n    with HTTPConnectionPool(self.host, self.port) as pool:\n        retries = Retry(total=1)\n        pool.urlopen(\"GET\", \"/\", chunked=True, retries=retries)\n        for sock in self.socks:\n            sock.close()\n    assert self.chunked_requests == 2",
    "hash_value": "7ca48f46535c67020db30b09db224902"
  },
  {
    "pyfile": "test_resolver.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/urllib3_future-2.12.917/urllib3_future-2.12.917/test/contrib/test_resolver.py",
    "line_number": "486",
    "type_description": "B807:close",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "485\n486\t    resolver.close()\n487",
    "context_snippet": "@pytest.mark.parametrize(\n    \"url, expected_resolver_class\",\n    [\n        (\"dou://1.1.1.1\", PlainResolver),\n        (\"dox://ooooo.com\", None),\n        (\"doh://dns.google/resolve\", HTTPSResolver),\n        (\"doq://dns.nextdns.io/?timeout=5&cert_reqs=0\", QUICResolver),\n        (\"dns://dns.nextdns.io\", None),\n        (\"null://default\", NullResolver),\n        (\"default://null\", None),\n        (\"system://default\", SystemResolver),\n        (\"system://noop\", SystemResolver),\n        (\"in-memory://noop\", InMemoryResolver),\n        (\"in-memory://default\", InMemoryResolver),\n        (\"DoU://1.1.1.1\", PlainResolver),\n        (\"DOH+GOOGLE://default\", HTTPSResolver),\n        (\"doT://1.1.1.1\", TLSResolver),\n        (\"dot://1.1.1.1/?implementation=nonexistent\", None),\n        (\"system://\", SystemResolver),\n        (\"dot://\", None),\n        (\n            \"doq://dns.nextdns.io/?implementation=qh3&timeout=1&cert_reqs=0\",\n            QUICResolver,\n        ),\n    ],\n)\ndef test_url_resolver(\n    url: str, expected_resolver_class: type[BaseResolver] | None\n) -> None:\n    if expected_resolver_class is _MISSING_QUIC_SENTINEL:\n        pytest.skip(\"Test requires qh3 installed\")\n\n    if expected_resolver_class is None:\n        with pytest.raises(\n            (\n                NotImplementedError,\n                ValueError,\n                TypeError,\n            )\n        ):\n            ResolverDescription.from_url(url).new()\n        return\n\n    resolver = ResolverDescription.from_url(url).new()\n\n    assert isinstance(resolver, expected_resolver_class)\n    resolver.close()\n",
    "hash_value": "b9e1eadda407d1b051934f317da0d66d"
  },
  {
    "pyfile": "test_socketlevel.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/urllib3_future-2.12.917/urllib3_future-2.12.917/test/with_dummyserver/test_socketlevel.py",
    "line_number": "621",
    "type_description": "B805:send",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "620\t            timed_out.wait()\n621\t            sock.send(body.encode(\"utf-8\"))\n622\t            sock.close()",
    "context_snippet": "def socket_handler(listener: socket.socket) -> None:\n    sock = listener.accept()[0]\n    buf = b\"\"\n    body = \"Hi\"\n    while not buf.endswith(b\"\\r\\n\\r\\n\"):\n        buf = sock.recv(65536)\n    sock.send(\n        (\n            \"HTTP/1.1 200 OK\\r\\n\"\n            \"Content-Type: text/plain\\r\\n\"\n            \"Content-Length: %d\\r\\n\"\n            \"\\r\\n\" % len(body)\n        ).encode(\"utf-8\")\n    )\n\n    timed_out.wait()\n    sock.send(body.encode(\"utf-8\"))\n    sock.close()",
    "hash_value": "1dad98335452bbb2d36c7523c4408b79"
  }
]