[
  {
    "metadata": {
      "package_name": "gekko-1.3.0",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "gekko.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gekko-1.3.0/gekko-1.3.0/gekko/gekko.py",
    "line_number": "1274",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1273\t        else:\n1274\t            fid.write('maximize\\n')\n1275\t        fid.write(str(int(nx)) + ' ! n = number of variables \\n')",
    "context_snippet": "def qobj(self,b,A=[],x=None,otype='min',sparse=False):\n    \"\"\"Create quadratic objective  = 0.5 x^T A x + c^T x\n    Usage: x = m.qobj(c,Q=[2d array],otype=['min','max'],sparse=[True,False])\n    Input: b = numpy 1D array or list in dense or sparse form\n           A = numpy 2D array or list in dense or sparse form\n           x = array of gekko variables (optional). If None on entry\n                 then the array is created and returned.\n           etype = ['=','<','>','>=','<='] for equality or inequality form\n           sparse = True if data is in sparse form, otherwise dense\n             sparse matrices are stored in COO form with [row,col,value] with\n             starting index 1 for optional matrix A and in [row,value] for\n             vector b\n           sparse matrices must have 3 columns\n    Output: GEKKO variables x\n    \"\"\"\n\n    #verify data input types\n    if not isinstance(b, (list,np.ndarray)):\n        raise TypeError(\"QOBJ input b must be a python list or numpy array\")\n\n    if not any(otype[0:min(3,len(otype))].lower()==t for t in ['min','max']):\n        raise TypeError(\"otype must start with either, 'min' or 'max'\")\n\n    b = np.array(b,dtype=float)\n    if sparse:\n        b = b.T\n        m = np.size(b,0)\n        n = np.size(b,1)\n        if (n!=2):\n            raise Exception('The b vector must be in COO form as [row,value] with 2 rows')\n    else:\n        b = b.flatten()\n\n    if (len(A)>=1):\n        if not isinstance(A, (list,np.ndarray)):\n            raise TypeError(\"QOBJ input A must be a python list or numpy array\")\n        A = np.array(A,dtype=float).T\n        # check sizes\n        if sparse:\n            m = np.size(A,0)\n            n = np.size(A,1)\n            if (n!=3):\n                raise Exception('The A matrix must be in COO form as [row,col,value] with 3 rows')\n\n        if sparse:\n            # sparse matrix size\n            r_max = np.max(A[:,0])\n            c_max = np.max(A[:,1])\n        else:\n            # dense matrix check\n            r_max = np.size(A,0)\n            c_max = np.size(A,1)\n            if (r_max!=c_max):\n                raise Exception('QOBJ: A matrix must have same number of rows and columns')\n\n    if x==None:\n        # create x variable array if none given\n        if sparse:\n            # maximum row index\n            nx = int(np.max(b[:,0]))\n        else:\n            nx = np.size(b)\n        xin = self.Array(self.Var,(nx))\n    else:\n        if not isinstance(x, (list,np.ndarray)):\n            raise TypeError(\"Optional x must be a python list or numpy array of GEKKO variables or parameters\")\n        nx = len(x)\n        if sparse:\n            if (nx!=int(np.max(b[:,0]))):\n                raise TypeError(\"Optional x must have same dimension as sparse b\")\n        else:\n            if nx!=np.size(b):\n                raise TypeError(\"Optional x must have same dimension as b\")\n        if len(A)>=1:\n            if nx!=c_max:\n                raise TypeError(\"Optional x must have same dimension as A\")\n        for i in range(nx):\n            if not isinstance(x[i],(GKVariable,GKParameter)):\n                raise TypeError(\"List x must be composed of GEKKO parameters or variables\")\n        xin = x\n\n    #build qobj object with unique object name\n    qobj_name = 'qobj' + str(len(self._objects) + 1)\n    self._objects.append(qobj_name + ' = qobj')\n\n    # write header file\n    filename = qobj_name+'.txt'\n    fid = open(os.path.join(self._path,filename),'w')\n    if sparse:\n        fid.write('sparse, ')\n    else:\n        fid.write('dense, ')\n    if (otype[0:min(3,len(otype))].lower()=='min'):\n        fid.write('minimize\\n')\n    else:\n        fid.write('maximize\\n')\n    fid.write(str(int(nx)) + ' ! n = number of variables \\n')\n    fid.close()\n    self._extra_files.append(filename)\n\n    # write A file\n    if (len(A)>=1):\n        filename = qobj_name+'.a.txt'\n        np.savetxt(os.path.join(self._path,filename), A, delimiter=\",\", fmt='%1.25s')\n        self._extra_files.append(qobj_name+'.a.txt')\n\n    # write b file\n    filename = qobj_name+'.b.txt'\n    np.savetxt(os.path.join(self._path,filename), b, delimiter=\",\", fmt='%1.25s')\n    self._extra_files.append(qobj_name+'.b.txt')\n\n    #Add connections between x and qobj object x (index 1)\n    for i in range(nx):\n        self._connections.append(xin[i].name + ' = ' + qobj_name+'.x['+str(i+1)+']')\n\n    if x==None:\n        return xin\n    else:\n        return",
    "hash_value": "2e4cf655c471490bba658bb0be3bcb02"
  }
]