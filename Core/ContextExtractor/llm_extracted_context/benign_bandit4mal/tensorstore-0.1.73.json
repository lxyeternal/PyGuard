[
  {
    "metadata": {
      "package_name": "tensorstore-0.1.73",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "emit_cc.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/tensorstore-0.1.73/tensorstore-0.1.73/tools/cmake/bazel_to_cmake/emit_cc.py",
    "line_number": "144",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "143\t  if add_dependencies:\n144\t    out.write(\n145\t        f\"add_dependencies({target_name} \"\n146\t        f\"{quote_list(sorted(add_dependencies))})\\n\"\n147\t    )",
    "context_snippet": "def _emit_cc_common_options(\n    out: io.StringIO,\n    target_name: str,\n    asm_dialect: Optional[str] = None,\n    link_libraries: Optional[Iterable[str]] = None,\n    private_link_libraries: Optional[Iterable[str]] = None,\n    copts: Optional[Iterable[str]] = None,\n    linkopts: Optional[Iterable[str]] = None,\n    defines: Optional[Iterable[str]] = None,\n    local_defines: Optional[Iterable[str]] = None,\n    includes: Optional[Iterable[str]] = None,\n    private_includes: Optional[Iterable[str]] = None,\n    add_dependencies: Optional[Iterable[str]] = None,\n    extra_public_compile_options: Optional[Iterable[str]] = None,\n    interface_only: bool = False,\n    srcs: Optional[Iterable[str]] = None,\n    public_srcs: Optional[Iterable[str]] = None,\n    **kwargs,\n):\n  \"\"\"Emits CMake rules for common C++ target options.\"\"\"\n  assert \"deps\" not in kwargs\n  del kwargs\n\n  public_context = \"INTERFACE\" if interface_only else \"PUBLIC\"\n  if local_defines is not None and local_defines and not interface_only:\n    out.write(\n        f\"target_compile_definitions({target_name} PRIVATE\"\n        f\" {quote_unescaped_list(local_defines)})\\n\"\n    )\n  if defines is not None and defines:\n    out.write(\n        f\"target_compile_definitions({target_name} {public_context} {quote_unescaped_list(defines)})\\n\"\n    )\n  if copts is not None and copts and not interface_only:\n    out.write(\n        f\"target_compile_options({target_name} PRIVATE {quote_list(copts)})\\n\"\n    )\n\n  if link_libraries or linkopts:\n    link_libs: List[str] = []\n    if link_libraries:\n      link_libs.extend(sorted(link_libraries))\n\n    link_options: List[str] = []\n    for x in linkopts or []:\n      if x.startswith(\"-l\") or x.startswith(\"-framework\"):\n        link_libs.append(x)\n      else:\n        link_options.append(x)\n    if link_libs:\n      out.write(\n          f\"target_link_libraries({target_name} {public_context}{_SEP}{quote_list(link_libs, separator=_SEP)})\\n\"\n      )\n    if link_options:\n      out.write(\n          f\"target_link_options({target_name} {public_context}{_SEP}{quote_list(link_options, separator=_SEP)})\\n\"\n      )\n\n  if private_link_libraries:\n    private_link_libs: List[str] = sorted(private_link_libraries)\n    out.write(\n        f\"target_link_libraries({target_name} PRIVATE{_SEP}{quote_list(private_link_libs, separator=_SEP)})\\n\"\n    )\n\n  include_dirs = [\n      f\"$<BUILD_INTERFACE:{include_dir}>\"\n      for include_dir in sorted(set(includes))\n  ]\n  if include_dirs:\n    out.write(\n        f\"target_include_directories({target_name} {public_context}\"\n        f\"{_SEP}{quote_path_list(include_dirs, separator=_SEP)})\\n\"\n    )\n  if not interface_only and private_includes:\n    include_dirs = [\n        f\"$<BUILD_INTERFACE:{include_dir}>\"\n        for include_dir in sorted(set(private_includes))\n    ]\n    if include_dirs:\n      out.write(\n          f\"target_include_directories({target_name} PRIVATE\"\n          f\"{_SEP}{quote_path_list(include_dirs, separator=_SEP)})\\n\"\n      )\n\n  out.write(\n      f\"target_compile_features({target_name} {public_context} cxx_std_17)\\n\"\n  )\n  if add_dependencies:\n    out.write(\n        f\"add_dependencies({target_name} \"\n        f\"{quote_list(sorted(add_dependencies))})\\n\"\n    )\n  if extra_public_compile_options:\n    out.write(\n        f\"target_compile_options({target_name} {public_context} \"\n        f\"{quote_list(extra_public_compile_options)})\\n\"\n    )\n\n  if srcs or public_srcs:\n    non_header_srcs = partition_by(srcs, pattern=_HEADER_SRC_PATTERN)[1]\n    asm_srcs = partition_by(\n        itertools.chain(non_header_srcs, public_srcs or []),\n        pattern=_ASM_SRC_PATTERN,\n    )[0]\n    if public_srcs:\n      out.write(\n          f\"target_sources({target_name} PUBLIC{_SEP}\"\n          f\"{quote_path_list(public_srcs , separator=_SEP)})\\n\"\n      )\n    if non_header_srcs:\n      out.write(\n          f\"target_sources({target_name} PRIVATE{_SEP}\"\n          f\"{quote_path_list(non_header_srcs , separator=_SEP)})\\n\"\n      )\n    if asm_srcs:\n      if asm_dialect is None:\n        raise ValueError(\n            f\"asm_dialect must be specified for ASM srcs: {asm_srcs!r}\"\n        )\n      out.write(f\"\"\"set_source_files_properties(\n    {quote_path_list(asm_srcs)}\n    PROPERTIES\n      LANGUAGE {asm_dialect})\\n\"\"\")",
    "hash_value": "ec4651b8f320600c44e4cc0711613a24"
  }
]