[
  {
    "metadata": {
      "package_name": "gevent-24.11.1",
      "total_matches": 25,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "test_subprocess.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/greentest/3.11/test_subprocess.py",
    "line_number": "594",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "593\t        with p:\n594\t            self.assertEqual(p.stderr.read(), b\"strawberry\")\n595",
    "context_snippet": "def test_stderr_pipe(self):\n    # stderr redirection\n    p = subprocess.Popen([sys.executable, \"-c\",\n                      'import sys; sys.stderr.write(\"strawberry\")'],\n                     stderr=subprocess.PIPE)\n    with p:\n        self.assertEqual(p.stderr.read(), b\"strawberry\")",
    "hash_value": "680293d2491da8a6cbf37cf37de15c84"
  },
  {
    "pyfile": "test_ssl.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/greentest/3.10/test_ssl.py",
    "line_number": "2137",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "2136\t        with open(SIGNING_CA) as f:\n2137\t            pem = f.read()\n2138\t        der = ssl.PEM_cert_to_DER_cert(pem)",
    "context_snippet": "with open(SIGNING_CA) as f:\n    pem = f.read()\nder = ssl.PEM_cert_to_DER_cert(pem)",
    "hash_value": "e931941d96b7aafd71a44b1b82270020"
  },
  {
    "pyfile": "test_socket.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/greentest/3.12/test_socket.py",
    "line_number": "5161",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "5160\t        while 1:\n5161\t            char = self.read_file.read(1)\n5162\t            if not char:",
    "context_snippet": "def testUnbufferedRead(self):\n    # Performing unbuffered file read test\n    buf = type(self.read_msg)()\n    while 1:\n        char = self.read_file.read(1)\n        if not char:\n            break\n        buf += char\n    self.assertEqual(buf, self.read_msg)",
    "hash_value": "5747bc020e45ff1db77b4895777ae558"
  },
  {
    "pyfile": "test_threading.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/greentest/3.13/test_threading.py",
    "line_number": "1487",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1486\n1487\t        self.assertEqual(os.read(r_interp, 1), INTERP)\n1488\t        self.assertEqual(os.read(r_interp, 1), FINI)",
    "context_snippet": "@requires_subinterpreters\n    def test_threads_join_with_no_main(self):\n        r_interp, w_interp = self.pipe()\n\n        INTERP = b'I'\n        FINI = b'F'\n        DONE = b'D'\n\n        interp = interpreters.create()\n        interp.exec(f\"\"\"if True:\n            import os\n            import threading\n            import time\n\n            done = False\n\n            def notify_fini():\n                global done\n                done = True\n                os.write({w_interp}, {FINI!r})\n                t.join()\n            threading._register_atexit(notify_fini)\n\n            def task():\n                while not done:\n                    time.sleep(0.1)\n                os.write({w_interp}, {DONE!r})\n            t = threading.Thread(target=task)\n            t.start()\n\n            os.write({w_interp}, {INTERP!r})\n            \"\"\")\n        interp.close()\n\n        self.assertEqual(os.read(r_interp, 1), INTERP)\n        self.assertEqual(os.read(r_interp, 1), FINI)\n        self.assertEqual(os.read(r_interp, 1), DONE)",
    "hash_value": "126041b0731262eb32de353707f750a2"
  },
  {
    "pyfile": "test_threading.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/greentest/3.10/test_threading.py",
    "line_number": "1618",
    "type_description": "B828:signal",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1617\n1618\t            signal.signal(signum, signal.SIG_DFL)\n1619\t            _thread.interrupt_main(signum)",
    "context_snippet": "def check_interrupt_main_noerror(self, signum):\n    handler = signal.getsignal(signum)\n    try:\n        # No exception should arise.\n        signal.signal(signum, signal.SIG_IGN)\n        _thread.interrupt_main(signum)\n\n        signal.signal(signum, signal.SIG_DFL)\n        _thread.interrupt_main(signum)\n    finally:\n        # Restore original handler\n        signal.signal(signum, handler)",
    "hash_value": "7e74d3f6037e3eee35fd5576162821be"
  },
  {
    "pyfile": "test_threading.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/greentest/3.9/test_threading.py",
    "line_number": "1481",
    "type_description": "B828:signal",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1480\t            # No exception should arise.\n1481\t            signal.signal(signal.SIGINT, signal.SIG_IGN)\n1482\t            _thread.interrupt_main()",
    "context_snippet": "class InterruptMainTests(unittest.TestCase):\n    def test_interrupt_main_subthread(self):\n        # Calling start_new_thread with a function that executes interrupt_main\n        # should raise KeyboardInterrupt upon completion.\n        def call_interrupt():\n            _thread.interrupt_main()\n        t = threading.Thread(target=call_interrupt)\n        with self.assertRaises(KeyboardInterrupt):\n            t.start()\n            t.join()\n        t.join()\n\n    def test_interrupt_main_mainthread(self):\n        # Make sure that if interrupt_main is called in main thread that\n        # KeyboardInterrupt is raised instantly.\n        with self.assertRaises(KeyboardInterrupt):\n            _thread.interrupt_main()\n\n    def test_interrupt_main_noerror(self):\n        handler = signal.getsignal(signal.SIGINT)\n        try:\n            # No exception should arise.\n            signal.signal(signal.SIGINT, signal.SIG_IGN)\n            _thread.interrupt_main()\n\n            signal.signal(signal.SIGINT, signal.SIG_DFL)\n            _thread.interrupt_main()\n        finally:\n            # Restore original handler\n            signal.signal(signal.SIGINT, handler)",
    "hash_value": "be04794ecaacea3f9825e9d8f37f003f"
  },
  {
    "pyfile": "test_socket.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/greentest/3.12/test_socket.py",
    "line_number": "5145",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "5144\t    def _testSmallRead(self):\n5145\t        self.write_file.write(self.write_msg)\n5146\t        self.write_file.flush()",
    "context_snippet": "def _testSmallRead(self):\n    self.write_file.write(self.write_msg)\n    self.write_file.flush()",
    "hash_value": "5c7b05ac8c10885129644bb24723306a"
  },
  {
    "pyfile": "test_ssl.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/greentest/3.11/test_ssl.py",
    "line_number": "2855",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "2854\t                            \" client:  sending %r...\\n\" % indata)\n2855\t                s.write(arg)\n2856\t                outdata = s.read()",
    "context_snippet": "def server_params_test(client_context, server_context, indata=b\"FOO\\n\",\n                       chatty=True, connectionchatty=False, sni_name=None,\n                       session=None):\n    \"\"\"\n    Launch a server, connect a client to it and try various reads\n    and writes.\n    \"\"\"\n    stats = {}\n    server = ThreadedEchoServer(context=server_context,\n                                chatty=chatty,\n                                connectionchatty=False)\n    with server:\n        with client_context.wrap_socket(socket.socket(),\n                server_hostname=sni_name, session=session) as s:\n            s.connect((HOST, server.port))\n            for arg in [indata, bytearray(indata), memoryview(indata)]:\n                if connectionchatty:\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" client:  sending %r...\\n\" % indata)\n                s.write(arg)\n                outdata = s.read()\n                if connectionchatty:\n                    if support.verbose:\n                        sys.stdout.write(\" client:  read %r\\n\" % outdata)\n                if outdata != indata.lower():\n                    raise AssertionError(\n                        \"bad data <<%r>> (%d) received; expected <<%r>> (%d)\\n\"\n                        % (outdata[:20], len(outdata),\n                           indata[:20].lower(), len(indata)))\n            s.write(b\"over\\n\")\n            if connectionchatty:\n                if support.verbose:\n                    sys.stdout.write(\" client:  closing connection.\\n\")\n            stats.update({\n                'compression': s.compression(),\n                'cipher': s.cipher(),\n                'peercert': s.getpeercert(),\n                'client_alpn_protocol': s.selected_alpn_protocol(),\n                'version': s.version(),\n                'session_reused': s.session_reused,\n                'session': s.session,\n            })\n            s.close()\n        stats['server_alpn_protocols'] = server.selected_alpn_protocols\n        stats['server_shared_ciphers'] = server.shared_ciphers\n    return stats",
    "hash_value": "d374cb17b189b2453186bbc240d96c98"
  },
  {
    "pyfile": "test_subprocess.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/greentest/3.9/test_subprocess.py",
    "line_number": "2188",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "2187\t            fobj.write(\"#!%s\\n\" % support.unix_shell)\n2188\t            fobj.write(\"exec '%s' -c 'import sys; sys.exit(47)'\\n\" %\n2189\t                       sys.executable)\n2190\t        os.chmod(fname, 0o700)",
    "context_snippet": "def test_args_string(self):\n    # args is a string\n    fd, fname = tempfile.mkstemp()\n    # reopen in text mode\n    with open(fd, \"w\", errors=\"surrogateescape\") as fobj:\n        fobj.write(\"#!%s\\n\" % support.unix_shell)\n        fobj.write(\"exec '%s' -c 'import sys; sys.exit(47)'\\n\" %\n                   sys.executable)\n    os.chmod(fname, 0o700)\n    p = subprocess.Popen(fname)\n    p.wait()\n    os.remove(fname)\n    self.assertEqual(p.returncode, 47)",
    "hash_value": "afb60e2750e6e2f1cb609cb2b5826ea9"
  },
  {
    "pyfile": "test__pywsgi.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/gevent/tests/test__pywsgi.py",
    "line_number": "704",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "703\t        with self.makefile() as fd:\n704\t            fd.write(data)\n705\t            read_http(fd, body='oh hai')",
    "context_snippet": "def test_negative_chunked_read(self):\n    data = (b'POST /read HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: close\\r\\n'\n            b'Transfer-Encoding: chunked\\r\\n\\r\\n'\n            b'2\\r\\noh\\r\\n4\\r\\n hai\\r\\n0\\r\\n\\r\\n')\n    with self.makefile() as fd:\n        fd.write(data)\n        read_http(fd, body='oh hai')",
    "hash_value": "95fe9a698237d08ddbf88fbc815466a2"
  },
  {
    "pyfile": "test_ssl.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/greentest/3.10/test_ssl.py",
    "line_number": "2593",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "2592\t                        certs = self.sslconn._sslobj.get_verified_chain()\n2593\t                        self.write(len(certs).to_bytes(1, \"big\") + b\"\\n\")\n2594\t                    elif stripped == b'UNVERIFIEDCHAIN':",
    "context_snippet": "def run(self):\n    self.running = True\n    if not self.server.starttls_server:\n        if not self.wrap_conn():\n            return\n    while self.running:\n        try:\n            msg = self.read()\n            stripped = msg.strip()\n            if not stripped:\n                # eof, so quit this handler\n                self.running = False\n                try:\n                    self.sock = self.sslconn.unwrap()\n                except OSError:\n                    # Many tests shut the TCP connection down\n                    # without an SSL shutdown. This causes\n                    # unwrap() to raise OSError with errno=0!\n                    pass\n                else:\n                    self.sslconn = None\n                self.close()\n            elif stripped == b'over':\n                if support.verbose and self.server.connectionchatty:\n                    sys.stdout.write(\" server: client closed connection\\n\")\n                self.close()\n                return\n            elif (self.server.starttls_server and\n                  stripped == b'STARTTLS'):\n                if support.verbose and self.server.connectionchatty:\n                    sys.stdout.write(\" server: read STARTTLS from client, sending OK...\\n\")\n                self.write(b\"OK\\n\")\n                if not self.wrap_conn():\n                    return\n            elif (self.server.starttls_server and self.sslconn\n                  and stripped == b'ENDTLS'):\n                if support.verbose and self.server.connectionchatty:\n                    sys.stdout.write(\" server: read ENDTLS from client, sending OK...\\n\")\n                self.write(b\"OK\\n\")\n                self.sock = self.sslconn.unwrap()\n                self.sslconn = None\n                if support.verbose and self.server.connectionchatty:\n                    sys.stdout.write(\" server: connection is now unencrypted...\\n\")\n            elif stripped == b'CB tls-unique':\n                if support.verbose and self.server.connectionchatty:\n                    sys.stdout.write(\" server: read CB tls-unique from client, sending our CB data...\\n\")\n                data = self.sslconn.get_channel_binding(\"tls-unique\")\n                self.write(repr(data).encode(\"us-ascii\") + b\"\\n\")\n            elif stripped == b'PHA':\n                if support.verbose and self.server.connectionchatty:\n                    sys.stdout.write(\" server: initiating post handshake auth\\n\")\n                try:\n                    self.sslconn.verify_client_post_handshake()\n                except ssl.SSLError as e:\n                    self.write(repr(e).encode(\"us-ascii\") + b\"\\n\")\n                else:\n                    self.write(b\"OK\\n\")\n            elif stripped == b'HASCERT':\n                if self.sslconn.getpeercert() is not None:\n                    self.write(b'TRUE\\n')\n                else:\n                    self.write(b'FALSE\\n')\n            elif stripped == b'GETCERT':\n                cert = self.sslconn.getpeercert()\n                self.write(repr(cert).encode(\"us-ascii\") + b\"\\n\")\n            elif stripped == b'VERIFIEDCHAIN':\n                certs = self.sslconn._sslobj.get_verified_chain()\n                self.write(len(certs).to_bytes(1, \"big\") + b\"\\n\")\n            elif stripped == b'UNVERIFIEDCHAIN':\n                certs = self.sslconn._sslobj.get_unverified_chain()\n                self.write(len(certs).to_bytes(1, \"big\") + b\"\\n\")\n            else:\n                if (support.verbose and\n                    self.server.connectionchatty):\n                    ctype = (self.sslconn and \"encrypted\") or \"unencrypted\"\n                    sys.stdout.write(\" server: read %r (%s), sending back %r (%s)...\\n\"\n                                     % (msg, ctype, msg.lower(), ctype))\n                self.write(msg.lower())\n        except OSError as e:\n            # handles SSLError and socket errors\n            if self.server.chatty and support.verbose:\n                if isinstance(e, ConnectionError):\n                    # OpenSSL 1.1.1 sometimes raises\n                    # ConnectionResetError when connection is not\n                    # shut down gracefully.\n                    print(\n                        f\" Connection reset by peer: {self.addr}\"\n                    )\n                else:\n                    handle_error(\"Test server failure:\\n\")\n            try:\n                self.write(b\"ERROR\\n\")\n            except OSError:\n                pass\n            self.close()\n            self.running = False\n\n            # normally, we'd just stop here, but for the test\n            # harness, we want to stop the server\n            self.server.stop()",
    "hash_value": "5a45a0f0ff26e5ecb546c335f9e9b97f"
  },
  {
    "pyfile": "test_socket.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/greentest/3.11/test_socket.py",
    "line_number": "47",
    "type_description": "B812:system",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "46\tVSOCKPORT = 1234\n47\tAIX = platform.system() == \"AIX\"\n48",
    "context_snippet": "import platform\n\nVSOCKPORT = 1234\nAIX = platform.system() == \"AIX\"\n",
    "hash_value": "14613db47d6f9662cbb114721b21b915"
  },
  {
    "pyfile": "test_socket.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/greentest/3.11/test_socket.py",
    "line_number": "816",
    "type_description": "B807:close",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "815\t        self.assertIsInstance(s, socket.SocketType)\n816\t        s.close()\n817",
    "context_snippet": "def test_SocketType_is_socketobject(self):\n    import _socket\n    self.assertTrue(socket.SocketType is _socket.socket)\n    s = socket.socket()\n    self.assertIsInstance(s, socket.SocketType)\n    s.close()",
    "hash_value": "adf707e136147af5bb4e844de663ac4e"
  },
  {
    "pyfile": "test_ssl.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/greentest/3.12/test_ssl.py",
    "line_number": "3703",
    "type_description": "B807:close",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "3702\t        t.join()\n3703\t        remote.close()\n3704\t        server.close()",
    "context_snippet": "def test_server_accept(self):\n    # Issue #16357: accept() on a SSLSocket created through\n    # SSLContext.wrap_socket().\n    client_ctx, server_ctx, hostname = testing_context()\n    server = socket.socket(socket.AF_INET)\n    host = \"127.0.0.1\"\n    port = socket_helper.bind_port(server)\n    server = server_ctx.wrap_socket(server, server_side=True)\n    self.assertTrue(server.server_side)\n\n    evt = threading.Event()\n    remote = None\n    peer = None\n    def serve():\n        nonlocal remote, peer\n        server.listen()\n        # Block on the accept and wait on the connection to close.\n        evt.set()\n        remote, peer = server.accept()\n        remote.send(remote.recv(4))\n\n    t = threading.Thread(target=serve)\n    t.start()\n    # Client wait until server setup and perform a connect.\n    evt.wait()\n    client = client_ctx.wrap_socket(\n        socket.socket(), server_hostname=hostname\n    )\n    client.connect((hostname, port))\n    client.send(b'data')\n    client.recv()\n    client_addr = client.getsockname()\n    client.close()\n    t.join()\n    remote.close()\n    server.close()\n    # Sanity checks.\n    self.assertIsInstance(remote, ssl.SSLSocket)\n    self.assertEqual(peer, client_addr)",
    "hash_value": "0524318bfb2bcbcc0b16f1e1159ae1b5"
  },
  {
    "pyfile": "test_socket.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/greentest/3.9/test_socket.py",
    "line_number": "409",
    "type_description": "B807:close",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "408\t    def clientTearDown(self):\n409\t        self.cli.close()\n410\t        self.cli = None",
    "context_snippet": "    def clientTearDown(self):\n        self.cli.close()\n        self.cli = None\n        ThreadableTest.clientTearDown(self)",
    "hash_value": "aaca84ec064f33b9683469c7b2f1a56f"
  },
  {
    "pyfile": "test_ftplib.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/greentest/3.10/test_ftplib.py",
    "line_number": "1143",
    "type_description": "B807:close",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1142\t        self.evt.wait()\n1143\t        ftp.close()\n1144",
    "context_snippet": "def testTimeoutDirectAccess(self):\n    ftp = ftplib.FTP()\n    ftp.timeout = 30\n    ftp.connect(HOST)\n    self.assertEqual(ftp.sock.gettimeout(), 30)\n    self.evt.wait()\n    ftp.close()",
    "hash_value": "fe4d7a251f2a97bfe1dcc7a66bb6ce18"
  },
  {
    "pyfile": "test_ssl.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/greentest/3.12/test_ssl.py",
    "line_number": "3432",
    "type_description": "B804:connect",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "3431\t                                cert_reqs=ssl.CERT_NONE)\n3432\t            s.connect((HOST, server.port))\n3433\t            # helper methods for standardising recv* method signatures",
    "context_snippet": "def test_recv_send(self):\n    \"\"\"Test recv(), send() and friends.\"\"\"\n    if support.verbose:\n        sys.stdout.write(\"\\n\")\n\n    server = ThreadedEchoServer(CERTFILE,\n                                certreqs=ssl.CERT_NONE,\n                                ssl_version=ssl.PROTOCOL_TLS_SERVER,\n                                cacerts=CERTFILE,\n                                chatty=True,\n                                connectionchatty=False)\n    with server:\n        s = test_wrap_socket(socket.socket(),\n                            server_side=False,\n                            certfile=CERTFILE,\n                            ca_certs=CERTFILE,\n                            cert_reqs=ssl.CERT_NONE)\n        s.connect((HOST, server.port))\n        # helper methods for standardising recv* method signatures\n        def _recv_into():\n            b = bytearray(b\"\\0\"*100)\n            count = s.recv_into(b)\n            return b[:count]\n\n        def _recvfrom_into():\n            b = bytearray(b\"\\0\"*100)\n            count, addr = s.recvfrom_into(b)\n            return b[:count]\n\n        # (name, method, expect success?, *args, return value func)\n        send_methods = [\n            ('send', s.send, True, [], len),\n            ('sendto', s.sendto, False, [\"some.address\"], len),\n            ('sendall', s.sendall, True, [], lambda x: None),\n        ]\n        # (name, method, whether to expect success, *args)\n        recv_methods = [\n            ('recv', s.recv, True, []),\n            ('recvfrom', s.recvfrom, False, [\"some.address\"]),\n            ('recv_into', _recv_into, True, []),\n            ('recvfrom_into', _recvfrom_into, False, []),\n        ]\n        data_prefix = \"PREFIX_\"\n\n        for (meth_name, send_meth, expect_success, args,\n                ret_val_meth) in send_methods:\n            indata = (data_prefix + meth_name).encode('ascii')\n            try:\n                ret = send_meth(indata, *args)\n                msg = \"sending with {}\".format(meth_name)\n                self.assertEqual(ret, ret_val_meth(indata), msg=msg)\n                outdata = s.read()\n                if outdata != indata.lower():\n                    self.fail(\n                        \"While sending with <<{name:s}>> bad data \"\n                        \"<<{outdata:r}>> ({nout:d}) received; \"\n                        \"expected <<{indata:r}>> ({nin:d})\\n\".format(\n                            name=meth_name, outdata=outdata[:20],\n                            nout=len(outdata),\n                            indata=indata[:20], nin=len(indata)\n                        )\n                    )\n            except ValueError as e:\n                if expect_success:\n                    self.fail(\n                        \"Failed to send with method <<{name:s}>>; \"\n                        \"expected to succeed.\\n\".format(name=meth_name)\n                    )\n                if not str(e).startswith(meth_name):\n                    self.fail(\n                        \"Method <<{name:s}>> failed with unexpected \"\n                        \"exception message: {exp:s}\\n\".format(\n                            name=meth_name, exp=e\n                        )\n                    )\n\n        for meth_name, recv_meth, expect_success, args in recv_methods:\n            indata = (data_prefix + meth_name).encode('ascii')\n            try:\n                s.send(indata)\n                outdata = recv_meth(*args)\n                if outdata != indata.lower():\n                    self.fail(\n                        \"While receiving with <<{name:s}>> bad data \"\n                        \"<<{outdata:r}>> ({nout:d}) received; \"\n                        \"expected <<{indata:r}>> ({nin:d})\\n\".format(\n                            name=meth_name, outdata=outdata[:20],\n                            nout=len(outdata),\n                            indata=indata[:20], nin=len(indata)\n                        )\n                    )\n            except ValueError as e:\n                if expect_success:\n                    self.fail(\n                        \"Failed to receive with method <<{name:s}>>; \"\n                        \"expected to succeed.\\n\".format(name=meth_name)\n                    )\n                if not str(e).startswith(meth_name):\n                    self.fail(\n                        \"Method <<{name:s}>> failed with unexpected \"\n                        \"exception message: {exp:s}\\n\".format(\n                            name=meth_name, exp=e\n                        )\n                    )\n                # consume data\n                s.read()\n\n        # read(-1, buffer) is supported, even though read(-1) is not\n        data = b\"data\"\n        s.send(data)\n        buffer = bytearray(len(data))\n        self.assertEqual(s.read(-1, buffer), len(data))\n        self.assertEqual(buffer, data)\n\n        # sendall accepts bytes-like objects\n        if ctypes is not None:\n            ubyte = ctypes.c_ubyte * len(data)\n            byteslike = ubyte.from_buffer_copy(data)\n            s.sendall(byteslike)\n            self.assertEqual(s.read(), data)\n\n        # Make sure sendmsg et al are disallowed to avoid\n        # inadvertent disclosure of data and/or corruption\n        # of the encrypted data stream\n        self.assertRaises(NotImplementedError, s.dup)\n        self.assertRaises(NotImplementedError, s.sendmsg, [b\"data\"])\n        self.assertRaises(NotImplementedError, s.recvmsg, 100)\n        self.assertRaises(NotImplementedError,\n                          s.recvmsg_into, [bytearray(100)])\n        s.write(b\"over\\n\")\n\n        self.assertRaises(ValueError, s.recv, -1)\n        self.assertRaises(ValueError, s.read, -1)\n\n        s.close()",
    "hash_value": "9878a64ffeb1d60c0e4860c8d5aad76e"
  },
  {
    "pyfile": "test_httplib.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/greentest/3.13/test_httplib.py",
    "line_number": "484",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "483\t        conn.request('POST', '/', ())\n484\t        _, headers, body = self._parse_request(conn.sock.data)\n485\t        self.assertEqual(headers['Transfer-Encoding'], 'chunked')",
    "context_snippet": "class TransferEncodingTest(TestCase):\n    expected_body = b\"It's just a flesh wound\"\n\n    def test_endheaders_chunked(self):\n        conn = client.HTTPConnection('example.com')\n        conn.sock = FakeSocket(b'')\n        conn.putrequest('POST', '/')\n        conn.endheaders(self._make_body(), encode_chunked=True)\n\n        _, _, body = self._parse_request(conn.sock.data)\n        body = self._parse_chunked(body)\n        self.assertEqual(body, self.expected_body)\n\n    def test_explicit_headers(self):\n        # explicit chunked\n        conn = client.HTTPConnection('example.com')\n        conn.sock = FakeSocket(b'')\n        # this shouldn't actually be automatically chunk-encoded because the\n        # calling code has explicitly stated that it's taking care of it\n        conn.request(\n            'POST', '/', self._make_body(), {'Transfer-Encoding': 'chunked'})\n\n        _, headers, body = self._parse_request(conn.sock.data)\n        self.assertNotIn('content-length', [k.lower() for k in headers.keys()])\n        self.assertEqual(headers['Transfer-Encoding'], 'chunked')\n        self.assertEqual(body, self.expected_body)\n\n        # explicit chunked, string body\n        conn = client.HTTPConnection('example.com')\n        conn.sock = FakeSocket(b'')\n        conn.request(\n            'POST', '/', self.expected_body.decode('latin-1'),\n            {'Transfer-Encoding': 'chunked'})\n\n        _, headers, body = self._parse_request(conn.sock.data)\n        self.assertNotIn('content-length', [k.lower() for k in headers.keys()])\n        self.assertEqual(headers['Transfer-Encoding'], 'chunked')\n        self.assertEqual(body, self.expected_body)\n\n        # User-specified TE, but request() does the chunk encoding\n        conn = client.HTTPConnection('example.com')\n        conn.sock = FakeSocket(b'')\n        conn.request('POST', '/',\n            headers={'Transfer-Encoding': 'gzip, chunked'},\n            encode_chunked=True,\n            body=self._make_body())\n        _, headers, body = self._parse_request(conn.sock.data)\n        self.assertNotIn('content-length', [k.lower() for k in headers])\n        self.assertEqual(headers['Transfer-Encoding'], 'gzip, chunked')\n        self.assertEqual(self._parse_chunked(body), self.expected_body)\n\n    def test_request(self):\n        for empty_lines in (False, True,):\n            conn = client.HTTPConnection('example.com')\n            conn.sock = FakeSocket(b'')\n            conn.request(\n                'POST', '/', self._make_body(empty_lines=empty_lines))\n\n            _, headers, body = self._parse_request(conn.sock.data)\n            body = self._parse_chunked(body)\n            self.assertEqual(body, self.expected_body)\n            self.assertEqual(headers['Transfer-Encoding'], 'chunked')\n\n            # Content-Length and Transfer-Encoding SHOULD not be sent in the\n            # same request\n            self.assertNotIn('content-length', [k.lower() for k in headers])\n\n    def test_empty_body(self):\n        # Zero-length iterable should be treated like any other iterable\n        conn = client.HTTPConnection('example.com')\n        conn.sock = FakeSocket(b'')\n        conn.request('POST', '/', ())\n        _, headers, body = self._parse_request(conn.sock.data)\n        self.assertEqual(headers['Transfer-Encoding'], 'chunked')\n        self.assertNotIn('content-length', [k.lower() for k in headers])\n        self.assertEqual(body, b\"0\\r\\n\\r\\n\")\n\n    def _make_body(self, empty_lines=False):\n        lines = self.expected_body.split(b' ')\n        for idx, line in enumerate(lines):\n            # for testing handling empty lines\n            if empty_lines and idx % 2:\n                yield b''\n            if idx < len(lines) - 1:\n                yield line + b' '\n            else:\n                yield line\n\n    def _parse_request(self, data):\n        lines = data.split(b'\\r\\n')\n        request = lines[0]\n        headers = {}\n        n = 1\n        while n < len(lines) and len(lines[n]) > 0:\n            key, val = lines[n].split(b':')\n            key = key.decode('latin-1').strip()\n            headers[key] = val.decode('latin-1').strip()\n            n += 1\n\n        return request, headers, b'\\r\\n'.join(lines[n + 1:])\n\n    def _parse_chunked(self, data):\n        body = []\n        trailers = {}\n        n = 0\n        lines = data.split(b'\\r\\n')\n        # parse body\n        while True:\n            size, chunk = lines[n:n+2]\n            size = int(size, 16)\n\n            if size == 0:\n                n += 1\n                break\n\n            self.assertEqual(size, len(chunk))\n            body.append(chunk)\n\n            n += 2\n            # we /should/ hit the end chunk, but check against the size of\n            # lines so we're not stuck in an infinite loop should we get\n            # malformed data\n            if n > len(lines):\n                break\n\n        return b''.join(body)\n",
    "hash_value": "fa12910a7333abf5ab07e3038dda38fb"
  },
  {
    "pyfile": "test_socket.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/greentest/3.13/test_socket.py",
    "line_number": "6271",
    "type_description": "B838:process",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "6270\t        q = multiprocessing.Queue()\n6271\t        p = multiprocessing.Process(target=self.remoteProcessServer, args=(q,))\n6272\t        p.start()",
    "context_snippet": "class TestSocketSharing(SocketTCPTest):\n    # This must be classmethod and not staticmethod or multiprocessing\n    # won't be able to bootstrap it.\n    @classmethod\n    def remoteProcessServer(cls, q):\n        # Recreate socket from shared data\n        sdata = q.get()\n        message = q.get()\n\n        s = socket.fromshare(sdata)\n        s2, c = s.accept()\n\n        # Send the message\n        s2.sendall(message)\n        s2.close()\n        s.close()\n\n    def testShare(self):\n        # Transfer the listening server socket to another process\n        # and service it from there.\n\n        # Create process:\n        q = multiprocessing.Queue()\n        p = multiprocessing.Process(target=self.remoteProcessServer, args=(q,))\n        p.start()\n\n        # Get the shared socket data\n        data = self.serv.share(p.pid)\n\n        # Pass the shared socket to the other process\n        addr = self.serv.getsockname()\n        self.serv.close()\n        q.put(data)\n\n        # The data that the server will send us\n        message = b\"slapmahfro\"\n        q.put(message)\n\n        # Connect\n        s = socket.create_connection(addr)\n        #  listen for the data\n        m = []\n        while True:\n            data = s.recv(100)\n            if not data:\n                break\n            m.append(data)\n        s.close()\n        received = b\"\".join(m)\n        self.assertEqual(received, message)\n        p.join()\n\n    def testShareLength(self):\n        data = self.serv.share(os.getpid())\n        self.assertRaises(ValueError, socket.fromshare, data[:-1])\n        self.assertRaises(ValueError, socket.fromshare, data+b\"foo\")\n\n    def compareSockets(self, org, other):\n        # socket sharing is expected to work only for blocking socket\n        # since the internal python timeout value isn't transferred.\n        self.assertEqual(org.gettimeout(), None)\n        self.assertEqual(org.gettimeout(), other.gettimeout())\n\n        self.assertEqual(org.family, other.family)\n        self.assertEqual(org.type, other.type)\n        # If the user specified \"0\" for proto, then\n        # internally windows will have picked the correct value.\n        # Python introspection on the socket however will still return\n        # 0.  For the shared socket, the python value is recreated\n        # from the actual value, so it may not compare correctly.\n        if org.proto != 0:\n            self.assertEqual(org.proto, other.proto)\n\n    def testShareLocal(self):\n        data = self.serv.share(os.getpid())\n        s = socket.fromshare(data)\n        try:\n            self.compareSockets(self.serv, s)\n        finally:\n            s.close()\n\n    def testTypes(self):\n        families = [socket.AF_INET, socket.AF_INET6]\n        types = [socket.SOCK_STREAM, socket.SOCK_DGRAM]\n        for f in families:\n            for t in types:\n                try:\n                    source = socket.socket(f, t)\n                except OSError:\n                    continue # This combination is not supported\n                try:\n                    data = source.share(os.getpid())\n                    shared = socket.fromshare(data)\n                    try:\n                        self.compareSockets(source, shared)\n                    finally:\n                        shared.close()\n                finally:\n                    source.close()",
    "hash_value": "f9f7142cada192588d1dbbe46d7d7b0b"
  },
  {
    "pyfile": "test_socket.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/greentest/3.9/test_socket.py",
    "line_number": "6640",
    "type_description": "B806:sendall",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "6639\t                        return\n6640\t                    conn.sendall(msg)\n6641",
    "context_snippet": "def testCreateConnectionBase(self):\n    conn, addr = self.serv.accept()\n    self.addCleanup(conn.close)\n    data = conn.recv(1024)\n    conn.sendall(data)\n",
    "hash_value": "065fced0e4784cb276bfa22c43785b60"
  },
  {
    "pyfile": "bench_socket.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/benchmarks/bench_socket.py",
    "line_number": "99",
    "type_description": "B806:sendall",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "98\t    send, recv = gsocket.socketpair()\n99\t    return _do_sendall(loops, send, recv)\n100",
    "context_snippet": "def bench_gevent_forked_socketpair(loops):\n    send, recv = gsocket.socketpair()\n    return _do_sendall(loops, send, recv)\n\ndef _do_sendall(loops, send, recv):\n    for s in send, recv:\n        os.set_inheritable(s.fileno(), True)\n    pid = os.fork()\n    if not pid:\n        send.close()\n        recvall(recv, None)\n        recv.close()\n        sys.exit()\n        return 0\n    else:\n        try:\n            return _sendall(loops, send, BIG_DATA)\n        finally:\n            send.close()\n            recv.close()\n\ndef _sendall(loops, conn, data):\n    start = perf.perf_counter()\n    for __ in range(loops):\n        for _ in range(N):\n            conn.sendall(data)\n    taken = perf.perf_counter() - start\n    conn.close()\n    return taken\n\ndef recvall(sock, _):\n    while sock.recv(4096):\n        pass\n\nN = 10\nMB = 1024 * 1024\nlength = 50 * MB\nBIG_DATA = b\"x\" * length",
    "hash_value": "6a94172ef0a32790555984db8ec6d7c9"
  },
  {
    "pyfile": "test_socket.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/greentest/3.13/test_socket.py",
    "line_number": "5653",
    "type_description": "B808:settimeout",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "5652\t        try:\n5653\t            self.serv.settimeout(0.0)\n5654\t            foo = self.serv.accept()",
    "context_snippet": "    def testTimeoutZero(self):\n        ok = False\n        try:\n            self.serv.settimeout(0.0)\n            foo = self.serv.accept()\n        except TimeoutError:\n            self.fail(\"caught timeout instead of error (TCP)\")\n        except OSError:\n            ok = True\n        except:\n            self.fail(\"caught unexpected exception (TCP)\")\n        if not ok:\n            self.fail(\"accept() returned success when we did not expect it\")",
    "hash_value": "9331bfc7eb333609ec02aa083a8b32b3"
  },
  {
    "pyfile": "test_ssl.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/greentest/3.10/test_ssl.py",
    "line_number": "3791",
    "type_description": "B831:send",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "3790\t                while True:\n3791\t                    s.send(buf)\n3792\t            self.assertRaises((ssl.SSLWantWriteError,",
    "context_snippet": "def test_nonblocking_send(self):\n    server = ThreadedEchoServer(CERTFILE,\n                                certreqs=ssl.CERT_NONE,\n                                ssl_version=ssl.PROTOCOL_TLS_SERVER,\n                                cacerts=CERTFILE,\n                                chatty=True,\n                                connectionchatty=False)\n    with server:\n        s = test_wrap_socket(socket.socket(),\n                            server_side=False,\n                            certfile=CERTFILE,\n                            ca_certs=CERTFILE,\n                            cert_reqs=ssl.CERT_NONE)\n        s.connect((HOST, server.port))\n        s.setblocking(False)\n\n        # If we keep sending data, at some point the buffers\n        # will be full and the call will block\n        buf = bytearray(8192)\n        def fill_buffer():\n            while True:\n                s.send(buf)\n        self.assertRaises((ssl.SSLWantWriteError,\n                           ssl.SSLWantReadError), fill_buffer)\n\n        # Now read all the output and discard it\n        s.setblocking(True)\n        s.close()",
    "hash_value": "cf10c343b08b1d22aa3975d4144dc024"
  },
  {
    "pyfile": "test_httplib.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/greentest/3.9/test_httplib.py",
    "line_number": "1719",
    "type_description": "B826:getresponse",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1718\t                h.request('GET', '/')\n1719\t                resp = h.getresponse()\n1720\t            except ssl.SSLError as ssl_err:",
    "context_snippet": "def test_networked_good_cert(self):\n    # We feed the server's cert as a validating cert\n    import ssl\n    support.requires('network')\n    selfsigned_pythontestdotnet = 'self-signed.pythontest.net'\n    with socket_helper.transient_internet(selfsigned_pythontestdotnet):\n        context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        self.assertEqual(context.verify_mode, ssl.CERT_REQUIRED)\n        self.assertEqual(context.check_hostname, True)\n        context.load_verify_locations(CERT_selfsigned_pythontestdotnet)\n        try:\n            h = client.HTTPSConnection(selfsigned_pythontestdotnet, 443,\n                                       context=context)\n            h.request('GET', '/')\n            resp = h.getresponse()\n        except ssl.SSLError as ssl_err:\n            ssl_err_str = str(ssl_err)\n            # In the error message of [SSL: CERTIFICATE_VERIFY_FAILED] on\n            # modern Linux distros (Debian Buster, etc) default OpenSSL\n            # configurations it'll fail saying \"key too weak\" until we\n            # address https://bugs.python.org/issue36816 to use a proper\n            # key size on self-signed.pythontest.net.\n            if re.search(r'(?i)key.too.weak', ssl_err_str):\n                raise unittest.SkipTest(\n                    f'Got {ssl_err_str} trying to connect '\n                    f'to {selfsigned_pythontestdotnet}. '\n                    'See https://bugs.python.org/issue36816.')\n            raise\n        server_string = resp.getheader('server')\n        resp.close()\n        h.close()\n        self.assertIn('nginx', server_string)",
    "hash_value": "3931e3e60129d544de56930d902a2f7c"
  },
  {
    "pyfile": "test_ssl.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gevent-24.11.1/gevent-24.11.1/src/greentest/3.10/test_ssl.py",
    "line_number": "1950",
    "type_description": "B830:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1949\t        bio.write(memoryview(b'baz'))\n1950\t        self.assertEqual(bio.read(), b'baz')\n1951",
    "context_snippet": "    def test_buffer_types(self):\n        bio = ssl.MemoryBIO()\n        bio.write(b'foo')\n        self.assertEqual(bio.read(), b'foo')\n        bio.write(bytearray(b'bar'))\n        self.assertEqual(bio.read(), b'bar')\n        bio.write(memoryview(b'baz'))\n        self.assertEqual(bio.read(), b'baz')",
    "hash_value": "a2e8c0b9ee3db4fa23efe70db5ff14b5"
  }
]