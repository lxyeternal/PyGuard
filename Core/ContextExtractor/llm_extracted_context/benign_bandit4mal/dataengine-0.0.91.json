[
  {
    "metadata": {
      "package_name": "dataengine-0.0.91",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:40"
    }
  },
  {
    "pyfile": "redact_utils.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/dataengine-0.0.91/dataengine-0.0.91/dataengine/utilities/redact_utils.py",
    "line_number": "600",
    "type_description": "B839:pool",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "599\t    # Set processes to 1 less than cpu count\n600\t    with Pool(\n601\t        processes=max(1, multiprocessing.cpu_count() - 1)\n602\t    ) as executor:",
    "context_snippet": "def generate_redact_map(\n        text_list: List[str], redact_type: str,\n        find_function: Callable[[str], Set[Any]],\n        regex_function: Callable[[Any], re.Pattern]\n    ) -> Dict[str, Dict[str, Union[str, str]]]:\n    \"\"\"\n    Generate a redaction map for a list of text items based on specified find\n    and regex functions.\n\n    Args:\n        text_list (List[str]):\n            A list of text items to be processed for redaction.\n        redact_type (str):\n            A string indicating the type of redaction.\n        find_function (Callable[[str], List[str]]):\n            A function that takes a string and returns a set of matches.\n        regex_function (Callable[[str], str]):\n            A function that gives regex pattern that covers all permutations\n            of a certain type of string.\n\n    Returns:\n        Dict[str, Dict[str, Union[str, str]]]:\n            A dictionary containing the redaction mappings. Each key is a\n            redaction label and each value is another dictionary containing\n            the original match and its regex pattern.\n    \"\"\"\n    # Set processes to 1 less than cpu count\n    with Pool(\n        processes=max(1, multiprocessing.cpu_count() - 1)\n    ) as executor:\n        results = list(executor.map(find_function, text_list))\n    # Get unique matches\n    unique_matches = set(itertools.chain.from_iterable(results))\n    # Return redact map\n    return {\n        f\"[REDACTED:{redact_type}:{{}}]\".format(index + 1): {\n            \"original\": match, \"regex\": regex_function(match)\n        } for index, match in enumerate(unique_matches)}",
    "hash_value": "3e0d1560d829c4648c803395b7ec2e48"
  }
]