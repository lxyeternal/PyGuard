[
  {
    "metadata": {
      "package_name": "prov-2.0.1",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "test_xml.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/prov-2.0.1/prov-2.0.1/src/prov/tests/test_xml.py",
    "line_number": "308",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "307\t            with io.StringIO() as xml:\n308\t                xml.write(xml_string)\n309\t                xml.seek(0, 0)",
    "context_snippet": "def test_deserialization_example_04_and_05(self):\n    \"\"\"\n    Example 4 and 5 have a different type specification. They use an\n    xsi:type as an attribute on an entity. This can be read but if\n    written again it will become an XML child element. This is\n    semantically identical but cannot be tested with a round trip.\n    \"\"\"\n    # Example 4.\n    xml_string = \"\"\"\n    <prov:document\n        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n        xmlns:prov=\"http://www.w3.org/ns/prov#\"\n        xmlns:ex=\"http://example.com/ns/ex#\"\n        xmlns:tr=\"http://example.com/ns/tr#\">\n\n      <prov:entity prov:id=\"tr:WD-prov-dm-20111215\" xsi:type=\"prov:Plan\">\n        <prov:type xsi:type=\"xsd:QName\">ex:Workflow</prov:type>\n      </prov:entity>\n\n    </prov:document>\n    \"\"\"\n    with io.StringIO() as xml:\n        xml.write(xml_string)\n        xml.seek(0, 0)\n        actual_document = prov.ProvDocument.deserialize(source=xml, format=\"xml\")\n\n    expected_document = prov.ProvDocument()\n    ex_ns = Namespace(*EX_NS)\n    expected_document.add_namespace(ex_ns)\n    expected_document.add_namespace(*EX_TR)\n\n    # The xsi:type attribute is mapped to a proper PROV attribute.\n    expected_document.entity(\n        \"tr:WD-prov-dm-20111215\",\n        (\n            (prov.PROV_TYPE, QualifiedName(ex_ns, \"Workflow\")),\n            (prov.PROV_TYPE, PROV[\"Plan\"]),\n        ),\n    )\n\n    self.assertEqual(actual_document, expected_document, \"example_04\")\n\n    # Example 5.\n    xml_string = \"\"\"\n    <prov:document\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n      xmlns:prov=\"http://www.w3.org/ns/prov#\"\n      xmlns:ex=\"http://example.com/ns/ex#\"\n      xmlns:tr=\"http://example.com/ns/tr#\">\n\n    <prov:entity prov:id=\"tr:WD-prov-dm-20111215\" xsi:type=\"prov:Plan\">\n      <prov:type xsi:type=\"xsd:QName\">ex:Workflow</prov:type>\n      <prov:type xsi:type=\"xsd:QName\">prov:Plan</prov:type> <!-- inferred -->\n      <prov:type xsi:type=\"xsd:QName\">prov:Entity</prov:type> <!-- inferred -->\n    </prov:entity>\n\n    </prov:document>\n    \"\"\"\n    with io.StringIO() as xml:\n        xml.write(xml_string)\n        xml.seek(0, 0)\n        actual_document = prov.ProvDocument.deserialize(source=xml, format=\"xml\")\n\n    expected_document = prov.ProvDocument()\n    expected_document.add_namespace(*EX_NS)\n    expected_document.add_namespace(*EX_TR)\n\n    # The xsi:type attribute is mapped to a proper PROV attribute.\n    expected_document.entity(\n        \"tr:WD-prov-dm-20111215\",\n        (\n            (prov.PROV_TYPE, QualifiedName(ex_ns, \"Workflow\")),\n            (prov.PROV_TYPE, PROV[\"Entity\"]),\n            (prov.PROV_TYPE, PROV[\"Plan\"]),\n        ),\n    )\n\n    self.assertEqual(actual_document, expected_document, \"example_05\")",
    "hash_value": "b37367cc7811aabf5f5a7254eeb83810"
  }
]