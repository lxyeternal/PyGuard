[
  {
    "metadata": {
      "package_name": "ase-3.24.0",
      "total_matches": 4,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "abinit.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ase-3.24.0/ase-3.24.0/ase/io/abinit.py",
    "line_number": "232",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "231\t            else:\n232\t                fd.write(f\"{key} {value} {unit}\\n\")\n233",
    "context_snippet": "def write_abinit_in(fd, atoms, param=None, species=None, pseudos=None):\n    from ase.calculators.calculator import kpts2mp\n\n    if param is None:\n        param = {}\n\n    if species is None:\n        species = sorted(set(atoms.numbers))\n\n    inp = dict(param)\n    xc = inp.pop('xc', 'LDA')\n    for key in ['smearing', 'kpts', 'pps', 'raw']:\n        inp.pop(key, None)\n\n    smearing = param.get('smearing')\n    if 'tsmear' in param or 'occopt' in param:\n        assert smearing is None\n\n    if smearing is not None:\n        inp['occopt'] = {'fermi-dirac': 3,\n                         'gaussian': 7}[smearing[0].lower()]\n        inp['tsmear'] = smearing[1]\n\n    inp['natom'] = len(atoms)\n\n    if 'nbands' in param:\n        inp['nband'] = param['nbands']\n        del inp['nbands']\n\n    # ixc is set from paw/xml file. Ignore 'xc' setting then.\n    if param.get('pps') not in ['pawxml']:\n        if 'ixc' not in param:\n            inp['ixc'] = {'LDA': 7,\n                          'PBE': 11,\n                          'revPBE': 14,\n                          'RPBE': 15,\n                          'WC': 23}[xc]\n\n    magmoms = atoms.get_initial_magnetic_moments()\n    if magmoms.any():\n        inp['nsppol'] = 2\n        fd.write('spinat\\n')\n        for n, M in enumerate(magmoms):\n            fd.write(f'{0:.14f} {0:.14f} {M:.14f}\\n')\n    else:\n        inp['nsppol'] = 1\n\n    if param.get('kpts') is not None:\n        mp = kpts2mp(atoms, param['kpts'])\n        fd.write('kptopt 1\\n')\n        fd.write('ngkpt %d %d %d\\n' % tuple(mp))\n        fd.write('nshiftk 1\\n')\n        fd.write('shiftk\\n')\n        fd.write('%.1f %.1f %.1f\\n' % tuple((np.array(mp) + 1) % 2 * 0.5))\n\n    valid_lists = (list, np.ndarray)\n    for key in sorted(inp):\n        value = inp[key]\n        unit = keys_with_units.get(key)\n        if unit is not None:\n            if 'fs**2' in unit:\n                value /= fs**2\n            elif 'fs' in unit:\n                value /= fs\n        if isinstance(value, valid_lists):\n            if isinstance(value[0], valid_lists):\n                fd.write(f\"{key}\\n\")\n                for dim in value:\n                    write_list(fd, dim, unit)\n            else:\n                fd.write(f\"{key}\\n\")\n                write_list(fd, value, unit)\n        else:\n            if unit is None:\n                fd.write(f\"{key} {value}\\n\")\n            else:\n                fd.write(f\"{key} {value} {unit}\\n\")\n\n    if param.get('raw') is not None:\n        if isinstance(param['raw'], str):\n            raise TypeError('The raw parameter is a single string; expected '\n                            'a sequence of lines')\n        for line in param['raw']:\n            if isinstance(line, tuple):\n                fd.write(' '.join([f'{x}' for x in line]) + '\\n')\n            else:\n                fd.write(f'{line}\\n')\n\n    fd.write('#Definition of the unit cell\\n')\n    fd.write('acell\\n')\n    fd.write(f'{1.0:.14f} {1.0:.14f} {1.0:.14f} Angstrom\\n')\n    fd.write('rprim\\n')\n    if atoms.cell.rank != 3:\n        raise RuntimeError('Abinit requires a 3D cell, but cell is {}'\n                           .format(atoms.cell))\n    for v in atoms.cell:\n        fd.write('%.14f %.14f %.14f\\n' % tuple(v))\n\n    fd.write('chkprim 0 # Allow non-primitive cells\\n')\n\n    fd.write('#Definition of the atom types\\n')\n    fd.write('ntypat %d\\n' % (len(species)))\n    fd.write('znucl {}\\n'.format(' '.join(str(Z) for Z in species)))\n    fd.write('#Enumerate different atomic species\\n')\n    fd.write('typat')\n    fd.write('\\n')\n\n    types = []\n    for Z in atoms.numbers:\n        for n, Zs in enumerate(species):\n            if Z == Zs:\n                types.append(n + 1)\n    n_entries_int = 20  # integer entries per line\n    for n, type in enumerate(types):\n        fd.write(' %d' % (type))\n        if n > 1 and ((n % n_entries_int) == 1):\n            fd.write('\\n')\n    fd.write('\\n')\n\n    if pseudos is not None:\n        listing = ',\\n'.join(pseudos)\n        line = f'pseudos \"{listing}\"\\n'\n        fd.write(line)\n\n    fd.write('#Definition of the atoms\\n')\n    fd.write('xcart\\n')\n    for pos in atoms.positions / Bohr:\n        fd.write('%.14f %.14f %.14f\\n' % tuple(pos))\n\n    fd.write('chkexit 1 # abinit.exit file in the running '\n             'directory terminates after the current SCF\\n')\n\ndef write_list(fd, value, unit):\n    for element in value:\n        fd.write(f\"{element} \")\n    if unit is not None:\n        fd.write(f\"{unit}\")\n    fd.write(\"\\n\")\n\nkeys_with_units = {\n    'toldfe': 'eV',\n    'tsmear': 'eV',\n    'paoenergyshift': 'eV',\n    'zmunitslength': 'Bohr',\n    'zmunitsangle': 'rad',\n    'zmforcetollength': 'eV/Ang',\n    'zmforcetolangle': 'eV/rad',\n    'zmmaxdispllength': 'Ang',\n    'zmmaxdisplangle': 'rad',\n    'ecut': 'eV',\n    'pawecutdg': 'eV',\n    'dmenergytolerance': 'eV',\n    'electronictemperature': 'eV',\n    'oneta': 'eV',\n    'onetaalpha': 'eV',\n    'onetabeta': 'eV',\n    'onrclwf': 'Ang',\n    'onchemicalpotentialrc': 'Ang',\n    'onchemicalpotentialtemperature': 'eV',\n    'mdmaxcgdispl': 'Ang',\n    'mdmaxforcetol': 'eV/Ang',\n    'mdmaxstresstol': 'eV/Ang**3',\n    'mdlengthtimestep': 'fs',\n    'mdinitialtemperature': 'eV',\n    'mdtargettemperature': 'eV',\n    'mdtargetpressure': 'eV/Ang**3',\n    'mdnosemass': 'eV*fs**2',\n    'mdparrinellorahmanmass': 'eV*fs**2',\n    'mdtaurelax': 'fs',\n    'mdbulkmodulus': 'eV/Ang**3',\n    'mdfcdispl': 'Ang',\n    'warningminimumatomicdistance': 'Ang',\n    'rcspatial': 'Ang',\n    'kgridcutoff': 'Ang',\n    'latticeconstant': 'Ang'}",
    "hash_value": "fe16663977c93360b2ce0d129d1e1038"
  },
  {
    "pyfile": "vasp_auxiliary.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ase-3.24.0/ase-3.24.0/ase/calculators/vasp/vasp_auxiliary.py",
    "line_number": "214",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "213\t                for dim in chg.shape:\n214\t                    fd.write(' %4i' % dim)\n215\t                fd.write('\\n')",
    "context_snippet": "def write(self, filename, format=None):\n    \"\"\"Write VASP charge density in CHG format.\n\n    filename: str\n        Name of file to write to.\n    format: str\n        String specifying whether to write in CHGCAR or CHG\n        format.\n\n    \"\"\"\n    import ase.io.vasp as aiv\n    if format is None:\n        if filename.lower().find('chgcar') != -1:\n            format = 'chgcar'\n        elif filename.lower().find('chg') != -1:\n            format = 'chg'\n        elif len(self.chg) == 1:\n            format = 'chgcar'\n        else:\n            format = 'chg'\n    with open(filename, 'w') as fd:\n        for ii, chg in enumerate(self.chg):\n            if format == 'chgcar' and ii != len(self.chg) - 1:\n                continue  # Write only the last image for CHGCAR\n            aiv.write_vasp(fd,\n                           self.atoms[ii],\n                           direct=True)\n            fd.write('\\n')\n            for dim in chg.shape:\n                fd.write(' %4i' % dim)\n            fd.write('\\n')\n            vol = self.atoms[ii].get_volume()\n            self._write_chg(fd, chg, vol, format)\n            if format == 'chgcar':\n                fd.write(self.aug)\n            if self.is_spin_polarized():\n                if format == 'chg':\n                    fd.write('\\n')\n                for dim in chg.shape:\n                    fd.write(' %4i' % dim)\n                fd.write('\\n')  # a new line after dim is required\n                self._write_chg(fd, self.chgdiff[ii], vol, format)\n                if format == 'chgcar':\n                    # a new line is always provided self._write_chg\n                    fd.write(self.augdiff)\n            if format == 'chg' and len(self.chg) > 1:\n                fd.write('\\n')",
    "hash_value": "2d21780fd93c296ded6eba37473ddfa8"
  },
  {
    "pyfile": "dftb.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ase-3.24.0/ase-3.24.0/ase/calculators/dftb.py",
    "line_number": "258",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "257\t                outfile.write(3 * (1 + my_backslash) * myspace + '} \\n')\n258\t            outfile.write(3 * current_depth * myspace)\n259\t            if key.endswith('_') and len(value) > 0:",
    "context_snippet": "def write_dftb_in(self, outfile):\n    \"\"\" Write the innput file for the dftb+ calculation.\n        Geometry is taken always from the file 'geo_end.gen'.\n    \"\"\"\n\n    outfile.write('Geometry = GenFormat { \\n')\n    outfile.write('    <<< \"geo_end.gen\" \\n')\n    outfile.write('} \\n')\n    outfile.write(' \\n')\n\n    params = self.parameters.copy()\n\n    s = 'Hamiltonian_MaxAngularMomentum_'\n    for key in params:\n        if key.startswith(s) and len(key) > len(s):\n            break\n    else:\n        if params.get('Hamiltonian_', 'DFTB') == 'DFTB':\n            # User didn't specify max angular mometa.  Get them from\n            # the .skf files:\n            symbols = set(self.atoms.get_chemical_symbols())\n            for symbol in symbols:\n                path = os.path.join(self.slako_dir,\n                                    '{0}-{0}.skf'.format(symbol))\n                l = read_max_angular_momentum(path)\n                params[s + symbol] = '\"{}\"'.format('spdf'[l])\n\n    if self.do_forces:\n        params['Analysis_'] = ''\n        params['Analysis_CalculateForces'] = 'Yes'\n\n    # --------MAIN KEYWORDS-------\n    previous_key = 'dummy_'\n    myspace = ' '\n    for key, value in sorted(params.items()):\n        current_depth = key.rstrip('_').count('_')\n        previous_depth = previous_key.rstrip('_').count('_')\n        for my_backslash in reversed(\n                range(previous_depth - current_depth)):\n            outfile.write(3 * (1 + my_backslash) * myspace + '} \\n')\n        outfile.write(3 * current_depth * myspace)\n        if key.endswith('_') and len(value) > 0:\n            outfile.write(key.rstrip('_').rsplit('_')[-1] +\n                          ' = ' + str(value) + '{ \\n')\n        elif (key.endswith('_') and (len(value) == 0)\n              and current_depth == 0):  # E.g. 'Options {'\n            outfile.write(key.rstrip('_').rsplit('_')[-1] +\n                          ' ' + str(value) + '{ \\n')\n        elif (key.endswith('_') and (len(value) == 0)\n              and current_depth > 0):  # E.g. 'Hamiltonian_Max... = {'\n            outfile.write(key.rstrip('_').rsplit('_')[-1] +\n                          ' = ' + str(value) + '{ \\n')\n        elif key.count('_empty') == 1:\n            outfile.write(str(value) + ' \\n')\n        elif ((key == 'Hamiltonian_ReadInitialCharges') and\n              (str(value).upper() == 'YES')):\n            f1 = os.path.isfile(self.directory + os.sep + 'charges.dat')\n            f2 = os.path.isfile(self.directory + os.sep + 'charges.bin')\n            if not (f1 or f2):\n                print('charges.dat or .bin not found, switching off guess')\n                value = 'No'\n            outfile.write(key.rsplit('_')[-1] + ' = ' + str(value) + ' \\n')\n        else:\n            outfile.write(key.rsplit('_')[-1] + ' = ' + str(value) + ' \\n')\n        if self.pcpot is not None and ('DFTB' in str(value)):\n            outfile.write('   ElectricField = { \\n')\n            outfile.write('      PointCharges = { \\n')\n            outfile.write(\n                '         CoordsAndCharges [Angstrom] = DirectRead { \\n')\n            outfile.write('            Records = ' +\n                          str(len(self.pcpot.mmcharges)) + ' \\n')\n            outfile.write(\n                '            File = \"dftb_external_charges.dat\" \\n')\n            outfile.write('         } \\n')\n            outfile.write('      } \\n')\n            outfile.write('   } \\n')\n        previous_key = key\n    current_depth = key.rstrip('_').count('_')\n    for my_backslash in reversed(range(current_depth)):\n        outfile.write(3 * my_backslash * myspace + '} \\n')",
    "hash_value": "fcc18afe7248970df1f9b9cb837d7b10"
  },
  {
    "pyfile": "castep.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ase-3.24.0/ase-3.24.0/ase/calculators/castep.py",
    "line_number": "1177",
    "type_description": "B837:rmdir",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1176\t            if os.listdir(self._directory) == []:\n1177\t                os.rmdir(self._directory)\n1178\t            else:",
    "context_snippet": "def prepare_input_files(self, atoms=None, force_write=None):\n    \"\"\"Only writes the input .cell and .param files and return\n    This can be useful if one quickly needs to prepare input files\n    for a cluster where no python or ASE is available. One can than\n    upload the file manually and read out the results using\n    Castep().read().\n    \"\"\"\n\n    if self.param.reuse.value is None:\n        if self._pedantic:\n            warnings.warn(\n                'You have not set e.g. calc.param.reuse = True. '\n                'Reusing a previous calculation may save CPU time! '\n                'The interface will make sure by default, .check exists. '\n                'file before adding this statement to the .param file.')\n    if self.param.num_dump_cycles.value is None:\n        if self._pedantic:\n            warnings.warn(\n                'You have not set e.g. calc.param.num_dump_cycles = 0. '\n                'This can save you a lot of disk space. One only needs '\n                '*wvfn* if electronic convergence is not achieved.')\n    from ase.io.castep import write_param\n\n    if atoms is None:\n        atoms = self.atoms\n    else:\n        self.atoms = atoms\n\n    if force_write is None:\n        force_write = self._force_write\n\n    # if we have new instance of the calculator,\n    # move existing results out of the way, first\n    if (os.path.isdir(self._directory)\n            and self._calls == 0\n            and self._rename_existing_dir):\n        if os.listdir(self._directory) == []:\n            os.rmdir(self._directory)\n        else:\n            # rename appending creation date of the directory\n            ctime = time.localtime(os.lstat(self._directory).st_ctime)\n            os.rename(self._directory, '%s.bak-%s' %\n                      (self._directory,\n                       time.strftime('%Y%m%d-%H%M%S', ctime)))\n\n    # create work directory\n    if not os.path.isdir(self._directory):\n        os.makedirs(self._directory, 0o775)\n\n    # we do this every time, not only upon first call\n    # if self._calls == 0:\n    self._fetch_pspots()\n\n    # if _try_reuse is requested and this\n    # is not the first run, we try to find\n    # the .check file from the previous run\n    # this is only necessary if _track_output\n    # is set to true\n    if self._try_reuse and self._calls > 0:\n        if os.path.exists(self._abs_path(self._check_file)):\n            self.param.reuse = self._check_file\n        elif os.path.exists(self._abs_path(self._castep_bin_file)):\n            self.param.reuse = self._castep_bin_file\n    self._seed = self._build_castep_seed()\n    self._check_file = f'{self._seed}.check'\n    self._castep_bin_file = f'{self._seed}.castep_bin'\n    self._castep_file = self._abs_path(f'{self._seed}.castep')\n\n    # write out the input file\n    magnetic_moments = ('initial' if\n                        self.param.spin_polarized.value == 'TRUE'\n                        else None)\n    self._write_cell(self._abs_path(f'{self._seed}.cell'),\n                     self.atoms, castep_cell=self.cell,\n                     magnetic_moments=magnetic_moments)\n\n    if self._export_settings:\n        interface_options = self._opt\n    else:\n        interface_options = None\n    write_param(self._abs_path(f'{self._seed}.param'), self.param,\n                check_checkfile=self._check_checkfile,\n                force_write=force_write,\n                interface_options=interface_options,)\n",
    "hash_value": "e18c374450ff5add470bdcf2415b013c"
  }
]