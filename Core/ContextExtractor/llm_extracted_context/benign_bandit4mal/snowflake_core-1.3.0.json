[
  {
    "metadata": {
      "package_name": "snowflake_core-1.3.0",
      "total_matches": 6,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "api_client.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/snowflake_core-1.3.0/snowflake_core-1.3.0/src/snowflake/core/cortex/inference_service/_generated/api_client.py",
    "line_number": "563",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "562\t                logger.info(\n563\t                    f\"{snowflake.core._http_requests.STATUS_CODES_MAPPING.get(response_data.status)} query completed\"\n564\t                )",
    "context_snippet": "def request_with_retry(self,\n                       root,\n                       method,\n                       url,\n                       query_params=None,\n                       headers=None,\n                       post_params=None,\n                       body=None,\n                       _preload_content=True,\n                       _request_timeout=None):\n    \"\"\"Response time by default one hour.\"\"\"\n    enter_timing = time.time()\n    response_data = self.request(root,\n                                 method,\n                                 url,\n                                 query_params=query_params,\n                                 headers=headers,\n                                 post_params=post_params,\n                                 body=body,\n                                 _preload_content=_preload_content,\n                                 _request_timeout=_request_timeout)\n\n    if not root.parameters(\n    ).should_retry_request or response_data.status not in rest.RETRY_STATUS_CODES:\n        return response_data\n\n    logger.info(\n        f\"Request Status {response_data.status} ({snowflake.core._http_requests.STATUS_CODES_MAPPING.get(response_data.status)}) Retrying...\"\n    )\n    # Query retry support\n    result_endpoint = response_data.getheader('Location')\n    if response_data.status == 202 and result_endpoint is None:\n        raise InvalidResponseError(\n            f\"{snowflake.core._http_requests.STATUS_CODES_MAPPING.get(response_data.status)} result endpoint is missing\"\n        )\n\n    if _request_timeout is None:\n        _request_timeout = snowflake.core._http_requests.DEFAULT_RETRY_TIMEOUT_SECONDS\n    wait_for_results_timeout = enter_timing + _request_timeout\n\n    exponential_wait_time = 1  # wait time increases exponentially, 30% more everytime\n    while True:\n        time_remaining = wait_for_results_timeout - time.time()\n        if time_remaining <= 0:\n            break\n        # Full Jitter\n        # ref: https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\n        # Take max(1, wait_time) to avoid making too many requests in a short period\n        wait_time = max(\n            1,\n            random.randint(0,\n                           int(min(exponential_wait_time,\n                                   time_remaining))))\n\n        if response_data.status in rest.RETRY_STATUS_CODES:\n            logger.info(\n                f\"{snowflake.core._http_requests.STATUS_CODES_MAPPING.get(response_data.status)} detected. Sleeping for {wait_time} seconds before checking again\"\n            )\n\n            time.sleep(wait_time)\n\n            new_url = url\n            if response_data.status == 202:\n                new_url = self.configuration.host + result_endpoint\n                method = \"GET\"\n\n            response_data = self.request(\n                root,\n                method,\n                new_url,\n                query_params=query_params,\n                headers=headers,\n                post_params=post_params,\n                body=body,\n                _preload_content=_preload_content,\n                _request_timeout=max(time_remaining - wait_time, 1)\n                # request_timeout can never be zero\n            )\n        else:\n            logger.info(\n                f\"{snowflake.core._http_requests.STATUS_CODES_MAPPING.get(response_data.status)} query completed\"\n            )\n            return response_data\n\n        exponential_wait_time *= 1.3\n\n    raise RetryTimeoutError(\n        f\"{response_data.status} {snowflake.core._http_requests.STATUS_CODES_MAPPING.get(response_data.status)} query timeout\"\n    )",
    "hash_value": "b0a7fca946d6c9040ee9ef8acd931f66"
  },
  {
    "pyfile": "rest.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/snowflake_core-1.3.0/snowflake_core-1.3.0/src/snowflake/core/stage/_generated/rest.py",
    "line_number": "403",
    "type_description": "B822:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "402\t        query_params = query_params or {}\n403\t        response_dict = _snowflake.send_snow_api_request(\n404\t            method, parsed_url.path, dict(query_params), headers, body,\n405\t            post_params, _request_timeout)\n406\t        json_content = json.loads(response_dict[\"content\"])",
    "context_snippet": "def request(\n    self,\n    root,\n    method,\n    url,\n    query_params={},\n    headers={},\n    body={},\n    post_params={},\n    _preload_content=True,\n    _request_timeout=None,\n):\n    \"\"\"Perform requests.\n    :param method: http request method\n    :param url: http request url\n    :param query_params: query parameters in the url\n    :param headers: http request headers\n    :param body: request json body, for `application/json`\n    :param post_params: request post parameters,\n                        `application/x-www-form-urlencoded`\n                        and `multipart/form-data`\n    :param _preload_content: if False, the urllib3.HTTPResponse object will\n                             be returned without reading/decoding response\n                             data. Default is True.\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    \"\"\"\n    method = method.upper()\n    assert method in [\n        'GET', 'HEAD', 'DELETE', 'POST', 'PUT', 'PATCH', 'OPTIONS'\n    ]\n    import _snowflake\n    parsed_url = urllib3.util.parse_url(url)\n    query_params = query_params or {}\n    response_dict = _snowflake.send_snow_api_request(\n        method, parsed_url.path, dict(query_params), headers, body,\n        post_params, _request_timeout)\n    json_content = json.loads(response_dict[\"content\"])\n    if self._is_correct_xp_request(json_content):\n        r = urllib3.HTTPResponse(body=json.dumps(json_content[\"data\"]))\n    else:\n        r = urllib3.HTTPResponse(\n            body=json.dumps(json_content).encode(\"utf-8\"))\n    r.status = response_dict[\"status\"]\n    formatted_headers = {\n        key.strip(): value\n        for key, value in response_dict[\"headers\"].items()\n    }\n    r.headers = formatted_headers\n    logger.info(\n        \"Received an HTTP response of status %d\",\n        r.status,\n    )\n    if _preload_content:\n        r = RESTResponse(r)\n        # log response body\n        logger.debug(\"response body: %s\", r.data)\n\n    return evaluate_status_codes(root, r)",
    "hash_value": "235ec11125ea7e29f54c962e721c0086"
  },
  {
    "pyfile": "rest.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/snowflake_core-1.3.0/snowflake_core-1.3.0/src/snowflake/core/alert/_generated/rest.py",
    "line_number": "285",
    "type_description": "B822:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "284\t                       _request_timeout=None):\n285\t        return self.request(\n286\t            root,\n287\t            \"DELETE\",\n288\t            url,\n289\t            headers=headers,\n290\t            query_params=query_params,\n291\t            _preload_content=_preload_content,\n292\t            _request_timeout=_request_timeout,\n293\t            body=body,\n294\t        )",
    "context_snippet": "def delete_request(self,\n                   root,\n                   url,\n                   headers=None,\n                   query_params=None,\n                   body=None,\n                   _preload_content=True,\n                   _request_timeout=None):\n    return self.request(\n        root,\n        \"DELETE\",\n        url,\n        headers=headers,\n        query_params=query_params,\n        _preload_content=_preload_content,\n        _request_timeout=_request_timeout,\n        body=body,\n    )",
    "hash_value": "a6bff825311447ca3db5591e707d5747"
  },
  {
    "pyfile": "rest.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/snowflake_core-1.3.0/snowflake_core-1.3.0/src/snowflake/core/managed_account/_generated/rest.py",
    "line_number": "181",
    "type_description": "B822:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "180\t                    request_body = body\n181\t                    r = self.pool_manager.request(\n182\t                        root,\n183\t                        method,\n184\t                        url,\n185\t                        body=request_body,\n186\t                        preload_content=_preload_content,\n187\t                        timeout=timeout,\n188\t                        headers=headers)\n189\t                else:",
    "context_snippet": "def request(\n        self,\n        root,\n        method,\n        url,\n        query_params=None,\n        headers=None,\n        body=None,\n        post_params=None,\n        _preload_content=True,\n        _request_timeout=None,\n    ):\n        \"\"\"Perform requests.\n\n        :param method: http request method\n        :param url: http request url\n        :param query_params: query parameters in the url\n        :param headers: http request headers\n        :param body: request json body, for `application/json`\n        :param post_params: request post parameters,\n                            `application/x-www-form-urlencoded`\n                            and `multipart/form-data`\n        :param _preload_content: if False, the urllib3.HTTPResponse object will\n                                 be returned without reading/decoding response\n                                 data. Default is True.\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        \"\"\"\n        method = method.upper()\n        assert method in [\n            'GET', 'HEAD', 'DELETE', 'POST', 'PUT', 'PATCH', 'OPTIONS'\n        ]\n\n        if post_params and body:\n            raise _APIValueError(\n                \"body parameter cannot be used with post_params parameter.\")\n\n        post_params = post_params or {}\n        headers = headers or {}\n        # url already contains the URL query string\n        # so reset query_params to empty dict\n        query_params = {}\n\n        timeout = None\n        if _request_timeout:\n            if isinstance(_request_timeout, (int, float)):  # noqa: E501,F821\n                timeout = urllib3.Timeout(total=_request_timeout)\n            elif (isinstance(_request_timeout, tuple)\n                  and len(_request_timeout) == 2):\n                timeout = urllib3.Timeout(connect=_request_timeout[0],\n                                          read=_request_timeout[1])\n\n        try:\n            # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`\n            if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:\n\n                # no content type provided or payload is json\n                if not headers.get('Content-Type') or re.search(\n                        'json', headers['Content-Type'], re.IGNORECASE):\n                    request_body = None\n                    if body is not None:\n                        request_body = json.dumps(body)\n                    r = self.pool_manager.request(\n                        root,\n                        method,\n                        url,\n                        body=request_body,\n                        preload_content=_preload_content,\n                        timeout=timeout,\n                        headers=headers)\n                elif headers[\n                        'Content-Type'] == 'application/x-www-form-urlencoded':  # noqa: E501\n                    r = self.pool_manager.request(\n                        root,\n                        method,\n                        url,\n                        fields=post_params,\n                        encode_multipart=False,\n                        preload_content=_preload_content,\n                        timeout=timeout,\n                        headers=headers)\n                elif headers['Content-Type'] == 'multipart/form-data':\n                    # must del headers['Content-Type'], or the correct\n                    # Content-Type which generated by urllib3 will be\n                    # overwritten.\n                    del headers['Content-Type']\n                    r = self.pool_manager.request(\n                        root,\n                        method,\n                        url,\n                        fields=post_params,\n                        encode_multipart=True,\n                        preload_content=_preload_content,\n                        timeout=timeout,\n                        headers=headers)\n                # Pass a `string` parameter directly in the body to support\n                # other content types than Json when `body` argument is\n                # provided in serialized form\n                elif isinstance(body, str) or isinstance(body, bytes):\n                    request_body = body\n                    r = self.pool_manager.request(\n                        root,\n                        method,\n                        url,\n                        body=request_body,\n                        preload_content=_preload_content,\n                        timeout=timeout,\n                        headers=headers)\n                else:\n                    # Cannot generate the request from given parameters\n                    msg = \"\"\"Cannot prepare a request message for provided\n                             arguments. Please check that your arguments match\n                             declared content type.\"\"\"\n                    raise APIError(status=0, reason=msg, root=root)\n            # For `GET`, `HEAD`\n            else:\n                r = self.pool_manager.request(\n                    root,\n                    method,\n                    url,\n                    fields={},\n                    preload_content=_preload_content,\n                    timeout=timeout,\n                    headers=headers,\n                )\n        except urllib3.exceptions.SSLError as e:\n            msg = \"{0}\\n{1}\".format(type(e).__name__, str(e))\n            raise APIError(status=0, reason=msg, root=root)\n\n        if _preload_content:\n            r = RESTResponse(r)\n\n            # log response body\n            logger.debug(\"response body: %s\", r.data)\n\n        return evaluate_status_codes(root, r)",
    "hash_value": "6fb81a9187bdd7e05d24f27eb2f6ef0b"
  },
  {
    "pyfile": "rest.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/snowflake_core-1.3.0/snowflake_core-1.3.0/src/snowflake/core/grant/_generated/rest.py",
    "line_number": "522",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "521\t    ):\n522\t        return self.request(\n523\t            root,\n524\t            \"POST\",\n525\t            url,\n526\t            headers=headers,\n527\t            query_params=query_params,\n528\t            post_params=post_params,\n529\t            _preload_content=_preload_content,\n530\t            _request_timeout=_request_timeout,\n531\t            body=body,\n532\t        )",
    "context_snippet": "def post_request(self,\n                 root,\n                 url,\n                 headers=None,\n                 query_params=None,\n                 post_params=None,\n                 body=None,\n                 _preload_content=True,\n                 _request_timeout=None):\n    return self.request(\n        root,\n        \"POST\",\n        url,\n        headers=headers,\n        query_params=query_params,\n        post_params=post_params,\n        _preload_content=_preload_content,\n        _request_timeout=_request_timeout,\n        body=body,\n    )",
    "hash_value": "210959e601f1862baf8acb5dd9456041"
  },
  {
    "pyfile": "api_client.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/snowflake_core-1.3.0/snowflake_core-1.3.0/src/snowflake/core/cortex/chat_service/_generated/api_client.py",
    "line_number": "656",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "655\t        elif method == \"DELETE\":\n656\t            return self.rest_client.delete_request(\n657\t                root,\n658\t                url,\n659\t                query_params=query_params,\n660\t                headers=headers,\n661\t                _preload_content=_preload_content,\n662\t                _request_timeout=_request_timeout,\n663\t                body=body,\n664\t            )",
    "context_snippet": "def request(self,\n            root,\n            method,\n            url,\n            query_params=None,\n            headers=None,\n            post_params=None,\n            body=None,\n            _preload_content=True,\n            _request_timeout=None):\n    \"\"\"Makes the HTTP request using RESTClient.\"\"\"\n    if method == \"GET\":\n        return self.rest_client.get_request(\n            root,\n            url,\n            query_params=query_params,\n            _preload_content=_preload_content,\n            _request_timeout=_request_timeout,\n            headers=headers,\n        )\n    elif method == \"HEAD\":\n        return self.rest_client.head_request(\n            root,\n            url,\n            query_params=query_params,\n            _preload_content=_preload_content,\n            _request_timeout=_request_timeout,\n            headers=headers,\n        )\n    elif method == \"OPTIONS\":\n        return self.rest_client.options_request(\n            root,\n            url,\n            query_params=query_params,\n            headers=headers,\n            _preload_content=_preload_content,\n            _request_timeout=_request_timeout,\n        )\n    elif method == \"POST\":\n        return self.rest_client.post_request(\n            root,\n            url,\n            query_params=query_params,\n            headers=headers,\n            post_params=post_params,\n            _preload_content=_preload_content,\n            _request_timeout=_request_timeout,\n            body=body,\n        )\n    elif method == \"PUT\":\n        try:\n            return self.rest_client.put_request(\n                root,\n                url,\n                query_params=query_params,\n                headers=headers,\n                post_params=post_params,\n                _preload_content=_preload_content,\n                _request_timeout=_request_timeout,\n                body=body,\n            )\n        except APIError as error:\n            # Raise a more helpful user error if CoA is not supported for this resource;\n            # this is represented as either 405 or 501 on the server.\n            if error.status in (405, 501):\n                raise NotImplementedError(\n                    'create_or_update is not yet supported for chat_service. Updating chat_service '\n                    'objects is not supported yet; use create() for creating a chat_service.'\n                )\n            raise\n\n    elif method == \"PATCH\":\n        return self.rest_client.patch_request(\n            root,\n            url,\n            query_params=query_params,\n            headers=headers,\n            post_params=post_params,\n            _preload_content=_preload_content,\n            _request_timeout=_request_timeout,\n            body=body,\n        )\n    elif method == \"DELETE\":\n        return self.rest_client.delete_request(\n            root,\n            url,\n            query_params=query_params,\n            headers=headers,\n            _preload_content=_preload_content,\n            _request_timeout=_request_timeout,\n            body=body,\n        )\n    else:\n        raise _APIValueError(\n            \"http method must be `GET`, `HEAD`, `OPTIONS`,\"\n            \" `POST`, `PATCH`, `PUT` or `DELETE`.\")",
    "hash_value": "3f261bc6405afcbcd78fb26d4a9912d6"
  }
]