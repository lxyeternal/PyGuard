[
  {
    "metadata": {
      "package_name": "asyncio-3.4.3",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "test_unix_events.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/asyncio-3.4.3/asyncio-3.4.3/tests/test_unix_events.py",
    "line_number": "518",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "517\t        m_write.return_value = 4\n518\t        tr.write(b'data')\n519\t        m_write.assert_called_with(5, b'data')",
    "context_snippet": "@mock.patch('os.write')\n    def test_write(self, m_write):\n        tr = self.write_pipe_transport()\n        m_write.return_value = 4\n        tr.write(b'data')\n        m_write.assert_called_with(5, b'data')\n        self.assertFalse(self.loop.writers)\n        self.assertEqual([], tr._buffer)",
    "hash_value": "bbf2154436ff15712639a88ca84ad55c"
  },
  {
    "pyfile": "proactor_events.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/asyncio-3.4.3/asyncio-3.4.3/asyncio/proactor_events.py",
    "line_number": "523",
    "type_description": "B807:close",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "522\t                    })\n523\t                    sock.close()\n524\t                elif self._debug:",
    "context_snippet": "def _start_serving(self, protocol_factory, sock,\n                   sslcontext=None, server=None):\n\n    def loop(f=None):\n        try:\n            if f is not None:\n                conn, addr = f.result()\n                if self._debug:\n                    logger.debug(\"%r got a new connection from %r: %r\",\n                                 server, addr, conn)\n                protocol = protocol_factory()\n                if sslcontext is not None:\n                    self._make_ssl_transport(\n                        conn, protocol, sslcontext, server_side=True,\n                        extra={'peername': addr}, server=server)\n                else:\n                    self._make_socket_transport(\n                        conn, protocol,\n                        extra={'peername': addr}, server=server)\n            if self.is_closed():\n                return\n            f = self._proactor.accept(sock)\n        except OSError as exc:\n            if sock.fileno() != -1:\n                self.call_exception_handler({\n                    'message': 'Accept failed on a socket',\n                    'exception': exc,\n                    'socket': sock,\n                })\n                sock.close()\n            elif self._debug:\n                logger.debug(\"Accept failed on socket %r\",\n                             sock, exc_info=True)\n        except futures.CancelledError:\n            sock.close()\n        else:\n            self._accept_futures[sock.fileno()] = f\n            f.add_done_callback(loop)\n\n    self.call_soon(loop)",
    "hash_value": "9931b59a534916cc64aa076efde4ef88"
  }
]