[
  {
    "metadata": {
      "package_name": "pyatlan-6.0.2",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "atlan.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pyatlan-6.0.2/pyatlan-6.0.2/pyatlan/client/atlan.py",
    "line_number": "546",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "545\t                    causes = error_info.get(\"causes\", [])\n546\t                    backend_error_id = error_info.get(\"errorId\")\n547",
    "context_snippet": "def _call_api_internal(\n        self,\n        api,\n        path,\n        params,\n        binary_data=None,\n        download_file_path=None,\n        text_response=False,\n    ):\n        token = request_id_var.set(str(uuid.uuid4()))\n        try:\n            params[\"headers\"][\"X-Atlan-Request-Id\"] = request_id_var.get()\n            if binary_data:\n                response = self._session.request(\n                    api.method.value,\n                    path,\n                    data=binary_data,\n                    **params,\n                    timeout=(self.connect_timeout, self.read_timeout),\n                )\n            elif api.consumes == EVENT_STREAM and api.produces == EVENT_STREAM:\n                response = self._session.request(\n                    api.method.value,\n                    path,\n                    **params,\n                    stream=True,\n                    timeout=(self.connect_timeout, self.read_timeout),\n                )\n                if download_file_path:\n                    return self._handle_file_download(response.raw, download_file_path)\n            else:\n                response = self._session.request(\n                    api.method.value,\n                    path,\n                    **params,\n                    timeout=(self.connect_timeout, self.read_timeout),\n                )\n            if response is not None:\n                LOGGER.debug(\"HTTP Status: %s\", response.status_code)\n            if response is None:\n                return None\n\n            # Reset `has_retried` flag if:\n            # - SDK already attempted a 401 token refresh (`has_retried = True`)\n            # - and the current response status code is NOT 401\n            #\n            # Real-world scenario:\n            # - First 401 triggers `_handle_401_token_refresh`, setting `has_retried = True`\n            # - If the next response is also 401 → SDK returns 401 (won’t retry again)\n            # - But if the next response is != 401 (e.g. 403), and `has_retried = True`,\n            # then we should reset `has_retried = False` so that future 401s can trigger a new token refresh.\n            if (\n                self._401_tls.has_retried\n                and response.status_code\n                != ErrorCode.AUTHENTICATION_PASSTHROUGH.http_error_code\n            ):\n                self._401_tls.has_retried = False\n\n            if response.status_code == api.expected_status:\n                try:\n                    if (\n                        response.content is None\n                        or response.content == \"null\"\n                        or len(response.content) == 0\n                        or response.status_code == HTTPStatus.NO_CONTENT\n                    ):\n                        return None\n                    events = []\n                    if LOGGER.isEnabledFor(logging.DEBUG):\n                        LOGGER.debug(\n                            \"<== __call_api(%s,%s), result = %s\",\n                            vars(api),\n                            params,\n                            response,\n                        )\n                    if api.consumes == EVENT_STREAM and api.produces == EVENT_STREAM:\n                        for line in response.iter_lines(decode_unicode=True):\n                            if not line:\n                                continue\n                            if not line.startswith(\"data: \"):\n                                raise ErrorCode.UNABLE_TO_DESERIALIZE.exception_with_parameters(\n                                    line\n                                )\n                            events.append(json.loads(line.split(\"data: \")[1]))\n                    if text_response:\n                        response_ = response.text\n                    else:\n                        response_ = events if events else response.json()\n                    LOGGER.debug(\"response: %s\", response_)\n                    return response_\n                except (\n                    requests.exceptions.JSONDecodeError,\n                    json.decoder.JSONDecodeError,\n                ) as e:\n                    raise ErrorCode.JSON_ERROR.exception_with_parameters(\n                        response.text, response.status_code, str(e)\n                    ) from e\n            elif response.status_code == HTTPStatus.SERVICE_UNAVAILABLE:\n                LOGGER.error(\n                    \"Atlas Service unavailable. HTTP Status: %s\",\n                    HTTPStatus.SERVICE_UNAVAILABLE,\n                )\n\n                return None\n            else:\n                with contextlib.suppress(ValueError, json.decoder.JSONDecodeError):\n                    error_info = json.loads(response.text)\n                    error_code = (\n                        error_info.get(\"errorCode\", 0)\n                        or error_info.get(\"code\", 0)\n                        or error_info.get(\"status\")\n                    )\n                    error_message = error_info.get(\n                        \"errorMessage\", \"\"\n                    ) or error_info.get(\"message\", \"\")\n                    error_doc = (\n                        error_info.get(\"doc\")\n                        or error_info.get(\"errorDoc\")\n                        or error_info.get(\"errorDocument\")\n                        or error_info.get(\"errorDocumentation\")\n                    )\n                    error_cause = error_info.get(\"errorCause\", [])\n                    causes = error_info.get(\"causes\", [])\n                    backend_error_id = error_info.get(\"errorId\")\n\n                    # Handle the causes and format them for exception\n                    error_cause_details = [\n                        f\"ErrorType: {cause.get('errorType', 'Unknown')}, \"\n                        f\"Message: {cause.get('errorMessage', 'No additional information provided')}, \"\n                        f\"Location: {cause.get('location', 'Unknown location')}\"\n                        for cause in causes\n                    ]\n                    # Join the error cause details into a single string, separated by newlines\n                    error_cause_details_str = (\n                        \"\\n\".join(error_cause_details) if error_cause_details else \"\"\n                    )\n\n                    # Retry with impersonation (if _user_id is present)\n                    # on authentication failure (token may have expired)\n                    if (\n                        self._user_id\n                        and not self._401_tls.has_retried\n                        and response.status_code\n                        == ErrorCode.AUTHENTICATION_PASSTHROUGH.http_error_code\n                    ):\n                        try:\n                            LOGGER.debug(\"Starting 401 automatic token refresh.\")\n                            return self._handle_401_token_refresh(\n                                api,\n                                path,\n                                params,\n                                binary_data=binary_data,\n                                download_file_path=download_file_path,\n                                text_response=text_response,\n                            )\n                        except Exception as e:\n                            LOGGER.debug(\n                                \"API call failed after a successful 401 token refresh. Error details: %s\",\n                                e,\n                            )\n                            raise\n\n                    if error_code and error_message:\n                        error = ERROR_CODE_FOR_HTTP_STATUS.get(\n                            response.status_code, ErrorCode.ERROR_PASSTHROUGH\n                        )\n                        # Raise exception with error details and causes\n                        raise error.exception_with_parameters(\n                            error_code,\n                            error_message,\n                            error_cause_details_str,\n                            error_cause=error_cause,\n                            backend_error_id=backend_error_id,\n                            error_doc=error_doc,\n                        )\n                raise AtlanError(\n                    SimpleNamespace(\n                        http_error_code=response.status_code,\n                        error_id=f\"ATLAN-PYTHON-{response.status_code}-000\",\n                        error_message=response.text,\n                        user_action=ErrorCode.ERROR_PASSTHROUGH.user_action,\n                    )\n                )\n        finally:\n            request_id_var.reset(token)\n",
    "hash_value": "ca9481e311613ebc7fa2c126b8036a2e"
  }
]