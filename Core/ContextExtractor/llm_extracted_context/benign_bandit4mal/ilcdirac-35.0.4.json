[
  {
    "metadata": {
      "package_name": "ilcdirac-35.0.4",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "dirac_fcc_make_productions.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ilcdirac-35.0.4/ilcdirac-35.0.4/src/ILCDIRAC/ILCTransformationSystem/scripts/dirac_fcc_make_productions.py",
    "line_number": "556",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "555\t      config2.optionxform = str  # do not transform options to lowercase\n556\t      config2.read(parameter.prodConfigFilename)\n557\t      for appName in APPLICATION_LIST:",
    "context_snippet": "def loadParameters(self, parameter):\n    \"\"\"Load parameters from config file.\"\"\"\n    if parameter.prodConfigFilename is not None:\n      defaultValueDict = vars(self)\n      defaultValueDict = {key: str(value) for key, value in defaultValueDict.items()}\n      self._flags.updateDictWithFlags(defaultValueDict)\n      # we are passing all instance attributes as the default dict so generally we do not have to check\n      # if an option exists, also options are case insensitive and stored in lowercase\n      config = six.moves.configparser.SafeConfigParser(defaults=defaultValueDict, dict_type=dict)\n      config.read(parameter.prodConfigFilename)\n      self._flags.loadFlags(config)\n\n      for attribute in LIST_ATTRIBUTES:\n        setattr(self, attribute, listify(config.get(PP, attribute)))\n\n      for attribute in STRING_ATTRIBUTES:\n        setattr(self, lowerFirst(attribute), config.get(PP, attribute))\n\n      # this parameter is deprecated and not part of the instance attributes so we need to check for existence\n      if config.has_option(PP, 'clicConfig'):\n        gLogger.warn('\"clicConfig\" parameter is deprected, please dump a new steering file!')\n        self.configVersion = config.get(PP, 'clicConfig')\n\n      # attribute and option names differ, special treatment\n      self.cliRecoOption = config.get(PP, 'cliReco')\n\n      if self.moveStatus not in ('Active', 'Stopped'):\n        raise AttributeError(\"MoveStatus can only be 'Active' or 'Stopped' not %r\" % self.moveStatus)\n\n      # self.overlayEvents = self.checkOverlayParameter(self.overlayEvents)\n      # self.overlayEventType = self.overlayEventType + self.overlayEvents.lower()\n\n      self.processes = [process.strip() for process in self.processes if process.strip()]\n      self.energies = [float(eng.strip()) for eng in self.energies if eng.strip()]\n      self.eventsPerJobs = [int(epj.strip()) for epj in self.eventsPerJobs if epj.strip()]\n      # these do not have to exist so we fill them to the same length if they are not set\n      self.prodIDs = [int(pID.strip()) for pID in self.prodIDs if pID.strip()]\n      self.prodIDs = self.prodIDs if self.prodIDs else [1 for _ in self.energies]\n\n      # if one of the lists only has size 1 and there is a longer list we extend\n      # the list to the maximum size assuming the values are re-used\n      maxLength = 0\n      parameterLists = [self.processes, self.energies, self.eventsPerJobs, self.generatorSteeringFile, self.secondaryGeneratorSteeringFile]\n      \n      for parList in parameterLists:\n        maxLength = len(parList) if len(parList) > maxLength else maxLength\n      for parList in parameterLists:\n        if len(parList) == 1 and maxLength > 1:\n          parList.extend([parList[0]] * (maxLength - 1))\n\n      if not (self.processes and self.energies and self.eventsPerJobs) and self.prodIDs:\n        eventsPerJobSave = list(self.eventsPerJobs) if self.eventsPerJobs else None\n        self._getProdInfoFromIDs()\n        self.eventsPerJobs = eventsPerJobSave if eventsPerJobSave else self.eventsPerJobs\n\n      self.numberOfTasks = [int(nbtask.strip()) for nbtask in self.numberOfTasks if nbtask.strip()]\n      self.numberOfTasks = self.numberOfTasks if self.numberOfTasks else [1] * len(self.energies)\n      self.taskNames = self.taskNames if self.taskNames else [''] * len(self.energies)\n\n      if len(self.processes) != len(self.energies) or \\\n         len(self.energies) != len(self.eventsPerJobs) or \\\n         len(self.prodIDs) != len(self.eventsPerJobs) or \\\n         len(self.eventsPerJobs) != len(self.taskNames) or \\\n         False:\n        raise AttributeError('Lengths of Processes, Energies, EventsPerJobs, AdditionalNames do not match')\n\n      if self._flags.gen:\n        if len(self.numberOfTasks) != len(self.energies) or \\\n           (self.generatorSteeringFile and (len(self.generatorSteeringFile) != len(self.energies))) or \\\n           (self.secondaryGeneratorSteeringFile and (len(self.secondaryGeneratorSteeringFile) != len(self.generatorSteeringFile))):\n          raise AttributeError(\"Lengths of numberOfTasks, generatorSteeringFile, secondaryGeneratorSteeringFile, and Energies do not match\")\n\n      self.eventsInSplitFiles = listify(self.eventsInSplitFiles, int)\n      self.eventsInSplitFiles = self.eventsInSplitFiles if self.eventsInSplitFiles else [-1] * len(self.energies)\n\n      if self._flags.spl and len(self.eventsInSplitFiles) != len(self.energies):\n        raise AttributeError(\"Length of eventsInSplitFiles does not match: %d vs %d\" % (\n            len(self.eventsInSplitFiles),\n            len(self.energies)))\n\n      # read options from application sections\n      config2 = six.moves.configparser.SafeConfigParser(dict_type=dict)\n      config2.optionxform = str  # do not transform options to lowercase\n      config2.read(parameter.prodConfigFilename)\n      for appName in APPLICATION_LIST:\n        try:\n          self.applicationOptions[appName] = dict(config2.items(appName))\n        except six.moves.configparser.NoSectionError:\n          pass\n\n    if parameter.dumpConfigFile:\n      print(self)\n      raise RuntimeError('')",
    "hash_value": "c9ebaac6a9e24ecf865aee55f79dcef4"
  },
  {
    "pyfile": "Test_DelphesAppModule.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ilcdirac-35.0.4/ilcdirac-35.0.4/src/ILCDIRAC/Workflow/Modules/Test/Test_DelphesAppModule.py",
    "line_number": "370",
    "type_description": "B832:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "369\t    with open(self.logFileName, \"w\") as scr:\n370\t      scr.write(\"content\")\n371\t    # side effect for the os.path.exists in DelphesAppModule:",
    "context_snippet": "def setUp(self):\n    super(TestDelphesAppModuleRunit, self).setUp()\n    self.logFileName = \"localEnv.log\"\n    self.executableName = \"DelphesPythia8_EDM4HEP\"\n    self.detectorCard = \"delphes_card_IDEA.tcl\"\n    self.outputCard = \"edm4hep_output_config.tcl\"\n    self.pythia8CardContent = \"Random:setSeed = on\\nMain:numberOfEvents = 3000         ! number of events to generate\"\n    self.step_commons = {'STEP_NUMBER': 1}\n    with open(self.logFileName, \"w\") as logF:\n      logF.write(\"logged the logging logs\")",
    "hash_value": "3a94feba58527e7d037d340ef4a1f571"
  }
]