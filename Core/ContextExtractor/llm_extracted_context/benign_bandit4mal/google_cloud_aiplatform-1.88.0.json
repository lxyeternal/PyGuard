[
  {
    "metadata": {
      "package_name": "google_cloud_aiplatform-1.88.0",
      "total_matches": 15,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "test_model_service.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/tests/unit/gapic/aiplatform_v1beta1/test_model_service.py",
    "line_number": "18969",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "18968\t        field = subfield_to_delete.get(\"field\")\n18969\t        field_repeated = subfield_to_delete.get(\"is_repeated\")\n18970\t        subfield = subfield_to_delete.get(\"subfield\")",
    "context_snippet": "    for subfield_to_delete in subfields_not_in_runtime:  # pragma: NO COVER\n        field = subfield_to_delete.get(\"field\")\n        field_repeated = subfield_to_delete.get(\"is_repeated\")\n        subfield = subfield_to_delete.get(\"subfield\")\n        if subfield:\n            if field_repeated:\n                for i in range(0, len(request_init[\"model\"][field])):\n                    del request_init[\"model\"][field][i][subfield]\n            else:\n                del request_init[\"model\"][field][subfield]",
    "hash_value": "310d36fd64eb5d032cd5db8f181a0880"
  },
  {
    "pyfile": "test_job_service.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/tests/unit/gapic/aiplatform_v1beta1/test_job_service.py",
    "line_number": "25286",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "25285\t        field = subfield_to_delete.get(\"field\")\n25286\t        field_repeated = subfield_to_delete.get(\"is_repeated\")\n25287\t        subfield = subfield_to_delete.get(\"subfield\")",
    "context_snippet": "    for subfield_to_delete in subfields_not_in_runtime:  # pragma: NO COVER\n        field = subfield_to_delete.get(\"field\")\n        field_repeated = subfield_to_delete.get(\"is_repeated\")\n        subfield = subfield_to_delete.get(\"subfield\")\n        if subfield:\n            if field_repeated:\n                for i in range(0, len(request_init[\"custom_job\"][field])):\n                    del request_init[\"custom_job\"][field][i][subfield]\n            else:\n                del request_init[\"custom_job\"][field][subfield]",
    "hash_value": "dcb502000919e3207c5a7f7a1a7f1bee"
  },
  {
    "pyfile": "test_schedule_service.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/tests/unit/gapic/aiplatform_v1beta1/test_schedule_service.py",
    "line_number": "8571",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "8570\t        field = subfield_to_delete.get(\"field\")\n8571\t        field_repeated = subfield_to_delete.get(\"is_repeated\")\n8572\t        subfield = subfield_to_delete.get(\"subfield\")",
    "context_snippet": "    for subfield_to_delete in subfields_not_in_runtime:  # pragma: NO COVER\n        field = subfield_to_delete.get(\"field\")\n        field_repeated = subfield_to_delete.get(\"is_repeated\")\n        subfield = subfield_to_delete.get(\"subfield\")\n        if subfield:\n            if field_repeated:\n                for i in range(0, len(request_init[\"schedule\"][field])):\n                    del request_init[\"schedule\"][field][i][subfield]\n            else:\n                del request_init[\"schedule\"][field][subfield]",
    "hash_value": "6dec90b84cace4e612f9435e00361e32"
  },
  {
    "pyfile": "rest.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/google/cloud/aiplatform_v1beta1/services/deployment_resource_pool_service/transports/rest.py",
    "line_number": "2933",
    "type_description": "B822:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "2932\t            )\n2933\t            transcoded_request = _BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_transcoded_request(\n2934\t                http_options, request\n2935\t            )",
    "context_snippet": "def __call__(\n    self,\n    request: deployment_resource_pool_service.CreateDeploymentResourcePoolRequest,\n    *,\n    retry: OptionalRetry = gapic_v1.method.DEFAULT,\n    timeout: Optional[float] = None,\n    metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n) -> operations_pb2.Operation:\n    r\"\"\"Call the create deployment\n    resource pool method over HTTP.\n\n        Args:\n            request (~.deployment_resource_pool_service.CreateDeploymentResourcePoolRequest):\n                The request object. Request message for\n            CreateDeploymentResourcePool method.\n            retry (google.api_core.retry.Retry): Designation of what errors, if any,\n                should be retried.\n            timeout (float): The timeout for this request.\n            metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n                sent along with the request as metadata. Normally, each value must be of type `str`,\n                but for metadata keys ending with the suffix `-bin`, the corresponding values must\n                be of type `bytes`.\n\n        Returns:\n            ~.operations_pb2.Operation:\n                This resource represents a\n            long-running operation that is the\n            result of a network API call.\n\n    \"\"\"\n\n    http_options = (\n        _BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_http_options()\n    )\n\n    request, metadata = self._interceptor.pre_create_deployment_resource_pool(\n        request, metadata\n    )\n    transcoded_request = _BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_transcoded_request(\n        http_options, request\n    )\n\n    body = _BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_request_body_json(\n        transcoded_request\n    )\n\n    # Jsonify the query params\n    query_params = _BaseDeploymentResourcePoolServiceRestTransport._BaseCreateDeploymentResourcePool._get_query_params_json(\n        transcoded_request\n    )\n\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        request_url = \"{host}{uri}\".format(\n            host=self._host, uri=transcoded_request[\"uri\"]\n        )\n        method = transcoded_request[\"method\"]\n        try:\n            request_payload = json_format.MessageToJson(request)\n        except:\n            request_payload = None\n        http_request = {\n            \"payload\": request_payload,\n            \"requestMethod\": method,\n            \"requestUrl\": request_url,\n            \"headers\": dict(metadata),\n        }\n        _LOGGER.debug(\n            f\"Sending request for google.cloud.aiplatform_v1beta1.DeploymentResourcePoolServiceClient.CreateDeploymentResourcePool\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1beta1.DeploymentResourcePoolService\",\n                \"rpcName\": \"CreateDeploymentResourcePool\",\n                \"httpRequest\": http_request,\n                \"metadata\": http_request[\"headers\"],\n            },\n        )\n\n    # Send the request\n    response = DeploymentResourcePoolServiceRestTransport._CreateDeploymentResourcePool._get_response(\n        self._host,\n        metadata,\n        query_params,\n        self._session,\n        timeout,\n        transcoded_request,\n        body,\n    )\n\n    # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n    # subclass.\n    if response.status_code >= 400:\n        raise core_exceptions.from_http_response(response)\n\n    # Return the response\n    resp = operations_pb2.Operation()\n    json_format.Parse(response.content, resp, ignore_unknown_fields=True)\n\n    resp = self._interceptor.post_create_deployment_resource_pool(resp)\n    response_metadata = [(k, str(v)) for k, v in response.headers.items()]\n    (\n        resp,\n        _,\n    ) = self._interceptor.post_create_deployment_resource_pool_with_metadata(\n        resp, response_metadata\n    )\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        try:\n            response_payload = json_format.MessageToJson(resp)\n        except:\n            response_payload = None\n        http_response = {\n            \"payload\": response_payload,\n            \"headers\": dict(response.headers),\n            \"status\": response.status_code,\n        }\n        _LOGGER.debug(\n            \"Received response for google.cloud.aiplatform_v1beta1.DeploymentResourcePoolServiceClient.create_deployment_resource_pool\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1beta1.DeploymentResourcePoolService\",\n                \"rpcName\": \"CreateDeploymentResourcePool\",\n                \"metadata\": http_response[\"headers\"],\n                \"httpResponse\": http_response,\n            },\n        )\n    return resp",
    "hash_value": "4cbc46b9c813c80f307d09d4245facc0"
  },
  {
    "pyfile": "rest.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/google/cloud/aiplatform_v1beta1/services/tensorboard_service/transports/rest.py",
    "line_number": "5342",
    "type_description": "B822:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "5341\t            )\n5342\t            transcoded_request = _BaseTensorboardServiceRestTransport._BaseCreateTensorboardTimeSeries._get_transcoded_request(\n5343\t                http_options, request\n5344\t            )",
    "context_snippet": "def __call__(\n    self,\n    request: tensorboard_service.BatchCreateTensorboardTimeSeriesRequest,\n    *,\n    retry: OptionalRetry = gapic_v1.method.DEFAULT,\n    timeout: Optional[float] = None,\n    metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n) -> tensorboard_service.BatchCreateTensorboardTimeSeriesResponse:\n    r\"\"\"Call the batch create tensorboard\n    time series method over HTTP.\n\n        Args:\n            request (~.tensorboard_service.BatchCreateTensorboardTimeSeriesRequest):\n                The request object. Request message for\n            [TensorboardService.BatchCreateTensorboardTimeSeries][google.cloud.aiplatform.v1beta1.TensorboardService.BatchCreateTensorboardTimeSeries].\n            retry (google.api_core.retry.Retry): Designation of what errors, if any,\n                should be retried.\n            timeout (float): The timeout for this request.\n            metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n                sent along with the request as metadata. Normally, each value must be of type `str`,\n                but for metadata keys ending with the suffix `-bin`, the corresponding values must\n                be of type `bytes`.\n\n        Returns:\n            ~.tensorboard_service.BatchCreateTensorboardTimeSeriesResponse:\n                Response message for\n            [TensorboardService.BatchCreateTensorboardTimeSeries][google.cloud.aiplatform.v1beta1.TensorboardService.BatchCreateTensorboardTimeSeries].\n\n    \"\"\"\n\n    http_options = (\n        _BaseTensorboardServiceRestTransport._BaseBatchCreateTensorboardTimeSeries._get_http_options()\n    )\n\n    (\n        request,\n        metadata,\n    ) = self._interceptor.pre_batch_create_tensorboard_time_series(\n        request, metadata\n    )\n    transcoded_request = _BaseTensorboardServiceRestTransport._BaseCreateTensorboardTimeSeries._get_transcoded_request(\n        http_options, request\n    )\n\n    body = _BaseTensorboardServiceRestTransport._BaseBatchCreateTensorboardTimeSeries._get_request_body_json(\n        transcoded_request\n    )\n\n    # Jsonify the query params\n    query_params = _BaseTensorboardServiceRestTransport._BaseBatchCreateTensorboardTimeSeries._get_query_params_json(\n        transcoded_request\n    )\n\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        request_url = \"{host}{uri}\".format(\n            host=self._host, uri=transcoded_request[\"uri\"]\n        )\n        method = transcoded_request[\"method\"]\n        try:\n            request_payload = type(request).to_json(request)\n        except:\n            request_payload = None\n        http_request = {\n            \"payload\": request_payload,\n            \"requestMethod\": method,\n            \"requestUrl\": request_url,\n            \"headers\": dict(metadata),\n        }\n        _LOGGER.debug(\n            f\"Sending request for google.cloud.aiplatform_v1beta1.TensorboardServiceClient.BatchCreateTensorboardTimeSeries\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1beta1.TensorboardService\",\n                \"rpcName\": \"BatchCreateTensorboardTimeSeries\",\n                \"httpRequest\": http_request,\n                \"metadata\": http_request[\"headers\"],\n            },\n        )\n\n    # Send the request\n    response = TensorboardServiceRestTransport._BatchCreateTensorboardTimeSeries._get_response(\n        self._host,\n        metadata,\n        query_params,\n        self._session,\n        timeout,\n        transcoded_request,\n        body,\n    )\n\n    # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n    # subclass.\n    if response.status_code >= 400:\n        raise core_exceptions.from_http_response(response)\n\n    # Return the response\n    resp = tensorboard_service.BatchCreateTensorboardTimeSeriesResponse()\n    pb_resp = tensorboard_service.BatchCreateTensorboardTimeSeriesResponse.pb(\n        resp\n    )\n\n    json_format.Parse(response.content, pb_resp, ignore_unknown_fields=True)\n\n    resp = self._interceptor.post_batch_create_tensorboard_time_series(resp)\n    response_metadata = [(k, str(v)) for k, v in response.headers.items()]\n    (\n        resp,\n        _,\n    ) = self._interceptor.post_batch_create_tensorboard_time_series_with_metadata(\n        resp, response_metadata\n    )\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        try:\n            response_payload = tensorboard_service.BatchCreateTensorboardTimeSeriesResponse.to_json(\n                response\n            )\n        except:\n            response_payload = None\n        http_response = {\n            \"payload\": response_payload,\n            \"headers\": dict(response.headers),\n            \"status\": response.status_code,\n        }\n        _LOGGER.debug(\n            \"Received response for google.cloud.aiplatform_v1beta1.TensorboardServiceClient.batch_create_tensorboard_time_series\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1beta1.TensorboardService\",\n                \"rpcName\": \"BatchCreateTensorboardTimeSeries\",\n                \"metadata\": http_response[\"headers\"],\n                \"httpResponse\": http_response,\n            },\n        )\n    return resp",
    "hash_value": "23d48a2cfb31e89af083696495f8fb2a"
  },
  {
    "pyfile": "rest.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/google/cloud/aiplatform_v1beta1/services/metadata_service/transports/rest.py",
    "line_number": "5809",
    "type_description": "B822:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "5808\t            request, metadata = self._interceptor.pre_delete_context(request, metadata)\n5809\t            transcoded_request = _BaseMetadataServiceRestTransport._BaseDeleteContext._get_transcoded_request(\n5810\t                http_options, request\n5811\t            )",
    "context_snippet": "class _DeleteContext(\n    _BaseMetadataServiceRestTransport._BaseDeleteContext, MetadataServiceRestStub\n):\n    def __hash__(self):\n        return hash(\"MetadataServiceRestTransport.DeleteContext\")\n\n    @staticmethod\n    def _get_response(\n        host,\n        metadata,\n        query_params,\n        session,\n        timeout,\n        transcoded_request,\n        body=None,\n    ):\n\n        uri = transcoded_request[\"uri\"]\n        method = transcoded_request[\"method\"]\n        headers = dict(metadata)\n        headers[\"Content-Type\"] = \"application/json\"\n        response = getattr(session, method)(\n            \"{host}{uri}\".format(host=host, uri=uri),\n            timeout=timeout,\n            headers=headers,\n            params=rest_helpers.flatten_query_params(query_params, strict=True),\n        )\n        return response\n\n    def __call__(\n        self,\n        request: metadata_service.DeleteContextRequest,\n        *,\n        retry: OptionalRetry = gapic_v1.method.DEFAULT,\n        timeout: Optional[float] = None,\n        metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n    ) -> operations_pb2.Operation:\n        r\"\"\"Call the delete context method over HTTP.\n\n        Args:\n            request (~.metadata_service.DeleteContextRequest):\n                The request object. Request message for\n            [MetadataService.DeleteContext][google.cloud.aiplatform.v1beta1.MetadataService.DeleteContext].\n            retry (google.api_core.retry.Retry): Designation of what errors, if any,\n                should be retried.\n            timeout (float): The timeout for this request.\n            metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n                sent along with the request as metadata. Normally, each value must be of type `str`,\n                but for metadata keys ending with the suffix `-bin`, the corresponding values must\n                be of type `bytes`.\n\n        Returns:\n            ~.operations_pb2.Operation:\n                This resource represents a\n            long-running operation that is the\n            result of a network API call.\n\n        \"\"\"\n\n        http_options = (\n            _BaseMetadataServiceRestTransport._BaseDeleteContext._get_http_options()\n        )\n\n        request, metadata = self._interceptor.pre_delete_context(request, metadata)\n        transcoded_request = _BaseMetadataServiceRestTransport._BaseDeleteContext._get_transcoded_request(\n            http_options, request\n        )\n\n        # Jsonify the query params\n        query_params = _BaseMetadataServiceRestTransport._BaseDeleteContext._get_query_params_json(\n            transcoded_request\n        )\n\n        if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n            logging.DEBUG\n        ):  # pragma: NO COVER\n            request_url = \"{host}{uri}\".format(\n                host=self._host, uri=transcoded_request[\"uri\"]\n            )\n            method = transcoded_request[\"method\"]\n            try:\n                request_payload = json_format.MessageToJson(request)\n            except:\n                request_payload = None\n            http_request = {\n                \"payload\": request_payload,\n                \"requestMethod\": method,\n                \"requestUrl\": request_url,\n                \"headers\": dict(metadata),\n            }\n            _LOGGER.debug(\n                f\"Sending request for google.cloud.aiplatform_v1beta1.MetadataServiceClient.DeleteContext\",\n                extra={\n                    \"serviceName\": \"google.cloud.aiplatform.v1beta1.MetadataService\",\n                    \"rpcName\": \"DeleteContext\",\n                    \"httpRequest\": http_request,\n                    \"metadata\": http_request[\"headers\"],\n                },\n            )\n\n        # Send the request\n        response = MetadataServiceRestTransport._DeleteContext._get_response(\n            self._host,\n            metadata,\n            query_params,\n            self._session,\n            timeout,\n            transcoded_request,\n        )\n\n        # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n        # subclass.\n        if response.status_code >= 400:\n            raise core_exceptions.from_http_response(response)\n\n        # Return the response\n        resp = operations_pb2.Operation()\n        json_format.Parse(response.content, resp, ignore_unknown_fields=True)\n\n        resp = self._interceptor.post_delete_context(resp)\n        response_metadata = [(k, str(v)) for k, v in response.headers.items()]\n        resp, _ = self._interceptor.post_delete_context_with_metadata(\n            resp, response_metadata\n        )\n        if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n            logging.DEBUG\n        ):  # pragma: NO COVER\n            try:\n                response_payload = json_format.MessageToJson(resp)\n            except:\n                response_payload = None\n            http_response = {\n                \"payload\": response_payload,\n                \"headers\": dict(response.headers),\n                \"status\": response.status_code,\n            }\n            _LOGGER.debug(\n                \"Received response for google.cloud.aiplatform_v1beta1.MetadataServiceClient.delete_context\",\n                extra={\n                    \"serviceName\": \"google.cloud.aiplatform.v1beta1.MetadataService\",\n                    \"rpcName\": \"DeleteContext\",\n                    \"metadata\": http_response[\"headers\"],\n                    \"httpResponse\": http_response,\n                },\n            )\n        return resp\n",
    "hash_value": "42ab1e055508723161a30602c4d7d122"
  },
  {
    "pyfile": "rest.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/google/cloud/aiplatform_v1beta1/services/evaluation_service/transports/rest.py",
    "line_number": "2845",
    "type_description": "B822:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "2844\t            )\n2845\t            transcoded_request = _BaseEvaluationServiceRestTransport._BaseEvaluateInstances._get_transcoded_request(\n2846\t                http_options, request\n2847\t            )",
    "context_snippet": "def __call__(\n    self,\n    request: evaluation_service.EvaluateInstancesRequest,\n    *,\n    retry: OptionalRetry = gapic_v1.method.DEFAULT,\n    timeout: Optional[float] = None,\n    metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n) -> evaluation_service.EvaluateInstancesResponse:\n    r\"\"\"Call the evaluate instances method over HTTP.\n\n    Args:\n        request (~.evaluation_service.EvaluateInstancesRequest):\n            The request object. Request message for\n        EvaluationService.EvaluateInstances.\n        retry (google.api_core.retry.Retry): Designation of what errors, if any,\n            should be retried.\n        timeout (float): The timeout for this request.\n        metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n            sent along with the request as metadata. Normally, each value must be of type `str`,\n            but for metadata keys ending with the suffix `-bin`, the corresponding values must\n            be of type `bytes`.\n\n    Returns:\n        ~.evaluation_service.EvaluateInstancesResponse:\n            Response message for\n        EvaluationService.EvaluateInstances.\n\n    \"\"\"\n\n    http_options = (\n        _BaseEvaluationServiceRestTransport._BaseEvaluateInstances._get_http_options()\n    )\n\n    request, metadata = self._interceptor.pre_evaluate_instances(\n        request, metadata\n    )\n    transcoded_request = _BaseEvaluationServiceRestTransport._BaseEvaluateInstances._get_transcoded_request(\n        http_options, request\n    )\n\n    body = _BaseEvaluationServiceRestTransport._BaseEvaluateInstances._get_request_body_json(\n        transcoded_request\n    )\n\n    # Jsonify the query params\n    query_params = _BaseEvaluationServiceRestTransport._BaseEvaluateInstances._get_query_params_json(\n        transcoded_request\n    )\n\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        request_url = \"{host}{uri}\".format(\n            host=self._host, uri=transcoded_request[\"uri\"]\n        )\n        method = transcoded_request[\"method\"]\n        try:\n            request_payload = type(request).to_json(request)\n        except:\n            request_payload = None\n        http_request = {\n            \"payload\": request_payload,\n            \"requestMethod\": method,\n            \"requestUrl\": request_url,\n            \"headers\": dict(metadata),\n        }\n        _LOGGER.debug(\n            f\"Sending request for google.cloud.aiplatform_v1beta1.EvaluationServiceClient.EvaluateInstances\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1beta1.EvaluationService\",\n                \"rpcName\": \"EvaluateInstances\",\n                \"httpRequest\": http_request,\n                \"metadata\": http_request[\"headers\"],\n            },\n        )\n\n    # Send the request\n    response = EvaluationServiceRestTransport._EvaluateInstances._get_response(\n        self._host,\n        metadata,\n        query_params,\n        self._session,\n        timeout,\n        transcoded_request,\n        body,\n    )\n\n    # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n    # subclass.\n    if response.status_code >= 400:\n        raise core_exceptions.from_http_response(response)\n\n    # Return the response\n    resp = evaluation_service.EvaluateInstancesResponse()\n    pb_resp = evaluation_service.EvaluateInstancesResponse.pb(resp)\n\n    json_format.Parse(response.content, pb_resp, ignore_unknown_fields=True)\n\n    resp = self._interceptor.post_evaluate_instances(resp)\n    response_metadata = [(k, str(v)) for k, v in response.headers.items()]\n    resp, _ = self._interceptor.post_evaluate_instances_with_metadata(\n        resp, response_metadata\n    )\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        try:\n            response_payload = (\n                evaluation_service.EvaluateInstancesResponse.to_json(response)\n            )\n        except:\n            response_payload = None\n        http_response = {\n            \"payload\": response_payload,\n            \"headers\": dict(response.headers),\n            \"status\": response.status_code,\n        }\n        _LOGGER.debug(\n            \"Received response for google.cloud.aiplatform_v1beta1.EvaluationServiceClient.evaluate_instances\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1beta1.EvaluationService\",\n                \"rpcName\": \"EvaluateInstances\",\n                \"metadata\": http_response[\"headers\"],\n                \"httpResponse\": http_response,\n            },\n        )\n    return resp",
    "hash_value": "b45be3f58cd2dbf0bd89c2d8e7569992"
  },
  {
    "pyfile": "rest_asyncio.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/google/cloud/aiplatform_v1beta1/services/metadata_service/transports/rest_asyncio.py",
    "line_number": "7097",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "7096\t            )\n7097\t            transcoded_request = _BaseMetadataServiceRestTransport._BaseRemoveContextChildren._get_transcoded_request(\n7098\t                http_options, request\n7099\t            )",
    "context_snippet": "        async def __call__(\n            self,\n            request: metadata_service.RemoveContextChildrenRequest,\n            *,\n            retry: OptionalRetry = gapic_v1.method.DEFAULT,\n            timeout: Optional[float] = None,\n            metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n        ) -> metadata_service.RemoveContextChildrenResponse:\n            r\"\"\"Call the remove context children method over HTTP.\n\n            Args:\n                request (~.metadata_service.RemoveContextChildrenRequest):\n                    The request object. Request message for\n                [MetadataService.DeleteContextChildrenRequest][].\n                retry (google.api_core.retry_async.AsyncRetry): Designation of what errors, if any,\n                    should be retried.\n                timeout (float): The timeout for this request.\n                metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n                    sent along with the request as metadata. Normally, each value must be of type `str`,\n                    but for metadata keys ending with the suffix `-bin`, the corresponding values must\n                    be of type `bytes`.\n\n            Returns:\n                ~.metadata_service.RemoveContextChildrenResponse:\n                    Response message for\n                [MetadataService.RemoveContextChildren][google.cloud.aiplatform.v1beta1.MetadataService.RemoveContextChildren].\n\n            \"\"\"\n\n            http_options = (\n                _BaseMetadataServiceRestTransport._BaseRemoveContextChildren._get_http_options()\n            )\n\n            request, metadata = await self._interceptor.pre_remove_context_children(\n                request, metadata\n            )\n            transcoded_request = _BaseMetadataServiceRestTransport._BaseRemoveContextChildren._get_transcoded_request(\n                http_options, request\n            )\n\n            body = _BaseMetadataServiceRestTransport._BaseRemoveContextChildren._get_request_body_json(\n                transcoded_request\n            )\n\n            # Jsonify the query params\n            query_params = _BaseMetadataServiceRestTransport._BaseRemoveContextChildren._get_query_params_json(\n                transcoded_request\n            )\n\n            if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n                logging.DEBUG\n            ):  # pragma: NO COVER\n                request_url = \"{host}{uri}\".format(\n                    host=self._host, uri=transcoded_request[\"uri\"]\n                )\n                method = transcoded_request[\"method\"]\n                try:\n                    request_payload = type(request).to_json(request)\n                except:\n                    request_payload = None\n                http_request = {\n                    \"payload\": request_payload,\n                    \"requestMethod\": method,\n                    \"requestUrl\": request_url,\n                    \"headers\": dict(metadata),\n                }\n                _LOGGER.debug(\n                    f\"Sending request for google.cloud.aiplatform_v1beta1.MetadataServiceClient.RemoveContextChildren\",\n                    extra={\n                        \"serviceName\": \"google.cloud.aiplatform.v1beta1.MetadataService\",\n                        \"rpcName\": \"RemoveContextChildren\",\n                        \"httpRequest\": http_request,\n                        \"metadata\": http_request[\"headers\"],\n                    },\n                )\n\n            # Send the request\n            response = await AsyncMetadataServiceRestTransport._RemoveContextChildren._get_response(\n                self._host,\n                metadata,\n                query_params,\n                self._session,\n                timeout,\n                transcoded_request,\n                body,\n            )\n\n            # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n            # subclass.\n            if response.status_code >= 400:\n                content = await response.read()\n                payload = json.loads(content.decode(\"utf-8\"))\n                request_url = \"{host}{uri}\".format(\n                    host=self._host, uri=transcoded_request[\"uri\"]\n                )\n                method = transcoded_request[\"method\"]\n                raise core_exceptions.format_http_response_error(response, method, request_url, payload)  # type: ignore\n\n            # Return the response\n            resp = metadata_service.RemoveContextChildrenResponse()\n            pb_resp = metadata_service.RemoveContextChildrenResponse.pb(resp)\n            content = await response.read()\n            json_format.Parse(content, pb_resp, ignore_unknown_fields=True)\n            resp = await self._interceptor.post_remove_context_children(resp)\n            response_metadata = [(k, str(v)) for k, v in response.headers.items()]\n            (\n                resp,\n                _,\n            ) = await self._interceptor.post_remove_context_children_with_metadata(\n                resp, response_metadata\n            )\n            if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n                logging.DEBUG\n            ):  # pragma: NO COVER\n                try:\n                    response_payload = (\n                        metadata_service.RemoveContextChildrenResponse.to_json(response)\n                    )\n                except:\n                    response_payload = None\n                http_response = {\n                    \"payload\": response_payload,\n                    \"headers\": dict(response.headers),\n                    \"status\": \"OK\",  # need to obtain this properly\n                }\n                _LOGGER.debug(\n                    \"Received response for google.cloud.aiplatform_v1beta1.MetadataServiceAsyncClient.remove_context_children\",\n                    extra={\n                        \"serviceName\": \"google.cloud.aiplatform.v1beta1.MetadataService\",\n                        \"rpcName\": \"RemoveContextChildren\",\n                        \"metadata\": http_response[\"headers\"],\n                        \"httpResponse\": http_response,\n                    },\n                )\n\n            return resp",
    "hash_value": "95ac1c5aace62b96c531ef31e2737bf0"
  },
  {
    "pyfile": "rest_asyncio.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/google/cloud/aiplatform_v1/services/metadata_service/transports/rest_asyncio.py",
    "line_number": "4505",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "4504\t            )\n4505\t            transcoded_request = _BaseMetadataServiceRestTransport._BaseGetArtifact._get_transcoded_request(\n4506\t                http_options, request\n4507\t            )",
    "context_snippet": "async def __call__(\n    self,\n    request: metadata_service.GetArtifactRequest,\n    *,\n    retry: OptionalRetry = gapic_v1.method.DEFAULT,\n    timeout: Optional[float] = None,\n    metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n) -> artifact.Artifact:\n    r\"\"\"Call the get artifact method over HTTP.\n\n    Args:\n        request (~.metadata_service.GetArtifactRequest):\n            The request object. Request message for\n        [MetadataService.GetArtifact][google.cloud.aiplatform.v1.MetadataService.GetArtifact].\n        retry (google.api_core.retry_async.AsyncRetry): Designation of what errors, if any,\n            should be retried.\n        timeout (float): The timeout for this request.\n        metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n            sent along with the request as metadata. Normally, each value must be of type `str`,\n            but for metadata keys ending with the suffix `-bin`, the corresponding values must\n            be of type `bytes`.\n\n    Returns:\n        ~.artifact.Artifact:\n            Instance of a general artifact.\n    \"\"\"\n\n    http_options = (\n        _BaseMetadataServiceRestTransport._BaseGetArtifact._get_http_options()\n    )\n\n    request, metadata = await self._interceptor.pre_get_artifact(\n        request, metadata\n    )\n    transcoded_request = _BaseMetadataServiceRestTransport._BaseGetArtifact._get_transcoded_request(\n        http_options, request\n    )\n\n    # Jsonify the query params\n    query_params = _BaseMetadataServiceRestTransport._BaseGetArtifact._get_query_params_json(\n        transcoded_request\n    )\n\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        request_url = \"{host}{uri}\".format(\n            host=self._host, uri=transcoded_request[\"uri\"]\n        )\n        method = transcoded_request[\"method\"]\n        try:\n            request_payload = type(request).to_json(request)\n        except:\n            request_payload = None\n        http_request = {\n            \"payload\": request_payload,\n            \"requestMethod\": method,\n            \"requestUrl\": request_url,\n            \"headers\": dict(metadata),\n        }\n        _LOGGER.debug(\n            f\"Sending request for google.cloud.aiplatform_v1.MetadataServiceClient.GetArtifact\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1.MetadataService\",\n                \"rpcName\": \"GetArtifact\",\n                \"httpRequest\": http_request,\n                \"metadata\": http_request[\"headers\"],\n            },\n        )\n\n    # Send the request\n    response = (\n        await AsyncMetadataServiceRestTransport._GetArtifact._get_response(\n            self._host,\n            metadata,\n            query_params,\n            self._session,\n            timeout,\n            transcoded_request,\n        )\n    )\n\n    # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n    # subclass.\n    if response.status_code >= 400:\n        content = await response.read()\n        payload = json.loads(content.decode(\"utf-8\"))\n        request_url = \"{host}{uri}\".format(\n            host=self._host, uri=transcoded_request[\"uri\"]\n        )\n        method = transcoded_request[\"method\"]\n        raise core_exceptions.format_http_response_error(response, method, request_url, payload)  # type: ignore\n\n    # Return the response\n    resp = artifact.Artifact()\n    pb_resp = artifact.Artifact.pb(resp)\n    content = await response.read()\n    json_format.Parse(content, pb_resp, ignore_unknown_fields=True)\n    resp = await self._interceptor.post_get_artifact(resp)\n    response_metadata = [(k, str(v)) for k, v in response.headers.items()]\n    resp, _ = await self._interceptor.post_get_artifact_with_metadata(\n        resp, response_metadata\n    )\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        try:\n            response_payload = artifact.Artifact.to_json(response)\n        except:\n            response_payload = None\n        http_response = {\n            \"payload\": response_payload,\n            \"headers\": dict(response.headers),\n            \"status\": \"OK\",  # need to obtain this properly\n        }\n        _LOGGER.debug(\n            \"Received response for google.cloud.aiplatform_v1.MetadataServiceAsyncClient.get_artifact\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1.MetadataService\",\n                \"rpcName\": \"GetArtifact\",\n                \"metadata\": http_response[\"headers\"],\n                \"httpResponse\": http_response,\n            },\n        )\n\n    return resp",
    "hash_value": "ead1c5f70a275def16d71e5c2ec714cd"
  },
  {
    "pyfile": "rest_asyncio.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/google/cloud/aiplatform_v1beta1/services/gen_ai_tuning_service/transports/rest_asyncio.py",
    "line_number": "3866",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "3865\t            )\n3866\t            transcoded_request = _BaseGenAiTuningServiceRestTransport._BaseListLocations._get_transcoded_request(\n3867\t                http_options, request\n3868\t            )",
    "context_snippet": "async def __call__(\n    self,\n    request: locations_pb2.ListLocationsRequest,\n    *,\n    retry: OptionalRetry = gapic_v1.method.DEFAULT,\n    timeout: Optional[float] = None,\n    metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n) -> locations_pb2.ListLocationsResponse:\n\n    r\"\"\"Call the list locations method over HTTP.\n\n    Args:\n        request (locations_pb2.ListLocationsRequest):\n            The request object for ListLocations method.\n        retry (google.api_core.retry_async.AsyncRetry): Designation of what errors, if any,\n            should be retried.\n        timeout (float): The timeout for this request.\n        metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n            sent along with the request as metadata. Normally, each value must be of type `str`,\n            but for metadata keys ending with the suffix `-bin`, the corresponding values must\n            be of type `bytes`.\n\n    Returns:\n        locations_pb2.ListLocationsResponse: Response from ListLocations method.\n    \"\"\"\n\n    http_options = (\n        _BaseGenAiTuningServiceRestTransport._BaseListLocations._get_http_options()\n    )\n\n    request, metadata = await self._interceptor.pre_list_locations(\n        request, metadata\n    )\n    transcoded_request = _BaseGenAiTuningServiceRestTransport._BaseListLocations._get_transcoded_request(\n        http_options, request\n    )\n\n    # Jsonify the query params\n    query_params = _BaseGenAiTuningServiceRestTransport._BaseListLocations._get_query_params_json(\n        transcoded_request\n    )\n\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        request_url = \"{host}{uri}\".format(\n            host=self._host, uri=transcoded_request[\"uri\"]\n        )\n        method = transcoded_request[\"method\"]\n        try:\n            request_payload = json_format.MessageToJson(request)\n        except:\n            request_payload = None\n        http_request = {\n            \"payload\": request_payload,\n            \"requestMethod\": method,\n            \"requestUrl\": request_url,\n            \"headers\": dict(metadata),\n        }\n        _LOGGER.debug(\n            f\"Sending request for google.cloud.aiplatform_v1beta1.GenAiTuningServiceClient.ListLocations\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1beta1.GenAiTuningService\",\n                \"rpcName\": \"ListLocations\",\n                \"httpRequest\": http_request,\n                \"metadata\": http_request[\"headers\"],\n            },\n        )\n\n    # Send the request\n    response = (\n        await AsyncGenAiTuningServiceRestTransport._ListLocations._get_response(\n            self._host,\n            metadata,\n            query_params,\n            self._session,\n            timeout,\n            transcoded_request,\n        )\n    )\n\n    # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n    # subclass.\n    if response.status_code >= 400:\n        content = await response.read()\n        payload = json.loads(content.decode(\"utf-8\"))\n        request_url = \"{host}{uri}\".format(\n            host=self._host, uri=transcoded_request[\"uri\"]\n        )\n        method = transcoded_request[\"method\"]\n        raise core_exceptions.format_http_response_error(response, method, request_url, payload)  # type: ignore\n\n    content = await response.read()\n    resp = locations_pb2.ListLocationsResponse()\n    resp = json_format.Parse(content, resp)\n    resp = await self._interceptor.post_list_locations(resp)\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        try:\n            response_payload = json_format.MessageToJson(resp)\n        except:\n            response_payload = None\n        http_response = {\n            \"payload\": response_payload,\n            \"headers\": dict(response.headers),\n            \"status\": response.status_code,\n        }\n        _LOGGER.debug(\n            \"Received response for google.cloud.aiplatform_v1beta1.GenAiTuningServiceAsyncClient.ListLocations\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1beta1.GenAiTuningService\",\n                \"rpcName\": \"ListLocations\",\n                \"httpResponse\": http_response,\n                \"metadata\": http_response[\"headers\"],\n            },\n        )\n    return resp",
    "hash_value": "d5bddbe814a386d235a49f5972a9366f"
  },
  {
    "pyfile": "rest_asyncio.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/google/cloud/aiplatform_v1/services/model_garden_service/transports/rest_asyncio.py",
    "line_number": "1226",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1225\t            )\n1226\t            transcoded_request = _BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_transcoded_request(\n1227\t                http_options, request\n1228\t            )",
    "context_snippet": "async def __call__(\n    self,\n    request: iam_policy_pb2.SetIamPolicyRequest,\n    *,\n    retry: OptionalRetry = gapic_v1.method.DEFAULT,\n    timeout: Optional[float] = None,\n    metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n) -> policy_pb2.Policy:\n\n    r\"\"\"Call the set iam policy method over HTTP.\n\n    Args:\n        request (iam_policy_pb2.SetIamPolicyRequest):\n            The request object for SetIamPolicy method.\n        retry (google.api_core.retry_async.AsyncRetry): Designation of what errors, if any,\n            should be retried.\n        timeout (float): The timeout for this request.\n        metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n            sent along with the request as metadata. Normally, each value must be of type `str`,\n            but for metadata keys ending with the suffix `-bin`, the corresponding values must\n            be of type `bytes`.\n\n    Returns:\n        policy_pb2.Policy: Response from SetIamPolicy method.\n    \"\"\"\n\n    http_options = (\n        _BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_http_options()\n    )\n\n    request, metadata = await self._interceptor.pre_set_iam_policy(\n        request, metadata\n    )\n    transcoded_request = _BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_transcoded_request(\n        http_options, request\n    )\n\n    body = _BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_request_body_json(\n        transcoded_request\n    )\n\n    # Jsonify the query params\n    query_params = _BaseModelGardenServiceRestTransport._BaseSetIamPolicy._get_query_params_json(\n        transcoded_request\n    )\n\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        request_url = \"{host}{uri}\".format(\n            host=self._host, uri=transcoded_request[\"uri\"]\n        )\n        method = transcoded_request[\"method\"]\n        try:\n            request_payload = json_format.MessageToJson(request)\n        except:\n            request_payload = None\n        http_request = {\n            \"payload\": request_payload,\n            \"requestMethod\": method,\n            \"requestUrl\": request_url,\n            \"headers\": dict(metadata),\n        }\n        _LOGGER.debug(\n            f\"Sending request for google.cloud.aiplatform_v1.ModelGardenServiceClient.SetIamPolicy\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1.ModelGardenService\",\n                \"rpcName\": \"SetIamPolicy\",\n                \"httpRequest\": http_request,\n                \"metadata\": http_request[\"headers\"],\n            },\n        )\n\n    # Send the request\n    response = (\n        await AsyncModelGardenServiceRestTransport._SetIamPolicy._get_response(\n            self._host,\n            metadata,\n            query_params,\n            self._session,\n            timeout,\n            transcoded_request,\n            body,\n        )\n    )\n\n    # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n    # subclass.\n    if response.status_code >= 400:\n        content = await response.read()\n        payload = json.loads(content.decode(\"utf-8\"))\n        request_url = \"{host}{uri}\".format(\n            host=self._host, uri=transcoded_request[\"uri\"]\n        )\n        method = transcoded_request[\"method\"]\n        raise core_exceptions.format_http_response_error(response, method, request_url, payload)  # type: ignore\n\n    content = await response.read()\n    resp = policy_pb2.Policy()\n    resp = json_format.Parse(content, resp)\n    resp = await self._interceptor.post_set_iam_policy(resp)\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        try:\n            response_payload = json_format.MessageToJson(resp)\n        except:\n            response_payload = None\n        http_response = {\n            \"payload\": response_payload,\n            \"headers\": dict(response.headers),\n            \"status\": response.status_code,\n        }\n        _LOGGER.debug(\n            \"Received response for google.cloud.aiplatform_v1.ModelGardenServiceAsyncClient.SetIamPolicy\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1.ModelGardenService\",\n                \"rpcName\": \"SetIamPolicy\",\n                \"httpResponse\": http_response,\n                \"metadata\": http_response[\"headers\"],\n            },\n        )\n    return resp",
    "hash_value": "385ad4fe970c8e55e8c0489e8096c799"
  },
  {
    "pyfile": "rest_asyncio.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/google/cloud/aiplatform_v1/services/job_service/transports/rest_asyncio.py",
    "line_number": "4813",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "4812\t            )\n4813\t            transcoded_request = _BaseJobServiceRestTransport._BaseDeleteModelDeploymentMonitoringJob._get_transcoded_request(\n4814\t                http_options, request\n4815\t            )",
    "context_snippet": "        async def __call__(\n            self,\n            request: job_service.DeleteModelDeploymentMonitoringJobRequest,\n            *,\n            retry: OptionalRetry = gapic_v1.method.DEFAULT,\n            timeout: Optional[float] = None,\n            metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n        ) -> operations_pb2.Operation:\n            r\"\"\"Call the delete model deployment\n            monitoring job method over HTTP.\n\n                Args:\n                    request (~.job_service.DeleteModelDeploymentMonitoringJobRequest):\n                        The request object. Request message for\n                    [JobService.DeleteModelDeploymentMonitoringJob][google.cloud.aiplatform.v1.JobService.DeleteModelDeploymentMonitoringJob].\n                    retry (google.api_core.retry_async.AsyncRetry): Designation of what errors, if any,\n                        should be retried.\n                    timeout (float): The timeout for this request.\n                    metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n                        sent along with the request as metadata. Normally, each value must be of type `str`,\n                        but for metadata keys ending with the suffix `-bin`, the corresponding values must\n                        be of type `bytes`.\n\n                Returns:\n                    ~.operations_pb2.Operation:\n                        This resource represents a\n                    long-running operation that is the\n                    result of a network API call.\n\n            \"\"\"\n\n            http_options = (\n                _BaseJobServiceRestTransport._BaseDeleteModelDeploymentMonitoringJob._get_http_options()\n            )\n\n            (\n                request,\n                metadata,\n            ) = await self._interceptor.pre_delete_model_deployment_monitoring_job(\n                request, metadata\n            )\n            transcoded_request = _BaseJobServiceRestTransport._BaseDeleteModelDeploymentMonitoringJob._get_transcoded_request(\n                http_options, request\n            )\n\n            # Jsonify the query params\n            query_params = _BaseJobServiceRestTransport._BaseDeleteModelDeploymentMonitoringJob._get_query_params_json(\n                transcoded_request\n            )\n\n            if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n                logging.DEBUG\n            ):  # pragma: NO COVER\n                request_url = \"{host}{uri}\".format(\n                    host=self._host, uri=transcoded_request[\"uri\"]\n                )\n                method = transcoded_request[\"method\"]\n                try:\n                    request_payload = json_format.MessageToJson(request)\n                except:\n                    request_payload = None\n                http_request = {\n                    \"payload\": request_payload,\n                    \"requestMethod\": method,\n                    \"requestUrl\": request_url,\n                    \"headers\": dict(metadata),\n                }\n                _LOGGER.debug(\n                    f\"Sending request for google.cloud.aiplatform_v1.JobServiceClient.DeleteModelDeploymentMonitoringJob\",\n                    extra={\n                        \"serviceName\": \"google.cloud.aiplatform.v1.JobService\",\n                        \"rpcName\": \"DeleteModelDeploymentMonitoringJob\",\n                        \"httpRequest\": http_request,\n                        \"metadata\": http_request[\"headers\"],\n                    },\n                )\n\n            # Send the request\n            response = await AsyncJobServiceRestTransport._DeleteModelDeploymentMonitoringJob._get_response(\n                self._host,\n                metadata,\n                query_params,\n                self._session,\n                timeout,\n                transcoded_request,\n            )\n\n            # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n            # subclass.\n            if response.status_code >= 400:\n                content = await response.read()\n                payload = json.loads(content.decode(\"utf-8\"))\n                request_url = \"{host}{uri}\".format(\n                    host=self._host, uri=transcoded_request[\"uri\"]\n                )\n                method = transcoded_request[\"method\"]\n                raise core_exceptions.format_http_response_error(response, method, request_url, payload)  # type: ignore\n\n            # Return the response\n            resp = operations_pb2.Operation()\n            pb_resp = resp\n            content = await response.read()\n            json_format.Parse(content, pb_resp, ignore_unknown_fields=True)\n            resp = await self._interceptor.post_delete_model_deployment_monitoring_job(\n                resp\n            )\n            response_metadata = [(k, str(v)) for k, v in response.headers.items()]\n            (\n                resp,\n                _,\n            ) = await self._interceptor.post_delete_model_deployment_monitoring_job_with_metadata(\n                resp, response_metadata\n            )\n            if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n                logging.DEBUG\n            ):  # pragma: NO COVER\n                try:\n                    response_payload = json_format.MessageToJson(resp)\n                except:\n                    response_payload = None\n                http_response = {\n                    \"payload\": response_payload,\n                    \"headers\": dict(response.headers),\n                    \"status\": \"OK\",  # need to obtain this properly\n                }\n                _LOGGER.debug(\n                    \"Received response for google.cloud.aiplatform_v1.JobServiceAsyncClient.delete_model_deployment_monitoring_job\",\n                    extra={\n                        \"serviceName\": \"google.cloud.aiplatform.v1.JobService\",\n                        \"rpcName\": \"DeleteModelDeploymentMonitoringJob\",\n                        \"metadata\": http_response[\"headers\"],\n                        \"httpResponse\": http_response,\n                    },\n                )\n\n            return resp",
    "hash_value": "a899c426783131f4afbdecd2582b63f3"
  },
  {
    "pyfile": "rest_asyncio.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/google/cloud/aiplatform_v1beta1/services/model_service/transports/rest_asyncio.py",
    "line_number": "7105",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "7104\t            transcoded_request = (\n7105\t                _BaseModelServiceRestTransport._BaseGetLocation._get_transcoded_request(\n7106\t                    http_options, request\n7107\t                )",
    "context_snippet": "        async def __call__(\n            self,\n            request: locations_pb2.GetLocationRequest,\n            *,\n            retry: OptionalRetry = gapic_v1.method.DEFAULT,\n            timeout: Optional[float] = None,\n            metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n        ) -> locations_pb2.Location:\n\n            r\"\"\"Call the get location method over HTTP.\n\n            Args:\n                request (locations_pb2.GetLocationRequest):\n                    The request object for GetLocation method.\n                retry (google.api_core.retry_async.AsyncRetry): Designation of what errors, if any,\n                    should be retried.\n                timeout (float): The timeout for this request.\n                metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n                    sent along with the request as metadata. Normally, each value must be of type `str`,\n                    but for metadata keys ending with the suffix `-bin`, the corresponding values must\n                    be of type `bytes`.\n\n            Returns:\n                locations_pb2.Location: Response from GetLocation method.\n            \"\"\"\n\n            http_options = (\n                _BaseModelServiceRestTransport._BaseGetLocation._get_http_options()\n            )\n\n            request, metadata = await self._interceptor.pre_get_location(\n                request, metadata\n            )\n            transcoded_request = (\n                _BaseModelServiceRestTransport._BaseGetLocation._get_transcoded_request(\n                    http_options, request\n                )\n            )\n\n            # Jsonify the query params\n            query_params = (\n                _BaseModelServiceRestTransport._BaseGetLocation._get_query_params_json(\n                    transcoded_request\n                )\n            )\n\n            if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n                logging.DEBUG\n            ):  # pragma: NO COVER\n                request_url = \"{host}{uri}\".format(\n                    host=self._host, uri=transcoded_request[\"uri\"]\n                )\n                method = transcoded_request[\"method\"]\n                try:\n                    request_payload = json_format.MessageToJson(request)\n                except:\n                    request_payload = None\n                http_request = {\n                    \"payload\": request_payload,\n                    \"requestMethod\": method,\n                    \"requestUrl\": request_url,\n                    \"headers\": dict(metadata),\n                }\n                _LOGGER.debug(\n                    f\"Sending request for google.cloud.aiplatform_v1beta1.ModelServiceClient.GetLocation\",\n                    extra={\n                        \"serviceName\": \"google.cloud.aiplatform.v1beta1.ModelService\",\n                        \"rpcName\": \"GetLocation\",\n                        \"httpRequest\": http_request,\n                        \"metadata\": http_request[\"headers\"],\n                    },\n                )\n\n            # Send the request\n            response = await AsyncModelServiceRestTransport._GetLocation._get_response(\n                self._host,\n                metadata,\n                query_params,\n                self._session,\n                timeout,\n                transcoded_request,\n            )\n\n            # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n            # subclass.\n            if response.status_code >= 400:\n                content = await response.read()\n                payload = json.loads(content.decode(\"utf-8\"))\n                request_url = \"{host}{uri}\".format(\n                    host=self._host, uri=transcoded_request[\"uri\"]\n                )\n                method = transcoded_request[\"method\"]\n                raise core_exceptions.format_http_response_error(response, method, request_url, payload)  # type: ignore\n\n            content = await response.read()\n            resp = locations_pb2.Location()\n            resp = json_format.Parse(content, resp)\n            resp = await self._interceptor.post_get_location(resp)\n            if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n                logging.DEBUG\n            ):  # pragma: NO COVER\n                try:\n                    response_payload = json_format.MessageToJson(resp)\n                except:\n                    response_payload = None\n                http_response = {\n                    \"payload\": response_payload,\n                    \"headers\": dict(response.headers),\n                    \"status\": response.status_code,\n                }\n                _LOGGER.debug(\n                    \"Received response for google.cloud.aiplatform_v1beta1.ModelServiceAsyncClient.GetLocation\",\n                    extra={\n                        \"serviceName\": \"google.cloud.aiplatform.v1beta1.ModelService\",\n                        \"rpcName\": \"GetLocation\",\n                        \"httpResponse\": http_response,\n                        \"metadata\": http_response[\"headers\"],\n                    },\n                )\n            return resp",
    "hash_value": "62058674e5f39598fcc064409403ef33"
  },
  {
    "pyfile": "rest_asyncio.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/google/cloud/aiplatform_v1/services/index_service/transports/rest_asyncio.py",
    "line_number": "1625",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1624\t            )\n1625\t            transcoded_request = _BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_transcoded_request(\n1626\t                http_options, request\n1627\t            )",
    "context_snippet": "async def __call__(\n    self,\n    request: index_service.RemoveDatapointsRequest,\n    *,\n    retry: OptionalRetry = gapic_v1.method.DEFAULT,\n    timeout: Optional[float] = None,\n    metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n) -> index_service.RemoveDatapointsResponse:\n    r\"\"\"Call the remove datapoints method over HTTP.\n\n    Args:\n        request (~.index_service.RemoveDatapointsRequest):\n            The request object. Request message for\n        [IndexService.RemoveDatapoints][google.cloud.aiplatform.v1.IndexService.RemoveDatapoints]\n        retry (google.api_core.retry_async.AsyncRetry): Designation of what errors, if any,\n            should be retried.\n        timeout (float): The timeout for this request.\n        metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n            sent along with the request as metadata. Normally, each value must be of type `str`,\n            but for metadata keys ending with the suffix `-bin`, the corresponding values must\n            be of type `bytes`.\n\n    Returns:\n        ~.index_service.RemoveDatapointsResponse:\n            Response message for\n        [IndexService.RemoveDatapoints][google.cloud.aiplatform.v1.IndexService.RemoveDatapoints]\n\n    \"\"\"\n\n    http_options = (\n        _BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_http_options()\n    )\n\n    request, metadata = await self._interceptor.pre_remove_datapoints(\n        request, metadata\n    )\n    transcoded_request = _BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_transcoded_request(\n        http_options, request\n    )\n\n    body = _BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_request_body_json(\n        transcoded_request\n    )\n\n    # Jsonify the query params\n    query_params = _BaseIndexServiceRestTransport._BaseRemoveDatapoints._get_query_params_json(\n        transcoded_request\n    )\n\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        request_url = \"{host}{uri}\".format(\n            host=self._host, uri=transcoded_request[\"uri\"]\n        )\n        method = transcoded_request[\"method\"]\n        try:\n            request_payload = type(request).to_json(request)\n        except:\n            request_payload = None\n        http_request = {\n            \"payload\": request_payload,\n            \"requestMethod\": method,\n            \"requestUrl\": request_url,\n            \"headers\": dict(metadata),\n        }\n        _LOGGER.debug(\n            f\"Sending request for google.cloud.aiplatform_v1.IndexServiceClient.RemoveDatapoints\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1.IndexService\",\n                \"rpcName\": \"RemoveDatapoints\",\n                \"httpRequest\": http_request,\n                \"metadata\": http_request[\"headers\"],\n            },\n        )\n\n    # Send the request\n    response = (\n        await AsyncIndexServiceRestTransport._RemoveDatapoints._get_response(\n            self._host,\n            metadata,\n            query_params,\n            self._session,\n            timeout,\n            transcoded_request,\n            body,\n        )\n    )\n\n    # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n    # subclass.\n    if response.status_code >= 400:\n        content = await response.read()\n        payload = json.loads(content.decode(\"utf-8\"))\n        request_url = \"{host}{uri}\".format(\n            host=self._host, uri=transcoded_request[\"uri\"]\n        )\n        method = transcoded_request[\"method\"]\n        raise core_exceptions.format_http_response_error(response, method, request_url, payload)  # type: ignore\n\n    # Return the response\n    resp = index_service.RemoveDatapointsResponse()\n    pb_resp = index_service.RemoveDatapointsResponse.pb(resp)\n    content = await response.read()\n    json_format.Parse(content, pb_resp, ignore_unknown_fields=True)\n    resp = await self._interceptor.post_remove_datapoints(resp)\n    response_metadata = [(k, str(v)) for k, v in response.headers.items()]\n    resp, _ = await self._interceptor.post_remove_datapoints_with_metadata(\n        resp, response_metadata\n    )\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        try:\n            response_payload = index_service.RemoveDatapointsResponse.to_json(\n                response\n            )\n        except:\n            response_payload = None\n        http_response = {\n            \"payload\": response_payload,\n            \"headers\": dict(response.headers),\n            \"status\": \"OK\",  # need to obtain this properly\n        }\n        _LOGGER.debug(\n            \"Received response for google.cloud.aiplatform_v1.IndexServiceAsyncClient.remove_datapoints\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1.IndexService\",\n                \"rpcName\": \"RemoveDatapoints\",\n                \"metadata\": http_response[\"headers\"],\n                \"httpResponse\": http_response,\n            },\n        )\n\n    return resp",
    "hash_value": "8f725509f983ac13830633f315bd5720"
  },
  {
    "pyfile": "rest.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/google_cloud_aiplatform-1.88.0/google_cloud_aiplatform-1.88.0/google/cloud/aiplatform_v1/services/prediction_service/transports/rest.py",
    "line_number": "3397",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "3396\t            )\n3397\t            transcoded_request = _BasePredictionServiceRestTransport._BaseCancelOperation._get_transcoded_request(\n3398\t                http_options, request\n3399\t            )",
    "context_snippet": "def __call__(\n    self,\n    request: operations_pb2.CancelOperationRequest,\n    *,\n    retry: OptionalRetry = gapic_v1.method.DEFAULT,\n    timeout: Optional[float] = None,\n    metadata: Sequence[Tuple[str, Union[str, bytes]]] = (),\n) -> None:\n\n    r\"\"\"Call the cancel operation method over HTTP.\n\n    Args:\n        request (operations_pb2.CancelOperationRequest):\n            The request object for CancelOperation method.\n        retry (google.api_core.retry.Retry): Designation of what errors, if any,\n            should be retried.\n        timeout (float): The timeout for this request.\n        metadata (Sequence[Tuple[str, Union[str, bytes]]]): Key/value pairs which should be\n            sent along with the request as metadata. Normally, each value must be of type `str`,\n            but for metadata keys ending with the suffix `-bin`, the corresponding values must\n            be of type `bytes`.\n    \"\"\"\n\n    http_options = (\n        _BasePredictionServiceRestTransport._BaseCancelOperation._get_http_options()\n    )\n\n    request, metadata = self._interceptor.pre_cancel_operation(\n        request, metadata\n    )\n    transcoded_request = _BasePredictionServiceRestTransport._BaseCancelOperation._get_transcoded_request(\n        http_options, request\n    )\n\n    # Jsonify the query params\n    query_params = _BasePredictionServiceRestTransport._BaseCancelOperation._get_query_params_json(\n        transcoded_request\n    )\n\n    if CLIENT_LOGGING_SUPPORTED and _LOGGER.isEnabledFor(\n        logging.DEBUG\n    ):  # pragma: NO COVER\n        request_url = \"{host}{uri}\".format(\n            host=self._host, uri=transcoded_request[\"uri\"]\n        )\n        method = transcoded_request[\"method\"]\n        try:\n            request_payload = json_format.MessageToJson(request)\n        except:\n            request_payload = None\n        http_request = {\n            \"payload\": request_payload,\n            \"requestMethod\": method,\n            \"requestUrl\": request_url,\n            \"headers\": dict(metadata),\n        }\n        _LOGGER.debug(\n            f\"Sending request for google.cloud.aiplatform_v1.PredictionServiceClient.CancelOperation\",\n            extra={\n                \"serviceName\": \"google.cloud.aiplatform.v1.PredictionService\",\n                \"rpcName\": \"CancelOperation\",\n                \"httpRequest\": http_request,\n                \"metadata\": http_request[\"headers\"],\n            },\n        )\n\n    # Send the request\n    response = PredictionServiceRestTransport._CancelOperation._get_response(\n        self._host,\n        metadata,\n        query_params,\n        self._session,\n        timeout,\n        transcoded_request,\n    )\n\n    # In case of error, raise the appropriate core_exceptions.GoogleAPICallError exception\n    # subclass.\n    if response.status_code >= 400:\n        raise core_exceptions.from_http_response(response)\n\n    return self._interceptor.post_cancel_operation(None)\n",
    "hash_value": "59d475eada30831206a1e6a144322aad"
  }
]