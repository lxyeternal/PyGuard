[
  {
    "metadata": {
      "package_name": "wandb-0.19.9",
      "total_matches": 3,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "sender.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/wandb-0.19.9/wandb-0.19.9/wandb/sdk/internal/sender.py",
    "line_number": "1602",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1601\t        server_info = self.get_server_info()\n1602\t        max_cli_version = server_info.get(\"cliVersionInfo\", {}).get(\n1603\t            \"max_cli_version\", None",
    "context_snippet": "def _max_cli_version(self) -> Optional[str]:\n    server_info = self.get_server_info()\n    max_cli_version = server_info.get(\"cliVersionInfo\", {}).get(\n        \"max_cli_version\", None\n    )\n    if not isinstance(max_cli_version, str):\n        return None\n    return max_cli_version",
    "hash_value": "7c78d5fca569e591de8e0e70ed9664ba"
  },
  {
    "pyfile": "audio.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/wandb-0.19.9/wandb-0.19.9/wandb/sdk/data_types/audio.py",
    "line_number": "51",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "50\t            tmp_path = os.path.join(MEDIA_TMP.name, runid.generate_id() + \".wav\")\n51\t            soundfile.write(tmp_path, data_or_path, sample_rate)\n52\t            self._duration = len(data_or_path) / float(sample_rate)",
    "context_snippet": "def __init__(self, data_or_path, sample_rate=None, caption=None):\n    \"\"\"Accept a path to an audio file or a numpy array of audio data.\"\"\"\n    super().__init__(caption=caption)\n    self._duration = None\n    self._sample_rate = sample_rate\n\n    if isinstance(data_or_path, str):\n        if self.path_is_reference(data_or_path):\n            self._path = data_or_path\n            self._sha256 = hashlib.sha256(data_or_path.encode(\"utf-8\")).hexdigest()\n            self._is_tmp = False\n        else:\n            self._set_file(data_or_path, is_tmp=False)\n    else:\n        if sample_rate is None:\n            raise ValueError(\n                'Argument \"sample_rate\" is required when instantiating wandb.Audio with raw data.'\n            )\n\n        soundfile = util.get_module(\n            \"soundfile\",\n            required='Raw audio requires the soundfile package. To get it, run \"pip install soundfile\"',\n        )\n\n        tmp_path = os.path.join(MEDIA_TMP.name, runid.generate_id() + \".wav\")\n        soundfile.write(tmp_path, data_or_path, sample_rate)\n        self._duration = len(data_or_path) / float(sample_rate)\n\n        self._set_file(tmp_path, is_tmp=True)",
    "hash_value": "0d57004ba267f393c50eca44c675bc3f"
  },
  {
    "pyfile": "__init__.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/wandb-0.19.9/wandb-0.19.9/wandb/vendor/pygments/formatters/__init__.py",
    "line_number": "101",
    "type_description": "B800:exec_used",
    "severity": "Medium",
    "confidence": "High",
    "original_snippet": "100\t        custom_namespace = {}\n101\t        exec(open(filename, 'rb').read(), custom_namespace)\n102\t        # Retrieve the class `formattername` from that namespace",
    "context_snippet": "def load_formatter_from_file(filename, formattername=\"CustomFormatter\",\n                             **options):\n    \"\"\"Load a formatter from a file.\n\n    This method expects a file located relative to the current working\n    directory, which contains a class named CustomFormatter. By default,\n    it expects the Formatter to be named CustomFormatter; you can specify\n    your own class name as the second argument to this function.\n\n    Users should be very careful with the input, because this method\n    is equivalent to running eval on the input file.\n\n    Raises ClassNotFound if there are any problems importing the Formatter.\n\n    .. versionadded:: 2.2\n    \"\"\"\n    try:\n        # This empty dict will contain the namespace for the exec'd file\n        custom_namespace = {}\n        exec(open(filename, 'rb').read(), custom_namespace)\n        # Retrieve the class `formattername` from that namespace\n        if formattername not in custom_namespace:\n            raise ClassNotFound('no valid %s class found in %s' %\n                                (formattername, filename))\n        formatter_class = custom_namespace[formattername]\n        # And finally instantiate it with the options\n        return formatter_class(**options)\n    except IOError as err:\n        raise ClassNotFound('cannot read %s' % filename)\n    except ClassNotFound as err:\n        raise\n    except Exception as err:\n        raise ClassNotFound('error when loading custom formatter: %s' % err)\n",
    "hash_value": "2a588baa6d45634803c14f85cf9ced31"
  }
]