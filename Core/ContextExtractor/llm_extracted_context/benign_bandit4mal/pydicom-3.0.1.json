[
  {
    "metadata": {
      "package_name": "pydicom-3.0.1",
      "total_matches": 3,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "test_rle_pixel_data.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pydicom-3.0.1/pydicom-3.0.1/tests/test_rle_pixel_data.py",
    "line_number": "259",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "258\t        \"\"\"Test can read and access elements in unsupported datasets.\"\"\"\n259\t        ds = dcmread(fpath)\n260\t        assert ds.file_meta.TransferSyntaxUID == data[0]",
    "context_snippet": "@pytest.mark.parametrize(\"fpath,data\", REFERENCE_DATA_UNSUPPORTED)\ndef test_can_access_unsupported_dataset(self, fpath, data):\n    \"\"\"Test can read and access elements in unsupported datasets.\"\"\"\n    ds = dcmread(fpath)\n    assert ds.file_meta.TransferSyntaxUID == data[0]\n    assert ds.PatientName == data[1]",
    "hash_value": "627e1b7c9eabbfa96dd4f37865ff1f91"
  },
  {
    "pyfile": "bench_rle_encode.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pydicom-3.0.1/pydicom-3.0.1/benchmarks/bench_rle_encode.py",
    "line_number": "36",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "35\t        self.arr16_3 = ds.pixel_array\n36\t        ds = dcmread(EXPL_32_1_1F)\n37\t        self.arr32_1 = ds.pixel_array",
    "context_snippet": "from pydicom import dcmread\nfrom pydicom.data import get_testdata_file\n\n# 8/8-bit, 1 sample/pixel, 1 frame\nEXPL_8_1_1F = get_testdata_file(\"OBXXXX1A.dcm\")\n# 8/8-bit, 3 sample/pixel, 1 frame\nEXPL_8_3_1F = get_testdata_file(\"SC_rgb.dcm\")\n# 16/16-bit, 1 sample/pixel, 1 frame\nEXPL_16_1_1F = get_testdata_file(\"MR_small.dcm\")\n# 16/16-bit, 3 sample/pixel, 1 frame\nEXPL_16_3_1F = get_testdata_file(\"SC_rgb_16bit.dcm\")\n# 32/32-bit, 1 sample/pixel, 1 frame\nEXPL_32_1_1F = get_testdata_file(\"rtdose_1frame.dcm\")\n# 32/32-bit, 3 sample/pixel, 1 frame\nEXPL_32_3_1F = get_testdata_file(\"SC_rgb_32bit.dcm\")\n\nclass TimeRLEEncodeFrame:\n    \"\"\"Time tests for rle_handler.rle_encode_frame.\"\"\"\n\n    def setup(self):\n        ds = dcmread(EXPL_8_1_1F)\n        self.arr8_1 = ds.pixel_array\n        ds = dcmread(EXPL_8_3_1F)\n        self.arr8_3 = ds.pixel_array\n        ds = dcmread(EXPL_16_1_1F)\n        self.arr16_1 = ds.pixel_array\n        ds = dcmread(EXPL_16_3_1F)\n        self.arr16_3 = ds.pixel_array\n        ds = dcmread(EXPL_32_1_1F)\n        self.arr32_1 = ds.pixel_array\n        ds = dcmread(EXPL_32_3_1F)\n        self.arr32_3 = ds.pixel_array\n\n        self.no_runs = 100",
    "hash_value": "8a88a0366f3aab14a0e51e9a46ea6e25"
  },
  {
    "pyfile": "generate_dicom_dict.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pydicom-3.0.1/pydicom-3.0.1/util/generate_dict/generate_dicom_dict.py",
    "line_number": "338",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "337\t    with open(PYDICOM_DICT_FILENAME, \"w\") as f:\n338\t        f.write(\n339\t            '\"\"\"DICOM data dictionary auto-generated by '\n340\t            f'{os.path.basename(__file__)}\"\"\"\\n\\n'\n341\t        )",
    "context_snippet": "import os\n\n_PKG_DIRECTORY = Path(__file__).parent.parent.parent / \"src\" / \"pydicom\"\nPYDICOM_DICT_FILENAME = _PKG_DIRECTORY / \"_dicom_dict.py\"\n\nif __name__ == \"__main__\":\n    args = setup_argparse()\n    USE_DOWNLOAD = True\n    if args.local:\n        USE_DOWNLOAD = False\n\n    attrs = []\n\n    if not USE_DOWNLOAD:\n        local_dir = Path(args.local)\n        part_06 = (local_dir / \"part06.xml\").resolve(strict=True)\n        part_07 = (local_dir / \"part07.xml\").resolve(strict=True)\n    else:\n        url = \"https://dicom.nema.org/medical/dicom/current/source/docbook\"\n        url_06 = f\"{url}/part06/part06.xml\"\n        url_07 = f\"{url}/part07/part07.xml\"\n        print(f\"Downloading '{url_06}'\")\n        part_06 = urllib2.urlopen(url_06)\n        print(f\"Downloading '{url_07}'\")\n        part_07 = urllib2.urlopen(url_07)\n        print(\"Downloads complete, processing...\")\n\n    # The public and repeating group elements - Part 6\n    tree = ET.parse(part_06)\n    root = tree.getroot()\n\n    # Check the version is up to date\n    dcm_version = root.find(f\"{BR}subtitle\")\n    dcm_version = dcm_version.text.split()[2]\n    lib_version = getattr(_version, \"__dicom_version__\", None)\n    if lib_version != dcm_version:\n        print(\n            \"Warning: 'pydicom._version.__dicom_version__' needs to be \"\n            f\"updated to '{dcm_version}'\"\n        )\n\n    title = \"Registry of DICOM\"\n    attrs += parse_docbook_table(root, f\"{title} Data Elements\")\n    attrs += parse_docbook_table(root, f\"{title} File Meta Elements\")\n    attrs += parse_docbook_table(root, f\"{title} Directory Structuring Elements\")\n\n    # Get the Command Group elements (0000,eeee) - Part 7\n    tree = ET.parse(part_07)\n    root = tree.getroot()\n    command_attrs = parse_docbook_table(root, \"Command Fields\")\n    for attr in command_attrs:\n        attr[\"Name\"] = attr[\"Message Field\"]\n        attr[\"Retired\"] = \"\"\n\n    retired_command_attrs = parse_docbook_table(root, \"Retired Command Fields\")\n    for attr in retired_command_attrs:\n        attr[\"Name\"] = attr[\"Message Field\"]\n        attr[\"Retired\"] = \"Retired\"\n\n    attrs += command_attrs\n    attrs += retired_command_attrs\n\n    # Create the dictionary\n    attrs = sorted(attrs, key=lambda x: x[\"Tag\"])\n\n    main_attributes = []\n    mask_attributes = []\n\n    for attr in attrs:\n        group, elem = attr[\"Tag\"][1:-1].split(\",\")\n\n        # e.g. (FFFE,E000)\n        if attr[\"VR\"] == \"See Note\":\n            attr[\"VR\"] = \"NONE\"\n\n        # e.g. (0018,1153), (0018,8150) and (0018,8151)\n        # SyntaxError without encoding statement\n        # replace micro symbol\n        attr[\"Name\"] = attr[\"Name\"].replace(\"Âµ\", \"u\")\n\n        # some new tags don't have the retired entry (2019)\n        if \"Retired\" not in attr:\n            attr[\"Retired\"] = \"\"\n        # e.g. (0014,0023) and (0018,9445)\n        elif attr[\"Retired\"] in [\"RET\", \"RET - See Note\"]:\n            attr[\"Retired\"] = \"Retired\"\n        # since 2019 the year is added, e.g. RET(2007)\n        elif attr[\"Retired\"].startswith(\"RET (\"):\n            attr[\"Retired\"] = \"Retired\"\n        # e.g. (0008,0102), (0014,0025), (0040,A170)\n        elif attr[\"Retired\"] in [\"DICOS\", \"DICONDE\", \"See Note\"]:\n            attr[\"Retired\"] = \"\"\n\n        # e.g. (0028,1200)\n        attr[\"VM\"] = attr[\"VM\"].split(\" or \")[0]\n\n        # If blank then add dummy vals\n        # e.g. (0018,9445) and (0028,0020)\n        if attr[\"VR\"] == \"\" and attr[\"VM\"] == \"\":\n            attr[\"VR\"] = \"OB\"\n            attr[\"VM\"] = \"1\"\n            attr[\"Name\"] = \"Retired-blank\"\n\n        # handle retired 'repeating group' tags\n        # e.g. (50xx,eeee) or (gggg,31xx)\n        if \"x\" in group or \"x\" in elem:\n            attr[\"Tag\"] = group + elem\n            mask_attributes.append(attr)\n        else:\n            attr[\"Tag\"] = f\"0x{group}{elem}\"\n            main_attributes.append(attr)\n\n    with open(PYDICOM_DICT_FILENAME, \"w\") as f:\n        f.write(\n            '\"\"\"DICOM data dictionary auto-generated by '\n            f'{os.path.basename(__file__)}\"\"\"\\n\\n'\n        )\n        f.write(\"# Each dict entry is Tag: (VR, VM, Name, Retired, Keyword)\")\n        write_dict(f, MAIN_DICT_NAME, main_attributes, tag_is_string=False)\n        write_dict(f, MASK_DICT_NAME, mask_attributes, tag_is_string=True)\n",
    "hash_value": "84c8a862153936dc4808bcdb50f313c1"
  }
]