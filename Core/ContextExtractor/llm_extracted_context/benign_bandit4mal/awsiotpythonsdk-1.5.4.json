[
  {
    "metadata": {
      "package_name": "awsiotpythonsdk-1.5.4",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:40"
    }
  },
  {
    "pyfile": "client.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/awsiotpythonsdk-1.5.4/AWSIoTPythonSDK-1.5.4/AWSIoTPythonSDK/core/protocol/paho/client.py",
    "line_number": "1592",
    "type_description": "B809:recv",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1591\t                else:\n1592\t                    data = self._sock.recv(self._in_packet['to_process'])\n1593\t            except socket.error as err:",
    "context_snippet": "def _packet_read(self):\n    # This gets called if pselect() indicates that there is network data\n    # available - ie. at least one byte.  What we do depends on what data we\n    # already have.\n    # If we've not got a command, attempt to read one and save it. This should\n    # always work because it's only a single byte.\n    # Then try to read the remaining length. This may fail because it is may\n    # be more than one byte - will need to save data pending next read if it\n    # does fail.\n    # Then try to read the remaining payload, where 'payload' here means the\n    # combined variable header and actual payload. This is the most likely to\n    # fail due to longer length, so save current data and current position.\n    # After all data is read, send to _mqtt_handle_packet() to deal with.\n    # Finally, free the memory and reset everything to starting conditions.\n    if self._in_packet['command'] == 0:\n        try:\n            if self._ssl:\n                command = self._ssl.read(1)\n            else:\n                command = self._sock.recv(1)\n        except socket.error as err:\n            if self._ssl and (err.errno == ssl.SSL_ERROR_WANT_READ or err.errno == ssl.SSL_ERROR_WANT_WRITE):\n                return MQTT_ERR_AGAIN\n            if err.errno == EAGAIN:\n                return MQTT_ERR_AGAIN\n            print(err)\n            return 1\n        else:\n            if len(command) == 0:\n                return 1\n            command = struct.unpack(\"!B\", command)\n            self._in_packet['command'] = command[0]\n\n    if self._in_packet['have_remaining'] == 0:\n        # Read remaining\n        # Algorithm for decoding taken from pseudo code at\n        # http://publib.boulder.ibm.com/infocenter/wmbhelp/v6r0m0/topic/com.ibm.etools.mft.doc/ac10870_.htm\n        while True:\n            try:\n                if self._ssl:\n                    byte = self._ssl.read(1)\n                else:\n                    byte = self._sock.recv(1)\n            except socket.error as err:\n                if self._ssl and (err.errno == ssl.SSL_ERROR_WANT_READ or err.errno == ssl.SSL_ERROR_WANT_WRITE):\n                    return MQTT_ERR_AGAIN\n                if err.errno == EAGAIN:\n                    return MQTT_ERR_AGAIN\n                print(err)\n                return 1\n            else:\n                byte = struct.unpack(\"!B\", byte)\n                byte = byte[0]\n                self._in_packet['remaining_count'].append(byte)\n                # Max 4 bytes length for remaining length as defined by protocol.\n                 # Anything more likely means a broken/malicious client.\n                if len(self._in_packet['remaining_count']) > 4:\n                    return MQTT_ERR_PROTOCOL\n\n                self._in_packet['remaining_length'] = self._in_packet['remaining_length'] + (byte & 127)*self._in_packet['remaining_mult']\n                self._in_packet['remaining_mult'] = self._in_packet['remaining_mult'] * 128\n\n            if (byte & 128) == 0:\n                break\n\n        self._in_packet['have_remaining'] = 1\n        self._in_packet['to_process'] = self._in_packet['remaining_length']\n\n    while self._in_packet['to_process'] > 0:\n        try:\n            if self._ssl:\n                data = self._ssl.read(self._in_packet['to_process'])\n            else:\n                data = self._sock.recv(self._in_packet['to_process'])\n        except socket.error as err:\n            if self._ssl and (err.errno == ssl.SSL_ERROR_WANT_READ or err.errno == ssl.SSL_ERROR_WANT_WRITE):\n                return MQTT_ERR_AGAIN\n            if err.errno == EAGAIN:\n                return MQTT_ERR_AGAIN\n            print(err)\n            return 1\n        else:\n            self._in_packet['to_process'] = self._in_packet['to_process'] - len(data)\n            self._in_packet['packet'] = self._in_packet['packet'] + data\n\n    # All data for this packet is read.\n    self._in_packet['pos'] = 0\n    rc = self._packet_handle()\n\n    # Free data and reset values\n    self._in_packet = dict(\n        command=0,\n        have_remaining=0,\n        remaining_count=[],\n        remaining_mult=1,\n        remaining_length=0,\n        packet=b\"\",\n        to_process=0,\n        pos=0)\n\n    self._msgtime_mutex.acquire()\n    self._last_msg_in = time.time()\n    self._msgtime_mutex.release()\n    return rc",
    "hash_value": "ed3fb1df25a2df765ffc3b8f92cb618b"
  }
]