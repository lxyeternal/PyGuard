[
  {
    "metadata": {
      "package_name": "jmetalpy-1.7.0",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "experiment.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/jmetalpy-1.7.0/jmetalpy-1.7.0/jmetal/lab/experiment.py",
    "line_number": "850",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "849\n850\t    output.write(\"\\\\usepackage[utf8]{inputenc}\\n\")\n851\t    output.write(\"\\\\usepackage{tabularx}\\n\")",
    "context_snippet": "def __averages_to_latex(\n        central_tendency: pd.DataFrame,\n        dispersion: pd.DataFrame,\n        caption: str,\n        label: str,\n        minimization=True,\n        alignment: str = \"c\",\n):\n    \"\"\"Convert a pandas DataFrame to a LaTeX tabular. Prints labels in bold and does use math mode.\n\n    :param caption: LaTeX table caption.\n    :param label: LaTeX table label.\n    :param minimization: If indicator is minimization, highlight the best values of mean/median; else, the lowest.\n    \"\"\"\n    num_columns, num_rows = central_tendency.shape[1], central_tendency.shape[0]\n    output = io.StringIO()\n\n    col_format = \"{}|{}\".format(alignment, alignment * num_columns)\n    column_labels = [\"\\\\textbf{{{0}}}\".format(label.replace(\"_\", \"\\\\_\")) for label in central_tendency.columns]\n\n    # Write header\n    output.write(\"\\\\documentclass{article}\\n\")\n\n    output.write(\"\\\\usepackage[utf8]{inputenc}\\n\")\n    output.write(\"\\\\usepackage{tabularx}\\n\")\n    output.write(\"\\\\usepackage{colortbl}\\n\")\n    output.write(\"\\\\usepackage[table*]{xcolor}\\n\")\n\n    output.write(\"\\\\xdefinecolor{gray95}{gray}{0.65}\\n\")\n    output.write(\"\\\\xdefinecolor{gray25}{gray}{0.8}\\n\")\n\n    output.write(\"\\\\title{Median and IQR}\\n\")\n    output.write(\"\\\\author{}\\n\")\n\n    output.write(\"\\\\begin{document}\\n\")\n    output.write(\"\\\\maketitle\\n\")\n\n    output.write(\"\\\\section{Table}\\n\")\n\n    output.write(\"\\\\begin{table}[!htp]\\n\")\n    output.write(\"  \\\\caption{{{}}}\\n\".format(caption))\n    output.write(\"  \\\\label{{{}}}\\n\".format(label))\n    output.write(\"  \\\\centering\\n\")\n    output.write(\"  \\\\begin{scriptsize}\\n\")\n    output.write(\"  \\\\begin{tabular}{%s}\\n\" % col_format)\n    output.write(\"      & {} \\\\\\\\\\\\hline\\n\".format(\" & \".join(column_labels)))\n\n    # Write data lines\n    for i in range(num_rows):\n        central_values = [v for v in central_tendency.iloc[i]]\n        dispersion_values = [v for v in dispersion.iloc[i]]\n\n        # Sort mean/median values (the lower the better if minimization)\n        # Note that mean/median values could be the same: in that case, sort by Std/IQR (the lower the better)\n        sorted_values = sorted(\n            zip(central_values, dispersion_values, [i for i in range(len(central_values))]), key=lambda v: (v[0], -v[1])\n        )\n\n        if minimization:\n            second_best, best = sorted_values[0][2], sorted_values[1][2]\n        else:\n            second_best, best = sorted_values[-1][2], sorted_values[-2][2]\n\n        # Compose cell\n        values = [\n            \"{:.2e}_{{{:.2e}}}\".format(central_values[i], dispersion_values[i]) for i in range(len(central_values))\n        ]\n\n        # Highlight values\n        values[best] = \"\\\\cellcolor{gray25} \" + values[best]\n        values[second_best] = \"\\\\cellcolor{gray95} \" + values[second_best]\n\n        output.write(\n            \"      \\\\textbf{{{0}}} & ${1}$ \\\\\\\\n\".format(\n                central_tendency.index[i], \" $ & $ \".join([str(val) for val in values])\n            )\n        )\n\n    # Write footer\n    output.write(\"  \\\\end{tabular}\\n\")\n    output.write(\"  \\\\end{scriptsize}\\n\")\n    output.write(\"\\\\end{table}\\n\")\n\n    output.write(\"\\\\end{document}\")\n\n    return output.getvalue()",
    "hash_value": "6210d65ef14aef2c2a4b3d4b017f9dd0"
  },
  {
    "pyfile": "evaluator.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/jmetalpy-1.7.0/jmetalpy-1.7.0/jmetal/util/evaluator.py",
    "line_number": "52",
    "type_description": "B839:pool",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "51\t        super().__init__()\n52\t        self.pool = Pool(processes)\n53",
    "context_snippet": "class MultiprocessEvaluator(Evaluator[S]):\n    def __init__(self, processes: int = None):\n        super().__init__()\n        self.pool = Pool(processes)\n\n    def evaluate(self, solution_list: List[S], problem: Problem) -> List[S]:\n        return self.pool.map(functools.partial(evaluate_solution, problem=problem), solution_list)",
    "hash_value": "f99642521e5c3cd969966f7c49bc3286"
  }
]