[
  {
    "metadata": {
      "package_name": "numpy-2.2.4",
      "total_matches": 4,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "depfixer.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/numpy-2.2.4/numpy-2.2.4/vendored-meson/meson/mesonbuild/scripts/depfixer.py",
    "line_number": "82",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "81\t# Elf64_Word\n82\t        self.sh_type = struct.unpack(self.Word, ifile.read(self.WordSize))[0]\n83\t# Elf64_Xword",
    "context_snippet": "class SectionHeader(DataSizes):\n    def __init__(self, ifile: T.BinaryIO, ptrsize: int, is_le: bool) -> None:\n        super().__init__(ptrsize, is_le)\n        is_64 = ptrsize == 64\n\n# Elf64_Word\n        self.sh_name = struct.unpack(self.Word, ifile.read(self.WordSize))[0]\n# Elf64_Word\n        self.sh_type = struct.unpack(self.Word, ifile.read(self.WordSize))[0]\n# Elf64_Xword\n        if is_64:\n            self.sh_flags = struct.unpack(self.XWord, ifile.read(self.XWordSize))[0]\n        else:\n            self.sh_flags = struct.unpack(self.Word, ifile.read(self.WordSize))[0]\n# Elf64_Addr\n        self.sh_addr = struct.unpack(self.Addr, ifile.read(self.AddrSize))[0]\n# Elf64_Off\n        self.sh_offset = struct.unpack(self.Off, ifile.read(self.OffSize))[0]\n# Elf64_Xword\n        if is_64:\n            self.sh_size = struct.unpack(self.XWord, ifile.read(self.XWordSize))[0]\n        else:\n            self.sh_size = struct.unpack(self.Word, ifile.read(self.WordSize))[0]\n# Elf64_Word\n        self.sh_link = struct.unpack(self.Word, ifile.read(self.WordSize))[0]\n# Elf64_Word\n        self.sh_info = struct.unpack(self.Word, ifile.read(self.WordSize))[0]\n# Elf64_Xword\n        if is_64:\n            self.sh_addralign = struct.unpack(self.XWord, ifile.read(self.XWordSize))[0]\n        else:\n            self.sh_addralign = struct.unpack(self.Word, ifile.read(self.WordSize))[0]\n# Elf64_Xword\n        if is_64:\n            self.sh_entsize = struct.unpack(self.XWord, ifile.read(self.XWordSize))[0]\n        else:\n            self.sh_entsize = struct.unpack(self.Word, ifile.read(self.WordSize))[0]",
    "hash_value": "59f9cd4589ccb0b5b38afb9b8f2d2553"
  },
  {
    "pyfile": "xcodebackend.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/numpy-2.2.4/numpy-2.2.4/vendored-meson/meson/mesonbuild/backend/xcodebackend.py",
    "line_number": "186",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "185\t                    else:\n186\t                        ofile.write(indent_level*INDENT + f'{i.key} = ')\n187\t                    i.value.write(ofile, indent_level)",
    "context_snippet": "class PbxDict:\n    def __init__(self) -> None:\n        # This class is a bit weird, because we want to write PBX dicts in\n        # defined order _and_ we want to write intermediate comments also in order.\n        self.keys: T.Set[str] = set()\n        self.items: T.List[T.Union[PbxDictItem, PbxComment]] = []\n\n    def add_item(self, key: str, value: T.Union[PbxArray, PbxDict, str, int], comment: str = '') -> None:\n        assert key not in self.keys\n        item = PbxDictItem(key, value, comment)\n        self.keys.add(key)\n        self.items.append(item)\n\n    def has_item(self, key: str) -> bool:\n        return key in self.keys\n\n    def add_comment(self, comment: PbxComment) -> None:\n        assert isinstance(comment, PbxComment)\n        self.items.append(comment)\n\n    def write(self, ofile: T.TextIO, indent_level: int) -> None:\n        ofile.write('{\n')\n        indent_level += 1\n        for i in self.items:\n            if isinstance(i, PbxComment):\n                i.write(ofile, indent_level)\n            elif isinstance(i, PbxDictItem):\n                if isinstance(i.value, (str, int)):\n                    if i.comment:\n                        ofile.write(indent_level*INDENT + f'{i.key} = {i.value} {i.comment};\\n')\n                    else:\n                        ofile.write(indent_level*INDENT + f'{i.key} = {i.value};\\n')\n                elif isinstance(i.value, PbxDict):\n                    if i.comment:\n                        ofile.write(indent_level*INDENT + f'{i.key} {i.comment} = ')\n                    else:\n                        ofile.write(indent_level*INDENT + f'{i.key} = ')\n                    i.value.write(ofile, indent_level)\n                elif isinstance(i.value, PbxArray):\n                    if i.comment:\n                        ofile.write(indent_level*INDENT + f'{i.key} {i.comment} = ')\n                    else:\n                        ofile.write(indent_level*INDENT + f'{i.key} = ')\n                    i.value.write(ofile, indent_level)\n                else:\n                    print(i)\n                    print(i.key)\n                    print(i.value)\n                    raise RuntimeError('missing code')\n            else:\n                print(i)\n                raise RuntimeError('missing code2')\n\n        indent_level -= 1\n        ofile.write(indent_level*INDENT + '}')\n        if indent_level == 0:\n            ofile.write('\\n')\n        else:\n            ofile.write(';\n')",
    "hash_value": "c8b10006ca6b6120ff9a422d0177b5ef"
  },
  {
    "pyfile": "wrap.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/numpy-2.2.4/numpy-2.2.4/vendored-meson/meson/mesonbuild/wrap/wrap.py",
    "line_number": "276",
    "type_description": "B832:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "275\t            with open(self.get_hashfile(subproject_directory), 'w', encoding='utf-8') as file:\n276\t                file.write(self.wrapfile_hash + '\\n')\n277",
    "context_snippet": "def update_hash_cache(self, subproject_directory: str) -> None:\n    if self.wrapfile_hash:\n        with open(self.get_hashfile(subproject_directory), 'w', encoding='utf-8') as file:\n            file.write(self.wrapfile_hash + '\\n')",
    "hash_value": "b654765d513bcb34cf02542a3e2fc873"
  },
  {
    "pyfile": "misc_util.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/numpy-2.2.4/numpy-2.2.4/numpy/distutils/misc_util.py",
    "line_number": "28",
    "type_description": "B836:rmtree",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "27\t            try:\n28\t                shutil.rmtree(d)\n29\t            except OSError:",
    "context_snippet": "def clean_up_temporary_directory():\n    if _tmpdirs is not None:\n        for d in _tmpdirs:\n            try:\n                shutil.rmtree(d)\n            except OSError:\n                pass",
    "hash_value": "caa26d686bb9959e966f90e7fde90cbe"
  }
]