[
  {
    "metadata": {
      "package_name": "kafka_python-2.1.5",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:40"
    }
  },
  {
    "pyfile": "client_async.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/kafka_python-2.1.5/kafka_python-2.1.5/kafka/client_async.py",
    "line_number": "607",
    "type_description": "B804:connect",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "606\t        if not conn or not self._can_send_request(node_id):\n607\t            self.maybe_connect(node_id, wakeup=wakeup)\n608\t            return Future().failure(Errors.NodeNotReadyError(node_id))",
    "context_snippet": "def send(self, node_id, request, wakeup=True, request_timeout_ms=None):\n    \"\"\"Send a request to a specific node. Bytes are placed on an\n    internal per-connection send-queue. Actual network I/O will be\n    triggered in a subsequent call to .poll()\n\n    Arguments:\n        node_id (int): destination node\n        request (Struct): request object (not-encoded)\n\n    Keyword Arguments:\n        wakeup (bool, optional): optional flag to disable thread-wakeup.\n        request_timeout_ms (int, optional): Provide custom timeout in milliseconds.\n            If response is not processed before timeout, client will fail the\n            request and close the connection.\n            Default: None (uses value from client configuration)\n\n    Raises:\n        AssertionError: if node_id is not in current cluster metadata\n\n    Returns:\n        Future: resolves to Response struct or Error\n    \"\"\"\n    conn = self._conns.get(node_id)\n    if not conn or not self._can_send_request(node_id):\n        self.maybe_connect(node_id, wakeup=wakeup)\n        return Future().failure(Errors.NodeNotReadyError(node_id))\n\n    # conn.send will queue the request internally\n    # we will need to call send_pending_requests()\n    # to trigger network I/O\n    future = conn.send(request, blocking=False, request_timeout_ms=request_timeout_ms)\n    if not future.is_done:\n        self._sending.add(conn)\n\n    # Wakeup signal is useful in case another thread is\n    # blocked waiting for incoming network traffic while holding\n    # the client lock in poll().\n    if wakeup:\n        self.wakeup()\n\n    return future",
    "hash_value": "8a6df83606210ddc0a068a227d99dcef"
  }
]