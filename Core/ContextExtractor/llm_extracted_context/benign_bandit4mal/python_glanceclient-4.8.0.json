[
  {
    "metadata": {
      "package_name": "python_glanceclient-4.8.0",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:40"
    }
  },
  {
    "pyfile": "https.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/python_glanceclient-4.8.0/python_glanceclient-4.8.0/glanceclient/common/https.py",
    "line_number": "250",
    "type_description": "B804:connect",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "249\t        self.sock = OpenSSLConnectionDelegator(self.context, sock)\n250\t        self.sock.connect((self.host, self.port))",
    "context_snippet": "def connect(self):\n    \"\"\"Connect to an SSL port using the OpenSSL library.\n\n    This method also applies per-connection parameters to the connection.\n    \"\"\"\n    result = socket.getaddrinfo(self.host, self.port, 0,\n                                socket.SOCK_STREAM)\n    if result:\n        socket_family = result[0][0]\n        if socket_family == socket.AF_INET6:\n            sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)\n        else:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    else:\n        # If due to some reason the address lookup fails - we still connect\n        # to IPv4 socket. This retains the older behavior.\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    if self.timeout is not None:\n        # '0' microseconds\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVTIMEO,\n                        struct.pack('LL', self.timeout, 0))\n    self.sock = OpenSSLConnectionDelegator(self.context, sock)\n    self.sock.connect((self.host, self.port))",
    "hash_value": "81e469f8b2a7d30b6fed4c383ac7a816"
  }
]