[
  {
    "metadata": {
      "package_name": "pdfminer_six-20250327",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "dumppdf.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pdfminer_six-20250327/pdfminer_six-20250327/tools/dumppdf.py",
    "line_number": "236",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "235\t        out = open(path, \"wb\")\n236\t        out.write(fileobj.get_data())\n237\t        out.close()",
    "context_snippet": "def extractembedded(fname: str, password: str, extractdir: str) -> None:\n    def extract1(objid: int, obj: Dict[str, Any]) -> None:\n        filename = os.path.basename(obj.get(\"UF\") or cast(bytes, obj.get(\"F\")).decode())\n        fileref = obj[\"EF\"].get(\"UF\") or obj[\"EF\"].get(\"F\")\n        fileobj = doc.getobj(fileref.objid)\n        if not isinstance(fileobj, PDFStream):\n            error_msg = (\n                \"unable to process PDF: reference for %r is not a \"\n                \"PDFStream\" % filename\n            )\n            raise PDFValueError(error_msg)\n        if fileobj.get(\"Type\") is not LITERAL_EMBEDDEDFILE:\n            raise PDFValueError(\n                \"unable to process PDF: reference for %r \"\n                \"is not an EmbeddedFile\" % (filename),\n            )\n        path = os.path.join(extractdir, \"%.6d-%s\" % (objid, filename))\n        if os.path.exists(path):\n            raise PDFIOError(\"file exists: %r\" % path)\n        print(\"extracting: %r\" % path)\n        os.makedirs(os.path.dirname(path), exist_ok=True)\n        out = open(path, \"wb\")\n        out.write(fileobj.get_data())\n        out.close()\n\n    with open(fname, \"rb\") as fp:\n        parser = PDFParser(fp)\n        doc = PDFDocument(parser, password)\n        extracted_objids = set()\n        for xref in doc.xrefs:\n            for objid in xref.get_objids():\n                obj = doc.getobj(objid)\n                if (\n                    objid not in extracted_objids\n                    and isinstance(obj, dict)\n                    and obj.get(\"Type\") is LITERAL_FILESPEC\n                ):\n                    extracted_objids.add(objid)\n                    extract1(objid, obj)",
    "hash_value": "be1a5cefec95809189fbcc27628c449f"
  },
  {
    "pyfile": "dumppdf.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pdfminer_six-20250327/pdfminer_six-20250327/tools/dumppdf.py",
    "line_number": "45",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "44\t    if isinstance(obj, dict):\n45\t        out.write('<dict size=\"%d\">\\n' % len(obj))\n46\t        for k, v in obj.items():",
    "context_snippet": "def dumpxml(out: TextIO, obj: object, codec: Optional[str] = None) -> None:\n    if obj is None:\n        out.write(\"<null />\")\n        return\n\n    if isinstance(obj, dict):\n        out.write('<dict size=\"%d\">\\n' % len(obj))\n        for k, v in obj.items():\n            out.write(\"<key>%s</key>\\n\" % k)\n            out.write(\"<value>\")\n            dumpxml(out, v)\n            out.write(\"</value>\\n\")\n        out.write(\"</dict>\")\n        return\n\n    if isinstance(obj, list):\n        out.write('<list size=\"%d\">\\n' % len(obj))\n        for v in obj:\n            dumpxml(out, v)\n            out.write(\"\\n\")\n        out.write(\"</list>\")\n        return\n\n    if isinstance(obj, (str, bytes)):\n        out.write('<string size=\"%d\">%s</string>' % (len(obj), escape(obj)))\n        return\n\n    if isinstance(obj, PDFStream):\n        if codec == \"raw\":\n            # Bug: writing bytes to text I/O. This will raise TypeError.\n            out.write(obj.get_rawdata())  # type: ignore [arg-type]\n        elif codec == \"binary\":\n            # Bug: writing bytes to text I/O. This will raise TypeError.\n            out.write(obj.get_data())  # type: ignore [arg-type]\n        else:\n            out.write(\"<stream>\\n<props>\\n\")\n            dumpxml(out, obj.attrs)\n            out.write(\"\\n</props>\\n\")\n            if codec == \"text\":\n                data = obj.get_data()\n                out.write('<data size=\"%d\">%s</data>\\n' % (len(data), escape(data)))\n            out.write(\"</stream>\")\n        return\n\n    if isinstance(obj, PDFObjRef):\n        out.write('<ref id=\"%d\" />' % obj.objid)\n        return\n\n    if isinstance(obj, PSKeyword):\n        # Likely bug: obj.name is bytes, not str\n        out.write(\"<keyword>%s</keyword>\" % obj.name)  # type: ignore [str-bytes-safe]\n        return\n\n    if isinstance(obj, PSLiteral):\n        # Likely bug: obj.name may be bytes, not str\n        out.write(\"<literal>%s</literal>\" % obj.name)  # type: ignore [str-bytes-safe]\n        return\n\n    if isnumber(obj):\n        out.write(\"<number>%s</number>\" % obj)\n        return\n\n    raise PDFTypeError(obj)\n",
    "hash_value": "a65e150fa7702abca84f2013be580bc4"
  }
]