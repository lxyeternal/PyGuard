[
  {
    "metadata": {
      "package_name": "cookiecutter-2.6.0",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "test_hooks.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cookiecutter-2.6.0/cookiecutter-2.6.0/tests/test_hooks.py",
    "line_number": "28",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "27\t        f.write(\"# -*- coding: utf-8 -*-\\n\")\n28\t        f.write(\"from __future__ import print_function\\n\")\n29\t        f.write(\"\\n\")",
    "context_snippet": "def make_test_repo(name, multiple_hooks=False):\n    \"\"\"Create test repository for test setup methods.\"\"\"\n    hook_dir = os.path.join(name, 'hooks')\n    template = os.path.join(name, 'input{{hooks}}')\n    os.mkdir(name)\n    os.mkdir(hook_dir)\n    os.mkdir(template)\n\n    Path(template, 'README.rst').write_text(\"foo\\n===\\n\\nbar\\n\")\n\n    with Path(hook_dir, 'pre_gen_project.py').open('w') as f:\n        f.write(\"#!/usr/bin/env python\\n\")\n        f.write(\"# -*- coding: utf-8 -*-\\n\")\n        f.write(\"from __future__ import print_function\\n\")\n        f.write(\"\\n\")\n        f.write(\"print('pre generation hook')\\n\")\n        f.write(\"f = open('python_pre.txt', 'w')\\n\")\n        f.write(\"f.close()\\n\")\n\n    if sys.platform.startswith('win'):\n        post = 'post_gen_project.bat'\n        with Path(hook_dir, post).open('w') as f:\n            f.write(\"@echo off\\n\")\n            f.write(\"\\n\")\n            f.write(\"echo post generation hook\\n\")\n            f.write(\"echo. >shell_post.txt\\n\")\n    else:\n        post = 'post_gen_project.sh'\n        filename = os.path.join(hook_dir, post)\n        with Path(filename).open('w') as f:\n            f.write(\"#!/bin/bash\\n\")\n            f.write(\"\\n\")\n            f.write(\"echo 'post generation hook';\\n\")\n            f.write(\"touch 'shell_post.txt'\\n\")\n        # Set the execute bit\n        os.chmod(filename, os.stat(filename).st_mode | stat.S_IXUSR)\n\n    # Adding an additional pre script\n    if multiple_hooks:\n        if sys.platform.startswith('win'):\n            pre = 'pre_gen_project.bat'\n            with Path(hook_dir, pre).open('w') as f:\n                f.write(\"@echo off\\n\")\n                f.write(\"\\n\")\n                f.write(\"echo post generation hook\\n\")\n                f.write(\"echo. >shell_pre.txt\\n\")\n        else:\n            pre = 'pre_gen_project.sh'\n            filename = os.path.join(hook_dir, pre)\n            with Path(filename).open('w') as f:\n                f.write(\"#!/bin/bash\\n\")\n                f.write(\"\\n\")\n                f.write(\"echo 'post generation hook';\\n\")\n                f.write(\"touch 'shell_pre.txt'\\n\")\n            # Set the execute bit\n            os.chmod(filename, os.stat(filename).st_mode | stat.S_IXUSR)\n\n    return post",
    "hash_value": "36268a8ff88f6a1c35c27844f1a8e8d1"
  },
  {
    "pyfile": "generate.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cookiecutter-2.6.0/cookiecutter-2.6.0/cookiecutter/generate.py",
    "line_number": "391",
    "type_description": "B836:rmtree",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "390\t                    if delete_project_on_failure:\n391\t                        rmtree(project_dir)\n392\t                    _dir = os.path.relpath(unrendered_dir, output_dir)",
    "context_snippet": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n    keep_project_on_failure=False,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param skip_if_file_exists: Skip the files in the corresponding directories\n        if they already exist\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    :param keep_project_on_failure: If `True` keep generated project directory even when\n        generation fails\n    \"\"\"\n    context = context or OrderedDict([])\n\n    env = create_env_with_context(context)\n\n    template_dir = find_template(repo_dir, env)\n    logger.debug('Generating project from %s...', template_dir)\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = f\"Unable to create project directory '{unrendered_dir}'\"\n        raise UndefinedVariableInTemplate(msg, err, context) from err\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created and not keep_project_on_failure\n\n    if accept_hooks:\n        run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader(['.', '../templates'])\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    logger.debug('Found copy only path %s', d)\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n\n                # The outdir is not the root dir, it is the dir which marked as copy\n                # only in the config file. If the program hits this line, which means\n                # the overwrite_if_exists = True, and root dir exists\n                if os.path.isdir(outdir):\n                    shutil.rmtree(outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = f\"Unable to create directory '{_dir}'\"\n                    raise UndefinedVariableInTemplate(msg, err, context) from err\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = f\"Unable to create file '{infile}'\"\n                    raise UndefinedVariableInTemplate(msg, err, context) from err\n\n    if accept_hooks:\n        run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "hash_value": "7d469207851880a7bae03612444031eb"
  }
]