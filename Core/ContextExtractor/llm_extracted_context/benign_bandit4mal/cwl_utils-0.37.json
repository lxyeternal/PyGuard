[
  {
    "metadata": {
      "package_name": "cwl_utils-0.37",
      "total_matches": 6,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "cwl_v1_2.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cwl_utils-0.37/cwl_utils-0.37/cwl_utils/parser/cwl_v1_2.py",
    "line_number": "12379",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "12378\t                else:\n12379\t                    val = _doc.get(\"streamable\")\n12380\t                    if error_message != str(e):",
    "context_snippet": "else:\n    val = _doc.get(\"streamable\")",
    "hash_value": "678582d5abe0b995928f785b1084df2b"
  },
  {
    "pyfile": "cwl_v1_1.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cwl_utils-0.37/cwl_utils-0.37/cwl_utils/parser/cwl_v1_1.py",
    "line_number": "25929",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "25928\t        try:\n25929\t            if _doc.get(\"shmSize\") is None:\n25930\t                raise ValidationException(\"missing required field `shmSize`\", None, [])",
    "context_snippet": "class ShmSize(ProcessRequirement):\n    def __init__(\n        self,\n        shmSize: Any,\n        extension_fields: Optional[dict[str, Any]] = None,\n        loadingOptions: Optional[LoadingOptions] = None,\n    ) -> None:\n        if extension_fields:\n            self.extension_fields = extension_fields\n        else:\n            self.extension_fields = CommentedMap()\n        if loadingOptions:\n            self.loadingOptions = loadingOptions\n        else:\n            self.loadingOptions = LoadingOptions()\n        self.class_ = \"ShmSize\"\n        self.shmSize = shmSize\n\n    def __eq__(self, other: Any) -> bool:\n        if isinstance(other, ShmSize):\n            return bool(self.class_ == other.class_ and self.shmSize == other.shmSize)\n        return False\n\n    def __hash__(self) -> int:\n        return hash((self.class_, self.shmSize))\n\n    @classmethod\n    def fromDoc(\n        cls,\n        doc: Any,\n        baseuri: str,\n        loadingOptions: LoadingOptions,\n        docRoot: Optional[str] = None\n    ) -> \"ShmSize\":\n        _doc = copy.copy(doc)\n\n        if hasattr(doc, \"lc\"):\n            _doc.lc.data = doc.lc.data\n            _doc.lc.filename = doc.lc.filename\n        _errors__ = []\n        try:\n            if _doc.get(\"class\") is None:\n                raise ValidationException(\"missing required field `class`\", None, [])\n\n            class_ = load_field(\n                _doc.get(\"class\"),\n                uri_strtype_False_True_None_None,\n                baseuri,\n                loadingOptions,\n                lc=_doc.get(\"class\")\n            )\n\n            if class_ not in (cls.__name__, loadingOptions.vocab.get(cls.__name__)):\n               raise ValidationException(f\"tried `{cls.__name__}` but\")\n        except ValidationException as e:\n               raise e\n        try:\n            if _doc.get(\"shmSize\") is None:\n                raise ValidationException(\"missing required field `shmSize\"\", None, [])\n\n            shmSize = load_field(\n                _doc.get(\"shmSize\"),\n                strtype,\n                baseuri,\n                loadingOptions,\n                lc=_doc.get(\"shmSize\")\n            )\n\n        except ValidationException as e:\n            error_message, to_print, verb_tensage = parse_errors(str(e))\n\n            if str(e) == \"missing required field `shmSize`\":\n                _errors__.append(\n                    ValidationException(\n                        str(e),\n                        None\n                    )\n                )\n            else:\n                val = _doc.get(\"shmSize\")\n                if error_message != str(e):\n                    val_type = convert_typing(extract_type(type(val)))\n                    _errors__.append(\n                        ValidationException(\n                            \"the `shmSize` field is not valid because:\",\n                            SourceLine(_doc, \"shmSize\", str),\n                            [ValidationException(f\"Value is a {val_type}, \"\n                                                 f\"but valid {to_print} for this field \"\n                                                 f\"{verb_tensage} {error_message}\",\n                                                 detailed_message=f\"Value `{val}` is a {val_type}, \"\n                                                 f\"but valid {to_print} for this field \"\n                                                 f\"{verb_tensage} {error_message}\")],\n                        )\n                    )\n                else:\n                    _errors__.append(\n                        ValidationException(\n                            \"the `shmSize` field is not valid because:\",\n                            SourceLine(_doc, \"shmSize\", str),\n                            [e],\n                            detailed_message=f\"the `shmSize` field with value `{val}` \"\n                            \"is not valid because:\",\n                        )\n                    )\n        extension_fields: dict[str, Any] = {}\n        for k in _doc.keys():\n            if k not in cls.attrs:\n                if not k:\n                    _errors__.append(\n                        ValidationException(\"mapping with implicit null key\")\n                    )\n                elif \":\" in k:\n                    ex = expand_url(\n                        k, \"\", loadingOptions, scoped_id=False, vocab_term=False\n                    )\n                    extension_fields[ex] = _doc[k]\n                else:\n                    _errors__.append(\n                        ValidationException(\n                            \"invalid field `{}`, expected one of: `class`, `shmSize`\".format(\n                                k\n                            ),\n                            SourceLine(_doc, k, str),\n                        )\n                    )\n\n        if _errors__:\n            raise ValidationException(\"\", None, _errors__, \"*\")\n        _constructed = cls(\n            shmSize=shmSize,\n            extension_fields=extension_fields,\n            loadingOptions=loadingOptions,\n        )\n        return _constructed\n",
    "hash_value": "705d5e5d20b8046f23973c0e274cd898"
  },
  {
    "pyfile": "cwl_v1_1.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cwl_utils-0.37/cwl_utils-0.37/cwl_utils/parser/cwl_v1_1.py",
    "line_number": "12707",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "12706\t                    loadingOptions,\n12707\t                    lc=_doc.get(\"fields\")\n12708\t                )",
    "context_snippet": "fields = None\nif \"fields\" in _doc:\n    try:\n        fields = load_field(\n            _doc.get(\"fields\"),\n            idmap_fields_union_of_None_type_or_array_of_RecordFieldLoader,\n            baseuri,\n            loadingOptions,\n            lc=_doc.get(\"fields\")\n        )\n\n    except ValidationException as e:\n        error_message, to_print, verb_tensage = parse_errors(str(e))\n\n        if str(e) == \"missing required field `fields`\":\n            _errors__.append(\n                ValidationException(\n                    str(e),\n                    None\n                )\n            )\n        else:\n            val = _doc.get(\"fields\")\n            if error_message != str(e):\n                val_type = convert_typing(extract_type(type(val)))\n                _errors__.append(\n                    ValidationException(\n                        \"the `fields` field is not valid because:\",\n                        SourceLine(_doc, \"fields\", str),\n                        [ValidationException(f\"Value is a {val_type}, \"\n                                             f\"but valid {to_print} for this field \"\n                                             f\"{verb_tensage} {error_message}\",\n                                             detailed_message=f\"Value `{val}` is a {val_type}, \"\n                                             f\"but valid {to_print} for this field \"\n                                             f\"{verb_tensage} {error_message}\")],\n                    )\n                )\n            else:\n                _errors__.append(\n                    ValidationException(\n                        \"the `fields` field is not valid because:\",\n                        SourceLine(_doc, \"fields\", str),\n                        [e],\n                        detailed_message=f\"the `fields` field with value `{val}` \"\n                        \"is not valid because:\",\n                    )\n                )",
    "hash_value": "ebba55a41f1542e886a334ae318d85eb"
  },
  {
    "pyfile": "cwl_v1_1.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cwl_utils-0.37/cwl_utils-0.37/cwl_utils/parser/cwl_v1_1.py",
    "line_number": "13971",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "13970\t                    loadingOptions,\n13971\t                    lc=_doc.get(\"streamable\")\n13972\t                )",
    "context_snippet": "def load_field(\n    val: Union[str, dict[str, str]],\n    fieldtype: \"_Loader\",\n    baseuri: str,\n    loadingOptions: LoadingOptions,\n    lc: Optional[list[Any]] = None,\n) -> Any:\n    \"\"\"Load field.\"\"\"\n    if isinstance(val, MutableMapping):\n        if \"$import\" in val:\n            if loadingOptions.fileuri is None:\n                raise SchemaSaladException(\"Cannot load $import without fileuri\")\n            url = loadingOptions.fetcher.urljoin(loadingOptions.fileuri, val[\"$import\"])\n            result, metadata = _document_load_by_url(\n                fieldtype,\n                url,\n                loadingOptions,\n            )\n            loadingOptions.imports.append(url)\n            return result\n        if \"$include\" in val:\n            if loadingOptions.fileuri is None:\n                raise SchemaSaladException(\"Cannot load $import without fileuri\")\n            url = loadingOptions.fetcher.urljoin(loadingOptions.fileuri, val[\"$include\"])\n            val = loadingOptions.fetcher.fetch_text(url)\n            loadingOptions.includes.append(url)\n    return fieldtype.load(val, baseuri, loadingOptions, lc=lc)",
    "hash_value": "7da4f090ea1d5cf7061be1710c0d62cd"
  },
  {
    "pyfile": "cwl_v1_0.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cwl_utils-0.37/cwl_utils-0.37/cwl_utils/parser/cwl_v1_0.py",
    "line_number": "5008",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "5007\t                else:\n5008\t                    val = _doc.get(\"label\")\n5009\t                    if error_message != str(e):",
    "context_snippet": "else:\n    val = _doc.get(\"label\")\n    if error_message != str(e):",
    "hash_value": "ce99d08171b0312827ad7b09df6774f4"
  },
  {
    "pyfile": "cwl_v1_1.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/cwl_utils-0.37/cwl_utils-0.37/cwl_utils/parser/cwl_v1_1.py",
    "line_number": "9327",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "9326\t                else:\n9327\t                    val = _doc.get(\"valueFrom\")\n9328\t                    if error_message != str(e):",
    "context_snippet": "    @classmethod\n    def fromDoc(\n        cls,\n        doc: Any,\n        baseuri: str,\n        loadingOptions: LoadingOptions,\n        docRoot: Optional[str] = None\n    ) -> \"CommandLineBinding\":\n        _doc = copy.copy(doc)\n\n        if hasattr(doc, \"lc\"):\n            _doc.lc.data = doc.lc.data\n            _doc.lc.filename = doc.lc.filename\n        _errors__ = []\n        loadContents = None\n        if \"loadContents\" in _doc:\n            try:\n                loadContents = load_field(\n                    _doc.get(\"loadContents\"),\n                    union_of_None_type_or_booltype,\n                    baseuri,\n                    loadingOptions,\n                    lc=_doc.get(\"loadContents\")\n                )\n\n            except ValidationException as e:\n                error_message, to_print, verb_tensage = parse_errors(str(e))\n\n                if str(e) == \"missing required field `loadContents`\":\n                    _errors__.append(\n                        ValidationException(\n                            str(e),\n                            None\n                        )\n                    )\n                else:\n                    val = _doc.get(\"loadContents\")\n                    if error_message != str(e):\n                        val_type = convert_typing(extract_type(type(val)))\n                        _errors__.append(\n                            ValidationException(\n                                \"the `loadContents` field is not valid because:\",\n                                SourceLine(_doc, \"loadContents\", str),\n                                [ValidationException(f\"Value is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\",\n                                                     detailed_message=f\"Value `{val}` is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\")],\n                            )\n                        )\n                    else:\n                        _errors__.append(\n                            ValidationException(\n                                \"the `loadContents` field is not valid because:\",\n                                SourceLine(_doc, \"loadContents\", str),\n                                [e],\n                                detailed_message=f\"the `loadContents` field with value `{val}` \"\n                                \"is not valid because:\",\n                            )\n                        )\n        position = None\n        if \"position\" in _doc:\n            try:\n                position = load_field(\n                    _doc.get(\"position\"),\n                    union_of_None_type_or_inttype_or_ExpressionLoader,\n                    baseuri,\n                    loadingOptions,\n                    lc=_doc.get(\"position\")\n                )\n\n            except ValidationException as e:\n                error_message, to_print, verb_tensage = parse_errors(str(e))\n\n                if str(e) == \"missing required field `position`\":\n                    _errors__.append(\n                        ValidationException(\n                            str(e),\n                            None\n                        )\n                    )\n                else:\n                    val = _doc.get(\"position\")\n                    if error_message != str(e):\n                        val_type = convert_typing(extract_type(type(val)))\n                        _errors__.append(\n                            ValidationException(\n                                \"the `position` field is not valid because:\",\n                                SourceLine(_doc, \"position\", str),\n                                [ValidationException(f\"Value is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\",\n                                                     detailed_message=f\"Value `{val}` is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\")],\n                            )\n                        )\n                    else:\n                        _errors__.append(\n                            ValidationException(\n                                \"the `position` field is not valid because:\",\n                                SourceLine(_doc, \"position\", str),\n                                [e],\n                                detailed_message=f\"the `position` field with value `{val}` \"\n                                \"is not valid because:\",\n                            )\n                        )\n        prefix = None\n        if \"prefix\" in _doc:\n            try:\n                prefix = load_field(\n                    _doc.get(\"prefix\"),\n                    union_of_None_type_or_strtype,\n                    baseuri,\n                    loadingOptions,\n                    lc=_doc.get(\"prefix\")\n                )\n\n            except ValidationException as e:\n                error_message, to_print, verb_tensage = parse_errors(str(e))\n\n                if str(e) == \"missing required field `prefix`\":\n                    _errors__.append(\n                        ValidationException(\n                            str(e),\n                            None\n                        )\n                    )\n                else:\n                    val = _doc.get(\"prefix\")\n                    if error_message != str(e):\n                        val_type = convert_typing(extract_type(type(val)))\n                        _errors__.append(\n                            ValidationException(\n                                \"the `prefix` field is not valid because:\",\n                                SourceLine(_doc, \"prefix\", str),\n                                [ValidationException(f\"Value is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\",\n                                                     detailed_message=f\"Value `{val}` is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\")],\n                            )\n                        )\n                    else:\n                        _errors__.append(\n                            ValidationException(\n                                \"the `prefix` field is not valid because:\",\n                                SourceLine(_doc, \"prefix\", str),\n                                [e],\n                                detailed_message=f\"the `prefix` field with value `{val}` \"\n                                \"is not valid because:\",\n                            )\n                        )\n        separate = None\n        if \"separate\" in _doc:\n            try:\n                separate = load_field(\n                    _doc.get(\"separate\"),\n                    union_of_None_type_or_booltype,\n                    baseuri,\n                    loadingOptions,\n                    lc=_doc.get(\"separate\")\n                )\n\n            except ValidationException as e:\n                error_message, to_print, verb_tensage = parse_errors(str(e))\n\n                if str(e) == \"missing required field `separate`\":\n                    _errors__.append(\n                        ValidationException(\n                            str(e),\n                            None\n                        )\n                    )\n                else:\n                    val = _doc.get(\"separate\")\n                    if error_message != str(e):\n                        val_type = convert_typing(extract_type(type(val)))\n                        _errors__.append(\n                            ValidationException(\n                                \"the `separate` field is not valid because:\",\n                                SourceLine(_doc, \"separate\", str),\n                                [ValidationException(f\"Value is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\",\n                                                     detailed_message=f\"Value `{val}` is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\")],\n                            )\n                        )\n                    else:\n                        _errors__.append(\n                            ValidationException(\n                                \"the `separate` field is not valid because:\",\n                                SourceLine(_doc, \"separate\", str),\n                                [e],\n                                detailed_message=f\"the `separate` field with value `{val}` \"\n                                \"is not valid because:\",\n                            )\n                        )\n        itemSeparator = None\n        if \"itemSeparator\" in _doc:\n            try:\n                itemSeparator = load_field(\n                    _doc.get(\"itemSeparator\"),\n                    union_of_None_type_or_strtype,\n                    baseuri,\n                    loadingOptions,\n                    lc=_doc.get(\"itemSeparator\")\n                )\n\n            except ValidationException as e:\n                error_message, to_print, verb_tensage = parse_errors(str(e))\n\n                if str(e) == \"missing required field `itemSeparator`\":\n                    _errors__.append(\n                        ValidationException(\n                            str(e),\n                            None\n                        )\n                    )\n                else:\n                    val = _doc.get(\"itemSeparator\")\n                    if error_message != str(e):\n                        val_type = convert_typing(extract_type(type(val)))\n                        _errors__.append(\n                            ValidationException(\n                                \"the `itemSeparator` field is not valid because:\",\n                                SourceLine(_doc, \"itemSeparator\", str),\n                                [ValidationException(f\"Value is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\",\n                                                     detailed_message=f\"Value `{val}` is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\")],\n                            )\n                        )\n                    else:\n                        _errors__.append(\n                            ValidationException(\n                                \"the `itemSeparator` field is not valid because:\",\n                                SourceLine(_doc, \"itemSeparator\", str),\n                                [e],\n                                detailed_message=f\"the `itemSeparator` field with value `{val}` \"\n                                \"is not valid because:\",\n                            )\n                        )\n        valueFrom = None\n        if \"valueFrom\" in _doc:\n            try:\n                valueFrom = load_field(\n                    _doc.get(\"valueFrom\"),\n                    union_of_None_type_or_strtype_or_ExpressionLoader,\n                    baseuri,\n                    loadingOptions,\n                    lc=_doc.get(\"valueFrom\")\n                )\n\n            except ValidationException as e:\n                error_message, to_print, verb_tensage = parse_errors(str(e))\n\n                if str(e) == \"missing required field `valueFrom`\":\n                    _errors__.append(\n                        ValidationException(\n                            str(e),\n                            None\n                        )\n                    )\n                else:\n                    val = _doc.get(\"valueFrom\")\n                    if error_message != str(e):\n                        val_type = convert_typing(extract_type(type(val)))\n                        _errors__.append(\n                            ValidationException(\n                                \"the `valueFrom` field is not valid because:\",\n                                SourceLine(_doc, \"valueFrom\", str),\n                                [ValidationException(f\"Value is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\",\n                                                     detailed_message=f\"Value `{val}` is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\")],\n                            )\n                        )\n                    else:\n                        _errors__.append(\n                            ValidationException(\n                                \"the `valueFrom` field is not valid because:\",\n                                SourceLine(_doc, \"valueFrom\", str),\n                                [e],\n                                detailed_message=f\"the `valueFrom` field with value `{val}` \"\n                                \"is not valid because:\",\n                            )\n                        )\n        shellQuote = None\n        if \"shellQuote\" in _doc:\n            try:\n                shellQuote = load_field(\n                    _doc.get(\"shellQuote\"),\n                    union_of_None_type_or_booltype,\n                    baseuri,\n                    loadingOptions,\n                    lc=_doc.get(\"shellQuote\")\n                )\n\n            except ValidationException as e:\n                error_message, to_print, verb_tensage = parse_errors(str(e))\n\n                if str(e) == \"missing required field `shellQuote`\":\n                    _errors__.append(\n                        ValidationException(\n                            str(e),\n                            None\n                        )\n                    )\n                else:\n                    val = _doc.get(\"shellQuote\")\n                    if error_message != str(e):\n                        val_type = convert_typing(extract_type(type(val)))\n                        _errors__.append(\n                            ValidationException(\n                                \"the `shellQuote` field is not valid because:\",\n                                SourceLine(_doc, \"shellQuote\", str),\n                                [ValidationException(f\"Value is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\",\n                                                     detailed_message=f\"Value `{val}` is a {val_type}, \"\n                                                     f\"but valid {to_print} for this field \"\n                                                     f\"{verb_tensage} {error_message}\")],\n                            )\n                        )\n                    else:\n                        _errors__.append(\n                            ValidationException(\n                                \"the `shellQuote` field is not valid because:\",\n                                SourceLine(_doc, \"shellQuote\", str),\n                                [e],\n                                detailed_message=f\"the `shellQuote` field with value `{val}` \"\n                                \"is not valid because:\",\n                            )\n                        )\n        extension_fields: dict[str, Any] = {}\n        for k in _doc.keys():\n            if k not in cls.attrs:\n                if not k:\n                    _errors__.append(\n                        ValidationException(\"mapping with implicit null key\")\n                    )\n                elif \":\" in k:\n                    ex = expand_url(\n                        k, \"\", loadingOptions, scoped_id=False, vocab_term=False\n                    )\n                    extension_fields[ex] = _doc[k]\n                else:\n                    _errors__.append(\n                        ValidationException(\n                            \"invalid field `{}`, expected one of: `loadContents`, `position`, `prefix`, `separate`, `itemSeparator`, `valueFrom`, `shellQuote`\".format(\n                                k\n                            ),\n                            SourceLine(_doc, k, str),\n                        )\n                    )\n\n        if _errors__:\n            raise ValidationException(\"\", None, _errors__, \"*\")\n        _constructed = cls(\n            loadContents=loadContents,\n            position=position,\n            prefix=prefix,\n            separate=separate,\n            itemSeparator=itemSeparator,\n            valueFrom=valueFrom,\n            shellQuote=shellQuote,\n            extension_fields=extension_fields,\n            loadingOptions=loadingOptions,\n        )\n        return _constructed",
    "hash_value": "325217e60eba8cd8824ca19ece31a230"
  }
]