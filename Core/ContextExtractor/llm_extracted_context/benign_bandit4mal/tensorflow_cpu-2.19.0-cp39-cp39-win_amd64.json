[
  {
    "metadata": {
      "package_name": "tensorflow_cpu-2.19.0-cp39-cp39-win_amd64",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "dumping_callback.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/tensorflow_cpu-2.19.0-cp39-cp39-win_amd64/tensorflow/python/debug/lib/dumping_callback.py",
    "line_number": "886",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "885\t    logging.info(\"Disabled dumping callback in thread %s (dump root: %s)\",\n886\t                 threading.current_thread().name, dump_root)",
    "context_snippet": "@tf_export(\"debugging.experimental.disable_dump_debug_info\")\ndef disable_dump_debug_info():\n  \"\"\"Disable the currently-enabled debugging dumping.\n\n  If the `enable_dump_debug_info()` method under the same Python namespace\n  has been invoked before, calling this method disables it. If no call to\n  `enable_dump_debug_info()` has been made, calling this method is a no-op.\n  Calling this method more than once is idempotent.\n  \"\"\"\n  if hasattr(_state, \"dumping_callback\"):\n    dump_root = _state.dumping_callback.dump_root\n    tfdbg_run_id = _state.dumping_callback.tfdbg_run_id\n    debug_events_writer.DebugEventsWriter(dump_root, tfdbg_run_id).Close()\n    op_callbacks.remove_op_callback(_state.dumping_callback.callback)\n    if (\n        _state.dumping_callback.function_callback\n        in function_lib.CONCRETE_FUNCTION_CALLBACKS\n    ):\n      function_lib.CONCRETE_FUNCTION_CALLBACKS.remove(\n          _state.dumping_callback.function_callback\n      )\n    delattr(_state, \"dumping_callback\")\n    logging.info(\"Disabled dumping callback in thread %s (dump root: %s)\",\n                 threading.current_thread().name, dump_root)\n",
    "hash_value": "4dea0548f88e59396a7deb832f6585d0"
  },
  {
    "pyfile": "resource_variable_ops.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/tensorflow_cpu-2.19.0-cp39-cp39-win_amd64/tensorflow/python/ops/resource_variable_ops.py",
    "line_number": "1489",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1488\t    \"\"\"\n1489\t    return self._lazy_read(\n1490\t        gen_state_ops.resource_scatter_nd_update(\n1491\t            self.handle,\n1492\t            indices,\n1493\t            ops.convert_to_tensor(updates, self.dtype),\n1494\t            name=name))\n1495",
    "context_snippet": "def scatter_nd_update(self, indices, updates, name=None):\n    \"\"\"Applies sparse assignment to individual values or slices in a Variable.\n\n    `ref` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.\n\n    `indices` must be integer tensor, containing indices into `ref`.\n    It must be shape `[d_0, ..., d_{Q-2}, K]` where `0 < K <= P`.\n\n    The innermost dimension of `indices` (with length `K`) corresponds to\n    indices into elements (if `K = P`) or slices (if `K < P`) along the `K`th\n    dimension of `ref`.\n\n    `updates` is `Tensor` of rank `Q-1+P-K` with shape:\n\n    ```\n    [d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].\n    ```\n\n    For example, say we want to add 4 scattered elements to a rank-1 tensor to\n    8 elements. In Python, that update would look like this:\n\n    ```python\n        ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])\n        indices = tf.constant([[4], [3], [1] ,[7]])\n        updates = tf.constant([9, 10, 11, 12])\n        op = ref.scatter_nd_update(indices, updates)\n        with tf.compat.v1.Session() as sess:\n          print sess.run(op)\n    ```\n\n    The resulting update to ref would look like this:\n\n        [1, 11, 3, 10, 9, 6, 7, 12]\n\n    See `tf.scatter_nd` for more details about how to make updates to\n    slices.\n\n    Args:\n      indices: The indices to be used in the operation.\n      updates: The values to be used in the operation.\n      name: the name of the operation.\n\n    Returns:\n      The updated variable.\n    \"\"\"\n    return self._lazy_read(\n        gen_state_ops.resource_scatter_nd_update(\n            self.handle,\n            indices,\n            ops.convert_to_tensor(updates, self.dtype),\n            name=name))",
    "hash_value": "b508fbe045245779e53e8faac31236c3"
  }
]