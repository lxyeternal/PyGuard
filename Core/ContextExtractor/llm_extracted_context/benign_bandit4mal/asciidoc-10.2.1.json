[
  {
    "metadata": {
      "package_name": "asciidoc-10.2.1",
      "total_matches": 1,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "asciidoc.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/asciidoc-10.2.1/asciidoc-10.2.1/asciidoc/asciidoc.py",
    "line_number": "2828",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "2827\t                stag, etag = config.section2tags(template, self.attributes)\n2828\t                writer.write(stag, trace=name + ' open')\n2829\t                Section.translate_body(self)",
    "context_snippet": "def translate(self):\n    AbstractBlock.translate(self)\n    reader.read()   # Discard delimiter.\n    self.merge_attributes(AttributeList.attrs)\n    if 'skip' not in self.parameters.options:\n        BlockTitle.consume(self.attributes)\n        AttributeList.consume()\n    if 'options' in self.attributes:\n        options = parse_options(self.attributes['options'], (), 'illegal option name')\n        for option in options:\n            self.attributes[option + '-option'] = ''\n    self.push_blockname()\n    options = self.parameters.options\n    if 'skip' in options:\n        reader.read_until(self.delimiter, same_file=True)\n    elif safe() and self.defname == 'blockdef-backend':\n        message.unsafe('Backend Block')\n        reader.read_until(self.delimiter, same_file=True)\n    else:\n        template = self.parameters.template\n        template = subs_attrs(template, self.attributes)\n        name = self.short_name() + ' block'\n        if 'sectionbody' in options:\n            # The body is treated like a section body.\n            stag, etag = config.section2tags(template, self.attributes)\n            writer.write(stag, trace=name + ' open')\n            Section.translate_body(self)\n            writer.write(etag, trace=name + ' close')\n        else:\n            stag = config.section2tags(template, self.attributes, skipend=True)[0]\n            body = reader.read_until(self.delimiter, same_file=True)\n            presubs = self.parameters.presubs\n            postsubs = self.parameters.postsubs\n            body = Lex.subs(body, presubs)\n            if self.parameters.filter:\n                body = filter_lines(self.parameters.filter, body, self.attributes)\n            body = Lex.subs(body, postsubs)\n            # Write start tag, content, end tag.\n            etag = config.section2tags(template, self.attributes, skipstart=True)[1]\n            writer.write(utils.dovetail_tags(stag, body, etag), trace=name)\n        trace(self.short_name() + ' block close', etag)\n    if reader.eof():\n        self.error('missing closing delimiter', self.start)\n    else:\n        delimiter = reader.read()   # Discard delimiter line.\n        assert re.match(self.delimiter, delimiter)\n    self.pop_blockname()",
    "hash_value": "e3dfc43043452bced5de1174ea04b015"
  }
]