[
  {
    "metadata": {
      "package_name": "pillow-simd-9.5.0.post2",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "EpsImagePlugin.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pillow-simd-9.5.0.post2/Pillow-SIMD-9.5.0.post2/src/PIL/EpsImagePlugin.py",
    "line_number": "190",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "189\t            s.append(c)\n190\t            c = self.fp.read(1)\n191",
    "context_snippet": "class PSFile:\n    \"\"\"\n    Wrapper for bytesio object that treats either CR or LF as end of line.\n    This class is no longer used internally, but kept for backwards compatibility.\n    \"\"\"\n\n    def __init__(self, fp):\n        deprecate(\n            \"PSFile\",\n            11,\n            action=\"If you need the functionality of this class \"\n            \"you will need to implement it yourself.\",\n        )\n        self.fp = fp\n        self.char = None\n\n    def seek(self, offset, whence=io.SEEK_SET):\n        self.char = None\n        self.fp.seek(offset, whence)\n\n    def readline(self):\n        s = [self.char or b\"\"]\n        self.char = None\n\n        c = self.fp.read(1)\n        while (c not in b\"\\r\\n\") and len(c):\n            s.append(c)\n            c = self.fp.read(1)\n\n        self.char = self.fp.read(1)\n        # line endings can be 1 or 2 of \\r \\n, in either order\n        if self.char in b\"\\r\\n\":\n            self.char = None\n\n        return b\"\".join(s).decode(\"latin-1\")",
    "hash_value": "17126e856a82d53c4d066be9833f6007"
  },
  {
    "pyfile": "TiffImagePlugin.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/pillow-simd-9.5.0.post2/Pillow-SIMD-9.5.0.post2/src/PIL/TiffImagePlugin.py",
    "line_number": "2039",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "2038\t        self.f.seek(-2, os.SEEK_CUR)\n2039\t        bytes_written = self.f.write(struct.pack(self.shortFmt, value))\n2040\t        if bytes_written is not None and bytes_written != 2:",
    "context_snippet": "def rewriteLastShort(self, value):\n    self.f.seek(-2, os.SEEK_CUR)\n    bytes_written = self.f.write(struct.pack(self.shortFmt, value))\n    if bytes_written is not None and bytes_written != 2:\n        msg = f\"wrote only {bytes_written} bytes but wanted 2\"\n        raise RuntimeError(msg)",
    "hash_value": "fb1776555730a74be78222cea375e70b"
  }
]