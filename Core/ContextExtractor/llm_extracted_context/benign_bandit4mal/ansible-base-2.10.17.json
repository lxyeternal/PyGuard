[
  {
    "metadata": {
      "package_name": "ansible-base-2.10.17",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "urls.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ansible-base-2.10.17/ansible-base-2.10.17/lib/ansible/module_utils/urls.py",
    "line_number": "1443",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1442\t            filename = value.get('filename')\n1443\t            content = value.get('content')\n1444\t            if not any((filename, content)):",
    "context_snippet": "def prepare_multipart(fields):\n    \"\"\"Takes a mapping, and prepares a multipart/form-data body\n\n    :arg fields: Mapping\n    :returns: tuple of (content_type, body) where ``content_type`` is\n        the ``multipart/form-data`` ``Content-Type`` header including\n        ``boundary`` and ``body`` is the prepared bytestring body\n\n    Payload content from a file will be base64 encoded and will include\n    the appropriate ``Content-Transfer-Encoding`` and ``Content-Type``\n    headers.\n\n    Example:\n        {\n            \"file1\": {\n                \"filename\": \"/bin/true\",\n                \"mime_type\": \"application/octet-stream\"\n            },\n            \"file2\": {\n                \"content\": \"text based file content\",\n                \"filename\": \"fake.txt\",\n                \"mime_type\": \"text/plain\",\n            },\n            \"text_form_field\": \"value\"\n        }\n    \"\"\"\n\n    if not isinstance(fields, Mapping):\n        raise TypeError(\n            'Mapping is required, cannot be type %s' % fields.__class__.__name__\n        )\n\n    m = email.mime.multipart.MIMEMultipart('form-data')\n    for field, value in sorted(fields.items()):\n        if isinstance(value, string_types):\n            main_type = 'text'\n            sub_type = 'plain'\n            content = value\n            filename = None\n        elif isinstance(value, Mapping):\n            filename = value.get('filename')\n            content = value.get('content')\n            if not any((filename, content)):\n                raise ValueError('at least one of filename or content must be provided')\n\n            mime = value.get('mime_type')\n            if not mime:\n                try:\n                    mime = mimetypes.guess_type(filename or '', strict=False)[0] or 'application/octet-stream'\n                except Exception:\n                    mime = 'application/octet-stream'\n            main_type, sep, sub_type = mime.partition('/')\n        else:\n            raise TypeError(\n                'value must be a string, or mapping, cannot be type %s' % value.__class__.__name__\n            )\n\n        if not content and filename:\n            with open(to_bytes(filename, errors='surrogate_or_strict'), 'rb') as f:\n                part = email.mime.application.MIMEApplication(f.read())\n                del part['Content-Type']\n                part.add_header('Content-Type', '%s/%s' % (main_type, sub_type))\n        else:\n            part = email.mime.nonmultipart.MIMENonMultipart(main_type, sub_type)\n            part.set_payload(to_bytes(content))\n\n        part.add_header('Content-Disposition', 'form-data')\n        del part['MIME-Version']\n        part.set_param(\n            'name',\n            field,\n            header='Content-Disposition'\n        )\n        if filename:\n            part.set_param(\n                'filename',\n                to_native(os.path.basename(filename)),\n                header='Content-Disposition'\n            )\n\n        m.attach(part)\n\n    if PY3:\n        # Ensure headers are not split over multiple lines\n        # The HTTP policy also uses CRLF by default\n        b_data = m.as_bytes(policy=email.policy.HTTP)\n    else:\n        # Py2\n        # We cannot just call ``as_string`` since it provides no way\n        # to specify ``maxheaderlen``\n        fp = cStringIO()  # cStringIO seems to be required here\n        # Ensure headers are not split over multiple lines\n        g = email.generator.Generator(fp, maxheaderlen=0)\n        g.flatten(m)\n        # ``fix_eols`` switches from ``\\n`` to ``\\r\\n``\n        b_data = email.utils.fix_eols(fp.getvalue())\n    del m\n\n    headers, sep, b_content = b_data.partition(b'\\r\\n\\r\\n')\n    del b_data\n\n    if PY3:\n        parser = email.parser.BytesHeaderParser().parsebytes\n    else:\n        # Py2\n        parser = email.parser.HeaderParser().parsestr\n\n    return (\n        parser(headers)['content-type'],  # Message converts to native strings\n        b_content\n    )\n",
    "hash_value": "5c318895299892982a5b5bc7dc2d353b"
  },
  {
    "pyfile": "ansible_connection_cli_stub.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ansible-base-2.10.17/ansible-base-2.10.17/lib/ansible/cli/scripts/ansible_connection_cli_stub.py",
    "line_number": "160",
    "type_description": "B807:close",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "159\n160\t                s.close()\n161",
    "context_snippet": "def run(self):\n    try:\n        while not self.connection._conn_closed:\n            signal.signal(signal.SIGALRM, self.connect_timeout)\n            signal.signal(signal.SIGTERM, self.handler)\n            signal.alarm(self.connection.get_option('persistent_connect_timeout'))\n\n            self.exception = None\n            (s, addr) = self.sock.accept()\n            signal.alarm(0)\n            signal.signal(signal.SIGALRM, self.command_timeout)\n            while True:\n                data = recv_data(s)\n                if not data:\n                    break\n                log_messages = self.connection.get_option('persistent_log_messages')\n\n                if log_messages:\n                    display.display(\"jsonrpc request: %s\" % data, log_only=True)\n\n                request = json.loads(to_text(data, errors='surrogate_or_strict'))\n                if request.get('method') == \"exec_command\" and not self.connection.connected:\n                    self.connection._connect()\n\n                signal.alarm(self.connection.get_option('persistent_command_timeout'))\n\n                resp = self.srv.handle_request(data)\n                signal.alarm(0)\n\n                if log_messages:\n                    display.display(\"jsonrpc response: %s\" % resp, log_only=True)\n\n                send_data(s, to_bytes(resp))\n\n            s.close()\n\n    except Exception as e:\n        # socket.accept() will raise EINTR if the socket.close() is called\n        if hasattr(e, 'errno'):\n            if e.errno != errno.EINTR:\n                self.exception = traceback.format_exc()\n        else:\n            self.exception = traceback.format_exc()\n\n    finally:\n        # allow time for any exception msg send over socket to receive at other end before shutting down\n        time.sleep(0.1)\n\n        # when done, close the connection properly and cleanup the socket file so it can be recreated\n        self.shutdown()",
    "hash_value": "8f89d3a4bc0768451533692729812ee2"
  }
]