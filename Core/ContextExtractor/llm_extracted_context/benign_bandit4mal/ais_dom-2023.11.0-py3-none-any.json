[
  {
    "metadata": {
      "package_name": "ais_dom-2023.11.0-py3-none-any",
      "total_matches": 6,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "device_tracker.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ais_dom-2023.11.0-py3-none-any/homeassistant/components/ddwrt/device_tracker.py",
    "line_number": "109",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "108\n109\t        return self.mac2name.get(device)\n110",
    "context_snippet": "    def get_device_name(self, device):\n        \"\"\"Return the name of the given device or None if we don't know.\"\"\"\n        # If not initialised and not already scanned and not found.\n        if device not in self.mac2name:\n            url = f\"{self.protocol}://{self.host}/Status_Lan.live.asp\"\n\n            if not (data := self.get_ddwrt_data(url)):\n                return None\n\n            if not (dhcp_leases := data.get(\"dhcp_leases\")):\n                return None\n\n            # Remove leading and trailing quotes and spaces\n            cleaned_str = dhcp_leases.replace('\"', \"\").replace(\"'\", \"\").replace(\" \", \"\")\n            elements = cleaned_str.split(\",\")\n            num_clients = int(len(elements) / 5)\n            self.mac2name = {}\n            for idx in range(0, num_clients):\n                # The data is a single array\n                # every 5 elements represents one host, the MAC\n                # is the third element and the name is the first.\n                mac_index = (idx * 5) + 2\n                if mac_index < len(elements):\n                    mac = elements[mac_index]\n                    self.mac2name[mac] = elements[idx * 5]\n\n        return self.mac2name.get(device)",
    "hash_value": "8feb16c9791d3e7d12286d6d97d52a69"
  },
  {
    "pyfile": "sensor.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ais_dom-2023.11.0-py3-none-any/homeassistant/components/plex/sensor.py",
    "line_number": "194",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "193\n194\t        recent_libtype = LIBRARY_RECENT_LIBTYPE.get(\n195\t            self.library_type, self.library_type\n196\t        )",
    "context_snippet": "def _update_state_and_attrs(self):\n    \"\"\"Update library sensor state with sync calls.\"\"\"\n    primary_libtype = LIBRARY_PRIMARY_LIBTYPE.get(\n        self.library_type, self.library_type\n    )\n\n    self._attr_native_value = self.library_section.totalViewSize(\n        libtype=primary_libtype, includeCollections=False\n    )\n    for libtype in LIBRARY_ATTRIBUTE_TYPES.get(self.library_type, []):\n        self._attr_extra_state_attributes[\n            f\"{libtype}s\"\n        ] = self.library_section.totalViewSize(\n            libtype=libtype, includeCollections=False\n        )\n\n    recent_libtype = LIBRARY_RECENT_LIBTYPE.get(\n        self.library_type, self.library_type\n    )\n    recently_added = self.library_section.recentlyAdded(\n        maxresults=1, libtype=recent_libtype\n    )\n    if recently_added:\n        media = recently_added[0]\n        self._attr_extra_state_attributes[\"last_added_item\"] = pretty_title(media)\n        self._attr_extra_state_attributes[\"last_added_timestamp\"] = media.addedAt",
    "hash_value": "6b8da5f94462ab6324f6f9ad6f33bde7"
  },
  {
    "pyfile": "__init__.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ais_dom-2023.11.0-py3-none-any/homeassistant/components/ais_ai_service/__init__.py",
    "line_number": "1374",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "1373\t                prev_id = len(attr) - 1\n1374\t            track = attr.get(int(prev_id))\n1375\t            _say_it(hass, track[\"name\"])",
    "context_snippet": "def set_prev_position(hass):\n    global CURR_ENTITIE_POSITION\n    CURR_ENTITIE_POSITION = get_curent_position(hass)\n    state = hass.states.get(CURR_ENTITIE)\n    attr = state.attributes\n    if CURR_ENTITIE.startswith(\"input_select.\"):\n        options = attr.get(\"options\")\n        if len(options) < 2:\n            _say_it(hass, \"brak pozycji\")\n        else:\n            CURR_ENTITIE_POSITION = get_prev(options, CURR_ENTITIE_POSITION)\n            _say_it(hass, CURR_ENTITIE_POSITION)\n    elif CURR_ENTITIE.startswith(\"sensor.\") and CURR_ENTITIE.endswith(\"list\"):\n        if len(attr) == 0:\n            _say_it(hass, \"brak pozycji\")\n        else:\n            curr_id = int(state.state)\n            prev_id = curr_id - 1\n            if prev_id < 0:\n                prev_id = len(attr) - 1\n            track = attr.get(int(prev_id))\n            _say_it(hass, track[\"name\"])\n            # update list\n            hass.states.async_set(CURR_ENTITIE, prev_id, attr)\n    elif CURR_ENTITIE.startswith(\"input_number.\"):\n        _min = float(state.attributes.get(\"min\"))\n        _step = float(state.attributes.get(\"step\"))\n        _curr = float(CURR_ENTITIE_POSITION)\n        CURR_ENTITIE_POSITION = str(round(max(_curr - _step, _min), 2))\n        _say_it(hass, str(CURR_ENTITIE_POSITION))",
    "hash_value": "5cfb7cc942f3a7a5262baac10988ecdd"
  },
  {
    "pyfile": "__init__.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ais_dom-2023.11.0-py3-none-any/homeassistant/components/ais_ai_service/__init__.py",
    "line_number": "2285",
    "type_description": "B820:get",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "2284\t    warnings.filterwarnings(\"ignore\", module=\"fuzzywuzzy\")\n2285\t    config = config.get(DOMAIN, {})\n2286\t    intents = hass.data.get(DOMAIN)",
    "context_snippet": "async def async_setup(hass, config):\n    \"\"\"Register the process service.\"\"\"\n    global aisCloudWS\n    aisCloudWS = ais_cloud.AisCloudWS(hass)\n    warnings.filterwarnings(\"ignore\", module=\"fuzzywuzzy\")\n    config = config.get(DOMAIN, {})\n    intents = hass.data.get(DOMAIN)\n    if intents is None:\n        intents = hass.data[DOMAIN] = {}\n\n    for intent_type, utterances in config.get(\"intents\", {}).items():\n        conf = intents.get(intent_type)\n        if conf is None:\n            conf = intents[intent_type] = []\n        conf.extend(_create_matcher(utterance) for utterance in utterances)\n\n    async def async_ais_setup_component(service):\n        # check and reload component if needed\n        domain = service.data[\"domain\"]\n        # for example satel_integra\n        # check if this domain is already setup\n        if domain in hass.config.components:\n            return True\n        ha_config = hass.config\n        result = await async_setup_component(hass, domain, ha_config)\n        _LOGGER.error(str(result))\n\n    async def process(service):\n        \"\"\"Parse text into commands.\"\"\"\n        text = service.data[ATTR_TEXT]\n        await _async_process(hass, text)\n\n    def process_code(service):\n        \"\"\"Parse remote code into action.\"\"\"\n        text = json.loads(service.data.get(ATTR_TEXT))\n        _process_code(hass, text)\n\n    def say_it(service):\n        \"\"\"Info to the user.\"\"\"\n        text = \"\"\n        pitch = None\n        rate = None\n        language = None\n        voice = None\n        path = None\n        if ATTR_TEXT in service.data:\n            text = service.data[ATTR_TEXT]\n        # TODO else:\n        #     # check message template\n        #     if \"template_text\" in service.data:\n        #         tpl = template.Template(service.data[\"template_text\"], hass)\n        #         message = tpl.async_render()\n        #     else:\n        #         return\n        if \"img\" in service.data:\n            img = service.data[\"img\"]\n            if img is not None:\n                if len(img) < 3:\n                    img = None\n        else:\n            img = None\n\n        if \"pitch\" in service.data:\n            pitch = service.data[\"pitch\"]\n        if \"rate\" in service.data:\n            rate = service.data[\"rate\"]\n        if \"language\" in service.data:\n            language = service.data[\"language\"]\n        if \"voice\" in service.data:\n            voice = service.data[\"voice\"]\n        if \"path\" in service.data:\n            path = service.data[\"path\"]\n\n        _say_it(\n            hass=hass,\n            message=text,\n            img=img,\n            pitch=pitch,\n            rate=rate,\n            language=language,\n            voice=voice,\n            path=path,\n        )\n\n    def say_in_browser(service):\n        \"\"\"Info to the via browser - this is handled by ais-tts in card\"\"\"\n\n    def welcome_home(service):\n        \"\"\"Welcome message.\"\"\"\n\n        # display favorites from Spotify only if Spotify is available\n        if hass.services.has_service(\"ais_spotify_service\", \"get_favorites\"):\n            hass.services.call(\n                \"ais_spotify_service\", \"get_favorites\", {\"type\": \"featured-playlists\"}\n            )\n\n        text = \"Witaj w Domu. Powiedz proszę w czym mogę Ci pomóc?\"\n        if ais_global.G_OFFLINE_MODE:\n            text = (\n                \"Uwaga, uruchomienie bez dostępu do sieci, część usług może nie działać poprawnie.\"\n                \"Sprawdź połączenie z Internetem.\"\n            )\n        _say_it(hass, text)\n\n        # immersive full mode for all apps\n        if ais_global.has_root():\n            hass.services.call(\n                \"ais_shell_command\",\n                \"execute_command\",\n                {\n                    \"command\": \"su -c 'settings put global policy_control \"\n                    \"immersive.full=*'\"\n                },\n            )\n        if hass.services.has_service(\"ais_tts\", \"play_item\"):\n            # ais_tts - remove all panels\n            if \"lovelace-dom\" in hass.data.get(\n                hass.components.frontend.DATA_PANELS, {}\n            ):\n                hass.components.frontend.async_remove_panel(\"lovelace-dom\")\n            if \"aisaudio\" in hass.data.get(hass.components.frontend.DATA_PANELS, {}):\n                hass.components.frontend.async_remove_panel(\"aisaudio\")\n            if \"map\" in hass.data.get(hass.components.frontend.DATA_PANELS, {}):\n                hass.components.frontend.async_remove_panel(\"map\")\n            if \"history\" in hass.data.get(hass.components.frontend.DATA_PANELS, {}):\n                hass.components.frontend.async_remove_panel(\"history\")\n            if \"logbook\" in hass.data.get(hass.components.frontend.DATA_PANELS, {}):\n                hass.components.frontend.async_remove_panel(\"logbook\")\n\n        # set the flag to info that the AIS start part is done - this is needed to don't say some info before this flag\n        ais_global.G_AIS_START_IS_DONE = True\n\n    async def async_set_context(service):\n        ...\n    # (rest of function omitted for brevity)\n",
    "hash_value": "02cc3848f1cc86b23ca7441679d87456"
  },
  {
    "pyfile": "__init__.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ais_dom-2023.11.0-py3-none-any/homeassistant/components/ais_web_zwave2mqtt/__init__.py",
    "line_number": "78",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "77\t            # Request\n78\t            return await self._handle_request(request, token, path)\n79",
    "context_snippet": "    async def _handle(\n        self, request: web.Request, token: str, path: str\n    ) -> Union[web.Response, web.StreamResponse, web.WebSocketResponse]:\n        \"\"\"Route data to Hass.io ingress service.\"\"\"\n        # validate token\n        if token != self._valid_token:\n            try:\n                auth = self._hass.auth\n                refresh_token = await auth.async_validate_access_token(token)\n                if refresh_token is None:\n                    raise HTTPUnauthorized() from None\n                # remember the token as valid\n                self._valid_token = token\n            except Exception:\n                raise HTTPUnauthorized() from None\n\n        try:\n            # Websockettoken\n            if _is_websocket(request):\n                return await self._handle_websocket(request, token, path)\n\n            # Request\n            return await self._handle_request(request, token, path)\n\n        except aiohttp.ClientError as err:\n            _LOGGER.debug(\"Ingress error with %s / %s: %s\", token, path, err)\n\n        raise HTTPBadGateway() from None",
    "hash_value": "66469a5a4844df1ca66e80831d9a06c6"
  },
  {
    "pyfile": "notify.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/ais_dom-2023.11.0-py3-none-any/homeassistant/components/lannouncer/notify.py",
    "line_number": "80",
    "type_description": "B806:sendall",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "79\t            sock.sendall(cmd.encode())\n80\t            sock.sendall(b\"&@DONE@\\n\")\n81",
    "context_snippet": "def send_message(self, message=\"\", **kwargs):\n    \"\"\"Send a message to Lannouncer.\"\"\"\n    data = kwargs.get(ATTR_DATA)\n    if data is not None and ATTR_METHOD in data:\n        method = data.get(ATTR_METHOD)\n    else:\n        method = ATTR_METHOD_DEFAULT\n\n    if method not in ATTR_METHOD_ALLOWED:\n        _LOGGER.error(\"Unknown method %s\", method)\n        return\n\n    cmd = urlencode({method: message})\n\n    try:\n        # Open socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(10)\n        sock.connect((self._host, self._port))\n\n        # Send message\n        _LOGGER.debug(\"Sending message: %s\", cmd)\n        sock.sendall(cmd.encode())\n        sock.sendall(b\"&@DONE@\\n\")\n\n        # Check response\n        buffer = sock.recv(1024)\n        if buffer != b\"LANnouncer: OK\":\n            _LOGGER.error(\"Error sending data to Lannnouncer: %s\", buffer.decode())\n\n        # Close socket\n        sock.close()\n    except socket.gaierror:\n        _LOGGER.error(\"Unable to connect to host %s\", self._host)\n    except OSError:\n        _LOGGER.exception(\"Failed to send data to Lannnouncer\")",
    "hash_value": "9fe63037dda6f5705764a25d1d670d46"
  }
]