[
  {
    "metadata": {
      "package_name": "extended_mypy_django_plugin-0.8.0",
      "total_matches": 3,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "pyproject.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/extended_mypy_django_plugin-0.8.0/extended_mypy_django_plugin-0.8.0/tools/.bootstrap-venv/lib/python3.10/site-packages/pip/_internal/pyproject.py",
    "line_number": "64",
    "type_description": "B814:read",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "63\t        with open(pyproject_toml, encoding=\"utf-8\") as f:\n64\t            pp_toml = tomli.loads(f.read())\n65\t        build_system = pp_toml.get(\"build-system\")",
    "context_snippet": "def load_pyproject_toml(\n    use_pep517: Optional[bool], pyproject_toml: str, setup_py: str, req_name: str\n) -> Optional[BuildSystemDetails]:\n    \"\"\"Load the pyproject.toml file.\n\n    Parameters:\n        use_pep517 - Has the user requested PEP 517 processing? None\n                     means the user hasn't explicitly specified.\n        pyproject_toml - Location of the project's pyproject.toml file\n        setup_py - Location of the project's setup.py file\n        req_name - The name of the requirement we're processing (for\n                   error reporting)\n\n    Returns:\n        None if we should use the legacy code path, otherwise a tuple\n        (\n            requirements from pyproject.toml,\n            name of PEP 517 backend,\n            requirements we should check are installed after setting\n                up the build environment\n            directory paths to import the backend from (backend-path),\n                relative to the project root.\n        )\n    \"\"\"\n    has_pyproject = os.path.isfile(pyproject_toml)\n    has_setup = os.path.isfile(setup_py)\n\n    if not has_pyproject and not has_setup:\n        raise InstallationError(\n            f\"{req_name} does not appear to be a Python project: \"\n            f\"neither 'setup.py' nor 'pyproject.toml' found.\"\n        )\n\n    if has_pyproject:\n        with open(pyproject_toml, encoding=\"utf-8\") as f:\n            pp_toml = tomli.loads(f.read())\n        build_system = pp_toml.get(\"build-system\")\n    else:\n        build_system = None\n\n    # The following cases must use PEP 517\n    # We check for use_pep517 being non-None and falsey because that means\n    # the user explicitly requested --no-use-pep517.  The value 0 as\n    # opposed to False can occur when the value is provided via an\n    # environment variable or config file option (due to the quirk of\n    # strtobool() returning an integer in pip's configuration code).\n    if has_pyproject and not has_setup:\n        if use_pep517 is not None and not use_pep517:\n            raise InstallationError(\n                \"Disabling PEP 517 processing is invalid: \"\n                \"project does not have a setup.py\"\n            )\n        use_pep517 = True\n    elif build_system and \"build-backend\" in build_system:\n        if use_pep517 is not None and not use_pep517:\n            raise InstallationError(\n                \"Disabling PEP 517 processing is invalid: \"\n                \"project specifies a build backend of {} \"\n                \"in pyproject.toml\".format(build_system[\"build-backend\"])\n            )\n        use_pep517 = True\n\n    # If we haven't worked out whether to use PEP 517 yet,\n    # and the user hasn't explicitly stated a preference,\n    # we do so if the project has a pyproject.toml file\n    # or if we cannot import setuptools.\n\n    # We fallback to PEP 517 when without setuptools,\n    # so setuptools can be installed as a default build backend.\n    # For more info see:\n    # https://discuss.python.org/t/pip-without-setuptools-could-the-experience-be-improved/11810/9\n    elif use_pep517 is None:\n        use_pep517 = has_pyproject or not importlib.util.find_spec(\"setuptools\")\n\n    # At this point, we know whether we're going to use PEP 517.\n    assert use_pep517 is not None\n\n    # If we're using the legacy code path, there is nothing further\n    # for us to do here.\n    if not use_pep517:\n        return None\n\n    if build_system is None:\n        # Either the user has a pyproject.toml with no build-system\n        # section, or the user has no pyproject.toml, but has opted in\n        # explicitly via --use-pep517.\n        # In the absence of any explicit backend specification, we\n        # assume the setuptools backend that most closely emulates the\n        # traditional direct setup.py execution, and require wheel and\n        # a version of setuptools that supports that backend.\n\n        build_system = {\n            \"requires\": [\"setuptools>=40.8.0\", \"wheel\"],\n            \"build-backend\": \"setuptools.build_meta:__legacy__\",\n        }\n\n    # If we're using PEP 517, we have build system information (either\n    # from pyproject.toml, or defaulted by the code above).\n    # Note that at this point, we do not know if the user has actually\n    # specified a backend, though.\n    assert build_system is not None\n\n    # Ensure that the build-system section in pyproject.toml conforms\n    # to PEP 518.\n\n    # Specifying the build-system table but not the requires key is invalid\n    if \"requires\" not in build_system:\n        raise MissingPyProjectBuildRequires(package=req_name)\n\n    # Error out if requires is not a list of strings\n    requires = build_system[\"requires\"]\n    if not _is_list_of_str(requires):\n        raise InvalidPyProjectBuildRequires(\n            package=req_name,\n            reason=\"It is not a list of strings.\",\n        )\n\n    # Each requirement must be valid as per PEP 508\n    for requirement in requires:\n        try:\n            Requirement(requirement)\n        except InvalidRequirement as error:\n            raise InvalidPyProjectBuildRequires(\n                package=req_name,\n                reason=f\"It contains an invalid requirement: {requirement!r}\",\n            ) from error\n\n    backend = build_system.get(\"build-backend\")\n    backend_path = build_system.get(\"backend-path\", [])\n    check: List[str] = []\n    if backend is None:\n        # If the user didn't specify a backend, we assume they want to use\n        # the setuptools backend. But we can't be sure they have included\n        # a version of setuptools which supplies the backend. So we\n        # make a note to check that this requirement is present once\n        # we have set up the environment.\n        # This is quite a lot of work to check for a very specific case. But\n        # the problem is, that case is potentially quite common - projects that\n        # adopted PEP 518 early for the ability to specify requirements to\n        # execute setup.py, but never considered needing to mention the build\n        # tools themselves. The original PEP 518 code had a similar check (but\n        # implemented in a different way).\n        backend = \"setuptools.build_meta:__legacy__\"\n        check = [\"setuptools>=40.8.0\"]\n\n    return BuildSystemDetails(requires, backend, check, backend_path)\n",
    "hash_value": "16e3c6c2e126f73b4110e4f7a7dfc755"
  },
  {
    "pyfile": "register.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/extended_mypy_django_plugin-0.8.0/extended_mypy_django_plugin-0.8.0/tools/.bootstrap-venv/lib/python3.10/site-packages/setuptools/_distutils/command/register.py",
    "line_number": "98",
    "type_description": "B818:urlopen",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "97\t        url = self.repository + '?:action=list_classifiers'\n98\t        response = urllib.request.urlopen(url)\n99\t        log.info(self._read_pypi_response(response))",
    "context_snippet": "def classifiers(self):\n    '''Fetch the list of classifiers from the server.'''\n    url = self.repository + '?:action=list_classifiers'\n    response = urllib.request.urlopen(url)\n    log.info(self._read_pypi_response(response))",
    "hash_value": "d0bcab665d1e050234e0e26c09e44435"
  },
  {
    "pyfile": "connection.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/extended_mypy_django_plugin-0.8.0/extended_mypy_django_plugin-0.8.0/tools/.bootstrap-venv/lib/python3.10/site-packages/pip/_vendor/urllib3/connection.py",
    "line_number": "250",
    "type_description": "B825:request",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "249\t        skip_host = \"host\" in header_keys\n250\t        self.putrequest(\n251\t            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\n252\t        )",
    "context_snippet": "def request_chunked(self, method, url, body=None, headers=None):\n    \"\"\"\n    Alternative to the common request method, which sends the\n    body with chunked encoding and not as one block\n    \"\"\"\n    headers = headers or {}\n    header_keys = set([six.ensure_str(k.lower()) for k in headers])\n    skip_accept_encoding = \"accept-encoding\" in header_keys\n    skip_host = \"host\" in header_keys\n    self.putrequest(\n        method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\n    )\n    if \"user-agent\" not in header_keys:\n        self.putheader(\"User-Agent\", _get_default_user_agent())\n    for header, value in headers.items():\n        self.putheader(header, value)\n    if \"transfer-encoding\" not in header_keys:\n        self.putheader(\"Transfer-Encoding\", \"chunked\")\n    self.endheaders()\n\n    if body is not None:\n        stringish_types = six.string_types + (bytes,)\n        if isinstance(body, stringish_types):\n            body = (body,)\n        for chunk in body:\n            if not chunk:\n                continue\n            if not isinstance(chunk, bytes):\n                chunk = chunk.encode(\"utf8\")\n            len_str = hex(len(chunk))[2:]\n            to_send = bytearray(len_str.encode())\n            to_send += b\"\\r\\n\"\n            to_send += chunk\n            to_send += b\"\\r\\n\"\n            self.send(to_send)\n\n    # After the if clause, to always have a closed body\n    self.send(b\"0\\r\\n\\r\\n\")",
    "hash_value": "e9bc267e71287ff804a862c87434ceb4"
  }
]