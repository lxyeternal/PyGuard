[
  {
    "metadata": {
      "package_name": "gdal-3.10.3",
      "total_matches": 2,
      "processing_date": "2025-05-18 01:49:39"
    }
  },
  {
    "pyfile": "batch_creator.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gdal-3.10.3/gdal-3.10.3/gdal-utils/osgeo_utils/auxiliary/batch_creator.py",
    "line_number": "43",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "42\t                with open(batch_name, \"w\") as file:\n43\t                    file.write(batch_content)\n44\t        return 0",
    "context_snippet": "def batch_creator(\n    filename_list: Sequence[PathLikeOrStr],\n    batch_content: str = r'@python \"%~dp0\\%~n0.py\" %*',\n):\n    \"\"\"\n    :param filename_list: list of file names (full path)\n    :param batch_content: contents of the wrapper batch file\n    :return: 0 if succeeded, 1 otherwise\n    The function create a wrapper batch file for each existing python file for invoking as a script\n    It is useful on Windows if the file association of *.py files is not python.exe (but some IDE for instance)\n    \"\"\"\n    try:\n        for script_name in filename_list:\n            py_name = Path(script_name).with_suffix(\".py\")\n            if os.path.exists(py_name):\n                batch_name = py_name.with_suffix(\".bat\")\n                print(f\"Creating: {batch_name}...\")\n                with open(batch_name, \"w\") as file:\n                    file.write(batch_content)\n        return 0\n    except Exception:\n        return 1",
    "hash_value": "af097c586153fce4414cc7ecb08e7564"
  },
  {
    "pyfile": "build_jp2_from_xml.py",
    "full_path": "/home2/blue/Documents/PyPIAgent/Dataset/study/unzip_benign/gdal-3.10.3/gdal-3.10.3/gdal-utils/osgeo_utils/samples/build_jp2_from_xml.py",
    "line_number": "311",
    "type_description": "B815:write",
    "severity": "High",
    "confidence": "Medium",
    "original_snippet": "310\t        out_f.write(jp2box_name.encode(\"ascii\"))\n311\t        out_f.write(text_content.encode(\"latin1\"))\n312",
    "context_snippet": "def parse_jp2_box(xml_tree, out_f, src_jp2file):\n    if not (\n        xml_tree[XML_TYPE_IDX] == gdal.CXT_Element\n        and xml_tree[XML_VALUE_IDX] == \"JP2Box\"\n    ):\n        print(\"Not a JP2Box element\")\n        return False\n    jp2box_name = get_attribute_val(xml_tree, \"name\")\n    if jp2box_name is None:\n        print(\"Cannot find JP2Box.name attribute\")\n        return False\n    if len(jp2box_name) != 4:\n        print(\"Invalid JP2Box.name : %s\" % jp2box_name)\n        return False\n    hex_binary_content = get_node_content(\n        find_xml_node(xml_tree, \"BinaryContent\", immediate_child=True)\n    )\n    decoded_content = find_xml_node(xml_tree, \"DecodedContent\", immediate_child=True)\n    decoded_geotiff = find_xml_node(xml_tree, \"DecodedGeoTIFF\", immediate_child=True)\n    text_content = get_node_content(\n        find_xml_node(xml_tree, \"TextContent\", immediate_child=True)\n    )\n    xml_content = find_xml_node(xml_tree, \"XMLContent\", immediate_child=True)\n    jp2box = find_xml_node(xml_tree, \"JP2Box\", immediate_child=True)\n    jp2codestream = find_xml_node(xml_tree, \"JP2KCodeStream\", immediate_child=True)\n\n    if hex_binary_content:\n        if decoded_content or decoded_geotiff or text_content or xml_content or jp2box:\n            print(\n                \"BinaryContent found, and one of DecodedContent/DecodedGeoTIFF/TextContent/XMLContent/JP2Box. The latter will be ignored\"\n            )\n        if jp2box_name == \"uuid\":\n            uuid = get_node_content(\n                find_xml_node(xml_tree, \"UUID\", immediate_child=True)\n            )\n            if uuid is None:\n                print(\"Cannot find JP2Box.UUID element\")\n                return False\n        else:\n            uuid = \"\"\n        out_f.write(\n            struct.pack(\n                \">I\" * 1, 8 + int(len(hex_binary_content) / 2) + int(len(uuid) / 2)\n            )\n        )\n        out_f.write(jp2box_name.encode(\"ascii\"))\n        write_hexstring_as_binary(uuid, out_f)\n        write_hexstring_as_binary(hex_binary_content, out_f)\n\n    elif decoded_content:\n        if decoded_geotiff or text_content or xml_content or jp2box:\n            print(\n                \"DecodedContent found, and one of DecodedGeoTIFF/TextContent/XMLContent/JP2Box. The latter will be ignored\"\n            )\n        pos = out_f.tell()\n        out_f.write(struct.pack(\">I\" * 1, 0))\n        out_f.write(jp2box_name.encode(\"ascii\"))\n        for child_idx in range(XML_FIRST_CHILD_IDX, len(decoded_content)):\n            child = decoded_content[child_idx]\n            if (\n                child[XML_TYPE_IDX] == gdal.CXT_Element\n                and child[XML_VALUE_IDX] == \"Field\"\n            ):\n                if not parse_field(child, out_f, src_jp2file):\n                    return False\n        new_pos = out_f.tell()\n        out_f.seek(pos, 0)\n        out_f.write(struct.pack(\">I\" * 1, new_pos - pos))\n        out_f.seek(new_pos, 0)\n\n    elif text_content:\n        if decoded_geotiff or xml_content or jp2box:\n            print(\n                \"TextContent found, and one of DecodedGeoTIFF/XMLContent/JP2Box. The latter will be ignored\"\n            )\n        out_f.write(struct.pack(\">I\" * 1, 8 + len(text_content)))\n        out_f.write(jp2box_name.encode(\"ascii\"))\n        out_f.write(text_content.encode(\"latin1\"))\n\n    elif xml_content:\n        if decoded_geotiff or jp2box:\n            print(\n                \"XMLContent found, and one of DecodedGeoTIFF/JP2Box. The latter will be ignored\"\n            )\n        serialized_xml_content = gdal.SerializeXMLTree(xml_content[XML_FIRST_CHILD_IDX])\n        out_f.write(struct.pack(\">I\" * 1, 8 + len(serialized_xml_content)))\n        out_f.write(jp2box_name.encode(\"ascii\"))\n        out_f.write(serialized_xml_content.encode(\"latin1\"))\n\n    elif jp2box:\n        if decoded_geotiff:\n            print(\"JP2Box found, and one of DecodedGeoTIFF. The latter will be ignored\")\n        pos = out_f.tell()\n        out_f.write(struct.pack(\">I\" * 1, 0))\n        out_f.write(jp2box_name.encode(\"ascii\"))\n        for child_idx in range(XML_FIRST_CHILD_IDX, len(xml_tree)):\n            child = xml_tree[child_idx]\n            if (\n                child[XML_TYPE_IDX] == gdal.CXT_Element\n                and child[XML_VALUE_IDX] == \"JP2Box\"\n            ):\n                if not parse_jp2_box(child, out_f, src_jp2file):\n                    return False\n        new_pos = out_f.tell()\n        out_f.seek(pos, 0)\n        out_f.write(struct.pack(\">I\" * 1, new_pos - pos))\n        out_f.seek(new_pos, 0)\n\n    elif decoded_geotiff:\n        serialized_xml_content = gdal.SerializeXMLTree(\n            decoded_geotiff[XML_FIRST_CHILD_IDX]\n        )\n\n        vrt_ds = gdal.Open(serialized_xml_content)\n        if vrt_ds is None:\n            print(\"Cannot decode VRTDataset. Outputting empty content\")\n            binary_content = \"\"\n        else:\n            tmpfilename = \"/vsimem/build_jp2_from_xml_tmp.tif\"\n            gdal.GetDriverByName(\"GTiff\").CreateCopy(tmpfilename, vrt_ds)\n            tif_f = gdal.VSIFOpenL(tmpfilename, \"rb\")\n            binary_content = gdal.VSIFReadL(1, 10000, tif_f)\n            gdal.VSIFCloseL(tif_f)\n            gdal.Unlink(tmpfilename)\n\n        uuid = get_node_content(find_xml_node(xml_tree, \"UUID\", immediate_child=True))\n        if uuid is None:\n            uuid = \"B14BF8BD083D4B43A5AE8CD7D5A6CE03\"\n\n        out_f.write(struct.pack(\">I\" * 1, 8 + len(binary_content) + int(len(uuid) / 2)))\n        out_f.write(jp2box_name.encode(\"ascii\"))\n        write_hexstring_as_binary(uuid, out_f)\n        out_f.write(binary_content)\n\n    elif jp2codestream:\n        pos = out_f.tell()\n        out_f.write(struct.pack(\">I\" * 1, 0))\n        out_f.write(jp2box_name.encode(\"ascii\"))\n        if not parse_jp2codestream(None, jp2codestream, out_f, src_jp2file):\n            return False\n        new_pos = out_f.tell()\n        out_f.seek(pos, 0)\n        out_f.write(struct.pack(\">I\" * 1, new_pos - pos))\n        out_f.seek(new_pos, 0)\n\n    else:\n        data_offset = get_attribute_val(xml_tree, \"data_offset\")\n        if data_offset is None:\n            print(\"Cannot find JP2Box.data_offset attribute\")\n            return False\n        data_offset = int(data_offset)\n\n        data_length = get_attribute_val(xml_tree, \"data_length\")\n        if data_length is None:\n            print(\"Cannot find JP2Box.data_length attribute\")\n            return False\n        data_length = int(data_length)\n\n        src_jp2file.seek(data_offset, 0)\n        data = src_jp2file.read(data_length)\n\n        out_f.write(struct.pack(\">I\" * 1, 8 + data_length))\n        out_f.write(jp2box_name.encode(\"ascii\"))\n        out_f.write(data)\n\n    return True",
    "hash_value": "fcd78a2fd253dc91ed68e0f290f00839"
  }
]