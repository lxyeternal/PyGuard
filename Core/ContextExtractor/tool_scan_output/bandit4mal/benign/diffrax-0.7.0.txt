Run started:2025-04-12 14:26:27.851117

Test results:
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/diffrax-0.7.0/diffrax-0.7.0/diffrax/_adjoint.py:523
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
522	
523	ImplicitAdjoint.__init__.__doc__ = """**Arguments:**
524	
525	- `linear_solver`: A [Lineax](https://github.com/google/lineax) solver for solving the
526	    linear system.
527	- `tags`: Any Lineax [tags](https://docs.kidger.site/lineax/api/tags/) describing the
528	    Jacobian matrix `df/dy`.
529	"""
530	
531	
532	# Compute derivatives with respect to the first argument:
533	# - y, corresponding to the initial state;
534	# - args, corresponding to explicit parameters;
535	# - terms, corresponding to implicit parameters as part of the vector field.
536	@eqx.filter_custom_vjp
537	def _loop_backsolve(y__args__terms, *, self, throw, init_state, **kwargs):

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/diffrax-0.7.0/diffrax-0.7.0/diffrax/_autocitation.py:145
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
144	
145	_start = r"""
146	% --- AUTOGENERATED REFERENCES PRODUCED USING `diffrax.citation(...)` ---

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/diffrax-0.7.0/diffrax-0.7.0/diffrax/_autocitation.py:189
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
188	        + _thesis_cite
189	        + r"""
190	
191	% You are using Equinox, which is citable as:
192	@article{kidger2021equinox,
193	    author={Patrick Kidger and Cristian Garcia},
194	    title={{E}quinox: neural networks in {JAX} via callable {P}y{T}rees and

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/diffrax-0.7.0/diffrax-0.7.0/diffrax/_autocitation.py:587
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
586	            out.add(
587	                r"""
588	% The use of adaptive step size controllers for SDEs are from:
589	@article{burrage2004adaptive,

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/diffrax-0.7.0/diffrax-0.7.0/diffrax/_event.py:27
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
26	
27	Event.__init__.__doc__ = """**Arguments:**
28	
29	- `cond_fn`: A function or PyTree of functions `f(t, y, args, **kwargs) -> c` each
30	    returning either a boolean or a real number. If the return value is a boolean, then
31	    the solve will terminate on the first step on which `c` becomes `True`. If the
32	    return value is a real number, then the solve will terminate on the step when `c`
33	    changes sign.
34	
35	- `root_finder`: An optional [root finder](../nonlinear_solver/) to use for finding
36	    the exact time of the event. If the triggered condition function returns a real
37	    number, then the final time will be the time at which that real number equals zero.
38	    (If the triggered condition function returns a boolean, then the returned time will
39	    just be the end of the step on which it becomes `True`.) 
40	    [`optimistix.Newton`](https://docs.kidger.site/optimistix/api/root_find/#optimistix.Newton)
41	    would be a typical choice here.
42	
43	!!! Example
44	
45	    Consider a bouncing ball dropped from some intial height $x_0$. We can model 
46	    the ball by a 2-dimensional ODE
47	
48	    $\\frac{dx_t}{dt} = v_t, \\quad \\frac{dv_t}{dt} = -g,$
49	
50	    where $x_t$ represents the height of the ball, $v_t$ its velocity, 
51	    and $g$ is the gravitational constant. With $g=8$, this corresponds to the
52	    vector field:
53	
54	    ```python
55	    def vector_field(t, y, args):
56	        _, v = y
57	        return jnp.array([v, -8.0])
58	    ```
59	
60	    Figuring out exactly when the ball hits the ground amounts to 
61	    solving the ODE until the event $x_t=0$ is triggered. This can be done by using 
62	    the real-valued condition function:
63	
64	    ```python
65	    def cond_fn(t, y, args, **kwargs):
66	        x, _ = y
67	        return x
68	    ```
69	
70	    With $x_0=10$, this would yield:
71	
72	    ```python
73	    y0 = jnp.array([10.0, 0.0])
74	    t0 = 0
75	    t1 = jnp.inf
76	    dt0 = 0.1
77	    term = diffrax.ODETerm(vector_field)
78	    root_finder = optx.Newton(1e-5, 1e-5, optx.rms_norm)
79	    event = diffrax.Event(cond_fn, root_finder)
80	    solver = diffrax.Tsit5()
81	    sol = diffrax.diffeqsolve(term, solver, t0, t1, dt0, y0, event=event)
82	    print(f"Event time: {sol.ts[0]}") # Event time: 1.58...
83	    print(f"Velocity at event time: {sol.ys[0, 1]}") # Velocity at event time: -12.64...
84	    ```
85	"""
86	
87	
88	def steady_state_event(

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/diffrax-0.7.0/diffrax-0.7.0/diffrax/_global_interpolation.py:295
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
294	
295	CubicInterpolation.__init__.__doc__ = """**Arguments:**
296	
297	- `ts`: Some increasing collection of times.
298	- `coeffs`: The coefficients at all but the last time.
299	
300	Any kind of spline (natural, ...) may be used; simply pass the appropriate
301	coefficients.
302	
303	In practice a good choice is typically "cubic Hermite splines with backward
304	differences", introduced in [this paper](https://arxiv.org/abs/2106.11028). Such
305	coefficients can be obtained using [`diffrax.backward_hermite_coefficients`][].
306	
307	Letting `d, c, b, a = coeffs`, then for all `t` in the interval from `ts[i]` to
308	`ts[i + 1]` the interpolation is defined as
309	```python
310	d[i] * (t - ts[i]) ** 3 + c[i] * (t - ts[i]) ** 2 + b[i] * (t - ts[i]) + a[i]
311	```
312	"""
313	
314	
315	class DenseInterpolation(AbstractGlobalInterpolation):

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/diffrax-0.7.0/diffrax-0.7.0/diffrax/_term.py:474
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
473	            raise ValueError(
474	                "The `ControlTerm` returned arrays whose output structure did not "
475	                "match the structure of the evolving state `y`. Specifically, the "
476	                f"{diffusion_word} had structure{vf_str}and the {control_word} "
477	                f"had structure{control_str}which when {dot_phrase} produced an "
478	                f"output of structure{out_str}which is different to the evolving "
479	                f"state `y` which had structure{y_str}"
480	                "\n"
481	                "This became an error in Diffrax 0.7.0. In previous versions of "
482	                "Diffrax then the output was broadcast to the shape of `y`. This "
483	                "has been removed as it was a common source of bugs.\n"
484	                "\n"
485	                "To walk you through what is going on, here is a sample program "
486	                "that now raises an error:\n"
487	                "```\n"
488	                "import diffrax as dfx\n"
489	                "import jax.numpy as jnp\n"
490	                "import jax.random as jr\n"
491	                "\n"
492	                "def drift(t, y, args):\n"
493	                "    return -y\n"
494	                "\n"
495	                "def diffusion(t, y, args):\n"
496	                "    return jnp.array([1., 0.5])\n"
497	                "\n"
498	                "key = jr.key(0)\n"
499	                "bm = dfx.VirtualBrownianTree(t0=0, t1=1, tol=1e-3, shape=(2,), key=key)\n"  # noqa: E501
500	                "terms = dfx.MultiTerm(dfx.ODETerm(drift), dfx.ControlTerm(diffusion, bm))\n"  # noqa: E501
501	                "solver = dfx.Euler()\n"
502	                "y0 = jnp.array([1., 1.])\n"
503	                "dfx.diffeqsolve(terms, solver, t0=0, t1=1, dt0=0.1, y0=y0)\n"
504	                "```\n"
505	                "In this case, the diffusion returns an array of shape `(2,)` and "
506	                "the Brownian motion is of shape `(2,)`. By the rules of "
507	                "`ControlTerm`, they are then dotted together so that the "
508	                "diffusion term returns a scalar. Under previous versions of "
509	                "Diffrax, this would then be broadcast out to both elements of the "
510	                "evolving state `y`, corresponding to the SDE:\n"
511	                "```\n"
512	                "dy₁(t) = -y₁(t) dt + dW₁ + 0.5 dW₂\n"
513	                "dy₂(t) = -y₂(t) dt + dW₁ + 0.5 dW₂\n"
514	                "```\n"
515	                "or the equivalent in vector notation, with `y(t), W(t) ⋹ R²`\n"
516	                "```\n"
517	                "dy(t) = -y(t) dt + [[1, 0.5], [1, 0.5]] dW\n"
518	                "```\n"
519	                "Which may have been unexpected! Quite possibly what was actually "
520	                "intended was an SDE with diagonal noise:\n"
521	                "```\n"
522	                "dy(t) = -y(t) dt + [[1, 0], [0, 0.5]] dW\n"
523	                "```\n"
524	                "\n"
525	                "As of Diffrax 0.7.0, the recommended way to express the "
526	                f"{diffusion_phrase} is to use a Lineax linear operator. "
527	                "(https://docs.kidger.site/lineax/api/operators/) For example, to "

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/diffrax-0.7.0/diffrax-0.7.0/diffrax/_term.py:561
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
560	
561	ControlTerm.__init__.__doc__ = """**Arguments:**
562	
563	- `vector_field`: A callable representing the vector field. This callable takes three
564	    arguments `(t, y, args)`. `t` is a scalar representing the integration time. `y` is
565	    the evolving state of the system. `args` are any static arguments as passed to
566	    [`diffrax.diffeqsolve`][]. This `vector_field` can either be
567	
568	    1. a function that returns a PyTree of JAX arrays, or
569	    2. it can return a
570	        [Lineax linear operator](https://docs.kidger.site/lineax/api/operators),
571	        as described above.
572	
573	- `control`: The control. Should either be
574	
575	    1. a [`diffrax.AbstractPath`][], in which case its `.evaluate(t0, t1)` method
576	        will be used to give the increment of the control over a time interval
577	        `[t0, t1]`, or
578	    2. a callable `(t0, t1) -> increment`, which returns the increment directly.
579	"""
580	
581	
582	def WeaklyDiagonalControlTerm(vector_field, control):

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/diffrax-0.7.0/diffrax-0.7.0/diffrax/_term.py:620
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
619	    warnings.warn(
620	        "`WeaklyDiagonalControlTerm` is now deprecated, in favour combining "
621	        "`ControlTerm` with a `lineax.AbstractLinearOperator`. This offers a way "
622	        "to define a vector field with any kind of structure -- diagonal or "
623	        "otherwise.\n"
624	        "For a diagonal linear operator, then this can be easily converted as "
625	        "follows. What was previously:\n"
626	        "```\n"
627	        "def vector_field(t, y, args):\n"
628	        "    ...\n"
629	        "    return some_vector\n"
630	        "\n"
631	        "diffrax.WeaklyDiagonalControlTerm(vector_field)\n"
632	        "```\n"
633	        "is now:\n"
634	        "```\n"
635	        "import lineax\n"
636	        "\n"
637	        "def vector_field(t, y, args):\n"
638	        "    ...\n"
639	        "    return lineax.DiagonalLinearOperator(some_vector)\n"
640	        "\n"
641	        "diffrax.ControlTerm(vector_field)\n"
642	        "```\n"
643	        "Lineax is available at `https://github.com/patrick-kidger/lineax`.\n",
644	        stacklevel=2,
645	    )
646	

--------------------------------------------------

Code scanned:
	Total lines of code: 12381
	Total lines skipped (#nosec): 0

Run metrics:
	Total issues (by severity):
		Undefined: 0.0
		Low: 0.0
		Medium: 9.0
		High: 0.0
	Total issues (by confidence):
		Undefined: 0.0
		Low: 0.0
		Medium: 9.0
		High: 0.0
Files skipped (0):
