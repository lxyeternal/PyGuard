Run started:2025-04-12 16:53:39.109107

Test results:
>> Issue: [B800:exec_used] exec
   Severity: Medium   Confidence: High
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/cytoolz-1.0.1/cytoolz-1.0.1/cytoolz/tests/test_inspect_args.py:22
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b800_exec_used.html
21	    d = {}
22	    exec('def func%s:\n    %s' % (param_string, body), globals(), d)
23	    return d['func']

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/cytoolz-1.0.1/cytoolz-1.0.1/setup.py:94
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
93	    ext_modules=ext_modules,
94	    long_description=(open('README.rst').read()
95	                        if os.path.exists('README.rst')

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/cytoolz-1.0.1/cytoolz-1.0.1/setup.py:97
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
96	                        else ''),
97	    url='https://github.com/pytoolz/cytoolz',
98	    author='https://raw.github.com/pytoolz/cytoolz/master/AUTHORS.md',

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/cytoolz-1.0.1/cytoolz-1.0.1/setup.py:98
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
97	    url='https://github.com/pytoolz/cytoolz',
98	    author='https://raw.github.com/pytoolz/cytoolz/master/AUTHORS.md',
99	    author_email='erik.n.welch@gmail.com',

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/cytoolz-1.0.1/cytoolz-1.0.1/versioneer.py:425
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
424	
425	LONG_VERSION_PY['git'] = r'''
426	# This file helps to compute a version number in source trees obtained from
427	# git-archive tarball (such as those provided by githubs download-from-tag
428	# feature). Distribution tarballs (built by setup.py sdist) and build
429	# directories (produced by setup.py build) will contain a much shorter file
430	# that just contains the computed version number.
431	
432	# This file is released into the public domain. Generated by
433	# versioneer-0.22 (https://github.com/python-versioneer/python-versioneer)
434	
435	"""Git implementation of _version.py."""
436	
437	import errno
438	import os
439	import re
440	import subprocess
441	import sys
442	import functools
443	
444	
445	def get_keywords():
446	    """Get the keywords needed to look up the version information."""
447	    # these strings will be replaced by git during git-archive.
448	    # setup.py/versioneer.py will grep for the variable names, so they must
449	    # each be defined on a line of their own. _version.py will just call
450	    # get_keywords().
451	    git_refnames = "%(DOLLAR)sFormat:%%d%(DOLLAR)s"
452	    git_full = "%(DOLLAR)sFormat:%%H%(DOLLAR)s"
453	    git_date = "%(DOLLAR)sFormat:%%ci%(DOLLAR)s"
454	    keywords = {"refnames": git_refnames, "full": git_full, "date": git_date}
455	    return keywords
456	
457	
458	class VersioneerConfig:
459	    """Container for Versioneer configuration parameters."""
460	
461	
462	def get_config():
463	    """Create, populate and return the VersioneerConfig() object."""
464	    # these strings are filled in when 'setup.py versioneer' creates
465	    # _version.py
466	    cfg = VersioneerConfig()
467	    cfg.VCS = "git"
468	    cfg.style = "%(STYLE)s"
469	    cfg.tag_prefix = "%(TAG_PREFIX)s"
470	    cfg.parentdir_prefix = "%(PARENTDIR_PREFIX)s"
471	    cfg.versionfile_source = "%(VERSIONFILE_SOURCE)s"
472	    cfg.verbose = False
473	    return cfg
474	
475	
476	class NotThisMethod(Exception):
477	    """Exception raised if a method is not valid for the current scenario."""
478	
479	
480	LONG_VERSION_PY = {}
481	HANDLERS = {}
482	
483	
484	def register_vcs_handler(vcs, method):  # decorator
485	    """Create decorator to mark a method as the handler of a VCS."""
486	    def decorate(f):
487	        """Store f in HANDLERS[vcs][method]."""
488	        if vcs not in HANDLERS:
489	            HANDLERS[vcs] = {}
490	        HANDLERS[vcs][method] = f
491	        return f
492	    return decorate
493	
494	
495	def run_command(commands, args, cwd=None, verbose=False, hide_stderr=False,
496	                env=None):
497	    """Call the given command(s)."""
498	    assert isinstance(commands, list)
499	    process = None
500	
501	    popen_kwargs = {}
502	    if sys.platform == "win32":
503	        # This hides the console window if pythonw.exe is used
504	        startupinfo = subprocess.STARTUPINFO()
505	        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
506	        popen_kwargs["startupinfo"] = startupinfo
507	
508	    for command in commands:
509	        try:
510	            dispcmd = str([command] + args)
511	            # remember shell=False, so use git.cmd on windows, not just git
512	            process = subprocess.Popen([command] + args, cwd=cwd, env=env,
513	                                       stdout=subprocess.PIPE,
514	                                       stderr=(subprocess.PIPE if hide_stderr
515	                                               else None), **popen_kwargs)
516	            break
517	        except OSError:
518	            e = sys.exc_info()[1]
519	            if e.errno == errno.ENOENT:
520	                continue
521	            if verbose:
522	                print("unable to run %%s" %% dispcmd)
523	                print(e)
524	            return None, None
525	    else:
526	        if verbose:
527	            print("unable to find command, tried %%s" %% (commands,))
528	        return None, None
529	    stdout = process.communicate()[0].strip().decode()
530	    if process.returncode != 0:
531	        if verbose:
532	            print("unable to run %%s (error)" %% dispcmd)
533	            print("stdout was %%s" %% stdout)
534	        return None, process.returncode
535	    return stdout, process.returncode
536	
537	
538	def versions_from_parentdir(parentdir_prefix, root, verbose):
539	    """Try to determine the version from the parent directory name.
540	
541	    Source tarballs conventionally unpack into a directory that includes both
542	    the project name and a version string. We will also support searching up
543	    two directory levels for an appropriately named parent directory
544	    """
545	    rootdirs = []
546	
547	    for _ in range(3):
548	        dirname = os.path.basename(root)
549	        if dirname.startswith(parentdir_prefix):
550	            return {"version": dirname[len(parentdir_prefix):],
551	                    "full-revisionid": None,
552	                    "dirty": False, "error": None, "date": None}
553	        rootdirs.append(root)
554	        root = os.path.dirname(root)  # up a level
555	
556	    if verbose:
557	        print("Tried directories %%s but none started with prefix %%s" %%
558	              (str(rootdirs), parentdir_prefix))
559	    raise NotThisMethod("rootdir doesn't start with parentdir_prefix")
560	
561	
562	@register_vcs_handler("git", "get_keywords")
563	def git_get_keywords(versionfile_abs):
564	    """Extract version information from the given file."""
565	    # the code embedded in _version.py can just fetch the value of these
566	    # keywords. When used from setup.py, we don't want to import _version.py,
567	    # so we do it with a regexp instead. This function is not used from
568	    # _version.py.
569	    keywords = {}
570	    try:
571	        with open(versionfile_abs, "r") as fobj:
572	            for line in fobj:
573	                if line.strip().startswith("git_refnames ="):
574	                    mo = re.search(r'=\s*"(.*)"', line)
575	                    if mo:
576	                        keywords["refnames"] = mo.group(1)
577	                if line.strip().startswith("git_full ="):
578	                    mo = re.search(r'=\s*"(.*)"', line)
579	                    if mo:
580	                        keywords["full"] = mo.group(1)
581	                if line.strip().startswith("git_date ="):
582	                    mo = re.search(r'=\s*"(.*)"', line)
583	                    if mo:
584	                        keywords["date"] = mo.group(1)
585	    except OSError:
586	        pass
587	    return keywords
588	
589	
590	@register_vcs_handler("git", "keywords")
591	def git_versions_from_keywords(keywords, tag_prefix, verbose):
592	    """Get version information from git keywords."""
593	    if "refnames" not in keywords:
594	        raise NotThisMethod("Short version file found")
595	    date = keywords.get("date")
596	    if date is not None:
597	        # Use only the last line.  Previous lines may contain GPG signature
598	        # information.
599	        date = date.splitlines()[-1]
600	
601	        # git-2.2.0 added "%%cI", which expands to an ISO-8601 -compliant
602	        # datestamp. However we prefer "%%ci" (which expands to an "ISO-8601
603	        # -like" string, which we must then edit to make compliant), because
604	        # it's been around since git-1.5.3, and it's too difficult to
605	        # discover which version we're using, or to work around using an
606	        # older one.
607	        date = date.strip().replace(" ", "T", 1).replace(" ", "", 1)
608	    refnames = keywords["refnames"].strip()
609	    if refnames.startswith("$Format"):
610	        if verbose:
611	            print("keywords are unexpanded, not using")
612	        raise NotThisMethod("unexpanded keywords, not a git-archive tarball")
613	    refs = {r.strip() for r in refnames.strip("()").split(",")}
614	    # starting in git-1.8.3, tags are listed as "tag: foo-1.0" instead of
615	    # just "foo-1.0". If we see a "tag: " prefix, prefer those.
616	    TAG = "tag: "
617	    tags = {r[len(TAG):] for r in refs if r.startswith(TAG)}
618	    if not tags:
619	        # Either we're using git < 1.8.3, or there really are no tags. We use
620	        # a heuristic: assume all version tags have a digit. The old git %%d
621	        # expansion behaves like git log --decorate=short and strips out the
622	        # refs/heads/ and refs/tags/ prefixes that would let us distinguish
623	        # between branches and tags. By ignoring refnames without digits, we
624	        # filter out many common branch names like "release" and
625	        # "stabilization", as well as "HEAD" and "master".
626	        tags = {r for r in refs if re.search(r'\d', r)}
627	        if verbose:
628	            print("discarding '%%s', no digits" %% ",".join(refs - tags))
629	    if verbose:
630	        print("likely tags: %%s" %% ",".join(sorted(tags)))
631	    for ref in sorted(tags):
632	        # sorting will prefer e.g. "2.0" over "2.0rc1"
633	        if ref.startswith(tag_prefix):
634	            r = ref[len(tag_prefix):]
635	            # Filter out refs that exactly match prefix or that don't start
636	            # with a number once the prefix is stripped (mostly a concern
637	            # when prefix is '')
638	            if not re.match(r'\d', r):
639	                continue
640	            if verbose:
641	                print("picking %%s" %% r)
642	            return {"version": r,
643	                    "full-revisionid": keywords["full"].strip(),
644	                    "dirty": False, "error": None,
645	                    "date": date}
646	    # no suitable tags, so version is "0+unknown", but full hex is still there
647	    if verbose:
648	        print("no suitable tags, using unknown + full revision id")
649	    return {"version": "0+unknown",
650	            "full-revisionid": keywords["full"].strip(),
651	            "dirty": False, "error": "no suitable tags", "date": None}
652	
653	
654	@register_vcs_handler("git", "pieces_from_vcs")
655	def git_pieces_from_vcs(tag_prefix, root, verbose, runner=run_command):
656	    """Get version from 'git describe' in the root of the source tree.
657	
658	    This only gets called if the git-archive 'subst' keywords were *not*
659	    expanded, and _version.py hasn't already been rewritten with a short
660	    version string, meaning we're inside a checked out source tree.
661	    """
662	    GITS = ["git"]
663	    if sys.platform == "win32":
664	        GITS = ["git.cmd", "git.exe"]
665	
666	    # GIT_DIR can interfere with correct operation of Versioneer.
667	    # It may be intended to be passed to the Versioneer-versioned project,
668	    # but that should not change where we get our version from.
669	    env = os.environ.copy()
670	    env.pop("GIT_DIR", None)
671	    runner = functools.partial(runner, env=env)
672	
673	    _, rc = runner(GITS, ["rev-parse", "--git-dir"], cwd=root,
674	                   hide_stderr=True)
675	    if rc != 0:
676	        if verbose:
677	            print("Directory %%s not under git control" %% root)
678	        raise NotThisMethod("'git rev-parse --git-dir' returned error")
679	
680	    MATCH_ARGS = ["--match", "%%s*" %% tag_prefix] if tag_prefix else []
681	
682	    # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]
683	    # if there isn't one, this yields HEX[-dirty] (no NUM)
684	    describe_out, rc = runner(GITS, ["describe", "--tags", "--dirty",
685	                                     "--always", "--long", *MATCH_ARGS],
686	                              cwd=root)
687	    # --long was added in git-1.5.5
688	    if describe_out is None:
689	        raise NotThisMethod("'git describe' failed")
690	    describe_out = describe_out.strip()
691	    full_out, rc = runner(GITS, ["rev-parse", "HEAD"], cwd=root)
692	    if full_out is None:
693	        raise NotThisMethod("'git rev-parse' failed")
694	    full_out = full_out.strip()
695	
696	    pieces = {}
697	    pieces["long"] = full_out
698	    pieces["short"] = full_out[:7]  # maybe improved later
699	    pieces["error"] = None
700	
701	    branch_name, rc = runner(GITS, ["rev-parse", "--abbrev-ref", "HEAD"],
702	                             cwd=root)
703	    # --abbrev-ref was added in git-1.6.3
704	    if rc != 0 or branch_name is None:
705	        raise NotThisMethod("'git rev-parse --abbrev-ref' returned error")
706	    branch_name = branch_name.strip()
707	
708	    if branch_name == "HEAD":
709	        # If we aren't exactly on a branch, pick a branch which represents
710	        # the current commit. If all else fails, we are on a branchless
711	        # commit.
712	        branches, rc = runner(GITS, ["branch", "--contains"], cwd=root)
713	        # --contains was added in git-1.5.4
714	        if rc != 0 or branches is None:
715	            raise NotThisMethod("'git branch --contains' returned error")
716	        branches = branches.split("\n")
717	
718	        # Remove the first line if we're running detached
719	        if "(" in branches[0]:
720	            branches.pop(0)
721	
722	        # Strip off the leading "* " from the list of branches.
723	        branches = [branch[2:] for branch in branches]
724	        if "master" in branches:
725	            branch_name = "master"
726	        elif not branches:
727	            branch_name = None
728	        else:
729	            # Pick the first branch that is returned. Good or bad.
730	            branch_name = branches[0]
731	
732	    pieces["branch"] = branch_name
733	
734	    # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]
735	    # TAG might have hyphens.
736	    git_describe = describe_out
737	
738	    # look for -dirty suffix
739	    dirty = git_describe.endswith("-dirty")
740	    pieces["dirty"] = dirty
741	    if dirty:
742	        git_describe = git_describe[:git_describe.rindex("-dirty")]
743	
744	    # now we have TAG-NUM-gHEX or HEX
745	
746	    if "-" in git_describe:
747	        # TAG-NUM-gHEX
748	        mo = re.search(r'^(.+)-(\d+)-g([0-9a-f]+)$', git_describe)
749	        if not mo:
750	            # unparsable. Maybe git-describe is misbehaving?
751	            pieces["error"] = ("unable to parse git-describe output: '%%s'"
752	                               %% describe_out)
753	            return pieces
754	
755	        # tag
756	        full_tag = mo.group(1)
757	        if not full_tag.startswith(tag_prefix):
758	            if verbose:
759	                fmt = "tag '%%s' doesn't start with prefix '%%s'"
760	                print(fmt %% (full_tag, tag_prefix))
761	            pieces["error"] = ("tag '%%s' doesn't start with prefix '%%s'"
762	                               %% (full_tag, tag_prefix))
763	            return pieces
764	        pieces["closest-tag"] = full_tag[len(tag_prefix):]
765	
766	        # distance: number of commits since tag
767	        pieces["distance"] = int(mo.group(2))
768	
769	        # commit: short hex revision ID
770	        pieces["short"] = mo.group(3)
771	
772	    else:
773	        # HEX: no tags
774	        pieces["closest-tag"] = None
775	        count_out, rc = runner(GITS, ["rev-list", "HEAD", "--count"], cwd=root)
776	        pieces["distance"] = int(count_out)  # total number of commits
777	
778	    # commit date: see ISO-8601 comment in git_versions_from_keywords()
779	    date = runner(GITS, ["show", "-s", "--format=%%ci", "HEAD"], cwd=root)[0].strip()
780	    # Use only the last line.  Previous lines may contain GPG signature
781	    # information.
782	    date = date.splitlines()[-1]
783	    pieces["date"] = date.strip().replace(" ", "T", 1).replace(" ", "", 1)
784	
785	    return pieces
786	
787	
788	def plus_or_dot(pieces):
789	    """Return a + if we don't already have one, else return a ."""
790	    if "+" in pieces.get("closest-tag", ""):
791	        return "."
792	    return "+"
793	
794	
795	def render_pep440(pieces):
796	    """Build up version string, with post-release "local version identifier".
797	
798	    Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you
799	    get a tagged build and then dirty it, you'll get TAG+0.gHEX.dirty
800	
801	    Exceptions:
802	    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]
803	    """
804	    if pieces["closest-tag"]:
805	        rendered = pieces["closest-tag"]
806	        if pieces["distance"] or pieces["dirty"]:
807	            rendered += plus_or_dot(pieces)
808	            rendered += "%%d.g%%s" %% (pieces["distance"], pieces["short"])
809	            if pieces["dirty"]:
810	                rendered += ".dirty"
811	    else:
812	        # exception #1
813	        rendered = "0+untagged.%%d.g%%s" %% (pieces["distance"],
814	                                          pieces["short"])
815	        if pieces["dirty"]:
816	            rendered += ".dirty"
817	    return rendered
818	
819	
820	def render_pep440_branch(pieces):
821	    """TAG[[.dev0]+DISTANCE.gHEX[.dirty]] .
822	
823	    The ".dev0" means not master branch. Note that .dev0 sorts backwards
824	    (a feature branch will appear "older" than the master branch).
825	
826	    Exceptions:
827	    1: no tags. 0[.dev0]+untagged.DISTANCE.gHEX[.dirty]
828	    """
829	    if pieces["closest-tag"]:
830	        rendered = pieces["closest-tag"]
831	        if pieces["distance"] or pieces["dirty"]:
832	            if pieces["branch"] != "master":
833	                rendered += ".dev0"
834	            rendered += plus_or_dot(pieces)
835	            rendered += "%%d.g%%s" %% (pieces["distance"], pieces["short"])
836	            if pieces["dirty"]:
837	                rendered += ".dirty"
838	    else:
839	        # exception #1
840	        rendered = "0"
841	        if pieces["branch"] != "master":
842	            rendered += ".dev0"
843	        rendered += "+untagged.%%d.g%%s" %% (pieces["distance"],
844	                                          pieces["short"])
845	        if pieces["dirty"]:
846	            rendered += ".dirty"
847	    return rendered
848	
849	
850	def pep440_split_post(ver):
851	    """Split pep440 version string at the post-release segment.
852	
853	    Returns the release segments before the post-release and the
854	    post-release version number (or -1 if no post-release segment is present).
855	    """
856	    vc = str.split(ver, ".post")
857	    return vc[0], int(vc[1] or 0) if len(vc) == 2 else None
858	
859	
860	def render_pep440_pre(pieces):
861	    """TAG[.postN.devDISTANCE] -- No -dirty.
862	
863	    Exceptions:
864	    1: no tags. 0.post0.devDISTANCE
865	    """
866	    if pieces["closest-tag"]:
867	        if pieces["distance"]:
868	            # update the post release segment
869	            tag_version, post_version = pep440_split_post(pieces["closest-tag"])
870	            rendered = tag_version
871	            if post_version is not None:
872	                rendered += ".post%%d.dev%%d" %% (post_version+1, pieces["distance"])
873	            else:
874	                rendered += ".post0.dev%%d" %% (pieces["distance"])
875	        else:
876	            # no commits, use the tag as the version
877	            rendered = pieces["closest-tag"]
878	    else:
879	        # exception #1
880	        rendered = "0.post0.dev%%d" %% pieces["distance"]
881	    return rendered
882	
883	
884	def render_pep440_post(pieces):
885	    """TAG[.postDISTANCE[.dev0]+gHEX] .
886	
887	    The ".dev0" means dirty. Note that .dev0 sorts backwards
888	    (a dirty tree will appear "older" than the corresponding clean one),
889	    but you shouldn't be releasing software with -dirty anyways.
890	
891	    Exceptions:
892	    1: no tags. 0.postDISTANCE[.dev0]
893	    """
894	    if pieces["closest-tag"]:
895	        rendered = pieces["closest-tag"]
896	        if pieces["distance"] or pieces["dirty"]:
897	            rendered += ".post%%d" %% pieces["distance"]
898	            if pieces["dirty"]:
899	                rendered += ".dev0"
900	            rendered += plus_or_dot(pieces)
901	            rendered += "g%%s" %% pieces["short"]
902	    else:
903	        # exception #1
904	        rendered = "0.post%%d" %% pieces["distance"]
905	        if pieces["dirty"]:
906	            rendered += ".dev0"
907	        rendered += "+g%%s" %% pieces["short"]
908	    return rendered
909	
910	
911	def render_pep440_post_branch(pieces):
912	    """TAG[.postDISTANCE[.dev0]+gHEX[.dirty]] .
913	
914	    The ".dev0" means not master branch.
915	
916	    Exceptions:
917	    1: no tags. 0.postDISTANCE[.dev0]+gHEX[.dirty]
918	    """
919	    if pieces["closest-tag"]:
920	        rendered = pieces["closest-tag"]
921	        if pieces["distance"] or pieces["dirty"]:
922	            rendered += ".post%%d" %% pieces["distance"]
923	            if pieces["branch"] != "master":
924	                rendered += ".dev0"
925	            rendered += plus_or_dot(pieces)
926	            rendered += "g%%s" %% pieces["short"]
927	            if pieces["dirty"]:
928	                rendered += ".dirty"
929	    else:
930	        # exception #1
931	        rendered = "0.post%%d" %% pieces["distance"]
932	        if pieces["branch"] != "master":
933	            rendered += ".dev0"
934	        rendered += "+g%%s" %% pieces["short"]
935	        if pieces["dirty"]:
936	            rendered += ".dirty"
937	    return rendered
938	
939	
940	def render_pep440_old(pieces):
941	    """TAG[.postDISTANCE[.dev0]] .
942	
943	    The ".dev0" means dirty.
944	
945	    Exceptions:
946	    1: no tags. 0.postDISTANCE[.dev0]
947	    """
948	    if pieces["closest-tag"]:
949	        rendered = pieces["closest-tag"]
950	        if pieces["distance"] or pieces["dirty"]:
951	            rendered += ".post%%d" %% pieces["distance"]
952	            if pieces["dirty"]:
953	                rendered += ".dev0"
954	    else:
955	        # exception #1
956	        rendered = "0.post%%d" %% pieces["distance"]
957	        if pieces["dirty"]:
958	            rendered += ".dev0"
959	    return rendered
960	
961	
962	def render_git_describe(pieces):
963	    """TAG[-DISTANCE-gHEX][-dirty].
964	
965	    Like 'git describe --tags --dirty --always'.
966	
967	    Exceptions:
968	    1: no tags. HEX[-dirty]  (note: no 'g' prefix)
969	    """
970	    if pieces["closest-tag"]:
971	        rendered = pieces["closest-tag"]
972	        if pieces["distance"]:
973	            rendered += "-%%d-g%%s" %% (pieces["distance"], pieces["short"])
974	    else:
975	        # exception #1
976	        rendered = pieces["short"]
977	    if pieces["dirty"]:
978	        rendered += "-dirty"
979	    return rendered
980	
981	
982	def render_git_describe_long(pieces):
983	    """TAG-DISTANCE-gHEX[-dirty].
984	
985	    Like 'git describe --tags --dirty --always -long'.
986	    The distance/hash is unconditional.
987	
988	    Exceptions:
989	    1: no tags. HEX[-dirty]  (note: no 'g' prefix)
990	    """
991	    if pieces["closest-tag"]:
992	        rendered = pieces["closest-tag"]
993	        rendered += "-%%d-g%%s" %% (pieces["distance"], pieces["short"])
994	    else:
995	        # exception #1
996	        rendered = pieces["short"]
997	    if pieces["dirty"]:
998	        rendered += "-dirty"
999	    return rendered
1000	
1001	
1002	def render(pieces, style):
1003	    """Render the given version pieces into the requested style."""
1004	    if pieces["error"]:
1005	        return {"version": "unknown",
1006	                "full-revisionid": pieces.get("long"),
1007	                "dirty": None,
1008	                "error": pieces["error"],
1009	                "date": None}
1010	
1011	    if not style or style == "default":
1012	        style = "pep440"  # the default
1013	
1014	    if style == "pep440":
1015	        rendered = render_pep440(pieces)
1016	    elif style == "pep440-branch":
1017	        rendered = render_pep440_branch(pieces)
1018	    elif style == "pep440-pre":
1019	        rendered = render_pep440_pre(pieces)
1020	    elif style == "pep440-post":
1021	        rendered = render_pep440_post(pieces)
1022	    elif style == "pep440-post-branch":
1023	        rendered = render_pep440_post_branch(pieces)
1024	    elif style == "pep440-old":
1025	        rendered = render_pep440_old(pieces)
1026	    elif style == "git-describe":
1027	        rendered = render_git_describe(pieces)
1028	    elif style == "git-describe-long":
1029	        rendered = render_git_describe_long(pieces)
1030	    else:
1031	        raise ValueError("unknown style '%%s'" %% style)
1032	
1033	    return {"version": rendered, "full-revisionid": pieces["long"],
1034	            "dirty": pieces["dirty"], "error": None,
1035	            "date": pieces.get("date")}
1036	
1037	
1038	def get_versions():
1039	    """Get version information or return default if unable to do so."""
1040	    # I am in _version.py, which lives at ROOT/VERSIONFILE_SOURCE. If we have
1041	    # __file__, we can work backwards from there to the root. Some
1042	    # py2exe/bbfreeze/non-CPython implementations don't do __file__, in which
1043	    # case we can only use expanded keywords.
1044	
1045	    cfg = get_config()
1046	    verbose = cfg.verbose
1047	
1048	    try:
1049	        return git_versions_from_keywords(get_keywords(), cfg.tag_prefix,
1050	                                          verbose)
1051	    except NotThisMethod:
1052	        pass
1053	
1054	    try:
1055	        root = os.path.realpath(__file__)
1056	        # versionfile_source is the relative path from the top of the source
1057	        # tree (where the .git directory might live) to this file. Invert
1058	        # this to find the root from __file__.
1059	        for _ in cfg.versionfile_source.split('/'):
1060	            root = os.path.dirname(root)
1061	    except NameError:
1062	        return {"version": "0+unknown", "full-revisionid": None,
1063	                "dirty": None,
1064	                "error": "unable to find root of source tree",
1065	                "date": None}
1066	
1067	    try:
1068	        pieces = git_pieces_from_vcs(cfg.tag_prefix, root, verbose)
1069	        return render(pieces, cfg.style)
1070	    except NotThisMethod:
1071	        pass
1072	
1073	    try:
1074	        if cfg.parentdir_prefix:
1075	            return versions_from_parentdir(cfg.parentdir_prefix, root, verbose)
1076	    except NotThisMethod:
1077	        pass
1078	
1079	    return {"version": "0+unknown", "full-revisionid": None,
1080	            "dirty": None,
1081	            "error": "unable to compute version", "date": None}
1082	'''
1083	
1084	
1085	@register_vcs_handler("git", "get_keywords")
1086	def git_get_keywords(versionfile_abs):

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/cytoolz-1.0.1/cytoolz-1.0.1/versioneer.py:1343
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1342	        with open(".gitattributes", "a+") as fobj:
1343	            fobj.write(versionfile_source + " export-subst\n")
1344	        files.append(".gitattributes")

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/cytoolz-1.0.1/cytoolz-1.0.1/versioneer.py:1394
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
1393	        with open(filename) as f:
1394	            contents = f.read()
1395	    except OSError:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/cytoolz-1.0.1/cytoolz-1.0.1/versioneer.py:1413
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1412	    with open(filename, "w") as f:
1413	        f.write(SHORT_VERSION_PY % contents)
1414	

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/cytoolz-1.0.1/cytoolz-1.0.1/versioneer.py:1890
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1889	                    LONG = LONG_VERSION_PY[cfg.VCS]
1890	                    f.write(LONG %
1891	                            {"DOLLAR": "$",
1892	                             "STYLE": cfg.style,
1893	                             "TAG_PREFIX": cfg.tag_prefix,
1894	                             "PARENTDIR_PREFIX": cfg.parentdir_prefix,
1895	                             "VERSIONFILE_SOURCE": cfg.versionfile_source,
1896	                             })

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/cytoolz-1.0.1/cytoolz-1.0.1/versioneer.py:1916
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1915	                    LONG = LONG_VERSION_PY[cfg.VCS]
1916	                    f.write(LONG %
1917	                            {"DOLLAR": "$",
1918	                             "STYLE": cfg.style,
1919	                             "TAG_PREFIX": cfg.tag_prefix,
1920	                             "PARENTDIR_PREFIX": cfg.parentdir_prefix,
1921	                             "VERSIONFILE_SOURCE": cfg.versionfile_source,
1922	                             })

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/cytoolz-1.0.1/cytoolz-1.0.1/versioneer.py:2018
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2017	            with open(os.path.join(root, "setup.cfg"), "a") as f:
2018	                f.write(SAMPLE_CONFIG)
2019	        print(CONFIG_ERROR, file=sys.stderr)

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/cytoolz-1.0.1/cytoolz-1.0.1/versioneer.py:2025
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2024	        LONG = LONG_VERSION_PY[cfg.VCS]
2025	        f.write(LONG % {"DOLLAR": "$",
2026	                        "STYLE": cfg.style,
2027	                        "TAG_PREFIX": cfg.tag_prefix,
2028	                        "PARENTDIR_PREFIX": cfg.parentdir_prefix,
2029	                        "VERSIONFILE_SOURCE": cfg.versionfile_source,
2030	                        })

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/cytoolz-1.0.1/cytoolz-1.0.1/versioneer.py:2037
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
2036	            with open(ipy, "r") as f:
2037	                old = f.read()
2038	        except OSError:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/cytoolz-1.0.1/cytoolz-1.0.1/versioneer.py:2045
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2044	            with open(ipy, "w") as f:
2045	                f.write(old.replace(OLD_SNIPPET, snippet))
2046	        elif snippet not in old:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/cytoolz-1.0.1/cytoolz-1.0.1/versioneer.py:2049
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2048	            with open(ipy, "a") as f:
2049	                f.write(snippet)
2050	        else:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/cytoolz-1.0.1/cytoolz-1.0.1/versioneer.py:2077
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2076	        with open(manifest_in, "a") as f:
2077	            f.write("include versioneer.py\n")
2078	    else:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/cytoolz-1.0.1/cytoolz-1.0.1/versioneer.py:2084
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2083	        with open(manifest_in, "a") as f:
2084	            f.write("include %s\n" % cfg.versionfile_source)
2085	    else:

--------------------------------------------------

Code scanned:
	Total lines of code: 4384
	Total lines skipped (#nosec): 0

Run metrics:
	Total issues (by severity):
		Undefined: 0.0
		Low: 0.0
		Medium: 4.0
		High: 13.0
	Total issues (by confidence):
		Undefined: 0.0
		Low: 0.0
		Medium: 16.0
		High: 1.0
Files skipped (0):
