Run started:2025-04-12 17:12:38.855769

Test results:
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/matchpy-0.5.5/matchpy-0.5.5/versioneer.py:421
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
420	
421	LONG_VERSION_PY['git'] = '''
422	# This file helps to compute a version number in source trees obtained from
423	# git-archive tarball (such as those provided by githubs download-from-tag
424	# feature). Distribution tarballs (built by setup.py sdist) and build
425	# directories (produced by setup.py build) will contain a much shorter file
426	# that just contains the computed version number.
427	
428	# This file is released into the public domain. Generated by
429	# versioneer-0.18 (https://github.com/warner/python-versioneer)
430	
431	"""Git implementation of _version.py."""
432	
433	import errno
434	import os
435	import re
436	import subprocess
437	import sys
438	
439	
440	def get_keywords():
441	    """Get the keywords needed to look up the version information."""
442	    # these strings will be replaced by git during git-archive.
443	    # setup.py/versioneer.py will grep for the variable names, so they must
444	    # each be defined on a line of their own. _version.py will just call
445	    # get_keywords().
446	    git_refnames = "%(DOLLAR)sFormat:%%d%(DOLLAR)s"
447	    git_full = "%(DOLLAR)sFormat:%%H%(DOLLAR)s"
448	    git_date = "%(DOLLAR)sFormat:%%ci%(DOLLAR)s"
449	    keywords = {"refnames": git_refnames, "full": git_full, "date": git_date}
450	    return keywords
451	
452	
453	class VersioneerConfig:
454	    """Container for Versioneer configuration parameters."""
455	
456	
457	def get_config():
458	    """Create, populate and return the VersioneerConfig() object."""
459	    # these strings are filled in when 'setup.py versioneer' creates
460	    # _version.py
461	    cfg = VersioneerConfig()
462	    cfg.VCS = "git"
463	    cfg.style = "%(STYLE)s"
464	    cfg.tag_prefix = "%(TAG_PREFIX)s"
465	    cfg.parentdir_prefix = "%(PARENTDIR_PREFIX)s"
466	    cfg.versionfile_source = "%(VERSIONFILE_SOURCE)s"
467	    cfg.verbose = False
468	    return cfg
469	
470	
471	class NotThisMethod(Exception):
472	    """Exception raised if a method is not valid for the current scenario."""
473	
474	
475	LONG_VERSION_PY = {}
476	HANDLERS = {}
477	
478	
479	def register_vcs_handler(vcs, method):  # decorator
480	    """Decorator to mark a method as the handler for a particular VCS."""
481	    def decorate(f):
482	        """Store f in HANDLERS[vcs][method]."""
483	        if vcs not in HANDLERS:
484	            HANDLERS[vcs] = {}
485	        HANDLERS[vcs][method] = f
486	        return f
487	    return decorate
488	
489	
490	def run_command(commands, args, cwd=None, verbose=False, hide_stderr=False,
491	                env=None):
492	    """Call the given command(s)."""
493	    assert isinstance(commands, list)
494	    p = None
495	    for c in commands:
496	        try:
497	            dispcmd = str([c] + args)
498	            # remember shell=False, so use git.cmd on windows, not just git
499	            p = subprocess.Popen([c] + args, cwd=cwd, env=env,
500	                                 stdout=subprocess.PIPE,
501	                                 stderr=(subprocess.PIPE if hide_stderr
502	                                         else None))
503	            break
504	        except EnvironmentError:
505	            e = sys.exc_info()[1]
506	            if e.errno == errno.ENOENT:
507	                continue
508	            if verbose:
509	                print("unable to run %%s" %% dispcmd)
510	                print(e)
511	            return None, None
512	    else:
513	        if verbose:
514	            print("unable to find command, tried %%s" %% (commands,))
515	        return None, None
516	    stdout = p.communicate()[0].strip()
517	    if sys.version_info[0] >= 3:
518	        stdout = stdout.decode()
519	    if p.returncode != 0:
520	        if verbose:
521	            print("unable to run %%s (error)" %% dispcmd)
522	            print("stdout was %%s" %% stdout)
523	        return None, p.returncode
524	    return stdout, p.returncode
525	
526	
527	def versions_from_parentdir(parentdir_prefix, root, verbose):
528	    """Try to determine the version from the parent directory name.
529	
530	    Source tarballs conventionally unpack into a directory that includes both
531	    the project name and a version string. We will also support searching up
532	    two directory levels for an appropriately named parent directory
533	    """
534	    rootdirs = []
535	
536	    for i in range(3):
537	        dirname = os.path.basename(root)
538	        if dirname.startswith(parentdir_prefix):
539	            return {"version": dirname[len(parentdir_prefix):],
540	                    "full-revisionid": None,
541	                    "dirty": False, "error": None, "date": None}
542	        else:
543	            rootdirs.append(root)
544	            root = os.path.dirname(root)  # up a level
545	
546	    if verbose:
547	        print("Tried directories %%s but none started with prefix %%s" %%
548	              (str(rootdirs), parentdir_prefix))
549	    raise NotThisMethod("rootdir doesn't start with parentdir_prefix")
550	
551	
552	@register_vcs_handler("git", "get_keywords")
553	def git_get_keywords(versionfile_abs):
554	    """Extract version information from the given file."""
555	    # the code embedded in _version.py can just fetch the value of these
556	    # keywords. When used from setup.py, we don't want to import _version.py,
557	    # so we do it with a regexp instead. This function is not used from
558	    # _version.py.
559	    keywords = {}
560	    try:
561	        f = open(versionfile_abs, "r")
562	        for line in f.readlines():
563	            if line.strip().startswith("git_refnames ="):
564	                mo = re.search(r'=\s*"(.*)"', line)
565	                if mo:
566	                    keywords["refnames"] = mo.group(1)
567	            if line.strip().startswith("git_full ="):
568	                mo = re.search(r'=\s*"(.*)"', line)
569	                if mo:
570	                    keywords["full"] = mo.group(1)
571	            if line.strip().startswith("git_date ="):
572	                mo = re.search(r'=\s*"(.*)"', line)
573	                if mo:
574	                    keywords["date"] = mo.group(1)
575	        f.close()
576	    except EnvironmentError:
577	        pass
578	    return keywords
579	
580	
581	@register_vcs_handler("git", "keywords")
582	def git_versions_from_keywords(keywords, tag_prefix, verbose):
583	    """Get version information from git keywords."""
584	    if not keywords:
585	        raise NotThisMethod("no keywords at all, weird")
586	    date = keywords.get("date")
587	    if date is not None:
588	        # git-2.2.0 added "%%cI", which expands to an ISO-8601 -compliant
589	        # datestamp. However we prefer "%%ci" (which expands to an "ISO-8601
590	        # -like" string, which we must then edit to make compliant), because
591	        # it's been around since git-1.5.3, and it's too difficult to
592	        # discover which version we're using, or to work around using an
593	        # older one.
594	        date = date.strip().replace(" ", "T", 1).replace(" ", "", 1)
595	    refnames = keywords["refnames"].strip()
596	    if refnames.startswith("$Format"):
597	        if verbose:
598	            print("keywords are unexpanded, not using")
599	        raise NotThisMethod("unexpanded keywords, not a git-archive tarball")
600	    refs = set([r.strip() for r in refnames.strip("()").split(",")])
601	    # starting in git-1.8.3, tags are listed as "tag: foo-1.0" instead of
602	    # just "foo-1.0". If we see a "tag: " prefix, prefer those.
603	    TAG = "tag: "
604	    tags = set([r[len(TAG):] for r in refs if r.startswith(TAG)])
605	    if not tags:
606	        # Either we're using git < 1.8.3, or there really are no tags. We use
607	        # a heuristic: assume all version tags have a digit. The old git %%d
608	        # expansion behaves like git log --decorate=short and strips out the
609	        # refs/heads/ and refs/tags/ prefixes that would let us distinguish
610	        # between branches and tags. By ignoring refnames without digits, we
611	        # filter out many common branch names like "release" and
612	        # "stabilization", as well as "HEAD" and "master".
613	        tags = set([r for r in refs if re.search(r'\d', r)])
614	        if verbose:
615	            print("discarding '%%s', no digits" %% ",".join(refs - tags))
616	    if verbose:
617	        print("likely tags: %%s" %% ",".join(sorted(tags)))
618	    for ref in sorted(tags):
619	        # sorting will prefer e.g. "2.0" over "2.0rc1"
620	        if ref.startswith(tag_prefix):
621	            r = ref[len(tag_prefix):]
622	            if verbose:
623	                print("picking %%s" %% r)
624	            return {"version": r,
625	                    "full-revisionid": keywords["full"].strip(),
626	                    "dirty": False, "error": None,
627	                    "date": date}
628	    # no suitable tags, so version is "0+unknown", but full hex is still there
629	    if verbose:
630	        print("no suitable tags, using unknown + full revision id")
631	    return {"version": "0+unknown",
632	            "full-revisionid": keywords["full"].strip(),
633	            "dirty": False, "error": "no suitable tags", "date": None}
634	
635	
636	@register_vcs_handler("git", "pieces_from_vcs")
637	def git_pieces_from_vcs(tag_prefix, root, verbose, run_command=run_command):
638	    """Get version from 'git describe' in the root of the source tree.
639	
640	    This only gets called if the git-archive 'subst' keywords were *not*
641	    expanded, and _version.py hasn't already been rewritten with a short
642	    version string, meaning we're inside a checked out source tree.
643	    """
644	    GITS = ["git"]
645	    if sys.platform == "win32":
646	        GITS = ["git.cmd", "git.exe"]
647	
648	    out, rc = run_command(GITS, ["rev-parse", "--git-dir"], cwd=root,
649	                          hide_stderr=True)
650	    if rc != 0:
651	        if verbose:
652	            print("Directory %%s not under git control" %% root)
653	        raise NotThisMethod("'git rev-parse --git-dir' returned error")
654	
655	    # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]
656	    # if there isn't one, this yields HEX[-dirty] (no NUM)
657	    describe_out, rc = run_command(GITS, ["describe", "--tags", "--dirty",
658	                                          "--always", "--long",
659	                                          "--match", "%%s*" %% tag_prefix],
660	                                   cwd=root)
661	    # --long was added in git-1.5.5
662	    if describe_out is None:
663	        raise NotThisMethod("'git describe' failed")
664	    describe_out = describe_out.strip()
665	    full_out, rc = run_command(GITS, ["rev-parse", "HEAD"], cwd=root)
666	    if full_out is None:
667	        raise NotThisMethod("'git rev-parse' failed")
668	    full_out = full_out.strip()
669	
670	    pieces = {}
671	    pieces["long"] = full_out
672	    pieces["short"] = full_out[:7]  # maybe improved later
673	    pieces["error"] = None
674	
675	    # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]
676	    # TAG might have hyphens.
677	    git_describe = describe_out
678	
679	    # look for -dirty suffix
680	    dirty = git_describe.endswith("-dirty")
681	    pieces["dirty"] = dirty
682	    if dirty:
683	        git_describe = git_describe[:git_describe.rindex("-dirty")]
684	
685	    # now we have TAG-NUM-gHEX or HEX
686	
687	    if "-" in git_describe:
688	        # TAG-NUM-gHEX
689	        mo = re.search(r'^(.+)-(\d+)-g([0-9a-f]+)$', git_describe)
690	        if not mo:
691	            # unparseable. Maybe git-describe is misbehaving?
692	            pieces["error"] = ("unable to parse git-describe output: '%%s'"
693	                               %% describe_out)
694	            return pieces
695	
696	        # tag
697	        full_tag = mo.group(1)
698	        if not full_tag.startswith(tag_prefix):
699	            if verbose:
700	                fmt = "tag '%%s' doesn't start with prefix '%%s'"
701	                print(fmt %% (full_tag, tag_prefix))
702	            pieces["error"] = ("tag '%%s' doesn't start with prefix '%%s'"
703	                               %% (full_tag, tag_prefix))
704	            return pieces
705	        pieces["closest-tag"] = full_tag[len(tag_prefix):]
706	
707	        # distance: number of commits since tag
708	        pieces["distance"] = int(mo.group(2))
709	
710	        # commit: short hex revision ID
711	        pieces["short"] = mo.group(3)
712	
713	    else:
714	        # HEX: no tags
715	        pieces["closest-tag"] = None
716	        count_out, rc = run_command(GITS, ["rev-list", "HEAD", "--count"],
717	                                    cwd=root)
718	        pieces["distance"] = int(count_out)  # total number of commits
719	
720	    # commit date: see ISO-8601 comment in git_versions_from_keywords()
721	    date = run_command(GITS, ["show", "-s", "--format=%%ci", "HEAD"],
722	                       cwd=root)[0].strip()
723	    pieces["date"] = date.strip().replace(" ", "T", 1).replace(" ", "", 1)
724	
725	    return pieces
726	
727	
728	def plus_or_dot(pieces):
729	    """Return a + if we don't already have one, else return a ."""
730	    if "+" in pieces.get("closest-tag", ""):
731	        return "."
732	    return "+"
733	
734	
735	def render_pep440(pieces):
736	    """Build up version string, with post-release "local version identifier".
737	
738	    Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you
739	    get a tagged build and then dirty it, you'll get TAG+0.gHEX.dirty
740	
741	    Exceptions:
742	    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]
743	    """
744	    if pieces["closest-tag"]:
745	        rendered = pieces["closest-tag"]
746	        if pieces["distance"] or pieces["dirty"]:
747	            rendered += plus_or_dot(pieces)
748	            rendered += "%%d.g%%s" %% (pieces["distance"], pieces["short"])
749	            if pieces["dirty"]:
750	                rendered += ".dirty"
751	    else:
752	        # exception #1
753	        rendered = "0+untagged.%%d.g%%s" %% (pieces["distance"],
754	                                          pieces["short"])
755	        if pieces["dirty"]:
756	            rendered += ".dirty"
757	    return rendered
758	
759	
760	def render_pep440_pre(pieces):
761	    """TAG[.post.devDISTANCE] -- No -dirty.
762	
763	    Exceptions:
764	    1: no tags. 0.post.devDISTANCE
765	    """
766	    if pieces["closest-tag"]:
767	        rendered = pieces["closest-tag"]
768	        if pieces["distance"]:
769	            rendered += ".post.dev%%d" %% pieces["distance"]
770	    else:
771	        # exception #1
772	        rendered = "0.post.dev%%d" %% pieces["distance"]
773	    return rendered
774	
775	
776	def render_pep440_post(pieces):
777	    """TAG[.postDISTANCE[.dev0]+gHEX] .
778	
779	    The ".dev0" means dirty. Note that .dev0 sorts backwards
780	    (a dirty tree will appear "older" than the corresponding clean one),
781	    but you shouldn't be releasing software with -dirty anyways.
782	
783	    Exceptions:
784	    1: no tags. 0.postDISTANCE[.dev0]
785	    """
786	    if pieces["closest-tag"]:
787	        rendered = pieces["closest-tag"]
788	        if pieces["distance"] or pieces["dirty"]:
789	            rendered += ".post%%d" %% pieces["distance"]
790	            if pieces["dirty"]:
791	                rendered += ".dev0"
792	            rendered += plus_or_dot(pieces)
793	            rendered += "g%%s" %% pieces["short"]
794	    else:
795	        # exception #1
796	        rendered = "0.post%%d" %% pieces["distance"]
797	        if pieces["dirty"]:
798	            rendered += ".dev0"
799	        rendered += "+g%%s" %% pieces["short"]
800	    return rendered
801	
802	
803	def render_pep440_old(pieces):
804	    """TAG[.postDISTANCE[.dev0]] .
805	
806	    The ".dev0" means dirty.
807	
808	    Eexceptions:
809	    1: no tags. 0.postDISTANCE[.dev0]
810	    """
811	    if pieces["closest-tag"]:
812	        rendered = pieces["closest-tag"]
813	        if pieces["distance"] or pieces["dirty"]:
814	            rendered += ".post%%d" %% pieces["distance"]
815	            if pieces["dirty"]:
816	                rendered += ".dev0"
817	    else:
818	        # exception #1
819	        rendered = "0.post%%d" %% pieces["distance"]
820	        if pieces["dirty"]:
821	            rendered += ".dev0"
822	    return rendered
823	
824	
825	def render_git_describe(pieces):
826	    """TAG[-DISTANCE-gHEX][-dirty].
827	
828	    Like 'git describe --tags --dirty --always'.
829	
830	    Exceptions:
831	    1: no tags. HEX[-dirty]  (note: no 'g' prefix)
832	    """
833	    if pieces["closest-tag"]:
834	        rendered = pieces["closest-tag"]
835	        if pieces["distance"]:
836	            rendered += "-%%d-g%%s" %% (pieces["distance"], pieces["short"])
837	    else:
838	        # exception #1
839	        rendered = pieces["short"]
840	    if pieces["dirty"]:
841	        rendered += "-dirty"
842	    return rendered
843	
844	
845	def render_git_describe_long(pieces):
846	    """TAG-DISTANCE-gHEX[-dirty].
847	
848	    Like 'git describe --tags --dirty --always -long'.
849	    The distance/hash is unconditional.
850	
851	    Exceptions:
852	    1: no tags. HEX[-dirty]  (note: no 'g' prefix)
853	    """
854	    if pieces["closest-tag"]:
855	        rendered = pieces["closest-tag"]
856	        rendered += "-%%d-g%%s" %% (pieces["distance"], pieces["short"])
857	    else:
858	        # exception #1
859	        rendered = pieces["short"]
860	    if pieces["dirty"]:
861	        rendered += "-dirty"
862	    return rendered
863	
864	
865	def render(pieces, style):
866	    """Render the given version pieces into the requested style."""
867	    if pieces["error"]:
868	        return {"version": "unknown",
869	                "full-revisionid": pieces.get("long"),
870	                "dirty": None,
871	                "error": pieces["error"],
872	                "date": None}
873	
874	    if not style or style == "default":
875	        style = "pep440"  # the default
876	
877	    if style == "pep440":
878	        rendered = render_pep440(pieces)
879	    elif style == "pep440-pre":
880	        rendered = render_pep440_pre(pieces)
881	    elif style == "pep440-post":
882	        rendered = render_pep440_post(pieces)
883	    elif style == "pep440-old":
884	        rendered = render_pep440_old(pieces)
885	    elif style == "git-describe":
886	        rendered = render_git_describe(pieces)
887	    elif style == "git-describe-long":
888	        rendered = render_git_describe_long(pieces)
889	    else:
890	        raise ValueError("unknown style '%%s'" %% style)
891	
892	    return {"version": rendered, "full-revisionid": pieces["long"],
893	            "dirty": pieces["dirty"], "error": None,
894	            "date": pieces.get("date")}
895	
896	
897	def get_versions():
898	    """Get version information or return default if unable to do so."""
899	    # I am in _version.py, which lives at ROOT/VERSIONFILE_SOURCE. If we have
900	    # __file__, we can work backwards from there to the root. Some
901	    # py2exe/bbfreeze/non-CPython implementations don't do __file__, in which
902	    # case we can only use expanded keywords.
903	
904	    cfg = get_config()
905	    verbose = cfg.verbose
906	
907	    try:
908	        return git_versions_from_keywords(get_keywords(), cfg.tag_prefix,
909	                                          verbose)
910	    except NotThisMethod:
911	        pass
912	
913	    try:
914	        root = os.path.realpath(__file__)
915	        # versionfile_source is the relative path from the top of the source
916	        # tree (where the .git directory might live) to this file. Invert
917	        # this to find the root from __file__.
918	        for i in cfg.versionfile_source.split('/'):
919	            root = os.path.dirname(root)
920	    except NameError:
921	        return {"version": "0+unknown", "full-revisionid": None,
922	                "dirty": None,
923	                "error": "unable to find root of source tree",
924	                "date": None}
925	
926	    try:
927	        pieces = git_pieces_from_vcs(cfg.tag_prefix, root, verbose)
928	        return render(pieces, cfg.style)
929	    except NotThisMethod:
930	        pass
931	
932	    try:
933	        if cfg.parentdir_prefix:
934	            return versions_from_parentdir(cfg.parentdir_prefix, root, verbose)
935	    except NotThisMethod:
936	        pass
937	
938	    return {"version": "0+unknown", "full-revisionid": None,
939	            "dirty": None,
940	            "error": "unable to compute version", "date": None}
941	'''
942	
943	
944	@register_vcs_handler("git", "get_keywords")
945	def git_get_keywords(versionfile_abs):

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/matchpy-0.5.5/matchpy-0.5.5/versioneer.py:1152
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1151	        f = open(".gitattributes", "a+")
1152	        f.write("%s export-subst\n" % versionfile_source)
1153	        f.close()

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/matchpy-0.5.5/matchpy-0.5.5/versioneer.py:1205
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
1204	        with open(filename) as f:
1205	            contents = f.read()
1206	    except EnvironmentError:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/matchpy-0.5.5/matchpy-0.5.5/versioneer.py:1224
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1223	    with open(filename, "w") as f:
1224	        f.write(SHORT_VERSION_PY % contents)
1225	

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/matchpy-0.5.5/matchpy-0.5.5/versioneer.py:1584
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1583	                    LONG = LONG_VERSION_PY[cfg.VCS]
1584	                    f.write(LONG %
1585	                            {"DOLLAR": "$",
1586	                             "STYLE": cfg.style,
1587	                             "TAG_PREFIX": cfg.tag_prefix,
1588	                             "PARENTDIR_PREFIX": cfg.parentdir_prefix,
1589	                             "VERSIONFILE_SOURCE": cfg.versionfile_source,
1590	                             })

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/matchpy-0.5.5/matchpy-0.5.5/versioneer.py:1613
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1612	                    LONG = LONG_VERSION_PY[cfg.VCS]
1613	                    f.write(LONG %
1614	                            {"DOLLAR": "$",
1615	                             "STYLE": cfg.style,
1616	                             "TAG_PREFIX": cfg.tag_prefix,
1617	                             "PARENTDIR_PREFIX": cfg.parentdir_prefix,
1618	                             "VERSIONFILE_SOURCE": cfg.versionfile_source,
1619	                             })

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/matchpy-0.5.5/matchpy-0.5.5/versioneer.py:1708
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1707	            with open(os.path.join(root, "setup.cfg"), "a") as f:
1708	                f.write(SAMPLE_CONFIG)
1709	        print(CONFIG_ERROR, file=sys.stderr)

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/matchpy-0.5.5/matchpy-0.5.5/versioneer.py:1715
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1714	        LONG = LONG_VERSION_PY[cfg.VCS]
1715	        f.write(LONG % {"DOLLAR": "$",
1716	                        "STYLE": cfg.style,
1717	                        "TAG_PREFIX": cfg.tag_prefix,
1718	                        "PARENTDIR_PREFIX": cfg.parentdir_prefix,
1719	                        "VERSIONFILE_SOURCE": cfg.versionfile_source,
1720	                        })

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/matchpy-0.5.5/matchpy-0.5.5/versioneer.py:1727
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
1726	            with open(ipy, "r") as f:
1727	                old = f.read()
1728	        except EnvironmentError:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/matchpy-0.5.5/matchpy-0.5.5/versioneer.py:1733
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1732	            with open(ipy, "a") as f:
1733	                f.write(INIT_PY_SNIPPET)
1734	        else:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/matchpy-0.5.5/matchpy-0.5.5/versioneer.py:1761
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1760	        with open(manifest_in, "a") as f:
1761	            f.write("include versioneer.py\n")
1762	    else:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/matchpy-0.5.5/matchpy-0.5.5/versioneer.py:1768
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1767	        with open(manifest_in, "a") as f:
1768	            f.write("include %s\n" % cfg.versionfile_source)
1769	    else:

--------------------------------------------------

Code scanned:
	Total lines of code: 6528
	Total lines skipped (#nosec): 0

Run metrics:
	Total issues (by severity):
		Undefined: 0.0
		Low: 0.0
		Medium: 1.0
		High: 11.0
	Total issues (by confidence):
		Undefined: 0.0
		Low: 0.0
		Medium: 12.0
		High: 0.0
Files skipped (0):
