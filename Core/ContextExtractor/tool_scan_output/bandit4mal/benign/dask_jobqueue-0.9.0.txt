Run started:2025-04-12 13:20:02.365553

Test results:
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/dask_jobqueue/core.py:382
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
381	            raise ValueError(
382	                "The class {} is required to have a 'config_name' class variable.\n"
383	                "If you have created this class, please add a 'config_name' class variable.\n"

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/dask_jobqueue/core.py:405
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
404	                logger.debug("writing job script: \n%s", self.job_script())
405	                f.write(self.job_script())
406	            yield fn

--------------------------------------------------
>> Issue: [B832:write] tempfile_NamedTemporaryFile_write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/dask_jobqueue/core.py:405
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b832_write.html
404	                logger.debug("writing job script: \n%s", self.job_script())
405	                f.write(self.job_script())
406	            yield fn

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/dask_jobqueue/core.py:788
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
787	                setattr(self, "_job_" + key, f)
788	                f.write(value)
789	                f.flush()

--------------------------------------------------
>> Issue: [B832:write] tempfile_NamedTemporaryFile_write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/dask_jobqueue/core.py:788
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b832_write.html
787	                setattr(self, "_job_" + key, f)
788	                f.write(value)
789	                f.flush()

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/dask_jobqueue/local.py:55
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
54	        with open(script_filename) as f:
55	            text = f.read().strip().split()
56	        self.process = Subprocess(

--------------------------------------------------
>> Issue: [B828:signal] signal.signal
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/dask_jobqueue/runner.py:18
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b828_signal.html
17	# Close gracefully when receiving a SIGINT
18	signal.signal(signal.SIGINT, lambda *_: sys.exit())
19	

--------------------------------------------------
>> Issue: [B324:blacklist] signal_signal
   Severity: Medium   Confidence: High
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/dask_jobqueue/runner.py:18
   More Info: https://bandit.readthedocs.io/en/latest/blacklists/blacklist_calls.html#b324-signal-signal
17	# Close gracefully when receiving a SIGINT
18	signal.signal(signal.SIGINT, lambda *_: sys.exit())
19	

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/dask_jobqueue/tests/test_jobqueue_core.py:77
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
76	    with Cluster(cores=1, memory="1GB") as cluster:
77	        assert re.match(r"http://\d+\.\d+\.\d+.\d+:\d+/status", cluster.dashboard_link)
78	

--------------------------------------------------
>> Issue: [B823:ip_found] ip_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/dask_jobqueue/tests/test_jobqueue_core.py:81
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b823_ip_found.html
80	def test_forward_ip(Cluster):
81	    ip = "127.0.0.1"
82	    with Cluster(

--------------------------------------------------
>> Issue: [B836:rmtree] shutil.rmtree
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/dask_jobqueue/tests/test_jobqueue_core.py:167
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b836_rmtree.html
166	def test_log_directory(Cluster, tmpdir):
167	    shutil.rmtree(tmpdir.strpath, ignore_errors=True)
168	    with Cluster(cores=1, memory="1GB"):

--------------------------------------------------
>> Issue: [B304:blacklist] socket.socket
   Severity: Medium   Confidence: High
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/dask_jobqueue/tests/test_jobqueue_core.py:241
   More Info: https://bandit.readthedocs.io/en/latest/blacklists/blacklist_calls.html#b304-b305-ciphers-and-modes
240	    interface = list(net_if_addrs.keys())[index]
241	    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
242	        s.bind((net_if_addrs[interface][0].address, 0))

--------------------------------------------------
>> Issue: [B807:close] socket.socket.close
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/dask_jobqueue/tests/test_jobqueue_core.py:245
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b807_close.html
244	        port = s.getsockname()[1]
245	        s.close()
246	    return (interface, port)

--------------------------------------------------
>> Issue: [B803:gethostname] socket.gethostname
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/dask_jobqueue/tests/test_jobqueue_core.py:265
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b803_gethostname.html
264	    worker_interface = "worker-interface"
265	    scheduler_host = socket.gethostname()
266	

--------------------------------------------------
>> Issue: [B302:blacklist] socket.gethostname
   Severity: Medium   Confidence: High
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/dask_jobqueue/tests/test_jobqueue_core.py:265
   More Info: https://bandit.readthedocs.io/en/latest/blacklists/blacklist_calls.html#b302-socket-gethostname
264	    worker_interface = "worker-interface"
265	    scheduler_host = socket.gethostname()
266	

--------------------------------------------------
>> Issue: [B803:gethostname] socket.gethostname
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/dask_jobqueue/tests/test_jobqueue_core.py:297
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b803_gethostname.html
296	def test_cluster_error_scheduler_arguments_should_use_scheduler_options(Cluster):
297	    scheduler_host = socket.gethostname()
298	    message_template = "pass {!r} through 'scheduler_options'"

--------------------------------------------------
>> Issue: [B302:blacklist] socket.gethostname
   Severity: Medium   Confidence: High
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/dask_jobqueue/tests/test_jobqueue_core.py:297
   More Info: https://bandit.readthedocs.io/en/latest/blacklists/blacklist_calls.html#b302-socket-gethostname
296	def test_cluster_error_scheduler_arguments_should_use_scheduler_options(Cluster):
297	    scheduler_host = socket.gethostname()
298	    message_template = "pass {!r} through 'scheduler_options'"

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/dask_jobqueue/tests/test_lsf.py:348
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
347	        with open(os.path.join(temp_dir, "lsf.conf"), "w") as conf_file:
348	            conf_file.write(conf_text)
349	    memory_string = "13GB"

--------------------------------------------------
>> Issue: [B832:write] tempfile_NamedTemporaryFile_write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/dask_jobqueue/tests/test_lsf.py:348
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b832_write.html
347	        with open(os.path.join(temp_dir, "lsf.conf"), "w") as conf_file:
348	            conf_file.write(conf_text)
349	    memory_string = "13GB"

--------------------------------------------------
>> Issue: [B836:rmtree] shutil.rmtree
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/dask_jobqueue/tests/test_lsf.py:354
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b836_rmtree.html
353	        assert "#BSUB -M %s" % correct_memory in cluster.job_header
354	    rmtree(temp_dir)
355	    if current_lsf_envdir is None:

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/setup.py:9
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
8	with open("requirements.txt") as f:
9	    install_requires = f.read().strip().split("\n")
10	

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/setup.py:21
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
20	    with open("README.rst") as f:
21	        long_description = f.read()
22	else:

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/setup.py:30
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
29	    description="Deploy Dask on job queuing systems like PBS, Slurm, SGE or LSF",
30	    url="https://jobqueue.dask.org",
31	    python_requires=">=3.10",

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/versioneer.py:519
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
518	    "git"
519	] = r'''
520	# This file helps to compute a version number in source trees obtained from
521	# git-archive tarball (such as those provided by githubs download-from-tag
522	# feature). Distribution tarballs (built by setup.py sdist) and build
523	# directories (produced by setup.py build) will contain a much shorter file
524	# that just contains the computed version number.
525	
526	# This file is released into the public domain.
527	# Generated by versioneer-0.29
528	# https://github.com/python-versioneer/python-versioneer
529	
530	"""Git implementation of _version.py."""
531	
532	import errno
533	import os
534	import re
535	import subprocess
536	import sys
537	from typing import Any, Callable, Dict, List, Optional, Tuple
538	import functools
539	
540	
541	def get_keywords() -> Dict[str, str]:
542	    """Get the keywords needed to look up the version information."""
543	    # these strings will be replaced by git during git-archive.
544	    # setup.py/versioneer.py will grep for the variable names, so they must
545	    # each be defined on a line of their own. _version.py will just call
546	    # get_keywords().
547	    git_refnames = "%(DOLLAR)sFormat:%%d%(DOLLAR)s"
548	    git_full = "%(DOLLAR)sFormat:%%H%(DOLLAR)s"
549	    git_date = "%(DOLLAR)sFormat:%%ci%(DOLLAR)s"
550	    keywords = {"refnames": git_refnames, "full": git_full, "date": git_date}
551	    return keywords
552	
553	
554	class VersioneerConfig:
555	    """Container for Versioneer configuration parameters."""
556	
557	    VCS: str
558	    style: str
559	    tag_prefix: str
560	    parentdir_prefix: str
561	    versionfile_source: str
562	    verbose: bool
563	
564	
565	def get_config() -> VersioneerConfig:
566	    """Create, populate and return the VersioneerConfig() object."""
567	    # these strings are filled in when 'setup.py versioneer' creates
568	    # _version.py
569	    cfg = VersioneerConfig()
570	    cfg.VCS = "git"
571	    cfg.style = "%(STYLE)s"
572	    cfg.tag_prefix = "%(TAG_PREFIX)s"
573	    cfg.parentdir_prefix = "%(PARENTDIR_PREFIX)s"
574	    cfg.versionfile_source = "%(VERSIONFILE_SOURCE)s"
575	    cfg.verbose = False
576	    return cfg
577	
578	
579	class NotThisMethod(Exception):
580	    """Exception raised if a method is not valid for the current scenario."""
581	
582	
583	LONG_VERSION_PY: Dict[str, str] = {}
584	HANDLERS: Dict[str, Dict[str, Callable]] = {}
585	
586	
587	def register_vcs_handler(vcs: str, method: str) -> Callable:  # decorator
588	    """Create decorator to mark a method as the handler of a VCS."""
589	    def decorate(f: Callable) -> Callable:
590	        """Store f in HANDLERS[vcs][method]."""
591	        if vcs not in HANDLERS:
592	            HANDLERS[vcs] = {}
593	        HANDLERS[vcs][method] = f
594	        return f
595	    return decorate
596	
597	
598	def run_command(
599	    commands: List[str],
600	    args: List[str],
601	    cwd: Optional[str] = None,
602	    verbose: bool = False,
603	    hide_stderr: bool = False,
604	    env: Optional[Dict[str, str]] = None,
605	) -> Tuple[Optional[str], Optional[int]]:
606	    """Call the given command(s)."""
607	    assert isinstance(commands, list)
608	    process = None
609	
610	    popen_kwargs: Dict[str, Any] = {}
611	    if sys.platform == "win32":
612	        # This hides the console window if pythonw.exe is used
613	        startupinfo = subprocess.STARTUPINFO()
614	        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
615	        popen_kwargs["startupinfo"] = startupinfo
616	
617	    for command in commands:
618	        try:
619	            dispcmd = str([command] + args)
620	            # remember shell=False, so use git.cmd on windows, not just git
621	            process = subprocess.Popen([command] + args, cwd=cwd, env=env,
622	                                       stdout=subprocess.PIPE,
623	                                       stderr=(subprocess.PIPE if hide_stderr
624	                                               else None), **popen_kwargs)
625	            break
626	        except OSError as e:
627	            if e.errno == errno.ENOENT:
628	                continue
629	            if verbose:
630	                print("unable to run %%s" %% dispcmd)
631	                print(e)
632	            return None, None
633	    else:
634	        if verbose:
635	            print("unable to find command, tried %%s" %% (commands,))
636	        return None, None
637	    stdout = process.communicate()[0].strip().decode()
638	    if process.returncode != 0:
639	        if verbose:
640	            print("unable to run %%s (error)" %% dispcmd)
641	            print("stdout was %%s" %% stdout)
642	        return None, process.returncode
643	    return stdout, process.returncode
644	
645	
646	def versions_from_parentdir(
647	    parentdir_prefix: str,
648	    root: str,
649	    verbose: bool,
650	) -> Dict[str, Any]:
651	    """Try to determine the version from the parent directory name.
652	
653	    Source tarballs conventionally unpack into a directory that includes both
654	    the project name and a version string. We will also support searching up
655	    two directory levels for an appropriately named parent directory
656	    """
657	    rootdirs = []
658	
659	    for _ in range(3):
660	        dirname = os.path.basename(root)
661	        if dirname.startswith(parentdir_prefix):
662	            return {"version": dirname[len(parentdir_prefix):],
663	                    "full-revisionid": None,
664	                    "dirty": False, "error": None, "date": None}
665	        rootdirs.append(root)
666	        root = os.path.dirname(root)  # up a level
667	
668	    if verbose:
669	        print("Tried directories %%s but none started with prefix %%s" %%
670	              (str(rootdirs), parentdir_prefix))
671	    raise NotThisMethod("rootdir doesn't start with parentdir_prefix")
672	
673	
674	@register_vcs_handler("git", "get_keywords")
675	def git_get_keywords(versionfile_abs: str) -> Dict[str, str]:
676	    """Extract version information from the given file."""
677	    # the code embedded in _version.py can just fetch the value of these
678	    # keywords. When used from setup.py, we don't want to import _version.py,
679	    # so we do it with a regexp instead. This function is not used from
680	    # _version.py.
681	    keywords: Dict[str, str] = {}
682	    try:
683	        with open(versionfile_abs, "r") as fobj:
684	            for line in fobj:
685	                if line.strip().startswith("git_refnames ="):
686	                    mo = re.search(r'=\s*"(.*)"', line)
687	                    if mo:
688	                        keywords["refnames"] = mo.group(1)
689	                if line.strip().startswith("git_full ="):
690	                    mo = re.search(r'=\s*"(.*)"', line)
691	                    if mo:
692	                        keywords["full"] = mo.group(1)
693	                if line.strip().startswith("git_date ="):
694	                    mo = re.search(r'=\s*"(.*)"', line)
695	                    if mo:
696	                        keywords["date"] = mo.group(1)
697	    except OSError:
698	        pass
699	    return keywords
700	
701	
702	@register_vcs_handler("git", "keywords")
703	def git_versions_from_keywords(
704	    keywords: Dict[str, str],
705	    tag_prefix: str,
706	    verbose: bool,
707	) -> Dict[str, Any]:
708	    """Get version information from git keywords."""
709	    if "refnames" not in keywords:
710	        raise NotThisMethod("Short version file found")
711	    date = keywords.get("date")
712	    if date is not None:
713	        # Use only the last line.  Previous lines may contain GPG signature
714	        # information.
715	        date = date.splitlines()[-1]
716	
717	        # git-2.2.0 added "%%cI", which expands to an ISO-8601 -compliant
718	        # datestamp. However we prefer "%%ci" (which expands to an "ISO-8601
719	        # -like" string, which we must then edit to make compliant), because
720	        # it's been around since git-1.5.3, and it's too difficult to
721	        # discover which version we're using, or to work around using an
722	        # older one.
723	        date = date.strip().replace(" ", "T", 1).replace(" ", "", 1)
724	    refnames = keywords["refnames"].strip()
725	    if refnames.startswith("$Format"):
726	        if verbose:
727	            print("keywords are unexpanded, not using")
728	        raise NotThisMethod("unexpanded keywords, not a git-archive tarball")
729	    refs = {r.strip() for r in refnames.strip("()").split(",")}
730	    # starting in git-1.8.3, tags are listed as "tag: foo-1.0" instead of
731	    # just "foo-1.0". If we see a "tag: " prefix, prefer those.
732	    TAG = "tag: "
733	    tags = {r[len(TAG):] for r in refs if r.startswith(TAG)}
734	    if not tags:
735	        # Either we're using git < 1.8.3, or there really are no tags. We use
736	        # a heuristic: assume all version tags have a digit. The old git %%d
737	        # expansion behaves like git log --decorate=short and strips out the
738	        # refs/heads/ and refs/tags/ prefixes that would let us distinguish
739	        # between branches and tags. By ignoring refnames without digits, we
740	        # filter out many common branch names like "release" and
741	        # "stabilization", as well as "HEAD" and "master".
742	        tags = {r for r in refs if re.search(r'\d', r)}
743	        if verbose:
744	            print("discarding '%%s', no digits" %% ",".join(refs - tags))
745	    if verbose:
746	        print("likely tags: %%s" %% ",".join(sorted(tags)))
747	    for ref in sorted(tags):
748	        # sorting will prefer e.g. "2.0" over "2.0rc1"
749	        if ref.startswith(tag_prefix):
750	            r = ref[len(tag_prefix):]
751	            # Filter out refs that exactly match prefix or that don't start
752	            # with a number once the prefix is stripped (mostly a concern
753	            # when prefix is '')
754	            if not re.match(r'\d', r):
755	                continue
756	            if verbose:
757	                print("picking %%s" %% r)
758	            return {"version": r,
759	                    "full-revisionid": keywords["full"].strip(),
760	                    "dirty": False, "error": None,
761	                    "date": date}
762	    # no suitable tags, so version is "0+unknown", but full hex is still there
763	    if verbose:
764	        print("no suitable tags, using unknown + full revision id")
765	    return {"version": "0+unknown",
766	            "full-revisionid": keywords["full"].strip(),
767	            "dirty": False, "error": "no suitable tags", "date": None}
768	
769	
770	@register_vcs_handler("git", "pieces_from_vcs")
771	def git_pieces_from_vcs(
772	    tag_prefix: str,
773	    root: str,
774	    verbose: bool,
775	    runner: Callable = run_command
776	) -> Dict[str, Any]:
777	    """Get version from 'git describe' in the root of the source tree.
778	
779	    This only gets called if the git-archive 'subst' keywords were *not*
780	    expanded, and _version.py hasn't already been rewritten with a short
781	    version string, meaning we're inside a checked out source tree.
782	    """
783	    GITS = ["git"]
784	    if sys.platform == "win32":
785	        GITS = ["git.cmd", "git.exe"]
786	
787	    # GIT_DIR can interfere with correct operation of Versioneer.
788	    # It may be intended to be passed to the Versioneer-versioned project,
789	    # but that should not change where we get our version from.
790	    env = os.environ.copy()
791	    env.pop("GIT_DIR", None)
792	    runner = functools.partial(runner, env=env)
793	
794	    _, rc = runner(GITS, ["rev-parse", "--git-dir"], cwd=root,
795	                   hide_stderr=not verbose)
796	    if rc != 0:
797	        if verbose:
798	            print("Directory %%s not under git control" %% root)
799	        raise NotThisMethod("'git rev-parse --git-dir' returned error")
800	
801	    # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]
802	    # if there isn't one, this yields HEX[-dirty] (no NUM)
803	    describe_out, rc = runner(GITS, [
804	        "describe", "--tags", "--dirty", "--always", "--long",
805	        "--match", f"{tag_prefix}[[:digit:]]*"
806	    ], cwd=root)
807	    # --long was added in git-1.5.5
808	    if describe_out is None:
809	        raise NotThisMethod("'git describe' failed")
810	    describe_out = describe_out.strip()
811	    full_out, rc = runner(GITS, ["rev-parse", "HEAD"], cwd=root)
812	    if full_out is None:
813	        raise NotThisMethod("'git rev-parse' failed")
814	    full_out = full_out.strip()
815	
816	    pieces: Dict[str, Any] = {}
817	    pieces["long"] = full_out
818	    pieces["short"] = full_out[:7]  # maybe improved later
819	    pieces["error"] = None
820	
821	    branch_name, rc = runner(GITS, ["rev-parse", "--abbrev-ref", "HEAD"],
822	                             cwd=root)
823	    # --abbrev-ref was added in git-1.6.3
824	    if rc != 0 or branch_name is None:
825	        raise NotThisMethod("'git rev-parse --abbrev-ref' returned error")
826	    branch_name = branch_name.strip()
827	
828	    if branch_name == "HEAD":
829	        # If we aren't exactly on a branch, pick a branch which represents
830	        # the current commit. If all else fails, we are on a branchless
831	        # commit.
832	        branches, rc = runner(GITS, ["branch", "--contains"], cwd=root)
833	        # --contains was added in git-1.5.4
834	        if rc != 0 or branches is None:
835	            raise NotThisMethod("'git branch --contains' returned error")
836	        branches = branches.split("\n")
837	
838	        # Remove the first line if we're running detached
839	        if "(" in branches[0]:
840	            branches.pop(0)
841	
842	        # Strip off the leading "* " from the list of branches.
843	        branches = [branch[2:] for branch in branches]
844	        if "master" in branches:
845	            branch_name = "master"
846	        elif not branches:
847	            branch_name = None
848	        else:
849	            # Pick the first branch that is returned. Good or bad.
850	            branch_name = branches[0]
851	
852	    pieces["branch"] = branch_name
853	
854	    # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]
855	    # TAG might have hyphens.
856	    git_describe = describe_out
857	
858	    # look for -dirty suffix
859	    dirty = git_describe.endswith("-dirty")
860	    pieces["dirty"] = dirty
861	    if dirty:
862	        git_describe = git_describe[:git_describe.rindex("-dirty")]
863	
864	    # now we have TAG-NUM-gHEX or HEX
865	
866	    if "-" in git_describe:
867	        # TAG-NUM-gHEX
868	        mo = re.search(r'^(.+)-(\d+)-g([0-9a-f]+)$', git_describe)
869	        if not mo:
870	            # unparsable. Maybe git-describe is misbehaving?
871	            pieces["error"] = ("unable to parse git-describe output: '%%s'"
872	                               %% describe_out)
873	            return pieces
874	
875	        # tag
876	        full_tag = mo.group(1)
877	        if not full_tag.startswith(tag_prefix):
878	            if verbose:
879	                fmt = "tag '%%s' doesn't start with prefix '%%s'"
880	                print(fmt %% (full_tag, tag_prefix))
881	            pieces["error"] = ("tag '%%s' doesn't start with prefix '%%s'"
882	                               %% (full_tag, tag_prefix))
883	            return pieces
884	        pieces["closest-tag"] = full_tag[len(tag_prefix):]
885	
886	        # distance: number of commits since tag
887	        pieces["distance"] = int(mo.group(2))
888	
889	        # commit: short hex revision ID
890	        pieces["short"] = mo.group(3)
891	
892	    else:
893	        # HEX: no tags
894	        pieces["closest-tag"] = None
895	        out, rc = runner(GITS, ["rev-list", "HEAD", "--left-right"], cwd=root)
896	        pieces["distance"] = len(out.split())  # total number of commits
897	
898	    # commit date: see ISO-8601 comment in git_versions_from_keywords()
899	    date = runner(GITS, ["show", "-s", "--format=%%ci", "HEAD"], cwd=root)[0].strip()
900	    # Use only the last line.  Previous lines may contain GPG signature
901	    # information.
902	    date = date.splitlines()[-1]
903	    pieces["date"] = date.strip().replace(" ", "T", 1).replace(" ", "", 1)
904	
905	    return pieces
906	
907	
908	def plus_or_dot(pieces: Dict[str, Any]) -> str:
909	    """Return a + if we don't already have one, else return a ."""
910	    if "+" in pieces.get("closest-tag", ""):
911	        return "."
912	    return "+"
913	
914	
915	def render_pep440(pieces: Dict[str, Any]) -> str:
916	    """Build up version string, with post-release "local version identifier".
917	
918	    Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you
919	    get a tagged build and then dirty it, you'll get TAG+0.gHEX.dirty
920	
921	    Exceptions:
922	    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]
923	    """
924	    if pieces["closest-tag"]:
925	        rendered = pieces["closest-tag"]
926	        if pieces["distance"] or pieces["dirty"]:
927	            rendered += plus_or_dot(pieces)
928	            rendered += "%%d.g%%s" %% (pieces["distance"], pieces["short"])
929	            if pieces["dirty"]:
930	                rendered += ".dirty"
931	    else:
932	        # exception #1
933	        rendered = "0+untagged.%%d.g%%s" %% (pieces["distance"],
934	                                          pieces["short"])
935	        if pieces["dirty"]:
936	            rendered += ".dirty"
937	    return rendered
938	
939	
940	def render_pep440_branch(pieces: Dict[str, Any]) -> str:
941	    """TAG[[.dev0]+DISTANCE.gHEX[.dirty]] .
942	
943	    The ".dev0" means not master branch. Note that .dev0 sorts backwards
944	    (a feature branch will appear "older" than the master branch).
945	
946	    Exceptions:
947	    1: no tags. 0[.dev0]+untagged.DISTANCE.gHEX[.dirty]
948	    """
949	    if pieces["closest-tag"]:
950	        rendered = pieces["closest-tag"]
951	        if pieces["distance"] or pieces["dirty"]:
952	            if pieces["branch"] != "master":
953	                rendered += ".dev0"
954	            rendered += plus_or_dot(pieces)
955	            rendered += "%%d.g%%s" %% (pieces["distance"], pieces["short"])
956	            if pieces["dirty"]:
957	                rendered += ".dirty"
958	    else:
959	        # exception #1
960	        rendered = "0"
961	        if pieces["branch"] != "master":
962	            rendered += ".dev0"
963	        rendered += "+untagged.%%d.g%%s" %% (pieces["distance"],
964	                                          pieces["short"])
965	        if pieces["dirty"]:
966	            rendered += ".dirty"
967	    return rendered
968	
969	
970	def pep440_split_post(ver: str) -> Tuple[str, Optional[int]]:
971	    """Split pep440 version string at the post-release segment.
972	
973	    Returns the release segments before the post-release and the
974	    post-release version number (or -1 if no post-release segment is present).
975	    """
976	    vc = str.split(ver, ".post")
977	    return vc[0], int(vc[1] or 0) if len(vc) == 2 else None
978	
979	
980	def render_pep440_pre(pieces: Dict[str, Any]) -> str:
981	    """TAG[.postN.devDISTANCE] -- No -dirty.
982	
983	    Exceptions:
984	    1: no tags. 0.post0.devDISTANCE
985	    """
986	    if pieces["closest-tag"]:
987	        if pieces["distance"]:
988	            # update the post release segment
989	            tag_version, post_version = pep440_split_post(pieces["closest-tag"])
990	            rendered = tag_version
991	            if post_version is not None:
992	                rendered += ".post%%d.dev%%d" %% (post_version + 1, pieces["distance"])
993	            else:
994	                rendered += ".post0.dev%%d" %% (pieces["distance"])
995	        else:
996	            # no commits, use the tag as the version
997	            rendered = pieces["closest-tag"]
998	    else:
999	        # exception #1
1000	        rendered = "0.post0.dev%%d" %% pieces["distance"]
1001	    return rendered
1002	
1003	
1004	def render_pep440_post(pieces: Dict[str, Any]) -> str:
1005	    """TAG[.postDISTANCE[.dev0]+gHEX] .
1006	
1007	    The ".dev0" means dirty. Note that .dev0 sorts backwards
1008	    (a dirty tree will appear "older" than the corresponding clean one),
1009	    but you shouldn't be releasing software with -dirty anyways.
1010	
1011	    Exceptions:
1012	    1: no tags. 0.postDISTANCE[.dev0]
1013	    """
1014	    if pieces["closest-tag"]:
1015	        rendered = pieces["closest-tag"]
1016	        if pieces["distance"] or pieces["dirty"]:
1017	            rendered += ".post%%d" %% pieces["distance"]
1018	            if pieces["dirty"]:
1019	                rendered += ".dev0"
1020	            rendered += plus_or_dot(pieces)
1021	            rendered += "g%%s" %% pieces["short"]
1022	    else:
1023	        # exception #1
1024	        rendered = "0.post%%d" %% pieces["distance"]
1025	        if pieces["dirty"]:
1026	            rendered += ".dev0"
1027	        rendered += "+g%%s" %% pieces["short"]
1028	    return rendered
1029	
1030	
1031	def render_pep440_post_branch(pieces: Dict[str, Any]) -> str:
1032	    """TAG[.postDISTANCE[.dev0]+gHEX[.dirty]] .
1033	
1034	    The ".dev0" means not master branch.
1035	
1036	    Exceptions:
1037	    1: no tags. 0.postDISTANCE[.dev0]+gHEX[.dirty]
1038	    """
1039	    if pieces["closest-tag"]:
1040	        rendered = pieces["closest-tag"]
1041	        if pieces["distance"] or pieces["dirty"]:
1042	            rendered += ".post%%d" %% pieces["distance"]
1043	            if pieces["branch"] != "master":
1044	                rendered += ".dev0"
1045	            rendered += plus_or_dot(pieces)
1046	            rendered += "g%%s" %% pieces["short"]
1047	            if pieces["dirty"]:
1048	                rendered += ".dirty"
1049	    else:
1050	        # exception #1
1051	        rendered = "0.post%%d" %% pieces["distance"]
1052	        if pieces["branch"] != "master":
1053	            rendered += ".dev0"
1054	        rendered += "+g%%s" %% pieces["short"]
1055	        if pieces["dirty"]:
1056	            rendered += ".dirty"
1057	    return rendered
1058	
1059	
1060	def render_pep440_old(pieces: Dict[str, Any]) -> str:
1061	    """TAG[.postDISTANCE[.dev0]] .
1062	
1063	    The ".dev0" means dirty.
1064	
1065	    Exceptions:
1066	    1: no tags. 0.postDISTANCE[.dev0]
1067	    """
1068	    if pieces["closest-tag"]:
1069	        rendered = pieces["closest-tag"]
1070	        if pieces["distance"] or pieces["dirty"]:
1071	            rendered += ".post%%d" %% pieces["distance"]
1072	            if pieces["dirty"]:
1073	                rendered += ".dev0"
1074	    else:
1075	        # exception #1
1076	        rendered = "0.post%%d" %% pieces["distance"]
1077	        if pieces["dirty"]:
1078	            rendered += ".dev0"
1079	    return rendered
1080	
1081	
1082	def render_git_describe(pieces: Dict[str, Any]) -> str:
1083	    """TAG[-DISTANCE-gHEX][-dirty].
1084	
1085	    Like 'git describe --tags --dirty --always'.
1086	
1087	    Exceptions:
1088	    1: no tags. HEX[-dirty]  (note: no 'g' prefix)
1089	    """
1090	    if pieces["closest-tag"]:
1091	        rendered = pieces["closest-tag"]
1092	        if pieces["distance"]:
1093	            rendered += "-%%d-g%%s" %% (pieces["distance"], pieces["short"])
1094	    else:
1095	        # exception #1
1096	        rendered = pieces["short"]
1097	    if pieces["dirty"]:
1098	        rendered += "-dirty"
1099	    return rendered
1100	
1101	
1102	def render_git_describe_long(pieces: Dict[str, Any]) -> str:
1103	    """TAG-DISTANCE-gHEX[-dirty].
1104	
1105	    Like 'git describe --tags --dirty --always -long'.
1106	    The distance/hash is unconditional.
1107	
1108	    Exceptions:
1109	    1: no tags. HEX[-dirty]  (note: no 'g' prefix)
1110	    """
1111	    if pieces["closest-tag"]:
1112	        rendered = pieces["closest-tag"]
1113	        rendered += "-%%d-g%%s" %% (pieces["distance"], pieces["short"])
1114	    else:
1115	        # exception #1
1116	        rendered = pieces["short"]
1117	    if pieces["dirty"]:
1118	        rendered += "-dirty"
1119	    return rendered
1120	
1121	
1122	def render(pieces: Dict[str, Any], style: str) -> Dict[str, Any]:
1123	    """Render the given version pieces into the requested style."""
1124	    if pieces["error"]:
1125	        return {"version": "unknown",
1126	                "full-revisionid": pieces.get("long"),
1127	                "dirty": None,
1128	                "error": pieces["error"],
1129	                "date": None}
1130	
1131	    if not style or style == "default":
1132	        style = "pep440"  # the default
1133	
1134	    if style == "pep440":
1135	        rendered = render_pep440(pieces)
1136	    elif style == "pep440-branch":
1137	        rendered = render_pep440_branch(pieces)
1138	    elif style == "pep440-pre":
1139	        rendered = render_pep440_pre(pieces)
1140	    elif style == "pep440-post":
1141	        rendered = render_pep440_post(pieces)
1142	    elif style == "pep440-post-branch":
1143	        rendered = render_pep440_post_branch(pieces)
1144	    elif style == "pep440-old":
1145	        rendered = render_pep440_old(pieces)
1146	    elif style == "git-describe":
1147	        rendered = render_git_describe(pieces)
1148	    elif style == "git-describe-long":
1149	        rendered = render_git_describe_long(pieces)
1150	    else:
1151	        raise ValueError("unknown style '%%s'" %% style)
1152	
1153	    return {"version": rendered, "full-revisionid": pieces["long"],
1154	            "dirty": pieces["dirty"], "error": None,
1155	            "date": pieces.get("date")}
1156	
1157	
1158	def get_versions() -> Dict[str, Any]:
1159	    """Get version information or return default if unable to do so."""
1160	    # I am in _version.py, which lives at ROOT/VERSIONFILE_SOURCE. If we have
1161	    # __file__, we can work backwards from there to the root. Some
1162	    # py2exe/bbfreeze/non-CPython implementations don't do __file__, in which
1163	    # case we can only use expanded keywords.
1164	
1165	    cfg = get_config()
1166	    verbose = cfg.verbose
1167	
1168	    try:
1169	        return git_versions_from_keywords(get_keywords(), cfg.tag_prefix,
1170	                                          verbose)
1171	    except NotThisMethod:
1172	        pass
1173	
1174	    try:
1175	        root = os.path.realpath(__file__)
1176	        # versionfile_source is the relative path from the top of the source
1177	        # tree (where the .git directory might live) to this file. Invert
1178	        # this to find the root from __file__.
1179	        for _ in cfg.versionfile_source.split('/'):
1180	            root = os.path.dirname(root)
1181	    except NameError:
1182	        return {"version": "0+unknown", "full-revisionid": None,
1183	                "dirty": None,
1184	                "error": "unable to find root of source tree",
1185	                "date": None}
1186	
1187	    try:
1188	        pieces = git_pieces_from_vcs(cfg.tag_prefix, root, verbose)
1189	        return render(pieces, cfg.style)
1190	    except NotThisMethod:
1191	        pass
1192	
1193	    try:
1194	        if cfg.parentdir_prefix:
1195	            return versions_from_parentdir(cfg.parentdir_prefix, root, verbose)
1196	    except NotThisMethod:
1197	        pass
1198	
1199	    return {"version": "0+unknown", "full-revisionid": None,
1200	            "dirty": None,
1201	            "error": "unable to compute version", "date": None}
1202	'''
1203	
1204	
1205	@register_vcs_handler("git", "get_keywords")
1206	def git_get_keywords(versionfile_abs: str) -> Dict[str, str]:
1207	    """Extract version information from the given file."""
1208	    # the code embedded in _version.py can just fetch the value of these

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/versioneer.py:1484
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1483	        with open(".gitattributes", "a+") as fobj:
1484	            fobj.write(f"{versionfile_source} export-subst\n")
1485	        files.append(".gitattributes")

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/versioneer.py:1545
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
1544	        with open(filename) as f:
1545	            contents = f.read()
1546	    except OSError:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/versioneer.py:1564
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1563	    with open(filename, "w") as f:
1564	        f.write(SHORT_VERSION_PY % contents)
1565	

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/versioneer.py:2061
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2060	                    LONG = LONG_VERSION_PY[cfg.VCS]
2061	                    f.write(
2062	                        LONG
2063	                        % {
2064	                            "DOLLAR": "$",
2065	                            "STYLE": cfg.style,
2066	                            "TAG_PREFIX": cfg.tag_prefix,
2067	                            "PARENTDIR_PREFIX": cfg.parentdir_prefix,
2068	                            "VERSIONFILE_SOURCE": cfg.versionfile_source,
2069	                        }

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/versioneer.py:2094
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2093	                    LONG = LONG_VERSION_PY[cfg.VCS]
2094	                    f.write(
2095	                        LONG
2096	                        % {
2097	                            "DOLLAR": "$",
2098	                            "STYLE": cfg.style,
2099	                            "TAG_PREFIX": cfg.tag_prefix,
2100	                            "PARENTDIR_PREFIX": cfg.parentdir_prefix,
2101	                            "VERSIONFILE_SOURCE": cfg.versionfile_source,
2102	                        }

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/versioneer.py:2143
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2142	            with open(manifest_filename, "w") as fobj:
2143	                fobj.write("\n".join(normalized))
2144	

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/versioneer.py:2238
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2237	            with open(os.path.join(root, "setup.cfg"), "a") as f:
2238	                f.write(SAMPLE_CONFIG)
2239	        print(CONFIG_ERROR, file=sys.stderr)

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/versioneer.py:2245
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2244	        LONG = LONG_VERSION_PY[cfg.VCS]
2245	        f.write(
2246	            LONG
2247	            % {
2248	                "DOLLAR": "$",
2249	                "STYLE": cfg.style,
2250	                "TAG_PREFIX": cfg.tag_prefix,
2251	                "PARENTDIR_PREFIX": cfg.parentdir_prefix,
2252	                "VERSIONFILE_SOURCE": cfg.versionfile_source,
2253	            }

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/versioneer.py:2261
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
2260	            with open(ipy, "r") as f:
2261	                old = f.read()
2262	        except OSError:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/versioneer.py:2269
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2268	            with open(ipy, "w") as f:
2269	                f.write(old.replace(OLD_SNIPPET, snippet))
2270	        elif snippet not in old:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/dask_jobqueue-0.9.0/dask_jobqueue-0.9.0/versioneer.py:2273
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2272	            with open(ipy, "a") as f:
2273	                f.write(snippet)
2274	        else:

--------------------------------------------------

Code scanned:
	Total lines of code: 5911
	Total lines skipped (#nosec): 0

Run metrics:
	Total issues (by severity):
		Undefined: 0.0
		Low: 0.0
		Medium: 9.0
		High: 26.0
	Total issues (by confidence):
		Undefined: 0.0
		Low: 0.0
		Medium: 31.0
		High: 4.0
Files skipped (0):
