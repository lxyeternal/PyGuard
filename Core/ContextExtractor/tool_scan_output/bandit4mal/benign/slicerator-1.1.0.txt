Run started:2025-04-12 16:59:34.949779

Test results:
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/slicerator-1.1.0/slicerator-1.1.0/setup.py:6
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
5	try:
6	    descr = open(os.path.join(os.path.dirname(__file__), "README.md")).read()
7	except IOError:

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/slicerator-1.1.0/slicerator-1.1.0/setup.py:24
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
23	    description="A lazy-loading, fancy-sliceable iterable.",
24	    url="http://github.com/soft-matter/slicerator",
25	    cmdclass=versioneer.get_cmdclass(),

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/slicerator-1.1.0/slicerator-1.1.0/versioneer.py:343
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
342	    parser = configparser.ConfigParser()
343	    parser.read(setup_cfg)
344	    VCS = parser.get("versioneer", "VCS")  # mandatory

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/slicerator-1.1.0/slicerator-1.1.0/versioneer.py:420
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
419	
420	LONG_VERSION_PY['git'] = '''
421	# This file helps to compute a version number in source trees obtained from
422	# git-archive tarball (such as those provided by githubs download-from-tag
423	# feature). Distribution tarballs (built by setup.py sdist) and build
424	# directories (produced by setup.py build) will contain a much shorter file
425	# that just contains the computed version number.
426	
427	# This file is released into the public domain. Generated by
428	# versioneer-0.18 (https://github.com/warner/python-versioneer)
429	
430	"""Git implementation of _version.py."""
431	
432	import errno
433	import os
434	import re
435	import subprocess
436	import sys
437	
438	
439	def get_keywords():
440	    """Get the keywords needed to look up the version information."""
441	    # these strings will be replaced by git during git-archive.
442	    # setup.py/versioneer.py will grep for the variable names, so they must
443	    # each be defined on a line of their own. _version.py will just call
444	    # get_keywords().
445	    git_refnames = "%(DOLLAR)sFormat:%%d%(DOLLAR)s"
446	    git_full = "%(DOLLAR)sFormat:%%H%(DOLLAR)s"
447	    git_date = "%(DOLLAR)sFormat:%%ci%(DOLLAR)s"
448	    keywords = {"refnames": git_refnames, "full": git_full, "date": git_date}
449	    return keywords
450	
451	
452	class VersioneerConfig:
453	    """Container for Versioneer configuration parameters."""
454	
455	
456	def get_config():
457	    """Create, populate and return the VersioneerConfig() object."""
458	    # these strings are filled in when 'setup.py versioneer' creates
459	    # _version.py
460	    cfg = VersioneerConfig()
461	    cfg.VCS = "git"
462	    cfg.style = "%(STYLE)s"
463	    cfg.tag_prefix = "%(TAG_PREFIX)s"
464	    cfg.parentdir_prefix = "%(PARENTDIR_PREFIX)s"
465	    cfg.versionfile_source = "%(VERSIONFILE_SOURCE)s"
466	    cfg.verbose = False
467	    return cfg
468	
469	
470	class NotThisMethod(Exception):
471	    """Exception raised if a method is not valid for the current scenario."""
472	
473	
474	LONG_VERSION_PY = {}
475	HANDLERS = {}
476	
477	
478	def register_vcs_handler(vcs, method):  # decorator
479	    """Decorator to mark a method as the handler for a particular VCS."""
480	    def decorate(f):
481	        """Store f in HANDLERS[vcs][method]."""
482	        if vcs not in HANDLERS:
483	            HANDLERS[vcs] = {}
484	        HANDLERS[vcs][method] = f
485	        return f
486	    return decorate
487	
488	
489	def run_command(commands, args, cwd=None, verbose=False, hide_stderr=False,
490	                env=None):
491	    """Call the given command(s)."""
492	    assert isinstance(commands, list)
493	    p = None
494	    for c in commands:
495	        try:
496	            dispcmd = str([c] + args)
497	            # remember shell=False, so use git.cmd on windows, not just git
498	            p = subprocess.Popen([c] + args, cwd=cwd, env=env,
499	                                 stdout=subprocess.PIPE,
500	                                 stderr=(subprocess.PIPE if hide_stderr
501	                                         else None))
502	            break
503	        except EnvironmentError:
504	            e = sys.exc_info()[1]
505	            if e.errno == errno.ENOENT:
506	                continue
507	            if verbose:
508	                print("unable to run %%s" %% dispcmd)
509	                print(e)
510	            return None, None
511	    else:
512	        if verbose:
513	            print("unable to find command, tried %%s" %% (commands,))
514	        return None, None
515	    stdout = p.communicate()[0].strip()
516	    if sys.version_info[0] >= 3:
517	        stdout = stdout.decode()
518	    if p.returncode != 0:
519	        if verbose:
520	            print("unable to run %%s (error)" %% dispcmd)
521	            print("stdout was %%s" %% stdout)
522	        return None, p.returncode
523	    return stdout, p.returncode
524	
525	
526	def versions_from_parentdir(parentdir_prefix, root, verbose):
527	    """Try to determine the version from the parent directory name.
528	
529	    Source tarballs conventionally unpack into a directory that includes both
530	    the project name and a version string. We will also support searching up
531	    two directory levels for an appropriately named parent directory
532	    """
533	    rootdirs = []
534	
535	    for i in range(3):
536	        dirname = os.path.basename(root)
537	        if dirname.startswith(parentdir_prefix):
538	            return {"version": dirname[len(parentdir_prefix):],
539	                    "full-revisionid": None,
540	                    "dirty": False, "error": None, "date": None}
541	        else:
542	            rootdirs.append(root)
543	            root = os.path.dirname(root)  # up a level
544	
545	    if verbose:
546	        print("Tried directories %%s but none started with prefix %%s" %%
547	              (str(rootdirs), parentdir_prefix))
548	    raise NotThisMethod("rootdir doesn't start with parentdir_prefix")
549	
550	
551	@register_vcs_handler("git", "get_keywords")
552	def git_get_keywords(versionfile_abs):
553	    """Extract version information from the given file."""
554	    # the code embedded in _version.py can just fetch the value of these
555	    # keywords. When used from setup.py, we don't want to import _version.py,
556	    # so we do it with a regexp instead. This function is not used from
557	    # _version.py.
558	    keywords = {}
559	    try:
560	        f = open(versionfile_abs, "r")
561	        for line in f.readlines():
562	            if line.strip().startswith("git_refnames ="):
563	                mo = re.search(r'=\s*"(.*)"', line)
564	                if mo:
565	                    keywords["refnames"] = mo.group(1)
566	            if line.strip().startswith("git_full ="):
567	                mo = re.search(r'=\s*"(.*)"', line)
568	                if mo:
569	                    keywords["full"] = mo.group(1)
570	            if line.strip().startswith("git_date ="):
571	                mo = re.search(r'=\s*"(.*)"', line)
572	                if mo:
573	                    keywords["date"] = mo.group(1)
574	        f.close()
575	    except EnvironmentError:
576	        pass
577	    return keywords
578	
579	
580	@register_vcs_handler("git", "keywords")
581	def git_versions_from_keywords(keywords, tag_prefix, verbose):
582	    """Get version information from git keywords."""
583	    if not keywords:
584	        raise NotThisMethod("no keywords at all, weird")
585	    date = keywords.get("date")
586	    if date is not None:
587	        # git-2.2.0 added "%%cI", which expands to an ISO-8601 -compliant
588	        # datestamp. However we prefer "%%ci" (which expands to an "ISO-8601
589	        # -like" string, which we must then edit to make compliant), because
590	        # it's been around since git-1.5.3, and it's too difficult to
591	        # discover which version we're using, or to work around using an
592	        # older one.
593	        date = date.strip().replace(" ", "T", 1).replace(" ", "", 1)
594	    refnames = keywords["refnames"].strip()
595	    if refnames.startswith("$Format"):
596	        if verbose:
597	            print("keywords are unexpanded, not using")
598	        raise NotThisMethod("unexpanded keywords, not a git-archive tarball")
599	    refs = set([r.strip() for r in refnames.strip("()").split(",")])
600	    # starting in git-1.8.3, tags are listed as "tag: foo-1.0" instead of
601	    # just "foo-1.0". If we see a "tag: " prefix, prefer those.
602	    TAG = "tag: "
603	    tags = set([r[len(TAG):] for r in refs if r.startswith(TAG)])
604	    if not tags:
605	        # Either we're using git < 1.8.3, or there really are no tags. We use
606	        # a heuristic: assume all version tags have a digit. The old git %%d
607	        # expansion behaves like git log --decorate=short and strips out the
608	        # refs/heads/ and refs/tags/ prefixes that would let us distinguish
609	        # between branches and tags. By ignoring refnames without digits, we
610	        # filter out many common branch names like "release" and
611	        # "stabilization", as well as "HEAD" and "master".
612	        tags = set([r for r in refs if re.search(r'\d', r)])
613	        if verbose:
614	            print("discarding '%%s', no digits" %% ",".join(refs - tags))
615	    if verbose:
616	        print("likely tags: %%s" %% ",".join(sorted(tags)))
617	    for ref in sorted(tags):
618	        # sorting will prefer e.g. "2.0" over "2.0rc1"
619	        if ref.startswith(tag_prefix):
620	            r = ref[len(tag_prefix):]
621	            if verbose:
622	                print("picking %%s" %% r)
623	            return {"version": r,
624	                    "full-revisionid": keywords["full"].strip(),
625	                    "dirty": False, "error": None,
626	                    "date": date}
627	    # no suitable tags, so version is "0+unknown", but full hex is still there
628	    if verbose:
629	        print("no suitable tags, using unknown + full revision id")
630	    return {"version": "0+unknown",
631	            "full-revisionid": keywords["full"].strip(),
632	            "dirty": False, "error": "no suitable tags", "date": None}
633	
634	
635	@register_vcs_handler("git", "pieces_from_vcs")
636	def git_pieces_from_vcs(tag_prefix, root, verbose, run_command=run_command):
637	    """Get version from 'git describe' in the root of the source tree.
638	
639	    This only gets called if the git-archive 'subst' keywords were *not*
640	    expanded, and _version.py hasn't already been rewritten with a short
641	    version string, meaning we're inside a checked out source tree.
642	    """
643	    GITS = ["git"]
644	    if sys.platform == "win32":
645	        GITS = ["git.cmd", "git.exe"]
646	
647	    out, rc = run_command(GITS, ["rev-parse", "--git-dir"], cwd=root,
648	                          hide_stderr=True)
649	    if rc != 0:
650	        if verbose:
651	            print("Directory %%s not under git control" %% root)
652	        raise NotThisMethod("'git rev-parse --git-dir' returned error")
653	
654	    # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]
655	    # if there isn't one, this yields HEX[-dirty] (no NUM)
656	    describe_out, rc = run_command(GITS, ["describe", "--tags", "--dirty",
657	                                          "--always", "--long",
658	                                          "--match", "%%s*" %% tag_prefix],
659	                                   cwd=root)
660	    # --long was added in git-1.5.5
661	    if describe_out is None:
662	        raise NotThisMethod("'git describe' failed")
663	    describe_out = describe_out.strip()
664	    full_out, rc = run_command(GITS, ["rev-parse", "HEAD"], cwd=root)
665	    if full_out is None:
666	        raise NotThisMethod("'git rev-parse' failed")
667	    full_out = full_out.strip()
668	
669	    pieces = {}
670	    pieces["long"] = full_out
671	    pieces["short"] = full_out[:7]  # maybe improved later
672	    pieces["error"] = None
673	
674	    # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]
675	    # TAG might have hyphens.
676	    git_describe = describe_out
677	
678	    # look for -dirty suffix
679	    dirty = git_describe.endswith("-dirty")
680	    pieces["dirty"] = dirty
681	    if dirty:
682	        git_describe = git_describe[:git_describe.rindex("-dirty")]
683	
684	    # now we have TAG-NUM-gHEX or HEX
685	
686	    if "-" in git_describe:
687	        # TAG-NUM-gHEX
688	        mo = re.search(r'^(.+)-(\d+)-g([0-9a-f]+)$', git_describe)
689	        if not mo:
690	            # unparseable. Maybe git-describe is misbehaving?
691	            pieces["error"] = ("unable to parse git-describe output: '%%s'"
692	                               %% describe_out)
693	            return pieces
694	
695	        # tag
696	        full_tag = mo.group(1)
697	        if not full_tag.startswith(tag_prefix):
698	            if verbose:
699	                fmt = "tag '%%s' doesn't start with prefix '%%s'"
700	                print(fmt %% (full_tag, tag_prefix))
701	            pieces["error"] = ("tag '%%s' doesn't start with prefix '%%s'"
702	                               %% (full_tag, tag_prefix))
703	            return pieces
704	        pieces["closest-tag"] = full_tag[len(tag_prefix):]
705	
706	        # distance: number of commits since tag
707	        pieces["distance"] = int(mo.group(2))
708	
709	        # commit: short hex revision ID
710	        pieces["short"] = mo.group(3)
711	
712	    else:
713	        # HEX: no tags
714	        pieces["closest-tag"] = None
715	        count_out, rc = run_command(GITS, ["rev-list", "HEAD", "--count"],
716	                                    cwd=root)
717	        pieces["distance"] = int(count_out)  # total number of commits
718	
719	    # commit date: see ISO-8601 comment in git_versions_from_keywords()
720	    date = run_command(GITS, ["show", "-s", "--format=%%ci", "HEAD"],
721	                       cwd=root)[0].strip()
722	    pieces["date"] = date.strip().replace(" ", "T", 1).replace(" ", "", 1)
723	
724	    return pieces
725	
726	
727	def plus_or_dot(pieces):
728	    """Return a + if we don't already have one, else return a ."""
729	    if "+" in pieces.get("closest-tag", ""):
730	        return "."
731	    return "+"
732	
733	
734	def render_pep440(pieces):
735	    """Build up version string, with post-release "local version identifier".
736	
737	    Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you
738	    get a tagged build and then dirty it, you'll get TAG+0.gHEX.dirty
739	
740	    Exceptions:
741	    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]
742	    """
743	    if pieces["closest-tag"]:
744	        rendered = pieces["closest-tag"]
745	        if pieces["distance"] or pieces["dirty"]:
746	            rendered += plus_or_dot(pieces)
747	            rendered += "%%d.g%%s" %% (pieces["distance"], pieces["short"])
748	            if pieces["dirty"]:
749	                rendered += ".dirty"
750	    else:
751	        # exception #1
752	        rendered = "0+untagged.%%d.g%%s" %% (pieces["distance"],
753	                                          pieces["short"])
754	        if pieces["dirty"]:
755	            rendered += ".dirty"
756	    return rendered
757	
758	
759	def render_pep440_pre(pieces):
760	    """TAG[.post.devDISTANCE] -- No -dirty.
761	
762	    Exceptions:
763	    1: no tags. 0.post.devDISTANCE
764	    """
765	    if pieces["closest-tag"]:
766	        rendered = pieces["closest-tag"]
767	        if pieces["distance"]:
768	            rendered += ".post.dev%%d" %% pieces["distance"]
769	    else:
770	        # exception #1
771	        rendered = "0.post.dev%%d" %% pieces["distance"]
772	    return rendered
773	
774	
775	def render_pep440_post(pieces):
776	    """TAG[.postDISTANCE[.dev0]+gHEX] .
777	
778	    The ".dev0" means dirty. Note that .dev0 sorts backwards
779	    (a dirty tree will appear "older" than the corresponding clean one),
780	    but you shouldn't be releasing software with -dirty anyways.
781	
782	    Exceptions:
783	    1: no tags. 0.postDISTANCE[.dev0]
784	    """
785	    if pieces["closest-tag"]:
786	        rendered = pieces["closest-tag"]
787	        if pieces["distance"] or pieces["dirty"]:
788	            rendered += ".post%%d" %% pieces["distance"]
789	            if pieces["dirty"]:
790	                rendered += ".dev0"
791	            rendered += plus_or_dot(pieces)
792	            rendered += "g%%s" %% pieces["short"]
793	    else:
794	        # exception #1
795	        rendered = "0.post%%d" %% pieces["distance"]
796	        if pieces["dirty"]:
797	            rendered += ".dev0"
798	        rendered += "+g%%s" %% pieces["short"]
799	    return rendered
800	
801	
802	def render_pep440_old(pieces):
803	    """TAG[.postDISTANCE[.dev0]] .
804	
805	    The ".dev0" means dirty.
806	
807	    Eexceptions:
808	    1: no tags. 0.postDISTANCE[.dev0]
809	    """
810	    if pieces["closest-tag"]:
811	        rendered = pieces["closest-tag"]
812	        if pieces["distance"] or pieces["dirty"]:
813	            rendered += ".post%%d" %% pieces["distance"]
814	            if pieces["dirty"]:
815	                rendered += ".dev0"
816	    else:
817	        # exception #1
818	        rendered = "0.post%%d" %% pieces["distance"]
819	        if pieces["dirty"]:
820	            rendered += ".dev0"
821	    return rendered
822	
823	
824	def render_git_describe(pieces):
825	    """TAG[-DISTANCE-gHEX][-dirty].
826	
827	    Like 'git describe --tags --dirty --always'.
828	
829	    Exceptions:
830	    1: no tags. HEX[-dirty]  (note: no 'g' prefix)
831	    """
832	    if pieces["closest-tag"]:
833	        rendered = pieces["closest-tag"]
834	        if pieces["distance"]:
835	            rendered += "-%%d-g%%s" %% (pieces["distance"], pieces["short"])
836	    else:
837	        # exception #1
838	        rendered = pieces["short"]
839	    if pieces["dirty"]:
840	        rendered += "-dirty"
841	    return rendered
842	
843	
844	def render_git_describe_long(pieces):
845	    """TAG-DISTANCE-gHEX[-dirty].
846	
847	    Like 'git describe --tags --dirty --always -long'.
848	    The distance/hash is unconditional.
849	
850	    Exceptions:
851	    1: no tags. HEX[-dirty]  (note: no 'g' prefix)
852	    """
853	    if pieces["closest-tag"]:
854	        rendered = pieces["closest-tag"]
855	        rendered += "-%%d-g%%s" %% (pieces["distance"], pieces["short"])
856	    else:
857	        # exception #1
858	        rendered = pieces["short"]
859	    if pieces["dirty"]:
860	        rendered += "-dirty"
861	    return rendered
862	
863	
864	def render(pieces, style):
865	    """Render the given version pieces into the requested style."""
866	    if pieces["error"]:
867	        return {"version": "unknown",
868	                "full-revisionid": pieces.get("long"),
869	                "dirty": None,
870	                "error": pieces["error"],
871	                "date": None}
872	
873	    if not style or style == "default":
874	        style = "pep440"  # the default
875	
876	    if style == "pep440":
877	        rendered = render_pep440(pieces)
878	    elif style == "pep440-pre":
879	        rendered = render_pep440_pre(pieces)
880	    elif style == "pep440-post":
881	        rendered = render_pep440_post(pieces)
882	    elif style == "pep440-old":
883	        rendered = render_pep440_old(pieces)
884	    elif style == "git-describe":
885	        rendered = render_git_describe(pieces)
886	    elif style == "git-describe-long":
887	        rendered = render_git_describe_long(pieces)
888	    else:
889	        raise ValueError("unknown style '%%s'" %% style)
890	
891	    return {"version": rendered, "full-revisionid": pieces["long"],
892	            "dirty": pieces["dirty"], "error": None,
893	            "date": pieces.get("date")}
894	
895	
896	def get_versions():
897	    """Get version information or return default if unable to do so."""
898	    # I am in _version.py, which lives at ROOT/VERSIONFILE_SOURCE. If we have
899	    # __file__, we can work backwards from there to the root. Some
900	    # py2exe/bbfreeze/non-CPython implementations don't do __file__, in which
901	    # case we can only use expanded keywords.
902	
903	    cfg = get_config()
904	    verbose = cfg.verbose
905	
906	    try:
907	        return git_versions_from_keywords(get_keywords(), cfg.tag_prefix,
908	                                          verbose)
909	    except NotThisMethod:
910	        pass
911	
912	    try:
913	        root = os.path.realpath(__file__)
914	        # versionfile_source is the relative path from the top of the source
915	        # tree (where the .git directory might live) to this file. Invert
916	        # this to find the root from __file__.
917	        for i in cfg.versionfile_source.split('/'):
918	            root = os.path.dirname(root)
919	    except NameError:
920	        return {"version": "0+unknown", "full-revisionid": None,
921	                "dirty": None,
922	                "error": "unable to find root of source tree",
923	                "date": None}
924	
925	    try:
926	        pieces = git_pieces_from_vcs(cfg.tag_prefix, root, verbose)
927	        return render(pieces, cfg.style)
928	    except NotThisMethod:
929	        pass
930	
931	    try:
932	        if cfg.parentdir_prefix:
933	            return versions_from_parentdir(cfg.parentdir_prefix, root, verbose)
934	    except NotThisMethod:
935	        pass
936	
937	    return {"version": "0+unknown", "full-revisionid": None,
938	            "dirty": None,
939	            "error": "unable to compute version", "date": None}
940	'''
941	
942	
943	@register_vcs_handler("git", "get_keywords")
944	def git_get_keywords(versionfile_abs):

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/slicerator-1.1.0/slicerator-1.1.0/versioneer.py:1151
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1150	        f = open(".gitattributes", "a+")
1151	        f.write("%s export-subst\n" % versionfile_source)
1152	        f.close()

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/slicerator-1.1.0/slicerator-1.1.0/versioneer.py:1204
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
1203	        with open(filename) as f:
1204	            contents = f.read()
1205	    except EnvironmentError:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/slicerator-1.1.0/slicerator-1.1.0/versioneer.py:1223
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1222	    with open(filename, "w") as f:
1223	        f.write(SHORT_VERSION_PY % contents)
1224	

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/slicerator-1.1.0/slicerator-1.1.0/versioneer.py:1583
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1582	                    LONG = LONG_VERSION_PY[cfg.VCS]
1583	                    f.write(LONG %
1584	                            {"DOLLAR": "$",
1585	                             "STYLE": cfg.style,
1586	                             "TAG_PREFIX": cfg.tag_prefix,
1587	                             "PARENTDIR_PREFIX": cfg.parentdir_prefix,
1588	                             "VERSIONFILE_SOURCE": cfg.versionfile_source,
1589	                             })

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/slicerator-1.1.0/slicerator-1.1.0/versioneer.py:1612
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1611	                    LONG = LONG_VERSION_PY[cfg.VCS]
1612	                    f.write(LONG %
1613	                            {"DOLLAR": "$",
1614	                             "STYLE": cfg.style,
1615	                             "TAG_PREFIX": cfg.tag_prefix,
1616	                             "PARENTDIR_PREFIX": cfg.parentdir_prefix,
1617	                             "VERSIONFILE_SOURCE": cfg.versionfile_source,
1618	                             })

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/slicerator-1.1.0/slicerator-1.1.0/versioneer.py:1707
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1706	            with open(os.path.join(root, "setup.cfg"), "a") as f:
1707	                f.write(SAMPLE_CONFIG)
1708	        print(CONFIG_ERROR, file=sys.stderr)

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/slicerator-1.1.0/slicerator-1.1.0/versioneer.py:1714
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1713	        LONG = LONG_VERSION_PY[cfg.VCS]
1714	        f.write(LONG % {"DOLLAR": "$",
1715	                        "STYLE": cfg.style,
1716	                        "TAG_PREFIX": cfg.tag_prefix,
1717	                        "PARENTDIR_PREFIX": cfg.parentdir_prefix,
1718	                        "VERSIONFILE_SOURCE": cfg.versionfile_source,
1719	                        })

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/slicerator-1.1.0/slicerator-1.1.0/versioneer.py:1726
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
1725	            with open(ipy, "r") as f:
1726	                old = f.read()
1727	        except EnvironmentError:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/slicerator-1.1.0/slicerator-1.1.0/versioneer.py:1732
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1731	            with open(ipy, "a") as f:
1732	                f.write(INIT_PY_SNIPPET)
1733	        else:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/slicerator-1.1.0/slicerator-1.1.0/versioneer.py:1760
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1759	        with open(manifest_in, "a") as f:
1760	            f.write("include versioneer.py\n")
1761	    else:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/slicerator-1.1.0/slicerator-1.1.0/versioneer.py:1767
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1766	        with open(manifest_in, "a") as f:
1767	            f.write("include %s\n" % cfg.versionfile_source)
1768	    else:

--------------------------------------------------

Code scanned:
	Total lines of code: 2420
	Total lines skipped (#nosec): 0

Run metrics:
	Total issues (by severity):
		Undefined: 0.0
		Low: 0.0
		Medium: 2.0
		High: 13.0
	Total issues (by confidence):
		Undefined: 0.0
		Low: 0.0
		Medium: 15.0
		High: 0.0
Files skipped (0):
