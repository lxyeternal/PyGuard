Run started:2025-04-12 17:01:19.056362

Test results:
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/minikanren-1.0.3/miniKanren-1.0.3/setup.py:13
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
12	    description="Relational programming in Python",
13	    url="http://github.com/pythological/kanren",
14	    maintainer="Brandon T. Willard",

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/minikanren-1.0.3/miniKanren-1.0.3/setup.py:26
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
25	    tests_require=["pytest", "sympy"],
26	    long_description=open("README.md").read() if exists("README.md") else "",
27	    long_description_content_type="text/markdown",

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/minikanren-1.0.3/miniKanren-1.0.3/versioneer.py:417
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
416	
417	LONG_VERSION_PY['git'] = r'''
418	# This file helps to compute a version number in source trees obtained from
419	# git-archive tarball (such as those provided by githubs download-from-tag
420	# feature). Distribution tarballs (built by setup.py sdist) and build
421	# directories (produced by setup.py build) will contain a much shorter file
422	# that just contains the computed version number.
423	
424	# This file is released into the public domain. Generated by
425	# versioneer-0.21 (https://github.com/python-versioneer/python-versioneer)
426	
427	"""Git implementation of _version.py."""
428	
429	import errno
430	import os
431	import re
432	import subprocess
433	import sys
434	from typing import Callable, Dict
435	
436	
437	def get_keywords():
438	    """Get the keywords needed to look up the version information."""
439	    # these strings will be replaced by git during git-archive.
440	    # setup.py/versioneer.py will grep for the variable names, so they must
441	    # each be defined on a line of their own. _version.py will just call
442	    # get_keywords().
443	    git_refnames = "%(DOLLAR)sFormat:%%d%(DOLLAR)s"
444	    git_full = "%(DOLLAR)sFormat:%%H%(DOLLAR)s"
445	    git_date = "%(DOLLAR)sFormat:%%ci%(DOLLAR)s"
446	    keywords = {"refnames": git_refnames, "full": git_full, "date": git_date}
447	    return keywords
448	
449	
450	class VersioneerConfig:
451	    """Container for Versioneer configuration parameters."""
452	
453	
454	def get_config():
455	    """Create, populate and return the VersioneerConfig() object."""
456	    # these strings are filled in when 'setup.py versioneer' creates
457	    # _version.py
458	    cfg = VersioneerConfig()
459	    cfg.VCS = "git"
460	    cfg.style = "%(STYLE)s"
461	    cfg.tag_prefix = "%(TAG_PREFIX)s"
462	    cfg.parentdir_prefix = "%(PARENTDIR_PREFIX)s"
463	    cfg.versionfile_source = "%(VERSIONFILE_SOURCE)s"
464	    cfg.verbose = False
465	    return cfg
466	
467	
468	class NotThisMethod(Exception):
469	    """Exception raised if a method is not valid for the current scenario."""
470	
471	
472	LONG_VERSION_PY: Dict[str, str] = {}
473	HANDLERS: Dict[str, Dict[str, Callable]] = {}
474	
475	
476	def register_vcs_handler(vcs, method):  # decorator
477	    """Create decorator to mark a method as the handler of a VCS."""
478	    def decorate(f):
479	        """Store f in HANDLERS[vcs][method]."""
480	        if vcs not in HANDLERS:
481	            HANDLERS[vcs] = {}
482	        HANDLERS[vcs][method] = f
483	        return f
484	    return decorate
485	
486	
487	def run_command(commands, args, cwd=None, verbose=False, hide_stderr=False,
488	                env=None):
489	    """Call the given command(s)."""
490	    assert isinstance(commands, list)
491	    process = None
492	    for command in commands:
493	        try:
494	            dispcmd = str([command] + args)
495	            # remember shell=False, so use git.cmd on windows, not just git
496	            process = subprocess.Popen([command] + args, cwd=cwd, env=env,
497	                                       stdout=subprocess.PIPE,
498	                                       stderr=(subprocess.PIPE if hide_stderr
499	                                               else None))
500	            break
501	        except OSError:
502	            e = sys.exc_info()[1]
503	            if e.errno == errno.ENOENT:
504	                continue
505	            if verbose:
506	                print("unable to run %%s" %% dispcmd)
507	                print(e)
508	            return None, None
509	    else:
510	        if verbose:
511	            print("unable to find command, tried %%s" %% (commands,))
512	        return None, None
513	    stdout = process.communicate()[0].strip().decode()
514	    if process.returncode != 0:
515	        if verbose:
516	            print("unable to run %%s (error)" %% dispcmd)
517	            print("stdout was %%s" %% stdout)
518	        return None, process.returncode
519	    return stdout, process.returncode
520	
521	
522	def versions_from_parentdir(parentdir_prefix, root, verbose):
523	    """Try to determine the version from the parent directory name.
524	
525	    Source tarballs conventionally unpack into a directory that includes both
526	    the project name and a version string. We will also support searching up
527	    two directory levels for an appropriately named parent directory
528	    """
529	    rootdirs = []
530	
531	    for _ in range(3):
532	        dirname = os.path.basename(root)
533	        if dirname.startswith(parentdir_prefix):
534	            return {"version": dirname[len(parentdir_prefix):],
535	                    "full-revisionid": None,
536	                    "dirty": False, "error": None, "date": None}
537	        rootdirs.append(root)
538	        root = os.path.dirname(root)  # up a level
539	
540	    if verbose:
541	        print("Tried directories %%s but none started with prefix %%s" %%
542	              (str(rootdirs), parentdir_prefix))
543	    raise NotThisMethod("rootdir doesn't start with parentdir_prefix")
544	
545	
546	@register_vcs_handler("git", "get_keywords")
547	def git_get_keywords(versionfile_abs):
548	    """Extract version information from the given file."""
549	    # the code embedded in _version.py can just fetch the value of these
550	    # keywords. When used from setup.py, we don't want to import _version.py,
551	    # so we do it with a regexp instead. This function is not used from
552	    # _version.py.
553	    keywords = {}
554	    try:
555	        with open(versionfile_abs, "r") as fobj:
556	            for line in fobj:
557	                if line.strip().startswith("git_refnames ="):
558	                    mo = re.search(r'=\s*"(.*)"', line)
559	                    if mo:
560	                        keywords["refnames"] = mo.group(1)
561	                if line.strip().startswith("git_full ="):
562	                    mo = re.search(r'=\s*"(.*)"', line)
563	                    if mo:
564	                        keywords["full"] = mo.group(1)
565	                if line.strip().startswith("git_date ="):
566	                    mo = re.search(r'=\s*"(.*)"', line)
567	                    if mo:
568	                        keywords["date"] = mo.group(1)
569	    except OSError:
570	        pass
571	    return keywords
572	
573	
574	@register_vcs_handler("git", "keywords")
575	def git_versions_from_keywords(keywords, tag_prefix, verbose):
576	    """Get version information from git keywords."""
577	    if "refnames" not in keywords:
578	        raise NotThisMethod("Short version file found")
579	    date = keywords.get("date")
580	    if date is not None:
581	        # Use only the last line.  Previous lines may contain GPG signature
582	        # information.
583	        date = date.splitlines()[-1]
584	
585	        # git-2.2.0 added "%%cI", which expands to an ISO-8601 -compliant
586	        # datestamp. However we prefer "%%ci" (which expands to an "ISO-8601
587	        # -like" string, which we must then edit to make compliant), because
588	        # it's been around since git-1.5.3, and it's too difficult to
589	        # discover which version we're using, or to work around using an
590	        # older one.
591	        date = date.strip().replace(" ", "T", 1).replace(" ", "", 1)
592	    refnames = keywords["refnames"].strip()
593	    if refnames.startswith("$Format"):
594	        if verbose:
595	            print("keywords are unexpanded, not using")
596	        raise NotThisMethod("unexpanded keywords, not a git-archive tarball")
597	    refs = {r.strip() for r in refnames.strip("()").split(",")}
598	    # starting in git-1.8.3, tags are listed as "tag: foo-1.0" instead of
599	    # just "foo-1.0". If we see a "tag: " prefix, prefer those.
600	    TAG = "tag: "
601	    tags = {r[len(TAG):] for r in refs if r.startswith(TAG)}
602	    if not tags:
603	        # Either we're using git < 1.8.3, or there really are no tags. We use
604	        # a heuristic: assume all version tags have a digit. The old git %%d
605	        # expansion behaves like git log --decorate=short and strips out the
606	        # refs/heads/ and refs/tags/ prefixes that would let us distinguish
607	        # between branches and tags. By ignoring refnames without digits, we
608	        # filter out many common branch names like "release" and
609	        # "stabilization", as well as "HEAD" and "master".
610	        tags = {r for r in refs if re.search(r'\d', r)}
611	        if verbose:
612	            print("discarding '%%s', no digits" %% ",".join(refs - tags))
613	    if verbose:
614	        print("likely tags: %%s" %% ",".join(sorted(tags)))
615	    for ref in sorted(tags):
616	        # sorting will prefer e.g. "2.0" over "2.0rc1"
617	        if ref.startswith(tag_prefix):
618	            r = ref[len(tag_prefix):]
619	            # Filter out refs that exactly match prefix or that don't start
620	            # with a number once the prefix is stripped (mostly a concern
621	            # when prefix is '')
622	            if not re.match(r'\d', r):
623	                continue
624	            if verbose:
625	                print("picking %%s" %% r)
626	            return {"version": r,
627	                    "full-revisionid": keywords["full"].strip(),
628	                    "dirty": False, "error": None,
629	                    "date": date}
630	    # no suitable tags, so version is "0+unknown", but full hex is still there
631	    if verbose:
632	        print("no suitable tags, using unknown + full revision id")
633	    return {"version": "0+unknown",
634	            "full-revisionid": keywords["full"].strip(),
635	            "dirty": False, "error": "no suitable tags", "date": None}
636	
637	
638	@register_vcs_handler("git", "pieces_from_vcs")
639	def git_pieces_from_vcs(tag_prefix, root, verbose, runner=run_command):
640	    """Get version from 'git describe' in the root of the source tree.
641	
642	    This only gets called if the git-archive 'subst' keywords were *not*
643	    expanded, and _version.py hasn't already been rewritten with a short
644	    version string, meaning we're inside a checked out source tree.
645	    """
646	    GITS = ["git"]
647	    TAG_PREFIX_REGEX = "*"
648	    if sys.platform == "win32":
649	        GITS = ["git.cmd", "git.exe"]
650	        TAG_PREFIX_REGEX = r"\*"
651	
652	    _, rc = runner(GITS, ["rev-parse", "--git-dir"], cwd=root,
653	                   hide_stderr=True)
654	    if rc != 0:
655	        if verbose:
656	            print("Directory %%s not under git control" %% root)
657	        raise NotThisMethod("'git rev-parse --git-dir' returned error")
658	
659	    # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]
660	    # if there isn't one, this yields HEX[-dirty] (no NUM)
661	    describe_out, rc = runner(GITS, ["describe", "--tags", "--dirty",
662	                                     "--always", "--long",
663	                                     "--match",
664	                                     "%%s%%s" %% (tag_prefix, TAG_PREFIX_REGEX)],
665	                              cwd=root)
666	    # --long was added in git-1.5.5
667	    if describe_out is None:
668	        raise NotThisMethod("'git describe' failed")
669	    describe_out = describe_out.strip()
670	    full_out, rc = runner(GITS, ["rev-parse", "HEAD"], cwd=root)
671	    if full_out is None:
672	        raise NotThisMethod("'git rev-parse' failed")
673	    full_out = full_out.strip()
674	
675	    pieces = {}
676	    pieces["long"] = full_out
677	    pieces["short"] = full_out[:7]  # maybe improved later
678	    pieces["error"] = None
679	
680	    branch_name, rc = runner(GITS, ["rev-parse", "--abbrev-ref", "HEAD"],
681	                             cwd=root)
682	    # --abbrev-ref was added in git-1.6.3
683	    if rc != 0 or branch_name is None:
684	        raise NotThisMethod("'git rev-parse --abbrev-ref' returned error")
685	    branch_name = branch_name.strip()
686	
687	    if branch_name == "HEAD":
688	        # If we aren't exactly on a branch, pick a branch which represents
689	        # the current commit. If all else fails, we are on a branchless
690	        # commit.
691	        branches, rc = runner(GITS, ["branch", "--contains"], cwd=root)
692	        # --contains was added in git-1.5.4
693	        if rc != 0 or branches is None:
694	            raise NotThisMethod("'git branch --contains' returned error")
695	        branches = branches.split("\n")
696	
697	        # Remove the first line if we're running detached
698	        if "(" in branches[0]:
699	            branches.pop(0)
700	
701	        # Strip off the leading "* " from the list of branches.
702	        branches = [branch[2:] for branch in branches]
703	        if "master" in branches:
704	            branch_name = "master"
705	        elif not branches:
706	            branch_name = None
707	        else:
708	            # Pick the first branch that is returned. Good or bad.
709	            branch_name = branches[0]
710	
711	    pieces["branch"] = branch_name
712	
713	    # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]
714	    # TAG might have hyphens.
715	    git_describe = describe_out
716	
717	    # look for -dirty suffix
718	    dirty = git_describe.endswith("-dirty")
719	    pieces["dirty"] = dirty
720	    if dirty:
721	        git_describe = git_describe[:git_describe.rindex("-dirty")]
722	
723	    # now we have TAG-NUM-gHEX or HEX
724	
725	    if "-" in git_describe:
726	        # TAG-NUM-gHEX
727	        mo = re.search(r'^(.+)-(\d+)-g([0-9a-f]+)$', git_describe)
728	        if not mo:
729	            # unparsable. Maybe git-describe is misbehaving?
730	            pieces["error"] = ("unable to parse git-describe output: '%%s'"
731	                               %% describe_out)
732	            return pieces
733	
734	        # tag
735	        full_tag = mo.group(1)
736	        if not full_tag.startswith(tag_prefix):
737	            if verbose:
738	                fmt = "tag '%%s' doesn't start with prefix '%%s'"
739	                print(fmt %% (full_tag, tag_prefix))
740	            pieces["error"] = ("tag '%%s' doesn't start with prefix '%%s'"
741	                               %% (full_tag, tag_prefix))
742	            return pieces
743	        pieces["closest-tag"] = full_tag[len(tag_prefix):]
744	
745	        # distance: number of commits since tag
746	        pieces["distance"] = int(mo.group(2))
747	
748	        # commit: short hex revision ID
749	        pieces["short"] = mo.group(3)
750	
751	    else:
752	        # HEX: no tags
753	        pieces["closest-tag"] = None
754	        count_out, rc = runner(GITS, ["rev-list", "HEAD", "--count"], cwd=root)
755	        pieces["distance"] = int(count_out)  # total number of commits
756	
757	    # commit date: see ISO-8601 comment in git_versions_from_keywords()
758	    date = runner(GITS, ["show", "-s", "--format=%%ci", "HEAD"], cwd=root)[0].strip()
759	    # Use only the last line.  Previous lines may contain GPG signature
760	    # information.
761	    date = date.splitlines()[-1]
762	    pieces["date"] = date.strip().replace(" ", "T", 1).replace(" ", "", 1)
763	
764	    return pieces
765	
766	
767	def plus_or_dot(pieces):
768	    """Return a + if we don't already have one, else return a ."""
769	    if "+" in pieces.get("closest-tag", ""):
770	        return "."
771	    return "+"
772	
773	
774	def render_pep440(pieces):
775	    """Build up version string, with post-release "local version identifier".
776	
777	    Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you
778	    get a tagged build and then dirty it, you'll get TAG+0.gHEX.dirty
779	
780	    Exceptions:
781	    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]
782	    """
783	    if pieces["closest-tag"]:
784	        rendered = pieces["closest-tag"]
785	        if pieces["distance"] or pieces["dirty"]:
786	            rendered += plus_or_dot(pieces)
787	            rendered += "%%d.g%%s" %% (pieces["distance"], pieces["short"])
788	            if pieces["dirty"]:
789	                rendered += ".dirty"
790	    else:
791	        # exception #1
792	        rendered = "0+untagged.%%d.g%%s" %% (pieces["distance"],
793	                                          pieces["short"])
794	        if pieces["dirty"]:
795	            rendered += ".dirty"
796	    return rendered
797	
798	
799	def render_pep440_branch(pieces):
800	    """TAG[[.dev0]+DISTANCE.gHEX[.dirty]] .
801	
802	    The ".dev0" means not master branch. Note that .dev0 sorts backwards
803	    (a feature branch will appear "older" than the master branch).
804	
805	    Exceptions:
806	    1: no tags. 0[.dev0]+untagged.DISTANCE.gHEX[.dirty]
807	    """
808	    if pieces["closest-tag"]:
809	        rendered = pieces["closest-tag"]
810	        if pieces["distance"] or pieces["dirty"]:
811	            if pieces["branch"] != "master":
812	                rendered += ".dev0"
813	            rendered += plus_or_dot(pieces)
814	            rendered += "%%d.g%%s" %% (pieces["distance"], pieces["short"])
815	            if pieces["dirty"]:
816	                rendered += ".dirty"
817	    else:
818	        # exception #1
819	        rendered = "0"
820	        if pieces["branch"] != "master":
821	            rendered += ".dev0"
822	        rendered += "+untagged.%%d.g%%s" %% (pieces["distance"],
823	                                          pieces["short"])
824	        if pieces["dirty"]:
825	            rendered += ".dirty"
826	    return rendered
827	
828	
829	def pep440_split_post(ver):
830	    """Split pep440 version string at the post-release segment.
831	
832	    Returns the release segments before the post-release and the
833	    post-release version number (or -1 if no post-release segment is present).
834	    """
835	    vc = str.split(ver, ".post")
836	    return vc[0], int(vc[1] or 0) if len(vc) == 2 else None
837	
838	
839	def render_pep440_pre(pieces):
840	    """TAG[.postN.devDISTANCE] -- No -dirty.
841	
842	    Exceptions:
843	    1: no tags. 0.post0.devDISTANCE
844	    """
845	    if pieces["closest-tag"]:
846	        if pieces["distance"]:
847	            # update the post release segment
848	            tag_version, post_version = pep440_split_post(pieces["closest-tag"])
849	            rendered = tag_version
850	            if post_version is not None:
851	                rendered += ".post%%d.dev%%d" %% (post_version+1, pieces["distance"])
852	            else:
853	                rendered += ".post0.dev%%d" %% (pieces["distance"])
854	        else:
855	            # no commits, use the tag as the version
856	            rendered = pieces["closest-tag"]
857	    else:
858	        # exception #1
859	        rendered = "0.post0.dev%%d" %% pieces["distance"]
860	    return rendered
861	
862	
863	def render_pep440_post(pieces):
864	    """TAG[.postDISTANCE[.dev0]+gHEX] .
865	
866	    The ".dev0" means dirty. Note that .dev0 sorts backwards
867	    (a dirty tree will appear "older" than the corresponding clean one),
868	    but you shouldn't be releasing software with -dirty anyways.
869	
870	    Exceptions:
871	    1: no tags. 0.postDISTANCE[.dev0]
872	    """
873	    if pieces["closest-tag"]:
874	        rendered = pieces["closest-tag"]
875	        if pieces["distance"] or pieces["dirty"]:
876	            rendered += ".post%%d" %% pieces["distance"]
877	            if pieces["dirty"]:
878	                rendered += ".dev0"
879	            rendered += plus_or_dot(pieces)
880	            rendered += "g%%s" %% pieces["short"]
881	    else:
882	        # exception #1
883	        rendered = "0.post%%d" %% pieces["distance"]
884	        if pieces["dirty"]:
885	            rendered += ".dev0"
886	        rendered += "+g%%s" %% pieces["short"]
887	    return rendered
888	
889	
890	def render_pep440_post_branch(pieces):
891	    """TAG[.postDISTANCE[.dev0]+gHEX[.dirty]] .
892	
893	    The ".dev0" means not master branch.
894	
895	    Exceptions:
896	    1: no tags. 0.postDISTANCE[.dev0]+gHEX[.dirty]
897	    """
898	    if pieces["closest-tag"]:
899	        rendered = pieces["closest-tag"]
900	        if pieces["distance"] or pieces["dirty"]:
901	            rendered += ".post%%d" %% pieces["distance"]
902	            if pieces["branch"] != "master":
903	                rendered += ".dev0"
904	            rendered += plus_or_dot(pieces)
905	            rendered += "g%%s" %% pieces["short"]
906	            if pieces["dirty"]:
907	                rendered += ".dirty"
908	    else:
909	        # exception #1
910	        rendered = "0.post%%d" %% pieces["distance"]
911	        if pieces["branch"] != "master":
912	            rendered += ".dev0"
913	        rendered += "+g%%s" %% pieces["short"]
914	        if pieces["dirty"]:
915	            rendered += ".dirty"
916	    return rendered
917	
918	
919	def render_pep440_old(pieces):
920	    """TAG[.postDISTANCE[.dev0]] .
921	
922	    The ".dev0" means dirty.
923	
924	    Exceptions:
925	    1: no tags. 0.postDISTANCE[.dev0]
926	    """
927	    if pieces["closest-tag"]:
928	        rendered = pieces["closest-tag"]
929	        if pieces["distance"] or pieces["dirty"]:
930	            rendered += ".post%%d" %% pieces["distance"]
931	            if pieces["dirty"]:
932	                rendered += ".dev0"
933	    else:
934	        # exception #1
935	        rendered = "0.post%%d" %% pieces["distance"]
936	        if pieces["dirty"]:
937	            rendered += ".dev0"
938	    return rendered
939	
940	
941	def render_git_describe(pieces):
942	    """TAG[-DISTANCE-gHEX][-dirty].
943	
944	    Like 'git describe --tags --dirty --always'.
945	
946	    Exceptions:
947	    1: no tags. HEX[-dirty]  (note: no 'g' prefix)
948	    """
949	    if pieces["closest-tag"]:
950	        rendered = pieces["closest-tag"]
951	        if pieces["distance"]:
952	            rendered += "-%%d-g%%s" %% (pieces["distance"], pieces["short"])
953	    else:
954	        # exception #1
955	        rendered = pieces["short"]
956	    if pieces["dirty"]:
957	        rendered += "-dirty"
958	    return rendered
959	
960	
961	def render_git_describe_long(pieces):
962	    """TAG-DISTANCE-gHEX[-dirty].
963	
964	    Like 'git describe --tags --dirty --always -long'.
965	    The distance/hash is unconditional.
966	
967	    Exceptions:
968	    1: no tags. HEX[-dirty]  (note: no 'g' prefix)
969	    """
970	    if pieces["closest-tag"]:
971	        rendered = pieces["closest-tag"]
972	        rendered += "-%%d-g%%s" %% (pieces["distance"], pieces["short"])
973	    else:
974	        # exception #1
975	        rendered = pieces["short"]
976	    if pieces["dirty"]:
977	        rendered += "-dirty"
978	    return rendered
979	
980	
981	def render(pieces, style):
982	    """Render the given version pieces into the requested style."""
983	    if pieces["error"]:
984	        return {"version": "unknown",
985	                "full-revisionid": pieces.get("long"),
986	                "dirty": None,
987	                "error": pieces["error"],
988	                "date": None}
989	
990	    if not style or style == "default":
991	        style = "pep440"  # the default
992	
993	    if style == "pep440":
994	        rendered = render_pep440(pieces)
995	    elif style == "pep440-branch":
996	        rendered = render_pep440_branch(pieces)
997	    elif style == "pep440-pre":
998	        rendered = render_pep440_pre(pieces)
999	    elif style == "pep440-post":
1000	        rendered = render_pep440_post(pieces)
1001	    elif style == "pep440-post-branch":
1002	        rendered = render_pep440_post_branch(pieces)
1003	    elif style == "pep440-old":
1004	        rendered = render_pep440_old(pieces)
1005	    elif style == "git-describe":
1006	        rendered = render_git_describe(pieces)
1007	    elif style == "git-describe-long":
1008	        rendered = render_git_describe_long(pieces)
1009	    else:
1010	        raise ValueError("unknown style '%%s'" %% style)
1011	
1012	    return {"version": rendered, "full-revisionid": pieces["long"],
1013	            "dirty": pieces["dirty"], "error": None,
1014	            "date": pieces.get("date")}
1015	
1016	
1017	def get_versions():
1018	    """Get version information or return default if unable to do so."""
1019	    # I am in _version.py, which lives at ROOT/VERSIONFILE_SOURCE. If we have
1020	    # __file__, we can work backwards from there to the root. Some
1021	    # py2exe/bbfreeze/non-CPython implementations don't do __file__, in which
1022	    # case we can only use expanded keywords.
1023	
1024	    cfg = get_config()
1025	    verbose = cfg.verbose
1026	
1027	    try:
1028	        return git_versions_from_keywords(get_keywords(), cfg.tag_prefix,
1029	                                          verbose)
1030	    except NotThisMethod:
1031	        pass
1032	
1033	    try:
1034	        root = os.path.realpath(__file__)
1035	        # versionfile_source is the relative path from the top of the source
1036	        # tree (where the .git directory might live) to this file. Invert
1037	        # this to find the root from __file__.
1038	        for _ in cfg.versionfile_source.split('/'):
1039	            root = os.path.dirname(root)
1040	    except NameError:
1041	        return {"version": "0+unknown", "full-revisionid": None,
1042	                "dirty": None,
1043	                "error": "unable to find root of source tree",
1044	                "date": None}
1045	
1046	    try:
1047	        pieces = git_pieces_from_vcs(cfg.tag_prefix, root, verbose)
1048	        return render(pieces, cfg.style)
1049	    except NotThisMethod:
1050	        pass
1051	
1052	    try:
1053	        if cfg.parentdir_prefix:
1054	            return versions_from_parentdir(cfg.parentdir_prefix, root, verbose)
1055	    except NotThisMethod:
1056	        pass
1057	
1058	    return {"version": "0+unknown", "full-revisionid": None,
1059	            "dirty": None,
1060	            "error": "unable to compute version", "date": None}
1061	'''
1062	
1063	
1064	@register_vcs_handler("git", "get_keywords")
1065	def git_get_keywords(versionfile_abs):

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/minikanren-1.0.3/miniKanren-1.0.3/versioneer.py:1317
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1316	        with open(".gitattributes", "a+") as fobj:
1317	            fobj.write(f"{versionfile_source} export-subst\n")
1318	        files.append(".gitattributes")

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/minikanren-1.0.3/miniKanren-1.0.3/versioneer.py:1368
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
1367	        with open(filename) as f:
1368	            contents = f.read()
1369	    except OSError:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/minikanren-1.0.3/miniKanren-1.0.3/versioneer.py:1387
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1386	    with open(filename, "w") as f:
1387	        f.write(SHORT_VERSION_PY % contents)
1388	

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/minikanren-1.0.3/miniKanren-1.0.3/versioneer.py:1861
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1860	                    LONG = LONG_VERSION_PY[cfg.VCS]
1861	                    f.write(LONG %
1862	                            {"DOLLAR": "$",
1863	                             "STYLE": cfg.style,
1864	                             "TAG_PREFIX": cfg.tag_prefix,
1865	                             "PARENTDIR_PREFIX": cfg.parentdir_prefix,
1866	                             "VERSIONFILE_SOURCE": cfg.versionfile_source,
1867	                             })

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/minikanren-1.0.3/miniKanren-1.0.3/versioneer.py:1887
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1886	                    LONG = LONG_VERSION_PY[cfg.VCS]
1887	                    f.write(LONG %
1888	                            {"DOLLAR": "$",
1889	                             "STYLE": cfg.style,
1890	                             "TAG_PREFIX": cfg.tag_prefix,
1891	                             "PARENTDIR_PREFIX": cfg.parentdir_prefix,
1892	                             "VERSIONFILE_SOURCE": cfg.versionfile_source,
1893	                             })

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/minikanren-1.0.3/miniKanren-1.0.3/versioneer.py:1989
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1988	            with open(os.path.join(root, "setup.cfg"), "a") as f:
1989	                f.write(SAMPLE_CONFIG)
1990	        print(CONFIG_ERROR, file=sys.stderr)

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/minikanren-1.0.3/miniKanren-1.0.3/versioneer.py:1996
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1995	        LONG = LONG_VERSION_PY[cfg.VCS]
1996	        f.write(LONG % {"DOLLAR": "$",
1997	                        "STYLE": cfg.style,
1998	                        "TAG_PREFIX": cfg.tag_prefix,
1999	                        "PARENTDIR_PREFIX": cfg.parentdir_prefix,
2000	                        "VERSIONFILE_SOURCE": cfg.versionfile_source,
2001	                        })

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/minikanren-1.0.3/miniKanren-1.0.3/versioneer.py:2008
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
2007	            with open(ipy, "r") as f:
2008	                old = f.read()
2009	        except OSError:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/minikanren-1.0.3/miniKanren-1.0.3/versioneer.py:2016
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2015	            with open(ipy, "w") as f:
2016	                f.write(old.replace(OLD_SNIPPET, snippet))
2017	        elif snippet not in old:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/minikanren-1.0.3/miniKanren-1.0.3/versioneer.py:2020
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2019	            with open(ipy, "a") as f:
2020	                f.write(snippet)
2021	        else:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/minikanren-1.0.3/miniKanren-1.0.3/versioneer.py:2048
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2047	        with open(manifest_in, "a") as f:
2048	            f.write("include versioneer.py\n")
2049	    else:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/minikanren-1.0.3/miniKanren-1.0.3/versioneer.py:2055
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2054	        with open(manifest_in, "a") as f:
2055	            f.write("include %s\n" % cfg.versionfile_source)
2056	    else:

--------------------------------------------------

Code scanned:
	Total lines of code: 2945
	Total lines skipped (#nosec): 0

Run metrics:
	Total issues (by severity):
		Undefined: 0.0
		Low: 0.0
		Medium: 2.0
		High: 13.0
	Total issues (by confidence):
		Undefined: 0.0
		Low: 0.0
		Medium: 15.0
		High: 0.0
Files skipped (0):
