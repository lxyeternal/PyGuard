Run started:2025-04-12 10:30:15.290950

Test results:
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/miniaudio-1.61/miniaudio-1.61/build_ffi_module.py:118
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
117	
118	miniaudio_defs = """
119	
120	/********** Miniaudio **********/
121	
122	typedef enum
123	{
124	    MA_SUCCESS                        =  0,
125	    MA_ERROR                          = -1,  /* A generic error. */
126	    MA_INVALID_ARGS                   = -2,
127	    MA_INVALID_OPERATION              = -3,
128	    MA_OUT_OF_MEMORY                  = -4,
129	    MA_OUT_OF_RANGE                   = -5,
130	    MA_ACCESS_DENIED                  = -6,
131	    MA_DOES_NOT_EXIST                 = -7,
132	    MA_ALREADY_EXISTS                 = -8,
133	    MA_TOO_MANY_OPEN_FILES            = -9,
134	    MA_INVALID_FILE                   = -10,
135	    MA_TOO_BIG                        = -11,
136	    MA_PATH_TOO_LONG                  = -12,
137	    MA_NAME_TOO_LONG                  = -13,
138	    MA_NOT_DIRECTORY                  = -14,
139	    MA_IS_DIRECTORY                   = -15,
140	    MA_DIRECTORY_NOT_EMPTY            = -16,
141	    MA_AT_END                         = -17,
142	    MA_NO_SPACE                       = -18,
143	    MA_BUSY                           = -19,
144	    MA_IO_ERROR                       = -20,
145	    MA_INTERRUPT                      = -21,
146	    MA_UNAVAILABLE                    = -22,
147	    MA_ALREADY_IN_USE                 = -23,
148	    MA_BAD_ADDRESS                    = -24,
149	    MA_BAD_SEEK                       = -25,
150	    MA_BAD_PIPE                       = -26,
151	    MA_DEADLOCK                       = -27,
152	    MA_TOO_MANY_LINKS                 = -28,
153	    MA_NOT_IMPLEMENTED                = -29,
154	    MA_NO_MESSAGE                     = -30,
155	    MA_BAD_MESSAGE                    = -31,
156	    MA_NO_DATA_AVAILABLE              = -32,
157	    MA_INVALID_DATA                   = -33,
158	    MA_TIMEOUT                        = -34,
159	    MA_NO_NETWORK                     = -35,
160	    MA_NOT_UNIQUE                     = -36,
161	    MA_NOT_SOCKET                     = -37,
162	    MA_NO_ADDRESS                     = -38,
163	    MA_BAD_PROTOCOL                   = -39,
164	    MA_PROTOCOL_UNAVAILABLE           = -40,
165	    MA_PROTOCOL_NOT_SUPPORTED         = -41,
166	    MA_PROTOCOL_FAMILY_NOT_SUPPORTED  = -42,
167	    MA_ADDRESS_FAMILY_NOT_SUPPORTED   = -43,
168	    MA_SOCKET_NOT_SUPPORTED           = -44,
169	    MA_CONNECTION_RESET               = -45,
170	    MA_ALREADY_CONNECTED              = -46,
171	    MA_NOT_CONNECTED                  = -47,
172	    MA_CONNECTION_REFUSED             = -48,
173	    MA_NO_HOST                        = -49,
174	    MA_IN_PROGRESS                    = -50,
175	    MA_CANCELLED                      = -51,
176	    MA_MEMORY_ALREADY_MAPPED          = -52,
177	
178	    /* General miniaudio-specific errors. */
179	    MA_FORMAT_NOT_SUPPORTED           = -100,
180	    MA_DEVICE_TYPE_NOT_SUPPORTED      = -101,
181	    MA_SHARE_MODE_NOT_SUPPORTED       = -102,
182	    MA_NO_BACKEND                     = -103,
183	    MA_NO_DEVICE                      = -104,
184	    MA_API_NOT_FOUND                  = -105,
185	    MA_INVALID_DEVICE_CONFIG          = -106,
186	    MA_LOOP                           = -107,
187	
188	    /* State errors. */
189	    MA_DEVICE_NOT_INITIALIZED         = -200,
190	    MA_DEVICE_ALREADY_INITIALIZED     = -201,
191	    MA_DEVICE_NOT_STARTED             = -202,
192	    MA_DEVICE_NOT_STOPPED             = -203,
193	
194	    /* Operation errors. */
195	    MA_FAILED_TO_INIT_BACKEND         = -300,
196	    MA_FAILED_TO_OPEN_BACKEND_DEVICE  = -301,
197	    MA_FAILED_TO_START_BACKEND_DEVICE = -302,
198	    MA_FAILED_TO_STOP_BACKEND_DEVICE  = -303
199	} ma_result; 
200	
201	
202	#define MA_MIN_CHANNELS                                1
203	#define MA_MAX_CHANNELS                                254
204	
205	
206	typedef enum
207	{
208	    ma_backend_wasapi,
209	    ma_backend_dsound,
210	    ma_backend_winmm,
211	    ma_backend_coreaudio,
212	    ma_backend_sndio,
213	    ma_backend_audio4,
214	    ma_backend_oss,
215	    ma_backend_pulseaudio,
216	    ma_backend_alsa,
217	    ma_backend_jack,
218	    ma_backend_aaudio,
219	    ma_backend_opensl,
220	    ma_backend_webaudio,
221	    ma_backend_custom,  /* <-- Custom backend, with callbacks defined by the context config. */
222	    ma_backend_null     /* <-- Must always be the last item. Lowest priority, and used as the terminator for backend enumeration. */
223	} ma_backend;
224	
225	typedef   signed char           ma_int8;
226	typedef unsigned char           ma_uint8;
227	typedef   signed short          ma_int16;
228	typedef unsigned short          ma_uint16;
229	typedef   signed int            ma_int32;
230	typedef unsigned int            ma_uint32;
231	typedef   signed long long  ma_int64;
232	typedef unsigned long long  ma_uint64;
233	typedef ma_uint64           ma_uintptr;
234	typedef ma_uint8    ma_bool8;
235	typedef ma_uint32   ma_bool32;
236	
237	
238	typedef enum
239	{
240	    ma_dither_mode_none = 0,
241	    ma_dither_mode_rectangle,
242	    ma_dither_mode_triangle
243	} ma_dither_mode;
244	
245	
246	typedef enum
247	{
248	    ma_format_unknown = 0,     /* Mainly used for indicating an error, but also used as the default for the output format for decoders. */
249	    ma_format_u8      = 1,
250	    ma_format_s16     = 2,     /* Seems to be the most widely supported format. */
251	    ma_format_s24     = 3,     /* Tightly packed. 3 bytes per sample. */
252	    ma_format_s32     = 4,
253	    ma_format_f32     = 5,
254	    ma_format_count
255	} ma_format;
256	
257	
258	typedef enum
259	{
260	    ma_channel_mix_mode_rectangular = 0,   /* Simple averaging based on the plane(s) the channel is sitting on. */
261	    ma_channel_mix_mode_simple,            /* Drop excess channels; zeroed out extra channels. */
262	    ma_channel_mix_mode_custom_weights,    /* Use custom weights specified in ma_channel_router_config. */
263	    ma_channel_mix_mode_default = ma_channel_mix_mode_rectangular
264	} ma_channel_mix_mode;
265	
266	typedef enum
267	{
268	    ma_standard_channel_map_microsoft,
269	    ma_standard_channel_map_alsa,
270	    ma_standard_channel_map_rfc3551,   /* Based off AIFF. */
271	    ma_standard_channel_map_flac,
272	    ma_standard_channel_map_vorbis,
273	    ma_standard_channel_map_sound4,    /* FreeBSD's sound(4). */
274	    ma_standard_channel_map_sndio,     /* www.sndio.org/tips.html */
275	    ma_standard_channel_map_webaudio = ma_standard_channel_map_flac, /* https://webaudio.github.io/web-audio-api/#ChannelOrdering. Only 1, 2, 4 and 6 channels are defined, but can fill in the gaps with logical assumptions. */
276	    ma_standard_channel_map_default = ma_standard_channel_map_microsoft
277	} ma_standard_channel_map;
278	
279	
280	typedef enum
281	{
282	    ma_thread_priority_idle     = -5,
283	    ma_thread_priority_lowest   = -4,
284	    ma_thread_priority_low      = -3,
285	    ma_thread_priority_normal   = -2,
286	    ma_thread_priority_high     = -1,
287	    ma_thread_priority_highest  =  0,
288	    ma_thread_priority_realtime =  1,
289	    ma_thread_priority_default  =  0
290	} ma_thread_priority;
291	
292	
293	typedef enum
294	{
295	    ma_device_type_playback = 1,
296	    ma_device_type_capture  = 2,
297	    ma_device_type_duplex   = 3,
298	    ma_device_type_loopback = 4
299	} ma_device_type;
300	
301	typedef enum
302	{
303	    ma_device_state_uninitialized = 0,
304	    ma_device_state_stopped       = 1,  /* The device's default state after initialization. */
305	    ma_device_state_started       = 2,  /* The device is started and is requesting and/or delivering audio data. */
306	    ma_device_state_starting      = 3,  /* Transitioning from a stopped state to started. */
307	    ma_device_state_stopping      = 4   /* Transitioning from a started state to stopped. */
308	} ma_device_state;
309	
310	typedef enum
311	{
312	    ma_encoding_format_unknown = 0,
313	    ma_encoding_format_wav,
314	    ma_encoding_format_flac,
315	    ma_encoding_format_mp3,
316	    ma_encoding_format_vorbis
317	} ma_encoding_format;
318	
319	typedef enum
320	{
321	    ma_share_mode_shared = 0,
322	    ma_share_mode_exclusive
323	} ma_share_mode;
324	
325	typedef enum
326	{
327	    ma_wasapi_usage_default = 0,
328	    ma_wasapi_usage_games,
329	    ma_wasapi_usage_pro_audio,
330	} ma_wasapi_usage;
331	
332	typedef enum
333	{
334	    ma_seek_origin_start,
335	    ma_seek_origin_current
336	} ma_seek_origin;
337	
338	typedef union ma_device_id {
339	    ...;
340	} ma_device_id;
341	typedef struct ma_context {
342	    ma_backend backend;
343	    ...;
344	} ma_context;
345	
346	typedef struct ma_context ma_context;
347	typedef struct ma_device ma_device;
348	
349	typedef enum
350	{
351	    ma_device_notification_type_started,
352	    ma_device_notification_type_stopped,
353	    ma_device_notification_type_rerouted,
354	    ma_device_notification_type_interruption_began,
355	    ma_device_notification_type_interruption_ended
356	} ma_device_notification_type;
357	
358	typedef struct
359	{
360	    ma_device* pDevice;
361	    ma_device_notification_type type;
362	    union
363	    {
364	        struct
365	        {
366	            int _unused;
367	        } started;
368	        struct
369	        {
370	            int _unused;
371	        } stopped;
372	        struct
373	        {
374	            int _unused;
375	        } rerouted;
376	        struct
377	        {
378	            int _unused;
379	        } interruption;
380	    } data;
381	} ma_device_notification;
382	
383	
384	typedef ma_uint8 ma_channel;
385	typedef struct ma_device ma_device;
386	typedef struct ma_decoder ma_decoder;
387	
388	typedef ma_result (* ma_decoder_read_proc)(ma_decoder* pDecoder, void* pBufferOut, size_t bytesToRead, size_t* pBytesRead);         /* Returns the number of bytes read. */
389	typedef ma_result (* ma_decoder_seek_proc)(ma_decoder* pDecoder, ma_int64 byteOffset, ma_seek_origin origin);
390	typedef ma_result (* ma_decoder_tell_proc)(ma_decoder* pDecoder, ma_int64* pCursor);
391	typedef void (* ma_device_data_proc)(ma_device* pDevice, void* pOutput, const void* pInput, ma_uint32 frameCount);
392	typedef void (* ma_stop_proc)(ma_device* pDevice);  /* DEPRECATED. Use ma_device_notification_proc instead. */
393	typedef void (* ma_device_notification_proc)(const ma_device_notification* pNotification);
394	
395	struct ma_atomic_device_state {
396	    ...;
397	};
398	
399	struct ma_atomic_float {
400	    ...;
401	};
402	
403	typedef struct ma_atomic_float ma_atomic_float;
404	typedef struct ma_atomic_device_state ma_atomic_device_state;
405	
406	
407	struct ma_device {
408	
409	    ma_context* pContext;
410	    ma_device_type type;
411	    ma_uint32 sampleRate;
412	    ma_atomic_device_state state;        /* The state of the device is variable and can change at any time on any thread. Must be used atomically. */
413	    void* pUserData;                        /* Application defined data. */
414	    ma_atomic_float masterVolumeFactor;     /* Linear 0..1. Can be read and written simultaneously by different threads. Must be used atomically. */
415	    ...;
416	    
417	};
418	
419	
420	typedef struct
421	{
422	    /* Basic info. This is the only information guaranteed to be filled in during device enumeration. */
423	    ma_device_id id;
424	    char name[256];
425	    ma_bool32 isDefault;
426	
427	    ma_uint32 nativeDataFormatCount;
428	    struct
429	    {
430	        ma_format format;       /* Sample format. If set to ma_format_unknown, all sample formats are supported. */
431	        ma_uint32 channels;     /* If set to 0, all channels are supported. */
432	        ma_uint32 sampleRate;   /* If set to 0, all sample rates are supported. */
433	        ma_uint32 flags;        /* A combination of MA_DATA_FORMAT_FLAG_* flags. */
434	    } nativeDataFormats[64];
435	} ma_device_info;
436	
437	
438	typedef struct
439	{
440	
441	    ma_device_type deviceType;
442	    ma_uint32 sampleRate;
443	    ma_uint32 periodSizeInFrames;
444	    ma_uint32 periodSizeInMilliseconds;
445	    ma_uint32 periods;
446	    ma_device_data_proc dataCallback;
447	    ma_device_notification_proc notificationCallback;
448	    ma_stop_proc stopCallback;
449	    void* pUserData;
450	    
451	    struct
452	    {
453	        const ma_device_id* pDeviceID;
454	        ma_format format;
455	        ma_uint32 channels;
456	        ma_channel* pChannelMap;
457	        ma_channel_mix_mode channelMixMode;
458	        ma_bool32 calculateLFEFromSpatialChannels;  /* When an output LFE channel is present, but no input LFE, set to true to set the output LFE to the average of all spatial channels (LR, FR, etc.). Ignored when an input LFE is present. */
459	        ma_share_mode shareMode;
460	    } playback;
461	    struct
462	    {
463	        const ma_device_id* pDeviceID;
464	        ma_format format;
465	        ma_uint32 channels;
466	        ma_channel* pChannelMap;
467	        ma_channel_mix_mode channelMixMode;
468	        ma_bool32 calculateLFEFromSpatialChannels;  /* When an output LFE channel is present, but no input LFE, set to true to set the output LFE to the average of all spatial channels (LR, FR, etc.). Ignored when an input LFE is present. */
469	        ma_share_mode shareMode;
470	    } capture;
471	
472	    struct
473	    {
474	        ma_wasapi_usage usage;              /* When configured, uses Avrt APIs to set the thread characteristics. */
475	        ma_bool8 noAutoConvertSRC;          /* When set to true, disables the use of AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM. */
476	        ma_bool8 noDefaultQualitySRC;       /* When set to true, disables the use of AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY. */
477	        ma_bool8 noAutoStreamRouting;       /* Disables automatic stream routing. */
478	        ma_bool8 noHardwareOffloading;      /* Disables WASAPI's hardware offloading feature. */
479	        ma_uint32 loopbackProcessID;        /* The process ID to include or exclude for loopback mode. Set to 0 to capture audio from all processes. Ignored when an explicit device ID is specified. */
480	        ma_bool8 loopbackProcessExclude;    /* When set to true, excludes the process specified by loopbackProcessID. By default, the process will be included. */
481	    } wasapi;
482	    struct
483	    {
484	        ma_bool32 noMMap;           /* Disables MMap mode. */
485	        ma_bool32 noAutoFormat;     /* Opens the ALSA device with SND_PCM_NO_AUTO_FORMAT. */
486	        ma_bool32 noAutoChannels;   /* Opens the ALSA device with SND_PCM_NO_AUTO_CHANNELS. */
487	        ma_bool32 noAutoResample;   /* Opens the ALSA device with SND_PCM_NO_AUTO_RESAMPLE. */
488	    } alsa;
489	    struct
490	    {
491	        const char* pStreamNamePlayback;
492	        const char* pStreamNameCapture;
493	    } pulse;
494	    
495	    ...;
496	    
497	} ma_device_config;
498	
499	
500	typedef struct
501	{
502	    ma_thread_priority threadPriority;
503	    void* pUserData;
504	    struct
505	    {
506	        ma_bool32 useVerboseDeviceEnumeration;
507	    } alsa;
508	    struct
509	    {
510	        const char* pApplicationName;
511	        const char* pServerName;
512	        ma_bool32 tryAutoSpawn; /* Enables autospawning of the PulseAudio daemon if necessary. */
513	    } pulse;
514	    struct
515	    {
516	        const char* pClientName;
517	        ma_bool32 tryStartServer;
518	    } jack;
519	    ...;
520	} ma_context_config;
521	
522	
523	typedef struct
524	{
525	    ma_format format;      /* Set to 0 or ma_format_unknown to use the stream's internal format. */
526	    ma_uint32 channels;    /* Set to 0 to use the stream's internal channels. */
527	    ma_uint32 sampleRate;  /* Set to 0 to use the stream's internal sample rate. */
528	    ma_encoding_format encodingFormat;
529	    ma_channel_mix_mode channelMixMode;
530	    ma_dither_mode ditherMode;
531	    ...;
532	} ma_decoder_config;
533	
534	
535	struct ma_decoder
536	{
537	    ma_decoder_read_proc onRead;
538	    ma_decoder_seek_proc onSeek;
539	    void* pUserData;
540	    ma_format  outputFormat;
541	    ma_uint32  outputChannels;
542	    ma_uint32  outputSampleRate;
543	    ...;
544	};
545	
546	
547	typedef struct
548	{
549	    ma_format formatIn;
550	    ma_format formatOut;
551	    ma_uint32 channelsIn;
552	    ma_uint32 channelsOut;
553	    ma_uint32 sampleRateIn;
554	    ma_uint32 sampleRateOut;
555	    ma_channel* pChannelMapIn;
556	    ma_channel* pChannelMapOut;
557	    ma_dither_mode ditherMode;
558	    ma_channel_mix_mode channelMixMode;
559	    float** ppChannelWeights;  /* [in][out]. Only used when mixingMode is set to ma_channel_mix_mode_custom_weights. */
560	    ma_bool32 allowDynamicSampleRate;
561	    ...;
562	} ma_data_converter_config;
563	
564	
565	typedef struct
566	{
567	    ma_format formatIn;
568	    ma_format formatOut;
569	    ma_uint32 channelsIn;
570	    ma_uint32 channelsOut;
571	    ma_uint32 sampleRateIn;
572	    ma_uint32 sampleRateOut;
573	    ma_dither_mode ditherMode;
574	    ...;
575	} ma_data_converter;
576	
577	
578	typedef struct
579	{
580	    ...;
581	} ma_allocation_callbacks;
582	
583	
584	
585	
586	typedef ma_bool32 (* ma_enum_devices_callback_proc)(ma_context* pContext, ma_device_type deviceType, const ma_device_info* pInfo, void* pUserData);
587	
588	
589	    /**** allocation / initialization / device control ****/
590	    ma_result ma_context_init(const ma_backend backends[], ma_uint32 backendCount, const ma_context_config* pConfig, ma_context* pContext);
591	    ma_result ma_context_uninit(ma_context* pContext);
592	    ma_result ma_context_enumerate_devices(ma_context* pContext, ma_enum_devices_callback_proc callback, void* pUserData);
593	    ma_result ma_context_get_devices(ma_context* pContext, ma_device_info** ppPlaybackDeviceInfos, ma_uint32* pPlaybackDeviceCount, ma_device_info** ppCaptureDeviceInfos, ma_uint32* pCaptureDeviceCount);
594	    ma_result ma_context_get_device_info(ma_context* pContext, ma_device_type deviceType, const ma_device_id* pDeviceID, ma_device_info* pDeviceInfo);
595	    ma_result ma_device_init(ma_context* pContext, const ma_device_config* pConfig, ma_device* pDevice);
596	    ma_result ma_device_init_ex(const ma_backend backends[], ma_uint32 backendCount, const ma_context_config* pContextConfig, const ma_device_config* pConfig, ma_device* pDevice);
597	    void ma_device_uninit(ma_device* pDevice);
598	    ma_result ma_device_start(ma_device* pDevice);
599	    ma_result ma_device_stop(ma_device* pDevice);
600	    ma_bool32 ma_device_is_started(ma_device* pDevice);
601	    ma_context_config ma_context_config_init(void);
602	    ma_device_config ma_device_config_init(ma_device_type deviceType);
603	    ma_decoder_config ma_decoder_config_init(ma_format outputFormat, ma_uint32 outputChannels, ma_uint32 outputSampleRate);
604	
605	    /**** decoding ****/
606	    ma_result ma_decoder_init(ma_decoder_read_proc onRead, ma_decoder_seek_proc onSeek, void* pUserData, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
607	    ma_result ma_decoder_init_memory(const void* pData, size_t dataSize, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
608	    ma_result ma_decoder_init_file(const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
609	    ma_result ma_decoder_init_file_w(const wchar_t* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder);
610	
611	    ma_result ma_decoder_uninit(ma_decoder* pDecoder);
612	    ma_result ma_decoder_read_pcm_frames(ma_decoder* pDecoder, void* pFramesOut, ma_uint64 frameCount, ma_uint64* pFramesRead);
613	    ma_result ma_decoder_seek_to_pcm_frame(ma_decoder* pDecoder, ma_uint64 frameIndex);
614	    ma_result ma_decode_file(const char* pFilePath, ma_decoder_config* pConfig, ma_uint64* pFrameCountOut, void** ppDataOut);
615	    ma_result ma_decode_memory(const void* pData, size_t dataSize, ma_decoder_config* pConfig, ma_uint64* pFrameCountOut, void** ppDataOut);
616	
617	    /**** format conversion ****/
618	    void ma_pcm_convert(void* pOut, ma_format formatOut, const void* pIn, ma_format formatIn, ma_uint64 sampleCount, ma_dither_mode ditherMode);
619	
620	    ma_uint64 ma_convert_frames(void* pOut, ma_uint64 frameCountOut, ma_format formatOut, ma_uint32 channelsOut, ma_uint32 sampleRateOut, const void* pIn, ma_uint64 frameCountIn, ma_format formatIn, ma_uint32 channelsIn, ma_uint32 sampleRateIn);
621	    ma_uint64 ma_calculate_frame_count_after_resampling(ma_uint32 sampleRateOut, ma_uint32 sampleRateIn, ma_uint64 frameCountIn);
622	
623	
624	    /**** misc ****/
625	    const char* ma_version_string(void);
626	    ma_bool32 ma_is_backend_enabled(ma_backend backend);
627	    ma_result ma_get_enabled_backends(ma_backend* pBackends, size_t backendCap, size_t* pBackendCount);
628	    ma_bool32 ma_is_loopback_supported(ma_backend backend);
629	    
630	    const char* ma_get_backend_name(ma_backend backend);
631	    const char* ma_get_format_name(ma_format format);
632	    void ma_free(void* p, const ma_allocation_callbacks* pAllocationCallbacks);
633	
634	    void init_miniaudio(void);
635	    void *malloc(size_t size);
636	    void free(void *ptr);
637	
638	    /**** callbacks ****/
639	    extern "Python" void _internal_data_callback(ma_device* pDevice, void* pOutput, const void* pInput, ma_uint32 frameCount);
640	    extern "Python" void _internal_stop_callback(ma_device* pDevice);
641	    
642	    /* decoder read and seek callbacks */
643	    extern "Python" ma_result _internal_decoder_read_callback(ma_decoder* pDecoder, void* pBufferOut, size_t bytesToRead, size_t* pBytesRead);
644	    extern "Python" ma_result _internal_decoder_seek_callback(ma_decoder* pDecoder, ma_int64 byteOffset, ma_seek_origin origin);
645	    
646	    
647	/********************** dr_flac ******************************/
648	
649	typedef   signed char           drflac_int8;
650	typedef unsigned char           drflac_uint8;
651	typedef   signed short          drflac_int16;
652	typedef unsigned short          drflac_uint16;
653	typedef   signed int            drflac_int32;
654	typedef unsigned int            drflac_uint32;
655	typedef   signed long long      drflac_int64;
656	typedef unsigned long long      drflac_uint64;
657	typedef drflac_uint8            drflac_bool8;
658	typedef drflac_uint32           drflac_bool32;
659	
660	typedef struct
661	{
662	    drflac_uint32 sampleRate;
663	    drflac_uint8 channels;
664	    drflac_uint8 bitsPerSample;
665	    drflac_uint16 maxBlockSizeInPCMFrames;
666	    drflac_uint64 totalPCMFrameCount;
667	
668	    ... ;
669	
670	} drflac;
671	
672	typedef struct {
673	    ... ;
674	} drflac_allocation_callbacks;
675	
676	
677	void drflac_close(drflac* pFlac);
678	drflac_uint64 drflac_read_pcm_frames_s32(drflac* pFlac, drflac_uint64 framesToRead, drflac_int32* pBufferOut);
679	drflac_uint64 drflac_read_pcm_frames_s16(drflac* pFlac, drflac_uint64 framesToRead, drflac_int16* pBufferOut);
680	drflac_uint64 drflac_read_pcm_frames_f32(drflac* pFlac, drflac_uint64 framesToRead, float* pBufferOut);
681	drflac_bool32 drflac_seek_to_pcm_frame(drflac* pFlac, drflac_uint64 pcmFrameIndex);
682	drflac* drflac_open_file(const char* filename, const drflac_allocation_callbacks* pAllocationCallbacks);
683	drflac* drflac_open_memory(const void* data, size_t dataSize, const drflac_allocation_callbacks* pAllocationCallbacks);
684	drflac_int32* drflac_open_file_and_read_pcm_frames_s32(const char* filename, unsigned int* channels, unsigned int* sampleRate, drflac_uint64* totalPCMFrameCount, const drflac_allocation_callbacks* pAllocationCallbacks);
685	drflac_int16* drflac_open_file_and_read_pcm_frames_s16(const char* filename, unsigned int* channels, unsigned int* sampleRate, drflac_uint64* totalPCMFrameCount, const drflac_allocation_callbacks* pAllocationCallbacks);
686	float* drflac_open_file_and_read_pcm_frames_f32(const char* filename, unsigned int* channels, unsigned int* sampleRate, drflac_uint64* totalPCMFrameCount, const drflac_allocation_callbacks* pAllocationCallbacks);
687	drflac_int32* drflac_open_memory_and_read_pcm_frames_s32(const void* data, size_t dataSize, unsigned int* channels, unsigned int* sampleRate, drflac_uint64* totalPCMFrameCount, const drflac_allocation_callbacks* pAllocationCallbacks);
688	drflac_int16* drflac_open_memory_and_read_pcm_frames_s16(const void* data, size_t dataSize, unsigned int* channels, unsigned int* sampleRate, drflac_uint64* totalPCMFrameCount, const drflac_allocation_callbacks* pAllocationCallbacks);
689	float* drflac_open_memory_and_read_pcm_frames_f32(const void* data, size_t dataSize, unsigned int* channels, unsigned int* sampleRate, drflac_uint64* totalPCMFrameCount, const drflac_allocation_callbacks* pAllocationCallbacks);
690	void drflac_free(void* p, const drflac_allocation_callbacks* pAllocationCallbacks);
691	
692	
693	/********************** dr_mp3 **********************************/
694	
695	typedef   signed char           drmp3_int8;
696	typedef unsigned char           drmp3_uint8;
697	typedef   signed short          drmp3_int16;
698	typedef unsigned short          drmp3_uint16;
699	typedef   signed int            drmp3_int32;
700	typedef unsigned int            drmp3_uint32;
701	typedef   signed long long  drmp3_int64;
702	typedef unsigned long long  drmp3_uint64;
703	typedef drmp3_uint8      drmp3_bool8;
704	typedef drmp3_uint32     drmp3_bool32;
705	
706	
707	typedef struct
708	{
709	    drmp3_uint32 channels;
710	    drmp3_uint32 sampleRate;
711	} drmp3_config;
712	
713	typedef struct
714	{
715	    drmp3_uint32 channels;
716	    drmp3_uint32 sampleRate;
717	    ...;
718	} drmp3;
719	
720	typedef struct {
721	    ...;
722	} drmp3_allocation_callbacks;
723	
724	drmp3_bool32 drmp3_init_memory(drmp3* pMP3, const void* pData, size_t dataSize, const drmp3_allocation_callbacks* pAllocationCallbacks);
725	drmp3_bool32 drmp3_init_file(drmp3* pMP3, const char* filePath, const drmp3_allocation_callbacks* pAllocationCallbacks);
726	void drmp3_uninit(drmp3* pMP3);
727	
728	drmp3_uint64 drmp3_read_pcm_frames_f32(drmp3* pMP3, drmp3_uint64 framesToRead, float* pBufferOut);
729	drmp3_uint64 drmp3_read_pcm_frames_s16(drmp3* pMP3, drmp3_uint64 framesToRead, drmp3_int16* pBufferOut);
730	drmp3_bool32 drmp3_seek_to_pcm_frame(drmp3* pMP3, drmp3_uint64 frameIndex);
731	drmp3_uint64 drmp3_get_pcm_frame_count(drmp3* pMP3);
732	drmp3_uint64 drmp3_get_mp3_frame_count(drmp3* pMP3);
733	drmp3_bool32 drmp3_get_mp3_and_pcm_frame_count(drmp3* pMP3, drmp3_uint64* pMP3FrameCount, drmp3_uint64* pPCMFrameCount);
734	
735	float* drmp3_open_memory_and_read_pcm_frames_f32(const void* pData, size_t dataSize, drmp3_config* pConfig, drmp3_uint64* pTotalFrameCount, const drmp3_allocation_callbacks* pAllocationCallbacks);
736	drmp3_int16* drmp3_open_memory_and_read_pcm_frames_s16(const void* pData, size_t dataSize, drmp3_config* pConfig, drmp3_uint64* pTotalFrameCount, const drmp3_allocation_callbacks* pAllocationCallbacks);
737	float* drmp3_open_file_and_read_pcm_frames_f32(const char* filePath, drmp3_config* pConfig, drmp3_uint64* pTotalFrameCount, const drmp3_allocation_callbacks* pAllocationCallbacks);
738	drmp3_int16* drmp3_open_file_and_read_pcm_frames_s16(const char* filePath, drmp3_config* pConfig, drmp3_uint64* pTotalFrameCount, const drmp3_allocation_callbacks* pAllocationCallbacks);
739	void drmp3_free(void* p, const drmp3_allocation_callbacks* pAllocationCallbacks);
740	
741	
742	
743	/********************** dr_wav **********************************/
744	
745	/* Common data formats. */
746	#define DR_WAVE_FORMAT_PCM          0x1
747	#define DR_WAVE_FORMAT_ADPCM        0x2
748	#define DR_WAVE_FORMAT_IEEE_FLOAT   0x3
749	#define DR_WAVE_FORMAT_ALAW         0x6
750	#define DR_WAVE_FORMAT_MULAW        0x7
751	#define DR_WAVE_FORMAT_DVI_ADPCM    0x11
752	#define DR_WAVE_FORMAT_EXTENSIBLE   0xFFFE
753	
754	typedef   signed char           drwav_int8;
755	typedef unsigned char           drwav_uint8;
756	typedef   signed short          drwav_int16;
757	typedef unsigned short          drwav_uint16;
758	typedef   signed int            drwav_int32;
759	typedef unsigned int            drwav_uint32;
760	typedef   signed long long  drwav_int64;
761	typedef unsigned long long  drwav_uint64;
762	typedef drwav_uint8             drwav_bool8;
763	typedef drwav_uint32            drwav_bool32;
764	
765	
766	typedef struct
767	{
768	    drwav_uint32 sampleRate;
769	    drwav_uint16 channels;
770	    drwav_uint16 bitsPerSample;
771	    drwav_uint16 translatedFormatTag;
772	    drwav_uint64 totalPCMFrameCount;
773	
774	    ...;
775	
776	} drwav;
777	
778	typedef enum
779	{
780	    drwav_container_riff,
781	    drwav_container_w64
782	} drwav_container;
783	
784	typedef struct
785	{
786	    drwav_container container;  /* RIFF, W64. */
787	    drwav_uint32 format;        /* DR_WAVE_FORMAT_* */
788	    drwav_uint32 channels;
789	    drwav_uint32 sampleRate;
790	    drwav_uint32 bitsPerSample;
791	} drwav_data_format;
792	
793	typedef struct {
794	    ...;
795	} drwav_allocation_callbacks;
796	
797	drwav_bool32 drwav_init_file(drwav* pWav, const char* filename, const drwav_allocation_callbacks* pAllocationCallbacks);
798	drwav_bool32 drwav_init_memory(drwav* pWav, const void* data, size_t dataSize, const drwav_allocation_callbacks* pAllocationCallbacks);
799	drwav_int32 drwav_uninit(drwav* pWav);
800	void drwav_free(void* p, const drwav_allocation_callbacks* pAllocationCallbacks);
801	
802	drwav_bool32 drwav_init_file_write(drwav* pWav, const char* filename, const drwav_data_format* pFormat, const drwav_allocation_callbacks* pAllocationCallbacks);
803	drwav_bool32 drwav_init_file_write_sequential(drwav* pWav, const char* filename, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, const drwav_allocation_callbacks* pAllocationCallbacks);
804	drwav_bool32 drwav_init_file_write_sequential_pcm_frames(drwav* pWav, const char* filename, const drwav_data_format* pFormat, drwav_uint64 totalPCMFrameCount, const drwav_allocation_callbacks* pAllocationCallbacks);
805	drwav_bool32 drwav_init_memory_write(drwav* pWav, void** ppData, size_t* pDataSize, const drwav_data_format* pFormat, const drwav_allocation_callbacks* pAllocationCallbacks);
806	drwav_bool32 drwav_init_memory_write_sequential(drwav* pWav, void** ppData, size_t* pDataSize, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, const drwav_allocation_callbacks* pAllocationCallbacks);
807	drwav_bool32 drwav_init_memory_write_sequential_pcm_frames(drwav* pWav, void** ppData, size_t* pDataSize, const drwav_data_format* pFormat, drwav_uint64 totalPCMFrameCount, const drwav_allocation_callbacks* pAllocationCallbacks);
808	
809	
810	drwav_uint64 drwav_read_pcm_frames(drwav* pWav, drwav_uint64 framesToRead, void* pBufferOut);
811	drwav_uint64 drwav_write_pcm_frames(drwav* pWav, drwav_uint64 framesToWrite, const void* pData);
812	drwav_bool32 drwav_seek_to_pcm_frame(drwav* pWav, drwav_uint64 targetFrameIndex);
813	drwav_uint64 drwav_read_pcm_frames_s16(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut);
814	drwav_uint64 drwav_read_pcm_frames_f32(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut);
815	drwav_uint64 drwav_read_pcm_frames_s32(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut);
816	
817	drwav_int16* drwav_open_file_and_read_pcm_frames_s16(const char* filename, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks);
818	float* drwav_open_file_and_read_pcm_frames_f32(const char* filename, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks);
819	drwav_int32* drwav_open_file_and_read_pcm_frames_s32(const char* filename, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks);
820	
821	drwav_int16* drwav_open_memory_and_read_pcm_frames_s16(const void* data, size_t dataSize, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks);
822	float* drwav_open_memory_and_read_pcm_frames_f32(const void* data, size_t dataSize, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks);
823	drwav_int32* drwav_open_memory_and_read_pcm_frames_s32(const void* data, size_t dataSize, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks);
824	
825	"""
826	
827	# TODO: expose and support filter API,  expose and support waveform and noise generation APIs.
828	
829	
830	ffibuilder = FFI()

--------------------------------------------------
>> Issue: [B818:urlopen] urllib.request.urlopen
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/miniaudio-1.61/miniaudio-1.61/miniaudio.py:1159
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b818_urlopen.html
1158	        req = urllib.request.Request(url, headers={"icy-metadata": "1"})
1159	        with urllib.request.urlopen(req, context=ssl_context) as result:
1160	            self.station_genre = result.headers["icy-genre"]

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/miniaudio-1.61/miniaudio-1.61/miniaudio.py:1164
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
1163	            self.audio_format = self.determine_audio_format(stream_format)
1164	        self._download_thread = threading.Thread(target=self._download_stream, daemon=True)
1165	        self._download_thread.start()

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/miniaudio-1.61/miniaudio-1.61/miniaudio.py:1194
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
1193	        while len(b) < size:
1194	            b += fileobject.read(size)
1195	        return b

--------------------------------------------------
>> Issue: [B818:urlopen] urllib.request.urlopen
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/miniaudio-1.61/miniaudio-1.61/miniaudio.py:1199
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b818_urlopen.html
1198	        req = urllib.request.Request(self.url, headers={"icy-metadata": "1"})
1199	        with urllib.request.urlopen(req) as result:
1200	            self.station_genre = result.headers["icy-genre"]

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/miniaudio-1.61/miniaudio-1.61/miniaudio.py:1235
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
1234	                            return
1235	                    chunk = result.read(self.BLOCK_SIZE)
1236	                    with self._buffer_lock:

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/miniaudio-1.61/miniaudio-1.61/miniaudio.py:1324
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
1323	        try:
1324	            data = source.read(num_bytes)
1325	            ffi.memmove(output, data, len(data))

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/miniaudio-1.61/miniaudio-1.61/miniaudio.py:1682
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1681	        else:
1682	            lib.drwav_init_memory_write(pwav, data, datasize, fmt, ffi.NULL)
1683	        lib.drwav_uninit(pwav)

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/miniaudio-1.61/miniaudio-1.61/setup.py:10
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
9	miniaudio_path = os.path.abspath(".")  # to make sure the compiler can find the required include files
10	PKG_VERSION = re.search(r'^__version__\s*=\s*"(.+)"', open("miniaudio.py", "rt").read(), re.MULTILINE).groups()[0]
11	

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/miniaudio-1.61/miniaudio-1.61/tests/test_miniaudio.py:303
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
302	    assert meta == {"StreamTitle": "title"}
303	    meta = ic.parse_metadata("StreamTitle='title';StreamUrl='http://something.url'")
304	    assert meta == {"StreamTitle": "title", "StreamUrl": "http://something.url"}

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/miniaudio-1.61/miniaudio-1.61/tests/test_miniaudio.py:304
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
303	    meta = ic.parse_metadata("StreamTitle='title';StreamUrl='http://something.url'")
304	    assert meta == {"StreamTitle": "title", "StreamUrl": "http://something.url"}
305	    meta = ic.parse_metadata("StreamTitle='title';StreamUrl='http://something.url';")

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/miniaudio-1.61/miniaudio-1.61/tests/test_miniaudio.py:305
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
304	    assert meta == {"StreamTitle": "title", "StreamUrl": "http://something.url"}
305	    meta = ic.parse_metadata("StreamTitle='title';StreamUrl='http://something.url';")
306	    assert meta == {"StreamTitle": "title", "StreamUrl": "http://something.url"}

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/miniaudio-1.61/miniaudio-1.61/tests/test_miniaudio.py:306
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
305	    meta = ic.parse_metadata("StreamTitle='title';StreamUrl='http://something.url';")
306	    assert meta == {"StreamTitle": "title", "StreamUrl": "http://something.url"}
307	    meta = ic.parse_metadata("StreamTitle='title'with'quotes';StreamUrl='http://something.url';")

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/miniaudio-1.61/miniaudio-1.61/tests/test_miniaudio.py:307
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
306	    assert meta == {"StreamTitle": "title", "StreamUrl": "http://something.url"}
307	    meta = ic.parse_metadata("StreamTitle='title'with'quotes';StreamUrl='http://something.url';")
308	    assert meta == {"StreamTitle": "title'with'quotes", "StreamUrl": "http://something.url"}

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/miniaudio-1.61/miniaudio-1.61/tests/test_miniaudio.py:308
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
307	    meta = ic.parse_metadata("StreamTitle='title'with'quotes';StreamUrl='http://something.url';")
308	    assert meta == {"StreamTitle": "title'with'quotes", "StreamUrl": "http://something.url"}
309	    meta = ic.parse_metadata("StreamTitle=TitlewithHTMLcodes&#39;and&#39;stuff;StreamUrl='http://something.url';")

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/miniaudio-1.61/miniaudio-1.61/tests/test_miniaudio.py:309
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
308	    assert meta == {"StreamTitle": "title'with'quotes", "StreamUrl": "http://something.url"}
309	    meta = ic.parse_metadata("StreamTitle=TitlewithHTMLcodes&#39;and&#39;stuff;StreamUrl='http://something.url';")
310	    assert meta == {"StreamTitle": "TitlewithHTMLcodes'and'stuff", "StreamUrl": "http://something.url"}

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/miniaudio-1.61/miniaudio-1.61/tests/test_miniaudio.py:310
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
309	    meta = ic.parse_metadata("StreamTitle=TitlewithHTMLcodes&#39;and&#39;stuff;StreamUrl='http://something.url';")
310	    assert meta == {"StreamTitle": "TitlewithHTMLcodes'and'stuff", "StreamUrl": "http://something.url"}

--------------------------------------------------

Code scanned:
	Total lines of code: 2557
	Total lines skipped (#nosec): 0

Run metrics:
	Total issues (by severity):
		Undefined: 0.0
		Low: 0.0
		Medium: 9.0
		High: 8.0
	Total issues (by confidence):
		Undefined: 0.0
		Low: 0.0
		Medium: 17.0
		High: 0.0
Files skipped (0):
