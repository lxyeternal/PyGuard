Run started:2025-04-12 18:06:03.179268

Test results:
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/pdqhash-0.2.7/pdqhash-0.2.7/tests/test_compute.py:152
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
151	def test_basic(expected, image_name, threshold):
152	    image = cv2.imread(os.path.join('tests', 'images', image_name))
153	    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

--------------------------------------------------
>> Issue: [B824:url_found] url_found
   Severity: Medium   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/pdqhash-0.2.7/pdqhash-0.2.7/versioneer.py:474
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b824_url_found.html
473	
474	LONG_VERSION_PY['git'] = r'''
475	# This file helps to compute a version number in source trees obtained from
476	# git-archive tarball (such as those provided by githubs download-from-tag
477	# feature). Distribution tarballs (built by setup.py sdist) and build
478	# directories (produced by setup.py build) will contain a much shorter file
479	# that just contains the computed version number.
480	
481	# This file is released into the public domain.
482	# Generated by versioneer-0.28
483	# https://github.com/python-versioneer/python-versioneer
484	
485	"""Git implementation of _version.py."""
486	
487	import errno
488	import os
489	import re
490	import subprocess
491	import sys
492	from typing import Callable, Dict
493	import functools
494	
495	
496	def get_keywords():
497	    """Get the keywords needed to look up the version information."""
498	    # these strings will be replaced by git during git-archive.
499	    # setup.py/versioneer.py will grep for the variable names, so they must
500	    # each be defined on a line of their own. _version.py will just call
501	    # get_keywords().
502	    git_refnames = "%(DOLLAR)sFormat:%%d%(DOLLAR)s"
503	    git_full = "%(DOLLAR)sFormat:%%H%(DOLLAR)s"
504	    git_date = "%(DOLLAR)sFormat:%%ci%(DOLLAR)s"
505	    keywords = {"refnames": git_refnames, "full": git_full, "date": git_date}
506	    return keywords
507	
508	
509	class VersioneerConfig:
510	    """Container for Versioneer configuration parameters."""
511	
512	
513	def get_config():
514	    """Create, populate and return the VersioneerConfig() object."""
515	    # these strings are filled in when 'setup.py versioneer' creates
516	    # _version.py
517	    cfg = VersioneerConfig()
518	    cfg.VCS = "git"
519	    cfg.style = "%(STYLE)s"
520	    cfg.tag_prefix = "%(TAG_PREFIX)s"
521	    cfg.parentdir_prefix = "%(PARENTDIR_PREFIX)s"
522	    cfg.versionfile_source = "%(VERSIONFILE_SOURCE)s"
523	    cfg.verbose = False
524	    return cfg
525	
526	
527	class NotThisMethod(Exception):
528	    """Exception raised if a method is not valid for the current scenario."""
529	
530	
531	LONG_VERSION_PY: Dict[str, str] = {}
532	HANDLERS: Dict[str, Dict[str, Callable]] = {}
533	
534	
535	def register_vcs_handler(vcs, method):  # decorator
536	    """Create decorator to mark a method as the handler of a VCS."""
537	    def decorate(f):
538	        """Store f in HANDLERS[vcs][method]."""
539	        if vcs not in HANDLERS:
540	            HANDLERS[vcs] = {}
541	        HANDLERS[vcs][method] = f
542	        return f
543	    return decorate
544	
545	
546	def run_command(commands, args, cwd=None, verbose=False, hide_stderr=False,
547	                env=None):
548	    """Call the given command(s)."""
549	    assert isinstance(commands, list)
550	    process = None
551	
552	    popen_kwargs = {}
553	    if sys.platform == "win32":
554	        # This hides the console window if pythonw.exe is used
555	        startupinfo = subprocess.STARTUPINFO()
556	        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
557	        popen_kwargs["startupinfo"] = startupinfo
558	
559	    for command in commands:
560	        try:
561	            dispcmd = str([command] + args)
562	            # remember shell=False, so use git.cmd on windows, not just git
563	            process = subprocess.Popen([command] + args, cwd=cwd, env=env,
564	                                       stdout=subprocess.PIPE,
565	                                       stderr=(subprocess.PIPE if hide_stderr
566	                                               else None), **popen_kwargs)
567	            break
568	        except OSError:
569	            e = sys.exc_info()[1]
570	            if e.errno == errno.ENOENT:
571	                continue
572	            if verbose:
573	                print("unable to run %%s" %% dispcmd)
574	                print(e)
575	            return None, None
576	    else:
577	        if verbose:
578	            print("unable to find command, tried %%s" %% (commands,))
579	        return None, None
580	    stdout = process.communicate()[0].strip().decode()
581	    if process.returncode != 0:
582	        if verbose:
583	            print("unable to run %%s (error)" %% dispcmd)
584	            print("stdout was %%s" %% stdout)
585	        return None, process.returncode
586	    return stdout, process.returncode
587	
588	
589	def versions_from_parentdir(parentdir_prefix, root, verbose):
590	    """Try to determine the version from the parent directory name.
591	
592	    Source tarballs conventionally unpack into a directory that includes both
593	    the project name and a version string. We will also support searching up
594	    two directory levels for an appropriately named parent directory
595	    """
596	    rootdirs = []
597	
598	    for _ in range(3):
599	        dirname = os.path.basename(root)
600	        if dirname.startswith(parentdir_prefix):
601	            return {"version": dirname[len(parentdir_prefix):],
602	                    "full-revisionid": None,
603	                    "dirty": False, "error": None, "date": None}
604	        rootdirs.append(root)
605	        root = os.path.dirname(root)  # up a level
606	
607	    if verbose:
608	        print("Tried directories %%s but none started with prefix %%s" %%
609	              (str(rootdirs), parentdir_prefix))
610	    raise NotThisMethod("rootdir doesn't start with parentdir_prefix")
611	
612	
613	@register_vcs_handler("git", "get_keywords")
614	def git_get_keywords(versionfile_abs):
615	    """Extract version information from the given file."""
616	    # the code embedded in _version.py can just fetch the value of these
617	    # keywords. When used from setup.py, we don't want to import _version.py,
618	    # so we do it with a regexp instead. This function is not used from
619	    # _version.py.
620	    keywords = {}
621	    try:
622	        with open(versionfile_abs, "r") as fobj:
623	            for line in fobj:
624	                if line.strip().startswith("git_refnames ="):
625	                    mo = re.search(r'=\s*"(.*)"', line)
626	                    if mo:
627	                        keywords["refnames"] = mo.group(1)
628	                if line.strip().startswith("git_full ="):
629	                    mo = re.search(r'=\s*"(.*)"', line)
630	                    if mo:
631	                        keywords["full"] = mo.group(1)
632	                if line.strip().startswith("git_date ="):
633	                    mo = re.search(r'=\s*"(.*)"', line)
634	                    if mo:
635	                        keywords["date"] = mo.group(1)
636	    except OSError:
637	        pass
638	    return keywords
639	
640	
641	@register_vcs_handler("git", "keywords")
642	def git_versions_from_keywords(keywords, tag_prefix, verbose):
643	    """Get version information from git keywords."""
644	    if "refnames" not in keywords:
645	        raise NotThisMethod("Short version file found")
646	    date = keywords.get("date")
647	    if date is not None:
648	        # Use only the last line.  Previous lines may contain GPG signature
649	        # information.
650	        date = date.splitlines()[-1]
651	
652	        # git-2.2.0 added "%%cI", which expands to an ISO-8601 -compliant
653	        # datestamp. However we prefer "%%ci" (which expands to an "ISO-8601
654	        # -like" string, which we must then edit to make compliant), because
655	        # it's been around since git-1.5.3, and it's too difficult to
656	        # discover which version we're using, or to work around using an
657	        # older one.
658	        date = date.strip().replace(" ", "T", 1).replace(" ", "", 1)
659	    refnames = keywords["refnames"].strip()
660	    if refnames.startswith("$Format"):
661	        if verbose:
662	            print("keywords are unexpanded, not using")
663	        raise NotThisMethod("unexpanded keywords, not a git-archive tarball")
664	    refs = {r.strip() for r in refnames.strip("()").split(",")}
665	    # starting in git-1.8.3, tags are listed as "tag: foo-1.0" instead of
666	    # just "foo-1.0". If we see a "tag: " prefix, prefer those.
667	    TAG = "tag: "
668	    tags = {r[len(TAG):] for r in refs if r.startswith(TAG)}
669	    if not tags:
670	        # Either we're using git < 1.8.3, or there really are no tags. We use
671	        # a heuristic: assume all version tags have a digit. The old git %%d
672	        # expansion behaves like git log --decorate=short and strips out the
673	        # refs/heads/ and refs/tags/ prefixes that would let us distinguish
674	        # between branches and tags. By ignoring refnames without digits, we
675	        # filter out many common branch names like "release" and
676	        # "stabilization", as well as "HEAD" and "master".
677	        tags = {r for r in refs if re.search(r'\d', r)}
678	        if verbose:
679	            print("discarding '%%s', no digits" %% ",".join(refs - tags))
680	    if verbose:
681	        print("likely tags: %%s" %% ",".join(sorted(tags)))
682	    for ref in sorted(tags):
683	        # sorting will prefer e.g. "2.0" over "2.0rc1"
684	        if ref.startswith(tag_prefix):
685	            r = ref[len(tag_prefix):]
686	            # Filter out refs that exactly match prefix or that don't start
687	            # with a number once the prefix is stripped (mostly a concern
688	            # when prefix is '')
689	            if not re.match(r'\d', r):
690	                continue
691	            if verbose:
692	                print("picking %%s" %% r)
693	            return {"version": r,
694	                    "full-revisionid": keywords["full"].strip(),
695	                    "dirty": False, "error": None,
696	                    "date": date}
697	    # no suitable tags, so version is "0+unknown", but full hex is still there
698	    if verbose:
699	        print("no suitable tags, using unknown + full revision id")
700	    return {"version": "0+unknown",
701	            "full-revisionid": keywords["full"].strip(),
702	            "dirty": False, "error": "no suitable tags", "date": None}
703	
704	
705	@register_vcs_handler("git", "pieces_from_vcs")
706	def git_pieces_from_vcs(tag_prefix, root, verbose, runner=run_command):
707	    """Get version from 'git describe' in the root of the source tree.
708	
709	    This only gets called if the git-archive 'subst' keywords were *not*
710	    expanded, and _version.py hasn't already been rewritten with a short
711	    version string, meaning we're inside a checked out source tree.
712	    """
713	    GITS = ["git"]
714	    if sys.platform == "win32":
715	        GITS = ["git.cmd", "git.exe"]
716	
717	    # GIT_DIR can interfere with correct operation of Versioneer.
718	    # It may be intended to be passed to the Versioneer-versioned project,
719	    # but that should not change where we get our version from.
720	    env = os.environ.copy()
721	    env.pop("GIT_DIR", None)
722	    runner = functools.partial(runner, env=env)
723	
724	    _, rc = runner(GITS, ["rev-parse", "--git-dir"], cwd=root,
725	                   hide_stderr=not verbose)
726	    if rc != 0:
727	        if verbose:
728	            print("Directory %%s not under git control" %% root)
729	        raise NotThisMethod("'git rev-parse --git-dir' returned error")
730	
731	    # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]
732	    # if there isn't one, this yields HEX[-dirty] (no NUM)
733	    describe_out, rc = runner(GITS, [
734	        "describe", "--tags", "--dirty", "--always", "--long",
735	        "--match", f"{tag_prefix}[[:digit:]]*"
736	    ], cwd=root)
737	    # --long was added in git-1.5.5
738	    if describe_out is None:
739	        raise NotThisMethod("'git describe' failed")
740	    describe_out = describe_out.strip()
741	    full_out, rc = runner(GITS, ["rev-parse", "HEAD"], cwd=root)
742	    if full_out is None:
743	        raise NotThisMethod("'git rev-parse' failed")
744	    full_out = full_out.strip()
745	
746	    pieces = {}
747	    pieces["long"] = full_out
748	    pieces["short"] = full_out[:7]  # maybe improved later
749	    pieces["error"] = None
750	
751	    branch_name, rc = runner(GITS, ["rev-parse", "--abbrev-ref", "HEAD"],
752	                             cwd=root)
753	    # --abbrev-ref was added in git-1.6.3
754	    if rc != 0 or branch_name is None:
755	        raise NotThisMethod("'git rev-parse --abbrev-ref' returned error")
756	    branch_name = branch_name.strip()
757	
758	    if branch_name == "HEAD":
759	        # If we aren't exactly on a branch, pick a branch which represents
760	        # the current commit. If all else fails, we are on a branchless
761	        # commit.
762	        branches, rc = runner(GITS, ["branch", "--contains"], cwd=root)
763	        # --contains was added in git-1.5.4
764	        if rc != 0 or branches is None:
765	            raise NotThisMethod("'git branch --contains' returned error")
766	        branches = branches.split("\n")
767	
768	        # Remove the first line if we're running detached
769	        if "(" in branches[0]:
770	            branches.pop(0)
771	
772	        # Strip off the leading "* " from the list of branches.
773	        branches = [branch[2:] for branch in branches]
774	        if "master" in branches:
775	            branch_name = "master"
776	        elif not branches:
777	            branch_name = None
778	        else:
779	            # Pick the first branch that is returned. Good or bad.
780	            branch_name = branches[0]
781	
782	    pieces["branch"] = branch_name
783	
784	    # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]
785	    # TAG might have hyphens.
786	    git_describe = describe_out
787	
788	    # look for -dirty suffix
789	    dirty = git_describe.endswith("-dirty")
790	    pieces["dirty"] = dirty
791	    if dirty:
792	        git_describe = git_describe[:git_describe.rindex("-dirty")]
793	
794	    # now we have TAG-NUM-gHEX or HEX
795	
796	    if "-" in git_describe:
797	        # TAG-NUM-gHEX
798	        mo = re.search(r'^(.+)-(\d+)-g([0-9a-f]+)$', git_describe)
799	        if not mo:
800	            # unparsable. Maybe git-describe is misbehaving?
801	            pieces["error"] = ("unable to parse git-describe output: '%%s'"
802	                               %% describe_out)
803	            return pieces
804	
805	        # tag
806	        full_tag = mo.group(1)
807	        if not full_tag.startswith(tag_prefix):
808	            if verbose:
809	                fmt = "tag '%%s' doesn't start with prefix '%%s'"
810	                print(fmt %% (full_tag, tag_prefix))
811	            pieces["error"] = ("tag '%%s' doesn't start with prefix '%%s'"
812	                               %% (full_tag, tag_prefix))
813	            return pieces
814	        pieces["closest-tag"] = full_tag[len(tag_prefix):]
815	
816	        # distance: number of commits since tag
817	        pieces["distance"] = int(mo.group(2))
818	
819	        # commit: short hex revision ID
820	        pieces["short"] = mo.group(3)
821	
822	    else:
823	        # HEX: no tags
824	        pieces["closest-tag"] = None
825	        out, rc = runner(GITS, ["rev-list", "HEAD", "--left-right"], cwd=root)
826	        pieces["distance"] = len(out.split())  # total number of commits
827	
828	    # commit date: see ISO-8601 comment in git_versions_from_keywords()
829	    date = runner(GITS, ["show", "-s", "--format=%%ci", "HEAD"], cwd=root)[0].strip()
830	    # Use only the last line.  Previous lines may contain GPG signature
831	    # information.
832	    date = date.splitlines()[-1]
833	    pieces["date"] = date.strip().replace(" ", "T", 1).replace(" ", "", 1)
834	
835	    return pieces
836	
837	
838	def plus_or_dot(pieces):
839	    """Return a + if we don't already have one, else return a ."""
840	    if "+" in pieces.get("closest-tag", ""):
841	        return "."
842	    return "+"
843	
844	
845	def render_pep440(pieces):
846	    """Build up version string, with post-release "local version identifier".
847	
848	    Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you
849	    get a tagged build and then dirty it, you'll get TAG+0.gHEX.dirty
850	
851	    Exceptions:
852	    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]
853	    """
854	    if pieces["closest-tag"]:
855	        rendered = pieces["closest-tag"]
856	        if pieces["distance"] or pieces["dirty"]:
857	            rendered += plus_or_dot(pieces)
858	            rendered += "%%d.g%%s" %% (pieces["distance"], pieces["short"])
859	            if pieces["dirty"]:
860	                rendered += ".dirty"
861	    else:
862	        # exception #1
863	        rendered = "0+untagged.%%d.g%%s" %% (pieces["distance"],
864	                                          pieces["short"])
865	        if pieces["dirty"]:
866	            rendered += ".dirty"
867	    return rendered
868	
869	
870	def render_pep440_branch(pieces):
871	    """TAG[[.dev0]+DISTANCE.gHEX[.dirty]] .
872	
873	    The ".dev0" means not master branch. Note that .dev0 sorts backwards
874	    (a feature branch will appear "older" than the master branch).
875	
876	    Exceptions:
877	    1: no tags. 0[.dev0]+untagged.DISTANCE.gHEX[.dirty]
878	    """
879	    if pieces["closest-tag"]:
880	        rendered = pieces["closest-tag"]
881	        if pieces["distance"] or pieces["dirty"]:
882	            if pieces["branch"] != "master":
883	                rendered += ".dev0"
884	            rendered += plus_or_dot(pieces)
885	            rendered += "%%d.g%%s" %% (pieces["distance"], pieces["short"])
886	            if pieces["dirty"]:
887	                rendered += ".dirty"
888	    else:
889	        # exception #1
890	        rendered = "0"
891	        if pieces["branch"] != "master":
892	            rendered += ".dev0"
893	        rendered += "+untagged.%%d.g%%s" %% (pieces["distance"],
894	                                          pieces["short"])
895	        if pieces["dirty"]:
896	            rendered += ".dirty"
897	    return rendered
898	
899	
900	def pep440_split_post(ver):
901	    """Split pep440 version string at the post-release segment.
902	
903	    Returns the release segments before the post-release and the
904	    post-release version number (or -1 if no post-release segment is present).
905	    """
906	    vc = str.split(ver, ".post")
907	    return vc[0], int(vc[1] or 0) if len(vc) == 2 else None
908	
909	
910	def render_pep440_pre(pieces):
911	    """TAG[.postN.devDISTANCE] -- No -dirty.
912	
913	    Exceptions:
914	    1: no tags. 0.post0.devDISTANCE
915	    """
916	    if pieces["closest-tag"]:
917	        if pieces["distance"]:
918	            # update the post release segment
919	            tag_version, post_version = pep440_split_post(pieces["closest-tag"])
920	            rendered = tag_version
921	            if post_version is not None:
922	                rendered += ".post%%d.dev%%d" %% (post_version + 1, pieces["distance"])
923	            else:
924	                rendered += ".post0.dev%%d" %% (pieces["distance"])
925	        else:
926	            # no commits, use the tag as the version
927	            rendered = pieces["closest-tag"]
928	    else:
929	        # exception #1
930	        rendered = "0.post0.dev%%d" %% pieces["distance"]
931	    return rendered
932	
933	
934	def render_pep440_post(pieces):
935	    """TAG[.postDISTANCE[.dev0]+gHEX] .
936	
937	    The ".dev0" means dirty. Note that .dev0 sorts backwards
938	    (a dirty tree will appear "older" than the corresponding clean one),
939	    but you shouldn't be releasing software with -dirty anyways.
940	
941	    Exceptions:
942	    1: no tags. 0.postDISTANCE[.dev0]
943	    """
944	    if pieces["closest-tag"]:
945	        rendered = pieces["closest-tag"]
946	        if pieces["distance"] or pieces["dirty"]:
947	            rendered += ".post%%d" %% pieces["distance"]
948	            if pieces["dirty"]:
949	                rendered += ".dev0"
950	            rendered += plus_or_dot(pieces)
951	            rendered += "g%%s" %% pieces["short"]
952	    else:
953	        # exception #1
954	        rendered = "0.post%%d" %% pieces["distance"]
955	        if pieces["dirty"]:
956	            rendered += ".dev0"
957	        rendered += "+g%%s" %% pieces["short"]
958	    return rendered
959	
960	
961	def render_pep440_post_branch(pieces):
962	    """TAG[.postDISTANCE[.dev0]+gHEX[.dirty]] .
963	
964	    The ".dev0" means not master branch.
965	
966	    Exceptions:
967	    1: no tags. 0.postDISTANCE[.dev0]+gHEX[.dirty]
968	    """
969	    if pieces["closest-tag"]:
970	        rendered = pieces["closest-tag"]
971	        if pieces["distance"] or pieces["dirty"]:
972	            rendered += ".post%%d" %% pieces["distance"]
973	            if pieces["branch"] != "master":
974	                rendered += ".dev0"
975	            rendered += plus_or_dot(pieces)
976	            rendered += "g%%s" %% pieces["short"]
977	            if pieces["dirty"]:
978	                rendered += ".dirty"
979	    else:
980	        # exception #1
981	        rendered = "0.post%%d" %% pieces["distance"]
982	        if pieces["branch"] != "master":
983	            rendered += ".dev0"
984	        rendered += "+g%%s" %% pieces["short"]
985	        if pieces["dirty"]:
986	            rendered += ".dirty"
987	    return rendered
988	
989	
990	def render_pep440_old(pieces):
991	    """TAG[.postDISTANCE[.dev0]] .
992	
993	    The ".dev0" means dirty.
994	
995	    Exceptions:
996	    1: no tags. 0.postDISTANCE[.dev0]
997	    """
998	    if pieces["closest-tag"]:
999	        rendered = pieces["closest-tag"]
1000	        if pieces["distance"] or pieces["dirty"]:
1001	            rendered += ".post%%d" %% pieces["distance"]
1002	            if pieces["dirty"]:
1003	                rendered += ".dev0"
1004	    else:
1005	        # exception #1
1006	        rendered = "0.post%%d" %% pieces["distance"]
1007	        if pieces["dirty"]:
1008	            rendered += ".dev0"
1009	    return rendered
1010	
1011	
1012	def render_git_describe(pieces):
1013	    """TAG[-DISTANCE-gHEX][-dirty].
1014	
1015	    Like 'git describe --tags --dirty --always'.
1016	
1017	    Exceptions:
1018	    1: no tags. HEX[-dirty]  (note: no 'g' prefix)
1019	    """
1020	    if pieces["closest-tag"]:
1021	        rendered = pieces["closest-tag"]
1022	        if pieces["distance"]:
1023	            rendered += "-%%d-g%%s" %% (pieces["distance"], pieces["short"])
1024	    else:
1025	        # exception #1
1026	        rendered = pieces["short"]
1027	    if pieces["dirty"]:
1028	        rendered += "-dirty"
1029	    return rendered
1030	
1031	
1032	def render_git_describe_long(pieces):
1033	    """TAG-DISTANCE-gHEX[-dirty].
1034	
1035	    Like 'git describe --tags --dirty --always -long'.
1036	    The distance/hash is unconditional.
1037	
1038	    Exceptions:
1039	    1: no tags. HEX[-dirty]  (note: no 'g' prefix)
1040	    """
1041	    if pieces["closest-tag"]:
1042	        rendered = pieces["closest-tag"]
1043	        rendered += "-%%d-g%%s" %% (pieces["distance"], pieces["short"])
1044	    else:
1045	        # exception #1
1046	        rendered = pieces["short"]
1047	    if pieces["dirty"]:
1048	        rendered += "-dirty"
1049	    return rendered
1050	
1051	
1052	def render(pieces, style):
1053	    """Render the given version pieces into the requested style."""
1054	    if pieces["error"]:
1055	        return {"version": "unknown",
1056	                "full-revisionid": pieces.get("long"),
1057	                "dirty": None,
1058	                "error": pieces["error"],
1059	                "date": None}
1060	
1061	    if not style or style == "default":
1062	        style = "pep440"  # the default
1063	
1064	    if style == "pep440":
1065	        rendered = render_pep440(pieces)
1066	    elif style == "pep440-branch":
1067	        rendered = render_pep440_branch(pieces)
1068	    elif style == "pep440-pre":
1069	        rendered = render_pep440_pre(pieces)
1070	    elif style == "pep440-post":
1071	        rendered = render_pep440_post(pieces)
1072	    elif style == "pep440-post-branch":
1073	        rendered = render_pep440_post_branch(pieces)
1074	    elif style == "pep440-old":
1075	        rendered = render_pep440_old(pieces)
1076	    elif style == "git-describe":
1077	        rendered = render_git_describe(pieces)
1078	    elif style == "git-describe-long":
1079	        rendered = render_git_describe_long(pieces)
1080	    else:
1081	        raise ValueError("unknown style '%%s'" %% style)
1082	
1083	    return {"version": rendered, "full-revisionid": pieces["long"],
1084	            "dirty": pieces["dirty"], "error": None,
1085	            "date": pieces.get("date")}
1086	
1087	
1088	def get_versions():
1089	    """Get version information or return default if unable to do so."""
1090	    # I am in _version.py, which lives at ROOT/VERSIONFILE_SOURCE. If we have
1091	    # __file__, we can work backwards from there to the root. Some
1092	    # py2exe/bbfreeze/non-CPython implementations don't do __file__, in which
1093	    # case we can only use expanded keywords.
1094	
1095	    cfg = get_config()
1096	    verbose = cfg.verbose
1097	
1098	    try:
1099	        return git_versions_from_keywords(get_keywords(), cfg.tag_prefix,
1100	                                          verbose)
1101	    except NotThisMethod:
1102	        pass
1103	
1104	    try:
1105	        root = os.path.realpath(__file__)
1106	        # versionfile_source is the relative path from the top of the source
1107	        # tree (where the .git directory might live) to this file. Invert
1108	        # this to find the root from __file__.
1109	        for _ in cfg.versionfile_source.split('/'):
1110	            root = os.path.dirname(root)
1111	    except NameError:
1112	        return {"version": "0+unknown", "full-revisionid": None,
1113	                "dirty": None,
1114	                "error": "unable to find root of source tree",
1115	                "date": None}
1116	
1117	    try:
1118	        pieces = git_pieces_from_vcs(cfg.tag_prefix, root, verbose)
1119	        return render(pieces, cfg.style)
1120	    except NotThisMethod:
1121	        pass
1122	
1123	    try:
1124	        if cfg.parentdir_prefix:
1125	            return versions_from_parentdir(cfg.parentdir_prefix, root, verbose)
1126	    except NotThisMethod:
1127	        pass
1128	
1129	    return {"version": "0+unknown", "full-revisionid": None,
1130	            "dirty": None,
1131	            "error": "unable to compute version", "date": None}
1132	'''
1133	
1134	
1135	@register_vcs_handler("git", "get_keywords")
1136	def git_get_keywords(versionfile_abs):

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/pdqhash-0.2.7/pdqhash-0.2.7/versioneer.py:1393
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1392	        with open(".gitattributes", "a+") as fobj:
1393	            fobj.write(f"{versionfile_source} export-subst\n")
1394	        files.append(".gitattributes")

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/pdqhash-0.2.7/pdqhash-0.2.7/versioneer.py:1444
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
1443	        with open(filename) as f:
1444	            contents = f.read()
1445	    except OSError:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/pdqhash-0.2.7/pdqhash-0.2.7/versioneer.py:1463
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1462	    with open(filename, "w") as f:
1463	        f.write(SHORT_VERSION_PY % contents)
1464	

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/pdqhash-0.2.7/pdqhash-0.2.7/versioneer.py:1947
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1946	                    LONG = LONG_VERSION_PY[cfg.VCS]
1947	                    f.write(LONG %
1948	                            {"DOLLAR": "$",
1949	                             "STYLE": cfg.style,
1950	                             "TAG_PREFIX": cfg.tag_prefix,
1951	                             "PARENTDIR_PREFIX": cfg.parentdir_prefix,
1952	                             "VERSIONFILE_SOURCE": cfg.versionfile_source,
1953	                             })

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/pdqhash-0.2.7/pdqhash-0.2.7/versioneer.py:1976
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
1975	                    LONG = LONG_VERSION_PY[cfg.VCS]
1976	                    f.write(LONG %
1977	                            {"DOLLAR": "$",
1978	                             "STYLE": cfg.style,
1979	                             "TAG_PREFIX": cfg.tag_prefix,
1980	                             "PARENTDIR_PREFIX": cfg.parentdir_prefix,
1981	                             "VERSIONFILE_SOURCE": cfg.versionfile_source,
1982	                             })

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/pdqhash-0.2.7/pdqhash-0.2.7/versioneer.py:2018
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2017	            with open(manifest_filename, 'w') as fobj:
2018	                fobj.write('\n'.join(normalized))
2019	

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/pdqhash-0.2.7/pdqhash-0.2.7/versioneer.py:2113
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2112	            with open(os.path.join(root, "setup.cfg"), "a") as f:
2113	                f.write(SAMPLE_CONFIG)
2114	        print(CONFIG_ERROR, file=sys.stderr)

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/pdqhash-0.2.7/pdqhash-0.2.7/versioneer.py:2120
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2119	        LONG = LONG_VERSION_PY[cfg.VCS]
2120	        f.write(LONG % {"DOLLAR": "$",
2121	                        "STYLE": cfg.style,
2122	                        "TAG_PREFIX": cfg.tag_prefix,
2123	                        "PARENTDIR_PREFIX": cfg.parentdir_prefix,
2124	                        "VERSIONFILE_SOURCE": cfg.versionfile_source,
2125	                        })

--------------------------------------------------
>> Issue: [B814:read] os.read
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/pdqhash-0.2.7/pdqhash-0.2.7/versioneer.py:2132
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b814_read.html
2131	            with open(ipy, "r") as f:
2132	                old = f.read()
2133	        except OSError:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/pdqhash-0.2.7/pdqhash-0.2.7/versioneer.py:2140
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2139	            with open(ipy, "w") as f:
2140	                f.write(old.replace(OLD_SNIPPET, snippet))
2141	        elif snippet not in old:

--------------------------------------------------
>> Issue: [B815:write] os.write
   Severity: High   Confidence: Medium
   Location: /home/blue/PyPIAgent/Dataset/study/unzip_benign/pdqhash-0.2.7/pdqhash-0.2.7/versioneer.py:2144
   More Info: https://bandit.readthedocs.io/en/latest/plugins/b815_write.html
2143	            with open(ipy, "a") as f:
2144	                f.write(snippet)
2145	        else:

--------------------------------------------------

Code scanned:
	Total lines of code: 1795
	Total lines skipped (#nosec): 0

Run metrics:
	Total issues (by severity):
		Undefined: 0.0
		Low: 0.0
		Medium: 1.0
		High: 12.0
	Total issues (by confidence):
		Undefined: 0.0
		Low: 0.0
		Medium: 13.0
		High: 0.0
Files skipped (0):
